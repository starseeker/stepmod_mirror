(*
 $Id: mim.exp,v 1.12 2009/12/21 13:36:40 liutkuviene Exp $
 ISO TC184/SC4/WG12 N6858 - ISO/TS 10303-1514 Advanced boundary representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5273
*)

SCHEMA Advanced_boundary_representation_mim;

USE FROM Topologically_bounded_surface_mim; --ISO/TS 10303-1511:2004
USE FROM Solid_model_mim;
USE FROM aic_advanced_brep; --ISO/TS 10303-514

END_SCHEMA;

(*

DRAFT mim Short Form for 14306 Open JT ed2 STEP Brep Model
KAH - 06/18/2013
TRT - 06/18/2013 removed redundant USE FROMs
TRT - 6/24/2013 resolved all open domain issues.
KAH - 7/25/2013 simplified the presentation to only use shape appearance layers
TRT - 8/19/2013 added USE FROM only to pick up mechanical_design_geometric_presentation_representation
commented out presented_item_select_iso_14306
also no shape_aspect in this schema!

In schema Fill_area_style_mim
made this update
SCHEMA Fill_area_style_mim;
..
call
USE FROM Value_with_unit_mim;
instead of
USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
...

*)

SCHEMA Ap243_boundary_representation_for_iso_14306_open_jt_mim;

(*
-- Nominal minimal product structure implicitly defined
*)



-- Faceted and Elementary Boundary Representation Models
USE FROM Elementary_boundary_representation_mim;
USE FROM Faceted_boundary_representation_mim;
USE FROM Advanced_boundary_representation_mim;
USE FROM Shape_appearance_layers_mim;
USE FROM Shape_property_assignment_mim;

USE FROM aic_mechanical_design_geometric_presentation (
     mechanical_design_geometric_presentation_representation);

--pick up annotation_symbol_occurrence_item explicitly

USE FROM presentation_definition_schema(
    annotation_symbol_occurrence_item,
    annotation_symbol,
    defined_symbol); 

  TYPE groupable_item_iso_14306 = SELECT BASED_ON groupable_item WITH 
    (geometric_representation_item,
     shape_representation_relationship, 
     mapped_item,
     styled_item, 
     topological_representation_item);
  END_TYPE; 
  
(*
  TYPE presented_item_select_iso_14306 = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON presented_item_select WITH 
    (product_definition,
    product_definition_formation);
  END_TYPE;
*)
  
END_SCHEMA;


(*
   $Id: mim.exp,v 1.18 2012/11/09 21:40:58 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N8251 - ISO/TS 10303-1001 Appearance assignment - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6861
*) 


SCHEMA Appearance_assignment_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (context_dependent_over_riding_styled_item,
   fill_area_style_colour,
   invisibility,
   over_riding_styled_item,
   presentation_style_assignment,
   presentation_style_by_context,
   externally_defined_style,
   style_context_select,
   styled_item);

USE FROM presentation_resource_schema   -- ISO 10303-46
   (planar_box);

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 

  TYPE appearance_representation_identification_item = SELECT BASED_ON identification_item WITH 
    (representation);
  END_TYPE; 

  SUBTYPE_CONSTRAINT aa_representation_item_subtypes FOR representation_item;
    ONEOF (mapped_item,
      styled_item);
  END_SUBTYPE_CONSTRAINT;

  RULE styled_curve FOR (styled_item);
    WHERE
      WR1: SIZEOF( QUERY( si <* styled_item | ('APPEARANCE_ASSIGNMENT_MIM.CURVE' IN TYPEOF (si.item)) AND (SIZEOF (QUERY (psa <* si.styles | (SIZEOF (QUERY (cs <* psa.styles | ('APPEARANCE_ASSIGNMENT_MIM.CURVE_STYLE' IN TYPEOF (cs)) )) > 0) )) <> 1) )) = 0;
  END_RULE; 

END_SCHEMA; 
(*
$Id: mim.exp,v 1.17 2012/10/11 23:20:18 thomasrthurman Exp $
ISO TC184/SC4/WG12 N7730 - ISO/TS 10303-1026 Assembly structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6112
*) 


SCHEMA Assembly_structure_mim;

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_reference_mim; -- ISO/TS 10303-1738

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

USE FROM product_structure_schema   -- ISO 10303-44
  (assembly_component_usage,
   next_assembly_usage_occurrence,
   promissory_usage_occurrence,
   quantified_assembly_component_usage,
   specified_higher_usage_occurrence,
   multi_level_reference_designator); 


END_SCHEMA;  -- Assembly_structure_mim




(*
 $Id: mim.exp,v 1.4 2012/11/09 21:40:58 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N8254 - ISO/TS 10303-1801 B_spline_geometry - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7191
*)

SCHEMA B_spline_geometry_mim;

USE FROM Basic_geometry_mim; -- ISO/TS 10303-1652


USE FROM geometry_schema    -- ISO 10303-42
(b_spline_curve,
 b_spline_surface,
 bezier_curve,
 bezier_surface,
 quasi_uniform_curve,
 quasi_uniform_surface,
 rational_b_spline_curve,
 rational_b_spline_surface, 
 uniform_curve,
 uniform_surface);

END_SCHEMA;
(*
   $Id: mim.exp,v 1.15 2012/10/11 05:49:08 liutkuviene Exp $
   ISO TC184/SC4/WG12 N7826 - ISO/TS 10303-1651 Basic curve - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7389
*)


SCHEMA Basic_curve_mim;
	USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128

	USE FROM geometry_schema
		(circle,
		trimmed_curve,
		line,
		composite_curve,
		composite_curve_segment,
		pcurve,
		surface_curve);
	
TYPE bc_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (trimmed_curve);
END_TYPE;
	
END_SCHEMA;
(*
  $Id: mim.exp,v 1.9 2012/11/09 21:40:57 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N8257 - ISO/TS 10303-1323 Basic geometric topology - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6873
*)

SCHEMA Basic_geometric_topology_mim;

USE FROM Basic_geometry_mim;  -- ISO/TS 10303-1652

USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005

USE FROM topology_schema  -- ISO 10303-42
      (edge_curve,
      face_surface,
      poly_loop,
      vertex_point); 

END_SCHEMA;

(*
$Id: mim.exp,v 1.20 2012/10/11 05:49:04 liutkuviene Exp $
ISO TC184/SC4/WG12 N7829 - ISO/TS 10303-1652 Basic geometry - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7194
*) 


SCHEMA Basic_geometry_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM geometry_schema   -- ISO 10303-42
  (bounded_curve,
  bounded_surface,
  circle,
  conic,
  conical_surface,
  curve,
  cylindrical_surface,
  ellipse,
  hyperbola,
  line,
  oriented_surface,
  parabola,
  plane,
  point_on_curve,
  point_on_surface,
  surface,
  surface_of_linear_extrusion,
  surface_of_revolution,
  swept_surface,
  toroidal_surface); 


END_SCHEMA;  -- Basic_geometry_mim

(*
$Id: mim.exp,v 1.4 2006/03/24 18:09:46 thendrix Exp $
ISO TC184/SC4/WG12 N4243 - ISO/TS 10303-1002 Colour - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N655
*)

SCHEMA Colour_mim;
  USE FROM external_reference_schema -- ISO 10303-41
      (externally_defined_item);
  USE FROM presentation_resource_schema -- ISO 10303-46
      (colour,
       colour_rgb,
       colour_specification,
       draughting_pre_defined_colour,
       pre_defined_colour);
  USE FROM support_resource_schema -- ISO 10303-41
      (identifier);

 ENTITY externally_defined_colour
  SUBTYPE OF (colour_specification,externally_defined_item);
END_ENTITY; -- externally_defined_colour

END_SCHEMA;

(*
	$Id: mim.exp,v 1.12 2012/10/06 20:09:56 liutkuviene Exp $
	ISO TC184/SC4/WG12 N7673 - ISO/TS 10303-1003 Curve appearance - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N7059
*) 


SCHEMA Curve_appearance_mim;

USE FROM Styled_curve_mim; -- ISO/TS 10303-1749

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (curve_style,
   curve_style_font,
   draughting_pre_defined_curve_font,
   marker_select,
   marker_type,
   point_style,
   pre_defined_curve_font,
   pre_defined_marker); 

USE FROM presentation_definition_schema   -- ISO 10303-46
  (externally_defined_symbol,
   pre_defined_symbol); 

USE FROM presentation_resource_schema   -- ISO 10303-46
  (externally_defined_text_font);


USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 


  TYPE terminator = SELECT
    (externally_defined_terminator_symbol, 
     pre_defined_terminator_symbol, 
     user_defined_terminator_symbol);
  END_TYPE; 

  ENTITY externally_defined_marker
    SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
  END_ENTITY;

  ENTITY externally_defined_terminator_symbol
    SUBTYPE OF (externally_defined_symbol);
  END_ENTITY;

  ENTITY pre_defined_point_marker_symbol
    SUBTYPE OF (pre_defined_marker, pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['asterisk','circle','dot','plus','square','triangle','x'];
  END_ENTITY;

  ENTITY pre_defined_terminator_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['blanked arrow', 'blanked box', 'blanked dot', 'blanked triangle', 'dimension origin', 'filled arrow', 'filled box', 'filled dot', 'integral symbol', 'open arrow', 'slash', 'unfilled arrow', 'unfilled triangle', 'filled triangle'];
  END_ENTITY;

  ENTITY user_defined_marker
    SUBTYPE OF (mapped_item, pre_defined_marker);
  END_ENTITY;

  ENTITY user_defined_terminator_symbol
    SUBTYPE OF (mapped_item, pre_defined_symbol);
  END_ENTITY;

  ENTITY vector_style
    SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
  END_ENTITY;

END_SCHEMA;  
(*
$Id: mim.exp,v 1.29 2013/10/01 16:32:54 thomasrthurman Exp $
ISO TC184/SC4/WG12 N8006 - ISO/TS 10303-1004 Elemental geometric shape - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7109
*)

   
SCHEMA Elemental_geometric_shape_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006
USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005

USE FROM geometry_schema   -- ISO 10303-42
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   cartesian_point,
   cartesian_transformation_operator_2d,
   cartesian_transformation_operator_3d,
   direction,
   geometric_representation_context,
   geometric_representation_item); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (item_defined_transformation,
   mapped_item,
   representation_map,
   value_representation_item); 


TYPE representation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (shape_representation);
END_TYPE; 

END_SCHEMA;  -- Elemental_geometric_shape_mim
(*
$Id: mim.exp,v 1.7 2012/10/11 05:49:05 liutkuviene Exp $
ISO TC184/SC4/WG12 N8009 - ISO/TS 10303-1005 Elemental topology - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6897
*)
   
SCHEMA Elemental_topology_mim;
  USE FROM Foundation_representation_mim; 
  USE FROM topology_schema -- ISO 10303-42
      (connected_edge_set,
       connected_face_set,
       edge,
       edge_loop,
       face,
       face_bound,
       face_outer_bound,
       loop,
       oriented_edge,
       path,
       topological_representation_item,
       vertex,
       vertex_loop);
END_SCHEMA;

(* Last update -  15 Aug 2001 *)
(*
   $Id: mim.exp,v 1.2 2008/09/15 12:09:10 liutkuviene Exp $
   ISO TC184/SC4/WG12 N5541 - ISO/TS 10303-1329 Elementary boundary representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4718
*)

SCHEMA Elementary_boundary_representation_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/CD-TS 10303-1004

USE FROM aic_elementary_brep; -- ISO 10303-513

END_SCHEMA;
(*
   $Id: mim.exp,v 1.12 2012/11/09 21:40:57 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N8264 - ISO/TS 10303-1667 Extended basic geometry - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6620
*)

SCHEMA Extended_basic_geometry_mim;

USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
USE FROM Geometric_model_relationship_mim;
	
USE FROM representation_schema(
--  definitional_representation_relationship,
  mapped_item,
  representation_item_relationship,
  representation_map);

USE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation_relationship);
  	 		
USE FROM geometry_schema(
  vector);	

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set);

  ENTITY geometric_model_element_relationship
    SUBTYPE OF (geometric_representation_item, representation_item_relationship);
      SELF\representation_item_relationship.relating_representation_item : geometric_representation_item;
      SELF\representation_item_relationship.related_representation_item: geometric_representation_item;
    UNIQUE
      UR1: SELF\representation_item_relationship.relating_representation_item, 
        SELF\representation_item_relationship.related_representation_item;
    WHERE
      WR1: SELF\representation_item_relationship.relating_representation_item :<>: 
        SELF\representation_item_relationship.related_representation_item;
  END_ENTITY; 

END_SCHEMA;
(*
 $Id: mim.exp,v 1.12 2004/10/21 17:58:55 darla Exp $
 ISO TC184/SC4/WG12 N1208 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
*)


SCHEMA External_item_identification_assignment_mim;

USE FROM management_resources_schema   	-- ISO 10303-41
  (external_identification_assignment); 

USE FROM support_resource_schema		-- ISO 10303-41
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

END_SCHEMA;
(*
 $Id: mim.exp,v 1.4 2012/10/06 20:09:56 liutkuviene Exp $
 ISO TC184/SC4/WG12 N7679 - ISO/TS 10303-1033 External model - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1229
*)

SCHEMA External_model_mim;
  
USE FROM Elemental_geometric_shape_mim; -- ISO 10303-1004
  
USE FROM File_identification_mim;

USE FROM product_property_definition_schema
  (property_definition);

USE FROM product_property_representation_schema
  (property_definition_representation);

END_SCHEMA;

(*
 $Id: mim.exp,v 1.8 2004/10/21 18:05:26 darla Exp $
 ISO TC184/SC4/WG12 N1286 - ISO/TS 10303-1512 Faceted boundary representation - EXPRESS MIM
*)


SCHEMA Faceted_boundary_representation_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_faceted_brep;

END_SCHEMA;

(*
$Id: mim.exp,v 1.18 2011/10/12 08:46:47 philsp Exp $
ISO TC184/SC4/WG12 N7112 - ISO/TS 10303-1127 File identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1205
*)

SCHEMA File_identification_mim;

USE FROM document_schema   -- ISO 10303-41
  (document,
   document_representation_type); 

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 


TYPE file_identification_item = SELECT BASED_ON identification_item WITH 
   (document_file);
END_TYPE; 

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH 
   (document_file);
END_TYPE; 

ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital', 'physical'])) = 1;
END_ENTITY;

END_SCHEMA;  -- File_identification_mim
(*
   $Id: mim.exp,v 1.18 2010/01/21 12:59:21 lothartklein Exp $
   ISO TC184/SC4/WG12 N6900 - ISO/TS 10303-1672 Fill area style - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5393
*)

SCHEMA Fill_area_style_mim;
USE FROM Basic_curve_mim;	-- ISO/TS 10303-1651
USE FROM Curve_appearance_mim;	-- ISO/TS 10303-1003
USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
USE FROM Extended_basic_geometry_mim;	-- ISO/TS 10303-1667	

USE FROM presentation_appearance_schema( -- ISO/TS 10303-46	
  externally_defined_hatch_style,
  externally_defined_tile_style,
  fill_area_style_colour,
  fill_area_style_hatching,
  fill_area_style_tiles,
  fill_area_style_tile_symbol_with_style);
	
END_SCHEMA;



(* 
$Id: mim.exp,v 1.19 2009/12/21 09:20:21 liutkuviene Exp $ 
ISO TC184/SC4/WG12 N6903 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4349
*) 


SCHEMA Foundation_representation_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select); 

USE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   uncertainty_measure_with_unit); 

USE FROM Support_resource_mim;

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Foundation_representation_mim
(*
$Id: mim.exp,v 1.9 2010/01/05 09:07:35 liutkuviene Exp $
ISO TC184/SC4/WG12 N7068 - ISO/TS 10303-1007 General surface appearance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5399
*)

SCHEMA General_surface_appearance_mim;

USE FROM Curve_appearance_mim; -- ISO/TS 10303-1003

USE FROM presentation_appearance_schema	
 ( fill_area_style_colour, 
   fill_area_style_tile_curve_with_style, 
   fill_area_style_tile_coloured_region, 
   fill_area_style_tile_symbol_with_style, 
   pre_defined_surface_side_style,
   pre_defined_tile, 
   externally_defined_tile, 
   surface_side,
   surface_side_style,
   surface_style_boundary,
   surface_style_control_grid,
   surface_style_rendering,
   surface_style_fill_area,
   surface_style_parameter_line,
   surface_style_segmentation_curve,
   surface_style_silhouette,
   surface_style_usage,
   u_direction_count,
   v_direction_count);

END_SCHEMA;
(*
   $Id: mim.exp,v 1.7 2012/10/11 05:49:26 liutkuviene Exp $
   ISO TC184/SC4/WG12 N8024 - ISO/TS 10303-1403 Geometric model relationship - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6906
*)   
SCHEMA Geometric_model_relationship_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM representation_schema(
  definitional_representation_relationship
);

USE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation_relationship);


END_SCHEMA;
(*
 $Id: mim.exp,v 1.8 2006/03/24 18:45:20 thendrix Exp $
 ISO TC184/SC4/WG12 N4276 - ISO/TS 10303-1113 Group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3246
*) 


SCHEMA Group_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Basic_attribute_schema(
	id_attribute, 
	id_attribute_select); -- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;

END_SCHEMA;  -- Group_mim

(*
$Id: mim.exp,v 1.13 2010/06/09 22:02:45 philsp Exp $
ISO TC184/SC4/WG12 N7115 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2915
*)

SCHEMA Identification_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment); 


TYPE identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

END_SCHEMA;  -- Identification_assignment_mim
(*
 $Id: mim.exp,v 1.10 2004/10/22 14:15:40 darla Exp $
 ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
*)
SCHEMA Independent_property_mim;

USE FROM product_property_definition_schema
(general_property,
 general_property_relationship);

END_SCHEMA;

(*
	$Id: mim.exp,v 1.7 2012/10/07 18:07:43 thomasrthurman Exp $
	ISO TC184/SC4/WG12 N5414 - ISO/TS 10303-1008 Layer assignment - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N4751
*) 

SCHEMA Layer_assignment_mim; 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Group_mim;	-- ISO/TS 10303-1113

USE FROM presentation_organization_schema   -- ISO 10303-46
  (presentation_layer_assignment); 

USE FROM geometry_schema(geometric_representation_item); -- ISO 10303-42

USE FROM topology_schema(topological_representation_item); -- ISO 10303-42


  ENTITY rep_item_group
    SUBTYPE OF (group, representation_item);
    WHERE
      WR1: SIZEOF(USEDIN(SELF,'PRESENTATION_ORGANIZATION_SCHEMA.' + 'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) > 0;
      WR2: SIZEOF(QUERY(r <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION.' + 'ITEMS') | r.name = 'group representation')) > 0;
      WR3: SIZEOF(QUERY(ga <* USEDIN(SELF,'MANAGEMENT_RESOURCES_SCHEMA.' + 'GROUP_ASSIGNMENT.' + 'ASSIGNED_GROUP') | ga.role.name <> 'group membership')) = 0;
      WR4: SIZEOF(['GEOMETRY_SCHEMA.' + 'GEOMETRIC_REPRESENTATION_ITEM', 
           'TOPOLOGY_SCHEMA.' + 'TOPOLOGICAL_REPRESENTATION_ITEM', 
           'REPRESENTATION_SCHEMA.' + 'MAPPED_ITEM',
           'PRESENTATION_APPEARANCE_SCHEMA.' + 'STYLED_ITEM'] * TYPEOF(SELF)) = 1;
  END_ENTITY;

END_SCHEMA; 
(*
$Id: mim.exp,v 1.13 2009/08/11 07:57:32 robbod Exp $
ISO TC184/SC4/WG12 N6066 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2926
*) 


SCHEMA Product_identification_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product); 


END_SCHEMA;  -- Product_identification_mim
(* 
 $Id: mim.exp,v 1.6 2004/01/13 10:15:26 robbod Exp $
 ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1106
*) 


SCHEMA Product_version_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation); 


END_SCHEMA;  -- Product_version_mim

(*
 $Id: mim.exp,v 1.16 2006/03/24 19:03:52 thendrix Exp $
 ISO TC184/SC4/WG12 N4352 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2928
*) 


SCHEMA Product_view_definition_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (product_definition_context); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (name_attribute,
   name_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_context_association); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_view_definition_mim
(*
   $Id: mim.exp,v 1.2 2012/10/11 05:49:13 liutkuviene Exp $
   ISO TC184/SC4/WG12 N7769 - ISO/TS 10303-1823 Product view definition reference - EXPRESS MIM*)

SCHEMA Product_view_definition_reference_mim;

	USE FROM Support_resource_mim; -- ISO/TS 10303-1800
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	USE FROM Product_view_definition_mim;	-- ISO/TS 10303-1019
	USE FROM External_reference_schema
		(externally_defined_item,
		external_source);
	USE FROM product_definition_schema (
		generic_product_definition_reference,
		product_definition_reference,
		product_definition_reference_with_local_representation);
	
TYPE pie_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (generic_product_definition_reference);
END_TYPE; 

END_SCHEMA;
(*
 $Id: mim.exp,v 1.6 2012/09/22 18:15:05 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1142 - ISO/TS 10303-1041 Product view definition relationship - EXPRESS MIM
*)

SCHEMA Product_view_definition_relationship_mim;

USE FROM Product_view_definition_mim; -- ISO 10303-1019
USE FROM Product_view_definition_reference_mim; -- ISO/TS 10303-1738

USE FROM product_definition_schema -- ISO 10303-41
  (product_definition_relationship);

USE FROM product_structure_schema -- ISO 10303-44
  (product_definition_usage);
END_SCHEMA;
(*
 $Id: mim.exp,v 1.15 2012/10/11 05:49:17 liutkuviene Exp $
 ISO TC184/SC4/WG12 N8042 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7458
*) 


SCHEMA Property_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property_association,
   property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 


END_SCHEMA;  -- Property_assignment_mim
(*
	$Id: mim.exp,v 1.11 2009/12/23 13:28:43 liutkuviene Exp $
	ISO TC184/SC4/WG12 N6927 - ISO/TS 10303-1009 Shape appearance layers - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N6689
*)

SCHEMA Shape_appearance_layers_mim; 

USE FROM Appearance_assignment_mim; -- ISO/CD-TS 10303-1001

USE FROM Fill_area_style_mim; -- ISO/TS 10303-1672

USE FROM General_surface_appearance_mim; -- ISO/CD-TS 10303-1007

USE FROM Layer_assignment_mim; -- ISO/CD-TS 10303-1008

END_SCHEMA; 
(*
	$Id: mim.exp,v 1.32 2012/10/11 05:49:03 liutkuviene Exp $
	ISO TC184/SC4/WG12 N8051 - ISO/TS 10303-1032 Shape property assignment - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N7467
*)


SCHEMA Shape_property_assignment_mim;

USE FROM Property_assignment_mim;
(*REFERENCE FROM*) USE FROM Assembly_structure_mim; -- ISO/TS 10303-1026

(*REFERENCE FROM*) USE FROM External_model_mim; -- ISO/TS 10303-1033

USE FROM Geometric_model_relationship_mim; -- ISO/TS 10303-1403 
USE FROM Product_view_definition_relationship_mim; -- ISO/TS 10303-1041

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition,
   product_definition_shape,
   shape_aspect,
   shape_aspect_relationship); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage,
   chain_based_item_identified_representation_usage,
   shape_definition_representation); 

TYPE geometric_model_item = EXTENSIBLE GENERIC_ENTITY SELECT (
    geometric_representation_item);
END_TYPE; 

TYPE geometric_item_specific_usage_select = SELECT
   (shape_aspect,
    shape_aspect_relationship);
END_TYPE; 

TYPE shape_model = EXTENSIBLE GENERIC_ENTITY SELECT 
   (shape_representation);
END_TYPE;   

ENTITY geometric_item_specific_usage
  SUBTYPE OF(item_identified_representation_usage);
    SELF\item_identified_representation_usage.definition          : geometric_item_specific_usage_select;
    SELF\item_identified_representation_usage.used_representation : shape_model;
    SELF\item_identified_representation_usage.identified_item     : geometric_model_item;
  UNIQUE
   UR1 : definition;
END_ENTITY;

ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage, 
    chain_based_item_identified_representation_usage);
END_ENTITY;

END_SCHEMA; 
(*
   $Id: mim.exp,v 1.2 2009/12/23 13:29:05 liutkuviene Exp $
   ISO TC184/SC4/WG12 N6933 - ISO/TS 10303-1793 Solid model - EXPRESS MIM
*)
SCHEMA Solid_model_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/TS 10303-1004
USE FROM geometric_model_schema(solid_model);

END_SCHEMA;
(*
   $Id: mim.exp,v 1.26 2012/10/11 05:49:04 liutkuviene Exp $
   ISO TC184/SC4/WG12 N8057 - ISO/TS 10303-1749 Styled curve - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7470
*)

SCHEMA Styled_curve_mim;
USE FROM Colour_mim;    -- ISO/TS 10303-1002

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM external_reference_schema(pre_defined_item); -- ISO 10303-41

USE FROM representation_schema
		(mapped_item,
		parametric_representation_context);
		
USE FROM presentation_appearance_schema
		(curve_style,
		curve_style_font,
		curve_style_font_pattern,
		curve_style_font_and_scaling,
		draughting_pre_defined_curve_font,
		externally_defined_curve_font,
		fill_area_style_colour,		
		pre_defined_curve_font,
		presentation_style_assignment,
		styled_item);
				
  ENTITY solid_curve_font
    SUBTYPE OF (pre_defined_curve_font);
  END_ENTITY; 

  ENTITY user_defined_curve_font
    SUBTYPE OF (curve_style_font, mapped_item);
  END_ENTITY;
	
END_SCHEMA;


(*
   $Id: mim.exp,v 1.4 2012/10/11 05:49:06 liutkuviene Exp $
   ISO TC184/SC4/WG12 N8060 - ISO/TS 10303-1800 Support resource - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N7473
*)
SCHEMA Support_resource_mim;
	USE FROM support_resource_schema;
END_SCHEMA;
(*
 $Id: mim.exp,v 1.11 2012/10/11 05:49:06 liutkuviene Exp $
 ISO TC184/SC4/WG12 N7841 - ISO/TS 10303-1511 Topologically bounded surface - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7200
*)

SCHEMA Topologically_bounded_surface_mim;

USE FROM Basic_geometric_topology_mim;
USE FROM B_spline_geometry_mim;
USE FROM aic_topologically_bounded_surface;

END_SCHEMA;

(*
 $Id: mim.exp,v 1.15 2012/10/11 05:49:06 liutkuviene Exp $
 ISO TC184/SC4/WG12 N7844 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N7239
*)

SCHEMA Value_with_unit_mim;

USE FROM measure_schema;

USE FROM representation_schema
 (uncertainty_measure_with_unit);

END_SCHEMA;
(*
   $Id: mim.exp,v 1.27 2013/02/20 00:35:48 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N8245 - ISO/TS 10303-1753 Value with unit extension - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5534
*)


SCHEMA Value_with_unit_extension_mim;
	USE FROM Value_with_unit_mim;	-- ISO/TS 10303-1054
	USE FROM iso13584_generic_expressions_schema
		(environment,
		variable_semantics);

    USE FROM mathematical_functions_schema
       (complex_number_literal_polar);  -- ISO 10303-50
       
	REFERENCE FROM measure_schema(derive_dimensional_exponents); -- ISO/TS 10303-41 

ENTITY expression_conversion_based_unit
  SUBTYPE OF (context_dependent_unit, variable_semantics); 
INVERSE
  associated_variable_environment: environment FOR semantics; 
END_ENTITY;

ENTITY dielectric_constant_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY loss_tangent_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY thermal_resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'VALUE_WITH_UNIT_EXTENSION_MIM.THERMAL_RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermal_resistance_unit
  SUBTYPE OF (derived_unit);
 WHERE
   WR1: derive_dimensional_exponents(SELF) = 
        dimensional_exponents ( -1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0 );
END_ENTITY;

END_SCHEMA;


(*
$Id: action_schema.exp,v 1.20 2014/03/04 00:30:24 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Action schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Action schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA action_schema '{iso standard 10303 part(41) version(7) object(1) action_schema(1)}';
  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value, 
    id_attribute, 
    id_attribute_select,
    name_attribute,
    name_attribute_select);
    
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  
  TYPE as_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  TYPE as_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    action);
  END_TYPE;
  TYPE as_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  
  TYPE supported_item = SELECT (action_directive, action, action_method);
  END_TYPE;

  ENTITY action;
    name : label;
    description : OPTIONAL text;
    chosen_method : action_method;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_directive;
    name : label;
    description : OPTIONAL text;
    analysis : text;
    comment : text;
    requests : SET [1:?] OF versioned_action_request;
  END_ENTITY;

  ENTITY action_method;
    name : label;
    description : OPTIONAL text;
    consequence : text;
    purpose : text;
  END_ENTITY;

  ENTITY action_method_relationship;
    name : label;
    description : OPTIONAL text;
    relating_method : action_method;
    related_method : action_method;
  END_ENTITY;

  ENTITY action_relationship;
    name : label;
    description : OPTIONAL text;
    relating_action : action;
    related_action : action;
  END_ENTITY;

  ENTITY action_request_solution;
    method : action_method;
    request : versioned_action_request;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_request_status;
    status : label;
    assigned_request : versioned_action_request;
  END_ENTITY;

  ENTITY action_resource;
    name : label;
    description : OPTIONAL text;
    usage : SET [1:?] OF supported_item;
    kind : action_resource_type;
  END_ENTITY;

  ENTITY action_resource_relationship;
    name : label;
    description : OPTIONAL text;
    relating_resource : action_resource;
    related_resource : action_resource;
  END_ENTITY;

  ENTITY action_resource_type;
    name : label;
  END_ENTITY;

  ENTITY action_status;
    status : label;
    assigned_action : executed_action;
  END_ENTITY;

  ENTITY directed_action
    SUBTYPE OF (executed_action);
    directive : action_directive;
  END_ENTITY;

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY;

  ENTITY versioned_action_request;
    id : identifier;
    version : OPTIONAL label;
    purpose : text;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY versioned_action_request_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_versioned_action_request : versioned_action_request;
    related_versioned_action_request : versioned_action_request;
  END_ENTITY;

  FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: aic_advanced_brep.exp,v 1.3 2014/03/04 00:30:24 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N413

EXPRESS Source:
ISO 10303-514 ed1 Advanced boundary representation - Aic advanced brep

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-514 ed1 Advanced boundary representation - Aic advanced brep
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA aic_advanced_brep '{iso standard 10303 part(514) version(1) object(1) aic_advanced_brep(1)}';
  
USE FROM aic_topologically_bounded_surface;
 USE FROM geometry_schema ( cartesian_transformation_operator_3d);
 USE FROM geometric_model_schema ( manifold_solid_brep, brep_with_voids);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, oriented_closed_shell);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY advanced_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.FACETED_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM', 'AIC_ADVANCED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* SELF.items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('AIC_ADVANCED_BREP.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_ADVANCED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 
(*

ISO 10303 TC184/SC4/WG12 N476

EXPRESS Source:
ISO 10303-513 ed1 Elementary boundary representation - Aic elementary brep

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-513 ed1 Elementary boundary representation - Aic elementary brep
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA aic_elementary_brep '{iso standard 10303 part(513) version(1) object(1) aic_elementary_brep(1)}';
  USE FROM geometry_schema(axis2_placement_3d,
                           cartesian_point,
                           cartesian_transformation_operator_3d,
                           circle,
                           conical_surface,
                           cylindrical_surface,
                           degenerate_toroidal_surface,
                           direction,
                           ellipse,
                           hyperbola,
                           line,
                           parabola,
                           plane,
                           polyline,
                           spherical_surface,
                           toroidal_surface,
                           vector);
  USE FROM geometric_model_schema(manifold_solid_brep,
                                  brep_with_voids);

REFERENCE FROM geometric_model_schema(msb_shells);

USE FROM topology_schema(closed_shell,
                           connected_face_set,
                           edge_curve,
                           edge_loop,
                           face_bound,
                           face_outer_bound,
                           face_surface,
                           oriented_closed_shell,
                           oriented_edge,
                           path,
                           vertex_loop,
                           vertex_point);


  USE FROM representation_schema(mapped_item);

  USE FROM product_property_representation_schema(shape_representation);

 ENTITY elementary_brep_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
                'AIC_ELEMENTARY_BREP.FACETED_BREP',
                'AIC_ELEMENTARY_BREP.MAPPED_ITEM',
                'AIC_ELEMENTARY_BREP.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
         'AIC_ELEMENTARY_BREP.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('AIC_ELEMENTARY_BREP.FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('AIC_ELEMENTARY_BREP.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('AIC_ELEMENTARY_BREP.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_ELEMENTARY_BREP.LINE',
                         'AIC_ELEMENTARY_BREP.CONIC',
                         'AIC_ELEMENTARY_BREP.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR8 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_ELEMENTARY_BREP.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR9 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AIC_ELEMENTARY_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
   WR10 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'AIC_ELEMENTARY_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR11 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_ELEMENTARY_BREP.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('AIC_ELEMENTARY_BREP.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR12 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
            'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
            NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
              NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
           NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                ('AIC_ELEMENTARY_BREP.CARTESIAN_POINT' IN
                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
 END_ENTITY;

END_SCHEMA; -- end AIC_ELEMENTARY_BREP SCHEMA

(*
$Id: aic_faceted_brep.exp,v 1.3 2014/03/04 00:30:26 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8370

EXPRESS Source:
ISO 10303-512 ed1 Faceted boundary representation - Aic faceted brep

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-512 ed1 Faceted boundary representation - Aic faceted brep
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA aic_faceted_brep '{iso standard 10303 part(512) version(1) object(1) aic_faceted_brep(1)}';
  
USE FROM geometry_schema ( axis2_placement_3d, cartesian_point, cartesian_transformation_operator_3d, elementary_surface, plane);
 USE FROM geometric_model_schema ( brep_with_voids, faceted_brep, manifold_solid_brep);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, face_bound, face_outer_bound, face_surface, oriented_closed_shell, poly_loop);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY faceted_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* items| NOT ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM', 'AIC_FACETED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* items| ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('AIC_FACETED_BREP.FACE_SURFACE' IN TYPEOF (fcs)) AND (('AIC_FACETED_BREP.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('AIC_FACETED_BREP.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( 
QUERY ( bnds <* fcs.bounds| ('AIC_FACETED_BREP.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_FACETED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 
(*
$Id: aic_mechanical_design_geometric_presentation.exp,v 1.11 2014/03/04 00:30:27 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8486

EXPRESS Source:
ISO 10303-517 ed2 Mechanical design geometric presentation - Aic mechanical design geometric presentation

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-517 ed2 Mechanical design geometric presentation - Aic mechanical design geometric presentation
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA aic_mechanical_design_geometric_presentation '{iso standard 10303 part(517) version(2) object(1) aic_mechanical_design_geometric_presentation(1)}';

    USE FROM geometry_schema                          -- ISO 10303-42
     (axis2_placement,
      axis2_placement_2d,
      axis2_placement_3d); 

    USE FROM presentation_appearance_schema           -- ISO 10303-46
       (curve_style,
        curve_style_font, 
        curve_style_font_pattern,
        draughting_pre_defined_curve_font,
        fill_area_style_colour,
        invisibility,
        marker_type,
        over_riding_styled_item,
        point_style,
        presentation_style_by_context,
        styled_item,
        surface_side_style,
        surface_style_boundary,
        surface_style_control_grid, 
        surface_style_fill_area,
        surface_style_parameter_line,
        surface_style_segmentation_curve, 
        surface_style_silhouette, 
        surface_style_usage,
        u_direction_count,        
        v_direction_count);

    REFERENCE FROM presentation_organization_schema    -- ISO 10303-46
       (aspect_ratio,
       camera_model_d3);

    USE FROM presentation_organization_schema          -- ISO 10303-46
       (background_colour,
        camera_image_3d_with_scale,
        camera_usage,
        presentation_area,        
        presentation_representation,
        presentation_size,
        presentation_view);

    USE FROM presentation_resource_schema              -- ISO 10303-46
       (colour_rgb,
        draughting_pre_defined_colour,
        planar_box,
        planar_extent);

    USE FROM product_property_representation_schema    -- ISO 10303-41
     (shape_representation);

    USE FROM representation_schema                     -- ISO 10303-43
       (mapped_item,
        representation); 

  TYPE mechanical_design_geometric_presentation_area_items = SELECT(
    axis2_placement,
    mapped_item);
  END_TYPE;

  TYPE mechanical_design_geometric_presentation_representation_items = SELECT(
    axis2_placement,
    camera_model_d3,
    mapped_item,
    styled_item);
  END_TYPE;

  ENTITY mechanical_design_geometric_presentation_area
    SUBTYPE OF (presentation_area);
      SELF\representation.items : SET[1:?] OF mechanical_design_geometric_presentation_area_items;
    WHERE
     WR1:  -- only presentation_views or axis2_placements in
        -- mechanical_design_geometric_presentation_area
       SIZEOF(QUERY(it1 <* SELF.items |
        NOT ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1))
        OR
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))) = 0;
  WR2:  -- only mechanical_design_geometric_presentation_representation
        -- via camera_image_3d_with_scale or axis2_placements in
        -- presentation_views
        SIZEOF(QUERY(pv <* QUERY(mi1 <* QUERY(it1 <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1)) |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        -- search in all presentation_views for axis2_placements and
        -- mapped_items and for the subtype of mapped_item
        -- camera_image_3d_with_scale; the latter shall reference
        -- a mechanical_design_geometric_presentation_representation;
        -- the supertype mapped_item shall reference presentation_view.
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
      WR3:  (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ((ps\presentation_size.size.size_in_x <= 0)
         OR
         (ps\presentation_size.size.size_in_y <= 0)))) = 0)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ((ps\presentation_size.size.size_in_x <= 0)
        OR
        (ps\presentation_size.size.size_in_y <= 0)))) > 0))) = 0);
      WR4:  (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)
        AND
        (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)
        OR
        ((SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('GEOMETRY_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1))) = 1)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0))) = 1));
  END_ENTITY;

  ENTITY mechanical_design_geometric_presentation_representation
    SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF mechanical_design_geometric_presentation_representation_items;
    WHERE
      WR1: SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
      WR2: SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
      WR3: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(pss <* psa.styles | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE']
        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0;
      WR4: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psbc <* QUERY(psa <* si\styled_item.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'REPRESENTATION_ITEM',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.REPRESENTATION']
        * TYPEOF(psbc\presentation_style_by_context.style_context))
        = 1))) = 0))) = 0;
      WR5: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ps <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE'
        IN TYPEOF(pss)) | NOT
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ps\point_style.marker_size))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ps\point_style.marker_colour))
        = 1)))) = 0))) = 0))) = 0;
      WR6: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(cs <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF(pss)) | NOT((SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(cs\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (cs\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
      WR7: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) |
        NOT ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_SIDE_STYLE' IN TYPEOF
        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0;
      WR8: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_FILL_AREA',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY']
        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0;
      WR9: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR10: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF 
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR11: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.
        curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR12: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR13: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))
        = 0))) = 0))) = 0;
  END_ENTITY;

END_SCHEMA;  
(*
$Id: aic_topologically_bounded_surface.exp,v 1.3 2014/03/04 00:30:28 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N400

EXPRESS Source:
ISO 10303-511 ed1 Topologically bounded surface - Aic topologically bounded surface

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-511 ed1 Topologically bounded surface - Aic topologically bounded surface
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA aic_topologically_bounded_surface '{iso standard 10303 part(511) version(3333) object(1) aic_topologically_bounded_surface(1)}';
  
USE FROM geometry_schema ( axis2_placement_2d, axis2_placement_3d, bezier_curve, bezier_surface, b_spline_curve_with_knots, b_spline_surface_with_knots, cartesian_point, circle, composite_curve_on_surface, conical_surface, cylindrical_surface, degenerate_toroidal_surface, direction, ellipse, geometric_representation_context, hyperbola, line, parabola, pcurve, plane, polyline, quasi_uniform_curve, quasi_uniform_surface, rational_b_spline_curve, rational_b_spline_surface, spherical_surface, surface_curve, surface_of_linear_extrusion, surface_of_revolution, swept_surface, toroidal_surface, uniform_curve, uniform_surface, vector);
 USE FROM topology_schema ( edge, edge_curve, edge_loop, face_bound, face_outer_bound, face_surface, oriented_edge, path, vertex_loop, vertex_point);
 USE FROM representation_schema ( definitional_representation, parametric_representation_context);
 USE FROM measure_schema ( parameter_value);
  
ENTITY advanced_face 
 SUBTYPE OF ( face_surface );
 WHERE 
WR1 : 
SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
WR2 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
WR6 : NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
WR7 : 
SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
WR10 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
 END_ENTITY ;
END_SCHEMA;
 
(*
$Id: application_context_schema.exp,v 1.14 2014/03/04 00:30:29 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Application context schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Application context schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA application_context_schema '{iso standard 10303 part(41) version(7) object(1) application_context_schema(2)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    id_attribute,
    id_attribute_select);
  REFERENCE FROM date_time_schema (
    year_number);
  REFERENCE FROM support_resource_schema (
    identifier, 
    label, 
    text);

  TYPE acs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    application_context);
  END_TYPE;
  
  TYPE acs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    application_context);
  END_TYPE;

  ENTITY application_context;
    application : label;
  DERIVE
    description : text := get_description_value(SELF);
    id : identifier := get_id_value(SELF);
  INVERSE
    context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF(library_context, product_concept_context, product_context, product_definition_context));
    name : label;
    frame_of_reference : application_context;
  END_ENTITY;

  ENTITY application_context_relationship;
    name : label;
    description : OPTIONAL text;
    relating_context : application_context;
    related_context : application_context;
  END_ENTITY;

  ENTITY application_protocol_definition;
    status : label;
    application_interpreted_model_schema_name : label;
    application_protocol_year : year_number;
    application : application_context;
  END_ENTITY;

  ENTITY library_context
    SUBTYPE OF (application_context_element);
    library_reference : label;
  END_ENTITY;

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
    market_segment_type : label;
  END_ENTITY;

  ENTITY product_context
    SUBTYPE OF (application_context_element);
    discipline_type : label;
  END_ENTITY;

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
    life_cycle_stage : label;
  END_ENTITY;

END_SCHEMA;
(*
$Id: approval_schema.exp,v 1.15 2014/03/04 00:30:30 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA approval_schema '{iso standard 10303 part(41) version(7) object(1) approval_schema(3)}';
  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM date_time_schema (
    date_time_select);
  REFERENCE FROM person_organization_schema (
    person_organization_select);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    label, 
    text);
    
  TYPE apps_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    approval_role);
  END_TYPE;
  
  TYPE apps_role_select = SELECT BASED_ON role_select WITH (
    approval_date_time);
  END_TYPE;
  
    
  ENTITY approval;
    status : approval_status;
    level : label;
  END_ENTITY;

  ENTITY approval_date_time;
    date_time : date_time_select;
    dated_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_person_organization;
    person_organization : person_organization_select;
    authorized_approval : approval;
    role : approval_role;
  END_ENTITY;

  ENTITY approval_relationship;
    name : label;
    description : OPTIONAL text;
    relating_approval : approval;
    related_approval : approval;
  END_ENTITY;

  ENTITY approval_role;
    role : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY approval_status;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_approval_relationship (relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: basic_attribute_schema.exp,v 1.15 2014/03/04 00:30:30 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Basic attribute schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Basic attribute schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA basic_attribute_schema '{iso standard 10303 part(41) version(7) object(1) basic_attribute_schema(4)}';

  REFERENCE FROM support_resource_schema (identifier, label, text);
 
  TYPE description_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE id_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE name_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
-- property_definition_representati
 
  TYPE role_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  ENTITY description_attribute;
    attribute_value : text;
    described_item : description_attribute_select;
  END_ENTITY;

  ENTITY id_attribute;
    attribute_value : identifier;
    identified_item : id_attribute_select;
  END_ENTITY;

  ENTITY name_attribute;
    attribute_value : label;
    named_item : name_attribute_select;
  END_ENTITY;

  ENTITY object_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY role_association;
    role : object_role;
    item_with_role : role_select;
  END_ENTITY;

  FUNCTION get_description_value (obj : description_attribute_select):text;
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_id_value (obj : id_attribute_select):identifier;
    LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_name_value (obj : name_attribute_select):label;
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_role (obj : role_select):object_role;
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
$Id: certification_schema.exp,v 1.14 2014/03/04 00:30:31 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA certification_schema '{iso standard 10303 part(41) version(3) object(1) certification_schema(5)}';
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY certification;
    name : label;
    purpose : text;
    kind : certification_type;
  END_ENTITY;

  ENTITY certification_type;
    description : label;
  END_ENTITY;

END_SCHEMA;
(*
$Id: contract_schema.exp,v 1.12 2014/03/04 00:30:32 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA contract_schema '{iso standard 10303 part(41) version(3) object(1) contract_schema(6)}';
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  ENTITY contract;
    name : label;
    purpose : text;
    kind : contract_type;
  END_ENTITY;

  ENTITY contract_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_contract : contract;
    related_contract : contract;
  END_ENTITY;

  ENTITY contract_type;
    description : label;
  END_ENTITY;

  FUNCTION acyclic_contract_relationship (relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: date_time_schema.exp,v 1.24 2014/03/04 00:30:32 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA date_time_schema '{iso standard 10303 part(41) version(7) object(1) date_time_schema(7)}';

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   get_description_value);

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit,
   time_measure_with_unit);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text);

  TYPE dts_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    date_role,
    date_time_role,
    time_role);
  END_TYPE;

TYPE ahead_or_behind = ENUMERATION OF
   (ahead,
    exact,
    behind);
END_TYPE;

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select,
    event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT
   (date,
    date_and_time,
    local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE;

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE;

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE;

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF < 60.0 };
END_TYPE;

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE;

TYPE year_number = INTEGER;
WHERE
  WR1: (SELF > 1581);
END_TYPE;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date,
                       year_month));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: EXISTS(primary_bound) OR EXISTS(secondary_bound);
  WR2: NOT (EXISTS(primary_bound) AND EXISTS(secondary_bound) AND EXISTS(duration));
  WR3: EXISTS(primary_bound) AND NOT EXISTS(secondary_bound) AND (NOT EXISTS(duration) OR duration_is_positive(duration));
  WR4: EXISTS(secondary_bound) AND NOT EXISTS(primary_bound) AND EXISTS(duration) AND duration_is_negative(duration);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
WHERE
 WR1: NOT(leap_year(SELF\date.year_component)) OR { 1<= (day_component + (7 * (week_component - 1))) <= 366 };
 WR2: leap_year(SELF\date.year_component) OR { 1<= (day_component + (7 * (week_component - 1))) <= 365 };
END_ENTITY;

ENTITY year_month
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN;
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN;
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION;


FUNCTION duration_is_positive
 (duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component > 0.0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION duration_is_negative
 (duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component < 0.0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION leap_year
 (year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION;

FUNCTION valid_time
 (time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;

END_SCHEMA;
(*
$Id: document_schema.exp,v 1.15 2014/03/04 00:30:33 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Document schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Document schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA document_schema '{iso standard 10303 part(41) version(4) object(1) document_schema(8)}';
  REFERENCE FROM product_definition_schema (product, product_definition, product_definition_formation);
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  TYPE product_or_formation_or_definition = SELECT (product, product_definition_formation, product_definition);
  END_TYPE;

  ENTITY document;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    kind : document_type;
  INVERSE
    representation_types : SET [0:?] OF document_representation_type FOR represented_document;
  END_ENTITY;

  ENTITY document_product_association;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_product : product_or_formation_or_definition;
  END_ENTITY;

  ENTITY document_relationship;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_document : document;
  END_ENTITY;

  ENTITY document_representation_type;
    name : label;
    represented_document : document;
  END_ENTITY;

  ENTITY document_type;
    product_data_type : label;
  END_ENTITY;

  ENTITY document_usage_constraint;
    source : document;
    subject_element : label;
    subject_element_value : text;
  END_ENTITY;

  ENTITY document_with_class
    SUBTYPE OF (document);
    class : identifier;
  END_ENTITY;

  FUNCTION acyclic_document_relationship (relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: effectivity_schema.exp,v 1.13 2014/03/04 00:30:35 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Effectivity schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Effectivity schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA effectivity_schema '{iso standard 10303 part(41) version(7) object(1) effectivity_schema(9)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM date_time_schema (
    date_time_or_event_occurrence, 
    time_interval);
  REFERENCE FROM measure_schema (
    measure_with_unit);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
    
  TYPE effs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    effectivity);
  END_TYPE;

  TYPE effs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    effectivity);
  END_TYPE;
    
  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
    effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
    effectivity_start_date : OPTIONAL date_time_or_event_occurrence;
  WHERE
    WR1: EXISTS(effectivity_end_date) OR EXISTS(effectivity_start_date);
  END_ENTITY;

  ENTITY effectivity
    SUPERTYPE OF (ONEOF(serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
    id : identifier;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY effectivity_relationship;
    name : label;
    description : OPTIONAL text;
    related_effectivity : effectivity;
    relating_effectivity : effectivity;
  END_ENTITY;

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
    effectivity_lot_id : identifier;
    effectivity_lot_size : measure_with_unit;
  END_ENTITY;

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
    effectivity_start_id : identifier;
    effectivity_end_id : OPTIONAL identifier;
  END_ENTITY;

  ENTITY time_interval_based_effectivity
    SUBTYPE OF (effectivity);
    effectivity_period : time_interval;
  END_ENTITY;

  FUNCTION acyclic_effectivity_relationship (relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: experience_schema.exp,v 1.19 2014/03/04 00:30:35 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA experience_schema '{iso standard 10303 part(41) version(4) object(1) experience_schema(10)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY experience;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience : experience;
    related_experience : experience;
  END_ENTITY;

  ENTITY experience_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience_type : experience_type;
    related_experience_type : experience_type;
  END_ENTITY;

  FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: external_reference_schema.exp,v 1.13 2014/03/04 00:30:36 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA external_reference_schema '{iso standard 10303 part(41) version(7) object(1) external_reference_schema(11)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value);
  REFERENCE FROM support_resource_schema (
    label, 
    text, 
    identifier, 
    bag_to_set);
    
  TYPE ers_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    external_source);
  END_TYPE;
    
  TYPE message = STRING;
  END_TYPE;

  TYPE source_item = SELECT (identifier, message);
  END_TYPE;

  ENTITY external_source;
    source_id : source_item;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY external_source_relationship;
    name : label;
    description : OPTIONAL text;
    relating_source : external_source;
    related_source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item;
    item_id : source_item;
    source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_item : externally_defined_item;
    related_item : externally_defined_item;
  END_ENTITY;
  
  ENTITY externally_defined_item_with_multiple_references
    SUBTYPE OF (externally_defined_item);
    references : LIST[1:?] OF UNIQUE source_item;
  UNIQUE
    UR1: references;
  WHERE
    WR1: NOT(SELF\externally_defined_item.item_id IN references);
  END_ENTITY;  

  ENTITY pre_defined_item;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_external_source_relationship (relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_externally_defined_item_relationship (relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: geometric_model_schema.exp,v 1.12 2014/03/04 00:30:37 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N7627

EXPRESS Source:
ISO 10303-42 ed4 Geometric and topological representation - Geometric model schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed4 Geometric and topological representation - Geometric model schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA geometric_model_schema '{iso standard 10303 part(42) version(9) object(1) geometric_model_schema(3)}';

REFERENCE FROM geometry_schema;    -- ISO 10303-42

REFERENCE FROM topology_schema;    -- ISO 10303-42

REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (founded_item,
   representation,
   representation_item,
   using_representations); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 


TYPE boolean_operand = SELECT
   (boolean_result, 
    csg_primitive, 
    half_space_2d, 
    half_space_solid, 
    solid_model);
END_TYPE; 

TYPE boolean_operator = ENUMERATION OF 
   (union,
    intersection,
    difference);
END_TYPE; 

TYPE bounded_primitive_2d = EXTENSIBLE GENERIC_ENTITY SELECT
   (area_with_outer_boundary, 
    circular_area, 
    elliptic_area, 
    polygonal_area, 
    rectangular_area);
END_TYPE; 

TYPE csg_primitive = SELECT
   (block, 
    bounded_primitive_2d, 
    cyclide_segment_solid, 
    eccentric_cone, 
    ellipsoid, 
    faceted_primitive, 
    rectangular_pyramid, 
    right_angular_wedge, 
    right_circular_cone, 
    right_circular_cylinder, 
    sphere, 
    torus);
END_TYPE; 

TYPE csg_select = SELECT
   (boolean_result, 
    csg_primitive);
END_TYPE; 

TYPE edge_or_curve = SELECT
   (curve, 
    edge);
END_TYPE; 

TYPE face_or_surface = SELECT
   (face, 
    surface);
END_TYPE; 

TYPE geometric_set_select = SELECT
   (curve, 
    point, 
    surface);
END_TYPE; 

TYPE path_or_composite_curve = SELECT
   (composite_curve, 
    path);
END_TYPE; 

TYPE surface_model = SELECT
   (face_based_surface_model, 
    shell_based_surface_model);
END_TYPE; 

TYPE tessellated_edge_or_vertex = SELECT
   (tessellated_edge, 
    tessellated_vertex);
END_TYPE; 

TYPE wireframe_model = SELECT
   (edge_based_wireframe_model, 
    shell_based_wireframe_model);
END_TYPE; 

ENTITY solid_model
  SUPERTYPE OF (ONEOF (csg_solid,
                       manifold_solid_brep,
                       swept_face_solid,
                       swept_area_solid,
                       swept_disk_solid,
                       solid_replica,
                       brep_2d,
                       trimmed_volume))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY;

ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET[1:?] OF oriented_closed_shell;
END_ENTITY;

ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
END_ENTITY;

ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
WHERE
  WR1: SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE', 'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] * TYPEOF (SELF.extent)) = 0;
  WR2: SIZEOF (QUERY (bnds <* extent.bounds | NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
  WR3: SIZEOF (QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
  WR4: SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) | NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2)))) = 0))) = 0;
END_ENTITY;

ENTITY csg_solid
  SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;

ENTITY boolean_result
  SUBTYPE OF (geometric_representation_item);
  operator : boolean_operator;
  first_operand : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;

ENTITY block
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY right_angular_wedge
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY rectangular_pyramid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY faceted_primitive
  SUPERTYPE OF (ONEOF (tetrahedron,
                       convex_hexahedron))
  SUBTYPE OF (geometric_representation_item);
  points : LIST[4:?] OF UNIQUE cartesian_point;
WHERE
  WR1: points[1].dim = 3;
END_ENTITY;

ENTITY tetrahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 4;
  WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;

ENTITY convex_hexahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 8;
  WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR8: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR9: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR10: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR11: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR12: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR13: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
END_ENTITY;

ENTITY sphere
  SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;

ENTITY right_circular_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY right_circular_cylinder
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : positive_length_measure;
END_ENTITY;

ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY torus
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: major_radius > minor_radius;
END_ENTITY;

ENTITY ellipsoid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY cyclide_segment_solid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  radius1 : positive_length_measure;
  radius2 : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle : plane_angle_measure;
END_ENTITY;

ENTITY half_space_solid
  SUBTYPE OF (geometric_representation_item);
  base_surface : surface;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY boxed_half_space
  SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;

ENTITY box_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')| NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY primitive_2d
  SUPERTYPE OF (ONEOF (circular_area,
                       elliptic_area,
                       rectangular_area,
                       polygonal_area,
                       half_space_2d))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY circular_area
  SUBTYPE OF (primitive_2d);
  centre : cartesian_point;
  radius : positive_length_measure;
END_ENTITY;

ENTITY elliptic_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  x : positive_length_measure;
  y : positive_length_measure;
END_ENTITY;

ENTITY polygonal_area
  SUBTYPE OF (primitive_2d);
  bounds : LIST[3:?] OF UNIQUE cartesian_point;
END_ENTITY;

ENTITY area_with_outer_boundary
  SUBTYPE OF (half_space_2d);
  SELF\half_space_2d.base_curve : composite_curve;
WHERE
  WR1: base_curve\composite_curve.closed_curve = TRUE;
END_ENTITY;

ENTITY half_space_2d
  SUBTYPE OF (primitive_2d);
  base_curve : curve;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
  enclosure : rectangle_domain;
END_ENTITY;

ENTITY rectangle_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY swept_face_solid
  SUPERTYPE OF (ONEOF (extruded_face_solid,
                       revolved_face_solid,
                       surface_curve_swept_face_solid))
  SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;

ENTITY extruded_face_solid
  SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_face_solid.swept_face.face_geometry\ elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_face_solid
  SUBTYPE OF (swept_face_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_face_solid
  SUBTYPE OF (swept_face_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY swept_area_solid
  SUPERTYPE OF (ONEOF (revolved_area_solid,
                       extruded_area_solid,
                       surface_curve_swept_area_solid))
  SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;

ENTITY extruded_area_solid
  SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_area_solid.swept_area.basis_surface\ elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_area_solid
  SUBTYPE OF (swept_area_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_area_solid
  SUBTYPE OF (swept_area_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY swept_disk_solid
  SUBTYPE OF (solid_model);
  directrix : curve;
  radius : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param : REAL;
  end_param : REAL;
WHERE
  WR1: directrix.dim = 3;
  WR2: (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;

ENTITY trimmed_volume
  SUBTYPE OF (solid_model);
  basis_volume : volume;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  w1 : parameter_value;
  w2 : parameter_value;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: w1 <> w2;
END_ENTITY;

ENTITY solid_replica
  SUBTYPE OF (solid_model);
  parent_solid : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_solid_replica(SELF, parent_solid);
  WR2: parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;

ENTITY face_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  fbsm_faces : SET[1:?] OF connected_face_set;
END_ENTITY;

ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;

ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET[1:?] OF connected_edge_set;
END_ENTITY;

ENTITY geometric_set
  SUPERTYPE OF (ONEOF (geometric_curve_set,
                       geometric_set_replica))
  SUBTYPE OF (geometric_representation_item);
  elements : SET[1:?] OF geometric_set_select;
END_ENTITY;

ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
  WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements | 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY;

ENTITY sectioned_spine
  SUBTYPE OF (geometric_curve_set);
  cross_sections : LIST[2:?] OF curve;
  spine_points : LIST[2:?] OF point;
WHERE
  WR1: SIZEOF(SELF\geometric_set.elements) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1]);
  WR3: SIZEOF(cross_sections) = SIZEOF(spine_points);
  WR4: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY geometric_set_replica
  SUBTYPE OF (geometric_set);
  parent_set : geometric_set;
  transformation : cartesian_transformation_operator;
DERIVE
  SELF\geometric_set.elements : SET[1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
WHERE
  WR1: acyclic_set_replica(SELF, parent_set);
END_ENTITY;

ENTITY tessellated_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF tessellated_item;
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY tessellated_item
  ABSTRACT SUPERTYPE OF (ONEOF (coordinates_list,
                                tessellated_solid,
                                tessellated_shell,
                                tessellated_wire,
                                tessellated_geometric_set,
                                tessellated_curve_set,
                                tessellated_point_set,
                                tessellated_surface_set,
                                tessellated_structured_item))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHAPE_REPRESENTATION' IN TYPEOF(using_rep)))) = 0;
END_ENTITY;

ENTITY repositioned_tessellated_item
  SUBTYPE OF (tessellated_item);
  location : axis2_placement_3d;
WHERE
  WR1: NOT (SIZEOF (['GEOMETRIC_MODEL_SCHEMA.TESSELLATED_CURVE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_GEOMETRIC_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_POINT_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SURFACE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHELL', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SOLID', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_WIRE'] * TYPEOF(SELF)) = 0);
END_ENTITY;

ENTITY tessellated_structured_item
  SUPERTYPE OF (ONEOF (tessellated_face,
                       tessellated_edge,
                       tessellated_vertex))
  SUBTYPE OF (tessellated_item);
END_ENTITY;

ENTITY coordinates_list
  SUBTYPE OF (tessellated_item);
  npoints : INTEGER;
  position_coords : LIST[1:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: npoints = SIZEOF(position_coords);
  WR2: SIZEOF (['GEOMETRIC_MODEL_SCHEMA.REPOSITIONED_TESSELLATED_ITEM'] * TYPEOF(SELF)) = 0;
END_ENTITY;

ENTITY tessellated_vertex
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  topological_link : OPTIONAL vertex_point;
  point_index : INTEGER;
END_ENTITY;

ENTITY tessellated_edge
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  geometric_link : OPTIONAL edge_or_curve;
  line_strip : LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_connecting_edge
  SUBTYPE OF (tessellated_edge);
  smooth : LOGICAL;
  face1 : tessellated_face;
  face2 : tessellated_face;
  line_strip_face1 : LIST[2:?] OF INTEGER;
  line_strip_face2 : LIST[2:?] OF INTEGER;
WHERE
  WR1: SIZEOF(line_strip_face1) = SIZEOF(line_strip_face2);
  WR2: SIZEOF(line_strip_face1) = SIZEOF(SELF\tessellated_edge.line_strip);
END_ENTITY;

ENTITY tessellated_face
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_face,
                                complex_triangulated_face))
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
  geometric_link : OPTIONAL face_or_surface;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY tessellated_solid
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  geometric_link : OPTIONAL manifold_solid_brep;
END_ENTITY;

ENTITY tessellated_shell
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  topological_link : OPTIONAL connected_face_set;
END_ENTITY;

ENTITY tessellated_wire
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_edge_or_vertex;
  geometric_model_link : OPTIONAL path_or_composite_curve;
END_ENTITY;

ENTITY tessellated_surface_set
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_surface_set,
                                complex_triangulated_surface_set))
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY tessellated_curve_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  line_strips : LIST[1:?] OF LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_geometric_set
  SUBTYPE OF (tessellated_item);
  children : SET[1:?] OF tessellated_item;
END_ENTITY;

ENTITY tessellated_point_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  point_list : LIST[1:?] OF INTEGER;
END_ENTITY;

FUNCTION acyclic_set_replica
 (rep : geometric_set_replica; parent : geometric_set) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type geometric_set_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_solid_replica
 (rep : solid_replica; parent : solid_model) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;END_FUNCTION; 

FUNCTION build_transformed_set
 (tr : cartesian_transformation_operator; gset : geometric_set) : SET[0:?] OF geometric_set_select; 
LOCAL
   s          : SET [1:?] OF geometric_set_select := gset.elements;
   trset      : SET [0:?] OF geometric_set_select := [];
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
     trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || point() || point_replica(s[j],tr);
       ELSE
       IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || surface()  || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d (?));
       END_IF;
     END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);END_FUNCTION; 

FUNCTION constraints_geometry_shell_based_surface_model
 (m : shell_based_surface_model) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION constraints_geometry_shell_based_wireframe_model
 (m : shell_based_wireframe_model) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION msb_shells
 (brep : manifold_solid_brep) : SET[1:?] OF closed_shell; 
LOCAL   
      return_set: SET[1:?] OF closed_shell := [brep.outer];   
    END_LOCAL;   

    IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) |   
                 msbtype LIKE '*BREP_WITH_VOIDS'))  >= 1    
          THEN   
       return_set := return_set + brep\brep_with_voids.voids;   
    END_IF;   
   RETURN(return_set);END_FUNCTION; 

END_SCHEMA;  -- geometric_model_schema



(*
$Id: geometry_schema.exp,v 1.14 2014/03/04 00:30:37 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N7627

EXPRESS Source:
ISO 10303-42 ed4 Geometric and topological representation - Geometry schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed4 Geometric and topological representation - Geometry schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA geometry_schema '{iso standard 10303 part(42) version(9) object(1) geometry_schema(1)}';

REFERENCE FROM representation_schema   -- ISO 10303-43
  (definitional_representation,
   founded_item,
   functionally_defined_transformation,
   item_in_context,
   representation,
   representation_context,
   representation_item,
   using_representations); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure); 

REFERENCE FROM topology_schema   -- ISO 10303-42
  (edge_curve,
   face_surface,
   poly_loop,
   vertex_point); 

REFERENCE FROM geometric_model_schema   -- ISO 10303-42
  (block,
   boolean_result,
   cyclide_segment_solid,
   eccentric_cone,
   edge_based_wireframe_model,
   ellipsoid,
   face_based_surface_model,
   faceted_primitive,
   geometric_set,
   half_space_solid,
   primitive_2d,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   shell_based_surface_model,
   shell_based_wireframe_model,
   solid_model,
   sphere,
   tessellated_item,
   torus); 


CONSTANT
  dummy_gri : geometric_representation_item := representation_item('')|| geometric_representation_item(); 
END_CONSTANT; 

TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
END_TYPE; 

TYPE b_spline_curve_form = ENUMERATION OF 
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
END_TYPE; 

TYPE b_spline_surface_form = ENUMERATION OF 
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
END_TYPE; 

TYPE curve_on_surface = SELECT
   (composite_curve_on_surface, 
    pcurve, 
    surface_curve);
END_TYPE; 

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE; 

TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
END_TYPE; 

TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
END_TYPE; 

TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
END_TYPE; 

TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1,
    pcurve_s2);
END_TYPE; 

TYPE surface_boundary = SELECT
   (boundary_curve, 
    degenerate_pcurve);
END_TYPE; 

TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
END_TYPE; 

TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
END_TYPE; 

TYPE trimming_select = SELECT
   (cartesian_point, 
    parameter_value);
END_TYPE; 

TYPE vector_or_direction = SELECT
   (direction, 
    vector);
END_TYPE; 

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (point,
                       direction,
                       vector,
                       placement,
                       cartesian_transformation_operator,
                       curve,
                       surface,
                       edge_curve,
                       face_surface,
                       poly_loop,
                       vertex_point,
                       solid_model,
                       boolean_result,
                       sphere,
                       right_circular_cone,
                       right_circular_cylinder,
                       torus,
                       block,
                       primitive_2d,
                       right_angular_wedge,
                       ellipsoid,
                       faceted_primitive,
                       rectangular_pyramid,
                       cyclide_segment_solid,
                       volume,
                       half_space_solid,
                       shell_based_surface_model,
                       face_based_surface_model,
                       shell_based_wireframe_model,
                       edge_based_wireframe_model,
                       geometric_set,
                       tessellated_item))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;

ENTITY point
  SUPERTYPE OF (ONEOF (cartesian_point,
                       point_on_curve,
                       point_on_surface,
                       point_in_volume,
                       point_replica,
                       degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY cartesian_point
  SUPERTYPE OF (ONEOF (cylindrical_point,
                       polar_point,
                       spherical_point))
  SUBTYPE OF (point);
  coordinates : LIST[1:3] OF length_measure;
END_ENTITY;

ENTITY cylindrical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  z : length_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*cos(theta), r*sin(theta), z];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY spherical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  phi : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY polar_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*cos(theta), r*sin(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve : curve;
  point_parameter : parameter_value;
END_ENTITY;

ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY;

ENTITY point_in_volume
  SUBTYPE OF (point);
  basis_volume : volume;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  point_parameter_w : parameter_value;
END_ENTITY;

ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica (SELF,parent_pt);
END_ENTITY;

ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation. items[1]\geometric_representation_item.dim =2;
END_ENTITY;

ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST[2:3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

ENTITY placement
  SUPERTYPE OF (ONEOF (axis1_placement,
                       axis2_placement_2d,
                       axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[2:2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[3:3] OF direction := build_axes(axis,ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR (cross_product(axis,ref_direction).magnitude > 0.0);
END_ENTITY;

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
                       cartesian_transformation_operator_3d))
  SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
  axis1 : OPTIONAL direction;
  axis2 : OPTIONAL direction;
  local_origin : cartesian_point;
  scale : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST[3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST[2:2] OF direction := base_axis(2,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY curve
  SUPERTYPE OF (ONEOF (line,
                       conic,
                       clothoid,
                       circular_involute,
                       pcurve,
                       surface_curve,
                       offset_curve_2d,
                       offset_curve_3d,
                       curve_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY;

ENTITY conic
  SUPERTYPE OF (ONEOF (circle,
                       ellipse,
                       hyperbola,
                       parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;

ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;

ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;

ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0.0;
END_ENTITY;

ENTITY clothoid
  SUBTYPE OF (curve);
  position : axis2_placement;
  clothoid_constant : length_measure;
END_ENTITY;

ENTITY circular_involute
  SUBTYPE OF (curve);
  position : axis2_placement;
  base_radius : positive_length_measure;
END_ENTITY;

ENTITY bounded_curve
  SUPERTYPE OF (ONEOF (polyline,
                       b_spline_curve,
                       trimmed_curve,
                       bounded_pcurve,
                       bounded_surface_curve,
                       composite_curve))
  SUBTYPE OF (curve);
END_ENTITY;

ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST[2:?] OF cartesian_point;
END_ENTITY;

ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF (uniform_curve,
                       b_spline_curve_with_knots,
                       quasi_uniform_curve,
                       bezier_curve)
               ANDOR rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree : INTEGER;
  control_points_list : LIST[2:?] OF cartesian_point;
  curve_form : b_spline_curve_form;
  closed_curve : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list) - 1);
  control_points : ARRAY[0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,0, upper_index_on_control_points);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
END_ENTITY;

ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST[2:?] OF INTEGER;
  knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,0, upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. control_points_list);
  WR2: curve_weights_positive(SELF);
END_ENTITY;

ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve : curve;
  trim_1 : SET[1:2] OF trimming_select;
  trim_2 : SET[1:2] OF trimming_select;
  sense_agreement : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;

ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments : LIST[1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 1)) OR ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 0));
END_ENTITY;

ENTITY composite_curve_segment
  SUBTYPE OF (founded_item);
  transition : transition_code;
  same_sense : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG[1:?] OF composite_curve FOR segments;
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;

ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0.0;
END_ENTITY;

ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\ geometric_representation_item.dim =2;
END_ENTITY;

ENTITY bounded_pcurve
  SUBTYPE OF (pcurve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;

ENTITY surface_curve
  SUPERTYPE OF (ONEOF (intersection_curve,
                       seam_curve)
               ANDOR bounded_surface_curve)
  SUBTYPE OF (curve);
  curve_3d : curve;
  associated_geometry : LIST[1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET[1:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
  WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
  WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY;

ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
  WR4: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY bounded_surface_curve
  SUBTYPE OF (surface_curve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;

ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET[0:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
END_ENTITY;

ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY;

ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
  ref_direction : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;

ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica (SELF, parent_curve);
END_ENTITY;

ENTITY surface
  SUPERTYPE OF (ONEOF (elementary_surface,
                       swept_surface,
                       bounded_surface,
                       offset_surface,
                       surface_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY elementary_surface
  SUPERTYPE OF (ONEOF (plane,
                       cylindrical_surface,
                       conical_surface,
                       spherical_surface,
                       toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;

ENTITY plane
  SUBTYPE OF (elementary_surface);
END_ENTITY;

ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;

ENTITY degenerate_toroidal_surface
  SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  WR1: major_radius < minor_radius;
END_ENTITY;

ENTITY dupin_cyclide_surface
  SUBTYPE OF (elementary_surface);
  generalised_major_radius : positive_length_measure;
  generalised_minor_radius : positive_length_measure;
  skewness : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

ENTITY swept_surface
  SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,
                       surface_of_revolution,
                       surface_curve_swept_surface,
                       fixed_reference_swept_surface))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;

ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY;

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY fixed_reference_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  fixed_reference : direction;
END_ENTITY;

ENTITY bounded_surface
  SUPERTYPE OF (ONEOF (b_spline_surface,
                       rectangular_trimmed_surface,
                       curve_bounded_surface,
                       rectangular_composite_surface))
  SUBTYPE OF (surface);
END_ENTITY;

ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,
                       uniform_surface,
                       quasi_uniform_surface,
                       bezier_surface)
               ANDOR rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree : INTEGER;
  v_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF cartesian_point;
  surface_form : b_spline_surface_form;
  u_closed : LOGICAL;
  v_closed : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF cartesian_point := make_array_of_array(control_points_list, 0,u_upper,0,v_upper);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;

ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY rational_b_spline_surface
  SUBTYPE OF (b_spline_surface);
  weights_data : LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive(SELF);
END_ENTITY;

ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  usense : BOOLEAN;
  vsense : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 > u1));
  WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 > v1));
END_ENTITY;

ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  boundaries : SET[1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: (NOT implicit_outer) OR (SIZEOF (QUERY (temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
  WR2: (NOT(implicit_outer)) OR ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF(QUERY(temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <= 1;
  WR4: SIZEOF(QUERY(temp <* boundaries | (temp\composite_curve_on_surface.basis_surface [1] <> SELF.basis_surface))) = 0;
END_ENTITY;

ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY;

ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY;

ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST[1:?] OF LIST[1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
  WR2: constraints_rectangular_composite_surface(SELF);
END_ENTITY;

ENTITY surface_patch
  SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition : transition_code;
  v_transition : transition_code;
  u_sense : BOOLEAN;
  v_sense : BOOLEAN;
INVERSE
  using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY;

ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface : surface;
  distance : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;

ENTITY oriented_surface
  SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;

ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;

ENTITY volume
  SUPERTYPE OF (ONEOF (block_volume,
                       wedge_volume,
                       spherical_volume,
                       cylindrical_volume,
                       eccentric_conical_volume,
                       toroidal_volume,
                       pyramid_volume,
                       b_spline_volume,
                       ellipsoid_volume,
                       tetrahedron_volume,
                       hexahedron_volume))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY block_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY wedge_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY pyramid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY tetrahedron_volume
  SUBTYPE OF (volume);
  point_1 : cartesian_point;
  point_2 : cartesian_point;
  point_3 : cartesian_point;
  point_4 : cartesian_point;
WHERE
  WR1: point_1.dim = 3;
  WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0;
END_ENTITY;

ENTITY hexahedron_volume
  SUBTYPE OF (volume);
  points : LIST[8:8] OF cartesian_point;
WHERE
  WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR7: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR8: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR9: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR10: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR11: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR12: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
  WR13: points[1].dim = 3;
END_ENTITY;

ENTITY spherical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
END_ENTITY;

ENTITY cylindrical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY toroidal_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: minor_radius < major_radius;
END_ENTITY;

ENTITY ellipsoid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY b_spline_volume
  SUPERTYPE OF (ONEOF (b_spline_volume_with_knots,
                       uniform_volume,
                       quasi_uniform_volume,
                       bezier_volume)
               ANDOR rational_b_spline_volume)
  SUBTYPE OF (volume);
  u_degree : INTEGER;
  v_degree : INTEGER;
  w_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF cartesian_point;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  w_upper : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF cartesian_point := make_array_of_array_of_array (control_points_list, 0,u_upper,0,v_upper, 0,w_upper );
WHERE
  WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_volume_with_knots
  SUBTYPE OF (b_spline_volume);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  w_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  w_knots : LIST[2:?] OF parameter_value;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
  knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper, v_multiplicities, v_knots);
  WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper, w_multiplicities, w_knots);
  WR4: SIZEOF(u_multiplicities) = knot_u_upper;
  WR5: SIZEOF(v_multiplicities) = knot_v_upper;
  WR6: SIZEOF(w_multiplicities) = knot_w_upper;
END_ENTITY;

ENTITY bezier_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY quasi_uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY rational_b_spline_volume
  SUBTYPE OF (b_spline_volume);
  weights_data : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF REAL := make_array_of_array_of_array (weights_data,0,u_upper,0,v_upper,0,w_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
  WR2: volume_weights_positive(SELF);
END_ENTITY;

RULE compatible_dimension FOR 
(cartesian_point,direction,representation_context,geometric_representation_context);
WHERE
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY (y <* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY (y <* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0 )) = 0;
END_RULE; 

FUNCTION above_plane
 (p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL; 
LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);END_FUNCTION; 

FUNCTION acyclic_curve_replica
 (rep : curve_replica; parent : curve) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_point_replica
 (rep : point_replica; parent : point) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_surface_replica
 (rep : surface_replica; parent : surface) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;END_FUNCTION; 

FUNCTION associated_surface
 (arg : pcurve_or_surface) : surface; 
LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);END_FUNCTION; 

FUNCTION base_axis
 (dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST[2:3] OF direction; 
LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);END_FUNCTION; 

FUNCTION build_2axes
 (ref_direction : direction) : LIST[2:2] OF direction; 
LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);END_FUNCTION; 

FUNCTION build_axes
 (axis : direction; ref_direction : direction) : LIST[3:3] OF direction; 
LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);END_FUNCTION; 

FUNCTION constraints_composite_curve_on_surface
 (c : composite_curve_on_surface) : BOOLEAN; 
LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION constraints_param_b_spline
 (degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST[0:?] OF INTEGER; knots : LIST[0:?] OF parameter_value) : BOOLEAN; 
LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION constraints_rectangular_composite_surface
 (s : rectangular_composite_surface) : BOOLEAN; 
REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION cross_product
 (arg1 : direction; arg2 : direction) : vector; 
LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;END_FUNCTION; 

FUNCTION curve_weights_positive
 (b : rational_b_spline_curve) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION default_b_spline_curve_weights
 (up_cp : INTEGER) : ARRAY[0:up_cp] OF REAL; 
RETURN([1:up_cp + 1]);END_FUNCTION; 

FUNCTION default_b_spline_knot_mult
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF INTEGER; 
LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);END_FUNCTION; 

FUNCTION default_b_spline_knots
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF parameter_value; 
LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);END_FUNCTION; 

FUNCTION default_b_spline_surface_weights
 (u_upper : INTEGER; v_upper : INTEGER) : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL; 
RETURN([[1:v_upper + 1]:u_upper +1]);END_FUNCTION; 

FUNCTION dimension_of
 (item : geometric_representation_item) : dimension_count; 
LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
    IF (SIZEOF(x) > 0) THEN
       y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
    ELSE
      RETURN(?);
    -- mark error by returning indeterminate result
   END_IF;END_FUNCTION; 

FUNCTION dot_product
 (arg1 : direction; arg2 : direction) : REAL; 
LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);END_FUNCTION; 

FUNCTION first_proj_axis
 (z_axis : direction; arg : direction) : direction; 
LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);END_FUNCTION; 

FUNCTION get_basis_surface
 (c : curve_on_surface) : SET[0:2] OF surface; 
LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);END_FUNCTION; 

FUNCTION list_to_array
 (lis : LIST[0:?] OF GENERIC : T; low : INTEGER; u : INTEGER) : ARRAY[low:u] OF GENERIC : T; 
LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;END_FUNCTION; 

FUNCTION make_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF GENERIC : T; 
LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);END_FUNCTION; 

FUNCTION make_array_of_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T; 
LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);END_FUNCTION; 

FUNCTION normalise
 (arg : vector_or_direction) : vector_or_direction; 
LOCAL
      ndim   : INTEGER;
      v      : direction := dummy_gri || direction ([1.0,0.0,0.0]);
      result : vector_or_direction;
      vec    : vector := dummy_gri || vector (v, 1.0);
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg\vector.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag > 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION orthogonal_complement
 (vec : direction) : direction; 
LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;END_FUNCTION; 

FUNCTION same_side
 (plane_pts : LIST[3:3] OF cartesian_point; test_points : LIST[2:?] OF cartesian_point) : BOOLEAN; 
LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION scalar_times_vector
 (scalar : REAL; vec : vector_or_direction) : vector; 
LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec\vector.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag < 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION second_proj_axis
 (z_axis : direction; x_axis : direction; arg : direction) : direction; 
LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);END_FUNCTION; 

FUNCTION surface_weights_positive
 (b : rational_b_spline_surface) : BOOLEAN; 
LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION vector_difference
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1\vector.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2\vector.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag > 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION vector_sum
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1\vector.magnitude;
         vec1 := arg1\vector.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2\vector.magnitude;
         vec2 := arg2\vector.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);END_FUNCTION; 

FUNCTION volume_weights_positive
 (b : rational_b_spline_volume) : BOOLEAN; 
LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);END_FUNCTION; 

END_SCHEMA;  -- geometry_schema

(*
$Id: group_schema.exp,v 1.13 2014/03/04 00:30:37 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Group schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Group schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA group_schema '{iso standard 10303 part(41) version(7) object(1) group_schema(12)}';

  REFERENCE FROM support_resource_schema (
    label, 
    bag_to_set, 
    identifier, 
    text);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);
    
  TYPE gs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    group);
  END_TYPE;
    
  ENTITY group;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY group_relationship;
    name : label;
    description : OPTIONAL text;
    relating_group : group;
    related_group : group;
  END_ENTITY;

  FUNCTION acyclic_group_relationship (relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
   $Id: iso13584_expressions_schema.exp,v 1.14 2013/07/09 21:03:46 thomasrthurman Exp $
   ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
   
The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas 
("the Schema"), and derivations of the Schema:

Copyright ISO 2013  All rights reserved

Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema, 
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of 
developing, implementing, installing and using software based on the Schema, and to permit persons to 
whom the Schema is furnished to do so, subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS 
COMPLYING WITH THAT STANDARD.

*)


SCHEMA iso13584_expressions_schema;

REFERENCE FROM iso13584_generic_expressions_schema(
			generic_expression,
			simple_generic_expression,
			generic_variable,
			generic_literal,
			unary_generic_expression,
			binary_generic_expression,
			multiple_arity_generic_expression);

ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,
				boolean_expression,
				string_expression))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable,
				boolean_variable,
					string_variable))
SUBTYPE OF(generic_variable);
END_ENTITY;

ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function,
				string_defined_function,
				boolean_defined_function)
				)
				ANDOR SQL_mappable_defined_function);
END_ENTITY;

ENTITY SQL_mappable_defined_function
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
								unary_numeric_expression,
								binary_numeric_expression,
								multiple_arity_numeric_expression,
								length_function,
								value_function,
								numeric_defined_function))
SUBTYPE OF (expression);
DERIVE
	is_int: BOOLEAN := is_int_expr (SELF);
	sql_mappable: BOOLEAN := is_SQL_mappable (SELF);
END_ENTITY;

ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;

ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;

ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;

ENTITY numeric_variable
SUPERTYPE OF (ONEOF (int_numeric_variable,
			          real_numeric_variable))
SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;

ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (unary_function_call))
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;

ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,
				div_expression,
				mod_expression,
				slash_expression,
				power_expression,
				binary_function_call))
SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,
				mult_expression,
				multiple_arity_function_call))
SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;

ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY value_function
SUPERTYPE OF (int_value_function)
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;

ENTITY numeric_defined_function
ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function,
				real_defined_function))
SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (abs_function,
				minus_function,
				sin_function,
				cos_function,
				tan_function,
				asin_function,
				acos_function,
				exp_function,
				log_function,
				log2_function,
				log10_function,
				square_root_function))
SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (atan_function))
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, 
				minimum_function))
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY integer_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY real_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression,
				unary_boolean_expression,
				binary_boolean_expression,
				multiple_arity_Boolean_expression,
				comparison_expression,
				interval_expression,
				boolean_defined_function))
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal,
				boolean_variable))
SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;

ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;

ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(operand);
END_ENTITY;

ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;

ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal,
				comparison_greater,
				comparison_greater_equal,
				comparison_less,
				comparison_less_equal,
				comparison_not_equal,
				like_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;

ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 

ENTITY boolean_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;

ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression,
				index_expression,
				substring_expression,
				concat_expression,
				format_function,
				string_defined_function)) 
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (string_literal,
				string_variable))
SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;

ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;

ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;

ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;

ENTITY string_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;

FUNCTION is_int_expr (arg: numeric_expression) : BOOLEAN;

IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

FUNCTION is_SQL_mappable (arg: expression) : BOOLEAN;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions (arg : expression) : SET OF defined_function;

LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
		+ used_functions (arg\comparison_expression.operands[2]));
END_IF;

RETURN ([ ]);

END_FUNCTION; -- used_functions

END_SCHEMA;
(*
   $Id: iso13584_generic_expressions_schema.exp,v 1.7 2013/07/09 21:08:03 thomasrthurman Exp $
   ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
   
The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas 
("the Schema"), and derivations of the Schema:

Copyright ISO 2013  All rights reserved

Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema, 
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of 
developing, implementing, installing and using software based on the Schema, and to permit persons to 
whom the Schema is furnished to do so, subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS 
COMPLYING WITH THAT STANDARD.

*)

SCHEMA iso13584_generic_expressions_schema;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_generic_expression,
								unary_generic_expression,
								binary_generic_expression,
								multiple_arity_generic_expression));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
END_ENTITY; 

ENTITY generic_variable
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);
END_FUNCTION; -- acyclic

FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' 
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables

END_SCHEMA; 
(*
$Id: location_schema.exp,v 1.17 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Location schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Location schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA location_schema '{iso standard 10303 part(41) version(4) object(1) location_schema(13)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY location;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_location : location;
    related_location : location;
  END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: management_resources_schema.exp,v 1.34 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Management resources schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Management resources schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA management_resources_schema '{iso standard 10303 part(41) version(7) object(1) management_resources_schema(14)}';
  REFERENCE FROM action_schema;
  REFERENCE FROM application_context_schema (library_context);
  REFERENCE FROM approval_schema;
  REFERENCE FROM basic_attribute_schema (
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM certification_schema;
  REFERENCE FROM contract_schema;
  REFERENCE FROM date_time_schema;
  REFERENCE FROM document_schema;
  REFERENCE FROM effectivity_schema;
  REFERENCE FROM experience_schema;
  REFERENCE FROM external_reference_schema (external_source);
  REFERENCE FROM group_schema;
  REFERENCE FROM location_schema;
  REFERENCE FROM person_organization_schema;
  REFERENCE FROM qualifications_schema;
  REFERENCE FROM security_classification_schema;
  REFERENCE FROM support_resource_schema;

  TYPE mrs_role_select = SELECT BASED_ON role_select WITH (
    action_assignment,
    action_request_assignment,
    approval_assignment,
    certification_assignment,
    contract_assignment,
    document_reference,
    effectivity_assignment,
    external_referent_assignment,
    group_assignment,
    name_assignment,
    security_classification_assignment);
  END_TYPE;

  TYPE attribute_type = SELECT (label, text);
  END_TYPE;

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
    assigned_action : action;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY action_method_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_method : action_method;
    role : action_method_role;
  END_ENTITY;

  ENTITY action_method_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_request : versioned_action_request;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
    assigned_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY attribute_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    attribute_name : label;
    role : classification_role;
  END_ENTITY;

  ENTITY attribute_value_assignment
    ABSTRACT SUPERTYPE;
    attribute_name : label;
    attribute_value : attribute_type;
    role : attribute_value_role;
  END_ENTITY;

  ENTITY attribute_value_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
    assigned_certification : certification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    role : classification_role;
  END_ENTITY;

  ENTITY classification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
    assigned_contract : contract;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
    assigned_date_and_time : date_and_time;
    role : date_time_role;
  END_ENTITY;

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
    assigned_date : date;
    role : date_role;
  END_ENTITY;

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
    assigned_document : document;
    source : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY document_usage_constraint_assignment
    ABSTRACT SUPERTYPE;
    assigned_document_usage : document_usage_constraint;
    role : document_usage_role;
  END_ENTITY;

  ENTITY document_usage_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY effectivity_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity : effectivity;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY effectivity_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity_assignment : effectivity_assignment;
    role : effectivity_context_role;
  END_ENTITY;

  ENTITY effectivity_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY event_occurrence_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence : event_occurrence;
    role : event_occurrence_role;
  END_ENTITY;

  ENTITY event_occurrence_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence_assignment : event_occurrence_assignment;
    role : event_occurrence_context_role;
  END_ENTITY;

  ENTITY experience_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience : experience;
    role : experience_role;
  END_ENTITY;

  ENTITY experience_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience_type : experience_type;
    role : experience_type_role;
  END_ENTITY;

  ENTITY experience_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
    source : external_source;
  END_ENTITY;

  ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
    assigned_group : group;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
    assigned_id : identifier;
    role : identification_role;
  END_ENTITY;

  ENTITY identification_assignment_relationship;
    name : label;
    description : OPTIONAL text;
    relating_identification_assignment : identification_assignment;
    related_identification_assignment : identification_assignment;
  END_ENTITY;

  ENTITY identification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY library_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (external_referent_assignment);
    frame_of_reference : library_context;
  UNIQUE
    UR1: frame_of_reference;
  END_ENTITY;

  ENTITY location_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_location : location;
    role : location_role;
  END_ENTITY;

  ENTITY location_representation_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    represented_location : location;
    role : location_representation_role;
  END_ENTITY;

  ENTITY location_representation_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_organization : organization;
    role : organization_role;
  END_ENTITY;

  ENTITY organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_organization_type : organization_type;
    role : organization_type_role;
  END_ENTITY;

  ENTITY organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project_assignment
    ABSTRACT SUPERTYPE;
    assigned_organizational_project : organizational_project;
    role : organizational_project_role;
  END_ENTITY;

  ENTITY organizational_project_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_person_and_organization : person_and_organization;
    role : person_and_organization_role;
  END_ENTITY;

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
    assigned_person : person;
    role : person_role;
  END_ENTITY;

  ENTITY person_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type : person_type;
    role : person_type_role;
  END_ENTITY;

  ENTITY person_type_definition_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type_definition : person_type_definition;
    role : person_type_definition_role;
  END_ENTITY;

  ENTITY person_type_definition_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization : position_in_organization;
    role : position_in_organization_role;
  END_ENTITY;

  ENTITY position_in_organization_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization_type : position_in_organization_type;
    role : position_in_organization_type_role;
  END_ENTITY;

  ENTITY position_in_organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification : qualification;
    role : qualification_role;
  END_ENTITY;

  ENTITY qualification_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification_type : qualification_type;
    role : qualification_type_role;
  END_ENTITY;

  ENTITY qualification_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_security_classification : security_classification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY time_assignment
    ABSTRACT SUPERTYPE;
    assigned_time : local_time;
    role : time_role;
  END_ENTITY;

  ENTITY time_interval_assignment
    ABSTRACT SUPERTYPE;
    assigned_time_interval : time_interval;
    role : time_interval_role;
  END_ENTITY;

  FUNCTION acyclic_identification_assignment_relationship (relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: material_property_definition_schema.exp,v 1.4 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6751

EXPRESS Source:
ISO 10303-45 ed3 Material and other engineering properties - Material property definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed3 Material and other engineering properties - Material property definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA material_property_definition_schema '{iso standard 10303 part(45) version(3) object(1) material_property_definition_schema(1)}';

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM qualified_measure_schema
     (maths_value_with_unit);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

TYPE characterized_product_composition_value = SELECT
  (maths_value_with_unit,
   measure_with_unit);
END_TYPE;

ENTITY material_designation; 
  name       		: label;
  definitions 	: SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       		: label;
  description 	: text;
  designation 	: material_designation;
  property    	: characterized_material_property;
END_ENTITY;
ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class        	       : label;
  constituent_amount  	: SET [1:?] OF characterized_product_composition_value;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

ENTITY property_definition_relationship;
  name                       		: label;
  description                 	: text;
  relating_property_definition 	: property_definition;
  related_property_definition  	: property_definition;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;
  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;
  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality
  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));
  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema
(*
$Id: material_property_representation_schema.exp,v 1.4 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6751

EXPRESS Source:
ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA material_property_representation_schema '{iso standard 10303 part(45) version(1) object(1) material_property_representation_schema(2)}';

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

ENTITY data_environment;
  name       		: label;
  description 	: text;
  elements    	: SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    		: label;
  description              	: text;
  relating_data_environment 	: data_environment;
  related_data_environment  	: data_environment;
END_ENTITY;

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;
END_SCHEMA;		-- material_property_representation_schema
(*
$Id: mathematical_functions_schema.exp,v 1.22 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8315

EXPRESS Source:
ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA mathematical_functions_schema '{iso standard 10303 part(50) version(3) object(1) mathematical_functions_schema(1)}';

REFERENCE FROM iso13584_generic_expressions_schema     -- ISO 13584-20
  (binary_generic_expression,
   environment,
   generic_expression,
   generic_literal,
   generic_variable,
   multiple_arity_generic_expression,
   simple_generic_expression,
   unary_generic_expression,
   variable_semantics);

REFERENCE FROM iso13584_expressions_schema             -- ISO 13584-20
  (abs_function                   AS abs_expression,
   acos_function                  AS acos_expression,
   and_expression,
   asin_function                  AS asin_expression,
   atan_function                  AS atan_expression,
   binary_boolean_expression,
   binary_function_call           AS binary_numeric_call_expression,
   binary_numeric_expression,
   boolean_defined_function       AS boolean_defined_expression,
   boolean_expression,
   boolean_literal,
   boolean_variable,
   comparison_equal,
   comparison_expression,
   comparison_greater,
   comparison_greater_equal,
   comparison_less,
   comparison_less_equal,
   comparison_not_equal,
   concat_expression,
   cos_function                   AS cos_expression,
   defined_function               AS defined_expression,
   div_expression,
   equals_expression,
   exp_function                   AS exp_expression,
   expression,
   format_function                AS format_expression,
   index_expression,
   int_literal,
   int_numeric_variable,
   int_value_function             AS int_value_expression,
   integer_defined_function       AS integer_defined_expression,
   interval_expression,
   length_function                AS length_expression,
   like_expression,
   literal_number,
   log_function                   AS log_expression,
   log10_function                 AS log10_expression,
   log2_function                  AS log2_expression,
   maximum_function               AS maximum_expression,
   minimum_function               AS minimum_expression,
   minus_expression,
   minus_function                 AS unary_minus_expression,
   mod_expression,
   mult_expression,
   multiple_arity_boolean_expression,
   multiple_arity_function_call   AS multiple_arity_numeric_call_expression,
   multiple_arity_numeric_expression,
   not_expression,
   numeric_defined_function       AS numeric_defined_expression,
   numeric_expression,
   numeric_variable,
   odd_function                   AS odd_expression,
   or_expression,
   plus_expression,
   power_expression,
   real_defined_function          AS real_defined_expression,
   real_literal,
   real_numeric_variable,
   simple_boolean_expression,
   simple_numeric_expression,
   simple_string_expression,
   sin_function                   AS sin_expression,
   slash_expression,
   sql_mappable_defined_function  AS sql_mappable_defined_expression,
   square_root_function           AS square_root_expression,
   string_defined_function        AS string_defined_expression,
   string_expression,
   string_literal,
   string_variable,
   substring_expression,
   tan_function                   AS tan_expression,
   unary_boolean_expression,
   unary_function_call            AS unary_numeric_call_expression,
   unary_numeric_expression,
   value_function                 AS value_expression,
   variable,
   xor_expression);

REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (label,
   text);

REFERENCE FROM external_reference_schema               -- ISO 10303-41
  (externally_defined_item);

REFERENCE FROM geometry_schema                         -- ISO 10303-42
  (curve,
   dimension_of,
   point,
   surface,
   volume);

CONSTANT
  schema_prefix : STRING := 'MATHEMATICAL_FUNCTIONS_SCHEMA.';
  the_integers        : elementary_space := make_elementary_space(es_integers);
  the_reals           : elementary_space := make_elementary_space(es_reals);
  the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);
  the_numbers         : elementary_space := make_elementary_space(es_numbers);
  the_logicals        : elementary_space := make_elementary_space(es_logicals);
  the_booleans        : elementary_space := make_elementary_space(es_booleans);
  the_strings         : elementary_space := make_elementary_space(es_strings);
  the_binarys         : elementary_space := make_elementary_space(es_binarys);
  the_maths_spaces    : elementary_space := make_elementary_space(es_maths_spaces);
  the_generics        : elementary_space := make_elementary_space(es_generics);
  the_empty_space : finite_space := make_finite_space([]);
  the_nonnegative_reals         : real_interval_from_min :=
    make_real_interval_from_min(0.0, closed);
  the_zero_one_interval         : finite_real_interval := make_finite_real_interval(
    0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval := make_finite_real_interval(
    0.0, closed, pi, closed);
  the_neg1_one_interval         : finite_real_interval := make_finite_real_interval(
    -1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval := make_finite_real_interval(
    -0.5*pi, closed, 0.5*pi, closed);
  the_negpi_pi_interval         : finite_real_interval := make_finite_real_interval(
    -pi, open, pi, closed);
  the_zero_tuple_space : listed_product_space := make_listed_product_space([]);
  the_tuples           : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_generics);
  the_integer_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_integers);
  the_real_tuples      : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_reals);
  the_complex_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_complex_numbers);
  the_empty_maths_tuple      : maths_tuple := [];
  the_empty_maths_value      : maths_value := the_empty_maths_tuple;
  the_empty_atom_based_tuple : atom_based_tuple := [];
  the_empty_atom_based_value : atom_based_value := the_empty_atom_based_tuple;
END_CONSTANT;
TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;
TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;
TYPE zero_or_one = nonnegative_integer;
WHERE in_range: (SELF = 0) OR (SELF = 1);
END_TYPE;
TYPE one_or_two = positive_integer;
WHERE in_range: (SELF = 1) OR (SELF = 2);
END_TYPE;
TYPE maths_number = NUMBER;
END_TYPE;
TYPE maths_real = REAL;
END_TYPE;
TYPE maths_integer = INTEGER;
END_TYPE;
TYPE maths_logical = LOGICAL;
END_TYPE;
TYPE maths_boolean = BOOLEAN;
END_TYPE;
TYPE maths_string = STRING;
END_TYPE;
TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_simple_atom = SELECT
  (maths_number,
   maths_real,
   maths_integer,
   maths_logical,
   maths_boolean,
   maths_string,
   maths_binary);
END_TYPE;
TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;
TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;
TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;
TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;
TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;
TYPE maths_expression = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
END_TYPE;
TYPE maths_function_select = SELECT
  (maths_function,
   elementary_function_enumerators);
END_TYPE;
TYPE input_selector = positive_integer;
END_TYPE;
TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;
TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;
TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;
TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;
TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and, ef_or, ef_not, ef_xor,
   ef_negate_i, ef_add_i, ef_subtract_i, ef_multiply_i, ef_divide_i, ef_mod_i,
   ef_exponentiate_i, ef_eq_i, ef_ne_i, ef_gt_i, ef_lt_i, ef_ge_i, ef_le_i,
   ef_abs_i, ef_max_i, ef_min_i, ef_if_i,
   ef_negate_r, ef_reciprocal_r, ef_add_r, ef_subtract_r, ef_multiply_r,
   ef_divide_r, ef_mod_r, ef_exponentiate_r, ef_exponentiate_ri,
   ef_eq_r, ef_ne_r, ef_gt_r, ef_lt_r, ef_ge_r, ef_le_r, ef_abs_r,
   ef_max_r, ef_min_r, ef_acos_r, ef_asin_r, ef_atan2_r, ef_cos_r, ef_exp_r,
   ef_ln_r, ef_log2_r, ef_log10_r, ef_sin_r, ef_sqrt_r, ef_tan_r, ef_if_r,
   ef_form_c, ef_rpart_c, ef_ipart_c,
   ef_negate_c, ef_reciprocal_c, ef_add_c, ef_subtract_c, ef_multiply_c,
   ef_divide_c, ef_exponentiate_c, ef_exponentiate_ci, ef_eq_c, ef_ne_c,
   ef_conjugate_c, ef_abs_c, ef_arg_c, ef_cos_c, ef_exp_c, ef_ln_c, ef_sin_c,
   ef_sqrt_c, ef_tan_c, ef_if_c,
   ef_subscript_s, ef_eq_s, ef_ne_s, ef_gt_s, ef_lt_s, ef_ge_s, ef_le_s,
   ef_subsequence_s, ef_concat_s, ef_size_s, ef_format, ef_value, ef_like, ef_if_s,
   ef_subscript_b, ef_eq_b, ef_ne_b, ef_gt_b, ef_lt_b, ef_ge_b, ef_le_b,
   ef_subsequence_b, ef_concat_b, ef_size_b, ef_if_b,
   ef_subscript_t, ef_eq_t, ef_ne_t, ef_concat_t, ef_size_t,
   ef_entuple, ef_detuple, ef_insert, ef_remove, ef_if_t,
   ef_sum_it, ef_product_it,
   ef_add_it, ef_subtract_it, ef_scalar_mult_it, ef_dot_prod_it,
   ef_sum_rt, ef_product_rt,
   ef_add_rt, ef_subtract_rt, ef_scalar_mult_rt, ef_dot_prod_rt, ef_norm_rt,
   ef_sum_ct, ef_product_ct,
   ef_add_ct, ef_subtract_ct, ef_scalar_mult_ct, ef_dot_prod_ct, ef_norm_ct,
   ef_if, ef_ensemble, ef_member_of);
END_TYPE;
TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;
TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;
TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;
TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;
TYPE maths_enum_atom = SELECT
  (elementary_space_enumerators,
   ordering_type,
   lower_upper,
   symmetry_type,
   elementary_function_enumerators,
   open_closed,
   space_constraint_type,
   repackage_options,
   extension_options);
END_TYPE;
TYPE dotted_express_identifier = STRING;
WHERE syntax: dotted_identifiers_syntax(SELF);
END_TYPE;
TYPE express_identifier = dotted_express_identifier;
WHERE syntax: dot_count(SELF) = 0;
END_TYPE;
TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;
TYPE tuple_space = SELECT
  (product_space,
   extended_tuple_space);
END_TYPE;
TYPE maths_space_or_function = SELECT
  (maths_space,
   maths_function);
END_TYPE;
TYPE real_interval = SELECT
  (real_interval_from_min,
   real_interval_to_max,
   finite_real_interval,
   elementary_space);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR
    (SELF\elementary_space.space_id = es_reals);
END_TYPE;
ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;
ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;
ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;

ENTITY complex_number_literal_polar
  SUBTYPE OF (complex_number_literal);
  modulus  : REAL;  -- was radius
  argument : REAL; -- was angle 
DERIVE
  SELF\complex_number_literal.real_part : REAL := modulus * cos(argument);
  SELF\complex_number_literal.imag_part : REAL := modulus * sin(argument);
WHERE
  WR1: modulus  >= 0;
  WR2: {0 <= argument <= 2*PI};
END_ENTITY;

ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;
ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;
ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;
ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF REAL;
END_ENTITY;
ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;
ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;
ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;
ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;
ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_reals);
END_ENTITY;
ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_integers);
END_ENTITY;
ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_booleans);
END_ENTITY;
ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_strings);
END_ENTITY;
ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1:?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression
    := [convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;
ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (elementary_space,
                                finite_integer_interval,
                                integer_interval_from_min,
                                integer_interval_to_max,
                                finite_real_interval,
                                real_interval_from_min,
                                real_interval_to_max,
                                cartesian_complex_number_region,
                                polar_complex_number_region,
                                finite_space,
                                uniform_product_space,
                                listed_product_space,
                                extended_tuple_space,
                                function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;
ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;
ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;
ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;
ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;
ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;
ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;
ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;
ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR
       min_exists(imag_constraint) OR max_exists(imag_constraint);
END_ENTITY;
ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0*PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open);
END_ENTITY;
ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF (member))
       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;
ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;
ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;
ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : product_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;
ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument  : maths_space;
  range_constraint : space_constraint_type;
  range_argument   : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND
       expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND
       (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT
       member_of(the_empty_space,domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT
       member_of(the_empty_space,range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint,domain_argument) AND
       any_space_satisfies(range_constraint,range_argument));
END_ENTITY;
ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF (finite_function,
                                constant_function,
                                selector_function,
                                elementary_function,
                                restriction_function,
                                repackaging_function,
                                reindexed_array_function,
                                series_composed_function,
                                parallel_composed_function,
                                explicit_table_function,
                                homogeneous_linear_function,
                                general_linear_function,
                                b_spline_basis,
                                b_spline_function,
                                rationalize_function,
                                partial_derivative_function,
                                definite_integral_function,
                                abstracted_expression_function,
                                expression_denoted_function,
                                imported_point_function,
                                imported_curve_function,
                                imported_surface_function,
                                imported_volume_function,
                                application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range : tuple_space := derive_function_range(SELF);
END_ENTITY;
ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;
ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;
ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;
ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack    : repackage_options;
  output_repack   : repackage_options;
  selected_output : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))));
  WR3: selected_output <= space_dimension( repackage(
       operand.range, output_repack));
END_ENTITY;
ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices : LIST [1:?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(
       SELF\unary_generic_expression.operand));
END_ENTITY;
ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;
ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain  : maths_space_or_function;
  prep_functions : LIST [1:?] OF maths_function;
  final_function : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of generic_expression
    := convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain),
       prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;
ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data,
                                listed_integer_data,
                                listed_logical_data,
                                listed_string_data,
                                listed_complex_number_data,
                                listed_data,
                                externally_listed_data,
                                linearized_table_function,
                                basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1:?] OF positive_integer;
END_ENTITY;
ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF REAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF INTEGER;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_logical_data
  SUBTYPE OF(explicit_table_function, generic_literal);
  values : LIST [1:?] OF LOGICAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF STRING;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2:?] OF REAL;
DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) DIV 2 ];
WHERE
      WR1:
         NOT ODD(SIZEOF(values));
END_ENTITY;
ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1:?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF (QUERY (val <* values | NOT (member_of( val, value_range)))) = 0;
END_ENTITY;
ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;
ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF (standard_table_function,
                       regular_table_function,
                       triangular_matrix,
                       symmetric_matrix,
                       banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first  : integer;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;
ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;
ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1:?] OF INTEGER;
WHERE
  WR1: SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape);
  WR2: extremal_position_check(self);
END_ENTITY;
ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;
ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;
ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] =
       SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = symmetry_type.skew) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_numbers));
  WR4: NOT ((symmetry = symmetry_type.hermitian) OR (symmetry = symmetry_type.skew_hermitian)) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_complex_numbers));
END_ENTITY;
ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : integer;
  above         : integer;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (self\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
  default_entry : maths_value;
  order : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;
ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2:?] OF REAL;
DERIVE
  order          : positive_integer := degree + 1;
  num_basis      : positive_integer := SIZEOF (repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis+1];
END_ENTITY;
ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis : LIST [1:?] OF b_spline_basis;
DERIVE
  coef  : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND
       (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF (basis) <=
       SIZEOF (shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;
ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;
ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables : LIST [1:?] OF input_selector;
  extension : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (derivand.range);
  WR2: partial_derivative_check (derivand.domain, d_variables);
END_ENTITY;
ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1:?] OF maths_variable;
  extension : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space (derivand);
  WR2: space_is_continuum (values_space_of (derivand));
  WR3: SIZEOF (QUERY (vbl <* d_variables | (NOT subspace_of (values_space_of (vbl),
    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))
    )) = 0;
END_ENTITY;
ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration : input_selector;
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (integrand.range);
  WR2: definite_integral_check (integrand.domain, variable_of_integration,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : generic_expression
    := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration : maths_variable
    := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable
    := [variable_of_integration];
WHERE
  WR1: has_values_space (integrand);
  WR2: space_is_continuum (values_space_of (integrand));
  WR3: definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable :=
    remove_first(SELF\multiple_arity_generic_expression.operands);
  expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF (QUERY ( operand <*
       SELF\multiple_arity_generic_expression.operands | NOT (
       has_values_space( operand)))) = 0;
END_ENTITY;
ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr));
END_ENTITY;
ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;
ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;
ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;
FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;
  CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) > 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    -- complex_number_literal, maths_space, or maths_function.
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
END_FUNCTION;  -- all_members_of_es
FUNCTION any_space_satisfies(sc  : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
END_FUNCTION;  -- any_space_satisfies
FUNCTION assoc_product_space(ts1, ts2 : tuple_space) : tuple_space;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender <> factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
END_FUNCTION;  -- assoc_product_space
FUNCTION atan2(y, x : REAL) : REAL;
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x < 0.0 THEN
    IF y < 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
END_FUNCTION;  -- atan2
FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- bool
FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base   : zero_or_one;
                                   shape  : LIST [1:?] OF positive_integer;
                                   order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
  -- The index function is evaluated at (base+shape[i]) when determining the
  -- upper search bound for entries of the last row or column, respectively.
END_FUNCTION;  -- check_sparse_index_domain;
FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base   : zero_or_one;
                                shape  : LIST [1:?] OF positive_integer;
                                order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) <> 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;  -- check_sparse_loc_range;
FUNCTION check_sparse_index_to_loc(index_range, loc_domain : tuple_space) : BOOLEAN;
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND
    (idx_rng_itvl.max <= loc_dmn_itvl.max+1)));
END_FUNCTION;  -- check_sparse_index_to_loc
FUNCTION compare_basis_and_coef(basis : LIST [1:?] OF b_spline_basis;
                                coef  : maths_function) : BOOLEAN;
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) < SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_basis_and_coef
FUNCTION compare_list_and_value(lv : LIST OF GENERIC:G;
                                op : elementary_function_enumerators;
                                v  : GENERIC:G) : BOOLEAN;
  IF NOT EXISTS (lv) OR NOT EXISTS (op) OR NOT EXISTS (v) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF (lv);
    IF NOT compare_values(lv[i], op, v) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_list_and_value
FUNCTION compare_values(v1 : GENERIC:G;
                        op : elementary_function_enumerators;
                        v2 : GENERIC:G) : BOOLEAN;
  -- This algorithm assumes a comparison between "incompatible" types will
  -- produce the indeterminate value (or UNKNOWN?).
  LOCAL
    logl : LOGICAL := UNKNOWN;
  END_LOCAL;
  IF NOT EXISTS (v1) OR NOT EXISTS (op) OR NOT EXISTS (v2) THEN
    RETURN (FALSE);
  END_IF;
  CASE op OF
  ef_eq_i : logl := (v1 = v2);
  ef_ne_i : logl := (v1 <> v2);
  ef_gt_i : logl := (v1 > v2);
  ef_lt_i : logl := (v1 < v2);
  ef_ge_i : logl := (v1 >= v2);
  ef_le_i : logl := (v1 <= v2);
  END_CASE;
  IF EXISTS (logl) THEN
    IF logl = TRUE THEN  RETURN (TRUE);  END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- compare_values
FUNCTION compatible_complex_number_regions(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
END_FUNCTION;  -- compatible_complex_number_regions
FUNCTION compatible_es_values(esval1, esval2 : elementary_space_enumerators) : BOOLEAN;
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
END_FUNCTION;  -- compatible_es_values
FUNCTION compatible_intervals(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- compatible_intervals
FUNCTION compatible_spaces(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n <> SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n > m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
END_FUNCTION;  -- compatible_spaces
FUNCTION composable_sequence(operands : LIST [2:?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- composable_sequence
FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_literal
FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
END_FUNCTION;  -- convert_to_maths_function
FUNCTION convert_to_maths_value(val : GENERIC:G) : maths_value;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- convert_to_maths_value
FUNCTION convert_to_operand(val : maths_value) : generic_expression;
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_operand
FUNCTION convert_to_operands(values : AGGREGATE OF maths_value)
                            : LIST OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands
FUNCTION convert_to_operands_prcmfn(srcdom  : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun  : maths_function_select)
                                   : LIST [2:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands_prcmfn
FUNCTION definite_integral_check(domain   : tuple_space;
                                 vrblint  : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k > dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_check
FUNCTION definite_integral_expr_check(operands : LIST [2:?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) <> nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_expr_check
FUNCTION derive_definite_integral_domain(igrl : definite_integral_function)
                                        : tuple_space;

  -- Internal utility function:
  FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx <= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx <= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix > 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix > 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;
END_FUNCTION;  -- derive_definite_integral_domain
FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators)
                                          : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_domain
FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators)
                                         : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_range
FUNCTION derive_finite_function_domain(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                      : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_domain
FUNCTION derive_finite_function_range(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                     : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_range
FUNCTION derive_function_domain(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_domain
FUNCTION derive_function_range(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
    temp : INTEGER := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_point_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_curve_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_surface_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_volume_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_range
FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
END_FUNCTION;  -- domain_from
FUNCTION dot_count(str : STRING) : INTEGER;
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
END_FUNCTION;  -- dot_count
FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k <= LENGTH (str);
    IF (str[k] <> '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- dotted_identifiers_syntax
FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- drop_numeric_constraints
FUNCTION enclose_cregion_in_pregion(crgn   : cartesian_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z < real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin > a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax < a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax < r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin < 0.0) OR (rmin > r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc <= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc <= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc >= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc >= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc <= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc <= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc >= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc >= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc <= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc <= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc <= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc <= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc >= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc >= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc >= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc >= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_cregion_in_pregion
FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region)
                                   : cartesian_complex_number_region;
  PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a < aitv.min THEN
      -- a+2.0*PI > aitv.min automatically!
      IF a+2.0*PI < aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a < aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) >= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) <= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) >= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) <= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
END_FUNCTION;  -- enclose_pregion_in_cregion
FUNCTION enclose_pregion_in_pregion(prgn   : polar_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min < a < aitv.max} OR {aitv.min < a+2.0*PI < aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc > rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc > rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax < r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax < r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax < r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc >= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc <= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 < rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 < rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc >= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc > rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc > rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc > rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp < r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp < r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc > rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_pregion_in_pregion
FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_cregion_pregion
FUNCTION equal_maths_functions(fun1, fun2 : maths_function) : LOGICAL;
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_functions
FUNCTION equal_maths_spaces(spc1, spc2 : maths_space) : LOGICAL;
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt <> spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) <> SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR
        (fs2.domain_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) <>
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint <> fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR
        (fs2.range_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) <>
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_maths_spaces
FUNCTION equal_maths_values(val1, val2 : maths_value) : LOGICAL;
  FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) <> SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_values
FUNCTION es_subspace_of_es(es1, es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- es_subspace_of_es
FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
END_FUNCTION;  -- expression_is_constant
FUNCTION extract_factors(tspace : tuple_space;
                         m, n   : INTEGER) : tuple_space;
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
END_FUNCTION;  -- extract_factors
FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- extremal_position_check
FUNCTION factor1(tspace : tuple_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor1
FUNCTION factor_space(tspace : tuple_space;
                      idx    : positive_integer) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx <= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx <= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx <= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor_space
FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
END_FUNCTION;  -- free_variables_of
FUNCTION function_applicability(func      : maths_function_select;
                                arguments : LIST [1:?] OF maths_value) : BOOLEAN;
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) <> narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) > narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_applicability
FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_array
FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_table
FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) <> 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;  -- function_is_2d_table
FUNCTION function_is_array(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_array
FUNCTION function_is_table(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_table
FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- has_values_space
FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k    : positive_integer) : LIST OF maths_value;
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k <= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- list_selected_components
FUNCTION make_abstracted_expression_function(
                                    operands : LIST [2:?] OF generic_expression)
                                   : abstracted_expression_function;
  RETURN (abstracted_expression_function()
    || maths_function()
      || generic_expression()
    || quantifier_expression (remove_first (operands))  -- derived
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_abstracted_expression_function
FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_atom_based_literal
FUNCTION make_b_spline_basis(degree         : nonnegative_integer;
                             repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
  RETURN (b_spline_basis (degree, repeated_knots)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_b_spline_basis
FUNCTION make_b_spline_function(coef  : maths_function;
                                bases : LIST [1:?] OF b_spline_basis)
                               : b_spline_function;
  RETURN (b_spline_function (bases)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (coef) );
END_FUNCTION;  -- make_b_spline_function
FUNCTION make_banded_matrix(index_base    : zero_or_one;
                            shape         : LIST [1:?] OF positive_integer;
                            source        : maths_function;
                            first         : INTEGER;
                            default_entry : maths_value;
                            below         : INTEGER;
                            above         : INTEGER;
                            order         : ordering_type) : banded_matrix;
  RETURN (banded_matrix (default_entry, below, above, order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (source) );
END_FUNCTION;  -- make_banded_matrix
FUNCTION make_basic_sparse_matrix(index_base    : zero_or_one;
                                  shape         : LIST [1:?] OF positive_integer;
                                  operands      : LIST [3:3] OF maths_function;
                                  default_entry : maths_value;
                                  order         : ordering_type)
                                 : basic_sparse_matrix;
  RETURN (basic_sparse_matrix (default_entry, order)
    || explicit_table_function (index_base, shape)
      || maths_function()
        || generic_expression()
    || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_basic_sparse_matrix
FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_binary_literal
FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_boolean_literal
FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval)
                                             : cartesian_complex_number_region;
  RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_cartesian_complex_number_region
FUNCTION make_complex_number_literal(rpart, ipart : REAL) : complex_number_literal;
  RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_complex_number_literal
FUNCTION make_constant_function(sole_value   : maths_value;
                                src_of_domn  : maths_space_or_function)
                               : constant_function;
  RETURN (constant_function (sole_value, src_of_domn)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_constant_function
FUNCTION make_cos_expression(operand : numeric_expression) : cos_expression;
  RETURN (cos_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_cos_expression
FUNCTION make_definite_integral_expression(
                                   operands     : LIST [2:4] OF generic_expression;
                                   loinf, upinf : BOOLEAN)
                                          : definite_integral_expression;
  RETURN (definite_integral_expression (loinf, upinf)
    || quantifier_expression ([operands[2]])
      || multiple_arity_generic_expression (operands)
        || generic_expression() );
END_FUNCTION;  -- make_definite_integral_expression
FUNCTION make_definite_integral_function(integrand    : maths_function;
                                         varintg      : input_selector;
                                         loinf, upinf : BOOLEAN)
                                        : definite_integral_function;
  RETURN (definite_integral_function (varintg, loinf, upinf)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (integrand) );
END_FUNCTION;  -- make_definite_integral_function
FUNCTION make_elementary_function(func_id : elementary_function_enumerators)
                                 : elementary_function;
  RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_function
FUNCTION make_elementary_space(space_id : elementary_space_enumerators)
                              : elementary_space;
  RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_space
FUNCTION make_environment(varbl : generic_variable;
                          sem   : variable_semantics) : environment;
  RETURN (environment (varbl, sem) );
END_FUNCTION;  -- make_environment
FUNCTION make_expression_denoted_function(expression : generic_expression)
                                         : expression_denoted_function;
  RETURN (expression_denoted_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (expression) );
END_FUNCTION;  -- make_expression_denoted_function
FUNCTION make_extended_tuple_space(base     : product_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
END_FUNCTION;  -- make_extended_tuple_space
FUNCTION make_finite_function(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                             : finite_function;
  RETURN (finite_function (pairs)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_function
FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_integer_interval
FUNCTION make_finite_real_interval(min    : REAL;
                                   minclo : open_closed;
                                   max    : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_real_interval
FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_space
FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1:?] OF maths_value)
                                  : function_application;
  RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
END_FUNCTION;  -- make_function_application
FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument   : maths_space;
                             range_constraint  : space_constraint_type;
                             range_argument    : maths_space) : function_space;
  RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_function_space
FUNCTION make_general_linear_function(mat       : maths_function;
                                      sum_index : one_or_two)
                                     : general_linear_function;
  RETURN (general_linear_function (sum_index)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (mat) );
END_FUNCTION;  -- make_general_linear_function
FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_int_literal
FUNCTION make_integer_interval_from_min(min : INTEGER)
  : integer_interval_from_min;
  RETURN (integer_interval_from_min (min)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_integer_interval_from_min
FUNCTION make_listed_complex_number_data(index_base : zero_or_one;
                                         values     : LIST [2:?] OF REAL)
                                        : listed_complex_number_data;
  RETURN (listed_complex_number_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)/2])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_complex_number_data
FUNCTION make_listed_data(index_base  : zero_or_one;
                          values      : LIST [2:?] OF maths_value;
                          value_range : maths_space) : listed_data;
  RETURN (listed_data (values, value_range)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_data
FUNCTION make_listed_integer_data(index_base : zero_or_one;
                                  values     : LIST [1:?] OF INTEGER)
                                 : listed_integer_data;
  RETURN (listed_integer_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_integer_data
FUNCTION make_listed_product_space(factors : LIST OF maths_space)
                                  : listed_product_space;
  RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_product_space
FUNCTION make_listed_real_data(index_base : zero_or_one;
                               values     : LIST [1:?] OF REAL)
                              : listed_real_data;
  RETURN (listed_real_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_real_data
FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_logical_literal
FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_enum_literal

FUNCTION make_maths_real_variable(values_space : maths_space;
                                  name         : label) : maths_real_variable;
    
   RETURN (expression() || numeric_expression() || simple_numeric_expression() 
   ||  maths_real_variable() 
    || maths_variable (values_space, name)
      || generic_variable()
        || simple_generic_expression()
          || generic_expression()
    || real_numeric_variable()
      || numeric_variable()
        || variable() );
  END_FUNCTION;

FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value)
                                 : maths_tuple_literal;
  RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_tuple_literal
FUNCTION make_mult_expression(operands : LIST [2:?] OF generic_expression)
                             : mult_expression;
  RETURN (mult_expression()
    || multiple_arity_numeric_expression()
      || numeric_expression()
        || expression()
          || generic_expression()
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_mult_expression
FUNCTION make_parallel_composed_function(srcdom    : maths_space_or_function;
                                         prepfuncs : LIST [2:?] OF maths_function;
                                         finfunc   : maths_function_select)
                                        : parallel_composed_function;
  RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );  -- derived
END_FUNCTION;  -- make_parallel_composed_function
FUNCTION make_partial_derivative_expression(derivand : generic_expression;
                                            dvars    : LIST [1:?] OF maths_variable;
                                            extend   : extension_options)
                                           : partial_derivative_expression;
  RETURN (partial_derivative_expression (dvars, extend)
    || unary_generic_expression (derivand)
      || generic_expression() );
END_FUNCTION;  -- make_partial_derivative_expression
FUNCTION make_partial_derivative_function(derivand : maths_function;
                                          dvars    : LIST [1:?] OF input_selector;
                                          extend   : extension_options)
                                         : partial_derivative_function;
  RETURN (partial_derivative_function (dvars, extend)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (derivand) );
END_FUNCTION;  -- make_partial_derivative_function
FUNCTION make_polar_complex_number_region(centre         : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval)
                                         : polar_complex_number_region;
  RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_polar_complex_number_region
FUNCTION make_rationalize_function(fun : maths_function) : rationalize_function;
  RETURN (rationalize_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (fun) );
END_FUNCTION;  -- make_rationalize_function
FUNCTION make_real_interval_from_min(min    : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_from_min
FUNCTION make_real_interval_to_max(max    : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_to_max
FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_real_literal
FUNCTION make_regular_table_function(index_base : zero_or_one;
                                     shape      : LIST [1:?] OF positive_integer;
                                     operand    : maths_function;
                                     first      : INTEGER;
                                     increments : LIST [1:?] OF INTEGER)
                                    : regular_table_function;
  RETURN (regular_table_function (increments)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_regular_table_function
FUNCTION make_reindexed_array_function(func       : maths_function;
                                       start_idxs : LIST [1:?] OF INTEGER)
                                      : reindexed_array_function;
  RETURN (reindexed_array_function(start_idxs)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (func) );
END_FUNCTION;  -- make_reindexed_array_function
FUNCTION make_repackaging_function(operand         : maths_function;
                                   input_repack    : repackage_options;
                                   output_repack   : repackage_options;
                                   selected_output : nonnegative_integer)
                                  : repackaging_function;
  RETURN (repackaging_function (input_repack, output_repack, selected_output)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (operand) );
END_FUNCTION;  -- make_repackaging_function
FUNCTION make_selector_function(selector    : input_selector;
                                src_of_domn : maths_space_or_function)
                               : selector_function;
  RETURN (selector_function (selector, src_of_domn)
    || maths_function()
       || generic_expression()
    || generic_literal()
       || simple_generic_expression() );
END_FUNCTION;  -- make_selector_function
FUNCTION make_series_composed_function(functions : LIST [2:?] OF maths_function)
                                      : series_composed_function;
  RETURN (series_composed_function()
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (functions) );
END_FUNCTION;  -- make_series_composed_function
FUNCTION make_sin_expression(operand : numeric_expression) : sin_expression;
  RETURN (sin_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_sin_expression
FUNCTION make_standard_table_function(index_base : zero_or_one;
                                      shape      : LIST [1:?] OF positive_integer;
                                      operand    : maths_function;
                                      first      : INTEGER;
                                      order      : ordering_type)
                                     : standard_table_function;
  RETURN (standard_table_function (order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_standard_table_function
FUNCTION make_strict_triangular_matrix(index_base    : zero_or_one;
                                       shape         : LIST [1:?] OF positive_integer;
                                       source        : maths_function;
                                       first         : INTEGER;
                                       default_entry : maths_value;
                                       lo_up         : lower_upper;
                                       order         : ordering_type;
                                       main_diagonal_value : maths_value)
                                      : strict_triangular_matrix;
  RETURN (strict_triangular_matrix (main_diagonal_value)
    || triangular_matrix (default_entry, lo_up, order)
      || linearized_table_function (first)
        || explicit_table_function (index_base, shape)
          || maths_function()
            || generic_expression()
        || unary_generic_expression (source) );
END_FUNCTION;  -- make_strict_triangular_matrix
FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_string_literal
FUNCTION make_unary_minus_expression(operand : numeric_expression)
  : unary_minus_expression;
  RETURN (unary_minus_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_unary_minus_expression
FUNCTION make_uniform_product_space(base     : maths_space;
                                    exponent : positive_integer)
                                   : uniform_product_space;
  RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_uniform_product_space
FUNCTION max_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;  -- max_exists
FUNCTION max_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- max_included
FUNCTION member_of(val : GENERIC:G;
                   spc : maths_space) : LOGICAL;

  -- Trivial function introduced to avoid NIST Fedex compiler error
  FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min <= tmp_int <=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min <= tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min <= tmp_real <
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min < tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min < tmp_real <
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min < tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real < s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) >= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- member_of
FUNCTION min_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;  -- min_exists
FUNCTION min_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- min_included
FUNCTION no_cyclic_domain_reference(ref  : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_domain_reference
FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_space_reference
FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] < lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
END_FUNCTION;  -- number_superspace_of
FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN (make_uniform_product_space (spc, 1));
END_FUNCTION;  -- one_tuples_of
FUNCTION parallel_composed_function_composability_check(
                                      funcs  : LIST OF maths_function;
                                      final  : maths_function_select) : BOOLEAN;
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
END_FUNCTION;  -- parallel_composed_function_composability_check
FUNCTION parallel_composed_function_domain_check(
                                comdom : tuple_space;
                                funcs  : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- parallel_composed_function_domain_check
FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i <= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k > LENGTH (s)) OR
        ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
END_FUNCTION;  -- parse_express_identifier
FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k > dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- partial_derivative_check
FUNCTION real_max(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_max
FUNCTION real_min(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_min
FUNCTION regular_indexing(sub   : LIST OF INTEGER;
                          base  : zero_or_one;
                          shape : LIST [1:?] OF positive_integer;
                          inc   : LIST [1:?] OF INTEGER;
                          first : INTEGER) : INTEGER;
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) <> SIZEOF (inc)) OR (SIZEOF (sub) <> SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
END_FUNCTION;
FUNCTION remove_first(alist : LIST OF GENERIC:GEN) : LIST OF GENERIC:GEN;
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) > 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
END_FUNCTION;  -- remove_first
FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- repackage
FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- shape_of_array
FUNCTION simplify_function_application(expr : function_application) : maths_value;
  FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) >= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) >= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) >= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k < 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <> k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j > k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j < k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j >= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k > j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k < j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t < 0.0) AND (j <> t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k < 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <> s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r > s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r < s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r >= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s > r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s < r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q <> 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p <> 1.0) OR (q <> 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k < 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p <> r) OR (q <> s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <> st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str > st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str < st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str >= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str <> '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str <> '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <> bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin > bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin < bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin >= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) <> 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) <> 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- simplify_function_application
FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
  FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  -- restore_unary
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  -- restore_binary
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  -- restore_mulary
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  -- make_number_literal;
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  -- No simpler expression available
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 > v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 >= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 < v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 <= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 <> v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) > 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) > 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) > 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb < vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb > vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);
END_FUNCTION;  -- simplify_generic_expression
FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin THEN
            zmin := zint;
          END_IF;
          IF zint > zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- simplify_maths_space
FUNCTION simplify_maths_value(val : maths_value) : maths_value;
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
END_FUNCTION;  -- simplify_maths_value
FUNCTION singleton_member_of(spc : maths_space) : maths_value;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- singleton_member_of
FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- space_dimension
FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_continuum
FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_singleton
FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + types[i][n+1:LENGTH(types[i])];
    ELSE
       stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
END_FUNCTION;  -- stripped_typeof
FUNCTION subspace_of(space1, space2 : maths_space) : LOGICAL;
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min>=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max > PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) >= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n < space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of
FUNCTION subspace_of_es(spc : maths_space;
                        es  : elementary_space_enumerators) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of_es
FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1:?] OF generic_variable;
                    vals : LIST [1:?] OF maths_value) : generic_expression;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) <> SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- substitute
FUNCTION values_space_of(expr : generic_expression) : maths_space;
  LOCAL
    e_prefix : STRING := 'ISO13584_EXPRESSIONS_SCHEMA.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);  -- not recognized as a mathematical expression
END_FUNCTION;  -- values_space_of
END_SCHEMA;  -- mathematical_functions_schema
(*
$Id: measure_schema.exp,v 1.26 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Measure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Measure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA measure_schema '{iso standard 10303 part(41) version(7) object(1) measure_schema(15)}';

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_name_value,
   name_attribute,
   name_attribute_select); 
REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context); 

REFERENCE FROM support_resource_schema;    -- ISO 10303-41

  TYPE s_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    derived_unit);
  END_TYPE;

  TYPE absorbed_dose_measure = REAL;
  END_TYPE;

TYPE acceleration_measure = REAL;
  END_TYPE;

  TYPE radioactivity_measure = REAL;
  END_TYPE;

TYPE amount_of_substance_measure = REAL;
  END_TYPE;

  TYPE area_measure = REAL;
  END_TYPE;

  TYPE celsius_temperature_measure = REAL;
  END_TYPE;

  TYPE context_dependent_measure = REAL;
  END_TYPE;

  TYPE count_measure = NUMBER;
  END_TYPE;

  TYPE descriptive_measure = STRING;
  END_TYPE;
  
  TYPE capacitance_measure = REAL;
  END_TYPE;
  
  TYPE dose_equivalent_measure = REAL;
  END_TYPE;

  TYPE electric_charge_measure = REAL;
  END_TYPE;
  
  TYPE electric_current_measure = REAL;
  END_TYPE;

  TYPE conductance_measure = REAL;
  END_TYPE;

  TYPE electric_potential_measure = REAL;
  END_TYPE;
  
  TYPE energy_measure = REAL;
  END_TYPE;  
  
  TYPE force_measure = REAL;
  END_TYPE;  
  
  TYPE frequency_measure = REAL;
  END_TYPE; 
  
  TYPE magnetic_flux_density_measure = REAL;
  END_TYPE;

  TYPE illuminance_measure = REAL;
  END_TYPE;  

  TYPE inductance_measure = REAL;
  END_TYPE;
  
  TYPE length_measure = REAL;
  END_TYPE;

  TYPE luminous_intensity_measure = REAL;
  END_TYPE;

  TYPE luminous_flux_measure = REAL;
  END_TYPE;

  TYPE mass_measure = REAL;
  END_TYPE;

  TYPE measure_value = SELECT 
    (absorbed_dose_measure,
     dose_equivalent_measure,
     radioactivity_measure,
     acceleration_measure,
     amount_of_substance_measure, 
     area_measure, 
     celsius_temperature_measure, 
     context_dependent_measure, 
     count_measure, 
     descriptive_measure, 
     capacitance_measure,
     electric_charge_measure,
     conductance_measure,
     electric_current_measure, 
     electric_potential_measure,
     energy_measure,
     magnetic_flux_density_measure,
     force_measure,
     frequency_measure,
     illuminance_measure,
     inductance_measure,
     length_measure, 
     luminous_flux_measure,
     luminous_intensity_measure, 
     magnetic_flux_measure,
     mass_measure, 
     numeric_measure, 
     non_negative_length_measure,
     parameter_value, 
     plane_angle_measure, 
     positive_length_measure, 
     positive_plane_angle_measure, 
     positive_ratio_measure, 
     power_measure,
     pressure_measure,
     ratio_measure, 
     resistance_measure,
     solid_angle_measure, 
     thermodynamic_temperature_measure, 
     time_measure, 
     velocity_measure,
     volume_measure);
  END_TYPE;

  TYPE magnetic_flux_measure = REAL;
  END_TYPE;

  TYPE non_negative_length_measure = length_measure;
   WHERE
    WR1: SELF >= 0.0;
  END_TYPE;

  TYPE numeric_measure = NUMBER;
  END_TYPE;

  TYPE parameter_value = REAL;
  END_TYPE;

  TYPE plane_angle_measure = REAL;
  END_TYPE;

  TYPE positive_length_measure = non_negative_length_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_plane_angle_measure = plane_angle_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_ratio_measure = ratio_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE power_measure = REAL;
  END_TYPE;

  TYPE pressure_measure = REAL;
  END_TYPE;

  TYPE ratio_measure = REAL;
  END_TYPE;

  TYPE resistance_measure = REAL;
  END_TYPE;

  TYPE si_prefix = ENUMERATION OF (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto);
  END_TYPE;

  TYPE si_unit_name = ENUMERATION OF (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz, newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, tesla, henry, degree_Celsius, lumen, lux, becquerel, gray, sievert);
  END_TYPE;

  TYPE solid_angle_measure = REAL;
  END_TYPE;

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE;

  TYPE time_measure = REAL;
  END_TYPE;

  TYPE unit = SELECT (derived_unit, named_unit);
  END_TYPE;

  TYPE velocity_measure = REAL;
  END_TYPE;
  
  TYPE volume_measure = REAL;
  END_TYPE;

ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY absorbed_dose_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray);  
END_ENTITY;

  ENTITY si_absorbed_dose_unit
     SUBTYPE OF (absorbed_dose_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.gray;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY acceleration_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY acceleration_unit
    SUBTYPE OF (derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

ENTITY radioactivity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY radioactivity_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel);  
END_ENTITY;

  ENTITY si_radioactivity_unit
     SUBTYPE OF (radioactivity_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.becquerel;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY area_unit
   SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
    name : label;
  END_ENTITY;

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
     name : label;
     conversion_factor : measure_with_unit;
  WHERE
    WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY derived_unit
    SUPERTYPE OF (ONEOF(absorbed_dose_unit,
	acceleration_unit,
    radioactivity_unit,
	area_unit,
    capacitance_unit,
	dose_equivalent_unit,
    electric_charge_unit,
    conductance_unit,
    electric_potential_unit,
    energy_unit,
    magnetic_flux_density_unit,
    force_unit,
    frequency_unit,
    illuminance_unit,
    inductance_unit,
    magnetic_flux_unit,
    power_unit,
    pressure_unit,
    resistance_unit,
    velocity_unit,
    volume_unit));
    elements : SET [1:?] OF derived_unit_element;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY derived_unit_element;
    unit : named_unit;
    exponent : REAL;
  END_ENTITY;

  ENTITY dimensional_exponents;
    length_exponent : REAL;
    mass_exponent : REAL;
    time_exponent : REAL;
    electric_current_exponent : REAL;
    thermodynamic_temperature_exponent : REAL;
    amount_of_substance_exponent : REAL;
    luminous_intensity_exponent : REAL;
  END_ENTITY;

  ENTITY capacitance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad);  
  END_ENTITY;

  ENTITY capacitance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_capacitance_unit
     SUBTYPE OF (capacitance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.farad;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY dose_equivalent_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert);  
END_ENTITY;

  ENTITY si_dose_equivalent_unit
     SUBTYPE OF (dose_equivalent_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.sievert;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_charge_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb);  
  END_ENTITY;

  ENTITY electric_charge_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_charge_unit
     SUBTYPE OF (electric_charge_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.coulomb;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
  
  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
  
   ENTITY conductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens);  
  END_ENTITY;

  ENTITY conductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_conductance_unit
     SUBTYPE OF (conductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.siemens;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_potential_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt);  
  END_ENTITY;

  ENTITY electric_potential_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_potential_unit
     SUBTYPE OF (electric_potential_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.volt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY energy_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule);  
  END_ENTITY;

  ENTITY energy_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_energy_unit
     SUBTYPE OF (energy_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.joule;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY magnetic_flux_density_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla);  
  END_ENTITY;

  ENTITY magnetic_flux_density_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_density_unit
     SUBTYPE OF (magnetic_flux_density_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.tesla;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY force_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton);  
  END_ENTITY;

  ENTITY force_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_force_unit
     SUBTYPE OF (force_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.newton;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY frequency_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz);  
  END_ENTITY;

  ENTITY frequency_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_frequency_unit
     SUBTYPE OF (frequency_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.hertz;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
    units : SET [1:?] OF unit;
  END_ENTITY;

  ENTITY illuminance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux);  
  END_ENTITY;

  ENTITY illuminance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_illuminance_unit
     SUBTYPE OF (illuminance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.lux;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY inductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry);  
  END_ENTITY;

  ENTITY inductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_inductance_unit
     SUBTYPE OF (inductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.henry;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY length_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND 
    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.time_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY luminous_flux_unit
    SUBTYPE OF(named_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen);  
  END_ENTITY;

  ENTITY luminous_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
  END_ENTITY;

  ENTITY magnetic_flux_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber);  
  END_ENTITY;

  ENTITY magnetic_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_unit
     SUBTYPE OF (magnetic_flux_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.weber;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF(length_measure_with_unit, 
    mass_measure_with_unit, 
	time_measure_with_unit, 
    electric_current_measure_with_unit, 
	thermodynamic_temperature_measure_with_unit, 
    celsius_temperature_measure_with_unit, 
	amount_of_substance_measure_with_unit, 
    luminous_intensity_measure_with_unit, 
	plane_angle_measure_with_unit, 
    solid_angle_measure_with_unit, 
	area_measure_with_unit, 
	volume_measure_with_unit, 
    ratio_measure_with_unit, 
    acceleration_measure_with_unit,
    capacitance_measure_with_unit,
    electric_charge_measure_with_unit,
    conductance_measure_with_unit,
    electric_potential_measure_with_unit,
    energy_measure_with_unit,
    magnetic_flux_density_measure_with_unit,
    force_measure_with_unit,
    frequency_measure_with_unit,
    illuminance_measure_with_unit,
    inductance_measure_with_unit,
    luminous_flux_measure_with_unit,
    magnetic_flux_measure_with_unit,
    power_measure_with_unit,
    pressure_measure_with_unit,
    resistance_measure_with_unit,
    velocity_measure_with_unit,
	absorbed_dose_measure_with_unit,
    radioactivity_measure_with_unit,
    dose_equivalent_measure_with_unit));
    value_component : measure_value;
    unit_component : unit;
  WHERE
    WR1: valid_units(SELF);
  END_ENTITY;

  ENTITY named_unit
    SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR 
    ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, 
    amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit, 
    solid_angle_unit, ratio_unit));
    dimensions : dimensional_exponents;
  END_ENTITY;

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY power_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt);  
  END_ENTITY;

  ENTITY power_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_power_unit
     SUBTYPE OF (power_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.watt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY pressure_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal);  
  END_ENTITY;

  ENTITY pressure_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_pressure_unit
     SUBTYPE OF (pressure_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.pascal;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY resistance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm);  
  END_ENTITY;

  ENTITY resistance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_resistance_unit
     SUBTYPE OF (resistance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.ohm;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  
  ENTITY si_unit
    SUBTYPE OF (named_unit);
    prefix : OPTIONAL si_prefix;
    name : si_unit_name;
  DERIVE
    SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
  WHERE
    WR1: NOT(('MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF)) AND
             (SIZEOF(USEDIN(SELF,'MEASURE_SCHEMA.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
            (prefix = si_prefix.kilo); 
  END_ENTITY;

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY time_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY velocity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
  WHERE
   WR1: 'MEASURE_SCHEMA.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY volume_unit
    SUBTYPE OF (derived_unit);
   WHERE
     WR1: derive_dimensional_exponents(SELF) = 
          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  FUNCTION derive_dimensional_exponents (x : unit):dimensional_exponents;
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);
  END_FUNCTION;

  FUNCTION dimensions_for_si_unit (n : si_unit_name):dimensional_exponents;
    CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;
  END_FUNCTION;

  FUNCTION valid_units (m : measure_with_unit):BOOLEAN;
    IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'MEASURE_SCHEMA.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;
END_SCHEMA;
(*
$Id: person_organization_schema.exp,v 1.26 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Person organization schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Person organization schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA person_organization_schema '{iso standard 10303 part(41) version(7) object(1) person_organization_schema(16)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value, 
    get_role, 
    id_attribute, 
    id_attribute_select,
    name_attribute, 
    name_attribute_select,
    object_role, 
    role_association);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  TYPE person_organization_select = SELECT (
    person, 
    organization, 
    person_and_organization);
  END_TYPE;

  TYPE pos_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    person_and_organization_role,
    person_and_organization,
    person_role,
    organization_role,
    organizational_project);
  END_TYPE;
  
  TYPE pos_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    address,
    organizational_project);
  END_TYPE;

  TYPE pos_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    address,
    person_and_organization);
  END_TYPE;

  ENTITY address;
    internal_location : OPTIONAL label;
    street_number : OPTIONAL label;
    street : OPTIONAL label;
    postal_box : OPTIONAL label;
    town : OPTIONAL label;
    region : OPTIONAL label;
    postal_code : OPTIONAL label;
    country : OPTIONAL label;
    facsimile_number : OPTIONAL label;
    telephone_number : OPTIONAL label;
    electronic_mail_address : OPTIONAL label;
    telex_number : OPTIONAL label;
  DERIVE
    name : label := get_name_value(SELF);
    url : identifier := get_id_value(SELF);
  WHERE
    WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
  END_ENTITY;

  ENTITY organization;
    id : OPTIONAL identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organization : organization;
    related_organization : organization;
  END_ENTITY;

  ENTITY organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_organization_type : organization_type;
    related_organization_type : organization_type;
  END_ENTITY;

  ENTITY organizational_address
    SUBTYPE OF (address);
    organizations : SET [1:?] OF organization;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project;
    name : label;
    description : OPTIONAL text;
    responsible_organizations : SET [1:?] OF organization;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organizational_project_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organizational_project : organizational_project;
    related_organizational_project : organizational_project;
  END_ENTITY;

  ENTITY person;
    id : identifier;
    last_name : OPTIONAL label;
    first_name : OPTIONAL label;
    middle_names : OPTIONAL LIST [1:?] OF label;
    prefix_titles : OPTIONAL LIST [1:?] OF label;
    suffix_titles : OPTIONAL LIST [1:?] OF label;
  WHERE
    WR1: EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY;

  ENTITY person_and_organization;
    the_person : person;
    the_organization : organization;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_and_organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_definition;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    formation : person_type_definition_formation;
  END_ENTITY;

  ENTITY person_type_definition_formation;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    of_person_type : person_type;
  END_ENTITY;

  ENTITY person_type_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_person_type_definition : person_type_definition;
    related_person_type_definition : person_type_definition;
  END_ENTITY;

  ENTITY personal_address
    SUBTYPE OF (address);
    people : SET [1:?] OF person;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_position_in_organization : position_in_organization;
    related_position_in_organization : position_in_organization;
  END_ENTITY;

  ENTITY position_in_organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organization_type_relationship (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_person_type_definition_relationship (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_position_in_organization_relationship (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*

ISO 10303 TC184/SC4/WG12 N6141

EXPRESS Source:
ISO 10303-46 ed3 Visual presentation - Presentation appearance schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-46 ed3 Visual presentation - Presentation appearance schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA presentation_appearance_schema '{iso standard 10303 part(46) version(3) object(1) presentation_appearance_schema(3)}';
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     b_spline_curve, 
     cartesian_point,
     composite_curve,
     curve,
     geometric_representation_item,
     point,
     polyline, 
     vector);

REFERENCE FROM topology_schema
    (topological_representation_item);

REFERENCE FROM group_schema
  (group);

REFERENCE FROM measure_schema
    (descriptive_measure,
     length_measure,
     measure_with_unit,
     plane_angle_measure,
     positive_length_measure,
     ratio_measure,
     positive_ratio_measure);

REFERENCE FROM presentation_organization_schema
     (area_dependent_annotation_representation,
      presentation_area,
      presentation_layer_assignment,
      presentation_layer_usage,
      presentation_representation,
      presentation_set,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation);

REFERENCE FROM presentation_definition_schema
    (annotation_curve_occurrence,
     annotation_fill_area,
     annotation_symbol_occurrence,
     annotation_text_with_delineation,
     symbol_representation_with_blanking_box);

REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol_outline,
     character_glyph_symbol_stroke,
     colour);

REFERENCE FROM representation_schema
    (founded_item,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     bag_to_set);
 

  TYPE approximation_method = ENUMERATION OF
    (chordal_deviation,
     chordal_length);
  END_TYPE;

  TYPE box_characteristic_select = SELECT
    (box_height,
     box_width,
     box_slant_angle,
     box_rotate_angle);
  END_TYPE;

  TYPE box_height = positive_ratio_measure;
  END_TYPE;

  TYPE box_rotate_angle = plane_angle_measure;
  END_TYPE;

  TYPE  box_slant_angle = plane_angle_measure;
  END_TYPE;

  TYPE box_width = positive_ratio_measure;
  END_TYPE;

  TYPE character_spacing_select = SELECT
    (length_measure,
     ratio_measure,
     measure_with_unit,
     descriptive_measure,
     pre_defined_character_spacing);
  END_TYPE;

  TYPE character_style_select = SELECT
    (character_glyph_style_stroke,
     character_glyph_style_outline,
     text_style_for_defined_font);
  END_TYPE;

  TYPE curve_font_or_scaled_curve_font_select = SELECT
    (curve_style_font_select,
     curve_style_font_and_scaling);
  END_TYPE;

  TYPE curve_or_annotation_curve_occurrence = SELECT
    (curve,
     annotation_curve_occurrence);
  END_TYPE;

  TYPE curve_or_render = SELECT
    (curve_style,
     curve_style_rendering);
  END_TYPE;

  TYPE curve_style_font_select = SELECT
    (curve_style_font,
     pre_defined_curve_font,
     externally_defined_curve_font);
  END_TYPE;

  TYPE curve_tolerance_deviation = positive_length_measure;
  END_TYPE;

  TYPE curve_tolerance_parameter = REAL;
  END_TYPE;

  TYPE direction_count_select = SELECT
    (u_direction_count,
     v_direction_count);
  END_TYPE;

  TYPE fill_style_select = SELECT
    (fill_area_style_colour,
     pre_defined_tile_style,
     externally_defined_tile_style,
     fill_area_style_tiles,
     pre_defined_hatch_style,
     externally_defined_hatch_style,
     fill_area_style_hatching);
  END_TYPE;

  TYPE fill_area_style_tile_shape_select = SELECT
    (fill_area_style_tile_curve_with_style,
     fill_area_style_tile_coloured_region,
     fill_area_style_tile_symbol_with_style,
     pre_defined_tile,
     externally_defined_tile);
  END_TYPE;

  TYPE hiding_or_blanking_select = SELECT
    (presentation_area,
     presentation_view,
     product_data_representation_view,
     annotation_fill_area,
     area_dependent_annotation_representation,
     view_dependent_annotation_representation,
     annotation_text_with_delineation,
     character_glyph_symbol_stroke,
     character_glyph_symbol_outline,
     symbol_representation_with_blanking_box);
  END_TYPE;

  TYPE invisibility_context = EXTENSIBLE GENERIC_ENTITY SELECT 
    (presentation_layer_usage,
     presentation_representation,
     presentation_set);
  END_TYPE;

  TYPE invisible_item = EXTENSIBLE GENERIC_ENTITY SELECT 
    (styled_item,
     presentation_layer_assignment,
     representation);
  END_TYPE;

  TYPE marker_select = SELECT
    (marker_type,
     pre_defined_marker);
  END_TYPE;

  TYPE marker_type = ENUMERATION OF
    (dot,
     x,
     plus,
     asterisk,
     ring,
     square,
     triangle);
  END_TYPE;

  TYPE null_style = ENUMERATION OF
    (null);
  END_TYPE;

  TYPE presentation_style_select = SELECT
    (pre_defined_presentation_style,
     point_style,
     curve_style,
     surface_style_usage,
     symbol_style,
     fill_area_style,
     text_style,
     approximation_tolerance,
     externally_defined_style,
     null_style);
  END_TYPE;

  TYPE product_or_presentation_space = ENUMERATION OF
    (product_shape_space,
     presentation_area_space);
  END_TYPE;

  TYPE rendering_properties_select = SELECT
    (surface_style_reflectance_ambient,
     surface_style_transparent);
  END_TYPE;

  TYPE shading_curve_method = ENUMERATION OF
    (constant_colour,
     linear_colour);
  END_TYPE;

  TYPE shading_surface_method = ENUMERATION OF
    (constant_shading,
     colour_shading,
     dot_shading,
     normal_shading);
  END_TYPE;

  TYPE size_select  = SELECT
    (positive_length_measure,
     measure_with_unit,
     descriptive_measure,
     pre_defined_size);
  END_TYPE;

  TYPE squared_or_rounded = ENUMERATION OF
    (squared,
     rounded);
  END_TYPE;

  TYPE style_context_select = SELECT
    (group,
     presentation_layer_assignment,
     presentation_set,
     representation,
     representation_item,
     representation_relationship);
  END_TYPE;

  TYPE styled_item_target = SELECT
    (geometric_representation_item,
     mapped_item,
     representation,
     topological_representation_item);
  END_TYPE;

  TYPE surface_side = ENUMERATION OF
    (positive,
     negative,
     both);
  END_TYPE;

  TYPE surface_side_style_select = SELECT
    (surface_side_style,
     pre_defined_surface_side_style);
  END_TYPE;

  TYPE surface_style_element_select = SELECT
    (surface_style_fill_area,
     surface_style_boundary,
     surface_style_silhouette,
     surface_style_segmentation_curve,
     surface_style_control_grid,
     surface_style_parameter_line,
     surface_style_rendering);
  END_TYPE;

  TYPE surface_tolerance_deviation = positive_length_measure;
  END_TYPE;

  TYPE surface_tolerance_parameter = REAL;
  END_TYPE;

  TYPE symbol_style_select = SELECT
    (symbol_element_style,
     symbol_colour);
  END_TYPE;


  TYPE text_justification = label;
  END_TYPE;

  TYPE tolerance_deviation_select = SELECT
    (curve_tolerance_deviation,
     surface_tolerance_deviation);
  END_TYPE;

  TYPE tolerance_parameter_select = SELECT
    (curve_tolerance_parameter,
     surface_tolerance_parameter);
  END_TYPE;

  TYPE tolerance_select = SELECT
    (approximation_tolerance_deviation,
     approximation_tolerance_parameter);
  END_TYPE;

  TYPE u_direction_count = INTEGER;
    WHERE
      WR1: SELF > 1;
  END_TYPE;

  TYPE v_direction_count = INTEGER;
    WHERE
      WR1: SELF > 1;
  END_TYPE;

  ENTITY approximation_tolerance
    SUBTYPE OF (founded_item);
      tolerance : tolerance_select;
  END_ENTITY;

  ENTITY approximation_tolerance_deviation
    SUBTYPE OF (founded_item);
      tessellation_type : approximation_method;
      tolerances        : SET [1:2] OF tolerance_deviation_select;
      definition_space  : product_or_presentation_space;
    WHERE
      WR1: (HIINDEX(SELF.tolerances) = 1)
            XOR
        (TYPEOF(SELF.tolerances[1]) <> TYPEOF(SELF.tolerances[2]));
  END_ENTITY;

  ENTITY approximation_tolerance_parameter
    SUBTYPE OF (founded_item);
      tolerances : SET [1:2] OF tolerance_parameter_select;
    WHERE
      WR1: (HIINDEX (SELF.tolerances) = 1 )
             XOR
        (TYPEOF (SELF.tolerances[1]) <> TYPEOF (SELF.tolerances[2]));
  END_ENTITY;

  ENTITY character_glyph_style_outline
    SUBTYPE OF (founded_item);
      outline_style : curve_style;
  END_ENTITY;

  ENTITY character_glyph_style_outline_with_characteristics
    SUBTYPE OF (character_glyph_style_outline);
      characteristics : fill_area_style;
  END_ENTITY;

  ENTITY character_glyph_style_stroke
    SUBTYPE OF (founded_item);
      stroke_style : curve_style;
  END_ENTITY;

  ENTITY context_dependent_invisibility
    SUBTYPE OF (invisibility);
      presentation_context : invisibility_context;
  END_ENTITY;

  ENTITY context_dependent_over_riding_styled_item
    SUBTYPE OF(over_riding_styled_item);
      style_context : LIST[1:?] OF style_context_select;
    WHERE
      WR1: 
(SIZEOF(QUERY(sc <* SELF.style_context | 'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(sc)))= 1) OR
(SIZEOF(QUERY(sc <* SELF.style_context |
     ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(sc))
  OR ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(sc)) ))
  = SIZEOF(style_context));     
  END_ENTITY;

  ENTITY curve_style
    SUBTYPE OF (founded_item);
      name         : label;
      curve_font   : OPTIONAL curve_font_or_scaled_curve_font_select;
      curve_width  : OPTIONAL size_select;
      curve_colour : OPTIONAL colour;
  WHERE
    WR1: EXISTS(curve_font) OR EXISTS(curve_width) OR EXISTS(curve_colour);
  END_ENTITY;

  ENTITY curve_style_curve_pattern
    SUBTYPE OF (geometric_representation_item);
      pattern        : annotation_curve_occurrence;
      pattern_length : positive_length_measure;
  END_ENTITY;

  ENTITY curve_style_curve_pattern_set
    SUBTYPE OF (curve_style_font, 
                geometric_representation_item);
      pattern_set : SET [1:?] OF curve_style_curve_pattern;
  END_ENTITY;

  ENTITY curve_style_font
    SUBTYPE OF (founded_item);
      name         : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
  END_ENTITY;

  ENTITY curve_style_font_and_scaling
    SUBTYPE OF (founded_item);
      name               : label;
      curve_font         : curve_style_font_select;
      curve_font_scaling : REAL;
  END_ENTITY;

  ENTITY curve_style_font_pattern
    SUBTYPE OF (founded_item);
      visible_segment_length   : positive_length_measure;
      invisible_segment_length : positive_length_measure;
  END_ENTITY;

  ENTITY curve_style_rendering;
    rendering_method     : shading_curve_method;
    rendering_properties : surface_rendering_properties;
  END_ENTITY;

  ENTITY curve_style_wide
    SUBTYPE OF (curve_style_font);
      interior_style : fill_area_style;
  END_ENTITY;

  ENTITY curve_style_with_ends_and_corners
    SUBTYPE OF (curve_style);
      curve_ends    : squared_or_rounded;
      curve_corners : squared_or_rounded;
  WHERE
    WR1: EXISTS(curve_width);
  END_ENTITY;

  ENTITY curve_style_with_extension
    SUBTYPE OF (curve_style);
      curve_extensions   : length_measure;
  WHERE
    WR1: EXISTS(curve_width);
  END_ENTITY;

  ENTITY draughting_pre_defined_curve_font
    SUBTYPE OF (pre_defined_curve_font);
    WHERE
      WR1: SELF.name IN
        ['continuous',
         'chain',
         'chain double dash',
         'dashed',
         'dotted'];
  END_ENTITY;

  ENTITY externally_defined_curve_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_hatch_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY externally_defined_style
    SUBTYPE OF (externally_defined_item, founded_item);
  END_ENTITY;

  ENTITY externally_defined_tile
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_tile_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY fill_area_style
    SUBTYPE OF (founded_item);
      name        : label;
      fill_styles : SET [1:?] OF fill_style_select;
    WHERE
      WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'PRESENTATION_APPEARANCE_SCHEMA.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
  END_ENTITY;

  ENTITY fill_area_style_colour;
    name        : label;
    fill_colour : colour;
  END_ENTITY;

  ENTITY fill_area_style_hatching
    SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance         : curve_style;
      start_of_next_hatch_line      : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start                 : cartesian_point;
      hatch_line_angle              : plane_angle_measure;
  END_ENTITY;

  ENTITY fill_area_style_tile_coloured_region
    SUBTYPE OF (geometric_representation_item);
      closed_curve  : curve_or_annotation_curve_occurrence;
      region_colour : colour;
    WHERE
      WR1: (NOT('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (closed_curve))) OR 
        ('GEOMETRY_SCHEMA.CIRCLE' IN TYPEOF (closed_curve)) OR 
        ('GEOMETRY_SCHEMA.ELLIPSE' IN TYPEOF (closed_curve)) OR 
        ( ('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\b_spline_curve.closed_curve = TRUE) ) OR 
        ( ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\composite_curve.closed_curve = TRUE) ) OR 
        ( ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\polyline.points[LOINDEX(closed_curve\polyline.points)] = 
                  closed_curve\polyline.points[HIINDEX(closed_curve\polyline.points)]) );
  END_ENTITY;

  ENTITY fill_area_style_tile_curve_with_style
    SUBTYPE OF (geometric_representation_item);
      styled_curve : annotation_curve_occurrence;
  END_ENTITY;

  ENTITY fill_area_style_tile_symbol_with_style
    SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
  END_ENTITY;

  ENTITY fill_area_style_tiles
    SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale   : positive_ratio_measure;
  END_ENTITY;

  ENTITY invisibility;
    invisible_items : SET [1:?] OF invisible_item;
  END_ENTITY;

  ENTITY occlusion_precedence;
      higher_precedence : hiding_or_blanking_select;
      lower_precedence  : hiding_or_blanking_select;
      occlusion_context : representation;
    WHERE
      WR1: acyclic_occlusion_precedence (SELF, [SELF.lower_precedence]);
  END_ENTITY;

  ENTITY one_direction_repeat_factor
    SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
  END_ENTITY;

  ENTITY over_riding_styled_item
    SUBTYPE OF (styled_item);
      over_ridden_style : styled_item;
  END_ENTITY;

  ENTITY point_style
    SUBTYPE OF (founded_item);
      name          : label;
      marker        : marker_select;
      marker_size   : size_select;
      marker_colour : colour;
  END_ENTITY;

  ENTITY pre_defined_character_spacing
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_curve_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_hatch_style
    SUBTYPE OF (pre_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY pre_defined_marker
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_presentation_style
    SUBTYPE OF (founded_item, pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_size
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_surface_side_style
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_tile
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_tile_style
    SUBTYPE OF (pre_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY presentation_style_assignment
    SUBTYPE OF (founded_item);
      styles : SET [1:?] OF presentation_style_select;
    WHERE
      WR1: SIZEOF (QUERY (style1 <* SELF.styles |
           NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['PRESENTATION_APPEARANCE_SCHEMA.' + 
                       'SURFACE_STYLE_USAGE',
                       'PRESENTATION_APPEARANCE_SCHEMA.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
      WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
      WR3: SIZEOF (QUERY (style1 <* SELF.styles |
         ('PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF (style1)) AND 
         (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           ('PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF (style2)) AND 
           ((style1\surface_style_usage.side = both) OR 
           (style2\surface_style_usage.side = both) OR 
           (style1\surface_style_usage.side = style2\surface_style_usage.side)) )) > 0))) = 0;
  END_ENTITY;

  ENTITY presentation_style_by_context
    SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
  END_ENTITY;

  ENTITY symbol_colour;
    colour_of_symbol : colour;
  END_ENTITY;

  ENTITY symbol_element_style
    SUBTYPE OF (founded_item);
      style_of_symbol : presentation_style_assignment;
    WHERE
      WR1: SIZEOF (QUERY ( style <* SELF.style_of_symbol.styles |
           'PRESENTATION_APPEARANCE_SCHEMA.SYMBOL_STYLE' IN
           TYPEOF (style))) = 0;
      WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
                'PRESENTATION_STYLE_BY_CONTEXT' IN
              TYPEOF (SELF.style_of_symbol)
           );
  END_ENTITY;

  ENTITY symbol_style
    SUBTYPE OF (founded_item);
      name            : label; 
      style_of_symbol : symbol_style_select;
  END_ENTITY;

  ENTITY styled_item
    SUBTYPE OF (representation_item);
      styles :  SET [1:?] OF presentation_style_assignment;
      item   :  styled_item_target; 
    WHERE
      WR1: (SIZEOF(SELF.styles) = 1)
               XOR
         (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
      WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM' IN TYPEOF(item));
      WR3: ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) OR
           ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item)) OR
           ('PRESENTATION_APPEARANCE_SCHEMA.CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM' IN TYPEOF(SELF));
  END_ENTITY;

  ENTITY surface_rendering_properties;
    rendered_colour : colour;
  END_ENTITY;

  ENTITY surface_side_style
    SUBTYPE OF (founded_item);
      name   : label;
      styles : SET [1:7] OF surface_style_element_select;
    WHERE
      WR1: SIZEOF(QUERY( style1 <* SELF.styles |
           SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
           )) = 0;
  END_ENTITY;

  ENTITY surface_style_boundary
    SUBTYPE OF (founded_item);
      style_of_boundary : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_control_grid
    SUBTYPE OF (founded_item);
      style_of_control_grid : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_fill_area
    SUBTYPE OF (founded_item);
      fill_area : fill_area_style;
  END_ENTITY;

  ENTITY surface_style_parameter_line
    SUBTYPE OF (founded_item);
      style_of_parameter_lines : curve_or_render;
      direction_counts         : SET [1:2] OF direction_count_select;
    WHERE
      WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
         (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient;
    ambient_reflectance : REAL;
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient_diffuse
    SUBTYPE OF (surface_style_reflectance_ambient);
      diffuse_reflectance : REAL;
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient_diffuse_specular
    SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
      specular_reflectance : REAL;
      specular_exponent    : REAL;
      specular_colour      : colour;
  END_ENTITY;

  ENTITY surface_style_rendering;
    rendering_method : shading_surface_method;
    surface_colour   : colour;
  END_ENTITY;

  ENTITY surface_style_rendering_with_properties
    SUBTYPE OF (surface_style_rendering);
      properties : SET [1:2] OF rendering_properties_select;
    WHERE
      WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
         (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
  END_ENTITY;

  ENTITY surface_style_segmentation_curve
    SUBTYPE OF (founded_item);
      style_of_segmentation_curve : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_silhouette
    SUBTYPE OF (founded_item);
      style_of_silhouette : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_transparent;
      transparency : REAL;
    WHERE
      WR1: {0.0 <= transparency <= 1.0};
  END_ENTITY;

  ENTITY surface_style_usage
    SUBTYPE OF (founded_item);
      side  : surface_side;
      style : surface_side_style_select;
  END_ENTITY;

  ENTITY text_style
    SUBTYPE OF (founded_item);
      name                 : label;
      character_appearance : character_style_select;
  END_ENTITY;

  ENTITY text_style_for_defined_font;
    text_colour : colour;
  END_ENTITY;

  ENTITY text_style_with_box_characteristics
    SUBTYPE OF (text_style);
      characteristics : SET [1:4] OF box_characteristic_select;
    WHERE
      WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
           SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
           )) = 0;
  END_ENTITY;

  ENTITY text_style_with_justification
    SUBTYPE OF (text_style);
      justification : text_justification;
  END_ENTITY;

  ENTITY text_style_with_mirror
    SUBTYPE OF (text_style);
      mirror_placement : axis2_placement;
  END_ENTITY;

  ENTITY text_style_with_spacing
    SUBTYPE OF (text_style);
      character_spacing : character_spacing_select;
  END_ENTITY;

  ENTITY two_direction_repeat_factor
    SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
  END_ENTITY;

  SUBTYPE_CONSTRAINT founded_item_subtypes FOR founded_item;
    ONEOF (approximation_tolerance,
      approximation_tolerance_deviation,
      approximation_tolerance_parameter,
      character_glyph_style_outline,
      character_glyph_style_stroke,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      curve_style_font_pattern,
      externally_defined_style,
      fill_area_style,
      point_style,
      pre_defined_presentation_style,
      presentation_style_assignment,
      surface_side_style,
      surface_style_boundary,
      surface_style_control_grid,
      surface_style_fill_area,
      surface_style_parameter_line,
      surface_style_segmentation_curve,
      surface_style_silhouette,
      surface_style_usage,
      symbol_element_style,
      symbol_style,
      text_style);
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT pas_geometric_representation_item_subtypes FOR geometric_representation_item;  
    (ONEOF ( 
     curve, 
     curve_style_curve_pattern, 
     curve_style_curve_pattern_set ,
     externally_defined_hatch_style,
     externally_defined_tile_style,  
     fill_area_style_hatching,
     fill_area_style_tile_coloured_region,
     fill_area_style_tile_curve_with_style, 
     fill_area_style_tile_symbol_with_style, 
     fill_area_style_tiles, 
     one_direction_repeat_factor,
     point, 
     pre_defined_hatch_style,  
     pre_defined_tile_style, 
     vector)); 
  END_SUBTYPE_CONSTRAINT; 

  FUNCTION acyclic_occlusion_precedence
       ( relation : occlusion_precedence;
     set_of_lower : SET OF hiding_or_blanking_select ) : BOOLEAN;
    LOCAL
      x : SET OF occlusion_precedence;
      local_set_of_lower : SET OF hiding_or_blanking_select;
    END_LOCAL;
    REPEAT i:=1 TO HIINDEX(set_of_lower);
      IF relation.higher_precedence :=: set_of_lower[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set (USEDIN ( relation.higher_precedence,
                   'PRESENTATION_APPEARANCE_SCHEMA.'+
           'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
    local_set_of_lower := set_of_lower + relation.higher_precedence;
    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_occlusion_precedence(x[i] ,
                                     local_set_of_lower) THEN
            RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA; 
(*
$Id: presentation_definition_schema.exp,v 1.19 2014/03/04 00:30:38 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6141

EXPRESS Source:
ISO 10303-46 ed3 Visual presentation - Presentation definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-46 ed3 Visual presentation - Presentation definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA presentation_definition_schema '{iso standard 10303 part(46) version(2) object(1) presentation_definition_schema(2)}';

REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometric_model_schema (
	geometric_curve_set);

REFERENCE FROM geometry_schema
    (axis2_placement,
     b_spline_curve,
     composite_curve,
     curve,
     geometric_representation_item,
     point,
     polyline
     );

REFERENCE FROM measure_schema
    (positive_ratio_measure);

REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM presentation_organization_schema
    (annotation_representation_select);

REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol,
     planar_box,
     planar_extent,
     font_select,
     text_font);

REFERENCE FROM representation_schema
    (item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     text,
     bag_to_set);

  TYPE annotation_symbol_occurrence_item = SELECT (
    annotation_symbol,
    defined_symbol);
  END_TYPE;

  TYPE curve_or_curve_set = SELECT (
    curve,
    geometric_curve_set);
  END_TYPE;

  TYPE defined_glyph_select = SELECT
    (pre_defined_character_glyph,
     externally_defined_character_glyph);
  END_TYPE;

  TYPE defined_symbol_select = SELECT
    (pre_defined_symbol,
     externally_defined_symbol);
  END_TYPE;

  TYPE text_alignment = label;
  END_TYPE;

  TYPE text_delineation = label;
  END_TYPE;

  TYPE text_or_character = SELECT
    (annotation_text,
     annotation_text_character,
     defined_character_glyph,
     composite_text,
     text_literal);
  END_TYPE;

  TYPE text_path = ENUMERATION OF
    (left,
     right,
     up,
     down);
  END_TYPE;

  TYPE annotation_table_occurrence_item = SELECT(
    annotation_table,
    defined_table);
  END_TYPE;

  TYPE annotation_text_occurrence_item = SELECT(
    text_literal,
    annotation_text,
    annotation_text_character,
    defined_character_glyph,
    composite_text);
  END_TYPE;

  TYPE presentable_text = STRING;
    WHERE
      WR1: control_characters_free(SELF);
  END_TYPE;

  TYPE text_string_representation_item = SELECT(
    text_literal,
    annotation_text,
    annotation_text_character,
    defined_character_glyph,
    composite_text,
    axis2_placement);
  END_TYPE;

  ENTITY annotation_curve_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : curve_or_curve_set;
  END_ENTITY;

  ENTITY annotation_fill_area
    SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
    WHERE
      WR1: (SELF\geometric_representation_item.dim = 3) OR (SIZEOF (QUERY (curve <* SELF.boundaries |
          NOT (
              ('GEOMETRY_SCHEMA.CIRCLE' IN TYPEOF (curve)) OR
              ('GEOMETRY_SCHEMA.ELLIPSE' IN TYPEOF (curve)) OR
              ( ('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (curve))
                   AND (curve\b_spline_curve.closed_curve = TRUE) ) OR
              ( ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF (curve))
                   AND (curve\composite_curve.closed_curve = TRUE) ) OR
              ( ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (curve))
                   AND (curve\polyline.points[LOINDEX(curve\polyline.points)] =
                        curve\polyline.points[HIINDEX(curve\polyline.points)]) )
              ) )) = 0);
  END_ENTITY;

  ENTITY annotation_fill_area_occurrence
    SUBTYPE OF (annotation_occurrence);
      fill_style_target     : point;
      SELF\styled_item.item : annotation_fill_area;
  END_ENTITY;

  ENTITY annotation_occurrence
    SUPERTYPE OF (ONEOF(annotation_point_occurrence,
                        annotation_curve_occurrence,
                        annotation_fill_area_occurrence,
                        annotation_text_occurrence,
                        annotation_symbol_occurrence))
    SUBTYPE OF (styled_item);
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
             TYPEOF (SELF);
      WR2: SIZEOF (QUERY (reps <* using_representations(SELF) |
        NOT('PRESENTATION_ORGANIZATION_SCHEMA.ANNOTATION_REPRESENTATION_SELECT' IN TYPEOF(reps)))) = 0;
  END_ENTITY;

  ENTITY annotation_occurrence_relationship;
    name                           : label;
    description                    : text;
    relating_annotation_occurrence : annotation_occurrence;
    related_annotation_occurrence  : annotation_occurrence;
  END_ENTITY;

  ENTITY annotation_point_occurrence
    SUBTYPE OF (annotation_occurrence);
    SELF\styled_item.item : point;
  END_ENTITY;

  ENTITY annotation_symbol
    SUBTYPE OF(mapped_item);
      SELF\mapped_item.mapping_source : symbol_representation_map;
      SELF\mapped_item.mapping_target : symbol_target;
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
  END_ENTITY;

  ENTITY annotation_symbol_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : annotation_symbol_occurrence_item;
  END_ENTITY;

  ENTITY annotation_table
    SUBTYPE OF(annotation_symbol);
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
          TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  END_ENTITY;

  ENTITY annotation_table_occurrence
    SUBTYPE OF (annotation_symbol_occurrence);
      SELF\styled_item.item : annotation_table_occurrence_item;
  END_ENTITY;

  ENTITY annotation_text
    SUBTYPE OF (mapped_item);
      SELF\mapped_item.mapping_target : axis2_placement;
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.TEXT_STRING_REPRESENTATION' IN
        TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
      WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
        TYPEOF( SELF);
  END_ENTITY;

  ENTITY annotation_text_character
    SUBTYPE OF (mapped_item);
      alignment                       : text_alignment;
      SELF\mapped_item.mapping_target : axis2_placement;
    WHERE
      WR1: 'PRESENTATION_RESOURCE_SCHEMA.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
      WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
  END_ENTITY;

  ENTITY annotation_text_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : annotation_text_occurrence_item;
  END_ENTITY;

  ENTITY annotation_text_with_associated_curves
    SUBTYPE OF (annotation_text);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY annotation_text_with_blanking_box
    SUBTYPE OF (annotation_text);
      blanking : planar_box;
  END_ENTITY;

  ENTITY annotation_text_with_delineation
    SUBTYPE OF (annotation_text);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY annotation_text_with_extent
    SUBTYPE OF (annotation_text);
      extent : planar_extent;
  END_ENTITY;

  ENTITY composite_text
    SUBTYPE OF (geometric_representation_item);
      collected_text : SET[2:?] of text_or_character;
    WHERE
      WR1: acyclic_composite_text( SELF, SELF.collected_text);
  END_ENTITY;

  ENTITY composite_text_with_associated_curves
    SUBTYPE OF (composite_text);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY composite_text_with_blanking_box
    SUBTYPE OF (composite_text);
      blanking : planar_box;
  END_ENTITY;

  ENTITY composite_text_with_delineation
    SUBTYPE OF (composite_text);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY composite_text_with_extent
    SUBTYPE OF (composite_text);
      extent : planar_extent;
  END_ENTITY;

  ENTITY defined_character_glyph
    SUBTYPE OF(geometric_representation_item);
      definition : defined_glyph_select;
      placement  : axis2_placement;
  END_ENTITY;

  ENTITY defined_symbol
    SUBTYPE OF(geometric_representation_item);
      definition : defined_symbol_select;
      target     : symbol_target;
  END_ENTITY;

  ENTITY defined_table
    SUBTYPE OF(defined_symbol);
  END_ENTITY;

  ENTITY externally_defined_character_glyph
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_symbol
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY pre_defined_character_glyph
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_symbol
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY symbol_representation
    SUBTYPE OF (representation);
  END_ENTITY;

  ENTITY symbol_representation_map
    SUBTYPE OF (representation_map);
      SELF\representation_map.mapped_representation : symbol_representation;
      SELF\representation_map.mapping_origin        : axis2_placement;
  WHERE
    WR1: SIZEOF(
           QUERY(mi <* SELF\representation_map.map_usage | NOT('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
         ) = 0;
  END_ENTITY;

  ENTITY symbol_representation_relationship
    SUBTYPE OF (representation_relationship_with_transformation);
      SELF\representation_relationship.rep_1 : symbol_representation;
      SELF\representation_relationship.rep_2 : symbol_representation;
    WHERE
      WR1: acyclic_symbol_representation_relationship (SELF,
                                                     [SELF\representation_relationship.
                                                           rep_2]);
  END_ENTITY;

  ENTITY symbol_representation_with_blanking_box
    SUBTYPE OF (symbol_representation);
      blanking : planar_box;
    WHERE
      WR1: item_in_context (SELF.blanking, SELF\representation.context_of_items);
  END_ENTITY;

  ENTITY symbol_target
    SUBTYPE OF (geometric_representation_item);
      placement         : axis2_placement;
      x_scale           : positive_ratio_measure;
      y_scale           : positive_ratio_measure;
  END_ENTITY;

  ENTITY table_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_1') |
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr))
            )) = 0) AND
            (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                      'REPRESENTATION_RELATIONSHIP.REP_2') |
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr))
            )) = 0);
  END_ENTITY;

  ENTITY table_record_field_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                     'REPRESENTATION_RELATIONSHIP.REP_2')) > 0)
                        OR
           (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                                   'REPRESENTATION_MAP.'+
                                                   'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                                 'MAPPED_ITEM.'+
                                                 'MAPPING_SOURCE') |
            SIZEOF(QUERY( rep <* using_representations (mi) |
                                          'PRESENTATION_DEFINITION_SCHEMA.'+
                                          'TABLE_RECORD_REPRESENTATION' IN
                                          TYPEOF (rep))) > 0
            )) > 0))
               > 0);
  END_ENTITY;

  ENTITY table_record_field_representation_with_clipping_box
    SUBTYPE OF (table_record_field_representation);
      clipping_box : planar_box;
    WHERE
      WR1: item_in_context (SELF.clipping_box,
                            SELF\representation.context_of_items);
  END_ENTITY;

  ENTITY table_record_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                'REPRESENTATION_RELATIONSHIP.REP_2')) > 0)
                        OR
           (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                                   'REPRESENTATION_MAP.'+
                                                   'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                                 'MAPPED_ITEM.'+
                                                 'MAPPING_SOURCE') |
	        SIZEOF(QUERY( rep <* using_representations (mi) |
	                             'PRESENTATION_DEFINITION_SCHEMA.'+
	                              'TABLE_REPRESENTATION' IN
	                              TYPEOF (rep))) > 0

            )) > 0))
               > 0);
      WR2: (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_1') |
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr))
            )) = 0) AND
            (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                 'REPRESENTATION_RELATIONSHIP.REP_2') |
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr))
            )) = 0);
  END_ENTITY;

  ENTITY table_representation_relationship
    SUBTYPE OF (symbol_representation_relationship);
    WHERE
      WR1: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1))
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
      WR2: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_1))
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
      WR3: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_1))
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
  END_ENTITY;

  ENTITY table_text_relationship
    SUBTYPE OF (annotation_occurrence_relationship);
      field : table_record_field_representation;
      SELF\annotation_occurrence_relationship.relating_annotation_occurrence : annotation_table_occurrence;
      SELF\annotation_occurrence_relationship.related_annotation_occurrence : annotation_text_occurrence;
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE'
         IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence\styled_item.item);
      WR2: field_in_table (SELF.field,
                           SELF\annotation_occurrence_relationship.
                                relating_annotation_occurrence);
  END_ENTITY;

  ENTITY text_literal
    SUBTYPE OF (geometric_representation_item);
      literal   : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path      : text_path;
      font      : font_select;
  END_ENTITY;

  ENTITY text_literal_with_associated_curves
    SUBTYPE OF (text_literal);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY text_literal_with_blanking_box
    SUBTYPE OF (text_literal);
      blanking : planar_box;
  END_ENTITY;

  ENTITY text_literal_with_delineation
    SUBTYPE OF (text_literal);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY text_literal_with_extent
    SUBTYPE OF (text_literal);
      extent : planar_extent;
  END_ENTITY;

  ENTITY text_string_representation
    SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF text_string_representation_item;
    WHERE
      WR1: SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                         'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                         'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
     WR2: SIZEOF (
         QUERY (a2p <*
           QUERY (item <* SELF\representation.items |
             'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <*
               QUERY (item <* SELF\representation.items |
                  'PRESENTATION_DEFINITION_SCHEMA.' +
                  'ANNOTATION_TEXT' IN TYPEOF (item)) |
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <*
               QUERY (item <* SELF\representation.items |
                 'PRESENTATION_DEFINITION_SCHEMA.' +
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) |
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
  END_ENTITY;

  SUBTYPE_CONSTRAINT pds_geometric_representation_item_subtypes FOR geometric_representation_item;
    (ONEOF (
      annotation_fill_area,
      composite_text,
      curve,
      defined_character_glyph,
      defined_symbol,
      point,
      symbol_target,
      text_literal));
  END_SUBTYPE_CONSTRAINT;

  FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;
    LOCAL
      i : INTEGER;
      local_composite_text : SET [0:?] OF composite_text;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_children : SET [0:?] OF text_or_character;
    END_LOCAL;

    local_composite_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

    IF (SIZEOF (local_composite_text) > 0)
      THEN
        REPEAT i := 1 TO HIINDEX (local_composite_text);
          IF (start_composite :=: local_composite_text[i])
            THEN
              RETURN (FALSE);
          END_IF;
        END_REPEAT;
    END_IF;

    local_children := child_text;

    IF (SIZEOF (local_composite_text)) > 0 THEN
      REPEAT i := 1 TO HIINDEX (local_composite_text);
        local_children := local_children +
                          local_composite_text[i].collected_text;
      END_REPEAT;
    END_IF;

    local_annotation_text := QUERY (child <* child_text |
                            ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT'
                             IN TYPEOF (child)));

    IF (SIZEOF (local_annotation_text) > 0) THEN
      REPEAT i := 1 TO HIINDEX (local_annotation_text);
        local_children := local_children +
        QUERY (item <* local_annotation_text[i]\mapped_item.
                       mapping_source.mapped_representation.items |
          SIZEOF(['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                  'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                  TYPEOF(item)) > 0);
      END_REPEAT;
    END_IF;

    IF (local_children :<>: child_text) THEN
      RETURN (acyclic_composite_text (start_composite, local_children));
    ELSE
      RETURN (TRUE);
    END_IF;

  END_FUNCTION;

  FUNCTION acyclic_symbol_representation_relationship
    (relation : symbol_representation_relationship;
     children : SET OF symbol_representation ) : BOOLEAN;
    LOCAL
      x : SET OF symbol_representation_relationship;
      local_children : SET OF symbol_representation;
    END_LOCAL;

    REPEAT i:=1 TO HIINDEX(children);
      IF relation\representation_relationship.rep_1 :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;

    x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.'+ 'REP_2'));
    local_children := children + relation\representation_relationship.rep_1;

    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_symbol_representation_relationship(x[i] ,
                                                  local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;

    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION control_characters_free
    (s : STRING) : BOOLEAN;

    LOCAL
      ch : STRING;
    END_LOCAL;

    REPEAT i:=1 TO LENGTH(s);
      ch := s[i];
      IF (ch = '\x9') OR (ch = '\xA') OR (ch = '\xD') THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION field_in_table (field : table_record_field_representation;
                           table : annotation_table_occurrence): BOOLEAN;
    LOCAL
      table_rep : table_representation;
      symbol_rep_rel_set : SET OF symbol_representation_relationship;
      mapped_item_set : SET OF mapped_item;
      table_record_rep_set : SET OF table_record_representation := [];
    END_LOCAL;

    table_rep := table\styled_item.item\mapped_item.mapping_source.
      mapped_representation;
    mapped_item_set := QUERY(item <* table_rep.items |
                         ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                          TYPEOF(item))
                                   AND
                         ('PRESENTATION_DEFINITION_SCHEMA.'+
                          'TABLE_RECORD_REPRESENTATION' IN
                           TYPEOF(item\mapped_item.mapping_source.
                                      mapped_representation ))
                       );

    REPEAT i := 1 TO HIINDEX(mapped_item_set);
      table_record_rep_set := table_record_rep_set +
             mapped_item_set[i].mapping_source.mapped_representation;
    END_REPEAT;

    symbol_rep_rel_set := bag_to_set (USEDIN(table_rep,
                                 'REPRESENTATION_SCHEMA.'+
                                 'REPRESENTATION_RELATIONSHIP.REP_1'));

    REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
       table_record_rep_set := table_record_rep_set +
                symbol_rep_rel_set[i]\representation_relationship.rep_2;
    END_REPEAT;

    IF SIZEOF(QUERY( table_record_rep <* table_record_rep_set |
                (SIZEOF(QUERY( rep_rel <* USEDIN(table_record_rep,
                              'REPRESENTATION_SCHEMA.'+
                              'REPRESENTATION_RELATIONSHIP.REP_1') |
                         ('PRESENTATION_DEFINITION_SCHEMA.' +
                         'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rep_rel)) AND
                         (rep_rel.rep_2 :=: field)
                         )) > 0)
                         OR
                (SIZEOF(QUERY(item <* table_record_rep.items |
                          ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                           TYPEOF(item))
                                   AND
                          (field :=: item\mapped_item.mapping_source.
                                      mapped_representation )
                           )) > 0)
               )) = 0 THEN
      RETURN(FALSE);
    END_IF;

    RETURN(TRUE);

  END_FUNCTION;

END_SCHEMA;
(*
$Id: presentation_organization_schema.exp,v 1.26 2014/03/04 00:30:39 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6141

EXPRESS Source:
ISO 10303-46 ed3 Visual presentation - Presentation organization schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-46 ed3 Visual presentation - Presentation organization schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA presentation_organization_schema '{iso standard 10303 part(46) version(3) object(1) presentation_organization_schema(1)}';

REFERENCE FROM presentation_resource_schema
   (colour,
    planar_box,
    planar_extent,
    presentation_scaled_placement);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     symbol_representation,
     symbol_representation_relationship);

REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     axis2_placement_2d,
     axis2_placement_3d,
     cartesian_point,
     curve,
     direction,
     dot_product,
     geometric_representation_context,
     geometric_representation_item,
     placement,
     plane
     );

REFERENCE FROM representation_schema
    (founded_item,
     item_defined_transformation,
     item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM measure_schema
   (length_measure,
    positive_ratio_measure,
    positive_plane_angle_measure);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text,
     bag_to_set);

  TYPE area_or_view = SELECT
    (presentation_area,
     presentation_view);
  END_TYPE;

  TYPE camera_model_d3_multi_clipping_interection_select = SELECT (
    camera_model_d3_multi_clipping_union,
    plane);
  END_TYPE;

  TYPE camera_model_d3_multi_clipping_union_select = SELECT (
    camera_model_d3_multi_clipping_intersection,
    plane);
  END_TYPE;

  TYPE central_or_parallel = ENUMERATION OF
    (central,
     parallel);
  END_TYPE;

  TYPE layered_item = SELECT
    (presentation_representation,
     representation_item);
  END_TYPE;

  SUBTYPE_CONSTRAINT pos_geometric_representation_item_subtypes FOR geometric_representation_item;
      (ONEOF (
    camera_model,
    camera_model_d3_multi_clipping_intersection,
    camera_model_d3_multi_clipping_union,
    curve,
    direction,
    light_source));
  END_SUBTYPE_CONSTRAINT;

  TYPE presentation_representation_select = SELECT
    (presentation_representation,
     presentation_set);
  END_TYPE;

  TYPE presentation_size_assignment_select = SELECT
    (presentation_view,
     presentation_area,
     area_in_set);
  END_TYPE;

  TYPE annotation_representation_select = EXTENSIBLE SELECT (
    area_dependent_annotation_representation,
    presentation_area,
    presentation_view,
    symbol_representation,
    view_dependent_annotation_representation);
  END_TYPE;

  TYPE area_dependent_annotation_representation_item = SELECT (
    annotation_occurrence,
    axis2_placement);
  END_TYPE;

  TYPE product_data_representation_view_item = SELECT (
    camera_image,
    axis2_placement);
  END_TYPE;

  TYPE view_dependent_annotation_representation_item = SELECT (
    annotation_occurrence,
    axis2_placement);
  END_TYPE;

  ENTITY area_dependent_annotation_representation
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET[1:?] OF area_dependent_annotation_representation_item;
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items |
        ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |
            SIZEOF(QUERY( rep <* using_representations (mi) |
                                           'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                           'PRESENTATION_AREA' IN
                                           TYPEOF (rep))) > 0
            )) > 0))
            > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |
            SIZEOF(QUERY( rep <* using_representations (mi) |
                                      NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                          'PRESENTATION_AREA' IN
                                          TYPEOF (rep)))) > 0
            )) > 0))
            = 0);
  END_ENTITY;

  ENTITY area_in_set;
    area   : presentation_area;
    in_set : presentation_set;
  END_ENTITY;

  ENTITY background_colour
    SUBTYPE OF (colour);
      presentation : area_or_view;
    UNIQUE
      UR1:  presentation;
  END_ENTITY;

  ENTITY camera_image
    SUPERTYPE OF(ONEOF(camera_image_2d_with_scale,
  	  camera_image_3d_with_scale))
    SUBTYPE OF (mapped_item);
      SELF\mapped_item.mapping_source : camera_usage;
      SELF\mapped_item.mapping_target : planar_box;
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
        IN TYPEOF (SELF);
  END_ENTITY;

  ENTITY camera_image_2d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale : positive_ratio_measure := (SELF\mapped_item.mapping_target\planar_extent.size_in_x)/
      (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window\planar_extent.size_in_x);
    WHERE
      WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D2' IN TYPEOF(SELF\mapped_item.mapping_source.mapping_origin));
      WR2: aspect_ratio (SELF\mapped_item.mapping_target) = aspect_ratio (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window);
      WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window_clipping;
  END_ENTITY;

  ENTITY camera_image_3d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
           planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
           mapping_origin\camera_model_d3.perspective_of_volume.view_window.
           size_in_x));
    WHERE
      WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D3'
         IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
      WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
           aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
           camera_model_d3.perspective_of_volume.view_window);
      WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.front_plane_clipping
           AND
           SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_volume_sides_clipping;
      WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
      WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_y > 0);
      WR6: ('GEOMETRY_SCHEMA.' +
            'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement))
           AND NOT ('GEOMETRY_SCHEMA.' +
           'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement));
  END_ENTITY;

  ENTITY camera_model
    ABSTRACT
    SUPERTYPE OF (ONEOF(camera_model_d2, camera_model_d3))
    SUBTYPE OF (geometric_representation_item);
    WHERE
      WR1: (SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                  'ITEM_DEFINED_TRANSFORMATION.' +
                                  'TRANSFORM_ITEM_1')) +
            SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                  'REPRESENTATION_MAP.MAPPING_ORIGIN'))
            ) > 0;
      WR2: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                              'STYLED_ITEM.ITEM')) = 0;
  END_ENTITY;

  ENTITY camera_model_d2
    SUBTYPE OF (camera_model);
      view_window          : planar_box;
      view_window_clipping : BOOLEAN;
    WHERE
      WR1: SELF\geometric_representation_item.dim = 2;
  END_ENTITY;

  ENTITY camera_model_d2_shape_clipping
    SUBTYPE OF (camera_model_d2);
      shape_clipping : curve;
  END_ENTITY;

  ENTITY camera_model_d3
    SUBTYPE OF (camera_model);
      view_reference_system : axis2_placement_3d;
      perspective_of_volume : view_volume;
    WHERE
      WR1: SELF\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY camera_model_d3_multi_clipping
    SUBTYPE OF (camera_model_d3);
      shape_clipping : SET [1:?] OF camera_model_d3_multi_clipping_interection_select;
  END_ENTITY;

  ENTITY camera_model_d3_multi_clipping_union
    SUBTYPE OF (geometric_representation_item);
      shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_union_select;
  END_ENTITY;

  ENTITY camera_model_d3_multi_clipping_intersection
    SUBTYPE OF (geometric_representation_item);
      shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_interection_select;
  END_ENTITY;

  ENTITY camera_model_d3_with_hlhsr
    SUBTYPE OF (camera_model_d3);
      hidden_line_surface_removal : BOOLEAN;
  END_ENTITY;

  ENTITY camera_model_with_light_sources
    SUBTYPE OF (camera_model_d3);
      sources : SET [1:?] OF light_source;
  END_ENTITY;

  ENTITY camera_usage
    SUBTYPE OF (representation_map);
      SELF\representation_map.mapping_origin : camera_model;
    WHERE
      WR1: NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
          IN TYPEOF(SELF\representation_map.mapped_representation));
  END_ENTITY;

  ENTITY graphical_transformation
    SUBTYPE OF (item_defined_transformation);
      SELF\item_defined_transformation.transform_item_1 : axis2_placement_2d;
      SELF\item_defined_transformation.transform_item_2 : presentation_scaled_placement;
  END_ENTITY;

  ENTITY light_source
    SUPERTYPE OF (ONEOF(light_source_ambient,
                        light_source_directional,
                        light_source_positional,
                        light_source_spot))
    SUBTYPE OF (geometric_representation_item);
      light_colour : colour;
    WHERE
      WR1: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                              'STYLED_ITEM.ITEM')) = 0;
  END_ENTITY;

  ENTITY light_source_ambient
    SUBTYPE OF (light_source);
  END_ENTITY;

  ENTITY light_source_directional
    SUBTYPE OF (light_source);
      orientation : direction;
  END_ENTITY;

  ENTITY light_source_positional
    SUBTYPE OF (light_source);
      position             : cartesian_point;
      constant_attenuation : REAL;
      distance_attenuation : REAL;
  END_ENTITY;

  ENTITY light_source_spot
    SUBTYPE OF (light_source);
      position               : cartesian_point;
      orientation            : direction;
      concentration_exponent : REAL;
      constant_attenuation   : REAL;
      distance_attenuation   : REAL;
      spread_angle           : positive_plane_angle_measure;
  END_ENTITY;

  ENTITY presentation_area
    SUBTYPE OF (presentation_representation);
    WHERE
      WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                                 'AREA_IN_SET.AREA') |
             SIZEOF (USEDIN (ais, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                  'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
            (SIZEOF (USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                   'PRESENTATION_SIZE.UNIT')) =1));
  END_ENTITY;

  ENTITY presentation_layer_assignment;
    name           : label;
    description    : text;
    assigned_items : SET [1:?] OF layered_item;
  END_ENTITY;

  ENTITY presentation_layer_usage;
      assignment   : presentation_layer_assignment;
      presentation : presentation_representation;
    UNIQUE
      UR1: assignment, presentation;
  END_ENTITY;

  ENTITY presentation_representation
    SUPERTYPE OF (ONEOF(area_dependent_annotation_representation,
      presentation_area,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation))
    SUBTYPE OF (representation);
      SELF\representation.context_of_items : geometric_representation_context;
    WHERE
      WR1: SELF\representation.
           context_of_items\geometric_representation_context.
           coordinate_space_dimension = 2;
      WR2: ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN TYPEOF (SELF))
           OR
           (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
           OR
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |
           SIZEOF(QUERY( rep <* using_representations (mi) |
                                        'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                        'PRESENTATION_REPRESENTATION' IN
                                        TYPEOF (rep))) > 0
           )) > 0))
           > 0);
  END_ENTITY;

  ENTITY presentation_representation_relationship
    SUBTYPE OF (representation_relationship_with_transformation);
      SELF\representation_relationship.rep_1                                       : presentation_representation;
      SELF\representation_relationship.rep_2                                       : presentation_representation;
      SELF\representation_relationship_with_transformation.transformation_operator : graphical_transformation;
    WHERE
      WR1: acyclic_presentation_representation_relationship (SELF,
           [SELF\representation_relationship.rep_2]);
      WR2: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (SELF\representation_relationship.rep_1))
           AND
           NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRODUCT_DATA_REPRESENTATION_VIEW',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION'] *
           TYPEOF (SELF\representation_relationship.rep_2)) = 0));
      WR3: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW'
           IN TYPEOF (SELF\representation_relationship.rep_1))
           AND
           NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRESENTATION_AREA',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRESENTATION_VIEW',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'AREA_DEPENDENT_ANNOTATION_REPRESENTATION'] *
                TYPEOF (SELF\representation_relationship.rep_2))=0));
      WR4: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF(SELF\representation_relationship.rep_2)))
              XOR
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA'IN
           TYPEOF(SELF\representation_relationship.rep_1));
      WR5: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.' +
                 'PRODUCT_DATA_REPRESENTATION_VIEW' IN
           (TYPEOF(SELF\representation_relationship.rep_1) +
            TYPEOF(SELF\representation_relationship.rep_2))))
              XOR
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
            TYPEOF(SELF\representation_relationship.rep_1))
              AND
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRODUCT_DATA_REPRESENTATION_VIEW' IN
            TYPEOF(SELF\representation_relationship.rep_2));
  END_ENTITY;

  ENTITY presentation_set;
   INVERSE
     areas : SET [1:?] OF area_in_set FOR in_set;
  END_ENTITY;

  ENTITY presentation_size;
      unit : presentation_size_assignment_select;
      size : planar_box;
    UNIQUE
      UR1: unit;
    WHERE
      WR1: (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
           IN TYPEOF (SELF.unit)) AND
           item_in_context (SELF.size,
                            SELF.unit\representation.context_of_items)
           )
           OR
           (('PRESENTATION_ORGANIZATION_SCHEMA.AREA_IN_SET'
           IN TYPEOF (SELF.unit)) AND
           (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0));
  END_ENTITY;

  ENTITY presentation_view
    SUBTYPE OF (presentation_representation);
  END_ENTITY;

  ENTITY presented_item
    ABSTRACT SUPERTYPE;
  END_ENTITY;

  ENTITY presented_item_representation;
    presentation : presentation_representation_select;
    item         : presented_item;
  END_ENTITY;

  ENTITY product_data_representation_view
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET[1:?] OF product_data_representation_view_item;
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items |
        ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE' IN
         TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |
           SIZEOF(QUERY( rep <* using_representations (mi) |
                                       'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                       'PRESENTATION_VIEW' IN
                                        TYPEOF (rep))) > 0
           )) > 0))
               > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
            NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
            TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |
            SIZEOF(QUERY( rep <* using_representations (mi) |
                                       NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                           'PRESENTATION_VIEW' IN
                                       TYPEOF (rep)))) > 0
            )) > 0))
            = 0);
  END_ENTITY;

  ENTITY representation_item_dependent_layer_assignment
    SUBTYPE OF (presentation_layer_assignment);
      item_context : representation_item;
  END_ENTITY;

  ENTITY view_dependent_annotation_representation
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET [1:?] OF view_dependent_annotation_representation_item;
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items |
        ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR
          (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                            'REPRESENTATION_MAP.'+
                                            'MAPPED_REPRESENTATION') |
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |
           SIZEOF(QUERY( rep <* using_representations (mi) |
                                       'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                       'PRESENTATION_VIEW' IN
                                        TYPEOF (rep))) > 0
           )) > 0))
           > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') |
           NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                                             'REPRESENTATION_MAP.'+
                                             'MAPPED_REPRESENTATION') |
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |
            SIZEOF(QUERY( rep <* using_representations (mi) |
                                      NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                          'PRESENTATION_VIEW' IN
                                      TYPEOF (rep)))) > 0
           )) > 0))
           = 0);
  END_ENTITY;

  ENTITY view_volume
    SUBTYPE OF (founded_item);
      projection_type            : central_or_parallel;
      projection_point           : cartesian_point;
      view_plane_distance        : length_measure;
      front_plane_distance       : length_measure;
      front_plane_clipping       : BOOLEAN;
      back_plane_distance        : length_measure;
      back_plane_clipping        : BOOLEAN;
      view_volume_sides_clipping : BOOLEAN;
      view_window                : planar_box;
    INVERSE
      camera_usages : SET[1:?] OF camera_model_d3 FOR perspective_of_volume;
    WHERE
      WR1:('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN TYPEOF(SELF\view_volume.view_window.placement)) OR
  (dot_product ((representation_item(' ') || geometric_representation_item() || direction([0.0,0.0,1.0])),
    SELF.view_window\planar_box.placement\axis2_placement_3d.p[3] ) = 1.0);
    WR2: view_plane_distance = view_window.placement\placement.location.coordinates[3];
  END_ENTITY;

  RULE symbol_representation_rule
    FOR (presentation_representation_relationship);
    WHERE
      WR1: SIZEOF(QUERY(each_1 <* presentation_representation_relationship  |
                NOT ('PRESENTATION_DEFINITION_SCHEMA.'+
                'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(each_1)) AND
          (SIZEOF(QUERY(each_2 <* [each_1\representation_relationship.rep_1,
                                   each_1\representation_relationship.rep_2] |
          'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)
          )) > 0)
          )) = 0;
  END_RULE;

  FUNCTION acyclic_presentation_representation_relationship
    ( relation : presentation_representation_relationship;
      children : SET OF presentation_representation ) : BOOLEAN;

    LOCAL
      x : SET OF presentation_representation_relationship;
      local_children : SET OF presentation_representation;
    END_LOCAL;

    REPEAT i:=1 TO HIINDEX(children);
      IF relation\representation_relationship.rep_1 :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;

    x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.REP_2'));
    local_children := children + relation\representation_relationship.rep_1;

    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_presentation_representation_relationship
          (x[i] , local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;

    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;
    IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
$Id: presentation_resource_schema.exp,v 1.17 2014/03/04 00:30:39 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6141

EXPRESS Source:
ISO 10303-46 ed3 Visual presentation - Presentation resource schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-46 ed3 Visual presentation - Presentation resource schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA presentation_resource_schema '{iso standard 10303 part(46) version(2) object(1) presentation_resource_schema(4)}';

REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item
     );

REFERENCE FROM measure_schema
    (length_measure,
     positive_length_measure,
     positive_ratio_measure,
     ratio_measure);

REFERENCE FROM presentation_definition_schema
    (annotation_fill_area,
     symbol_representation);

REFERENCE FROM representation_schema
    (item_in_context,
     representation);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);


TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font,
   text_font);
END_TYPE;

TYPE staircase_or_linear = ENUMERATION OF
  (staircase,
   linear);
END_TYPE;


ENTITY character_glyph_font_usage;
  character : generic_character_glyph_symbol;
  font      : text_font;
END_ENTITY;

ENTITY character_glyph_symbol
  SUBTYPE OF (generic_character_glyph_symbol);
  character_box  : planar_extent;
  baseline_ratio : ratio_measure;
DERIVE
  box_height : length_measure := character_box.size_in_y;
WHERE
  WR1: {0.0 <= baseline_ratio <= 1.0};
  WR2: item_in_context(SELF.character_box,
                       SELF\representation.context_of_items);
  WR3: 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;

ENTITY character_glyph_symbol_outline
  SUBTYPE OF (character_glyph_symbol);
  outlines : SET [1:?] OF annotation_fill_area;
WHERE
  WR1: SELF.outlines <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_symbol_stroke
  SUBTYPE OF (character_glyph_symbol);
  strokes : SET [1:?] OF curve;
WHERE
  WR1: SELF.strokes <= SELF\representation.items;
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_associated
  SUBTYPE OF (colour);
  name : label;
  variable_to_be_shown : SET [1:?] OF REAL;
  mapping              : colour_association_table;
END_ENTITY;

ENTITY colour_association_table;
  discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
  interpolation_type           : staircase_or_linear;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_text_font
   SUBTYPE of (pre_defined_text_font);
WHERE
   WR1: SELF.name[1:8] = 'ISO 3098';
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY generic_character_glyph_symbol
  ABSTRACT SUPERTYPE
  SUBTYPE OF (symbol_representation);
END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY presentation_scaled_placement
  SUBTYPE OF (geometric_representation_item);
  placement : axis2_placement;
  scaling   : positive_ratio_measure;
END_ENTITY;

ENTITY state_variable_with_colour;
  state_variable    : REAL;
  associated_colour : colour_specification;
END_ENTITY;

ENTITY text_font;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;

ENTITY text_font_family;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  fonts       : SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;

ENTITY text_font_in_family;
  font   : text_font;
  family : text_font_family;
END_ENTITY;

SUBTYPE_CONSTRAINT prs_geometric_representation_item_subtypes FOR geometric_representation_item;
    (ONEOF (
    curve,
	planar_extent,
	presentation_scaled_placement));
END_SUBTYPE_CONSTRAINT;

END_SCHEMA; -- presentation_resource_schema
(*
$Id: process_property_schema.exp,v 1.3 2014/03/04 00:30:39 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8372

EXPRESS Source:
ISO 10303-49 ed1 Process structure and properties - Process property schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-49 ed1 Process structure and properties - Process property schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA process_property_schema '{iso standard 10303 part(49) version(1) object(1) process_property_schema(3)}';

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema
(*
$Id: product_definition_schema.exp,v 1.18 2014/03/04 00:30:39 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Product definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Product definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_definition_schema '{iso standard 10303 part(41) version(7) object(1) product_definition_schema(17)}';

  REFERENCE FROM application_context_schema (
    product_context, 
    product_definition_context);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    get_name_value, 
    id_attribute,
    id_attribute_select,
    name_attribute,
    name_attribute_select);
  REFERENCE FROM product_property_definition_schema (
    characterized_object);
  REFERENCE FROM document_schema (
    document);
  REFERENCE FROM effectivity_schema (
    effectivity);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  REFERENCE FROM external_reference_schema (
    external_source);
    
  TYPE product_definition_or_reference = SELECT (
    product_definition, 
    generic_product_definition_reference);
  END_TYPE;
    
  TYPE pds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    product_category);
  END_TYPE;
  TYPE pds_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    product_definition,
    product_definition_substitute);
  END_TYPE;
  
  TYPE source = ENUMERATION OF (made, bought, not_known);
  END_TYPE;

  ENTITY characterized_product
    SUBTYPE OF (characterized_object, product);
  END_ENTITY;

  ENTITY generic_product_definition_reference
    ABSTRACT SUPERTYPE OF ( ONEOF ( product_definition_reference, product_definition_reference_with_local_representation) );
    source : external_source;
  END_ENTITY;
 
  ENTITY product;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;

  ENTITY product_category;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_category_relationship;
    name : label;
    description : OPTIONAL text;
    category : product_category;
    sub_category : product_category;
  WHERE
    WR1: acyclic_product_category_relationship(SELF, [SELF.sub_category]);
  END_ENTITY;

  ENTITY product_definition;
    id : identifier;
    description : OPTIONAL text;
    formation : product_definition_formation;
    frame_of_reference : product_definition_context;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_context_association;
    definition : product_definition;
    frame_of_reference : product_definition_context;
    role : product_definition_context_role;
  END_ENTITY;

  ENTITY product_definition_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
    usage : product_definition_relationship;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
  END_ENTITY;

  ENTITY product_definition_formation;
    id : identifier;
    description : OPTIONAL text;
    of_product : product;
  UNIQUE
    UR1: id, of_product;
  END_ENTITY;

  ENTITY product_definition_formation_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition_formation : product_definition_formation;
    related_product_definition_formation : product_definition_formation;
  END_ENTITY;

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
    make_or_buy : source;
  END_ENTITY;

  ENTITY product_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition : product_definition_or_reference;
    related_product_definition : product_definition_or_reference;
  END_ENTITY;

  ENTITY product_definition_reference
    SUBTYPE OF (generic_product_definition_reference);
    product_id : identifier;
    product_definition_formation_id : identifier;
    product_definition_id : identifier;
    id_owning_organization_name : OPTIONAL label;
  END_ENTITY;
 
  ENTITY product_definition_reference_with_local_representation
    SUBTYPE OF (generic_product_definition_reference, product_definition);
  END_ENTITY;
  
  ENTITY product_definition_substitute;
    description : OPTIONAL text;
    context_relationship : product_definition_relationship;
    substitute_definition : product_definition;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: context_relationship.related_product_definition :<>: substitute_definition;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
    documentation_ids : SET [1:?] OF document;
  END_ENTITY;

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
    products : SET [1:?] OF product;
  END_ENTITY;

  ENTITY product_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product : product;
    related_product : product;
  END_ENTITY;

  FUNCTION acyclic_product_category_relationship (relation : product_category_relationship; children : SET OF product_category):BOOLEAN;
    LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_formation_relationship (relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_relationship (relation : product_definition_relationship; relatives : SET [1:?] OF product_definition_or_reference; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_relationship (relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION categories_of_product
   (obj : product) : SET OF STRING; 
  LOCAL
    category_assignments: BAG OF product_category;
    categories: SET OF STRING:=[];
  END_LOCAL;
    category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);
  END_FUNCTION; 

  FUNCTION get_product_definitions (c_def_instance : product):SET OF product_definition;
    LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: product_property_definition_schema.exp,v 1.17 2014/03/04 00:30:39 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Product property definition schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Product property definition schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_property_definition_schema '{iso standard 10303 part(41) version(7) object(1) product_property_definition_schema(18)}';

  REFERENCE FROM process_property_schema (
    action_property, 
    resource_property);
  REFERENCE FROM product_definition_schema (
    product_definition, 
    product_definition_relationship);
  REFERENCE FROM product_structure_schema (
    assembly_component_usage,
    multi_level_reference_designator,
    next_assembly_usage_occurrence);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);
    
  TYPE characterized_definition = SELECT (
    characterized_object, 
    characterized_product_definition, 
    shape_definition);
  END_TYPE;

  TYPE ppds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    property_definition,
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;

  TYPE characterized_product_definition = SELECT (
    product_definition, 
    product_definition_relationship);
  END_TYPE;

  TYPE derived_property_select = SELECT (property_definition, action_property, resource_property);
  END_TYPE;

  TYPE shape_definition = SELECT (product_definition_shape, shape_aspect, shape_aspect_relationship);
  END_TYPE;

  TYPE internal_or_reflected_shape_aspect = SELECT (
    shape_aspect,
    identifier);
  END_TYPE;

  TYPE multi_or_next_assembly_usage_occurrence = SELECT (
    multi_level_reference_designator,
    next_assembly_usage_occurrence);
  END_TYPE;

  ENTITY characterized_object;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY characterized_object_relationship;
    name : label;
    description : OPTIONAL text;
    relating_object : characterized_object;
    related_object : characterized_object;
  END_ENTITY;

  ENTITY component_path_shape_aspect
    SUBTYPE OF (shape_aspect);
    location : multi_or_next_assembly_usage_occurrence;
    component_shape_aspect : internal_or_reflected_shape_aspect;
  UNIQUE
    UR1 : location, component_shape_aspect;
  END_ENTITY;

  ENTITY general_property;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY general_property_association;
    name : label;
    description : OPTIONAL text;
    base_definition : general_property;
    derived_definition : derived_property_select;
  WHERE
    WR1: SIZEOF(USEDIN(derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
    WR2: derived_definition.name = base_definition.name;
  END_ENTITY;

  ENTITY general_property_relationship;
    name : label;
    description : OPTIONAL text;
    relating_property : general_property;
    related_property : general_property;
  END_ENTITY;

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
  END_ENTITY;

  ENTITY property_definition;
    name : label;
    description : OPTIONAL text;
    definition : characterized_definition;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect;
    name : label;
    description : OPTIONAL text;
    of_shape : product_definition_shape;
    product_definitional : LOGICAL;
  DERIVE
    id : identifier := get_id_value(SELF);
  UNIQUE
    UR1: id, of_shape;    
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect_relationship;
    name : label;
    description : OPTIONAL text;
    relating_shape_aspect : shape_aspect;
    related_shape_aspect : shape_aspect;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  FUNCTION acyclic_characterized_object_relationship (relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_general_property_relationship (relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_shape_aspect_relationship (relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION get_shape_aspects (c_def_instance : characterized_definition):SET OF shape_aspect;
    LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: product_property_representation_schema.exp,v 1.38 2014/03/04 00:30:40 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Product property representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Product property representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_property_representation_schema '{iso standard 10303 part(41) version(7) object(1) product_property_representation_schema(19)}';

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM material_property_definition_schema (
    property_definition_relationship);
  REFERENCE FROM product_definition_schema (
    product_definition, 
    product_definition_relationship);
  REFERENCE FROM product_property_definition_schema (
    characterized_object, 
    characterized_definition, 
    general_property, 
    product_definition_shape, 
    property_definition, 
    shape_aspect, 
    shape_aspect_relationship);
  REFERENCE FROM representation_schema (
    representation, 
    representation_item, 
    representation_relationship, 
    using_representations, 
    mapped_item, 
    representation_context, 
    representation_map,
    list_representation_item,
    set_representation_item);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    label, 
    text);

  TYPE pprs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;
  
  TYPE pprs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;

  TYPE chained_representation_link = SELECT (mapped_item, representation_context, representation_relationship);
  END_TYPE;

  TYPE represented_definition = SELECT (
    general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;

  TYPE item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT (
    represented_definition);
  END_TYPE;
  
  TYPE item_identified_representation_usage_select = SELECT (
    representation_item,
    list_representation_item,
    set_representation_item);
  END_TYPE;  

  ENTITY chain_based_item_identified_representation_usage
    SUBTYPE OF (item_identified_representation_usage);
    nodes : LIST [2:?] OF UNIQUE representation;
    undirected_link : LIST [1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\item_identified_representation_usage.used_representation RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST [1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_chain_based_item_within_representation 
    SUBTYPE OF (characterized_item_within_representation);
    nodes : LIST[2:?] OF UNIQUE representation;
    undirected_link : LIST[1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\characterized_item_within_representation.rep RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST[1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_item_within_representation
    SUBTYPE OF (characterized_object);
    item : representation_item;
    rep : representation;
  UNIQUE
    WR1: item, rep;
  WHERE
    WR2: rep IN using_representations(item);
  END_ENTITY;

  ENTITY context_dependent_shape_representation;
    representation_relation : shape_representation_relationship;
    represented_product_relation : product_definition_shape;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR3: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY item_identified_representation_usage;
    name : label;
    description : OPTIONAL text;
    definition : item_identified_representation_usage_definition;
    used_representation : representation;
    identified_item : item_identified_representation_usage_select;
  WHERE
    WR1: SELF.used_representation IN using_representations(SELF.identified_item);
  END_ENTITY;

  ENTITY property_definition_representation;
    definition : represented_definition;
    used_representation : representation;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    SELF\property_definition_representation.definition : property_definition;
    SELF\property_definition_representation.used_representation : shape_representation;
  WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(definition\property_definition.definition));   
  END_ENTITY;

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY;

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
  WHERE
    WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
  END_ENTITY;

  FUNCTION get_directed_link ( nodes : LIST OF representation;
                            undirected_link  : LIST OF chained_representation_link) : LIST OF representation_relationship;
  LOCAL
   directed_link : LIST OF representation_relationship := [];
  END_LOCAL;

  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR
     (value_unique(nodes) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  REPEAT i := 1 to SIZEOF(undirected_link);
   CASE TRUE OF
    ('REPRESENTATION_SCHEMA.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i]\representation.context_of_items   :=: undirected_link[i]) AND 
         (nodes[i+1]\representation.context_of_items :=: undirected_link[i])) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF (((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_1) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_2)) OR
         ((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_2) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_1))) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i] IN using_representations(undirected_link[i])) AND 
         (nodes[i+1] :=: undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation)) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    OTHERWISE : RETURN(?);
   END_CASE;
  END_REPEAT;
  
  IF (value_unique(directed_link) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  RETURN(directed_link);
  END_FUNCTION;

  FUNCTION relatives_of_product_definitions (definition_set : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
    FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
  END_FUNCTION;

  FUNCTION relatives_of_shape_representations (shape_representation_set : SET OF shape_representation):SET OF shape_representation;
    FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
  END_FUNCTION;

  FUNCTION get_property_definition_representations (c_def_instance : characterized_definition):SET OF property_definition_representation;
    LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: product_structure_schema.exp,v 1.21 2014/03/04 00:30:40 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8371

EXPRESS Source:
ISO 10303-44 ed3 Product structure configuration - Product structure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-44 ed3 Product structure configuration - Product structure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA product_structure_schema '{iso standard 10303 part(44) version(3) object(1) product_structure_schema(1)}';

  REFERENCE FROM product_definition_schema
    (product,
     product_definition,
     product_definition_formation,
     product_definition_reference,
     product_definition_relationship,
     acyclic_product_definition_relationship,
     product_definition_or_reference);

  REFERENCE FROM measure_schema
     (measure_with_unit);

  REFERENCE FROM support_resource_schema
     (identifier, label, text);

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (quantified_assembly_component_usage ANDOR
                ONEOF (multi_level_reference_designator,
  					   next_assembly_usage_occurrence,
  					   promissory_usage_occurrence,
                       specified_higher_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY multi_level_reference_designator
  SUBTYPE OF (assembly_component_usage);
  location : LIST[1:?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  SELF\product_definition_relationship.relating_product_definition RENAMED root : product_definition := location[1]\product_definition_relationship.relating_product_definition;
  SELF\product_definition_relationship.related_product_definition  RENAMED leaf : product_definition_or_reference := location[HIINDEX(location)]\product_definition_relationship.related_product_definition;
UNIQUE
  UR1: location;
WHERE
  WR1: unambiguously_specified_multi_level_reference_designator(location);
  WR2: SIZEOF(QUERY(cp <* location | NOT (
         EXISTS(cp\assembly_component_usage.reference_designator)))) = 0; 
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
UNIQUE
  UR1 : SELF\assembly_component_usage.reference_designator, SELF\product_definition_relationship.relating_product_definition;  
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

FUNCTION unambiguously_specified_multi_level_reference_designator (links : LIST[1:?] OF next_assembly_usage_occurrence) : BOOLEAN;
REPEAT i := 1 to SIZEOF(links) - 1;
--case 1 all in one file; had to disambiguate link[i].relating instance type to distinguish case 1 from case 3.
   CASE TRUE OF
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) 
       AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition)) 
       AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i+1]\product_definition_relationship.relating_product_definition)) :
     BEGIN
        IF NOT (
                (links[i]\product_definition_relationship.related_product_definition :=:
                 links[i+1]\product_definition_relationship.relating_product_definition)
                 OR
                ((SIZEOF (QUERY (pdr <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION') |
                          pdr\product_definition_relationship.relating_product_definition :=: 
                          links[i+1]\product_definition_relationship.relating_product_definition)) = 1)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition.formation\product_definition_formation.of_product
                    :=:
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition.formation\product_definition_formation.of_product)))
         THEN
          RETURN(FALSE);
        END_IF;
     END;

--case 2 ; intermediate node reference from main to external file or both node references in external file. links[i].relating instance can be either pd or pdref.
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition))
       AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i+1]\product_definition_relationship.relating_product_definition)) :
       BEGIN
         IF NOT (
                (links[i]\product_definition_relationship.related_product_definition :=:
                 links[i+1]\product_definition_relationship.relating_product_definition)
                 OR
                ((SIZEOF (QUERY (pdr <* USEDIN(links[i]\product_definition_relationship.related_product_definition,
                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION') |
                          pdr\product_definition_relationship.relating_product_definition :=: 
                          links[i+1]\product_definition_relationship.relating_product_definition)) = 1)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_id
                    =
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_id)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.id_owning_organization_name
                    =
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.id_owning_organization_name)
                  AND
                   (links[i]\product_definition_relationship.related_product_definition\product_definition_reference.product_definition_id
                   <> 
                    links[i+1]\product_definition_relationship.relating_product_definition\product_definition_reference.product_definition_id)))
         THEN
          RETURN(FALSE);
        END_IF;
     END;

--case 3 should never see -- link in external file referencing a node in main assembly file. Note link is just links[i].
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN TYPEOF(links[i]\product_definition_relationship.relating_product_definition))
       AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(links[i]\product_definition_relationship.related_product_definition)) :
     RETURN(FALSE);

     OTHERWISE : RETURN(FALSE);
   END_CASE;

END_REPEAT;
RETURN(TRUE);
END_FUNCTION; 

END_SCHEMA; -- product_structure
(*
$Id: qualifications_schema.exp,v 1.16 2014/03/04 00:30:40 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA qualifications_schema '{iso standard 10303 part(41) version(6) object(1) qualifications_schema(20)}';
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY qualification;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification : qualification;
    related_qualification : qualification;
  END_ENTITY;

  ENTITY qualification_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification_type : qualification_type;
    related_qualification_type : qualification_type;
  END_ENTITY;

  FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
$Id: qualified_measure_schema.exp,v 1.9 2014/03/04 00:30:40 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6751

EXPRESS Source:
ISO 10303-45 ed3 Material and other engineering properties - Qualified measure schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-45 ed3 Material and other engineering properties - Qualified measure schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA qualified_measure_schema '{iso standard 10303 part(45) version(3) object(1) qualified_measure_schema(3)}';

REFERENCE FROM mathematical_functions_schema
     (maths_value);

REFERENCE FROM measure_schema
     (measure_with_unit,
unit);

REFERENCE FROM representation_schema
     (representation_item);

REFERENCE FROM support_resource_schema
     (identifier,
      label,
      text,
      bag_to_set);

TYPE value_format_type = identifier;
WHERE
      WR1: LENGTH(SELF) <= 80; 
END_TYPE; -- value_format_type
  
TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
END_TYPE;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY maths_value_qualification;
  name 			: label;
  description 		: text;
  qualified_maths_value : maths_value_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\maths_value_qualification.qualified_maths_value));
END_ENTITY;

ENTITY maths_value_representation_item
  SUBTYPE OF (representation_item, maths_value_with_unit);
END_ENTITY;

ENTITY maths_value_with_unit;
  value_component 	: maths_value;
  unit_component 		: unit;
END_ENTITY;

ENTITY measure_qualification;
  name 			: label;
  description 		: text;
  qualified_measure 	: measure_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers 	: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY uncertainty_qualifier
 SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY value_format_type_qualifier;
  format_type : value_format_type;
END_ENTITY;


END_SCHEMA;  -- qualified_measure_schema

(*
$Id: representation_schema.exp,v 1.11 2014/03/04 00:30:40 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N6135

EXPRESS Source:
ISO 10303-43 ed3 Representation structures - Representation schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-43 ed3 Representation structures - Representation schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA representation_schema '{iso standard 10303 part(43) version(2) object(1) representation_schema(1)}';

REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   id_attribute,
   id_attribute_select);

REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);
   
  TYPE rs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    representation);
  END_TYPE;
  TYPE rs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    representation);
  END_TYPE;

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE;

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE;

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE;

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE;

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE;

  ENTITY binary_representation_item 
    SUBTYPE OF (representation_item); 
      binary_value : BINARY; 
  END_ENTITY; 

  ENTITY bytes_representation_item 
    SUBTYPE OF (binary_representation_item); 
    DERIVE 
      no_of_bytes : INTEGER := BLENGTH(SELF\binary_representation_item.binary_value) DIV 8; 
    WHERE 
      WR1: BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0; 
  END_ENTITY; 

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY;

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
          TYPEOF (SELF\representation.context_of_items );
  END_ENTITY;

  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
     WHERE
       WR1: acyclic_representation_relationship(SELF,
         [SELF\representation_relationship.rep_2],
         'REPRESENTATION_SCHEMA.'+'REPRESENTATION');
  END_ENTITY;  

  ENTITY definitional_representation_relationship_with_same_context
    SUBTYPE OF (definitional_representation_relationship);
     WHERE
       WR1: SELF\representation_relationship.rep_1.context_of_items :=: 
            SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;  

  ENTITY founded_item;
    DERIVE
      users : SET[0:?] OF founded_item_select := using_items(SELF,[]);
    WHERE
      WR1: SIZEOF(users) > 0;
      WR2: NOT(SELF IN users);  
  END_ENTITY;

  ENTITY functionally_defined_transformation;
    name        : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY item_defined_transformation;
    name             : label;
    description      : OPTIONAL text;
    transform_item_1 : representation_item;
    transform_item_2 : representation_item;
  END_ENTITY;

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      WR1: acyclic_mapped_representation(SELF);
  END_ENTITY;

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY;

  ENTITY representation;
      name             : label;
      items            : SET[1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id               : identifier := get_id_value (SELF);
      description      : text := get_description_value (SELF);
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
         <= 1;
      WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
         <= 1;
  END_ENTITY;

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
  END_ENTITY;

  ENTITY representation_item
    SUPERTYPE OF(ONEOF(binary_representation_item,
      compound_representation_item, 
      mapped_item, 
      value_representation_item));
      name : label;
    WHERE
      WR1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY;

  ENTITY representation_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_representation_item : representation_item;
    related_representation_item : representation_item;
  END_ENTITY;

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET[1:?] OF mapped_item FOR mapping_source;
    WHERE
      WR1: item_in_context(SELF.mapping_origin,
        SELF.mapped_representation.context_of_items);
  END_ENTITY;

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY;

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      WR1: SELF\representation_relationship.rep_1.context_of_items
           :<>: SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;

  ENTITY uncertainty_assigned_representation
    SUBTYPE OF (representation);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      WR1: valid_measure_value (SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
        NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
        IN TYPEOF (rep.context_of_items)
        ))) = 0;
  END_ENTITY;

  FUNCTION acyclic_mapped_representation
    (mi : mapped_item) : BOOLEAN;
    LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) > 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) > 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) > 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;  
  
  FUNCTION acyclic_representation_relationship
    (relation : representation_relationship; relatives : SET[1:?] OF representation; specific_relation : STRING) : BOOLEAN; 
    LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

  FUNCTION item_in_context
    (item  : representation_item;
     cntxt : representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);
  END_FUNCTION;

  FUNCTION using_items (item : founded_item_select;
                        checked_items: SET OF founded_item_select)
                      : SET OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);
  END_FUNCTION;

  FUNCTION using_representations (item : founded_item_select)
    : SET OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);
  END_FUNCTION;

  FUNCTION valid_measure_value
    (m : measure_value) : BOOLEAN;
    IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
$Id: security_classification_schema.exp,v 1.11 2014/03/04 00:30:41 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA security_classification_schema '{iso standard 10303 part(41) version(3) object(1) security_classification_schema(21)}';
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY security_classification;
    name : label;
    purpose : text;
    security_level : security_classification_level;
  END_ENTITY;

  ENTITY security_classification_level;
    name : label;
  END_ENTITY;

END_SCHEMA;
(*
$Id: support_resource_schema.exp,v 1.17 2014/03/04 00:30:42 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N8369

EXPRESS Source:
ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA support_resource_schema '{iso standard 10303 part(41) version(7) object(1) support_resource_schema(22)}';
  TYPE identifier = STRING;
  END_TYPE;

  TYPE label = STRING;
  END_TYPE;

  TYPE text = STRING;
  END_TYPE;

  FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
  END_FUNCTION;

  FUNCTION type_check_function (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER):LOGICAL;
    IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0)) THEN
      RETURN (UNKNOWN);
    ELSE
      CASE criterion OF 
        0: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
        1: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
        OTHERWISE : RETURN (UNKNOWN);
      END_CASE;
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
$Id: topology_schema.exp,v 1.9 2014/03/04 00:30:43 thomasrthurman Exp $
ISO 10303 TC184/SC4/WG12 N7627

EXPRESS Source:
ISO 10303-42 ed4 Geometric and topological representation - Topology schema

The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"), 
and derivations of the Schema:

Copyright ISO 2014  All rights reserved
Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing, 
implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so, 
subject to the following conditions:

THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE 
USE OR OTHER DEALINGS IN THE SCHEMA.

In addition, any modified copy of the Schema shall include the following notice:

THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
ISO 10303-42 ed4 Geometric and topological representation - Topology schema
AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
*)

SCHEMA topology_schema '{iso standard 10303 part(42) version(8) object(1) topology_schema(2)}';
   REFERENCE FROM geometry_schema;
   REFERENCE FROM representation_schema(representation_item);

 CONSTANT
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        
 END_CONSTANT;

 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;

 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;

  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;

 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;

 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;

 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;

 ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
   parent_face_set   :  connected_face_set;
 END_ENTITY;

 ENTITY edge
   SUPERTYPE OF(ONEOF(edge_curve, oriented_edge, subedge))
   SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;

 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;

 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;

 ENTITY face
   SUPERTYPE OF(ONEOF(face_surface, subface, oriented_face))
   SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;

 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;

    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;

 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;

 ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY open_path
   SUBTYPE OF (path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                       (SELF\path.edge_list[ne].edge_element.edge_end);
 END_ENTITY;

 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;

 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;

 ENTITY path
   SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;

 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY seam_edge
   SUBTYPE OF (oriented_edge);
     pcurve_reference : pcurve ; 
 WHERE
    WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
                ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
                       (edge_element\edge_curve.edge_geometry)) ;
   WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry ;
 END_ENTITY;

 ENTITY subedge
   SUBTYPE OF (edge);
   parent_edge   :  edge;
 END_ENTITY;

 ENTITY subface
   SUBTYPE OF (face);
   parent_face   :  face;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
 END_ENTITY;

 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 END_ENTITY;

 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;

 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;

 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;

 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (result);
END_FUNCTION;

 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
   LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);
 END_FUNCTION;

 FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point; 
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (result);
END_FUNCTION;

 END_SCHEMA; -- end TOPOLOGY schema
