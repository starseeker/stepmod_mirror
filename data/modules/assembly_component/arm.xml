<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="arm_descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="">
   <application name="JSDAI" owner="LKSoft" source="assembly_component_arm schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="Assembly_component_arm">
      <interface kind="use" schema="Component_grouping_arm"/>
      <interface kind="use" schema="Assembly_shape_arm"/>
      <entity name="Assembly_component" supertypes="Definition_based_product_occurrence">
         <derived expression="ac_get_assemblies(SELF)" name="assemblies">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Product_view_definition"/>
         </derived>
         <derived expression="ac_get_groups(SELF)" name="groups">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Assembly_group_component"/>
         </derived>
         <derived expression="ac_get_versions(assemblies)" name="versions">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Product_version"/>
         </derived>
         <derived expression="ac_get_products(versions)" name="product">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Product"/>
         </derived>
         <inverse attribute="related_view" entity="Assembly_component_relationship" name="occurrence_contexts">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
            <redeclaration entity-ref="Product_occurrence"/>
         </inverse>
         <where expression="NOT(('LAYERED_INTERCONNECT_MODULE_DESIGN_ARM.FOOTPRINT_OCCURRENCE' IN TYPEOF(SELF)) XOR ('FOOTPRINT_DEFINITION_ARM.FOOTPRINT_DEFINITION' IN TYPEOF(derived_from))) OR &#10;        NOT(('LAYERED_INTERCONNECT_MODULE_DESIGN_ARM.PADSTACK_OCCURRENCE' IN TYPEOF(SELF)) XOR ('LAYERED_INTERCONNECT_COMPLEX_TEMPLATE_ARM.PADSTACK_DEFINITION' IN TYPEOF(SELF\Definition_based_product_occurrence.derived_from)))" label="WR1"/>
         <where expression="SELF\Product_view_definition.defined_version :=: SELF\Definition_based_product_occurrence.derived_from.defined_version" label="WR2"/>
         <where expression="SIZEOF(assemblies) = SIZEOF(versions)" label="WR3"/>
         <where expression="SIZEOF(product) = 1" label="WR4"/>
         <where expression="(('LAYERED_INTERCONNECT_MODULE_DESIGN_ARM.STRUCTURED_LAYOUT_COMPONENT_SUB_ASSEMBLY_RELATIONSHIP' IN TYPEOF(SELF\Assembly_component.occurrence_contexts[1])) OR&#10;         (SIZEOF(groups) = 0) OR &#10;         (ac_get_group_assemblies(groups) = assemblies))" label="WR5"/>
      </entity>
      <entity name="Component_make_from_relationship" supertypes="View_definition_relationship">
         <explicit name="reusable_component">
            <typename name="Assembly_component"/>
            <redeclaration entity-ref="View_definition_relationship" old_name="relating_view"/>
         </explicit>
         <explicit name="resultant_component">
            <typename name="Assembly_component"/>
            <redeclaration entity-ref="View_definition_relationship" old_name="related_view"/>
         </explicit>
         <where expression="resultant_component &lt;&gt; reusable_component" label="WR1"/>
      </entity>
      <entity name="Physical_component" supertypes="Assembly_component"/>
      <entity name="Thermal_component" supertypes="Assembly_component"/>
      <function name="ac_get_assemblies">
         <parameter name="input">
            <typename name="Assembly_component"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Product_view_definition"/>
         <algorithm>LOCAL
      acr : SET OF Assembly_component_relationship := input\Assembly_component.occurrence_contexts;
      pvd : SET OF Product_view_definition := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(acr) BY 1;
      IF NOT('COMPONENT_GROUPING_ARM.' + 'ASSEMBLY_GROUP_COMPONENT' IN TYPEOF(acr[i]\Product_occurrence_definition_relationship.relating_view))
      THEN
        pvd := pvd + acr[i]\Product_occurrence_definition_relationship.relating_view; 
      ELSE
        pvd := pvd + get_assemblies(acr[i]\Product_occurrence_definition_relationship.relating_view);
      END_IF;
    END_REPEAT;
    RETURN (pvd);</algorithm>
      </function>
      <function name="ac_get_group_assemblies">
         <parameter name="input">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Assembly_group_component"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Product_view_definition"/>
         <algorithm>LOCAL
      acr : SET OF Assembly_component_relationship := [];
      pvd : SET OF Product_view_definition := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input) BY 1;
      acr := input[i]\Assembly_component.occurrence_contexts;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(acr) BY 1;
      IF NOT('COMPONENT_GROUPING_ARM.' + 'ASSEMBLY_GROUP_COMPONENT' IN TYPEOF(acr[i]\Product_occurrence_definition_relationship.relating_view))
      THEN
        pvd := pvd + acr[i]\Product_occurrence_definition_relationship.relating_view; 
      ELSE
        pvd := pvd + get_assemblies(acr[i]\Product_occurrence_definition_relationship.relating_view);
      END_IF;
    END_REPEAT;
    RETURN (pvd);</algorithm>
      </function>
      <function name="ac_get_groups">
         <parameter name="input">
            <typename name="Assembly_component"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Assembly_group_component"/>
         <algorithm>LOCAL
      acr : SET OF Assembly_component_relationship := input\Assembly_component.occurrence_contexts;
      agc : SET OF Assembly_group_component := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(acr) BY 1;
      IF ('COMPONENT_GROUPING_ARM.' + 'ASSEMBLY_GROUP_COMPONENT' IN TYPEOF(acr[i]\Product_occurrence_definition_relationship.relating_view))
      THEN
        agc := agc + acr[i]\Product_occurrence_definition_relationship.relating_view; 
      END_IF;
    END_REPEAT;
    RETURN (agc);</algorithm>
      </function>
      <function name="ac_get_products">
         <parameter name="input">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Product_version"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Product"/>
         <algorithm>LOCAL
      p : SET OF Product := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input) BY 1;
      p := p + input[i]\Product_version.of_product; 
    END_REPEAT;
    RETURN (p);</algorithm>
      </function>
      <function name="ac_get_versions">
         <parameter name="input">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="Product_view_definition"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Product_version"/>
         <algorithm>LOCAL
      pv : SET OF Product_version := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input) BY 1;
      pv := pv + input[i]\Product_view_definition.defined_version; 
    END_REPEAT;
    RETURN (pv);</algorithm>
      </function>
      <function name="get_assemblies">
         <parameter name="input">
            <typename name="Assembly_component"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="Product_view_definition"/>
         <algorithm>LOCAL
      acr : SET OF Assembly_component_relationship := input\Assembly_component.occurrence_contexts;
      pvd : SET OF Product_view_definition := [];
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(acr) BY 1;
      IF NOT('LAYERED_INTERCONNECT_MODULE_DESIGN_ARM.' +
        'STRUCTURED_LAYOUT_COMPONENT' IN
        TYPEOF(acr[i]\Product_occurrence_definition_relationship.relating_view))
      THEN
        pvd := pvd + acr[i]\Product_occurrence_definition_relationship.relating_view; 
      ELSE
        pvd := pvd + get_assemblies(acr[i]\Product_occurrence_definition_relationship.relating_view);
      END_IF;
    END_REPEAT;

    RETURN (pvd);</algorithm>
      </function>
   </schema>
</express>
