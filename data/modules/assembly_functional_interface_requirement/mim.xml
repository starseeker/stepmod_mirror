<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2004-12-14T12:55:42" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="assembly_functional_interface_requirement_mim schema_instance"/>
   <schema name="Assembly_functional_interface_requirement_mim">
      <interface kind="use" schema="PACKAGED_PART_BLACK_BOX_MODEL_MIM"/>
      <interface kind="use" schema="PRODUCT_VIEW_DEFINITION_MIM"/>
      <interface kind="use" schema="FUNCTIONAL_SPECIFICATION_MIM"/>
      <interface kind="use" schema="REQUIREMENT_ASSIGNMENT_MIM"/>
      <interface kind="use" schema="REQUIREMENT_DECOMPOSITION_MIM"/>
      <interface kind="use" schema="ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENT_MIM"/>
      <entity name="minimally_defined_connector" supertypes="packaged_part">
         <where label="wr1" expression=" sizeof ( query ( pd &lt;* usedin ( self , 'electronic_assembly_interconnect_and_packaging_design.' + 'property_definition.definition' ) | ( sizeof ( query ( sa &lt;* usedin ( pd , 'electronic_assembly_interconnect_and_packaging_design.' + 'shape_aspect.of_shape' ) | ( 'electronic_assembly_interconnect_and_packaging_design.' + 'packaged_part_terminal' in typeof ( sa ) ) and ( sa . description = 'interface terminal' ) ) ) &gt;= 0 ) ) ) &gt;= 0 "/>
      </entity>
      <entity name="protocol_physical_layer_definition" supertypes="product_definition"/>
      <entity name="protocol_requirement_allocation_to_part_terminal" supertypes="requirement_assignment">
         <where label="wr1" expression=" 'electronic_assembly_interconnect_and_packaging_design.' + 'requirements_property' in typeof ( self \ property_definition_relationship . relating_property_definition ) "/>
      </entity>
      <rule name="mating_connector_termination_constraint" appliesto="shape_aspect">
         <where label="wr1" expression=" sizeof ( query ( sa &lt;* shape_aspect | ( sa \ shape_aspect . description = 'mating connector termination' ) and not ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'component_definition' in typeof ( sa . of_shape . definition ) ) and ( sa . of_shape . definition \ product_definition . description = 'mating connector' ) ) ) ) = 0 "/>
      </rule>
      <rule name="mating_connector_termination_unique_constraint" appliesto="shape_aspect">
         <algorithm> local mct : bag of shape_aspect := query ( sa &lt;* shape_aspect | ( sa \ shape_aspect . description = 'mating connector termination' ) ) ; cd_bag : bag of component_definition := [ ] ; sa_bag : bag of shape_aspect ; sar_bag : bag of shape_aspect_relationship ; pass : boolean := true ; ppt_bag : bag of packaged_part_terminal ; end_local ; repeat i := 1 to sizeof ( mct ) by 1 ; if exists ( mct [ i ] . of_shape . definition ) then if ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'component_definition' in typeof ( mct [ i ] . of_shape . definition ) ) and ( mct [ i ] . of_shape . definition \ product_definition . description = 'mating connector' ) ) then if ( not ( mct [ i ] . of_shape . definition in cd_bag ) ) then cd_bag := cd_bag + mct [ i ] . of_shape . definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( cd_bag ) by 1 ; if ( not pass ) then escape ; end_if ; ppt_bag := [ ] ; sa_bag := query ( sa &lt;* mct | ( sa . of_shape . definition :=: cd_bag [ i ] ) ) ; repeat j := 1 to sizeof ( sa_bag ) by 1 ; if ( not pass ) then escape ; end_if ; sar_bag := query ( sar &lt;* usedin ( sa_bag [ j ] , 'electronic_assembly_interconnect_and_packaging_design.' + 'shape_aspect_relationship.related_shape_aspect' ) | ( ( sar \ shape_aspect_relationship . name = 'instantiated terminal' ) and ( 'electronic_assembly_interconnect_and_packaging_design.' + 'packaged_part_terminal' in typeof ( sar . relating_shape_aspect ) ) ) ) ; repeat k := 1 to sizeof ( sar_bag ) by 1 ; if exists ( sar_bag [ k ] . relating_shape_aspect ) then if ( sar_bag [ k ] . relating_shape_aspect in ppt_bag ) then pass := false ; escape ; else ppt_bag := ppt_bag + sar_bag [ k ] . relating_shape_aspect ; end_if ; end_if ; end_repeat ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
   </schema>
</express>
