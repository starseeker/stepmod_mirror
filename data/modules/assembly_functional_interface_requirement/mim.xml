<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-01-03T15:26:47" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="assembly_functional_interface_requirement_mim schema_instance"/>
   <schema name="Assembly_functional_interface_requirement_mim">
      <interface kind="use" schema="Packaged_part_black_box_model_mim"/>
      <interface kind="use" schema="Product_view_definition_mim"/>
      <interface kind="use" schema="Functional_specification_mim"/>
      <interface kind="use" schema="Requirement_assignment_mim"/>
      <interface kind="use" schema="Requirement_decomposition_mim"/>
      <interface kind="use" schema="Assembly_physical_interface_requirement_mim"/>
      <interface kind="use" schema="Printed_physical_layout_template_mim"/>
      <entity name="minimally_defined_connector" supertypes="packaged_part">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pd &lt;* USEDIN ( SELF , 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'PROPERTY_DEFINITION.DEFINITION' ) | ( SIZEOF ( QUERY ( sa &lt;* USEDIN ( pd , 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'SHAPE_ASPECT.OF_SHAPE' ) | ( 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF ( sa ) ) AND ( sa . description = 'interface terminal' ) ) ) &gt;= 0 ) ) ) &gt;= 0 "/>
      </entity>
      <entity name="protocol_physical_layer_definition" supertypes="product_definition"/>
      <entity name="protocol_requirement_allocation_to_part_terminal" supertypes="requirement_assignment requirement_allocation_group">
         <where label="WR1" expression=" 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF ( SELF \ property_definition_relationship . relating_property_definition ) "/>
      </entity>
      <rule name="mating_connector_termination_constraint" appliesto="shape_aspect">
         <where label="WR1" expression=" SIZEOF ( QUERY ( sa &lt;* shape_aspect | ( sa \ shape_aspect . description = 'mating connector termination' ) AND NOT ( ( 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'COMPONENT_DEFINITION' IN TYPEOF ( sa . of_shape . definition ) ) AND ( sa . of_shape . definition \ product_definition . description = 'mating connector' ) ) ) ) = 0 "/>
      </rule>
      <rule name="mating_connector_termination_unique_constraint" appliesto="shape_aspect">
         <algorithm> LOCAL mct : BAG OF shape_aspect := QUERY ( sa &lt;* shape_aspect | ( sa \ shape_aspect . description = 'mating connector termination' ) ) ; cd_bag : BAG OF component_definition := [ ] ; sa_bag : BAG OF shape_aspect ; sar_bag : BAG OF shape_aspect_relationship ; pass : BOOLEAN := TRUE ; ppt_bag : BAG OF packaged_part_terminal ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( mct ) by 1 ; IF EXISTS ( mct [ i ] . of_shape . definition ) THEN IF ( ( 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'COMPONENT_DEFINITION' IN TYPEOF ( mct [ i ] . of_shape . definition ) ) AND ( mct [ i ] . of_shape . definition \ product_definition . description = 'mating connector' ) ) THEN IF ( NOT ( mct [ i ] . of_shape . definition IN cd_bag ) ) THEN cd_bag := cd_bag + mct [ i ] . of_shape . definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( cd_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; ppt_bag := [ ] ; sa_bag := QUERY ( sa &lt;* mct | ( sa . of_shape . definition :=: cd_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( sa_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; sar_bag := QUERY ( sar &lt;* USEDIN ( sa_bag [ j ] , 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | ( ( sar \ shape_aspect_relationship . name = 'instantiated terminal' ) AND ( 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF ( sar . relating_shape_aspect ) ) ) ) ; REPEAT k := 1 to SIZEOF ( sar_bag ) by 1 ; IF EXISTS ( sar_bag [ k ] . relating_shape_aspect ) THEN IF ( sar_bag [ k ] . relating_shape_aspect IN ppt_bag ) THEN pass := FALSE ; ESCAPE ; ELSE ppt_bag := ppt_bag + sar_bag [ k ] . relating_shape_aspect ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
   </schema>
</express>
