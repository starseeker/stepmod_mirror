<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:55:28" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="assembly_module_with_interconnect_component_mim schema_instance"/>
   <schema name="ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM">
      <interface kind="use" schema="ASSEMBLY_MODULE_DESIGN_MIM"/>
      <interface kind="use" schema="INTERCONNECT_MODULE_USAGE_VIEW_MIM"/>
      <interface kind="use" schema="PART_OCCURRENCE_MIM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_DESIGN_VIEW_MIM"/>
      <interface kind="use" schema="INTERFACE_COMPONENT_MIM"/>
      <entity name="interconnect_module_component_surface_feature" supertypes="physical_component_feature">
         <where label="wr1" expression=" 'assembly_module_with_interconnect_component_mim.' + 'component_definition' in typeof ( self . of_shape . definition ) "/>
         <where label="wr2" expression=" ( self \ shape_aspect . description in [ 'interconnect module component surface feature' ] ) "/>
         <where label="wr3" expression=" sizeof ( query ( i_f &lt;* query ( sar &lt;* usedin ( self , 'assembly_module_with_interconnect_component_mim.' + 'shape_aspect_relationship.related_shape_aspect' ) | sar \ shape_aspect_relationship . name = 'instantiated feature' ) | i_f . relating_shape_aspect \ shape_aspect . description in [ 'interconnect module secondary surface' , 'interconnect module primary surface' , 'interconnect module cavity surface' , 'interconnect module cutout surface' , 'interconnect module edge surface' , 'interconnect module edge segment surface' ] ) ) = 1 "/>
      </entity>
      <rule name="interconnect_component_interface_terminal_unique_constraint" appliesto="physical_component_interface_terminal">
         <algorithm> local icit : bag of physical_component_interface_terminal := query ( cit &lt;* physical_component_interface_terminal | ( cit \ shape_aspect . description = 'interconnect component interface terminal' ) ) ; icd_bag : bag of interface_component_definition := [ ] ; cit_bag : bag of physical_component_interface_terminal ; pass : boolean := true ; name_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( icit ) by 1 ; if exists ( icit [ i ] . of_shape . definition ) then if ( 'assembly_module_with_interconnect_component_mim.' + 'interface_component_definition' in typeof ( icit [ i ] . of_shape . definition ) ) then if ( not ( icit [ i ] . of_shape . definition in icd_bag ) ) then icd_bag := icd_bag + icit [ i ] . of_shape . definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( icd_bag ) by 1 ; if ( not pass ) then escape ; end_if ; name_bag := [ ] ; cit_bag := query ( cit &lt;* icit | ( cit . of_shape . definition :=: icd_bag [ i ] ) ) ; repeat j := 1 to sizeof ( cit_bag ) by 1 ; if exists ( cit_bag [ j ] \ shape_aspect . name ) then if ( cit_bag [ j ] \ shape_aspect . name in name_bag ) then pass := false ; escape ; else name_bag := name_bag + cit_bag [ j ] \ shape_aspect . name ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="interconnect_component_join_terminal_unique_constraint" appliesto="component_terminal">
         <algorithm> local icjt : bag of component_terminal := query ( ct &lt;* component_terminal | ( ct \ shape_aspect . description = 'interconnect component join terminal' ) ) ; cd_bag : bag of component_definition := [ ] ; ct_bag : bag of component_terminal ; pass : boolean := true ; name_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( icjt ) by 1 ; if exists ( icjt [ i ] . of_shape . definition ) then if ( 'assembly_module_with_interconnect_component_mim.' + 'component_definition' in typeof ( icjt [ i ] . of_shape . definition ) ) then if ( not ( icjt [ i ] . of_shape . definition in cd_bag ) ) then cd_bag := cd_bag + icjt [ i ] . of_shape . definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( cd_bag ) by 1 ; if ( not pass ) then escape ; end_if ; name_bag := [ ] ; ct_bag := query ( ct &lt;* icjt | ( ct . of_shape . definition :=: cd_bag [ i ] ) ) ; repeat j := 1 to sizeof ( ct_bag ) by 1 ; if exists ( ct_bag [ j ] \ shape_aspect . name ) then if ( ct_bag [ j ] \ shape_aspect . name in name_bag ) then pass := false ; escape ; else name_bag := name_bag + ct_bag [ j ] \ shape_aspect . name ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
   </schema>
</express>
