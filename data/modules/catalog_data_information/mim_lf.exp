(*
   $Id: mim_lf.exp,v 1.18 2006/05/05 10:42:52 rocc Exp $
   ISO TC184/SC4/WG3 N1305 - ISO/TS 10303-1351 catalog data information - EXPRESS MIM Long form
*)

SCHEMA CATALOG_DATA_INFORMATION_MIM_LF;

CONSTANT
  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();                                          
 END_CONSTANT;

(*
   ------------------------------------------------------------
../data/modules/Catalog_Data_Information/mim.exp
   ------------------------------------------------------------
*)


TYPE approval_item_236cc1 = EXTENSIBLE SELECT BASED_ON approval_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configured_effectivity_assignment,
   contract,
   document_file,
   general_property,
   material_designation,
   organizational_project,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;

TYPE attribute_language_item_236cc1 = EXTENSIBLE SELECT BASED_ON attribute_language_item WITH
  (alternate_product_relationship,
   application_context,
   approval_relationship,
   assembly_component_usage_substitute,
   attribute_value_assignment,
   certification,
   configuration_design,
   configuration_item,
   contract,
   date_role,
   date_time_role,
   descriptive_representation_item,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   external_source,
   general_property,
   general_property_relationship,
   geometric_representation_item,
   group,
   group_relationship,
   identification_role,
   mapped_item,
   organization_relationship,
   organization_role,
   organizational_project,
   organizational_project_relationship,
   person_and_organization_role,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   representation_relationship,
   shape_aspect,
   shape_aspect_relationship,
   time_interval_role,
   uncertainty_measure_with_unit,
   uncertainty_qualifier);
END_TYPE;

TYPE certification_item_236cc1  = EXTENSIBLE SELECT BASED_ON certification_item WITH
  (product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship);
END_TYPE;

TYPE classification_item_236cc1  = EXTENSIBLE SELECT BASED_ON classification_item WITH
  (approval_status,
   class,
   configuration_item,
   contract,
   document_file,
   document_type,
   general_property,
   material_designation,
   organizational_project,
   planar_extent,
   product,
   product_concept,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   property_definition,
   shape_aspect);
END_TYPE;

TYPE contract_item_236cc1  = EXTENSIBLE SELECT BASED_ON contract_item WITH
  (product_definition_formation);
END_TYPE;

TYPE date_and_time_item_236cc1   = EXTENSIBLE SELECT BASED_ON date_and_time_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_person_organization,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;

TYPE date_item_236cc1  = EXTENSIBLE SELECT BASED_ON date_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_person_organization,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;

TYPE document_reference_item_236cc1  = EXTENSIBLE SELECT BASED_ON document_reference_item WITH
  (approval,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   contract,
   descriptive_representation_item,
   general_property,
   material_designation,
   organization,
   organizational_project,
   person,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE effectivity_item_236cc1  = EXTENSIBLE SELECT BASED_ON effectivity_item WITH
  (assembly_component_usage_substitute,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   document_file,
   general_property,
   material_designation,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_aspect,
   shape_representation);
END_TYPE;

TYPE event_occurrence_item_236cc1  = EXTENSIBLE SELECT BASED_ON event_occurrence_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   applied_person_and_organization_assignment,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;

TYPE external_identification_item_236cc1  = EXTENSIBLE SELECT BASED_ON external_identification_item WITH
  (document_file,
   externally_defined_class,
   externally_defined_general_property,
   product_definition);
END_TYPE;

TYPE identification_item_236cc1  = EXTENSIBLE SELECT BASED_ON identification_item WITH
  (applied_identification_assignment,
   approval_status,
   class,
   class_system,
   configuration_item,
   document_file,
   document_type,
   effectivity,
   general_property,
   measure_representation_item,
   organization,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   property_definition,
   shape_aspect_relationship,
   shape_representation);
END_TYPE;

TYPE multi_language_attribute_item_236cc1 = EXTENSIBLE SELECT BASED_ON multi_language_attribute_item WITH
  (alternate_product_relationship,
   application_context,
   approval_relationship,
   assembly_component_usage_substitute,
   certification,
   configuration_design,
   configuration_item,
   contract,
   date_role,
   date_time_role,
   descriptive_representation_item,
   document_relationship,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   external_source,
   general_property,
   general_property_relationship,
   geometric_representation_item,
   group,
   group_relationship,
   identification_role,
   mapped_item,
   organization_relationship,
   organization_role,
   organizational_project,
   organizational_project_relationship,
   person_and_organization_role,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   representation_relationship,
   shape_aspect,
   shape_aspect_relationship,
   time_interval_role,
   uncertainty_measure_with_unit,
   uncertainty_qualifier);
END_TYPE;

TYPE organization_item_236cc1  = EXTENSIBLE SELECT BASED_ON organization_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   applied_identification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   executed_action,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;

TYPE person_and_organization_item_236cc1  = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH
  (alternate_product_relationship,
   applied_classification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   event_occurrence,
   executed_action,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;


RULE approval_person_organization_requires_date_time 
    FOR (approval_person_organization);
WHERE
WR1: SIZEOF ( QUERY ( apo <* approval_person_organization | (
     SIZEOF ( QUERY ( u <* USEDIN ( apo , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_DATE_ASSIGNMENT.ITEMS' ) | 
	( u.role.name =  'sign off' ) ) ) + 
   SIZEOF ( QUERY ( u <* USEDIN ( apo , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' ) | 
	( u.role.name =  'sign off' ) ) ) ) <>1 ) ) =  0;
END_RULE; 

RULE approval_requires_approval_assignment FOR (approval);
WHERE
WR1: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF(USEDIN( a, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL' )) =  0 )) =  0;
END_RULE;

RULE dependent_instantiable_derived_unit FOR
    (derived_unit);
WHERE
 WR1: SIZEOF ( QUERY ( d <* derived_unit | NOT ( SIZEOF ( USEDIN
     ( d , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_document_usage_role FOR
    (document_usage_role);
WHERE
 WR1: SIZEOF ( QUERY ( d <* document_usage_role | NOT ( SIZEOF (
     USEDIN ( d , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_measure_with_unit FOR
    (measure_with_unit);
WHERE
 WR1: SIZEOF ( QUERY ( m <* measure_with_unit | NOT ( SIZEOF (
     USEDIN ( m , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_named_unit FOR
    (named_unit);
WHERE
 WR1: SIZEOF ( QUERY ( n <* named_unit | NOT ( SIZEOF ( USEDIN (
     n , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_precision_qualifier FOR
    (precision_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( p <* precision_qualifier | NOT ( SIZEOF (
     USEDIN ( p , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_product_definition_context_role FOR
    (product_definition_context_role);
WHERE
 WR1: SIZEOF ( QUERY ( p <* product_definition_context_role |
     NOT ( SIZEOF ( USEDIN ( p , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_standard_uncertainty FOR
    (standard_uncertainty);
WHERE
 WR1: SIZEOF ( QUERY ( s <* standard_uncertainty | NOT ( SIZEOF
     ( USEDIN ( s , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_time_interval_role FOR (time_interval_role);
WHERE
WR1: SIZEOF ( QUERY ( t <* time_interval_role | NOT (
     SIZEOF ( USEDIN ( t , '' ) ) >0 ) ) ) =  0;
END_RULE;

RULE dependent_instantiable_type_qualifier FOR
    (type_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( t <* type_qualifier | NOT ( SIZEOF (
     USEDIN ( t , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_uncertainty_qualifier FOR
    (uncertainty_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( u <* uncertainty_qualifier | NOT ( SIZEOF
     ( USEDIN ( u , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dimensionality_is_two_or_three FOR
    (geometric_representation_context);
WHERE
 WR1: SIZEOF ( QUERY ( g <* geometric_representation_context |
     NOT ((g.coordinate_space_dimension =2 ) OR (g.coordinate_space_dimension =3 )))) =0;
END_RULE;

RULE event_occurrence_requires_event_occurrence_assignment FOR
    (event_occurrence);
WHERE
 WR1: SIZEOF ( QUERY ( eo <* event_occurrence | 
	( SIZEOF (USEDIN ( eo, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.RELATIVE_EVENT_OCCURRENCE.BASE_EVENT' ) ) =0 ) AND 
	( SIZEOF ( USEDIN ( eo ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EVENT_OCCURRENCE_ASSIGNMENT.ASSIGNED_EVENT_OCCURRENCE' ) ) =0 )) ) =0;
END_RULE;

RULE global_length_and_angle_units_2d_or_3d FOR
    (global_unit_assigned_context);
WHERE
WR1: SIZEOF ( QUERY ( guac <* global_unit_assigned_context |
     SIZEOF ( guac. units ) <2 ) ) =0;
WR2: SIZEOF ( QUERY ( guac <* global_unit_assigned_context | (
     SIZEOF ( QUERY ( x <* guac. units | 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.LENGTH_UNIT' IN TYPEOF ( x ) ) ) <>1 ) OR 
    ( SIZEOF(QUERY( x <* guac. units | 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PLANE_ANGLE_UNIT' IN TYPEOF(x))) <>1 ))) =0;
END_RULE;

RULE externally_defined_class_with_known_source_requirement FOR 
	(externally_defined_class);
LOCAL
   known_sourced_classes : SET OF externally_defined_class;
END_LOCAL;
  known_sourced_classes := QUERY( edc <* externally_defined_class | 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE
WR1: SIZEOF ( QUERY ( edc <* known_sourced_classes | 
   (SIZEOF ( QUERY ( aoa <* USEDIN ( edc ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' )
     | aoa.role.name =  'class supplier' )) =  0 ))) =  0;
END_RULE;

RULE restrict_name_for_known_source FOR (known_source); 
WHERE 
WR1: SIZEOF( QUERY( ks <* known_source | (ks.name <> 'ISO 13584 library') )) = 0; 
END_RULE; 

RULE plib_class_reference_requires_version FOR (externally_defined_class); 
LOCAL
   known_sourced_classes : SET OF externally_defined_class;
END_LOCAL;
  known_sourced_classes := QUERY( edc <* externally_defined_class | 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE 
WR1: SIZEOF( QUERY( edc <* known_sourced_classes | 
  (SIZEOF( QUERY( aei <* USEDIN(edc,'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
	aei.role.name = 'version' )) <> 1) )) = 0; 
WR2: SIZEOF( QUERY( edc <* known_sourced_classes | 
  (SIZEOF( QUERY( aei <* USEDIN(edc,'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
	aei.role.name = 'version' )) > 0) )) = 0; 
END_RULE; 

RULE person_requires_person_and_organization FOR (person);
WHERE
WR1: SIZEOF ( QUERY ( p <* person | 
	SIZEOF ( USEDIN ( p ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.PERSON_AND_ORGANIZATION.THE_PERSON' )) =  0 )) =  0;
END_RULE; 

RULE restrict_applied_event_occurrence_assignment FOR
    (applied_event_occurrence_assignment);
WHERE
WR1: SIZEOF ( QUERY ( eo <* applied_event_occurrence_assignment| 
	( eo\event_occurrence_assignment.role.name ='event context' ) AND 
	( SIZEOF ( eo.items ) >1 ) ) ) =0;
END_RULE;

RULE restrict_applied_organizational_project_assignment FOR
    (applied_organizational_project_assignment);
WHERE
WR1: SIZEOF ( QUERY ( aopa <* applied_organizational_project_assignment | 
	( aopa.role.name = 'affecting project' ) AND 
	NOT item_correlation( aopa. items , 
	['PRODUCT_CONCEPT', 'PRODUCT', 'PRODUCT_DEFINITION', 'PRODUCT_DEFINITION_FORMATION'] ) ) ) =0;
WR2: SIZEOF ( QUERY ( aopa <* applied_organizational_project_assignment | 
	( aopa.role.name = 'work program' ) AND 
	NOT item_correlation (aopa.items , ['EXECUTED_ACTION'] ) ) ) =0;
END_RULE;

RULE restrict_approval FOR
    (approval,
     approval_date_time);
WHERE
 WR1: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( USEDIN ( a , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) ) >2 ) ) =0;
 WR2: SIZEOF ( QUERY ( adt <* approval_date_time | 
	( NOT EXISTS( adt.role ) ) OR 
	( NOT ( adt.role.name IN ['actual' , 'planned'] ) ) ) ) =0;
 WR3: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( QUERY ( adt <* USEDIN ( a , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) | 
	adt.role.name ='actual' ) ) >1 ) ) =0;
 WR4: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( QUERY ( adt <* USEDIN ( a , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) | 
	adt.role.name ='planned' ) ) >1 ) ) =0;
END_RULE;

RULE restrict_class_system_assignment_for_approval_status FOR
    (approval_status);
WHERE
WR1: SIZEOF ( QUERY ( ent <* approval_status |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

RULE restrict_class_system_assignment_for_class FOR
    (class);
WHERE
WR1: SIZEOF ( QUERY ( c <* class | 
	SIZEOF ( QUERY ( aca <* USEDIN ( c , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.CLASSIFICATION_ASSIGNMENT.ASSIGNED_CLASS' ) | 
	( ( aca.role.name ='class system membership' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT' IN TYPEOF ( aca ) ) ) ) ) >1 ) ) =0;
END_RULE;

RULE restrict_class_system_assignment_for_descriptive_representation_item FOR
    (descriptive_representation_item);
WHERE
WR1: SIZEOF ( QUERY ( ent <* descriptive_representation_item |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

RULE restrict_class_system_assignment_for_document_type FOR
    (document_type);
WHERE
WR1: SIZEOF ( QUERY ( ent <* document_type | 
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

RULE restrict_class_system_assignment_for_planar_extent FOR
 (planar_extent);
WHERE
WR1: SIZEOF ( QUERY ( pe <* planar_extent | 
				( pe\representation_item.name = 'size format' ) AND 
				NOT at_most_one_class_system(pe) ))=0; 
END_RULE;

RULE restrict_class_system_assignment_for_security_classification_level FOR
    (security_classification_level);
WHERE
WR1: SIZEOF ( QUERY ( ent <* security_classification_level |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

RULE restrict_configuration_design_for_specified_individual FOR
    (configuration_design);
WHERE
WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd. name ='physical instance basis' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	( cd. design\product_definition.frame_of_reference.name<> 'physical occurrence' ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd. name ='physical instance basis' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_IDENTIFICATION' IN TYPEOF (cd.configuration ) ) ) ) ) =0;
END_RULE;

RULE restrict_date_assignment FOR 
	(applied_date_assignment);
WHERE
WR1: SIZEOF(QUERY(adr <* applied_date_assignment |
  (adr.role.name = 'actual end') AND
   (NOT  item_correlation (adr.items, ['ORGANIZATIONAL_PROJECT', 'EFFECTIVITY'])) 
	))=0; 
END_RULE;

RULE restrict_document_reference FOR 
	(applied_document_reference);
WHERE
WR1: SIZEOF(QUERY(adr <* applied_document_reference |
 (adr.role.name = 'general tolerance definition') AND 
 (NOT item_correlation (adr.items, ['REPRESENTATION']))
	))=0; 
WR2: SIZEOF(QUERY(adr <* applied_document_reference |
  NOT ((adr.role.name = 'general tolerance definition') OR 
   item_correlation (adr.items, 
	['APPROVAL','CERTIFICATION','CLASS',
	'CLASS_SYSTEM','CONFIGURATION_DESIGN', 
	'CONFIGURATION_ITEM','CONTRACT',
	'GENERAL_PROPERTY','MATERIAL_DESIGNATION', 
	'ORGANIZATION','ORGANIZATIONAL_PROJECT',
	'PERSON','PRODUCT_CONCEPT',
	'PRODUCT_CONCEPT_FEATURE', 'PRODUCT_CONCEPT_FEATURE_CATEGORY',
	'PRODUCT_DEFINITION','PRODUCT_DEFINITION_FORMATION',
	'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP','PRODUCT_DEFINITION_RELATIONSHIP', 
	'PRODUCT_DEFINITION_SUBSTITUTE','PRODUCT_RELATED_PRODUCT_CATEGORY',
	'PROPERTY_DEFINITION', 'REPRESENTATION',
	'SECURITY_CLASSIFICATION','SHAPE_ASPECT', 'SHAPE_ASPECT_RELATIONSHIP']))
	))=0;
END_RULE;

RULE restrict_effectivity_assignment_for_class_category_usage FOR 
	(applied_effectivity_assignment);
WHERE
WR1: SIZEOF( QUERY( aea <* applied_effectivity_assignment |
      ((SIZEOF( QUERY( i <* aea.items |
      ('CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) > 0) AND 
	((SIZEOF( QUERY( i <* aea.items |
      ('CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) <> SIZEOF(aea.items)) OR
      (SIZEOF(TYPEOF(aea.assigned_effectivity) * 
      ['CATALOG_DATA_INFORMATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_MIM_LF' + '.DATED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_MIM_LF' + '.LOT_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']) > 0) OR
      (aea.assigned_effectivity.id <> 'class usage') OR
      (SIZEOF( QUERY ( cueca <* USEDIN(aea,'CATALOG_DATA_INFORMATION_MIM_LF' + '.EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') |
      'CATALOG_DATA_INFORMATION_MIM_LF' + '.CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF (cueca ) )) = 0)) ))) = 0;
END_RULE;

RULE restrict_effectivity_for_effectivity_relationship FOR
    (effectivity_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( er <* effectivity_relationship | 
	( SIZEOF
     ( ['CATALOG_DATA_INFORMATION_MIM_LF' + '.LOT_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']*TYPEOF( er.relating_effectivity ) ) >0 ) OR 
	( SIZEOF (
     ['CATALOG_DATA_INFORMATION_MIM_LF' + '.LOT_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']*TYPEOF( er.related_effectivity ) ) >0 ) ) ) =0;
END_RULE;

RULE restrict_effectivity_usage FOR (effectivity); 
LOCAL
  other_effectivities : SET OF effectivity ;
END_LOCAL;
  other_effectivities := QUERY( e <* effectivity | 
	(SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF' + '.DATED_EFFECTIVITY', 'CATALOG_DATA_INFORMATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY'] * TYPEOF(e)) =  0));
WHERE 
WR1: SIZEOF( QUERY( e <* other_effectivities | 
	( (SIZEOF( QUERY( er <* USEDIN(e,'CATALOG_DATA_INFORMATION_MIM_LF' + '.EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY') | 
		er.name = 'inheritance' )) = 0) 
       OR
	  ((e.id = 'configuration validity') AND 
	  (SIZEOF( QUERY ( cea <* USEDIN(e,'CATALOG_DATA_INFORMATION_MIM_LF' + '.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY') | 
		'CATALOG_DATA_INFORMATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF ( cea) ) ) = 0)) 
       OR
	  ((e.id = 'class usage') AND 
	  (SIZEOF( QUERY( aea <* USEDIN(e,'CATALOG_DATA_INFORMATION_MIM_LF' + '.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY') | 
		('CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF ( aea ) ) AND 
		(SIZEOF( QUERY( i <* aea.items | 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i) )) > 0) )) = 0))) 
	)) = 0; 
END_RULE; 

RULE restrict_externally_defined_item_relationship FOR
    (externally_defined_item_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( edir <* externally_defined_item_relationship | 
	( edir. name = 'name scope' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY' IN TYPEOF ( edir.relating_item ) ) OR 
	NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir. relating_item.source ) )
     OR 
	NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' IN TYPEOF ( edir. related_item ) ) OR 
	NOT ('CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) ) =0;
END_RULE;

RULE restrict_external_identification_assignment FOR 
	(applied_external_identification_assignment);
WHERE
WR1: SIZEOF(QUERY(aeia <* applied_external_identification_assignment |
   (aeia.role.name = 'alternative document id and location') AND 
   (NOT item_correlation (aeia.items, ['DOCUMENT_FILE']))))=0; 
WR2: SIZEOF(QUERY(aeia <* applied_external_identification_assignment |
   (aeia.role.name = 'version') AND 
   (NOT item_correlation (aeia.items, ['EXTERNALLY_DEFINED_CLASS', 'EXTERNALLY_DEFINED_GENERAL_PROPERTY']))
	))=0; 
END_RULE;

RULE restrict_group_assignment FOR 
	(applied_group_assignment);
WHERE
WR2: SIZEOF(QUERY(aeia <* applied_group_assignment |
 (aeia.role.name = 'group membership') AND
  (NOT item_correlation (aeia.items, ['GEOMETRIC_REPRESENTATION_ITEM', 'SHAPE_ASPECT'])) 
	))=0; 
WR3: SIZEOF(QUERY(aeia <* applied_group_assignment |
 (aeia.role.name = 'group membership') AND
 (NOT  ((SIZEOF(aeia.items) = SIZEOF( QUERY( i <* aeia.items | 'CATALOG_DATA_INFORMATION_MIM_LF' + '.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(i)))) OR 
  (SIZEOF(aeia.items) = SIZEOF( QUERY( i <* aeia.items | 'CATALOG_DATA_INFORMATION_MIM_LF' + '.SHAPE_ASPECT' IN TYPEOF(i)))))) 
	))=0; 
END_RULE;

RULE restrict_multi_language_for_alternate_product_relationship FOR
    (alternate_product_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* alternate_product_relationship |
	NOT allowed_translations (ent, ['basis']) ))=0;
END_RULE;

RULE restrict_multi_language_for_application_context FOR
    (application_context);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* application_context | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_approval_relationship FOR
    (approval_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* approval_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_assembly_component_usage_substitute FOR
    (assembly_component_usage_substitute);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* assembly_component_usage_substitute | 
	NOT allowed_translations (ent, ['definition']) ))=0;
END_RULE;

RULE restrict_multi_language_for_certification FOR
    (certification);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* certification | 
	NOT allowed_translations (ent, ['purpose', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_configuration_design FOR
    (configuration_design);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* configuration_design | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_configuration_item FOR
    (configuration_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* configuration_item | 
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_contract FOR
    (contract);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* contract | 
	NOT allowed_translations (ent, ['purpose']) ))=0;
END_RULE;

RULE restrict_multi_language_for_data_environment FOR
    (data_environment);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* data_environment | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_date_role FOR
    (date_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* date_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_date_time_role FOR
    (date_time_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* date_time_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_descriptive_representation_item FOR
    (descriptive_representation_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* descriptive_representation_item |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_document_relationship FOR
    (document_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* document_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_effectivity FOR
    (effectivity);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* effectivity | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_effectivity_relationship FOR
    (effectivity_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* effectivity_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_event_occurrence FOR
    (event_occurrence);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* event_occurrence | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_external_source FOR
    (external_source);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* external_source | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_general_property FOR
    (general_property);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* general_property | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_general_property_relationship FOR
    (general_property_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* general_property_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_geometric_representation_item FOR
    (geometric_representation_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* geometric_representation_item |
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_group FOR
    (group);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* group | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_group_relationship FOR
    (group_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* group_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_identification_role FOR
    (identification_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* identification_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_mapped_item FOR
    (mapped_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* mapped_item | 
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_organization_relationship FOR
    (organization_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organization_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_organization_role FOR
    (organization_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organization_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_organizational_project FOR
    (organizational_project);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organizational_project | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_organizational_project_relationship FOR
    (organizational_project_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organizational_project_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_person_and_organization_role FOR
    (person_and_organization_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* person_and_organization_role |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product FOR
    (product);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_concept FOR
    (product_concept);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_concept_feature FOR
    (product_concept_feature);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_feature | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_concept_feature_association FOR
    (product_concept_feature_association);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_feature_association | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_concept_relationship FOR
    (product_concept_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_definition FOR
    (product_definition);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_definition_formation FOR
    (product_definition_formation);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_formation |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_definition_formation_relationship FOR
    (product_definition_formation_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <*
     product_definition_formation_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_definition_relationship FOR
    (product_definition_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_definition_substitute FOR
    (product_definition_substitute);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_substitute |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_product_related_product_category FOR
    (product_related_product_category);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_related_product_category |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_property_definition FOR
    (property_definition);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* property_definition | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* representation | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_representation_relationship FOR
    (representation_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* representation_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_security_classification FOR
    (security_classification);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* security_classification | 
	NOT allowed_translations (ent, ['purpose', 'name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_shape_aspect FOR
    (shape_aspect);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* shape_aspect | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_shape_aspect_relationship FOR
    (shape_aspect_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* shape_aspect_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_time_interval_role FOR
    (time_interval_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* time_interval_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_uncertainty_measure_with_unit FOR
    (uncertainty_measure_with_unit);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* uncertainty_measure_with_unit |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_uncertainty_qualifier FOR
    (uncertainty_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* uncertainty_qualifier | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_name_for_known_source FOR
    (known_source);
WHERE
 WR1: SIZEOF ( QUERY ( ks <* known_source | 
	( ks.name<>'ISO 13584 library' ) ) ) =0;
END_RULE;

RULE restrict_organization_assignment FOR
	(applied_organization_assignment);
WHERE
WR1: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'organization in contract') AND 
  (NOT item_correlation (aoa.items, ['CONTRACT'])) 
	))= 0;
WR2: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'signing for contract') AND 
  (NOT item_correlation (aoa.items, ['APPLIED_ORGANIZATION_ASSIGNMENT'])) 
	))= 0;
WR3: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'validity context') AND
  (NOT item_correlation (aoa.items, ['PROPERTY_DEFINITION'])) 
	))= 0;
WR4: SIZEOF(QUERY(aoa <* applied_organization_assignment |
 (aoa.role.name = 'alias scope') AND 
  (NOT  item_correlation (aoa.items, ['APPLIED_IDENTIFICATION_ASSIGNMENT']))
	))= 0;
END_RULE;

RULE restrict_person_and_organization_assignment FOR
	(applied_person_and_organization_assignment);
WHERE
WR1: SIZEOF(QUERY(aoa <* applied_person_and_organization_assignment |
 (aoa.role.name = 'signing for contract') AND
    (NOT item_correlation (aoa.items, ['APPLIED_ORGANIZATION_ASSIGNMENT']))
	))= 0;
END_RULE;

RULE restrict_product_categories_for_tool_part_relationship FOR
    (product_definition_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name = 'tool part relationship' ) AND 
	( ( SIZEOF (QUERY ( prpc <* USEDIN ( pdr.relating_product_definition.formation.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='tool') ) <1 ) OR 
	( SIZEOF ( QUERY (prpc <* USEDIN ( pdr. related_product_definition.formation.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name ='part') ) <1 ) ) ) ) =0;
END_RULE;

RULE restrict_product_category_for_product FOR (product); 
WHERE 
WR1: SIZEOF(QUERY(p <* product | 
  SIZEOF(QUERY(prpc <* USEDIN(p, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
   prpc.name IN ['part','document','functionality', 'conceptual product','alternative solution','requirement', 'physically realized product','tool','raw material'] ) ) 
	<> 1 )) = 0; 
END_RULE; 

RULE restrict_product_definition_context_for_external_properties FOR
    (product_definition);
WHERE
WR1: SIZEOF ( QUERY (pd <* product_definition | 
	(SIZEOF (QUERY ( propd <* USEDIN ( pd, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' ) | 
	  SIZEOF ( QUERY (gpa <* USEDIN ( propd , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION' )| 
	  'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY' IN TYPEOF (gpa.base_definition ) ) ) > 0 ) ) > 0 ) AND 
	  ( SIZEOF (QUERY ( pdca <* USEDIN ( pd, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION' )| 
		(pdca.frame_of_reference.name = 'external') AND
      	(pdca.role.name = 'external') ) ) = 0 ) ) ) = 0;
END_RULE;

RULE restrict_product_definition_context_for_product FOR
    (product_definition);
WHERE
WR2: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name = 'functional definition' ) AND 
	(SIZEOF ( QUERY ( prpc <* USEDIN ( pd. formation.of_product,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='functionality' ) ) =0 ) ) ) =0;
WR3: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name = 'conceptual definition' ) AND 
	(SIZEOF ( QUERY ( prpc <* USEDIN ( pd. formation.of_product,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
 	prpc.name = 'conceptual product' ) ) =0 ) ) ) =0;
WR7: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name IN ['physical document definition',
	'digital document definition',
	'physical model_occurrence'] ) AND 
	( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='document' ) ) =0 ) ) ) =0;
END_RULE;

RULE restrict_product_definition_substitute FOR
    (product_definition_substitute);
WHERE
WR1: SIZEOF ( QUERY ( pds <* product_definition_substitute | 
	(SIZEOF ( USEDIN ( pds ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS' ) ) =0 ) ) ) =0;
WR2: SIZEOF ( QUERY ( pds <* product_definition_substitute |
     pds.substitute_definition.frame_of_reference.name <> 'part occurrence' ) ) =0;
WR3: SIZEOF ( QUERY ( pds <* product_definition_substitute | (
     ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( pds.context_relationship ) ) AND 
     ( SIZEOF (USEDIN ( pds.context_relationship , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE_USAGE' ) ) =0 ) ) AND 
	(( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF ( pds.context_relationship ) ) AND 
	( pds.context_relationship.related_product_definition.frame_of_reference.name <> 'part occurrence' ) ) ) ) =0;
END_RULE;

RULE restrict_product_definitions_for_product_definition_relationship FOR
    (product_definition_relationship);
WHERE
WR3: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( pdr ) ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <> 'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <> 'part definition' ) ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <>'physical occurrence' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <>'physical occurrence' ) ) ) ) =0;
WR5: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'physical realization') AND 
	((pdr.relating_product_definition.frame_of_reference.name <> 'part definition') OR 
	(pdr.related_product_definition.frame_of_reference.name <> 'physical occurrence')) )) = 0; 
WR6: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'physical occurrence usage') AND 
	(NOT('CATALOG_DATA_INFORMATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)) OR 
	(pdr.relating_product_definition.frame_of_reference.name <> 'physical occurrence') OR 
	(pdr.related_product_definition.frame_of_reference.name <> 'physical occurrence')) )) = 0; 
END_RULE;

RULE restrict_properties_of_document_file FOR
    (document_file);
WHERE
WR1: SIZEOF ( QUERY ( df <* document_file | 
	SIZEOF ( QUERY ( pd <* USEDIN ( df ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' )| 
	pd.name = 'document property' ) ) >1 ) ) =0;
WR2: SIZEOF ( QUERY ( df <* document_file | 
	SIZEOF ( QUERY ( rt<* df.representation_types | 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DOCUMENT_REPRESENTATION_TYPE' IN TYPEOF ( rt ) ) AND 
	( rt.name IN ['digital' , 'physical'] ) ) ) =0 ) ) =0;
END_RULE;

RULE restrict_properties_of_document_representation FOR
    (product_definition);
WHERE
 WR1: SIZEOF ( QUERY ( pd <* product_definition | 
	(pd.frame_of_reference.name IN 
	  ['physical document definition', 'digital document definition' ,'physical model occurrence' ] ) AND 
	( SIZEOF ( QUERY ( pd1 <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' )| 
	pd1.name = 'document property' ) ) >1 ) ) ) =0;
END_RULE;

RULE restrict_representation_for_document_content_property FOR
    (representation,
     representation_item);
LOCAL
  document_content_representations: SET OF representation := [];
END_LOCAL;
  document_content_representations :=  QUERY( r <* representation |
	(r.name ='document content' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_content_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR ( SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document content' ) ) >0 ) AND 
	NOT ( ri. name IN ['detail level' , 'geometry type' , 'real world scale' ] ) )) =0;
WR3: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |( it.name = 'detail level' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( it ) ) ) ) >1) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |
     ( it.name = 'geometry type' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( it ) ) ) ) >1 ) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |( it.name = 'real world scale' ) AND 
	( SIZEOF (
     ['CATALOG_DATA_INFORMATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF( it ) ) =1 ) ) ) >1 ) ) ) =0;
END_RULE;

RULE restrict_representation_for_document_creation_property FOR
    (representation,
     representation_item);
LOCAL
  document_creation_representations: SET OF representation := [];
END_LOCAL;
  document_creation_representations :=  QUERY( r <* representation |
	(r.name ='document creation' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document creation' ) ) >0 ) AND 
	NOT ( ri. name IN [ 'creating interface' , 'creating system' ,'operating system' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'creating interface' ) AND (
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) >1 ) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'creating system' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) <>1 ) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'operating system' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) >1) ) ) =0;
END_RULE;

RULE restrict_representation_for_document_format_property FOR
    (representation,
     representation_item);
LOCAL
  document_format_representations: SET OF representation := [];
END_LOCAL;
  document_format_representations :=  QUERY( r <* representation |
	(r.name ='document format' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_format_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document format' ) ) >0 ) AND 
	NOT ( ri. name IN ['character code' , 'data format' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'character code' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) ) >1) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'data format' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) ) >1) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items| ( i.name =  'size format' ) AND 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PLANAR_EXTENT' IN TYPEOF ( i ) ) ) ) >1 ) ) ) =  0;
END_RULE;

RULE restrict_representation_for_document_properties FOR
    (property_definition,
     representation,
     representation_context);
WHERE
WR1: SIZEOF ( QUERY ( pd <* property_definition | 
	( pd. name ='document property' ) AND 
	( SIZEOF ( QUERY ( pdr <* USEDIN( pd ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	NOT ( pdr.used_representation.name IN ['document content' , 'document creation' ,
     'document format' , 'document size' ] ) ) ) >0 ) ) ) =0;
WR2: SIZEOF ( QUERY ( r <* representation | 
	( r.name IN [ 'document content' , 'document creation' , 'document format' , 'document size' ] ) AND 
	( SIZEOF (QUERY ( pdr <* USEDIN ( r ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PROPERTY_DEFINITION' IN TYPEOF( pdr. definition ) ) AND 
	( pdr. definition.name = 'document property' ) ) ) =0 ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* representation | 
	( r.name IN ['document content' , 'document creation' , 'document format' , 'document size' ] ) AND 
	(r.context_of_items.context_type<> 'document parameters' )) ) =0;
WR4: SIZEOF ( QUERY ( rc <* representation_context | 
	( rc.context_type = 'document parameters' ) AND 
	( SIZEOF ( QUERY( r <* USEDIN ( rc ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.REPRESENTATION.CONTEXT_OF_ITEMS' ) | 
	NOT( r.name IN [ 'document content' , 'document creation' ,
     'document format' , 'document size' ] ) ) ) >0 ) ) ) =0;
END_RULE;

RULE restrict_representation_for_document_size_property FOR
    (representation,
     representation_item);
LOCAL
  document_size_representations: SET OF representation := [];
END_LOCAL;
  document_size_representations :=  QUERY( r <* representation |
	(r.name ='document size'));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_size_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >2 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | ( SIZEOF (
     QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document size' ) ) >0 ) AND 
	NOT ( ri. name IN ['file size' , 'page count' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_size_representations| 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'file size' ) AND 
	( SIZEOF (
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_RANGE' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) =1 ) ) ) >1 ) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_size_representations | 
	( SIZEOF ( QUERY ( i <* r.items | ( i.name = 'page count' ) AND 
	( SIZEOF ( 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_RANGE' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) =1 ) ) ) >1 )) ) =0;
END_RULE;

RULE restrict_version_assignment_for_applied_identification_assignment FOR
    (applied_identification_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ent <* applied_identification_assignment| 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_class FOR
    (class);
WHERE
WR1: SIZEOF ( QUERY ( ent <* class | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_configuration_item FOR
    (configuration_item);
WHERE
WR1: SIZEOF ( QUERY ( ent <* configuration_item | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_document_file FOR
    (document_file);
WHERE
WR1: SIZEOF ( QUERY ( ent <* document_file | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_effectivity FOR
    (effectivity);
WHERE
WR1: SIZEOF ( QUERY ( ent <* effectivity | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_general_property FOR
    (general_property);
WHERE
WR1: SIZEOF ( QUERY ( ent <* general_property | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_product_concept FOR
    (product_concept);
WHERE
WR1: SIZEOF ( QUERY ( ent <* product_concept | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_product_concept_feature FOR
    (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( ent <* product_concept_feature | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_version_assignment_for_shape_representation FOR
    (shape_representation);
WHERE
WR1: SIZEOF ( QUERY ( ent <* shape_representation | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE security_classification_requires_security_classification_assignment FOR
    (security_classification);
WHERE
 WR1: SIZEOF ( QUERY ( sc <* security_classification | 
	SIZEOF (USEDIN ( sc ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.SECURITY_CLASSIFICATION_ASSIGNMENT.ASSIGNED_SECURITY_CLASSIFICATION' ) ) =0 ) ) =0;
END_RULE;

RULE subtype_exclusiveness_characterized_object FOR
    (characterized_object);
WHERE
WR1: SIZEOF ( QUERY ( co <* characterized_object | NOT (
     type_check_function ( co , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.CHARACTERIZED_CLASS' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.DOCUMENT_FILE' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.FEATURE_COMPONENT_DEFINITION' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.FEATURE_DEFINITION' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CLASS' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_IDENTIFICATION'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_classification_assignment FOR
    (classification_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ca <* classification_assignment | NOT (
     type_check_function ( ca , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.LANGUAGE_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_compound_representation_item FOR
    (compound_representation_item);
WHERE
WR1: SIZEOF ( QUERY ( cri <* compound_representation_item | NOT
     ( type_check_function ( cri , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.DEFAULT_TOLERANCE_TABLE_CELL' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_RANGE'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_document_reference FOR
    (document_reference);
WHERE
 WR1: SIZEOF ( QUERY ( dr <* document_reference | NOT (
     type_check_function ( dr , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_DOCUMENT_REFERENCE' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.DRAUGHTING_SPECIFICATION_REFERENCE'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_effectivity FOR
    (effectivity);
WHERE
 WR1: SIZEOF ( QUERY ( e <* effectivity | NOT (
     type_check_function ( e , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_effectivity_assignment FOR
    (effectivity_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ea <* effectivity_assignment | NOT (
     type_check_function ( ea , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_INEFFECTIVITY_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_effectivity_context_assignment FOR
    (effectivity_context_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( eca <* effectivity_context_assignment |
     NOT ( type_check_function ( eca , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_externally_defined_item FOR
    (externally_defined_item);
WHERE
 WR1: SIZEOF ( QUERY ( edi <* externally_defined_item | NOT (
     type_check_function ( edi , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CHARACTER_GLYPH' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CURVE_FONT' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_FEATURE_DEFINITION' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY',
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_HATCH_STYLE' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_STYLE' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_SYMBOL' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_TEXT_FONT' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_TILE_STYLE'] , 3
     ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_group FOR
    (group);
WHERE
 WR1: SIZEOF ( QUERY ( g <* group | NOT ( type_check_function ( g , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.CLASS' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.CLASS_SYSTEM' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.LANGUAGE' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.REP_ITEM_GROUP'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_group_assignment FOR
    (group_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ga <* group_assignment | NOT (
     type_check_function ( ga , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_GROUP_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_identification_assignment FOR
    (identification_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ia <* identification_assignment | NOT (
     type_check_function ( ia , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNAL_IDENTIFICATION_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_property_definition FOR
    (property_definition);
WHERE
 WR1: SIZEOF ( QUERY ( pd <* property_definition | NOT (
     type_check_function ( pd , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.MATERIAL_PROPERTY' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_SHAPE'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_property_definition_representation FOR
    (property_definition_representation);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* property_definition_representation| 
	NOT ( type_check_function ( pdr , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.MATERIAL_PROPERTY_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.SHAPE_DEFINITION_REPRESENTATION'] ,3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_representation FOR (representation); 
WHERE 
WR1: SIZEOF(QUERY (r <* representation | 
NOT (type_check_function(r, 
['CATALOG_DATA_INFORMATION_MIM_LF' + '.CONSTRUCTIVE_GEOMETRY_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.CONTACT_RATIO_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.DEFAULT_TOLERANCE_TABLE', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.DEFINITIONAL_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.DIRECTION_SHAPE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.HARDNESS_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.MOMENTS_OF_INERTIA_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.SHAPE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.SURFACE_TEXTURE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.TACTILE_APPEARANCE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.TEXT_STRING_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_MIM_LF' + '.VISUAL_APPEARANCE_REPRESENTATION'] , 3 ) 
))) = 0; 
END_RULE; 

RULE subtype_exclusiveness_representation_item FOR
    (representation_item);
WHERE
WR1: SIZEOF ( QUERY ( ri <* representation_item | NOT (
     type_check_function ( ri , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.REP_ITEM_GROUP' , 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_mandatory_address FOR
    (address);
WHERE
WR1: SIZEOF ( QUERY ( a <* address | NOT ( type_check_function( a , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.ORGANIZATIONAL_ADDRESS' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PERSONAL_ADDRESS'] , 0 ) ) ) ) =0;
END_RULE;

RULE subtype_mandatory_configurable_item FOR
    (configurable_item);
WHERE
 WR1: SIZEOF ( QUERY ( ci <* configurable_item | NOT (
     type_check_function ( ci , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_SPECIFICATION'] , 0 ) ) ) ) =0;
END_RULE;

RULE subtype_mandatory_document_product_association FOR
    (document_product_association);
WHERE
 WR1: SIZEOF ( QUERY ( dpa <* document_product_association | NOT
     ( type_check_function ( dpa , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.DOCUMENT_PRODUCT_EQUIVALENCE'] , 0 ) ) ) ) =0;
END_RULE;

RULE subtype_mandatory_externally_defined_item FOR
    (externally_defined_item);
WHERE
 WR1: SIZEOF ( QUERY ( edi <* externally_defined_item | NOT (
     type_check_function ( edi , 
	['CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CHARACTER_GLYPH' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CURVE_FONT' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_FEATURE_DEFINITION' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY',
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_HATCH_STYLE' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_STYLE' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_SYMBOL' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_TEXT_FONT' ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_TILE_STYLE'] , 0 ) ) ) ) =0;
END_RULE;

FUNCTION at_most_one_class_system (ent: GENERIC_ENTITY): LOGICAL;
RETURN(
  SIZEOF ( QUERY (ia <* USEDIN ( ent , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS' ) | 
	ia.role.name = 'class system membership' ) )<=1 );
END_FUNCTION;

FUNCTION at_most_one_version_id (ent: GENERIC_ENTITY): LOGICAL;
RETURN(
  SIZEOF ( QUERY ( ia <* USEDIN ( ent , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS' ) | 
	ia.role.name ='version' ) ) <=1 );
END_FUNCTION;

FUNCTION item_correlation 
         (items : SET OF GENERIC_ENTITY; c_items: SET OF STRING): LOGICAL;
LOCAL
  c_types   : SET OF STRING := [];
  c_hit     : INTEGER := 0;
END_LOCAL;
 
REPEAT i:=1 TO HIINDEX(c_items);
  c_types := c_types + ['CATALOG_DATA_INFORMATION_MIM_LF' + '.' + c_items[i]];
END_REPEAT;

REPEAT i:=1 TO HIINDEX(items);
  IF (SIZEOF(c_types * TYPEOF(items[i])) = 1) THEN
    c_hit := c_hit + 1;
  END_IF;
END_REPEAT;

RETURN (SIZEOF(items) = c_hit);
END_FUNCTION;

FUNCTION allowed_translations ( ent: GENERIC_ENTITY; translatable_attributes: SET OF STRING): LOGICAL;

	LOCAL
	  mlaa: BAG OF multi_language_attribute_assignment;
	  ala: BAG OF attribute_language_assignment;
	END_LOCAL;
			
	IF (SIZEOF(translatable_attributes)=0) THEN
	  RETURN(UNKNOWN);
	END_IF;
			
	mlaa:= USEDIN ( ent , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS' );
			
	REPEAT i:=1 TO HIINDEX(mlaa);
	  IF NOT (mlaa[i].attribute_name IN translatable_attributes) THEN
		RETURN(FALSE);
	  END_IF;
	END_REPEAT;
			
	ala:= USEDIN ( ent , 'CATALOG_DATA_INFORMATION_MIM_LF' + '.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' );
			
	REPEAT i:=1 TO HIINDEX(ala);
	  IF NOT (ala[i].attribute_name IN translatable_attributes) THEN
		RETURN(FALSE);
	  END_IF;
	END_REPEAT;
			
	RETURN(TRUE);
END_FUNCTION;


(*
   ------------------------------------------------------------
../data/modules/Activity/mim.exp
   ------------------------------------------------------------
*)


TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Activity_Method/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Alias_Identification/mim.exp
   ------------------------------------------------------------
*)


TYPE aliasable_item = EXTENSIBLE SELECT;
END_TYPE; 



(*
   ------------------------------------------------------------
../data/modules/Alternative_Solution/mim.exp
   ------------------------------------------------------------
*)


TYPE organization_item_solution = SELECT BASED_ON organization_item WITH (product_definition);
END_TYPE;

RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
LOCAL
  solution_versions: SET OF product_definition_formation := [];
END_LOCAL;
  solution_versions :=  QUERY( pdf <* product_definition_formation |
	SIZEOF( QUERY( prpc <* USEDIN(pdf.of_product, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name = 'alternative solution')) = 1);
WHERE 
WR1: SIZEOF( QUERY( pdf <* solution_versions |
SIZEOF( QUERY( pd <* USEDIN(pdf, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION.FORMATION') | 
 pd.frame_of_reference.name = 'alternative definition')) <> 1))= 0; 
END_RULE;

RULE restrict_alternative_definition FOR (product_definition);
LOCAL
  solution_definitions: SET OF product_definition := [];
END_LOCAL;
  solution_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'alternative definition'));
WHERE
WR1: SIZEOF ( QUERY ( pd <* solution_definitions | 
	( SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	pdr.name = 'solution alternative definition' ) ) <>1 ) ) ) = 0;
WR2: SIZEOF ( QUERY ( pd <* solution_definitions | 
	NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0;
WR3: SIZEOF ( QUERY ( pd <* solution_definitions | 
	( pd.name IN ['supplier' , 'technical supplier'] ) AND (
	SIZEOF ( QUERY ( aoa <* USEDIN ( pd.formation ,
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | 
	aoa.role.name = 'supplier' )) <>1 ) )) = 0;
END_RULE; 

RULE solution_definition_requires_solution_category FOR (product_definition);
LOCAL
  solution_definitions: SET OF product_definition := [];
END_LOCAL;
  solution_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'alternative definition'));
WHERE
WR1: SIZEOF( QUERY( pd <* solution_definitions | 
(SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name = 'alternative solution')) = 0 ) )) = 0;
END_RULE;

RULE restrict_product_definitions_for_base_element FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'solution alternative definition' ) AND 
	( NOT( pdr. relating_product_definition.frame_of_reference.name
     IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'alternative definition' ) ) ) ) =0;
END_RULE;


(*
   ------------------------------------------------------------
../data/modules/Approval/mim.exp
   ------------------------------------------------------------
*)


TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH 
   (approval_person_organization);
END_TYPE; 

TYPE date_item_approval = SELECT BASED_ON date_item WITH 
   (approval_person_organization);
END_TYPE; 

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET[1:?] OF approval_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Assembly_Structure/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Basic_Curve/mim.exp
   ------------------------------------------------------------
*)


		
	
	
TYPE bc_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (trimmed_curve);
END_TYPE;
	


(*
   ------------------------------------------------------------
../data/modules/Basic_Geometry/mim.exp
   ------------------------------------------------------------
*)


	
	 -- required by mapping




(*
   ------------------------------------------------------------
../data/modules/Certification/mim.exp
   ------------------------------------------------------------
*)


TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Characterizable_Object/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Class/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Classification_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Classification_With_Attributes/mim.exp
   ------------------------------------------------------------
*)


TYPE classification_classification_item = EXTENSIBLE SELECT BASED_ON classification_item WITH
  (class);
END_TYPE;

TYPE classification_identification_item = EXTENSIBLE SELECT BASED_ON identification_item WITH
  (class);
END_TYPE;

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
      product, 
      product_definition_formation,
      product_definition);
END_TYPE;

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (product, product_definition_formation, product_definition);
END_TYPE;

TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT(characterized_class);
END_TYPE;

TYPE id_for_class = SELECT BASED_ON identification_item WITH (characterized_class);
END_TYPE;

TYPE version_for_class = SELECT BASED_ON versionable_item WITH (characterized_class);
END_TYPE;


ENTITY characterized_class
SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY class_system 
SUBTYPE OF (group); 
END_ENTITY; 


RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE;

FUNCTION class_assignment_is_valid (aia: applied_classification_assignment): BOOLEAN;
LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia.role;
IF ('CATALOG_DATA_INFORMATION_MIM_LF.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
  IF(role.name <> 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('CATALOG_DATA_INFORMATION_MIM_LF.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
  IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;

  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);
END_FUNCTION;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship); 
WHERE 
WR1: SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'class hierarchy') AND 
  (NOT('CATALOG_DATA_INFORMATION_MIM_LF.CLASS' IN TYPEOF(gr.related_group)) OR 
  NOT('CATALOG_DATA_INFORMATION_MIM_LF.CLASS' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 



(*
   ------------------------------------------------------------
../data/modules/Configuration_Effectivity/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Configuration_Item/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Construction_Geometry/mim.exp
   ------------------------------------------------------------
*)


ENTITY constructive_geometry_representation
  SUBTYPE OF (representation);
WHERE
  WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
  WR2: SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.PLACEMENT', 'CATALOG_DATA_INFORMATION_MIM_LF.CURVE', 'CATALOG_DATA_INFORMATION_MIM_LF.EDGE', 'CATALOG_DATA_INFORMATION_MIM_LF.FACE', 'CATALOG_DATA_INFORMATION_MIM_LF.POINT', 'CATALOG_DATA_INFORMATION_MIM_LF.SURFACE', 'CATALOG_DATA_INFORMATION_MIM_LF.FACE_SURFACE', 'CATALOG_DATA_INFORMATION_MIM_LF.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
  WR3: SIZEOF( USEDIN( SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
  WR4: SIZEOF( USEDIN( SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
END_ENTITY;

ENTITY constructive_geometry_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2);
  WR3: SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_REPRESENTATION', 'CATALOG_DATA_INFORMATION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1;
  WR4: NOT('CATALOG_DATA_INFORMATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Contextual_Shape_Positioning/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Contract/mim.exp
   ------------------------------------------------------------
*)


TYPE contract_item = EXTENSIBLE SELECT; 
END_TYPE;
   
   
ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Date_Time/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Date_Time_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE date_item = EXTENSIBLE SELECT; 
END_TYPE;
   
TYPE date_and_time_item = EXTENSIBLE SELECT; 
END_TYPE;
   
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
   
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Derived_Shape_Element/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Dimension_Tolerance/mim.exp
   ------------------------------------------------------------
*)


TYPE dimension_identification_item = SELECT BASED_ON identification_item WITH 
   (dimensional_size);
END_TYPE; 

TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (dimensional_size, 
    externally_defined_dimension_definition);
END_TYPE; 

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY externally_defined_dimension_definition
  SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
  WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
  WR2: 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Document_And_Version_Identification/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Document_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE document_reference_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  WR3: NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Document_Definition/mim.exp
   ------------------------------------------------------------
*)


TYPE document_location_select = SELECT BASED_ON external_identification_item WITH 
   (product_definition);
END_TYPE; 



(*
   ------------------------------------------------------------
../data/modules/Document_Management/mim.exp
   ------------------------------------------------------------
*)


TYPE dm_aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON aliasable_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (product_definition_formation);
END_TYPE; 

TYPE dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 




(*
   ------------------------------------------------------------
../data/modules/Document_Properties/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Document_Structure/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Effectivity_Application/mim.exp
   ------------------------------------------------------------
*)


TYPE effectivity_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Effectivity/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Elemental_Geometric_Shape/mim.exp
   ------------------------------------------------------------
*)


-- ISO 10303-45







TYPE representation_identification_item = SELECT BASED_ON identification_item WITH 
  (shape_representation);
END_TYPE; 
 
TYPE representation_version_item = SELECT BASED_ON versionable_item WITH 
  (shape_representation);
END_TYPE;


(*
   ------------------------------------------------------------
../data/modules/Event/mim.exp
   ------------------------------------------------------------
*)


TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (event_occurrence);
END_TYPE; 




(*
   ------------------------------------------------------------
../data/modules/Event_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Extended_Basic_Geometry/mim.exp
   ------------------------------------------------------------
*)


		--		
	
		
		



  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
   WHERE
    WR1: acyclic_representation_relationship(SELF,
       [SELF\representation_relationship.rep_2],
       'CATALOG_DATA_INFORMATION_MIM_LF.'+
       'REPRESENTATION');
  END_ENTITY;  
	
ENTITY geometric_model_element_relationship
  SUBTYPE OF (geometric_representation_item, representation_item_relationship);
UNIQUE
  UR1: SELF\representation_item_relationship.relating_representation_item, 
       SELF\representation_item_relationship.related_representation_item;
WHERE
  WR1: SELF\representation_item_relationship.relating_representation_item :<>: 
       SELF\representation_item_relationship.related_representation_item;
END_ENTITY; 

FUNCTION acyclic_representation_relationship
 (relation : representation_relationship; relatives : SET[1:?] OF representation; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 
	
	


(*
   ------------------------------------------------------------
../data/modules/Extended_Measure_Representation/mim.exp
   ------------------------------------------------------------
*)


ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ( 'value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
  WR2: value_range_wr2 ( item_element );
  WR3: value_range_wr3 ( item_element );
END_ENTITY;

RULE subtype_exclusiveness_representation_item FOR 
(representation_item);
WHERE
  WR1: SIZEOF(QUERY (cri <* representation_item | NOT (type_check_function(cri,['CATALOG_DATA_INFORMATION_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
END_RULE; 

FUNCTION value_range_wr1
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
'CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 <* agg | (
'CATALOG_DATA_INFORMATION_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

FUNCTION value_range_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY (i <* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i <* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

FUNCTION value_range_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY(i1 <* agg |
('CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 <* agg |
('CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
(i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;
      END_FUNCTION; 



(*
   ------------------------------------------------------------
../data/modules/External_Class/mim.exp
   ------------------------------------------------------------
*)


TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
   (external_class_library);
END_TYPE; 

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/External_Item_Identification_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/External_Model/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/External_Properties/mim.exp
   ------------------------------------------------------------
*)


TYPE external_identification_for_plib_property = SELECT BASED_ON external_identification_item WITH (externally_defined_general_property);
END_TYPE;

TYPE externally_versioned_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

TYPE version_for_plib_property = SELECT BASED_ON externally_versioned_item WITH (externally_defined_general_property);
END_TYPE;

ENTITY externally_defined_general_property 
SUBTYPE OF (general_property, externally_defined_item); 
END_ENTITY; 


RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia <* applied_external_identification_assignment | 
		NOT external_version_assignment_is_valid(aia)))=0;
END_RULE;


RULE plib_property_reference_requires_version FOR (externally_defined_general_property); 
	LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	plib_properties := QUERY ( edgp <* externally_defined_general_property | 
		( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' + '\PRE_DEFINED_ITEM.NAME' = 'ISO 13584 library' ) ); 
	WHERE 
	WR1: SIZEOF( QUERY( edgp <* plib_properties | 
		(SIZEOF( QUERY( edir <* USEDIN(edgp, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
		(edir.role.name = 'version') )) <> 1) )) = 0; 
END_RULE;

RULE plib_property_reference_requires_name_scope FOR (
      externally_defined_general_property);
LOCAL
   known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
  known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
	'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE
WR1: SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
   ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
	( edir.name =  'name scope' ) AND 
      ('CATALOG_DATA_INFORMATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
      ( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
END_RULE; 

FUNCTION external_version_assignment_is_valid (aia: applied_external_identification_assignment): BOOLEAN;
LOCAL
  item: identification_item;
  role: identification_role;
END_LOCAL;

role:= aia.role;
IF role.name='version' THEN
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to versionable types
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);

ELSE		-- case where aia does not convey a version id
  RETURN(TRUE);
END_IF;
END_FUNCTION;


(*
   ------------------------------------------------------------
../data/modules/File_Identification/mim.exp
   ------------------------------------------------------------
*)


TYPE file_identification_item = SELECT BASED_ON identification_item WITH (document_file);
END_TYPE; 

TYPE file_version_item = SELECT BASED_ON versionable_item WITH
  (document_file);
END_TYPE;

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (document_file);
END_TYPE;

ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Foundation_Representation/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Functional_Breakdown/mim.exp
   ------------------------------------------------------------
*)


ENTITY functional_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY functional_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Generic_Product_Occurrence/mim.exp
   ------------------------------------------------------------
*)


				


(*
   ------------------------------------------------------------
../data/modules/Group/mim.exp
   ------------------------------------------------------------
*)


-- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Identification_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE identification_item = EXTENSIBLE SELECT;
END_TYPE; 

TYPE versionable_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Incomplete_Data_Reference_Mechanism/mim.exp
   ------------------------------------------------------------
*)


TYPE idrm_marked_item  = EXTENSIBLE SELECT BASED_ON classification_item WITH
      (product_definition, document_file);
END_TYPE;


(*
   ------------------------------------------------------------
../data/modules/Independent_Property/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Independent_Property_Representation/mim.exp
   ------------------------------------------------------------
*)


(*
 $Id: mim.exp,v 1.10 2006/03/24 18:37:02 thendrix Exp $
 ISO TC184/SC4/WG12 N4372 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
 upersedes ISO TC184/SC4/WG12 N1244
*)


(*
   ------------------------------------------------------------
../data/modules/Inertia_Characteristics/mim.exp
   ------------------------------------------------------------
*)


ENTITY moments_of_inertia_representation 
SUBTYPE OF (representation); 
WHERE 
WR1: (SIZEOF(SELF.items) = 1) AND 
 (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i.name = 'moments of inertia matrix') )) = 1); 
WR2: SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  ('CATALOG_DATA_INFORMATION_MIM_LF' + '.LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND 
  value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1; 
END_ENTITY; 

RULE restrict_centre_of_mass_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( r <* representation | 
	( r.name ='centre of mass' ) AND 
	( ( SIZEOF ( r.items ) <>1 ) OR 
	(SIZEOF ( QUERY ( i <* r.items | 
	( 'CATALOG_DATA_INFORMATION_MIM_LF' + '.POINT' IN TYPEOF ( i ) ) AND 
	( i.name = 'centre point' ) )) <>1 ) ) ) ) 
	=0;
END_RULE;

FUNCTION value_range_aggregate_rep_item (agg : AGGREGATE OF representation_item) : BOOLEAN; 
  BEGIN 
  IF (SIZEOF(QUERY(i1 <* agg | ('CATALOG_DATA_INFORMATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
	  RETURN (TRUE); 
   ELSE 
	RETURN (FALSE); 
   END_IF; 
   END; 
END_FUNCTION; 



(*
   ------------------------------------------------------------
../data/modules/Item_Definition_Structure/mim.exp
   ------------------------------------------------------------
*)


TYPE effectivity_item_for_replacement  = SELECT BASED_ON effectivity_item WITH
  (product_definition_relationship);
END_TYPE;


RULE restrict_assembly_category FOR (product_definition);
LOCAL
  assembly_definitions: SET OF product_definition := [];
END_LOCAL;
  assembly_definitions :=  QUERY( pd <* product_definition | 
    SIZEOF( QUERY( pdca <* USEDIN( pd, 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
    pdca.frame_of_reference.name= 'assembly definition')) > 0 );
WHERE
WR1: SIZEOF( QUERY( pd <* assembly_definitions | 
   NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

RULE restrict_product_definitions_for_part_definition_relationship FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
END_RULE;

RULE product_definition_replacement_requires_effectivity_assignment FOR 
	(product_definition_relationship);
WHERE 
WR1: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'definition replacement') AND 
	(SIZEOF( USEDIN(pdr,'CATALOG_DATA_INFORMATION_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
	 = 0; 
END_RULE; 



(*
   ------------------------------------------------------------
../data/modules/Management_Resource_Information/mim.exp
   ------------------------------------------------------------
*)


TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON aliasable_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification_level);
END_TYPE; 

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (certification, 
    contract);
END_TYPE; 

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification_level);
END_TYPE; 

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 







(*
   ------------------------------------------------------------
../data/modules/Manufacturing_Configuration_Effectivity/mim.exp
   ------------------------------------------------------------
*)


TYPE mce_organization_item = SELECT BASED_ON organization_item WITH
	(configuration_effectivity);
END_TYPE;


(*
   ------------------------------------------------------------
../data/modules/Measure_Representation/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Multi_Linguism/mim.exp
   ------------------------------------------------------------
*)


TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (multi_language_attribute_assignment, 
    attribute_value_assignment);
END_TYPE; 


TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY language 
SUBTYPE OF (group); 
WHERE
WR1: SELF\group.name <> '';
END_ENTITY; 

ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; 

ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'CATALOG_DATA_INFORMATION_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'CATALOG_DATA_INFORMATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY; 


RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'CATALOG_DATA_INFORMATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;


(*
   ------------------------------------------------------------
../data/modules/Name_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Part_And_Version_Identification/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Part_Collection/mim.exp
   ------------------------------------------------------------
*)


RULE restrict_collection_category FOR (product_definition);
LOCAL
  collection_definitions: SET OF product_definition := [];
END_LOCAL;
  collection_definitions :=  QUERY( pd <* product_definition | 
  SIZEOF( QUERY( pdca <* USEDIN( pd, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
  pdca.frame_of_reference.name= 'collection definition')) > 0 );
WHERE
WR1: SIZEOF( QUERY( pd <* collection_definitions | 
	NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

RULE restrict_product_definitions_for_collection FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'collection membership' ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name<>'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' ) OR 
	( SIZEOF ( QUERY ( pdca <* USEDIN (pdr.relating_product_definition ,
     'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | 
	( pdca.role.name = 'part definition type' ) AND 
	( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0;
END_RULE;


(*
   ------------------------------------------------------------
../data/modules/Part_Definition_Relationship/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Part_Occurrence/mim.exp
   ------------------------------------------------------------
*)


TYPE product_definition_or_assembly_relationship = SELECT (assembly_component_usage, product_definition);
END_TYPE;
	
RULE restrict_part_occurrence FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := [];
END_LOCAL;
  part_occurrences := QUERY(pd <* product_definition | 
	( pd.frame_of_reference.name = 'part occurrence' ));
WHERE
WR1: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( NOT( pd.name IN 
['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
WR2: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	(SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	pdr.name = 'definition usage' ) ) <>1 ) AND 
	( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
	( cd.name = 'occurrence usage definition' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
WR3: SIZEOF ( QUERY ( pd <* part_occurrences |  
	(SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
 	( 'CATALOG_DATA_INFORMATION_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
 	( SIZEOF ( USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
WR4: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'selected instance' ) AND 
	NOT valid_selected_instance_representation(pd) ))=0;
WR5: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	( pd.name = 'quantified instance' ) AND 
	( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION' ) |
 	( ppd.name ='occurrence quantity' ) AND 
	( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'CATALOG_DATA_INFORMATION_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
	pdr.used_representation.name = 'quantity' ) AND 
	(SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
 	(SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
	('CATALOG_DATA_INFORMATION_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
	( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
WR6: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'specified instance' ) AND 
	( SIZEOF ( QUERY (
pdor <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
  'CATALOG_DATA_INFORMATION_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
END_RULE;
	
RULE restrict_part_occurrence_category FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := [];
END_LOCAL;
  part_occurrences :=  QUERY( pd <* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));
WHERE
WR1: SIZEOF( QUERY( pd <* part_occurrences | 
(SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
  prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
END_RULE;
	
RULE selected_instance_usage_requires_representation FOR
    (assembly_component_usage);
LOCAL
  selected_instance_usages: SET OF assembly_component_usage := [];
END_LOCAL;
  selected_instance_usages:=  QUERY( acr <* assembly_component_usage|
		(acr.name = 'selected instance usage'));
WHERE
WR1: SIZEOF ( QUERY ( acr <* selected_instance_usages | 
	NOT valid_selected_instance_representation(acr) ))=0;
END_RULE;
	
RULE restrict_product_definitions_for_definition_usage FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name = 'definition usage' ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
END_RULE;
	
FUNCTION valid_selected_instance_representation (pd: product_definition_or_assembly_relationship): LOGICAL;
LOCAL
  properties: SET OF property_definition :=[];
  property_definition_representations: SET OF property_definition_representation :=[];
  selected_representation: representation;
END_LOCAL;

properties := bag_to_set(QUERY( prd<* USEDIN ( pd ,'CATALOG_DATA_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION' ) | 
 (prd.name = 'occurrence selection' )));
IF (SIZEOF( properties)<>1) THEN
	RETURN(FALSE);
END_IF;

property_definition_representations := bag_to_set(QUERY ( pdr <* USEDIN ( properties[1] , 'CATALOG_DATA_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	( pdr.used_representation.name = 'selection criteria' )));
IF (SIZEOF(property_definition_representations)<>1) THEN
	RETURN(FALSE);
END_IF;

selected_representation := property_definition_representations[1].used_representation;

IF (SIZEOF(selected_representation.items) <1) OR (SIZEOF(selected_representation.items) >2) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
			'CATALOG_DATA_INFORMATION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
 	( i.name = 'selection quantity' ))) <> 1 ) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( 'CATALOG_DATA_INFORMATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	( i.name = 'selection control' )))> 1) THEN
	RETURN(FALSE);
END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( 'CATALOG_DATA_INFORMATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
 	( i.name = 'selection control' ) ))= 0) AND 
   (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
		'CATALOG_DATA_INFORMATION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	RETURN(FALSE);
END_IF;
	
RETURN(TRUE);
END_FUNCTION;
	



(*
   ------------------------------------------------------------
../data/modules/Part_View_Definition/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Pdm_Material_Aspects/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Person_Organization/mim.exp
   ------------------------------------------------------------
*)


ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'CATALOG_DATA_INFORMATION_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Person_Organization_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE organization_item = EXTENSIBLE SELECT; 
END_TYPE;

   
TYPE person_and_organization_item = EXTENSIBLE SELECT; 
END_TYPE;

   
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;

   
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Physical_Breakdown/mim.exp
   ------------------------------------------------------------
*)


ENTITY physical_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;

ENTITY physical_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Plib_Class_Reference/mim.exp
   ------------------------------------------------------------
*)


TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH 
   (externally_defined_class);
END_TYPE; 

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH 
   (class);
END_TYPE; 

ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Process_Property_Assignment/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_As_Individual/mim.exp
   ------------------------------------------------------------
*)


TYPE product_as_individual_identification_item = SELECT BASED_ON identification_item WITH 
   (product_as_individual, 
    product_as_individual_version, 
    product_as_individual_view);
END_TYPE; 

ENTITY product_as_individual
  SUBTYPE OF (product);
END_ENTITY;

ENTITY product_as_individual_version
  ABSTRACT SUPERTYPE OF (ONEOF (product_as_planned,
                                product_as_realized))
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : product_as_individual;
END_ENTITY;

ENTITY product_as_individual_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation RENAMED defined_version : product_as_individual_version;
END_ENTITY;

ENTITY product_as_planned
  SUBTYPE OF (product_as_individual_version);
END_ENTITY;

ENTITY product_as_realized
  SUBTYPE OF (product_as_individual_version);
END_ENTITY;

ENTITY product_design_to_individual
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.related_product RENAMED individual_product : product_as_individual;
  SELF\product_relationship.relating_product RENAMED product_design : product;
END_ENTITY;

ENTITY product_design_version_to_individual
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED individual_product : product_as_individual_version;
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED product_design_version : product_definition_formation;
END_ENTITY;

ENTITY product_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED planned_product : product_as_planned;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED realized_product : product_as_realized;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Product_Breakdown/mim.exp
   ------------------------------------------------------------
*)


TYPE product_definition_or_breakdown_element_usage = EXTENSIBLE GENERIC_ENTITY SELECT
   (breakdown_element_usage, 
    product_definition);
END_TYPE; 

TYPE product_definition_or_product_definition_relationship = EXTENSIBLE GENERIC_ENTITY SELECT
   (product_definition, 
    product_definition_usage);
END_TYPE; 

ENTITY breakdown_context
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY breakdown_element_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items : SET[1:1] OF product_definition_or_breakdown_element_usage;
END_ENTITY;

ENTITY breakdown_element_realization
  SUBTYPE OF (characterized_object, product_definition_element_relationship);
END_ENTITY;

ENTITY breakdown_element_usage
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY breakdown_of
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;

ENTITY product_definition_element_relationship
  SUBTYPE OF (group);
END_ENTITY;

ENTITY product_definition_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items : SET[1:1] OF product_definition_or_product_definition_relationship;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Product_Categorization/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Class/mim.exp
   ------------------------------------------------------------
*)


TYPE category_usage_item = SELECT (product_class);
END_TYPE;

TYPE id_for_class = SELECT BASED_ON identification_item WITH (
	product_class, 
	product_concept_feature);
END_TYPE;

TYPE version_for_class = SELECT BASED_ON versionable_item WITH (
	product_class, 
	product_concept_feature);
END_TYPE;

TYPE specification_for_category = SELECT BASED_ON groupable_item WITH (
	package_product_concept_feature,
	product_concept_feature);
END_TYPE;

ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;

ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
	WHERE
		WR1: NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
		WR2: SIZEOF (QUERY
									( cfr <* USEDIN 
											( SELF ,'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) 
											| 
											'CATALOG_DATA_INFORMATION_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) 
									) 
								) + 
				 SIZEOF(QUERY
				 					( cfr <* USEDIN 
				 							(SELF , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) 
				 							| 
											'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)
									)
								)= 0;
		WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;

ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1: NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
	WR2: SIZEOF ( QUERY 
									( 
										cfr <* USEDIN ( SELF , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) 
										| 
										('CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) 
										AND 
										( SIZEOF ( QUERY 
																( 
																	ipcf <* USEDIN ( cfr , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +	'CONDITION' ) 
																	| 
																	'CATALOG_DATA_INFORMATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) 
																)
															)= 1 
										)
									)
							)>0;
END_ENTITY;
					
ENTITY product_class
  SUBTYPE OF (product_concept,characterized_object);
END_ENTITY;

ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY
									( 
										aga <* USEDIN( SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) 
										|
     								('CATALOG_DATA_INFORMATION_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) 
     								AND
    								(
    									( aga.role.name <> 'specification category member' ) 
    									OR 
    									( SIZEOF(QUERY 
    															( 
    																i <* aga.items 
    																| 
    																('CATALOG_DATA_INFORMATION_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) 
    																AND 
    																NOT ('CATALOG_DATA_INFORMATION_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i))
    															)
    													) <> SIZEOF (aga.items)
    									)
    								) 
       						) 
       				) =0;
END_ENTITY;

ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items : SET [1:?] OF category_usage_item;
WHERE
WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
	WR1: SIZEOF ( QUERY ( cfo <* concept_feature_operator | NOT
		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0;
	WR2: SIZEOF ( QUERY ( cfo <* concept_feature_operator | (cfo.name = 'implication' ) AND
	 ( SIZEOF ( QUERY (cfrwc <* USEDIN ( cfo , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
	'CONDITIONAL_OPERATOR' ) | 
		SIZEOF ( QUERY ( ccf <* USEDIN( cfrwc , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | 
		NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) >0 )) >0 ))) = 0;
	WR3: SIZEOF( QUERY (cfo <* concept_feature_operator | (cfo.name = 'not')
	AND (SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | 
		cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature)) >0 ))) = 0;
END_RULE;	

RULE restrict_group_relationship_for_specification_category FOR (group_relationship); 
WHERE 
WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'specification category hierarchy') AND 
  (NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) 
  OR NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( pcf <* product_concept_feature |
(SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND 
(SIZEOF ( QUERY ( aga <* USEDIN ( pcf , 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | 
( aga.role.name = 'specification category member' ) AND 
('CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) <>1 ) ) ) = 0;
END_RULE;


(*
   ------------------------------------------------------------
../data/modules/Product_Concept_Identification/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Data_Management/mim.exp
   ------------------------------------------------------------
*)


TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (configuration_effectivity, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_request_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    property_definition);
END_TYPE; 

TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action, 
    applied_action_assignment, 
    configuration_effectivity, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_certification_item = EXTENSIBLE SELECT BASED_ON certification_item WITH 
   (product_definition_formation_relationship);
END_TYPE; 

TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_property, 
    action_relationship, 
    action_request_solution, 
    action_request_status, 
    address, 
    alternate_product_relationship, 
    applied_action_assignment, 
    applied_action_request_assignment, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    assembly_component_usage_substitute, 
    calendar_date, 
    certification, 
    class, 
    configuration_item, 
    context_dependent_unit, 
    contract, 
    conversion_based_unit, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    descriptive_representation_item, 
    directed_action, 
    document_file, 
    document_relationship, 
    effectivity, 
    event_occurrence, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    group, 
    identification_assignment, 
    language, 
    measure_representation_item, 
    measure_with_unit, 
    multi_language_attribute_assignment, 
    named_unit, 
    organization, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization_address, 
    product, 
    product_category, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    security_classification, 
    uncertainty_measure_with_unit, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action, 
    applied_action_assignment, 
    executed_action, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action, 
    applied_action_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_method, 
    executed_action, 
    product_definition_formation_relationship, 
    shape_aspect, 
    shape_aspect_relationship, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE pdm_external_class_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (assembly_component_usage, 
    external_class_library);
END_TYPE; 

TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (shape_aspect_relationship);
END_TYPE; 

TYPE pdm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (executed_action, 
    product_concept);
END_TYPE; 

TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (assembly_component_usage);
END_TYPE; 

TYPE pdm_time_interval_item = EXTENSIBLE SELECT BASED_ON time_interval_item WITH 
   (action);
END_TYPE; 



(*
   ------------------------------------------------------------
../data/modules/Product_Identification/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Occurrence/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Placement/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Replacement/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Structure/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Version/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_Version_Relationship/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_View_Definition/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_View_Definition_Properties/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Product_View_Definition_Relationship/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Project/mim.exp
   ------------------------------------------------------------
*)


TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_as_date_item = SELECT BASED_ON date_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Property_Assignment/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Requirement_Identification_And_Version/mim.exp
   ------------------------------------------------------------
*)


TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 



(*
   ------------------------------------------------------------
../data/modules/Security_Classification/mim.exp
   ------------------------------------------------------------
*)


TYPE security_classification_item = EXTENSIBLE SELECT; 
END_TYPE;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Single_Part_Representation/mim.exp
   ------------------------------------------------------------
*)


TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

FUNCTION categories_of_product
 (obj : product) : SET OF STRING; 
LOCAL
category_assignments: BAG OF product_category;
categories: SET OF STRING:=[];
i: INTEGER;
END_LOCAL;
category_assignments := USEDIN(obj, 'CATALOG_DATA_INFORMATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);
      END_FUNCTION; 



(*
   ------------------------------------------------------------
../data/modules/Shape_Property_Assignment/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Specification_Based_Configuration/mim.exp
   ------------------------------------------------------------
*)


TYPE configured_effectivity_context_item = SELECT (product_concept_feature_association);
END_TYPE;

TYPE configured_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT (
  product_definition); 
END_TYPE; 

ENTITY configured_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment);
  SELF\effectivity_context_assignment.assigned_effectivity_assignment: configured_effectivity_assignment;
  items : SET [1:?] OF configured_effectivity_context_item; 
WHERE 
WR1: SIZEOF(SELF.items) = 1; 
END_ENTITY;
 
ENTITY configured_effectivity_assignment 
	SUBTYPE OF (effectivity_assignment);
	  items : SET [1:?] OF configured_effectivity_item; 
	WHERE 
	WR1: (SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
	AND (SELF.assigned_effectivity.id = 'configuration validity'); 
	WR2: SIZEOF(SELF.items) = 1; 
	WR3: SIZEOF( QUERY( i <* SELF.items | NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) 
	OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0; 
	WR4: SELF.role.name IN ['design', 'usage']; 
	WR5: (SELF.role.name <> 'design') 
	OR (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0); 
	WR6: (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0); 
	WR7: SELF.role.description IN ['exception', 'inherited', 'local']; 
	WR8: SIZEOF( QUERY( x <* USEDIN(SELF,'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'CATALOG_DATA_INFORMATION_MIM_LF.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1; 
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Specification_Control/mim.exp
   ------------------------------------------------------------
*)


TYPE class_usage_effectivity_context_item = SELECT
  (product_definition);
END_TYPE;

TYPE effectivity_specification_for_replacement  = SELECT BASED_ON effectivity_item WITH
  (product_definition_substitute);
END_TYPE;

TYPE instance_usage_context_select  = EXTENSIBLE GENERIC_ENTITY SELECT 
  (product_definition_relationship,
   product_definition_usage);
END_TYPE;


ENTITY class_usage_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment); 
items : SET [1:?] OF class_usage_effectivity_context_item; 
WHERE 
WR1: SELF.role.name = 'class usage influence'; 
WR2: SIZEOF( QUERY( i <* SELF.items | NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0; 
WR3: ('CATALOG_DATA_INFORMATION_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
  (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
  (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
 (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
   NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0); 
END_ENTITY; 

ENTITY instance_usage_context_assignment 
SUBTYPE OF (product_definition_context); 
items : SET [1:?] OF instance_usage_context_select; 
END_ENTITY; 


RULE breakdown_element_requires_product_definition FOR 
	(product_definition_formation);
WHERE
WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
     ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name =  'functionality' ) ) =  1 ) AND 
	( SIZEOF ( QUERY ( pd <* USEDIN ( pdf ,'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	pd.frame_of_reference.name =  'functional definition' ) ) <1 ) ) ) =  0;
WR2: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
     ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product , 
	'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
     prpc.name =  'conceptual design' ) ) =  1 ) AND 
     ( SIZEOF (QUERY ( pd <* USEDIN ( pdf , 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION.FORMATION' ) | 
     pd.frame_of_reference.name =  'conceptual definition' ) ) <1) ) ) =  0;
END_RULE;

RULE restrict_product_definitions_for_design_constraint_association FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'design constraint association' ) AND 
	( (pdr. relating_product_definition.frame_of_reference.name<>'design constraint definition' ) OR 
	NOT ( pdr.related_product_definition.frame_of_reference.name IN 
	['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0;
END_RULE;

RULE constraint_definition_requires_constraint_category FOR (product_definition);
LOCAL
  constraint_definitions: SET OF product_definition := [];
END_LOCAL;
  constraint_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'design constraint definition'));
WHERE
WR1: SIZEOF ( QUERY ( pd <* constraint_definitions | 
	( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc. name ='requirement' ) ) =0 ) ) ) =0;
END_RULE;

RULE design_constraint_requires_product_definition 
    FOR (product_definition_formation);
WHERE
WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | (
     SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
     'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name =  'requirement' ) ) >0 ) AND 
     ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf , 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	pd.frame_of_reference.name = 'design constraint definition' ) ) <1 ) ) ) =  0;
END_RULE; 

RULE restrict_configuration_design_for_design_constraint FOR (configuration_design); 
WHERE 
WR1: SIZEOF ( QUERY (cd <* configuration_design | 
	(cd.name = 'design constraint usage') AND 
	(NOT('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	(cd.design\product_definition.frame_of_reference.name <> 'design constraint definition')))) = 0; 
END_RULE;

RULE restrict_configuration_design_for_class_breakdown_association FOR
    (configuration_design);
WHERE
WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name ='functionality' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR 
	( cd.design\product_definition.frame_of_reference.name<> 'functional definition' ) ) 
	) ) =0;
WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name='realization' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	( cd.design\product_definition.frame_of_reference.name<> 'conceptual definition' ) ) 
	) ) =0;
WR3: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name IN ['functionality' , 'realization'] ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) 
	) ) =0;
END_RULE;


(*
   ------------------------------------------------------------
../data/modules/Specified_Product/mim.exp
   ------------------------------------------------------------
*)


TYPE id_for_product_identification = SELECT BASED_ON identification_item WITH (product_identification);
END_TYPE;

TYPE version_for_product_identification = SELECT BASED_ON versionable_item WITH (product_identification);
END_TYPE;

ENTITY product_identification
  SUBTYPE OF (configuration_item, characterized_object);
	SELF\configuration_item.item_concept : product_class;
WHERE
	WR1 : SIZEOF(QUERY 
								( cd <* USEDIN ( SELF ,'CATALOG_DATA_INFORMATION_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION' ) 
								|
     						( 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) 
     						AND 
    						( SIZEOF ( QUERY 
    												( 
    													prpc <* USEDIN ( cd. design\product_definition_formation.of_product , 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') 
    													| 
         											prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
     													) 
     												) 
     											) <=1;
	WR2 : NOT ( 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) 
				XOR ( 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) ) ;
END_ENTITY;

ENTITY product_specification
  SUBTYPE OF (product_identification, configurable_item);
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Time_Interval/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Time_Interval_Assignment/mim.exp
   ------------------------------------------------------------
*)


TYPE time_interval_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET[0:?] OF time_interval_item;
END_ENTITY;


(*
   ------------------------------------------------------------
../data/modules/Value_With_Unit/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Work_Order/mim.exp
   ------------------------------------------------------------
*)


(*
   ------------------------------------------------------------
../data/modules/Work_Request/mim.exp
   ------------------------------------------------------------
*)


TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\action_schema\action_schema.exp
   ------------------------------------------------------------
*)


TYPE supported_item = SELECT
   (action, 
    action_directive, 
    action_method);
END_TYPE; 

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET[1:?] OF versioned_action_request;
END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_method_relationship;
  name : label;
  description : OPTIONAL text;
  relating_method : action_method;
  related_method : action_method;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_resource;
  name : label;
  description : OPTIONAL text;
  usage : SET[1:?] OF supported_item;
  kind : action_resource_type;
END_ENTITY;

ENTITY action_resource_relationship;
  name : label;
  description : OPTIONAL text;
  relating_resource : action_resource;
  related_resource : action_resource;
END_ENTITY;

ENTITY action_resource_type;
  name : label;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY versioned_action_request_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_versioned_action_request : versioned_action_request;
  related_versioned_action_request : versioned_action_request;
END_ENTITY;

FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\aic_topologically_bounded_surface\aic_topologically_bounded_surface.exp
   ------------------------------------------------------------
*)


ENTITY advanced_face 
 SUBTYPE OF ( face_surface );
 WHERE 
WR1 : 
SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
WR2 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
WR6 : NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
WR7 : 
SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
WR10 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
 END_ENTITY ;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\application_context_schema\application_context_schema.exp
   ------------------------------------------------------------
*)


ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (library_context,
                       product_concept_context,
                       product_context,
                       product_definition_context));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;

ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\approval_schema\approval_schema.exp
   ------------------------------------------------------------
*)


ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;

ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

FUNCTION acyclic_approval_relationship
 (relation : approval_relationship; relatives : SET[1:?] OF approval; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\basic_attribute_schema\basic_attribute_schema.exp
   ------------------------------------------------------------
*)


TYPE description_attribute_select = SELECT
   (action_request_solution, 
    application_context, 
    approval_role, 
    configuration_design, 
    context_dependent_shape_representation, 
    date_role, 
    date_time_role, 
    effectivity, 
    external_source, 
    organization_role, 
    person_and_organization, 
    person_and_organization_role, 
    person_role, 
    property_definition_representation, 
    representation, 
    time_role);
END_TYPE; 

TYPE id_attribute_select = SELECT
   (action, 
    address, 
    application_context, 
    group, 
    organizational_project, 
    product_category, 
    property_definition, 
    representation, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

TYPE name_attribute_select = SELECT
   (action_request_solution, 
    address, 
    configuration_design, 
    context_dependent_shape_representation, 
    derived_unit, 
    effectivity, 
    person_and_organization, 
    product_definition, 
    product_definition_substitute, 
    property_definition_representation);
END_TYPE; 

TYPE role_select = SELECT
   (action_assignment, 
    action_request_assignment, 
    approval_assignment, 
    approval_date_time, 
    certification_assignment, 
    contract_assignment, 
    document_reference, 
    effectivity_assignment, 
    external_referent_assignment, 
    group_assignment, 
    name_assignment, 
    security_classification_assignment);
END_TYPE; 

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;
END_FUNCTION; 

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 








(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\certification_schema\certification_schema.exp
   ------------------------------------------------------------
*)


ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\classification_schema\classification_schema.exp
   ------------------------------------------------------------
*)


TYPE classification_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE complete_membership_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET[1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF (classification,
         complete_membership);
END_SUBTYPE_CONSTRAINT;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\configuration_management_schema\configuration_management_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n529.exp *)


TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\contract_schema\contract_schema.exp
   ------------------------------------------------------------
*)


ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;

ENTITY contract_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_contract : contract;
  related_contract : contract;
END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

FUNCTION acyclic_contract_relationship
 (relation : contract_relationship; relatives : SET[1:?] OF contract; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\date_time_schema\date_time_schema.exp
   ------------------------------------------------------------
*)


TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE; 

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE; 

TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE; 

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; 

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; 

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; 

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; 

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; 

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; 

TYPE year_number = INTEGER;
END_TYPE; 

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION; 

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION; 

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; 




(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\document_schema\document_schema.exp
   ------------------------------------------------------------
*)


TYPE product_or_formation_or_definition = SELECT
   (product, 
    product_definition_formation, 
    product_definition);
END_TYPE; 

ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;

ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY;

FUNCTION acyclic_document_relationship
 (relation : document_relationship; relatives : SET[1:?] OF document; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\effectivity_schema\effectivity_schema.exp
   ------------------------------------------------------------
*)


ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity,
                       dated_effectivity,
                       lot_effectivity,
                       time_interval_based_effectivity));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

FUNCTION acyclic_effectivity_relationship
 (relation : effectivity_relationship; relatives : SET[1:?] OF effectivity; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 





(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\experience_schema\experience_schema.exp
   ------------------------------------------------------------
*)


ENTITY experience;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience : experience;
  related_experience : experience;
END_ENTITY;

ENTITY experience_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience_type : experience_type;
  related_experience_type : experience_type;
END_ENTITY;

FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\external_reference_schema\external_reference_schema.exp
   ------------------------------------------------------------
*)


TYPE message = STRING;
END_TYPE; 

TYPE source_item = SELECT
   (identifier, 
    message);
END_TYPE; 

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY external_source_relationship;
  name : label;
  description : OPTIONAL text;
  relating_source : external_source;
  related_source : external_source;
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;

ENTITY externally_defined_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item : externally_defined_item;
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

FUNCTION acyclic_external_source_relationship
 (relation : external_source_relationship; relatives : SET[1:?] OF external_source; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_externally_defined_item_relationship
 (relation : externally_defined_item_relationship; relatives : SET[1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\geometric_model_schema\geometric_model_schema.exp
   ------------------------------------------------------------
*)


(* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)


TYPE boolean_operand = SELECT
   (solid_model, 
    half_space_solid,
    csg_primitive,
    boolean_result,
    half_space_2d);
 END_TYPE;

 TYPE boolean_operator = ENUMERATION OF 
   (union, 
    intersection, 
    difference);
 END_TYPE;

 TYPE csg_select = SELECT
   (boolean_result,
    csg_primitive);
 END_TYPE;

 TYPE csg_primitive = SELECT
   (sphere,
    ellipsoid,
    block,
    right_angular_wedge,
    faceted_primitive,
    rectangular_pyramid,
    torus,
    right_circular_cone,
    eccentric_cone,
    right_circular_cylinder,
    cyclide_segment_solid,
    primitive_2d);
 END_TYPE;

 TYPE geometric_set_select = SELECT
   (point,
    curve,
    surface);
 END_TYPE;

 TYPE surface_model = SELECT
   (shell_based_surface_model, 
    face_based_surface_model);
 END_TYPE;

 TYPE wireframe_model = SELECT
   (shell_based_wireframe_model,
    edge_based_wireframe_model);
 END_TYPE;

 ENTITY block
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
   operator        : boolean_operator;
   first_operand   :  boolean_operand;
   second_operand  :  boolean_operand;
 END_ENTITY;

 ENTITY box_domain
   SUBTYPE OF (founded_item);
   corner  : cartesian_point;
   xlength : positive_length_measure;
   ylength : positive_length_measure;
   zlength : positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT ('CATALOG_DATA_INFORMATION_MIM_LF.BOXED_HALF_SPACE'
                    IN TYPEOF(item)))) = 0;
 END_ENTITY;

 ENTITY boxed_half_space
   SUBTYPE OF(half_space_solid);
   enclosure : box_domain;
 END_ENTITY;

 ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
  WHERE
    WR1:  SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.FACE_SURFACE',
          'CATALOG_DATA_INFORMATION_MIM_LF.SUBFACE', 'CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_FACE'] *
              TYPEOF (SELF.extent)) = 0;
   WR2 : SIZEOF (QUERY (bnds <* extent.bounds |
         NOT ('CATALOG_DATA_INFORMATION_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
   WR3 : SIZEOF (QUERY (bnds <* extent.bounds |
         'CATALOG_DATA_INFORMATION_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
   WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds |
         'CATALOG_DATA_INFORMATION_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT
          (('CATALOG_DATA_INFORMATION_MIM_LF.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND
         (oe.edge_element\geometric_representation_item.dim = 2)))) =
                0))) = 0;
 END_ENTITY;

 ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
   voids : SET [1:?] OF oriented_closed_shell;
 END_ENTITY;

ENTITY  circular_area
  SUBTYPE OF (primitive_2d);
    centre: cartesian_point;
    radius: positive_length_measure;
END_ENTITY;

 ENTITY convex_hexahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 8 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR8: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR9: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR10: same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR11: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR12: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR13: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
  END_ENTITY;

 ENTITY csg_solid
   SUBTYPE OF (solid_model);
   tree_root_expression : csg_select;
 END_ENTITY;

ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   radius1     : positive_length_measure;
   radius2     : positive_length_measure;
   cone_angle1 : plane_angle_measure;
   cone_angle2 : plane_angle_measure;
   turn_angle  : plane_angle_measure;
END_ENTITY;

 ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   ebwm_boundary  : SET [1:?] OF connected_edge_set;
 END_ENTITY;

 ENTITY face_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   fbsm_faces : SET [1:?] OF connected_face_set;
 END_ENTITY;

 ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
 WHERE
   WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'CATALOG_DATA_INFORMATION_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0;
 END_ENTITY;

 ENTITY geometric_set
   SUPERTYPE OF (ONEOF(geometric_curve_set,
                       geometric_set_replica))
   SUBTYPE OF (geometric_representation_item);
   elements :  SET [1:?] OF geometric_set_select;
 END_ENTITY;

 ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

ENTITY  elliptic_area
  SUBTYPE OF (primitive_2d);
    position : axis2_placement_2d;
    semi_axis_1 : positive_length_measure;
    semi_axis_2 : positive_length_measure;
END_ENTITY;

 ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_area_solid.swept_area.basis_surface\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
 END_ENTITY;

 ENTITY faceted_primitive
   SUPERTYPE OF (ONEOF(tetrahedron, convex_hexahedron))
   SUBTYPE OF (geometric_representation_item) ;
     points : LIST[4:?] OF UNIQUE cartesian_point ;
  WHERE
    WR1: points[1].dim = 3 ;
  END_ENTITY;

  ENTITY geometric_set_replica
   SUBTYPE OF (geometric_set); 
     parent_set     : geometric_set; 
     transformation : cartesian_transformation_operator; 
   DERIVE 
     SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
           build_transformed_set(transformation, parent_set); 
   WHERE
     WR1: acyclic_set_replica(SELF, parent_set);
   END_ENTITY;

ENTITY  half_space_2d
  SUBTYPE OF (geometric_representation_item);
    base_curve:  curve;
    agreement_flag: BOOLEAN;
END_ENTITY;

 ENTITY half_space_solid
   SUBTYPE OF(geometric_representation_item);
   base_surface   : surface;
   agreement_flag : BOOLEAN;
 END_ENTITY;

 ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
   outer : closed_shell;
 END_ENTITY;

 ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
   bounds:  LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY primitive_2d
   SUPERTYPE  OF (ONEOF (circular_area, elliptic_area, rectangular_area,
                            polygonal_area))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY rectangle_domain
   SUBTYPE OF (founded_item);
   corner: cartesian_point;
   xlength: positive_length_measure;
   ylength: positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT
   ('CATALOG_DATA_INFORMATION_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
 END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
    enclosure: rectangle_domain;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
    position: axis2_placement_2d;
    x: positive_length_measure;
    y: positive_length_measure;
END_ENTITY;

 ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength        : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;

ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;

 ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

 ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

 ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : positive_length_measure;
 END_ENTITY;

 ENTITY sectioned_spine
   SUBTYPE OF (geometric_curve_set);
      cross_sections   : LIST[2:?] OF curve;
      spine_points     : LIST[2:?] OF point;
   WHERE
     WR1 : SIZEOF(SELF\geometric_set.elements) = 1;
     WR2 : 'CATALOG_DATA_INFORMATION_MIM_LF.CURVE' IN
                     TYPEOF(SELF\geometric_set.elements[1]);
     WR3 : SIZEOF(cross_sections) = SIZEOF(spine_points);
     WR4 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   sbsm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_surface_model(SELF);
 END_ENTITY;

 ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   sbwm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_wireframe_model(SELF);
 END_ENTITY;

 ENTITY solid_model
   SUPERTYPE OF (ONEOF( csg_solid, manifold_solid_brep, swept_face_solid,
                        swept_area_solid, swept_disk_solid, solid_replica,
                        brep_2d, trimmed_volume))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY solid_replica
   SUBTYPE OF (solid_model);
   parent_solid   : solid_model;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_solid_replica(SELF, parent_solid);
   WR2: parent_solid\geometric_representation_item.dim = 3;
 END_ENTITY;


 ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
   radius : positive_length_measure;
   centre : point;
 END_ENTITY;

 ENTITY surface_curve_swept_area_solid
   SUBTYPE OF (swept_area_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_curve_swept_face_solid
   SUBTYPE OF (swept_face_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF(revolved_area_solid, extruded_area_solid,
                       surface_curve_swept_area_solid))
   SUBTYPE OF (solid_model);
   swept_area :  curve_bounded_surface;
 WHERE
   WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PLANE' IN TYPEOF(swept_area.basis_surface);
 END_ENTITY;

 ENTITY swept_disk_solid
   SUBTYPE OF (solid_model);
     directrix    : curve;
     radius       : positive_length_measure;
     inner_radius : OPTIONAL positive_length_measure;
     start_param : REAL;
     end_param   : REAL;
   WHERE
     WR1 : directrix.dim = 3;
     WR2 : (NOT EXISTS(inner_radius)) OR (radius > inner_radius) ;
 END_ENTITY;

 ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF(extruded_face_solid, revolved_face_solid,
                 surface_curve_swept_face_solid))
   SUBTYPE OF (solid_model);
   swept_face :  face_surface;
 WHERE
   WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PLANE' IN TYPEOF(swept_face.face_geometry);
 END_ENTITY;

 ENTITY tetrahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 4 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
  END_ENTITY;

 ENTITY torus
   SUBTYPE OF (geometric_representation_item);
   position     : axis1_placement;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1: major_radius > minor_radius;
 END_ENTITY;

 ENTITY trimmed_volume
   SUBTYPE OF (solid_model);
   basis_volume :  volume;
     u1         :  parameter_value;
     u2         :  parameter_value;
     v1         :  parameter_value;
     v2         :  parameter_value;
     w1         :  parameter_value;
     w2         :  parameter_value;
   WHERE
     WR1 : u1 <> u2;
     WR2 : v1 <> v2;
     WR3 : w1 <> w2;
 END_ENTITY;

 
 FUNCTION acyclic_set_replica(rep : geometric_set_replica;
                           parent : geometric_set) : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;


(* Return TRUE if the parent is not of type geometric_set_replica *)


IF (parent :=: rep) THEN
      RETURN (FALSE);


(* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)


ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_solid_replica(rep : solid_replica; parent :
                    solid_model) : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;


(* Return TRUE if the parent is not of type solid_replica. *)


IF (parent :=: rep) THEN
      RETURN (FALSE);


(* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)


ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
  END_FUNCTION;

 FUNCTION build_transformed_set(tr: cartesian_transformation_operator;
           gset : geometric_set) : SET [0:?] OF geometric_set_select;
  LOCAL
   s          : SET [1:?] OF geometric_set_select := gset.elements;
   trset      : SET [0:?] OF geometric_set_select := [];
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('CATALOG_DATA_INFORMATION_MIM_LF.CURVE' IN TYPEOF(s[j])) THEN
     trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
     IF ('CATALOG_DATA_INFORMATION_MIM_LF.POINT' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || point() || point_replica(s[j],tr);
       ELSE
       IF ('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || surface()  || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d (?));
       END_IF;
     END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);
 END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_surface_model
             (m: shell_based_surface_model): BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);


(* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)


END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_wireframe_model
                       (m : shell_based_wireframe_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);


(* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)


END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION msb_shells (brep: manifold_solid_brep) :
                          SET [1:?] OF  closed_shell;
 
     IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
       msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
 END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\geometry_schema\geometry_schema.exp
   ------------------------------------------------------------
*)


(* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)

(*
CONSTANT
  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();
 END_CONSTANT;
 *)

 TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
 END_TYPE;

 TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
 END_TYPE;

 TYPE b_spline_surface_form = ENUMERATION OF
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
 END_TYPE;

 TYPE curve_on_surface = SELECT
   (pcurve, 
    surface_curve, 
    composite_curve_on_surface);
 END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

 TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
 END_TYPE;

 TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
 END_TYPE;

 TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
 END_TYPE;

 TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1, 
    pcurve_s2);
 END_TYPE;

TYPE surface_boundary = SELECT
   (boundary_curve,
    degenerate_pcurve);
END_TYPE;

 TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
 END_TYPE;

 TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
 END_TYPE;

 TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;

 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

 ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
 END_ENTITY;

 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;

 ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots,
                       quasi_uniform_curve, bezier_curve)
                         ANDOR rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                         OF cartesian_point 
                                  := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
 END_ENTITY;

 ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

 ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface,
                       quasi_uniform_surface, bezier_surface)
                         ANDOR rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF cartesian_point;
   surface_form         : b_spline_surface_form;
   u_closed             : LOGICAL;
   v_closed             : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point 
                       := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
 END_ENTITY;

 ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   knot_spec         : knot_type;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
    WR3: SIZEOF(u_multiplicities) = knot_u_upper;
    WR4: SIZEOF(v_multiplicities) = knot_v_upper;
 END_ENTITY;

 ENTITY b_spline_volume
   SUPERTYPE OF (ONEOF(b_spline_volume_with_knots, uniform_volume,
                      quasi_uniform_volume,bezier_volume) ANDOR
                       rational_b_spline_volume)
   SUBTYPE OF (volume);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   w_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF
                              LIST [2:?] OF cartesian_point;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   w_upper             : INTEGER := SIZEOF(control_points_list[1][1]) - 1;

   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper]
                         OF ARRAY [0:w_upper] OF  cartesian_point
                       := make_array_of_array_of_array (control_points_list,
                                              0,u_upper,0,v_upper,
                                              0,w_upper );
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.BEZIER_VOLUME' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF)) ;
 END_ENTITY;

 ENTITY b_spline_volume_with_knots
   SUBTYPE OF (b_spline_volume);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   w_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   w_knots           : LIST [2:?] OF parameter_value;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
   knot_w_upper      : INTEGER := SIZEOF(w_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree,
                   knot_u_upper, SELF\b_spline_volume.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree,
                   knot_v_upper, SELF\b_spline_volume.v_upper,
                               v_multiplicities, v_knots);
    WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree,
                   knot_w_upper, SELF\b_spline_volume.w_upper,
                               w_multiplicities, w_knots);
    WR4: SIZEOF(u_multiplicities) = knot_u_upper;
    WR5: SIZEOF(v_multiplicities) = knot_v_upper;
    WR6: SIZEOF(w_multiplicities) = knot_w_upper;
 END_ENTITY;

 ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY bezier_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY block_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
 WHERE
   WR1: SELF\composite_curve.closed_curve;
 END_ENTITY;

 ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline, b_spline_curve, trimmed_curve,
                      bounded_pcurve, bounded_surface_curve, composite_curve))
   SUBTYPE OF (curve);
 END_ENTITY;

 ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
  WHERE
    WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY;

 ENTITY bounded_surface
   SUPERTYPE OF (ONEOF(b_spline_surface, rectangular_trimmed_surface,
                       curve_bounded_surface, rectangular_composite_surface))
   SUBTYPE OF (surface);
 END_ENTITY;

 ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
 END_ENTITY;

 ENTITY cartesian_point
   SUPERTYPE OF (ONEOF(cylindrical_point, polar_point, spherical_point))
   SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

 ENTITY cartesian_transformation_operator
   SUPERTYPE OF(ONEOF(cartesian_transformation_operator_2d,
                               cartesian_transformation_operator_3d))
   SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
 DERIVE
   u : LIST[2:2] OF direction := 
       base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY circular_involute
   SUBTYPE OF (curve);
   position    : axis2_placement;
   base_radius : positive_length_measure;
 END_ENTITY;

 ENTITY clothoid
   SUBTYPE OF (curve);
     position          : axis2_placement;
     clothoid_constant : length_measure;
  END_ENTITY;

 ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
 END_ENTITY;

 ENTITY composite_curve_on_surface
   SUPERTYPE OF(boundary_curve)
   SUBTYPE OF (composite_curve);

 DERIVE
   basis_surface : SET[0:2] OF surface :=
                get_basis_surface(SELF);
 WHERE
   WR1: SIZEOF(basis_surface) > 0;
   WR2: constraints_composite_curve_on_surface(SELF);
 END_ENTITY;

 ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('CATALOG_DATA_INFORMATION_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
 END_ENTITY;

 ENTITY conic
   SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
   SUBTYPE OF (curve);
   position: axis2_placement;
 END_ENTITY;

 ENTITY
 conical_surface
   SUBTYPE OF (elementary_surface);
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

ENTITY curve
   SUPERTYPE OF (ONEOF(line, conic, clothoid, circular_involute, pcurve,
             surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
   SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
 ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
    basis_surface    : surface;
    boundaries       : SET [1:?] OF boundary_curve;
    implicit_outer   : BOOLEAN;
  WHERE
    WR1: (NOT implicit_outer) OR
         (SIZEOF (QUERY (temp <* boundaries |
           'CATALOG_DATA_INFORMATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
    WR2: (NOT(implicit_outer)) OR
                ('CATALOG_DATA_INFORMATION_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
    WR3: SIZEOF(QUERY(temp <* boundaries |
                  'CATALOG_DATA_INFORMATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp))) <= 1;
    WR4: SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface))) = 0;
 END_ENTITY;

 ENTITY curve_replica
   SUBTYPE OF (curve);
   parent_curve   : curve;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_curve.dim;
   WR2: acyclic_curve_replica (SELF, parent_curve);
 END_ENTITY;

 ENTITY cylindrical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     z     : length_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                     [r*cos(theta), r*sin(theta), z];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
   radius : positive_length_measure;
 END_ENTITY;

 ENTITY  cylindrical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
   height   : positive_length_measure;
 END_ENTITY;

 ENTITY degenerate_pcurve
   SUBTYPE OF (point);
   basis_surface:  surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
   select_outer : BOOLEAN;
 WHERE
  WR1: major_radius <   minor_radius;
 END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY dupin_cyclide_surface
   SUBTYPE OF (elementary_surface);
   generalised_major_radius : positive_length_measure;
   generalised_minor_radius : positive_length_measure;
   skewness                 : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

 ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface,
                       spherical_surface, toroidal_surface))
   SUBTYPE OF (surface);
   position : axis2_placement_3d;
 END_ENTITY;

 ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;

 ENTITY ellipsoid_volume
   SUBTYPE OF (volume);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

 ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
   equivalent_point : cartesian_point;
 END_ENTITY;

 ENTITY fixed_reference_swept_surface
   SUBTYPE OF (swept_surface);
      directrix       : curve;
      fixed_reference : direction;
 END_ENTITY;

  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF(point, direction, vector, placement,
                 cartesian_transformation_operator, curve, surface,
                 edge_curve, face_surface, poly_loop, vertex_point,
                 solid_model, boolean_result, sphere, right_circular_cone,
                 right_circular_cylinder, torus, block, primitive_2d,
                 right_angular_wedge, ellipsoid, faceted_primitive,
                 rectangular_pyramid, cyclide_segment_solid, volume,
                 half_space_solid, half_space_2d,
                 shell_based_surface_model, face_based_surface_model,
                 shell_based_wireframe_model, edge_based_wireframe_model,
                 geometric_set))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

 ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;

 ENTITY hexahedron_volume
   SUBTYPE OF (volume);
   points  : LIST[8:8] OF cartesian_point;
  WHERE
    WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR7: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR8: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR9:  same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR10: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR11: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR12: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
    WR13: points[1].dim = 3;
  END_ENTITY;

 ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;

 ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY offset_curve_2d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
 WHERE
   WR1: basis_curve.dim = 2;
 END_ENTITY;

 ENTITY offset_curve_3d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
   ref_direction  : direction;
 WHERE
   WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
 END_ENTITY;

 ENTITY offset_surface
   SUBTYPE OF (surface);
   basis_surface  : surface;
   distance       : length_measure;
   self_intersect : LOGICAL;
 END_ENTITY;

 ENTITY oriented_surface
   SUBTYPE OF (surface);
   orientation : BOOLEAN;
 END_ENTITY;

 ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
 END_ENTITY;

 ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;

 ENTITY pcurve
   SUBTYPE OF (curve);
   basis_surface      : surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;

 ENTITY plane
 SUBTYPE OF (elementary_surface);
 END_ENTITY;

 ENTITY polar_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                   [r*cos(theta), r*sin(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface,
                        point_in_volume, point_replica, degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY point_in_volume
   SUBTYPE OF (point);
   basis_volume     : volume;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
   point_parameter_w : parameter_value;
 END_ENTITY;

 ENTITY point_on_curve
   SUBTYPE OF (point);
   basis_curve     : curve;
   point_parameter : parameter_value;
 END_ENTITY;

 ENTITY point_on_surface
   SUBTYPE OF (point);
   basis_surface     : surface;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
 END_ENTITY;

 ENTITY point_replica
   SUBTYPE OF (point);
   parent_pt      : point;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_pt.dim;
   WR2: acyclic_point_replica (SELF,parent_pt);
 END_ENTITY;

 ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;

 ENTITY pyramid_volume
   SUBTYPE OF (volume);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength          : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY quasi_uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
                                
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                               := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
   weights_data : LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                      ARRAY [0:v_upper] OF REAL
                 := make_array_of_array(weights_data,0,u_upper,0,v_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
   WR2: surface_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_volume
   SUBTYPE OF (b_spline_volume);
   weights_data : LIST [2:?] OF
                   LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                    ARRAY [0:v_upper] OF
                     ARRAY [0:w_upper] OF REAL
                 := make_array_of_array_of_array
                             (weights_data,0,u_upper,0,v_upper,0,w_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                         SIZEOF(SELF\b_spline_volume.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))
            AND (SIZEOF(weights_data[1][1]) =
                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
   WR2: volume_weights_positive(SELF);
 END_ENTITY;

 ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
   segments      : LIST [1:?] OF LIST [1:?] OF surface_patch;
 DERIVE
   n_u : INTEGER := SIZEOF(segments);
   n_v : INTEGER := SIZEOF(segments[1]);
 WHERE
   WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
   WR2: constraints_rectangular_composite_surface(SELF);
 END_ENTITY;

 ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
   basis_surface : surface;
   u1            : parameter_value;
   u2            : parameter_value;
   v1            : parameter_value;
   v2            : parameter_value;
   usense        : BOOLEAN;
   vsense        : BOOLEAN;
 WHERE
   WR1: u1 <> u2;
   WR2: v1 <> v2;
   WR3: (('CATALOG_DATA_INFORMATION_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
       AND  (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR
      ('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR (usense = (u2 > u1));
   WR4: (('CATALOG_DATA_INFORMATION_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
          OR
         ('CATALOG_DATA_INFORMATION_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR (vsense = (v2 > v1));
 END_ENTITY;

 ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
   param_length : parameter_value;
 WHERE
   WR1: param_length > 0.0;
 END_ENTITY;

 ENTITY seam_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
           associated_surface(SELF\surface_curve.associated_geometry[2]);
   WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
   WR4: 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY spherical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     phi   : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
       [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY spherical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface,
                       offset_surface, surface_replica))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR
                                            bounded_surface_curve)
   SUBTYPE OF (curve);
   curve_3d              : curve;
   associated_geometry   : LIST[1:2] OF pcurve_or_surface;
   master_representation : preferred_surface_curve_representation;
 DERIVE
   basis_surface         : SET[1:2] OF surface
                         := get_basis_surface(SELF);
 WHERE
   WR1: curve_3d.dim = 3;
   WR2: ('CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
   WR3: ('CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
   WR4: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
 END_ENTITY;

 ENTITY surface_curve_swept_surface
   SUBTYPE OF (swept_surface);
      directrix  : curve;
      reference_surface : surface;
   WHERE
     WR1 : (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
   extrusion_axis      : vector;
 END_ENTITY;

 ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
   axis_position       : axis1_placement;
 DERIVE
   axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
 END_ENTITY;

 ENTITY surface_patch
 SUBTYPE OF (founded_item);
   parent_surface : bounded_surface;
   u_transition   : transition_code;
   v_transition   : transition_code;
   u_sense        : BOOLEAN;
   v_sense        : BOOLEAN;
 INVERSE
   using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
 WHERE
   WR1: (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
 END_ENTITY;

 ENTITY surface_replica
   SUBTYPE OF (surface);
   parent_surface : surface;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_surface_replica(SELF, parent_surface);
 END_ENTITY;

 ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution,
                 surface_curve_swept_surface, fixed_reference_swept_surface))
   SUBTYPE OF (surface);
   swept_curve : curve;
 END_ENTITY;

 ENTITY tetrahedron_volume
   SUBTYPE OF (volume);
     point_1 : cartesian_point ;
     point_2 : cartesian_point ;
     point_3 : cartesian_point ;
     point_4 : cartesian_point ;
  WHERE
    WR1: point_1.dim = 3 ;
    WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0 ;
  END_ENTITY;

 ENTITY toroidal_volume
   SUBTYPE OF (volume);
   position     : axis2_placement_3d;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1 : minor_radius < major_radius;
 END_ENTITY;

 ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
   basis_curve           : curve;
   trim_1                : SET[1:2] OF trimming_select;
   trim_2                : SET[1:2] OF trimming_select;
   sense_agreement       : BOOLEAN;
   master_representation : trimming_preference;
 WHERE
   WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
   WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
 END_ENTITY;

 ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 END_ENTITY;

 ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;

 ENTITY volume
   SUPERTYPE OF (ONEOF(block_volume, wedge_volume, spherical_volume,
                    cylindrical_volume, eccentric_conical_volume,
                    toroidal_volume, pyramid_volume, b_spline_volume,
                    ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

  ENTITY wedge_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

 FUNCTION above_plane(p1, p2, p3, p4 : cartesian_point) : REAL;
   LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
 END_FUNCTION;

 FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;


(* Return TRUE if the parent is not of type curve_replica *)


IF (parent :=: rep) THEN
      RETURN (FALSE);


(* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)


ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_point_replica(rep : point_replica; parent : point)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;


(* Return TRUE if the parent is not of type point_replica *)


IF (parent :=: rep) THEN
      RETURN (FALSE);


(* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)


ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_surface_replica(rep : surface_replica; parent : surface)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;


(* Return TRUE if the parent is not of type surface_replica *)


IF (parent :=: rep) THEN
      RETURN (FALSE);


(* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)


ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
  END_FUNCTION;

 FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
 END_FUNCTION;

FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                 LIST [2:3] OF 
direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
 END_FUNCTION;

 FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
 END_FUNCTION;

 FUNCTION constraints_composite_curve_on_surface
               (c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                               knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;


(* Find sum of knot multiplicities. *)


sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;


(* Check limits holding for all B-spline parametrisations *)


IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

   FUNCTION constraints_rectangular_composite_surface
           (s : rectangular_composite_surface) : BOOLEAN;


(* Check the surface types *)


REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('CATALOG_DATA_INFORMATION_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('CATALOG_DATA_INFORMATION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;


(* Check the transition codes, omitting the last row or column *)


REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

 FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION default_b_spline_curve_weights(up_cp : INTEGER)
                                          : ARRAY [0:up_cp] OF REAL;
   RETURN([1:up_cp + 1]);
 END_FUNCTION;

 FUNCTION default_b_spline_surface_weights(u_upper, v_upper: INTEGER)
                                      : ARRAY [0:u_upper] OF 
                                        ARRAY [0:v_upper] OF REAL;
    RETURN([[1:v_upper + 1]:u_upper +1]);
 END_FUNCTION;

 FUNCTION default_b_spline_knot_mult(degree, up_knots : INTEGER;
                                          uniform : knot_type) 
                                                  : LIST [2:?] OF INTEGER;
   LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);
 END_FUNCTION;

 FUNCTION default_b_spline_knots(degree,up_knots : INTEGER;
                              uniform : knot_type)
                                      : LIST [2:?] OF parameter_value;
  LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
 END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'CATALOG_DATA_INFORMATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'CATALOG_DATA_INFORMATION_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);

END_FUNCTION;

 FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;


(* When function is called with invalid data an indeterminate result
     is returned *)


ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;


(* When function is called with invalid data an indeterminate result
     is returned *)


ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
 END_FUNCTION;

FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION get_basis_surface (c : curve_on_surface) : SET[0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)


n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION;

 FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                      low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
 END_FUNCTION;

 FUNCTION make_array_of_array(lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                              low1, u1, low2, u2 : INTEGER):
                 ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;


(* Check input dimensions for consistency *)


IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;


(* Initialise res with values from lis[1] *)


res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
 END_FUNCTION;

 FUNCTION make_array_of_array_of_array(lis : LIST[1:?] OF
              LIST [1:?] OF LIST [1:?] OF GENERIC : T;
              low1, u1, low2, u2, low3, u3 : INTEGER):
      ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T;
 LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)


IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;


(* Initialise res with values from lis[1] *)


res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);
 END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;


(* When function is called with invalid data a NULL result is returned *)


ELSE
     ndim := arg.dim;
     IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
 END_FUNCTION;

 FUNCTION same_side(plane_pts : LIST [3:3] of cartesian_point;
                    test_points : LIST [2:?] of cartesian_point) : BOOLEAN;
   LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                      : vector;
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag < 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
 END_FUNCTION;

 FUNCTION surface_weights_positive(b: rational_b_spline_surface) : BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION vector_sum(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'CATALOG_DATA_INFORMATION_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION volume_weights_positive(b: rational_b_spline_volume): BOOLEAN;
     LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);
   END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\group_schema\group_schema.exp
   ------------------------------------------------------------
*)


ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY group_relationship;
  name : label;
  description : OPTIONAL text;
  relating_group : group;
  related_group : group;
END_ENTITY;

FUNCTION acyclic_group_relationship
 (relation : group_relationship; relatives : SET[1:?] OF group; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\location_schema\location_schema.exp
   ------------------------------------------------------------
*)


ENTITY location;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_location : location;
  related_location : location;
END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\management_resources_schema\management_resources_schema.exp
   ------------------------------------------------------------
*)


TYPE attribute_type = SELECT
   (label, 
    text);
END_TYPE; 

ENTITY action_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_method : action_method;
  role : action_method_role;
END_ENTITY;

ENTITY action_method_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE ;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY certification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  role : classification_role;
END_ENTITY;

ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE ;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date : date;
  role : date_role;
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE ;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE ;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity_assignment : effectivity_assignment;
  role : effectivity_context_role;
END_ENTITY;

ENTITY effectivity_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role : event_occurrence_context_role;
END_ENTITY;

ENTITY experience_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience : experience;
  role : experience_role;
END_ENTITY;

ENTITY experience_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience_type : experience_type;
  role : experience_type_role;
END_ENTITY;

ENTITY experience_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

ENTITY group_assignment
  ABSTRACT SUPERTYPE ;
  assigned_group : group;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_assignment_relationship;
  name : label;
  description : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment : identification_assignment;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY library_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY;

ENTITY location_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_location : location;
  role : location_role;
END_ENTITY;

ENTITY location_representation_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  represented_location : location;
  role : location_representation_role;
END_ENTITY;

ENTITY location_representation_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY name_assignment
  ABSTRACT SUPERTYPE ;
  assigned_name : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_organization_type : organization_type;
  role : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;

ENTITY person_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person : person;
  role : person_role;
END_ENTITY;

ENTITY person_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type : person_type;
  role : person_type_role;
END_ENTITY;

ENTITY person_type_definition_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type_definition : person_type_definition;
  role : person_type_definition_role;
END_ENTITY;

ENTITY person_type_definition_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization : position_in_organization;
  role : position_in_organization_role;
END_ENTITY;

ENTITY position_in_organization_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization_type : position_in_organization_type;
  role : position_in_organization_type_role;
END_ENTITY;

ENTITY position_in_organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification : qualification;
  role : qualification_role;
END_ENTITY;

ENTITY qualification_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification_type : qualification_type;
  role : qualification_type_role;
END_ENTITY;

ENTITY qualification_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time : local_time;
  role : time_role;
END_ENTITY;

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;

FUNCTION acyclic_identification_assignment_relationship
 (relation : identification_assignment_relationship; relatives : SET[1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);

END_FUNCTION; 






(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\material_property_definition_schema\material_property_definition_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n257.exp *)


TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('CATALOG_DATA_INFORMATION_MIM_LF.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'CATALOG_DATA_INFORMATION_MIM_LF.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('CATALOG_DATA_INFORMATION_MIM_LF.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY property_definition_relationship;
  name                       : label;
  description                 : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

ENTITY material_designation;
  name       : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class               : label;
  constituent_amount   : SET [1:?] OF measure_with_unit;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;

  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;

  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality

  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'CATALOG_DATA_INFORMATION_MIM_LF.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));

  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;

  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\material_property_representation_schema\material_property_representation_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n257.exp *)


ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY data_environment;
  name       : label;
  description : text;
  elements    : SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    : label;
  description              : text;
  relating_data_environment : data_environment;
  related_data_environment  : data_environment;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\measure_schema\measure_schema.exp
   ------------------------------------------------------------
*)


TYPE amount_of_substance_measure = REAL;
END_TYPE; 

TYPE area_measure = REAL;
END_TYPE; 

TYPE celsius_temperature_measure = REAL;
END_TYPE; 

TYPE context_dependent_measure = REAL;
END_TYPE; 

TYPE count_measure = NUMBER;
END_TYPE; 

TYPE descriptive_measure = STRING;
END_TYPE; 

TYPE electric_current_measure = REAL;
END_TYPE; 

TYPE length_measure = REAL;
END_TYPE; 

TYPE luminous_intensity_measure = REAL;
END_TYPE; 

TYPE mass_measure = REAL;
END_TYPE; 

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE; 

TYPE numeric_measure = NUMBER;
END_TYPE; 

TYPE parameter_value = REAL;
END_TYPE; 

TYPE plane_angle_measure = REAL;
END_TYPE; 

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE ratio_measure = REAL;
END_TYPE; 

TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE; 

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE; 

TYPE solid_angle_measure = REAL;
END_TYPE; 

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; 

TYPE time_measure = REAL;
END_TYPE; 

TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE; 

TYPE volume_measure = REAL;
END_TYPE; 

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit,
                       mass_measure_with_unit,
                       time_measure_with_unit,
                       electric_current_measure_with_unit,
                       thermodynamic_temperature_measure_with_unit,
                       celsius_temperature_measure_with_unit,
                       amount_of_substance_measure_with_unit,
                       luminous_intensity_measure_with_unit,
                       plane_angle_measure_with_unit,
                       solid_angle_measure_with_unit,
                       area_measure_with_unit,
                       volume_measure_with_unit,
                       ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit,
                       conversion_based_unit,
                       context_dependent_unit)
               ANDOR ONEOF (length_unit,
                    mass_unit,
                    time_unit,
                    electric_current_unit,
                    thermodynamic_temperature_unit,
                    amount_of_substance_unit,
                    luminous_intensity_unit,
                    plane_angle_unit,
                    solid_angle_unit,
                    area_unit,
                    volume_unit,
                    ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'CATALOG_DATA_INFORMATION_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; 

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; 

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'CATALOG_DATA_INFORMATION_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; 





(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\person_organization_schema\person_organization_schema.exp
   ------------------------------------------------------------
*)


TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE; 

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_organization_type : organization_type;
  related_organization_type : organization_type;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value (SELF);
  description : text := get_description_value(SELF);
  
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_definition;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  formation : person_type_definition_formation;
END_ENTITY;

ENTITY person_type_definition_formation;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  of_person_type : person_type;
END_ENTITY;

ENTITY person_type_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition : person_type_definition;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization : position_in_organization;
END_ENTITY;

ENTITY position_in_organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_organization_type_relationship
 (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_person_type_definition_relationship
 (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_position_in_organization_relationship
 (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\presentation_appearance_schema\presentation_appearance_schema.exp
   ------------------------------------------------------------
*)


TYPE approximation_method = ENUMERATION OF
  (chordal_deviation,
   chordal_length);
END_TYPE;

TYPE box_characteristic_select = SELECT
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle);
END_TYPE;

TYPE box_height = positive_ratio_measure;
END_TYPE;

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

TYPE  box_slant_angle = plane_angle_measure;
END_TYPE;

TYPE box_width = positive_ratio_measure;
END_TYPE;

TYPE character_spacing_select = SELECT
  (length_measure,
   ratio_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_character_spacing);
END_TYPE;

TYPE character_style_select = SELECT
  (character_glyph_style_stroke,
   character_glyph_style_outline,
   text_style_for_defined_font);
END_TYPE;

TYPE curve_font_or_scaled_curve_font_select = SELECT
  (curve_style_font_select,
   curve_style_font_and_scaling);
END_TYPE;

TYPE curve_or_annotation_curve_occurrence = SELECT
  (curve,
   annotation_curve_occurrence);
END_TYPE;

TYPE curve_or_render = SELECT
  (curve_style,
   curve_style_rendering);
END_TYPE;

TYPE curve_style_font_select = SELECT
  (curve_style_font,
   pre_defined_curve_font,
   externally_defined_curve_font);
END_TYPE;

TYPE curve_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE curve_tolerance_parameter = REAL;
END_TYPE;

TYPE direction_count_select = SELECT
  (u_direction_count,
   v_direction_count);
END_TYPE;

TYPE fill_style_select = SELECT
  (fill_area_style_colour,
   pre_defined_tile_style,
   externally_defined_tile_style,
   fill_area_style_tiles,
   pre_defined_hatch_style,
   externally_defined_hatch_style,
   fill_area_style_hatching);
END_TYPE;

TYPE fill_area_style_tile_shape_select = SELECT
  (fill_area_style_tile_curve_with_style,
   fill_area_style_tile_coloured_region,
   fill_area_style_tile_symbol_with_style,
   pre_defined_tile,
   externally_defined_tile);
END_TYPE;

TYPE hiding_or_blanking_select = SELECT
  (presentation_area,
   presentation_view,
   product_data_representation_view,
   annotation_fill_area,
   area_dependent_annotation_representation,
   view_dependent_annotation_representation,
   annotation_text_with_delineation,
   character_glyph_symbol_stroke,
   character_glyph_symbol_outline,
   symbol_representation_with_blanking_box);
END_TYPE;

TYPE invisibility_context = SELECT 
  (presentation_layer_usage,
   presentation_representation,
   presentation_set);
END_TYPE;

TYPE invisible_item = SELECT 
  (styled_item,
   presentation_layer_assignment,
   representation);
END_TYPE;

TYPE marker_select = SELECT
  (marker_type,
   pre_defined_marker);
END_TYPE;

TYPE marker_type = ENUMERATION OF
  (dot,
   x,
   plus,
   asterisk,
   ring,
   square,
   triangle);
END_TYPE;

TYPE null_style = ENUMERATION OF
  (null);
END_TYPE;

TYPE presentation_style_select = SELECT
  (pre_defined_presentation_style,
   point_style,
   curve_style,
   surface_style_usage,
   symbol_style,
   fill_area_style,
   text_style,
   approximation_tolerance,
   externally_defined_style,
   null_style);
END_TYPE;

TYPE product_or_presentation_space = ENUMERATION OF
  (product_shape_space,
   presentation_area_space);
END_TYPE;

TYPE rendering_properties_select = SELECT
  (surface_style_reflectance_ambient,
   surface_style_transparent);
END_TYPE;

TYPE shading_curve_method = ENUMERATION OF
  (constant_colour,
   linear_colour);
END_TYPE;

TYPE shading_surface_method = ENUMERATION OF
  (constant_shading,
   colour_shading,
   dot_shading,
   normal_shading);
END_TYPE;

TYPE size_select  = SELECT
  (positive_length_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_size);
END_TYPE;

TYPE squared_or_rounded = ENUMERATION OF
  (squared,
   rounded);
END_TYPE;

TYPE style_context_select = SELECT
  (group,
   presentation_layer_assignment,
   representation,
   representation_item,
   presentation_set);
END_TYPE;

TYPE surface_side = ENUMERATION OF
  (positive,
   negative,
   both);
END_TYPE;

TYPE surface_side_style_select = SELECT
  (surface_side_style,
   pre_defined_surface_side_style);
END_TYPE;

TYPE surface_style_element_select = SELECT
  (surface_style_fill_area,
   surface_style_boundary,
   surface_style_silhouette,
   surface_style_segmentation_curve,
   surface_style_control_grid,
   surface_style_parameter_line,
   surface_style_rendering);
END_TYPE;

TYPE surface_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE surface_tolerance_parameter = REAL;
END_TYPE;

TYPE symbol_style_select= SELECT
  (symbol_element_style,
   symbol_colour);
END_TYPE;


TYPE text_justification = label;
END_TYPE;

TYPE tolerance_deviation_select = SELECT
  (curve_tolerance_deviation,
   surface_tolerance_deviation);
END_TYPE;

TYPE tolerance_parameter_select = SELECT
  (curve_tolerance_parameter,
   surface_tolerance_parameter);
END_TYPE;

TYPE tolerance_select = SELECT
  (approximation_tolerance_deviation,
   approximation_tolerance_parameter);
END_TYPE;

TYPE u_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE v_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;




ENTITY approximation_tolerance;
  tolerance : tolerance_select;
END_ENTITY;

ENTITY approximation_tolerance_deviation;
  tessellation_type : approximation_method;
  tolerances        : SET [1:2] OF tolerance_deviation_select;
  definition_space  : product_or_presentation_space;
WHERE
  WR1: (HIINDEX(SELF.tolerances) = 1)
                XOR
       (TYPEOF(SELF.tolerances[1]) <> TYPEOF(SELF.tolerances[2]));
END_ENTITY;

ENTITY approximation_tolerance_parameter;
  tolerances : SET [1:2] OF tolerance_parameter_select;
WHERE
  WR1: (HIINDEX (SELF.tolerances) = 1 )
               XOR
       (TYPEOF (SELF.tolerances[1]) <> TYPEOF (SELF.tolerances[2]));
END_ENTITY;

ENTITY character_glyph_style_outline;
  outline_style : curve_style;
END_ENTITY;

ENTITY character_glyph_style_outline_with_characteristics
  SUBTYPE OF (character_glyph_style_outline);
  characteristics : fill_area_style;
END_ENTITY;

ENTITY character_glyph_style_stroke;
  stroke_style : curve_style;
END_ENTITY;

ENTITY context_dependent_invisibility
  SUBTYPE OF (invisibility);
  presentation_context : invisibility_context;
END_ENTITY;

ENTITY context_dependent_over_riding_styled_item
  SUBTYPE OF(over_riding_styled_item);
  style_context : SET[1:2] OF style_context_select;
WHERE
  WR1: (SIZEOF(QUERY( sc <* SELF.style_context |
       'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION' IN
         TYPEOF(sc))) = 1 )
                 AND
       (SIZEOF(QUERY( sc <* SELF.style_context |
       'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION_ITEM' IN
         TYPEOF(sc))) = 1);
END_ENTITY;

ENTITY curve_style;
  name         : label;
  curve_font   : curve_font_or_scaled_curve_font_select;
  curve_width  : size_select;
  curve_colour : colour;
END_ENTITY;

ENTITY curve_style_curve_pattern
  SUBTYPE OF (geometric_representation_item);
  pattern        : annotation_curve_occurrence;
  pattern_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_curve_pattern_set
  SUBTYPE OF (curve_style_font, 
              geometric_representation_item);
  pattern_set : SET [1:?] OF curve_style_curve_pattern;
END_ENTITY;

ENTITY curve_style_font;
  name         : label;
  pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;

ENTITY curve_style_font_and_scaling;
  name               : label;
  curve_font         : curve_style_font_select;
  curve_font_scaling : REAL;
END_ENTITY;

ENTITY curve_style_font_pattern;
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_rendering;
  rendering_method     : shading_curve_method;
  rendering_properties : surface_rendering_properties;
END_ENTITY;

ENTITY curve_style_wide
  SUBTYPE OF (curve_style_font);
  interior_style : fill_area_style;
END_ENTITY;

ENTITY curve_style_with_ends_and_corners
  SUBTYPE OF (curve_style);
  curve_ends    : squared_or_rounded;
  curve_corners : squared_or_rounded;
END_ENTITY;

ENTITY curve_style_with_extension
  SUBTYPE OF (curve_style);
  curve_extensions   : length_measure;
END_ENTITY;

ENTITY draughting_pre_defined_curve_font
  SUBTYPE OF (pre_defined_curve_font);
WHERE
  WR1: SELF.name IN
       ['continuous',
        'chain',
        'chain double dash',
        'dashed',
        'dotted'];
END_ENTITY;

ENTITY externally_defined_curve_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_hatch_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_style
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_tile
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_tile_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style;
  name       : label;
  fill_styles : SET [1:?] OF fill_style_select;
WHERE
  WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'CATALOG_DATA_INFORMATION_MIM_LF.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;

ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

ENTITY fill_area_style_hatching
  SUBTYPE OF (geometric_representation_item);
  hatch_line_appearance         : curve_style;
  start_of_next_hatch_line      : one_direction_repeat_factor;
  point_of_reference_hatch_line : cartesian_point;
  pattern_start                 : cartesian_point;
  hatch_line_angle              : plane_angle_measure;
END_ENTITY;

ENTITY fill_area_style_tile_coloured_region
  SUBTYPE OF (geometric_representation_item);
  closed_curve  : curve_or_annotation_curve_occurrence;
  region_colour : colour;
END_ENTITY;

ENTITY fill_area_style_tile_curve_with_style
  SUBTYPE OF (geometric_representation_item);
  styled_curve : annotation_curve_occurrence;
END_ENTITY;

ENTITY fill_area_style_tile_symbol_with_style
  SUBTYPE OF (geometric_representation_item);
  symbol : annotation_symbol_occurrence;
END_ENTITY;

ENTITY fill_area_style_tiles
  SUBTYPE OF (geometric_representation_item);
  tiling_pattern : two_direction_repeat_factor;
  tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
  tiling_scale   : positive_ratio_measure;
END_ENTITY;

ENTITY invisibility;
  invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;

ENTITY occlusion_precedence;
  higher_precedence : hiding_or_blanking_select;
  lower_precedence  : hiding_or_blanking_select;
  occlusion_context : representation;
WHERE
  WR1: acyclic_occlusion_precedence (SELF, [SELF.lower_precedence]);
END_ENTITY;

ENTITY one_direction_repeat_factor
  SUBTYPE OF (geometric_representation_item);
  repeat_factor : vector;
END_ENTITY;

ENTITY over_riding_styled_item
  SUBTYPE OF (styled_item);
  over_ridden_style : styled_item;
END_ENTITY;

ENTITY point_style;
  name          : label;
  marker        : marker_select;
  marker_size   : size_select;
  marker_colour : colour;
END_ENTITY;

ENTITY pre_defined_character_spacing
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_hatch_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY pre_defined_marker
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_presentation_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_size
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_surface_side_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_tile
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_tile_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY presentation_style_assignment;
  styles : SET [1:?] OF presentation_style_select;
WHERE
  WR1: SIZEOF (QUERY (style1 <* SELF.styles |
         NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.' +
                       'SURFACE_STYLE_USAGE',
                       'CATALOG_DATA_INFORMATION_MIM_LF.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
  WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
END_ENTITY;

ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

ENTITY symbol_colour;
  colour_of_symbol : colour;
END_ENTITY;

ENTITY symbol_element_style;
  style_of_symbol : presentation_style_assignment;
WHERE
  WR1: SIZEOF (QUERY ( style <* SELF.style_of_symbol.styles |
         'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_STYLE' IN
         TYPEOF (style))) = 0;
  WR2: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' +
            'PRESENTATION_STYLE_BY_CONTEXT' IN
            TYPEOF (SELF.style_of_symbol)
           );
END_ENTITY;

ENTITY symbol_style;
  name            : label; 
  style_of_symbol : symbol_style_select;
END_ENTITY;

ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles :  SET [1:?] OF presentation_style_assignment;
  item   :  representation_item;
WHERE
  WR1: (SIZEOF(SELF.styles) = 1)
               XOR
       (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;

ENTITY surface_rendering_properties;
  rendered_colour : colour;
END_ENTITY;

ENTITY surface_side_style;
  name   : label;
  styles : SET [1:7] OF surface_style_element_select;
WHERE
  WR1: SIZEOF(QUERY( style1 <* SELF.styles |
         SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
         )) = 0;
END_ENTITY;

ENTITY surface_style_boundary;
  style_of_boundary : curve_or_render;
END_ENTITY;

ENTITY surface_style_control_grid;
  style_of_control_grid : curve_or_render;
END_ENTITY;

ENTITY surface_style_fill_area;
  fill_area : fill_area_style;
END_ENTITY;

ENTITY surface_style_parameter_line;
  style_of_parameter_lines : curve_or_render;
  direction_counts         : SET [1:2] OF direction_count_select;
WHERE
  WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
       (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
END_ENTITY;

ENTITY surface_style_reflectance_ambient;
  ambient_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse
  SUBTYPE OF (surface_style_reflectance_ambient);
  diffuse_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse_specular
  SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
  specular_reflectance : REAL;
  specular_exponent    : REAL;
  specular_colour      : colour;
END_ENTITY;

ENTITY surface_style_rendering;
  rendering_method : shading_surface_method;
  surface_colour   : colour;
END_ENTITY;

ENTITY surface_style_rendering_with_properties
  SUBTYPE OF (surface_style_rendering);
  properties : SET [1:2] OF rendering_properties_select;
WHERE
  WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
       (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
END_ENTITY;

ENTITY surface_style_segmentation_curve;
  style_of_segmentation_curve : curve_or_render;
END_ENTITY;

ENTITY surface_style_silhouette;
  style_of_silhouette : curve_or_render;
END_ENTITY;

ENTITY surface_style_transparent;
  transparency : REAL;
WHERE
  WR1: {0.0 <= transparency <= 1.0};
END_ENTITY;

ENTITY surface_style_usage;
  side  : surface_side;
  style : surface_side_style_select;
END_ENTITY;

ENTITY text_style;
  name                 : label;
  character_appearance : character_style_select;
END_ENTITY;

ENTITY text_style_for_defined_font;
  text_colour : colour;
END_ENTITY;

ENTITY text_style_with_box_characteristics
  SUBTYPE OF (text_style);
  characteristics : SET [1:4] OF box_characteristic_select;
WHERE
  WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
         SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
       )) = 0;
END_ENTITY;

ENTITY text_style_with_justification
  SUBTYPE OF (text_style);
  justification : text_justification;
END_ENTITY;

ENTITY text_style_with_mirror
  SUBTYPE OF (text_style);
  mirror_placement : axis2_placement;
END_ENTITY;

ENTITY text_style_with_spacing
  SUBTYPE OF (text_style);
  character_spacing : character_spacing_select;
END_ENTITY;

ENTITY two_direction_repeat_factor
  SUBTYPE OF (one_direction_repeat_factor);
  second_repeat_factor : vector;
END_ENTITY;


FUNCTION acyclic_occlusion_precedence
   ( relation : occlusion_precedence;
     set_of_lower : SET OF hiding_or_blanking_select ) : BOOLEAN;
   LOCAL
      x : SET OF occlusion_precedence;
      local_set_of_lower : SET OF hiding_or_blanking_select;
   END_LOCAL;
   REPEAT i:=1 TO HIINDEX(set_of_lower);
      IF relation.higher_precedence :=: set_of_lower[i] THEN
         RETURN(FALSE);
      END_IF;
   END_REPEAT;
   x := bag_to_set (USEDIN ( relation.higher_precedence,
                   'CATALOG_DATA_INFORMATION_MIM_LF.'+
           'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
   local_set_of_lower := set_of_lower + relation.higher_precedence;
   IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
         If NOT acyclic_occlusion_precedence(x[i] ,
 
                                     local_set_of_lower) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
   END_IF;
   RETURN (TRUE);
END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\presentation_definition_schema\presentation_definition_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n953.exp *)


TYPE defined_glyph_select = SELECT
  (pre_defined_character_glyph,
   externally_defined_character_glyph);
END_TYPE;

TYPE defined_symbol_select = SELECT
  (pre_defined_symbol,
   externally_defined_symbol);
END_TYPE;

TYPE text_alignment = label;
END_TYPE;

TYPE text_delineation = label;
END_TYPE;

TYPE text_or_character = SELECT
  (annotation_text,
   annotation_text_character,
   defined_character_glyph,
   composite_text,
   text_literal);
END_TYPE;

TYPE text_path = ENUMERATION OF
  (left,
   right,
   up,
   down);
END_TYPE;

ENTITY annotation_curve_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.CURVE' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_fill_area
  SUBTYPE OF (geometric_representation_item);
  boundaries : SET [1:?] OF curve;
END_ENTITY;

ENTITY annotation_fill_area_occurrence
  SUBTYPE OF (annotation_occurrence);
  fill_style_target : point;
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_FILL_AREA' IN
         TYPEOF (SELF.item);
END_ENTITY;

ENTITY annotation_occurrence
  SUPERTYPE OF (ONEOF(annotation_point_occurrence,
                      annotation_curve_occurrence,
                      annotation_fill_area_occurrence,
                      annotation_text_occurrence,
                      annotation_symbol_occurrence))
  SUBTYPE OF (styled_item);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_occurrence_relationship;
  name                           : label;
  description                    : text;
  relating_annotation_occurrence : annotation_occurrence;
  related_annotation_occurrence  : annotation_occurrence;
END_ENTITY;

ENTITY annotation_point_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.POINT' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_symbol
  SUBTYPE OF(mapped_item);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_REPRESENTATION_MAP' IN
         TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_TARGET' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_symbol_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF(
         ['CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_SYMBOL',
          'CATALOG_DATA_INFORMATION_MIM_LF.DEFINED_SYMBOL'] *
         TYPEOF(SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_table
  SUBTYPE OF(annotation_symbol);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.TABLE_REPRESENTATION' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;

ENTITY annotation_table_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (
         ['CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TABLE',
          'CATALOG_DATA_INFORMATION_MIM_LF.DEFINED_TABLE'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_text
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT' IN
       TYPEOF( SELF\mapped_item.mapping_target);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.TEXT_STRING_REPRESENTATION' IN
       TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
       TYPEOF( SELF);
END_ENTITY;

ENTITY annotation_text_character
  SUBTYPE OF (mapped_item);
  alignment : text_alignment;
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_text_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF (
         ['CATALOG_DATA_INFORMATION_MIM_LF.TEXT_LITERAL',
          'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT',
          'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT_CHARACTER',
          'CATALOG_DATA_INFORMATION_MIM_LF.DEFINED_CHARACTER_GLYPH',
          'CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_TEXT'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_text_with_associated_curves
  SUBTYPE OF (annotation_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY annotation_text_with_blanking_box
  SUBTYPE OF (annotation_text);
  blanking : planar_box;
END_ENTITY;

ENTITY annotation_text_with_delineation
  SUBTYPE OF (annotation_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY annotation_text_with_extent
  SUBTYPE OF (annotation_text);
  extent : planar_extent;
END_ENTITY;

ENTITY composite_text
  SUBTYPE OF (geometric_representation_item);
  collected_text : SET[2:?] of text_or_character;
WHERE
  WR1: acyclic_composite_text( SELF, SELF.collected_text);
END_ENTITY;

ENTITY composite_text_with_associated_curves
  SUBTYPE OF (composite_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY composite_text_with_blanking_box
  SUBTYPE OF (composite_text);
  blanking : planar_box;
END_ENTITY;

ENTITY composite_text_with_delineation
  SUBTYPE OF (composite_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY composite_text_with_extent
  SUBTYPE OF (composite_text);
  extent : planar_extent;
END_ENTITY;

ENTITY defined_character_glyph
  SUBTYPE OF(geometric_representation_item);
  definition : defined_glyph_select;
  placement  : axis2_placement;
END_ENTITY;

ENTITY defined_symbol
  SUBTYPE OF(geometric_representation_item);
  definition : defined_symbol_select;
  target     : symbol_target;
END_ENTITY;

ENTITY defined_table
  SUBTYPE OF(defined_symbol);
END_ENTITY;

ENTITY externally_defined_character_glyph
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_symbol
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY pre_defined_character_glyph
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_symbol
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY symbol_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY symbol_representation_map
  SUBTYPE OF (representation_map);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_map.mapped_representation);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY symbol_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: acyclic_symbol_representation_relationship (SELF,
                                                   [SELF\representation_relationship.
                                                         rep_2]);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_REPRESENTATION'IN
          TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY symbol_representation_with_blanking_box
  SUBTYPE OF (symbol_representation);
  blanking : planar_box;
WHERE
  WR1: item_in_context (SELF.blanking, SELF\representation.context_of_items);
END_ENTITY;

ENTITY symbol_target
  SUBTYPE OF (geometric_representation_item);
  placement         : axis2_placement;
  x_scale           : positive_ratio_measure;
  y_scale           : positive_ratio_measure;
END_ENTITY;

ENTITY table_representation
  SUBTYPE OF (symbol_representation);
END_ENTITY;

ENTITY table_record_field_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'CATALOG_DATA_INFORMATION_MIM_LF.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                         'CATALOG_DATA_INFORMATION_MIM_LF.'+
                                           'TABLE_RECORD_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_record_field_representation_with_clipping_box
  SUBTYPE OF (table_record_field_representation);
  clipping_box : planar_box;
WHERE
   WR1: item_in_context (SELF.clipping_box, 
                         SELF\representation.context_of_items);
END_ENTITY;

ENTITY table_record_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'CATALOG_DATA_INFORMATION_MIM_LF.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                              'CATALOG_DATA_INFORMATION_MIM_LF.'+
                                              'TABLE_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_representation_relationship
  SUBTYPE OF (symbol_representation_relationship);
WHERE
  WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_RECORD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR2: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_REPRESENTATION' IN
             TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_RECORD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR3: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1)) 
         XOR
       ('CATALOG_DATA_INFORMATION_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
END_ENTITY;

ENTITY table_text_relationship
  SUBTYPE OF (annotation_occurrence_relationship);
  field : table_record_field_representation;
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TABLE_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TABLE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence\styled_item.item);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  related_annotation_occurrence);
  WR4: field_in_table (SELF.field,
                       SELF\annotation_occurrence_relationship.
                       relating_annotation_occurrence);
END_ENTITY;

ENTITY text_literal
  SUBTYPE OF (geometric_representation_item);
  literal   : presentable_text;
  placement : axis2_placement;
  alignment : text_alignment;
  path      : text_path;
  font      : font_select;
END_ENTITY;

ENTITY text_literal_with_associated_curves
  SUBTYPE OF (text_literal);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY text_literal_with_blanking_box
  SUBTYPE OF (text_literal);
  blanking : planar_box;
END_ENTITY;

ENTITY text_literal_with_delineation
  SUBTYPE OF (text_literal);
  delineation : text_delineation;
END_ENTITY;

ENTITY text_literal_with_extent
  SUBTYPE OF (text_literal);
  extent : planar_extent;
END_ENTITY;

ENTITY text_string_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (
         QUERY (item <* SELF\representation.items |
           SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.TEXT_LITERAL',
                    'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT',
                    'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT_CHARACTER',
                    'CATALOG_DATA_INFORMATION_MIM_LF.DEFINED_CHARACTER_GLYPH',
                    'CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_TEXT',
                    'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT'] * TYPEOF (item)) = 0
         )) = 0;
  WR2: SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.TEXT_LITERAL',
                         'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT',
                         'CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT_CHARACTER',
                         'CATALOG_DATA_INFORMATION_MIM_LF.DEFINED_CHARACTER_GLYPH',
                         'CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
  WR3: SIZEOF (
         QUERY (a2p <* 
           QUERY (item <* SELF\representation.items | 
             'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <* 
               QUERY (item <* SELF\representation.items | 
                  'CATALOG_DATA_INFORMATION_MIM_LF.' + 
                  'ANNOTATION_TEXT' IN TYPEOF (item)) | 
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <* 
               QUERY (item <* SELF\representation.items |
                 'CATALOG_DATA_INFORMATION_MIM_LF.' + 
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | 
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
END_ENTITY;

FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;

  LOCAL
   i : INTEGER;
   local_composite_text : SET [0:?] OF composite_text;
   local_annotation_text : SET [0:?] OF annotation_text;
   local_children : SET [0:?] OF text_or_character;
  END_LOCAL;

  local_composite_text := QUERY (child <* child_text |
                          ('CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_composite_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      IF (start_composite :=: local_composite_text[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;

  local_children := child_text;

  IF (SIZEOF (local_composite_text)) > 0 THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      local_children := local_children +
                        local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;


  local_annotation_text := QUERY (child <* child_text |
                          ('CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_annotation_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_annotation_text);
      local_children := local_children +
      QUERY (item <* local_annotation_text[i]\mapped_item.
                     mapping_source.mapped_representation.items |
        SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_TEXT',
                'CATALOG_DATA_INFORMATION_MIM_LF.COMPOSITE_TEXT'] *
                TYPEOF(item)) > 0);
    END_REPEAT;
  END_IF;

  IF (local_children :<>: child_text) THEN
    RETURN (acyclic_composite_text (start_composite, local_children));
  ELSE
    RETURN (TRUE);
  END_IF;

 END_FUNCTION;

FUNCTION acyclic_symbol_representation_relationship
  (relation : symbol_representation_relationship;
   children : SET OF symbol_representation ) : BOOLEAN;
  LOCAL
    x : SET OF symbol_representation_relationship;
    local_children : SET OF symbol_representation;
  END_LOCAL;
 
  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
 
  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                'CATALOG_DATA_INFORMATION_MIM_LF.'+
                'REPRESENTATION_RELATIONSHIP.'+ 'REP_2'));
  local_children := children + relation\representation_relationship.rep_1;
 
  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
      IF NOT acyclic_symbol_representation_relationship(x[i] , 
                                                local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
 
  RETURN (TRUE);
 
END_FUNCTION;

FUNCTION field_in_table (field : table_record_field_representation;
                         table : annotation_table_occurrence): BOOLEAN;
  LOCAL
    table_rep : table_representation;
    symbol_rep_rel_set : SET OF symbol_representation_relationship;
    mapped_item_set : SET OF mapped_item;
    table_record_rep_set : SET OF table_record_representation := [];
  END_LOCAL;
 
  table_rep := table\styled_item.item\mapped_item.mapping_source.
    mapped_representation;
  mapped_item_set := QUERY(item <* table_rep.items |
                       ('CATALOG_DATA_INFORMATION_MIM_LF.MAPPED_ITEM' IN
                        TYPEOF(item))
                                 AND
                       ('CATALOG_DATA_INFORMATION_MIM_LF.'+
                        'TABLE_RECORD_REPRESENTATION' IN
                         TYPEOF(item\mapped_item.mapping_source.
                                    mapped_representation ))
                     );
 
  REPEAT i := 1 TO HIINDEX(mapped_item_set);
    table_record_rep_set := table_record_rep_set +
           mapped_item_set[i].mapping_source.mapped_representation;
  END_REPEAT;
 
  symbol_rep_rel_set := bag_to_set (USEDIN(table_rep, 
                               'CATALOG_DATA_INFORMATION_MIM_LF.'+
                               'REPRESENTATION_RELATIONSHIP.REP_1'));
 
  REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
     table_record_rep_set := table_record_rep_set +
              symbol_rep_rel_set[i]\representation_relationship.rep_2;
  END_REPEAT;
 
  IF SIZEOF(QUERY( table_record_rep <* table_record_rep_set |
--              (SIZEOF(QUERY( symbol_rep_rel <* USEDIN(table_record_rep,
--                            'CATALOG_DATA_INFORMATION_MIM_LF.'+
--                            'SYMBOL_REPRESENTATION_RELATIONSHIP.REP_1') |
--                       symbol_rep_rel\representation_relationship.rep_2 :=: field
              (SIZEOF(QUERY( rep_rel <* USEDIN(table_record_rep,
                            'CATALOG_DATA_INFORMATION_MIM_LF.'+
                            'REPRESENTATION_RELATIONSHIP.REP_1') |
                       ('CATALOG_DATA_INFORMATION_MIM_LF.' +
                       'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rep_rel)) AND  
                       (rep_rel.rep_2 :=: field)
                       )) > 0)
                       OR
              (SIZEOF(QUERY(item <* table_record_rep.items |
                        ('CATALOG_DATA_INFORMATION_MIM_LF.MAPPED_ITEM' IN
                         TYPEOF(item))
                                 AND
                        (field :=: item\mapped_item.mapping_source.
                                    mapped_representation )
                         )) > 0)
             )) = 0 THEN
    RETURN(FALSE);
  END_IF;
 
  RETURN(TRUE);
 
END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\presentation_organization_schema\presentation_organization_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n953.exp *)


TYPE area_or_view = SELECT 
  (presentation_area,
   presentation_view);
END_TYPE;

TYPE central_or_parallel = ENUMERATION OF 
  (central, 
   parallel);
END_TYPE;

TYPE layered_item = SELECT 
  (presentation_representation,
   representation_item);
END_TYPE;

TYPE presentation_representation_select = SELECT 
  (presentation_representation,
   presentation_set);
END_TYPE;

TYPE presentation_size_assignment_select = SELECT 
  (presentation_view,
   presentation_area,
   area_in_set);
END_TYPE;

ENTITY area_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'ANNOTATION_OCCURRENCE',
                     'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_OCCURRENCE' IN
         TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY area_in_set;
  area   : presentation_area;
  in_set : presentation_set;
END_ENTITY;

ENTITY background_colour
  SUBTYPE OF (colour);
  presentation : area_or_view;
UNIQUE
  UR1:  presentation;
END_ENTITY;

ENTITY camera_image
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.CAMERA_USAGE'
       IN TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.PLANAR_BOX'
       IN TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'
       IN TYPEOF (SELF);
END_ENTITY;

ENTITY camera_image_3d_with_scale
  SUBTYPE OF (camera_image);
DERIVE
  scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
         planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
         mapping_origin\camera_model_d3.perspective_of_volume.view_window.
         size_in_x));
WHERE
  WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.CAMERA_MODEL_D3'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
  WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
       aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
       camera_model_d3.perspective_of_volume.view_window);
  WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.front_plane_clipping
       AND
       SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_volume_sides_clipping;
  WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
  WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_y > 0);
  WR6: ('CATALOG_DATA_INFORMATION_MIM_LF.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement))
       AND NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement));
END_ENTITY;

ENTITY camera_model
  SUPERTYPE OF (ONEOF(camera_model_d2, camera_model_d3))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: (SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                              'ITEM_DEFINED_TRANSFORMATION.' +
                              'TRANSFORM_ITEM_1')) +
        SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                              'REPRESENTATION_MAP.MAPPING_ORIGIN'))
       ) > 0;
  WR2: SIZEOF(USEDIN(SELF,'CATALOG_DATA_INFORMATION_MIM_LF.'+
                          'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY camera_model_d2
  SUBTYPE OF (camera_model);
  view_window          : planar_box;
  view_window_clipping : BOOLEAN;
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY camera_model_d2_shape_clipping
  SUBTYPE OF (camera_model_d2);
  shape_clipping : curve;
END_ENTITY;

ENTITY camera_model_d3
  SUBTYPE OF (camera_model);
  view_reference_system : axis2_placement_3d;
  perspective_of_volume : view_volume;
WHERE
  WR1: (dot_product (SELF.view_reference_system.p[3],
         SELF.perspective_of_volume.view_window.placement.p[3]) = 1.0)
         AND
       (SELF.view_reference_system.location.coordinates[3] =
        SELF.perspective_of_volume.view_window.
             placement.location.coordinates[3]);
  WR2: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY camera_model_d3_multi_clipping
  SUBTYPE OF (camera_model_d3);
  shape_clipping : SET [1:?] OF plane;
END_ENTITY;

ENTITY camera_model_d3_with_hlhsr
  SUBTYPE OF (camera_model_d3);
  hidden_line_surface_removal : BOOLEAN;
END_ENTITY;

ENTITY camera_model_with_light_sources
  SUBTYPE OF (camera_model_d3);
  sources : SET [1:?] OF light_source;
END_ENTITY;

ENTITY camera_usage
  SUBTYPE OF (representation_map);
WHERE
  WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_REPRESENTATION'
       IN TYPEOF(SELF\representation_map.mapped_representation));
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.CAMERA_MODEL'
       IN TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY graphical_transformation
  SUBTYPE OF (item_defined_transformation);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT_2D' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_1);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_SCALED_PLACEMENT' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_2);
END_ENTITY;

ENTITY light_source
  SUPERTYPE OF (ONEOF(light_source_ambient,
                      light_source_directional,
                      light_source_positional,
                      light_source_spot))
  SUBTYPE OF (geometric_representation_item);
  light_colour : colour;
WHERE
  WR1: SIZEOF(USEDIN(SELF,'CATALOG_DATA_INFORMATION_MIM_LF.'+
                         'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY light_source_ambient
  SUBTYPE OF (light_source);
END_ENTITY;

ENTITY light_source_directional
  SUBTYPE OF (light_source);
  orientation : direction;
END_ENTITY;

ENTITY light_source_positional
  SUBTYPE OF (light_source);
  position             : cartesian_point;
  constant_attenuation : REAL;
  distance_attenuation : REAL;
END_ENTITY;

ENTITY light_source_spot
  SUBTYPE OF (light_source);
  position               : cartesian_point;
  orientation            : direction;
  concentration_exponent : REAL;
  constant_attenuation   : REAL;
  distance_attenuation   : REAL;
  spread_angle           : positive_plane_angle_measure;
END_ENTITY;

ENTITY presentation_area
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                                             'AREA_IN_SET.AREA') | 
           SIZEOF (USEDIN (ais, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                                'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
         (SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                                'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;

ENTITY presentation_layer_assignment;
  name           : label;
  description    : text;
  assigned_items : SET [1:?] OF layered_item;
END_ENTITY;

ENTITY presentation_layer_usage;
  assignment   : presentation_layer_assignment;
  presentation : presentation_representation;
UNIQUE
  UR1: assignment, presentation;
END_ENTITY;

ENTITY presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SELF\representation.
            context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT'
       IN TYPEOF (SELF\representation.context_of_items);
END_ENTITY;



ENTITY presentation_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2);
  WR3: acyclic_presentation_representation_relationship (SELF,
         [SELF\representation_relationship.rep_2]);
  WR4: NOT (('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_AREA' IN
         TYPEOF (SELF\representation_relationship.rep_1)) 
                 AND
         NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.' +
                       'PRODUCT_DATA_REPRESENTATION_VIEW',
                       'CATALOG_DATA_INFORMATION_MIM_LF.' +
                       'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION'] *
         TYPEOF (SELF\representation_relationship.rep_2)) = 0));
  WR5: NOT (('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_VIEW'
         IN TYPEOF (SELF\representation_relationship.rep_1))
                 AND
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'PRESENTATION_AREA',
                     'CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'PRESENTATION_VIEW',
                     'CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'AREA_DEPENDENT_ANNOTATION_REPRESENTATION'] *
              TYPEOF (SELF\representation_relationship.rep_2))=0));
  WR6: (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2)))
              XOR
         ('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_AREA'IN
         TYPEOF(SELF\representation_relationship.rep_1));
  WR7: (NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' +
             'PRODUCT_DATA_REPRESENTATION_VIEW' IN
         (TYPEOF(SELF\representation_relationship.rep_1) +
          TYPEOF(SELF\representation_relationship.rep_2))))
              XOR
       ('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_1))
                AND
       ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DATA_REPRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2));
  WR8: 'CATALOG_DATA_INFORMATION_MIM_LF.GRAPHICAL_TRANSFORMATION' IN
         TYPEOF(SELF\representation_relationship_with_transformation.
                     transformation_operator);
END_ENTITY;

ENTITY presentation_set;
INVERSE
  areas : SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;

ENTITY presentation_size;
  unit : presentation_size_assignment_select;
  size : planar_box;
WHERE
  WR1: (('CATALOG_DATA_INFORMATION_MIM_LF.PRESENTATION_REPRESENTATION'
         IN TYPEOF (SELF.unit)) AND
         item_in_context (SELF.size, 
                          SELF.unit\representation.context_of_items)
       )
            OR
       (
        ('CATALOG_DATA_INFORMATION_MIM_LF.AREA_IN_SET'
          IN TYPEOF (SELF.unit)) AND
        (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0)
       ); 
END_ENTITY;

ENTITY presentation_view
  SUBTYPE OF (presentation_representation);
END_ENTITY;

ENTITY presented_item
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY presented_item_representation;
  presentation : presentation_representation_select;
  item         : presented_item;
END_ENTITY;

ENTITY product_data_representation_view
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.CAMERA_IMAGE',
                     'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT'] *
                    TYPEOF (item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('CATALOG_DATA_INFORMATION_MIM_LF.CAMERA_IMAGE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY representation_item_dependent_layer_assignment
  SUBTYPE OF (presentation_layer_assignment);
  item_context : representation_item;
END_ENTITY;

ENTITY view_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.' +
                     'ANNOTATION_OCCURRENCE',
                     'CATALOG_DATA_INFORMATION_MIM_LF.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
       ('CATALOG_DATA_INFORMATION_MIM_LF.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY view_volume
  SUBTYPE OF (founded_item);
  projection_type            : central_or_parallel;
  projection_point           : cartesian_point;
  view_plane_distance        : length_measure;
  front_plane_distance       : length_measure;
  front_plane_clipping       : BOOLEAN;
  back_plane_distance        : length_measure;
  back_plane_clipping        : BOOLEAN;
  view_volume_sides_clipping : BOOLEAN;
  view_window                : planar_box;
END_ENTITY;

RULE symbol_representation_rule
  FOR (presentation_representation_relationship);
WHERE
  WR1: SIZEOF(QUERY(each_1 <* presentation_representation_relationship  |
              NOT ('CATALOG_DATA_INFORMATION_MIM_LF.'+
              'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(each_1)) AND
         (SIZEOF(QUERY(each_2 <* [each_1\representation_relationship.rep_1,
                                  each_1\representation_relationship.rep_2] |
         'CATALOG_DATA_INFORMATION_MIM_LF.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)
         )) > 0)
       )) = 0;
END_RULE;

FUNCTION acyclic_presentation_representation_relationship
  ( relation : presentation_representation_relationship;
    children : SET OF presentation_representation ) : BOOLEAN;

  LOCAL
    x : SET OF presentation_representation_relationship;
    local_children : SET OF presentation_representation;
  END_LOCAL;

  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
       RETURN(FALSE);
    END_IF;
  END_REPEAT;

  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'CATALOG_DATA_INFORMATION_MIM_LF.'+
                  'REPRESENTATION_RELATIONSHIP.REP_2'));
  local_children := children + relation\representation_relationship.rep_1;

  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
       IF NOT acyclic_presentation_representation_relationship
              (x[i] , local_children) THEN
         RETURN (FALSE);
       END_IF;
    END_REPEAT;
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;


(* if the dimensions of the planar_box are greater than zero,
      compute the aspect ratio and return the resulting value. *)


IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
   ELSE
      RETURN (?);
   END_IF;
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\presentation_resource_schema\presentation_resource_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n953.exp *)


TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font,
   text_font);
END_TYPE;

TYPE presentable_text = STRING;
END_TYPE;

TYPE staircase_or_linear = ENUMERATION OF 
  (staircase, 
   linear);
END_TYPE;


ENTITY character_glyph_font_usage;
  character : generic_character_glyph_symbol;
  font      : text_font;
END_ENTITY;

ENTITY generic_character_glyph_symbol
  ABSTRACT SUPERTYPE
  SUBTYPE OF (symbol_representation);
END_ENTITY; 

ENTITY character_glyph_symbol
  SUBTYPE OF (generic_character_glyph_symbol);
  character_box  : planar_extent;
  baseline_ratio : ratio_measure;
DERIVE
  box_height : length_measure := character_box.size_in_y;
WHERE
  WR1: {0.0 <= baseline_ratio <= 1.0};
  WR2: item_in_context(SELF.character_box, 
                       SELF\representation.context_of_items);
  WR3: 'CATALOG_DATA_INFORMATION_MIM_LF.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;

ENTITY character_glyph_symbol_outline
  SUBTYPE OF (character_glyph_symbol);
  outlines : SET [1:?] OF annotation_fill_area;
WHERE
  WR1: SELF.outlines <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_symbol_stroke
  SUBTYPE OF (character_glyph_symbol);
  strokes : SET [1:?] OF curve;
WHERE
  WR1: SELF.strokes <= SELF\representation.items;
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_associated
  SUBTYPE OF (colour);
  name : label;
  variable_to_be_shown : SET [1:?] OF REAL;
  mapping              : colour_association_table;
END_ENTITY;

ENTITY colour_association_table;
  discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
  interpolation_type           : staircase_or_linear;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_text_font
   SUBTYPE of (pre_defined_text_font);
WHERE
   WR1: SELF.name IN ['ISO 3098'];
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY presentation_scaled_placement 
  SUBTYPE OF (geometric_representation_item);
  placement : axis2_placement;
  scaling   : positive_ratio_measure;
END_ENTITY;

ENTITY state_variable_with_colour;
  state_variable    : REAL;
  associated_colour : colour_specification;
END_ENTITY;

ENTITY text_font;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;

ENTITY text_font_family;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  fonts       : SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;

ENTITY text_font_in_family;
  font   : text_font;
  family : text_font_family;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\process_property_schema\process_property_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/10303-049.exp *)


TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'CATALOG_DATA_INFORMATION_MIM_LF.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\process_property_representation_schema\process_property_representation_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/10303-049.exp *)


ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\product_concept_schema\product_concept_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n529.exp *)


ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\product_definition_schema\product_definition_schema.exp
   ------------------------------------------------------------
*)


TYPE source = ENUMERATION OF 
   (made,
    bought,
    not_known);
END_TYPE; 

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;

ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;

ENTITY product_definition_substitute;
  description : OPTIONAL text;
  context_relationship : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY product_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product : product;
  related_product : product;
END_ENTITY;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_formation_relationship
 (relation : product_definition_formation_relationship; relatives : SET[1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_relationship
 (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_relationship
 (relation : product_relationship; relatives : SET[1:?] OF product; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_product_definitions
 (c_def_instance : product) : SET OF product_definition; 
  LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 




(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\product_property_definition_schema\product_property_definition_schema.exp
   ------------------------------------------------------------
*)


TYPE characterized_definition = SELECT
   (characterized_object, 
    characterized_product_definition, 
    shape_definition);
END_TYPE; 

TYPE characterized_product_definition = SELECT
   (product_definition, 
    product_definition_relationship);
END_TYPE; 

TYPE derived_property_select = SELECT
   (action_property, 
    property_definition, 
    resource_property);
END_TYPE; 

TYPE shape_definition = SELECT
   (product_definition_shape, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY characterized_object_relationship;
  name : label;
  description : OPTIONAL text;
  relating_object : characterized_object;
  related_object : characterized_object;
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['CATALOG_DATA_INFORMATION_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'CATALOG_DATA_INFORMATION_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

FUNCTION acyclic_characterized_object_relationship
 (relation : characterized_object_relationship; relatives : SET[1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_general_property_relationship
 (relation : general_property_relationship; relatives : SET[1:?] OF general_property; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_shape_aspect_relationship
 (relation : shape_aspect_relationship; relatives : SET[1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_shape_aspects
 (c_def_instance : characterized_definition) : SET OF shape_aspect; 
  LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'CATALOG_DATA_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION') | 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\product_property_representation_schema\product_property_representation_schema.exp
   ------------------------------------------------------------
*)


TYPE represented_definition = SELECT
   (general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY item_identified_representation_usage;
  name : label;
  description : OPTIONAL text;
  definition : represented_definition;
  used_representation : representation;
  identified_item : representation_item;
WHERE
  WR1: SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
  WR2: 'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;

FUNCTION relatives_of_product_definitions
 (definition_set : SET OF product_definition; relation_subtype : STRING) : SET OF product_definition; 
FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
END_FUNCTION; 

FUNCTION relatives_of_shape_representations
 (shape_representation_set : SET OF shape_representation) : SET OF shape_representation; 
 FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_1')) | 'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));      
END_FUNCTION; 

FUNCTION get_property_definition_representations
 (c_def_instance : characterized_definition) : SET OF property_definition_representation; 
LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'CATALOG_DATA_INFORMATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'CATALOG_DATA_INFORMATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\product_structure_schema\product_structure_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n529.exp *)


ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
                       specified_higher_usage_occurrence,
                       promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'CATALOG_DATA_INFORMATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['CATALOG_DATA_INFORMATION_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'CATALOG_DATA_INFORMATION_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\qualifications_schema\qualifications_schema.exp
   ------------------------------------------------------------
*)


ENTITY qualification;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification : qualification;
  related_qualification : qualification;
END_ENTITY;

ENTITY qualification_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification_type : qualification_type;
  related_qualification_type : qualification_type;
END_ENTITY;

FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'CATALOG_DATA_INFORMATION_MIM_LF.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\qualified_measure_schema\qualified_measure_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n257.exp *)


TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'CATALOG_DATA_INFORMATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'CATALOG_DATA_INFORMATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\representation_schema\representation_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n458.exp *)


TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF (SELF\representation.context_of_items );
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_MIM_LF.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('CATALOG_DATA_INFORMATION_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'CATALOG_DATA_INFORMATION_MIM_LF.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);
END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('CATALOG_DATA_INFORMATION_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'CATALOG_DATA_INFORMATION_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\security_classification_schema\security_classification_schema.exp
   ------------------------------------------------------------
*)


ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\shape_aspect_definition_schema\shape_aspect_definition_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n548.exp *)


TYPE limit_condition = ENUMERATION OF
  (maximum_material_condition,
   least_material_condition,
   regardless_of_feature_size);
END_TYPE;

ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification               :identifier;
INVERSE
  established_by_relationships : SET [1:?] OF shape_aspect_relationship
                                 FOR related_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\datum.established_by_relationships |
       SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* 
       ['CATALOG_DATA_INFORMATION_MIM_LF.DATUM_FEATURE', 
       'CATALOG_DATA_INFORMATION_MIM_LF.DATUM_TARGET']) <> 1))=0;
END_ENTITY;

ENTITY datum_feature
   SUBTYPE OF (shape_aspect);
INVERSE 
   feature_basis_relationship : shape_aspect_relationship
                              FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.'+
       'RELATING_SHAPE_ASPECT'))
       | NOT ('CATALOG_DATA_INFORMATION_MIM_LF.DATUM' IN TYPEOF
       (sar\shape_aspect_relationship.related_shape_aspect))))=0;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id             : identifier; 
INVERSE
  target_basis_relationship : shape_aspect_relationship FOR
                              relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'CATALOG_DATA_INFORMATION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.' +
       'RELATING_SHAPE_ASPECT'))
      | NOT ('CATALOG_DATA_INFORMATION_MIM_LF.DATUM' IN TYPEOF 
      (sar\shape_aspect_relationship.related_shape_aspect))))=0;
   WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_reference;
  precedence       : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;

ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;

ENTITY composite_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET [2:?] OF shape_aspect_relationship
                            FOR relating_shape_aspect;
END_ENTITY;

ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (apex,
                       centre_of_symmetry,
                       geometric_alignment,
                       geometric_intersection,
                       parallel_offset,
                       perpendicular_to,
                       extension,
                       tangent))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET [1:?] OF
          shape_aspect_relationship FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (dr <*
          SELF\derived_shape_aspect.deriving_relationships |
          NOT ('CATALOG_DATA_INFORMATION_MIM_LF.' +
               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'
          IN TYPEOF (dr)))) = 0;
END_ENTITY;

ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY centre_of_symmetry 
   SUBTYPE OF (derived_shape_aspect);
WHERE
    WR1: SIZEOF
        (QUERY(sadr<*SELF\derived_shape_aspect.deriving_relationships|
    NOT('CATALOG_DATA_INFORMATION_MIM_LF.SYMMETRIC_SHAPE_ASPECT'
     IN TYPEOF
     (sadr\shape_aspect_relationship.related_shape_aspect))))=0; 
END_ENTITY;

ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset               : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY shape_aspect_deriving_relationship
       SUBTYPE OF (shape_aspect_relationship);
     WHERE
       WR1: 'CATALOG_DATA_INFORMATION_MIM_LF.DERIVED_SHAPE_ASPECT' IN
TYPEOF
            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
     END_ENTITY;

ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET [1:?] OF shape_aspect_relationship
                        FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\symmetric_shape_aspect.basis_relationships |
       'CATALOG_DATA_INFORMATION_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF 
       (x\shape_aspect_relationship.related_shape_aspect)))>=1;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\shape_dimension_schema\shape_dimension_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n548.exp *)


TYPE angle_relator = ENUMERATION OF
  (equal,
   large,
   small);
END_TYPE;

TYPE dimensional_characteristic = SELECT (dimensional_location,
                                          dimensional_size);
END_TYPE;

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension      : dimensional_characteristic; 
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (angular_location,
                       dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (angular_size,
                       dimensional_size_with_path));
  applies_to : shape_aspect;
  name       : label;
WHERE
  WR1: applies_to.product_definitional = TRUE;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY shape_dimension_representation
                SUBTYPE OF (shape_representation);
  WHERE
   WR1: SIZEOF (QUERY (temp <* SELF\representation.items | 
    NOT ('CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF (temp)))) = 0;
   WR2: SIZEOF (SELF\representation.items) <= 3;
   WR3: SIZEOF (QUERY (pos_mri <* QUERY (real_mri <*
        SELF\representation.items | 'REAL' IN TYPEOF
        (real_mri\measure_with_unit.value_component) ) |        
     NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\shape_tolerance_schema\shape_tolerance_schema.exp
   ------------------------------------------------------------
*)


(* Genenerated from: ../../irs/wg12n548.exp *)


TYPE tolerance_method_definition = SELECT
  (tolerance_value,
   limits_and_fits);
END_TYPE;

TYPE  shape_tolerance_select = SELECT
     (geometric_tolerance,
      plus_minus_tolerance);
END_TYPE;

ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location; 
  related_element   : tolerance_zone_definition;
END_ENTITY;

ENTITY geometric_tolerance;
  name                    : label;
  description             : text;
  magnitude               : measure_with_unit; 
  toleranced_shape_aspect : shape_aspect; 
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (magnitude\measure_with_unit.value_component)) AND
       (magnitude\measure_with_unit.value_component >= 0.0);
END_ENTITY;

ENTITY geometric_tolerance_relationship;
                                   name                         :label;
                                   description                  :text;
                                   relating_geometric_tolerance : geometric_tolerance; 
                                   related_geometric_tolerance  : geometric_tolerance; 
END_ENTITY;

ENTITY geometric_tolerance_with_datum_reference
   SUBTYPE OF (geometric_tolerance);
   datum_system : SET [1:?] OF  datum_reference;
END_ENTITY;

ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (unit_size\measure_with_unit.value_component)) AND
       (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;

ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;

ENTITY projected_zone_definition 
  SUBTYPE OF (tolerance_zone_definition);  
  projection_end   : shape_aspect; 
  projected_length : measure_with_unit;
WHERE 
  WR1: ('NUMBER' IN TYPEOF
       (projected_length\measure_with_unit.value_component)) AND
       (projected_length\measure_with_unit.value_component > 0.0);
  WR2: (derive_dimensional_exponents
       (projected_length\measure_with_unit.unit_component)=
        dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;

ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition); 
  orientation  : runout_zone_orientation;
END_ENTITY;

ENTITY runout_zone_orientation;
  angle : measure_with_unit;
END_ENTITY;

ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation); 
  orientation_defining_relationship: shape_aspect_relationship;
END_ENTITY;

ENTITY statistical_distribution_for_tolerance
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT ('CATALOG_DATA_INFORMATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (item)))) = 0;
END_ENTITY;

ENTITY tolerance_with_statistical_distribution;
   associated_tolerance : shape_tolerance_select;
   tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY;

ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET [1:?] OF geometric_tolerance; 
  form               : tolerance_zone_form;
END_ENTITY;

ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;

ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (projected_zone_definition,
                       runout_zone_definition));
  zone : tolerance_zone;
  boundaries: SET [1:?] OF shape_aspect;
END_ENTITY;

ENTITY limits_and_fits;
  form_variance   : label;
  zone_variance   : label;
  grade           : label;
  source          : text;
END_ENTITY;

ENTITY  plus_minus_tolerance;
  range                : tolerance_method_definition; 
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;

ENTITY tolerance_value; 
   lower_bound : measure_with_unit; 
   upper_bound : measure_with_unit;
WHERE 
   WR1: upper_bound\measure_with_unit.value_component >
        lower_bound\measure_with_unit.value_component;  
   WR2: upper_bound\measure_with_unit.unit_component =
        lower_bound\measure_with_unit.unit_component;
END_ENTITY;


(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\support_resource_schema\support_resource_schema.exp
   ------------------------------------------------------------
*)


TYPE identifier = STRING;
END_TYPE; 

TYPE label = STRING;
END_TYPE; 

TYPE text = STRING;
END_TYPE; 

FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
END_FUNCTION; 

FUNCTION type_check_function
 (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION; 



(*
   ------------------------------------------------------------
C:\Stepmod_client\stepmod\data\resources\topology_schema\topology_schema.exp
   ------------------------------------------------------------
*)


(* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)

(*
CONSTANT
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        
 END_CONSTANT;
*)


 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;

 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;

  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;

 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;

 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;

 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;

 ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
   parent_face_set   :  connected_face_set;
 END_ENTITY;

 ENTITY edge
   SUPERTYPE OF(ONEOF(edge_curve, oriented_edge, subedge))
   SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;

 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;

 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;

 ENTITY face
   SUPERTYPE OF(ONEOF(face_surface, subface, oriented_face))
   SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'CATALOG_DATA_INFORMATION_MIM_LF.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;

 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;

    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;

 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;

 ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY open_path
   SUBTYPE OF (path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                       (SELF\path.edge_list[ne].edge_element.edge_end);
 END_ENTITY;

 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;

 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;

 ENTITY path
   SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;

 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY seam_edge
   SUBTYPE OF (oriented_edge);
     pcurve_reference : pcurve ; 
 WHERE
    WR1 : ( 'CATALOG_DATA_INFORMATION_MIM_LF.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
                ('CATALOG_DATA_INFORMATION_MIM_LF.SEAM_CURVE' IN TYPEOF
                       (edge_element\edge_curve.edge_geometry)) ;
   WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry ;
 END_ENTITY;

 ENTITY subedge
   SUBTYPE OF (edge);
   parent_edge   :  edge;
 END_ENTITY;

 ENTITY subface
   SUBTYPE OF (face);
   parent_face   :  face;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
 END_ENTITY;

 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 END_ENTITY;

 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;

 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;

 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;

 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'CATALOG_DATA_INFORMATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'CATALOG_DATA_INFORMATION_MIM_LF.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'CATALOG_DATA_INFORMATION_MIM_LF.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
   LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('CATALOG_DATA_INFORMATION_MIM_LF.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);
 END_FUNCTION;

 FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'CATALOG_DATA_INFORMATION_MIM_LF.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'CATALOG_DATA_INFORMATION_MIM_LF.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('CATALOG_DATA_INFORMATION_MIM_LF.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('CATALOG_DATA_INFORMATION_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('CATALOG_DATA_INFORMATION_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('CATALOG_DATA_INFORMATION_MIM_LF.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('CATALOG_DATA_INFORMATION_MIM_LF.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('CATALOG_DATA_INFORMATION_MIM_LF.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_MIM_LF.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_MIM_LF.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('CATALOG_DATA_INFORMATION_MIM_LF.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_MIM_LF.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point; 
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'CATALOG_DATA_INFORMATION_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 END_SCHEMA;