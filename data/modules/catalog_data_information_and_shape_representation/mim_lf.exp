(*
 $Id: mim_lf.exp,v 1.16 2005/03/09 01:07:43 sonofre Exp $
 ISO TC184/SC4/WG3 N1312 - ISO/TS 10303-1352 Catalog data information and shape representation - EXPRESS MIM Long form
*)

SCHEMA Catalog_data_information_and_shape_representation_mim_LF;


(*
USE FROM Advanced_boundary_representation_mim;

USE FROM Constructive_solid_geometry_3d_mim;

USE FROM Edge_based_wireframe_mim;

USE FROM Faceted_boundary_representation_mim;

USE FROM Geometric_tolerance_mim;

USE FROM Geometric_validation_property_representation_mim;

USE FROM Geometrically_bounded_surface_mim;

USE FROM Geometrically_bounded_wireframe_mim;

USE FROM Manifold_surface_mim;

USE FROM representation_schema(founded_item);

USE FROM Shell_based_wireframe_mim;

USE FROM Surface_conditions_mim;

USE FROM topology_schema(topological_representation_item);

USE FROM Wireframe_2d_mim;

USE FROM Catalog_data_information_mim;
*)

CONSTANT

(* Implicit interfaced from: geometry_schema *)
  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();

(* Implicit interfaced from: topology_schema *)
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        

END_CONSTANT;
(* USED FROM (Activity_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE action_items = SELECT (
   configuration_effectivity,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;

(* USED FROM (Work_request_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE action_request_item = SELECT (
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   property_definition);
END_TYPE;


(* Implicit interfaced from: date_time_schema *)
TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE; 

(* Pruned unused type: aliasable_item  *)

(* USED FROM (measure_schema); *)
TYPE amount_of_substance_measure = REAL;
END_TYPE; 
(* USED FROM (shape_dimension_schema); *)
TYPE angle_relator = ENUMERATION OF
  (equal,
   large,
   small);
END_TYPE;
(* USED FROM (Approval_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE approval_item = SELECT (
   action,
   alternate_product_relationship,
   applied_action_assignment,
   applied_classification_assignment,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configured_effectivity_assignment,
   contract,
   document_file,
   general_property,
   material_designation,
   organizational_project,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: approval_item_236cc1  *)

(* USED FROM (measure_schema); *)
TYPE area_measure = REAL;
END_TYPE; 
(* USED FROM (Multi_linguism_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE attribute_language_item = SELECT (
   alternate_product_relationship,
   application_context,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   assembly_component_usage_substitute,
   attribute_value_assignment,
   certification,
   certification_type,
   configuration_design,
   configuration_item,
   contract,
   date_role,
   date_time_role,
   descriptive_representation_item,
   document_relationship,
   document_usage_role,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   external_source,
   general_property,
   general_property_relationship,
   geometric_representation_item,
   geometric_tolerance,
   group,
   group_relationship,
   identification_role,
   mapped_item,
   multi_language_attribute_assignment,
   object_role,
   organization_relationship,
   organization_role,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   person_and_organization_role,
   product,
   product_category,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   representation_relationship,
   shape_aspect,
   shape_aspect_relationship,
   time_interval_role,
   topological_representation_item,
   uncertainty_measure_with_unit,
   uncertainty_qualifier);
END_TYPE;


(* Pruned unused type: attribute_language_item_236cc1  *)


(* Pruned unused type: attribute_language_item_236cc2  *)


(* Implicit interfaced from: management_resources_schema *)
TYPE attribute_type = SELECT
   (label, 
    text);
END_TYPE; 

(* Implicit interfaced from: geometry_schema *)
 TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
 END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
 END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE b_spline_surface_form = ENUMERATION OF
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
 END_TYPE;

(* Pruned unused type: bc_external_identification_item  *)

(* USED FROM (geometric_model_schema); *)
(* This SELECT set has been pruned. *)
TYPE boolean_operand = SELECT (
   solid_model,
   half_space_solid,
   csg_primitive,
   boolean_result);
END_TYPE;

(* USED FROM (geometric_model_schema); *)
 TYPE boolean_operator = ENUMERATION OF 
   (union, 
    intersection, 
    difference);
 END_TYPE;
(* USED FROM (Product_class_mim); *)
TYPE category_usage_item = SELECT (product_class);
END_TYPE;
(* USED FROM (measure_schema); *)
TYPE celsius_temperature_measure = REAL;
END_TYPE; 
(* USED FROM (Certification_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE certification_item = SELECT (
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship);
END_TYPE;


(* Pruned unused type: certification_item_236cc1  *)

(* USED FROM (process_property_schema); *)
(* This SELECT set has been pruned. *)
TYPE characterized_action_definition = SELECT (
   action,
   action_method,
   action_relationship);
END_TYPE;

(* USED FROM (product_property_definition_schema); *)
TYPE characterized_definition = SELECT
   (characterized_object, 
    characterized_product_definition, 
    shape_definition);
END_TYPE; 

(* Implicit interfaced from: material_property_definition_schema *)
(* This SELECT set has been pruned. *)
TYPE characterized_material_property = SELECT (
   material_property_representation);
END_TYPE;

(* USED FROM (product_property_definition_schema); *)
TYPE characterized_product_definition = SELECT
   (product_definition, 
    product_definition_relationship);
END_TYPE; 

(* Pruned unused type: class_system_item  *)

(* USED FROM (Specification_control_mim); *)
TYPE class_usage_effectivity_context_item = SELECT
  (product_definition);
END_TYPE;

(* Pruned unused type: classification_classification_item  *)


(* Pruned unused type: classification_identification_item  *)

(* USED FROM (Classification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE classification_item = SELECT (
   action,
   action_directive,
   action_method,
   action_property,
   action_relationship,
   action_request_solution,
   action_request_status,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   assembly_component_usage_substitute,
   calendar_date,
   certification,
   characterized_class,
   class,
   configuration_item,
   context_dependent_unit,
   contract,
   conversion_based_unit,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   document_type,
   effectivity,
   event_occurrence,
   executed_action,
   general_property,
   general_property_relationship,
   group,
   identification_assignment,
   language,
   material_designation,
   measure_representation_item,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization_address,
   planar_extent,
   product,
   product_category,
   product_concept,
   product_concept_feature_category,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_context,
   representation_item,
   security_classification,
   shape_aspect,
   uncertainty_measure_with_unit,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: classification_item_236cc1  *)


(* Pruned unused type: classification_item_extended  *)


(* Pruned unused type: classified_item  *)


(* Pruned unused type: complete_membership_select  *)

(* USED FROM (representation_schema); *)
TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

(* Implicit interfaced from: configuration_management_schema *)
TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;
(* USED FROM (Specification_based_configuration_mim); *)
TYPE configured_effectivity_context_item = SELECT (product_concept_feature_association);
END_TYPE;
(* USED FROM (Specification_based_configuration_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
TYPE configured_effectivity_item = SELECT (
   product_definition);
END_TYPE;

(* USED FROM (measure_schema); *)
TYPE context_dependent_measure = REAL;
END_TYPE; 
(* USED FROM (Contract_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE contract_item = SELECT (
   product_definition_formation);
END_TYPE;


(* Pruned unused type: contract_item_236cc1  *)

(* USED FROM (measure_schema); *)
TYPE count_measure = NUMBER;
END_TYPE; 
(* USED FROM (geometric_model_schema); *)
(* This SELECT set has been pruned. *)
TYPE csg_primitive = SELECT (
   sphere,
   block,
   right_angular_wedge,
   torus,
   right_circular_cone,
   right_circular_cylinder);
END_TYPE;

(* USED FROM (geometric_model_schema); *)
 TYPE csg_select = SELECT
   (boolean_result,
    csg_primitive);
 END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE curve_on_surface = SELECT
   (pcurve, 
    surface_curve, 
    composite_curve_on_surface);
 END_TYPE;

(* Pruned unused type: cwa_identification_item  *)


(* Pruned unused type: cwa_versionable_item  *)

(* USED FROM (Date_time_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE date_and_time_item = SELECT (
   action,
   alternate_product_relationship,
   applied_action_assignment,
   applied_classification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval_person_organization,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   executed_action,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   security_classification,
   shape_representation,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: date_and_time_item_236cc1  *)


(* Pruned unused type: date_and_time_item_approval  *)

(* USED FROM (Date_time_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE date_item = SELECT (
   action,
   alternate_product_relationship,
   applied_action_assignment,
   applied_classification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval_person_organization,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   security_classification,
   shape_representation,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: date_item_236cc1  *)


(* Pruned unused type: date_item_approval  *)


(* Chained implicit interfaced from: date_time_schema *)
TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE; 

(* Chained implicit interfaced from: date_time_schema *)
TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE; 

(* Implicit interfaced from: date_time_schema *)
TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; 
(* USED FROM (product_property_definition_schema); *)
(* This SELECT set has been pruned. *)
TYPE derived_property_select = SELECT (
   action_property,
   property_definition);
END_TYPE;

(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE description_attribute_select = SELECT (
   action_request_solution,
   application_context,
   approval_role,
   configuration_design,
   context_dependent_shape_representation,
   date_role,
   date_time_role,
   effectivity,
   external_source,
   organization_role,
   person_and_organization,
   person_and_organization_role,
   property_definition_representation,
   representation);
END_TYPE;

(* USED FROM (measure_schema); *)
TYPE descriptive_measure = STRING;
END_TYPE; 

(* Implicit interfaced from: geometry_schema *)
TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

(* Pruned unused type: dimension_identification_item  *)


(* Pruned unused type: dimension_tolerance_document_reference_item  *)

(* USED FROM (shape_dimension_schema); *)
TYPE dimensional_characteristic = SELECT (dimensional_location,
                                          dimensional_size);
END_TYPE;

(* Pruned unused type: dm_aliasable_item  *)


(* Pruned unused type: dm_approval_item  *)


(* Pruned unused type: dm_attribute_language_item  *)


(* Pruned unused type: dm_contract_item  *)


(* Pruned unused type: dm_date_and_time_item  *)


(* Pruned unused type: dm_date_item  *)


(* Pruned unused type: dm_identification_item  *)


(* Pruned unused type: dm_multi_language_attribute_item  *)


(* Pruned unused type: dm_organization_item  *)


(* Pruned unused type: dm_person_and_organization_item  *)


(* Pruned unused type: dm_security_classification_item  *)


(* Pruned unused type: document_location_select  *)

(* USED FROM (Document_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE document_reference_item = SELECT (
   action_method,
   approval,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_item,
   contract,
   descriptive_representation_item,
   dimensional_size,
   executed_action,
   externally_defined_dimension_definition,
   general_property,
   material_designation,
   organization,
   organizational_project,
   person,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   shape_aspect,
   shape_aspect_relationship,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: document_reference_item_236cc1  *)

(* USED FROM (Effectivity_application_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE effectivity_item = SELECT (
   assembly_component_usage_substitute,
   class_system,
   configuration_design,
   configuration_item,
   configured_effectivity_assignment,
   document_file,
   general_property,
   material_designation,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_aspect,
   shape_representation);
END_TYPE;


(* Pruned unused type: effectivity_item_236cc1  *)


(* Pruned unused type: effectivity_item_for_replacement  *)


(* Pruned unused type: effectivity_specification_for_replacement  *)

(* USED FROM (measure_schema); *)
TYPE electric_current_measure = REAL;
END_TYPE; 

(* Pruned unused type: event_occurrence_date_and_time_item  *)


(* Pruned unused type: event_occurrence_date_item  *)

(* USED FROM (Event_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE event_occurrence_item = SELECT (
   alternate_product_relationship,
   applied_classification_assignment,
   applied_person_and_organization_assignment,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   shape_representation);
END_TYPE;


(* Pruned unused type: event_occurrence_item_236cc1  *)


(* Pruned unused type: external_class_name_item  *)


(* Pruned unused type: external_identification_for_plib_property  *)

(* USED FROM (External_item_identification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE external_identification_item = SELECT (
   document_file,
   externally_defined_class,
   externally_defined_general_property,
   product_definition,
   trimmed_curve);
END_TYPE;


(* Pruned unused type: external_identification_item_236cc1  *)


(* Pruned unused type: externally_versioned_item  *)


(* Pruned unused type: file_identification_item  *)


(* Pruned unused type: file_location_select  *)


(* Pruned unused type: file_version_item  *)


(* Implicit interfaced from: representation_schema *)
TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

(* Implicit interfaced from: geometric_model_schema *)
 TYPE geometric_set_select = SELECT
   (point,
    curve,
    surface);
 END_TYPE;
(* USED FROM (Group_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
(* NOTE: Empty SELECT set! *)
(* TYPE groupable_item = SELECT (); END_TYPE; *) 


(* Implicit interfaced from: date_time_schema *)
TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; 
(* USED FROM (basic_attribute_schema); *)
TYPE id_attribute_select = SELECT
   (action, 
    address, 
    application_context, 
    group, 
    organizational_project, 
    product_category, 
    property_definition, 
    representation, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

(* Pruned unused type: id_for_product_identification  *)

(* USED FROM (Identification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE identification_item = SELECT (
   applied_identification_assignment,
   approval_status,
   characterized_class,
   class,
   class_system,
   configuration_item,
   contract,
   dimensional_size,
   document_file,
   document_type,
   effectivity,
   general_property,
   measure_representation_item,
   organization,
   person_and_organization,
   product,
   product_as_individual,
   product_as_individual_version,
   product_as_individual_view,
   product_concept,
   product_concept_feature,
   product_concept_feature_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_identification,
   property_definition,
   security_classification_level,
   shape_aspect_relationship,
   shape_representation);
END_TYPE;


(* Pruned unused type: identification_item_236cc1  *)

(* USED FROM (support_resource_schema); *)
TYPE identifier = STRING;
END_TYPE; 

(* Pruned unused type: idrm_marked_item  *)

(* USED FROM (Specification_control_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
TYPE instance_usage_context_select = SELECT (
   product_definition_relationship,
   product_definition_usage);
END_TYPE;


(* Implicit interfaced from: geometry_schema *)
 TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
 END_TYPE;
(* USED FROM (support_resource_schema); *)
TYPE label = STRING;
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE length_measure = REAL;
END_TYPE; 

(* Implicit interfaced from: shape_aspect_definition_schema *)
TYPE limit_condition = ENUMERATION OF
  (maximum_material_condition,
   least_material_condition,
   regardless_of_feature_size);
END_TYPE;

(* Implicit interfaced from: topology_schema *)
 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;
(* USED FROM (representation_schema); *)
TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;
(* USED FROM (measure_schema); *)
TYPE luminous_intensity_measure = REAL;
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE mass_measure = REAL;
END_TYPE; 

(* Pruned unused type: mce_organization_item  *)

(* USED FROM (measure_schema); *)
TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE; 

(* Implicit interfaced from: date_time_schema *)
TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; 

(* Implicit interfaced from: date_time_schema *)
TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; 

(* Pruned unused type: mri_aliasable_item  *)


(* Pruned unused type: mri_approval_item  *)


(* Pruned unused type: mri_attribute_language_item  *)


(* Pruned unused type: mri_date_and_time_item  *)


(* Pruned unused type: mri_date_item  *)


(* Pruned unused type: mri_identification_item  *)


(* Pruned unused type: mri_multi_language_attribute_item  *)


(* Pruned unused type: mri_organization_item  *)


(* Pruned unused type: mri_person_and_organization_item  *)

(* USED FROM (Multi_linguism_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE multi_language_attribute_item = SELECT (
   alternate_product_relationship,
   application_context,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   certification_type,
   configuration_design,
   configuration_item,
   contract,
   date_role,
   date_time_role,
   descriptive_representation_item,
   document_relationship,
   document_usage_role,
   effectivity,
   effectivity_relationship,
   event_occurrence,
   external_source,
   general_property,
   general_property_relationship,
   geometric_representation_item,
   geometric_tolerance,
   group,
   group_relationship,
   identification_role,
   mapped_item,
   object_role,
   organization_relationship,
   organization_role,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   person_and_organization_role,
   product,
   product_category,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_relationship,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   product_related_product_category,
   property_definition,
   representation,
   representation_relationship,
   shape_aspect,
   shape_aspect_relationship,
   time_interval_role,
   topological_representation_item,
   uncertainty_measure_with_unit,
   uncertainty_qualifier);
END_TYPE;


(* Pruned unused type: multi_language_attribute_item_236cc1  *)


(* Pruned unused type: multi_language_attribute_item_236cc2  *)

(* USED FROM (basic_attribute_schema); *)
TYPE name_attribute_select = SELECT
   (action_request_solution, 
    address, 
    configuration_design, 
    context_dependent_shape_representation, 
    derived_unit, 
    effectivity, 
    person_and_organization, 
    product_definition, 
    product_definition_substitute, 
    property_definition_representation);
END_TYPE; 
(* USED FROM (Name_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE name_item = SELECT (
   assembly_component_usage,
   external_class_library);
END_TYPE;

(* USED FROM (measure_schema); *)
TYPE numeric_measure = NUMBER;
END_TYPE; 
(* USED FROM (Person_organization_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE organization_item = SELECT (
   action,
   alternate_product_relationship,
   applied_action_assignment,
   applied_classification_assignment,
   applied_identification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   effectivity,
   event_occurrence,
   executed_action,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   security_classification,
   shape_representation,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: organization_item_236cc1  *)


(* Pruned unused type: organization_item_solution  *)

(* USED FROM (measure_schema); *)
TYPE parameter_value = REAL;
END_TYPE; 

(* Implicit interfaced from: geometry_schema *)
 TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
 END_TYPE;

(* Pruned unused type: pdm_action_items  *)


(* Pruned unused type: pdm_action_request_item  *)


(* Pruned unused type: pdm_approval_item  *)


(* Pruned unused type: pdm_attribute_language_item  *)


(* Pruned unused type: pdm_certification_item  *)


(* Pruned unused type: pdm_classification_item  *)


(* Pruned unused type: pdm_date_and_time_item  *)


(* Pruned unused type: pdm_date_item  *)


(* Pruned unused type: pdm_document_reference_item  *)


(* Pruned unused type: pdm_effectivity_item  *)


(* Pruned unused type: pdm_event_occurrence_item  *)


(* Pruned unused type: pdm_external_class_name_item  *)


(* Pruned unused type: pdm_identification_item  *)


(* Pruned unused type: pdm_multi_language_attribute_item  *)


(* Pruned unused type: pdm_organization_item  *)


(* Pruned unused type: pdm_person_and_organization_item  *)


(* Pruned unused type: pdm_project_item  *)


(* Pruned unused type: pdm_security_classification_item  *)


(* Pruned unused type: pdm_time_interval_item  *)

(* USED FROM (Person_organization_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE person_and_organization_item = SELECT (
   action,
   alternate_product_relationship,
   applied_action_assignment,
   applied_classification_assignment,
   applied_identification_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval,
   approval_status,
   assembly_component_usage_substitute,
   certification,
   class,
   class_system,
   configuration_design,
   configuration_effectivity,
   configuration_item,
   configured_effectivity_assignment,
   contract,
   document_file,
   event_occurrence,
   executed_action,
   general_property,
   material_designation,
   organization_relationship,
   organizational_project,
   person_and_organization,
   product,
   product_concept,
   product_concept_feature,
   product_concept_feature_association,
   product_concept_feature_category,
   product_concept_feature_category_usage,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_definition_substitute,
   property_definition,
   security_classification,
   shape_representation,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: person_and_organization_item_236cc1  *)


(* Chained implicit interfaced from: person_organization_schema *)
TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE plane_angle_measure = REAL;
END_TYPE; 

(* Pruned unused type: plib_class_identification_item  *)


(* Pruned unused type: plib_class_organization_item  *)

(* USED FROM (measure_schema); *)
TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

(* Implicit interfaced from: geometry_schema *)
 TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1, 
    pcurve_s2);
 END_TYPE;

(* Pruned unused type: product_as_individual_identification_item  *)

(* USED FROM (Part_occurrence_mim); *)
TYPE product_definition_or_assembly_relationship = SELECT (assembly_component_usage, product_definition);
END_TYPE;
(* USED FROM (Product_breakdown_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
TYPE product_definition_or_breakdown_element_usage = SELECT (
   breakdown_element_usage,
   product_definition);
END_TYPE;

(* USED FROM (Product_breakdown_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
TYPE product_definition_or_product_definition_relationship = SELECT (
   product_definition,
   product_definition_usage);
END_TYPE;


(* Implicit interfaced from: document_schema *)
TYPE product_or_formation_or_definition = SELECT
   (product, 
    product_definition_formation, 
    product_definition);
END_TYPE; 

(* Pruned unused type: project_as_date_and_time_item  *)


(* Pruned unused type: project_as_date_item  *)


(* Pruned unused type: project_event_occurrence_item  *)

(* USED FROM (Project_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE project_item = SELECT (
   executed_action,
   product_concept);
END_TYPE;

(* USED FROM (measure_schema); *)
TYPE ratio_measure = REAL;
END_TYPE; 

(* Pruned unused type: representation_identification_item  *)


(* Pruned unused type: representation_version_item  *)


(* Implicit interfaced from: product_property_representation_schema *)
TYPE represented_definition = SELECT
   (general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

(* Pruned unused type: requirement_identification_and_version_mri_identification_item  *)


(* Implicit interfaced from: topology_schema *)
 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

(* Implicit interfaced from: topology_schema *)
 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;
(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE role_select = SELECT (
   action_assignment,
   action_request_assignment,
   approval_assignment,
   approval_date_time,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE;


(* Implicit interfaced from: date_time_schema *)
TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; 
(* USED FROM (Security_classification_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE security_classification_item = SELECT (
   assembly_component_usage,
   document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;


(* Implicit interfaced from: topology_schema *)
  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;
(* USED FROM (representation_schema); *)
TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;
(* USED FROM (product_property_definition_schema); *)
TYPE shape_definition = SELECT
   (product_definition_shape, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

(* Pruned unused type: shape_tolerance_select  *)


(* Implicit interfaced from: topology_schema *)
 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;
(* USED FROM (measure_schema); *)
TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE solid_angle_measure = REAL;
END_TYPE; 

(* Implicit interfaced from: product_definition_schema *)
TYPE source = ENUMERATION OF 
   (made,
    bought,
    not_known);
END_TYPE; 

(* Implicit interfaced from: external_reference_schema *)
(* This SELECT set has been pruned. *)
TYPE source_item = SELECT (
   identifier);
END_TYPE;


(* Pruned unused type: spr_document_reference_item  *)


(* Pruned unused type: spr_organization_item  *)


(* Pruned unused type: spr_person_and_organization_item  *)


(* Pruned unused type: supported_item  *)


(* Pruned unused type: surface_boundary  *)


(* Pruned unused type: surface_model  *)

(* USED FROM (support_resource_schema); *)
TYPE text = STRING;
END_TYPE; 
(* USED FROM (measure_schema); *)
TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; 
(* USED FROM (Time_interval_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE time_interval_item = SELECT (
   action);
END_TYPE;

(* USED FROM (measure_schema); *)
TYPE time_measure = REAL;
END_TYPE; 
(* USED FROM (shape_tolerance_schema); *)
TYPE tolerance_method_definition = SELECT
  (tolerance_value,
   limits_and_fits);
END_TYPE;
(* USED FROM (representation_schema); *)
TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
 END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
 END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;
(* USED FROM (measure_schema); *)
TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE; 
(* USED FROM (qualified_measure_schema); *)
TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

(* Implicit interfaced from: geometry_schema *)
 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

(* Pruned unused type: version_for_plib_property  *)


(* Pruned unused type: version_for_product_identification  *)


(* Pruned unused type: versionable_item  *)

(* USED FROM (measure_schema); *)
TYPE volume_measure = REAL;
END_TYPE; 

(* Pruned unused type: wireframe_model  *)


(* Implicit interfaced from: date_time_schema *)
TYPE year_number = INTEGER;
END_TYPE; 
(* USED FROM (action_schema); *)
ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY action_assignment
   ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET[1:?] OF versioned_action_request;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;
(* USED FROM (process_property_schema); *)
ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;
(* USED FROM (process_property_representation_schema); *)
ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY action_request_assignment
   ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;
(* USED FROM (aic_advanced_brep); *)
ENTITY advanced_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SOLID_BREP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SOLID_BREP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
(* USED FROM (aic_topologically_bounded_surface); *)
ENTITY advanced_face 
 SUBTYPE OF ( face_surface );
 WHERE 
WR1 : 
SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELEMENTARY_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
WR2 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
WR6 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
WR7 : 
SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
WR10 : (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
 END_ENTITY ;
(* USED FROM (product_structure_schema); *)
ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY angularity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
 END_ENTITY ;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;
(* USED FROM (application_context_schema); *)
ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (application_context_schema); *)
(* Pruned SUPERTYPE *)
ENTITY application_context_element
  SUPERTYPE OF (ONEOF (
              PRODUCT_CONCEPT_CONTEXT,
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;
(* USED FROM (application_context_schema); *)
ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;
(* USED FROM (application_context_schema); *)
ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;
(* USED FROM (Activity_mim); *)
ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;
(* USED FROM (Work_request_mim); *)
ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;
(* USED FROM (Approval_mim); *)
ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET[1:?] OF approval_item;
END_ENTITY;
(* USED FROM (Certification_mim); *)
ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;
(* USED FROM (Classification_assignment_mim); *)
ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;
(* USED FROM (Contract_mim); *)
ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;
(* USED FROM (Date_time_assignment_mim); *)
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
(* USED FROM (Date_time_assignment_mim); *)
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;
(* USED FROM (Effectivity_application_mim); *)
ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;
(* USED FROM (Event_assignment_mim); *)
ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;
(* USED FROM (External_item_identification_assignment_mim); *)
ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;
(* USED FROM (Group_mim); *)
ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;
(* USED FROM (Identification_assignment_mim); *)
ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;
(* USED FROM (Name_assignment_mim); *)
ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;
(* USED FROM (Person_organization_assignment_mim); *)
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;
(* USED FROM (Project_mim); *)
ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;
(* USED FROM (Person_organization_assignment_mim); *)
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;
(* USED FROM (Security_classification_mim); *)
ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;
(* USED FROM (Time_interval_assignment_mim); *)
ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET[0:?] OF time_interval_item;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY approval_assignment
   ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (approval_schema); *)
ENTITY approval_status;
  name : label;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (
              NEXT_ASSEMBLY_USAGE_OCCURRENCE,
              SPECIFIED_HIGHER_USAGE_OCCURRENCE,
              PROMISSORY_USAGE_OCCURRENCE))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY attribute_classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;
(* USED FROM (Multi_linguism_mim); *)
ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; 
(* USED FROM (management_resources_schema); *)
ENTITY attribute_value_assignment
   ABSTRACT SUPERTYPE;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;

(* Implicit interfaced from: management_resources_schema *)
ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF (
              UNIFORM_CURVE,
              B_SPLINE_CURVE_WITH_KNOTS,
              QUASI_UNIFORM_CURVE,
              BEZIER_CURVE)
              ANDOR 
              RATIONAL_B_SPLINE_CURVE)
  SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                         OF cartesian_point 
                                  := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE_WITH_KNOTS,
              UNIFORM_SURFACE,
              QUASI_UNIFORM_SURFACE,
              BEZIER_SURFACE)
              ANDOR 
              RATIONAL_B_SPLINE_SURFACE)
  SUBTYPE OF (bounded_surface);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF cartesian_point;
   surface_form         : b_spline_surface_form;
   u_closed             : LOGICAL;
   v_closed             : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point 
                       := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   knot_spec         : knot_type;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
    WR3: SIZEOF(u_multiplicities) = knot_u_upper;
    WR4: SIZEOF(v_multiplicities) = knot_v_upper;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY block
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
   operator        : boolean_operator;
   first_operand   :  boolean_operand;
   second_operand  :  boolean_operand;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
 WHERE
   WR1: SELF\composite_curve.closed_curve;
 END_ENTITY;

(* Implicit interfaced from: geometry_schema *)
 ENTITY bounded_curve
   SUPERTYPE OF (ONEOF (
              POLYLINE,
              B_SPLINE_CURVE,
              TRIMMED_CURVE,
              BOUNDED_PCURVE,
              BOUNDED_SURFACE_CURVE,
              COMPOSITE_CURVE))
  SUBTYPE OF (curve);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
  WHERE
    WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY;

(* Implicit interfaced from: geometry_schema *)
 ENTITY bounded_surface
   SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE,
              RECTANGULAR_TRIMMED_SURFACE,
              CURVE_BOUNDED_SURFACE,
              RECTANGULAR_COMPOSITE_SURFACE))
  SUBTYPE OF (surface);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
 WHERE
   WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY box_domain
   SUBTYPE OF (founded_item);
   corner  : cartesian_point;
   xlength : positive_length_measure;
   ylength : positive_length_measure;
   zlength : positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOXED_HALF_SPACE'
                    IN TYPEOF(item)))) = 0;
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY boxed_half_space
   SUBTYPE OF(half_space_solid);
   enclosure : box_domain;
 END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY breakdown_context
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY breakdown_element_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items : SET[1:1] OF product_definition_or_breakdown_element_usage;
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY breakdown_element_realization
  SUBTYPE OF (characterized_object, product_definition_element_relationship);
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY breakdown_element_usage
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY breakdown_of
  SUBTYPE OF (product_definition_relationship);
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
   voids : SET [1:?] OF oriented_closed_shell;
 END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;
(* USED FROM (geometry_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY cartesian_point
   
  SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

(* Implicit interfaced from: geometry_schema *)
 ENTITY cartesian_transformation_operator
   SUPERTYPE OF (ONEOF (
              CARTESIAN_TRANSFORMATION_OPERATOR_2D,
              CARTESIAN_TRANSFORMATION_OPERATOR_3D))
  SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
 DERIVE
   u : LIST[2:2] OF direction := 
       base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
 END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY centre_of_symmetry 
   SUBTYPE OF (derived_shape_aspect);
WHERE
    WR1: SIZEOF
        (QUERY(sadr<*SELF\derived_shape_aspect.deriving_relationships|
    NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SYMMETRIC_SHAPE_ASPECT'
     IN TYPEOF
     (sadr\shape_aspect_relationship.related_shape_aspect))))=0; 
END_ENTITY;
(* USED FROM (certification_schema); *)
ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY certification_assignment
   ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (certification_schema); *)
ENTITY certification_type;
  description : label;
END_ENTITY;
(* USED FROM (Classification_with_attributes_mim); *)
ENTITY characterized_class
SUBTYPE OF (characterized_object, class);
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY characterized_object_relationship;
  name : label;
  description : OPTIONAL text;
  relating_object : characterized_object;
  related_object : characterized_object;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY circular_runout_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
(* USED FROM (classification_schema); *)
ENTITY class
  SUBTYPE OF (group);
END_ENTITY;
(* USED FROM (classification_schema); *)
ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;
(* USED FROM (classification_schema); *)
ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;
(* USED FROM (Classification_with_attributes_mim); *)
ENTITY class_system 
SUBTYPE OF (group); 
END_ENTITY; 
(* USED FROM (Specification_control_mim); *)
ENTITY class_usage_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment); 
items : SET [1:?] OF class_usage_effectivity_context_item; 
WHERE 
WR1: SELF.role.name = 'class usage influence'; 
WR2: SIZEOF( QUERY( i <* SELF.items | NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0; 
WR3: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
  (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
  (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
 (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
   NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0); 
END_ENTITY; 
(* USED FROM (management_resources_schema); *)
ENTITY classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_class : group;
  role : classification_role;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY coaxiality_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY common_datum 
 SUBTYPE OF ( composite_shape_aspect , datum );
 WHERE 
WR1 : 
SIZEOF (SELF.component_relationships) = 2;
WR2 : 
SIZEOF ( 
QUERY ( sar <* SELF.component_relationships| NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0;
 END_ENTITY ;
(* USED FROM (geometry_schema); *)
 ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY composite_curve_on_surface
   SUPERTYPE OF (
              BOUNDARY_CURVE)
  SUBTYPE OF (composite_curve);

 DERIVE
   basis_surface : SET[0:2] OF surface :=
                get_basis_surface(SELF);
 WHERE
   WR1: SIZEOF(basis_surface) > 0;
   WR2: constraints_composite_curve_on_surface(SELF);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY composite_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET [2:?] OF shape_aspect_relationship
                            FOR relating_shape_aspect;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY concentricity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) = 1;
 END_ENTITY ;
(* USED FROM (product_concept_schema); *)
ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

(* Implicit interfaced from: product_concept_schema *)
ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

(* Implicit interfaced from: product_concept_schema *)
ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;
(* USED FROM (product_concept_schema); *)
ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;
(* USED FROM (configuration_management_schema); *)
ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;
(* USED FROM (configuration_management_schema); *)
ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (configuration_management_schema); *)
ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;
(* USED FROM (configuration_management_schema); *)
ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;
(* USED FROM (Specification_based_configuration_mim); *)
ENTITY configured_effectivity_assignment 
	SUBTYPE OF (effectivity_assignment);
	  items : SET [1:?] OF configured_effectivity_item; 
	WHERE 
	WR1: (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
	AND (SELF.assigned_effectivity.id = 'configuration validity'); 
	WR2: SIZEOF(SELF.items) = 1; 
	WR3: SIZEOF( QUERY( i <* SELF.items | NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) 
	OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0; 
	WR4: SELF.role.name IN ['design', 'usage']; 
	WR5: (SELF.role.name <> 'design') 
	OR (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0); 
	WR6: (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0); 
	WR7: SELF.role.description IN ['exception', 'inherited', 'local']; 
	WR8: SIZEOF( QUERY( x <* USEDIN(SELF,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1; 
END_ENTITY;
(* USED FROM (Specification_based_configuration_mim); *)
ENTITY configured_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment);
  SELF\effectivity_context_assignment.assigned_effectivity_assignment: configured_effectivity_assignment;
  items : SET [1:?] OF configured_effectivity_context_item; 
WHERE 
WR1: SIZEOF(SELF.items) = 1; 
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY conic
   SUPERTYPE OF (ONEOF (
              CIRCLE,
              ELLIPSE,
              HYPERBOLA,
              PARABOLA))
  SUBTYPE OF (curve);
   position: axis2_placement;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY
 conical_surface
   SUBTYPE OF (elementary_surface);
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;
(* REFERENCE FROM (topology_schema); *)
 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (
              CLOSED_SHELL,
              OPEN_SHELL))
  SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;
(* USED FROM (Construction_geometry_mim); *)
ENTITY constructive_geometry_representation
  SUBTYPE OF (representation);
WHERE
  WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
  WR2: SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLACEMENT', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
  WR3: SIZEOF( USEDIN( SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
  WR4: SIZEOF( USEDIN( SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
END_ENTITY;
(* USED FROM (Construction_geometry_mim); *)
ENTITY constructive_geometry_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
  WR2: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2);
  WR3: SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_REPRESENTATION', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1;
  WR4: NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
END_ENTITY;
(* USED FROM (Surface_conditions_mim); *)
ENTITY contact_ratio_representation
  SUBTYPE OF (representation);
WHERE
 WR1: ( SIZEOF ( SELF.items ) =1 ) AND ( SIZEOF ( QUERY ( i <*
     SELF.items | ( SIZEOF ( ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'MEASURE_REPRESENTATION_ITEM' , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) AND ( i.name =
     'ratio value' ) ) ) =1 ) ;
 WR2: ( SIZEOF ( QUERY ( pdr <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | pdr. name =
     'contact ratio reference' ) ) =1 ) AND ( SIZEOF ( QUERY (
     pdr <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | ( pdr. name =
     'contact ratio reference' ) AND ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'PHYSICALLY_MODELLED_PRODUCT_DEFINITION' IN TYPEOF ( pdr.
     definition.definition ) ) ) ) =1 ) ;
 WR3: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
     <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
     pdr. definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
     'DERIVED_DEFINITION' ) | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
     ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
     ) =1 ) ;
END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;
(* USED FROM (contract_schema); *)
ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY contract_assignment
   ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

(* Implicit interfaced from: contract_schema *)
ENTITY contract_type;
  description : label;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;
(* USED FROM (aic_csg); *)
ENTITY csg_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CSG_SOLID', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SOLID_REPLICA', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REVOLVED_FACE_SOLID', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (it)) <> 1) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sr <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CSG_SOLID', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REVOLVED_FACE_SOLID', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) > 0;
 END_ENTITY ;
(* USED FROM (geometric_model_schema); *)
 ENTITY csg_solid
   SUBTYPE OF (solid_model);
   tree_root_expression : csg_select;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
(* Pruned SUPERTYPE *)
ENTITY curve
   SUPERTYPE OF (ONEOF (
              LINE,
              CONIC,
              PCURVE,
              SURFACE_CURVE,
              OFFSET_CURVE_2D,
              OFFSET_CURVE_3D,
              CURVE_REPLICA))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
    basis_surface    : surface;
    boundaries       : SET [1:?] OF boundary_curve;
    implicit_outer   : BOOLEAN;
  WHERE
    WR1: (NOT implicit_outer) OR
         (SIZEOF (QUERY (temp <* boundaries |
           'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
    WR2: (NOT(implicit_outer)) OR
                ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
    WR3: SIZEOF(QUERY(temp <* boundaries |
                  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp))) <= 1;
    WR4: SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface))) = 0;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY curve_replica
   SUBTYPE OF (curve);
   parent_curve   : curve;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_curve.dim;
   WR2: acyclic_curve_replica (SELF, parent_curve);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
   radius : positive_length_measure;
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY cylindricity_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
(* USED FROM (material_property_representation_schema); *)
ENTITY data_environment;
  name       : label;
  description : text;
  elements    : SET [1:?] OF property_definition_representation;
END_ENTITY;
(* USED FROM (date_time_schema); *)
(* Pruned SUPERTYPE *)
ENTITY date
  ;
  year_component : year_number;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY date_and_time_assignment
   ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY date_assignment
   ABSTRACT SUPERTYPE;
  assigned_date : date;
  role : date_role;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification               :identifier;
INVERSE
  established_by_relationships : SET [1:?] OF shape_aspect_relationship
                                 FOR related_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\datum.established_by_relationships |
       SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* 
       ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DATUM_FEATURE', 
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DATUM_TARGET']) <> 1))=0;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY datum_feature
   SUBTYPE OF (shape_aspect);
INVERSE 
   feature_basis_relationship : shape_aspect_relationship
                              FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.'+
       'RELATING_SHAPE_ASPECT'))
       | NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DATUM' IN TYPEOF
       (sar\shape_aspect_relationship.related_shape_aspect))))=0;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY datum_reference;
  precedence       : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id             : identifier; 
INVERSE
  target_basis_relationship : shape_aspect_relationship FOR
                              relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.' +
       'RELATING_SHAPE_ASPECT'))
      | NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DATUM' IN TYPEOF 
      (sar\shape_aspect_relationship.related_shape_aspect))))=0;
   WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF (SELF\representation.context_of_items );
END_ENTITY;
(* USED FROM (Extended_basic_geometry_mim); *)
  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
   WHERE
    WR1: acyclic_representation_relationship(SELF,
       [SELF\representation_relationship.rep_2],
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
       'REPRESENTATION');
  END_ENTITY;  
(* USED FROM (geometry_schema); *)
 ENTITY degenerate_pcurve
   SUBTYPE OF (point);
   basis_surface:  surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
   select_outer : BOOLEAN;
 WHERE
  WR1: major_radius <   minor_radius;
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (
              APEX,
              CENTRE_OF_SYMMETRY,
              GEOMETRIC_ALIGNMENT,
              GEOMETRIC_INTERSECTION,
              PARALLEL_OFFSET,
              PERPENDICULAR_TO,
              EXTENSION,
              TANGENT))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET [1:?] OF
          shape_aspect_relationship FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (dr <*
          SELF\derived_shape_aspect.deriving_relationships |
          NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'
          IN TYPEOF (dr)))) = 0;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location; 
  related_element   : tolerance_zone_definition;
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY dimensional_characteristic_representation;
  dimension      : dimensional_characteristic; 
  representation : shape_dimension_representation;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (
              ANGULAR_LOCATION,
              DIMENSIONAL_LOCATION_WITH_PATH))
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (
              ANGULAR_SIZE,
              DIMENSIONAL_SIZE_WITH_PATH));
  applies_to : shape_aspect;
  name       : label;
WHERE
  WR1: applies_to.product_definitional = TRUE;
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;
(* USED FROM (Dimension_tolerance_mim); *)
ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;
(* USED FROM (document_schema); *)
ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;
(* USED FROM (File_identification_mim); *)
ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;
(* USED FROM (document_schema); *)
ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  WR3: NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY document_reference
   ABSTRACT SUPERTYPE;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (document_schema); *)
ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;
(* USED FROM (document_schema); *)
ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;
(* USED FROM (document_schema); *)
ENTITY document_type;
  product_data_type : label;
END_ENTITY;
(* REFERENCE FROM (document_schema); *)
ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY document_usage_constraint_assignment
   ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (topology_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY edge
   SUPERTYPE OF (ONEOF (
              EDGE_CURVE,
              ORIENTED_EDGE))
  SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   ebwm_boundary  : SET [1:?] OF connected_edge_set;
 END_ENTITY;
(* USED FROM (aic_edge_based_wireframe); *)
ENTITY edge_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_CURVE' IN TYPEOF (edges)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( pline_edges <* 
QUERY ( edges <* eb.ces_edges| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_end))) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR9 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
(* USED FROM (topology_schema); *)
 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY effectivity
  SUPERTYPE OF (ONEOF (
              SERIAL_NUMBERED_EFFECTIVITY,
              DATED_EFFECTIVITY,
              LOT_EFFECTIVITY,
              TIME_INTERVAL_BASED_EFFECTIVITY));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY effectivity_assignment
   ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY effectivity_context_assignment
   ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role : effectivity_context_role;
END_ENTITY;

(* Implicit interfaced from: management_resources_schema *)
ENTITY effectivity_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY elementary_surface
   SUPERTYPE OF (ONEOF (
              PLANE,
              CYLINDRICAL_SURFACE,
              CONICAL_SURFACE,
              SPHERICAL_SURFACE,
              TOROIDAL_SURFACE))
  SUBTYPE OF (surface);
   position : axis2_placement_3d;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
   equivalent_point : cartesian_point;
 END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY event_occurrence_assignment
   ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;
(* REFERENCE FROM (date_time_schema); *)
ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;
(* USED FROM (External_class_mim); *)
ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY external_identification_assignment
   ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;
(* USED FROM (external_reference_schema); *)
ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (External_class_mim); *)
ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;
(* USED FROM (Dimension_tolerance_mim); *)
ENTITY externally_defined_dimension_definition
  SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
  WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
  WR2: 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;
(* USED FROM (External_properties_mim); *)
ENTITY externally_defined_general_property 
SUBTYPE OF (general_property, externally_defined_item); 
END_ENTITY; 
(* USED FROM (external_reference_schema); *)
ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;
(* USED FROM (external_reference_schema); *)
ENTITY externally_defined_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item : externally_defined_item;
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;
(* USED FROM (topology_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY face
   SUPERTYPE OF (ONEOF (
              FACE_SURFACE,
              ORIENTED_FACE))
  SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;
(* USED FROM (topology_schema); *)
    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
 END_ENTITY;
(* USED FROM (aic_faceted_brep); *)
ENTITY faceted_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* items| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* items| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_SURFACE' IN TYPEOF (fcs)) AND (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( 
QUERY ( bnds <* fcs.bounds| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY flatness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
(* USED FROM (representation_schema); *)
ENTITY founded_item;
END_ENTITY;
(* USED FROM (Functional_breakdown_mim); *)
ENTITY functional_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;
(* USED FROM (Functional_breakdown_mim); *)
ENTITY functional_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (Generic_material_aspects_mim); *)
ENTITY general_material_property 
SUBTYPE OF (general_property); 
WHERE 
WR1: SIZEOF( QUERY( gpa <* USEDIN(SELF,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | 
  NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0; 
END_ENTITY; 
(* USED FROM (product_property_definition_schema); *)
ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
 WHERE
   WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0;
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;
(* USED FROM (Extended_basic_geometry_mim); *)
ENTITY geometric_model_element_relationship
  SUBTYPE OF (geometric_representation_item, representation_item_relationship);
UNIQUE
  UR1: SELF\representation_item_relationship.relating_representation_item, 
       SELF\representation_item_relationship.related_representation_item;
WHERE
  WR1: SELF\representation_item_relationship.relating_representation_item :<>: 
       SELF\representation_item_relationship.related_representation_item;
END_ENTITY; 
(* USED FROM (geometry_schema); *)
ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;
(* USED FROM (geometry_schema); *)
(* Pruned SUPERTYPE *)
  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR,
              CURVE,
              SURFACE,
              EDGE_CURVE,
              FACE_SURFACE,
              POLY_LOOP,
              VERTEX_POINT,
              SOLID_MODEL,
              BOOLEAN_RESULT,
              SPHERE,
              RIGHT_CIRCULAR_CONE,
              RIGHT_CIRCULAR_CYLINDER,
              TORUS,
              BLOCK,
              RIGHT_ANGULAR_WEDGE,
              HALF_SPACE_SOLID,
              SHELL_BASED_SURFACE_MODEL,
              SHELL_BASED_WIREFRAME_MODEL,
              EDGE_BASED_WIREFRAME_MODEL,
              GEOMETRIC_SET))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;
(* USED FROM (geometric_model_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY geometric_set
   
  SUBTYPE OF (geometric_representation_item);
   elements :  SET [1:?] OF geometric_set_select;
 END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY geometric_tolerance;
  name                    : label;
  description             : text;
  magnitude               : measure_with_unit; 
  toleranced_shape_aspect : shape_aspect; 
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (magnitude\measure_with_unit.value_component)) AND
       (magnitude\measure_with_unit.value_component >= 0.0);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY geometric_tolerance_relationship;
                                   name                         :label;
                                   description                  :text;
                                   relating_geometric_tolerance : geometric_tolerance; 
                                   related_geometric_tolerance  : geometric_tolerance; 
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY geometric_tolerance_with_datum_reference
   SUBTYPE OF (geometric_tolerance);
   datum_system : SET [1:?] OF  datum_reference;
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (unit_size\measure_with_unit.value_component)) AND
       (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;
(* USED FROM (aic_geometrically_bounded_2d_wireframe); *)
ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET',           
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_2D',
            'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *
          
['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET',
            'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCLE',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELLIPSE',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_2D',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE',
              'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
           ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT',
                'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
        
     ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET'
           IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pl <* 
           QUERY (elem <* gcs\geometric_set.elements |
             ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE'
                  IN TYPEOF (elem))) |
             NOT (SIZEOF (pl\polyline.points) > 2)
         )) = 0)
       )) = 0;
END_ENTITY;
(* USED FROM (aic_geometrically_bounded_surface); *)
ENTITY geometrically_bounded_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it <* SELF.items | NOT (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
  WR2: SIZEOF(QUERY(it <* SELF.items | SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
  WR3: SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) | NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it <* mi\mapped_item.mapping_source.mapped_representation.items | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET' IN TYPEOF(mr_it)))) > 0)))) = 0;
  WR4: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt <* QUERY(gsel <* gs\geometric_set.elements | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT' IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0;
  WR5: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv <* QUERY(gsel <* gs\geometric_set.elements | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE' IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0;
  WR6: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf <* QUERY(gsel <* gs\geometric_set.elements | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE' IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0;
  WR7: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | SIZEOF(QUERY(gsel <* gs\geometric_set.elements | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE' IN TYPEOF(gsel))) > 0)) > 0;
END_ENTITY;
(* USED FROM (aic_geometrically_bounded_wireframe); *)
ENTITY geometrically_bounded_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ( TYPEOF (it) * [ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ]) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ( TYPEOF (it) * [ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ]) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( crv <* 
QUERY ( elem <* gcs\geometric_set.elements| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_curve(crv) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pnts <* 
QUERY ( elem <* gcs\geometric_set.elements| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_point(pnts) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( cnc <* 
QUERY ( elem <* gcs\geometric_set.elements| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC' IN TYPEOF (elem)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (cnc\conic.position)) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pline <* 
QUERY ( elem <* gcs\geometric_set.elements| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF (elem)) )| NOT ( SIZEOF (pline\polyline.points) > 2) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
(* USED FROM (representation_schema); *)
ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;
(* USED FROM (group_schema); *)
ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY group_assignment
   ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (group_schema); *)
ENTITY group_relationship;
  name : label;
  description : OPTIONAL text;
  relating_group : group;
  related_group : group;
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY half_space_solid
   SUBTYPE OF(geometric_representation_item);
   base_surface   : surface;
   agreement_flag : BOOLEAN;
 END_ENTITY;
(* USED FROM (Surface_conditions_mim); *)
ENTITY hardness_representation
  SUBTYPE OF (representation);
WHERE
 WR1: ( {2<= SIZEOF ( SELF.items ) <=4} ) AND ( SIZEOF ( QUERY (
     i <* items | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
     i.name IN [ 'measuring method' , 'measuring position' ] ) )
     ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )
     AND ( i.name IN ['depth' , 'hardness'] ) ) ) = SIZEOF (
     SELF.items ) ) ;
 WR2: SIZEOF ( QUERY ( i <* SELF.items | i.name =
     'measuring method' ) ) =1;
 WR3: SIZEOF ( QUERY ( i <* SELF.items | i.name ='hardness' ) )
     =1;
 WR4: SIZEOF ( QUERY ( i <* SELF.items | i.name =
     'measuring position' ) ) <=1;
 WR5: SIZEOF ( QUERY ( i <* SELF.items | i.name ='depth' ) )
     <=1;
 WR6: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
     <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
     pdr. definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
     'DERIVED_DEFINITION' ) | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
     ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
     ) =1 ) ;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY identification_assignment
   ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
	WHERE
		WR1: NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
		WR2: SIZEOF (QUERY
									( cfr <* USEDIN 
											( SELF ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) 
											| 
											'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) 
									) 
								) + 
				 SIZEOF(QUERY
				 					( cfr <* USEDIN 
				 							(SELF , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) 
				 							| 
											'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)
									)
								)= 0;
		WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;
(* USED FROM (Specification_control_mim); *)
ENTITY instance_usage_context_assignment 
SUBTYPE OF (product_definition_context); 
items : SET [1:?] OF instance_usage_context_select; 
END_ENTITY; 
(* USED FROM (geometry_schema); *)
 ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;
(* USED FROM (Plib_class_reference_mim); *)
ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;
(* USED FROM (Multi_linguism_mim); *)
ENTITY language 
SUBTYPE OF (group); 
WHERE
WR1: SELF\group.name <> '';
END_ENTITY; 
(* USED FROM (measure_schema); *)
ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY limits_and_fits;
  form_variance   : label;
  zone_variance   : label;
  grade           : label;
  source          : text;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY line_profile_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
WR2 : 
SIZEOF ( 
QUERY ( sar <* USEDIN (SELF\geometric_tolerance.toleranced_shape_aspect, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.name IN [ 'affected plane association', 'resulting intersection curve association' ]) )) = 1;
 END_ENTITY ;

(* Implicit interfaced from: date_time_schema *)
ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

(* Implicit interfaced from: topology_schema *)
 ENTITY loop
   SUPERTYPE OF (ONEOF (
              VERTEX_LOOP,
              EDGE_LOOP,
              POLY_LOOP))
  SUBTYPE OF (topological_representation_item);
 END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
   outer : closed_shell;
 END_ENTITY;
(* USED FROM (aic_manifold_surface); *)
ENTITY manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OPEN_SHELL',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_CLOSED_SHELL',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DEGENERATE_PCURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DEGENERATE_PCURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR14: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DEGENERATE_PCURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (material_property_definition_schema); *)
ENTITY material_designation;
  name       : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;
(* USED FROM (material_property_definition_schema); *)
ENTITY material_designation_characterization;
  name       : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;
(* USED FROM (material_property_definition_schema); *)
ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;
(* USED FROM (material_property_representation_schema); *)
ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;
(* USED FROM (Inertia_characteristics_mim); *)
ENTITY moments_of_inertia_representation 
SUBTYPE OF (representation); 
WHERE 
WR1: (SIZEOF(SELF.items) = 1) AND 
 (SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i.name = 'moments of inertia matrix') )) = 1); 
WR2: SIZEOF( QUERY( i <* SELF.items | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND 
  value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1; 
END_ENTITY; 
(* USED FROM (Multi_linguism_mim); *)
ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY; 
(* USED FROM (management_resources_schema); *)
ENTITY name_assignment
   ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;
END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY offset_curve_2d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
 WHERE
   WR1: basis_curve.dim = 2;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY offset_curve_3d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
   ref_direction  : direction;
 WHERE
   WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY offset_surface
   SUBTYPE OF (surface);
   basis_surface  : surface;
   distance       : length_measure;
   self_intersect : LOGICAL;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY organizational_project_assignment
   ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

(* Implicit interfaced from: topology_schema *)
 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

(* Implicit interfaced from: topology_schema *)
 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

(* Implicit interfaced from: topology_schema *)
 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY oriented_surface
   SUBTYPE OF (surface);
   orientation : BOOLEAN;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
 END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1: NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
	WR2: SIZEOF ( QUERY 
									( 
										cfr <* USEDIN ( SELF , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) 
										| 
										('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) 
										AND 
										( SIZEOF ( QUERY 
																( 
																	ipcf <* USEDIN ( cfr , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +	'CONDITION' ) 
																	| 
																	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) 
																)
															)= 1 
										)
									)
							)>0;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset               : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY parallelism_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
 END_ENTITY ;
(* USED FROM (representation_schema); *)
ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;
(* USED FROM (topology_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY path
   SUPERTYPE OF (ONEOF (
              EDGE_LOOP,
              ORIENTED_PATH))
  SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY pcurve
   SUBTYPE OF (curve);
   basis_surface      : surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY perpendicularity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
 END_ENTITY ;
(* USED FROM (person_organization_schema); *)
ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value (SELF);
  description : text := get_description_value(SELF);
  
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (Person_organization_mim); *)
ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY person_and_organization_assignment
   ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (person_organization_schema); *)
ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (Physical_breakdown_mim); *)
ENTITY physical_breakdown_context
  SUBTYPE OF (breakdown_context);
END_ENTITY;
(* USED FROM (Physical_breakdown_mim); *)
ENTITY physical_element_usage
  SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
(* USED FROM (Surface_conditions_mim); *)
ENTITY physically_modelled_product_definition 
SUBTYPE OF (product_definition); 
WHERE 
WR1: SELF.frame_of_reference\application_context_element.name = 'physical model occurrence'; 
WR2: 'document' IN categories_of_product(SELF\product_definition.formation.of_product);
END_ENTITY; 
(* USED FROM (Geometric_tolerance_mim); *)
ENTITY placed_datum_target_feature
  SUBTYPE OF (datum_target);
DERIVE
  representation_associations : SET[0:?] OF property_definition_representation := get_shape_aspect_property_definition_representations(SELF);
WHERE
  WR1: SELF.description IN ['point','line','rectangle','circle', 'circular line'];
  WR2: SIZEOF (QUERY (pdr <* representation_associations | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1;
  WR3: valid_datum_target_parameters(SELF);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY placement
   SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT,
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;
(* USED FROM (presentation_resource_schema); *)
ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY plane
 SUBTYPE OF (elementary_surface);
 END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY  plus_minus_tolerance;
  range                : tolerance_method_definition; 
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;
(* USED FROM (geometry_schema); *)
(* Pruned SUPERTYPE *)
ENTITY point
   SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT,
              POINT_ON_CURVE,
              POINT_ON_SURFACE,
              POINT_REPLICA,
              DEGENERATE_PCURVE))
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY point_on_curve
   SUBTYPE OF (point);
   basis_curve     : curve;
   point_parameter : parameter_value;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY point_on_surface
   SUBTYPE OF (point);
   basis_surface     : surface;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY point_replica
   SUBTYPE OF (point);
   parent_pt      : point;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_pt.dim;
   WR2: acyclic_point_replica (SELF,parent_pt);
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY position_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
 END_ENTITY ;
(* USED FROM (external_reference_schema); *)
ENTITY pre_defined_item;
  name : label;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_as_individual
  SUBTYPE OF (product);
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_as_individual_version
   ABSTRACT SUPERTYPE OF (ONEOF (
                        PRODUCT_AS_PLANNED,
                        PRODUCT_AS_REALIZED))
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : product_as_individual;
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_as_individual_view
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : product_as_individual_version;  -- defined_version : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
    DERIVE
      defined_version : PRODUCT_AS_INDIVIDUAL_VERSION := SELF\product_definition.formation;  -- FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE

END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_as_planned
  SUBTYPE OF (product_as_individual_version);
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_as_realized
  SUBTYPE OF (product_as_individual_version);
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY product_class
  SUBTYPE OF (product_concept,characterized_object);
END_ENTITY;
(* USED FROM (product_concept_schema); *)
ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;
(* USED FROM (application_context_schema); *)
ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;
(* USED FROM (product_concept_schema); *)
ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (product_concept_schema); *)
ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY
									( 
										aga <* USEDIN( SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) 
										|
    								(
    									( aga.role.name <> 'specification category member' ) 
    									OR 
    									( SIZEOF(QUERY 
    															( 
    																i <* aga.items 
    																| 
    																('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) 
    																AND 
    																NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i))
    															)
    													) <> SIZEOF (aga.items)
    									)
    								) 
       						) 
       				) =0;
END_ENTITY;
(* USED FROM (Product_class_mim); *)
ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items : SET [1:?] OF category_usage_item;
WHERE
WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY;
(* USED FROM (product_concept_schema); *)
ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;
(* REFERENCE FROM (application_context_schema); *)
ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (application_context_schema); *)
ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* REFERENCE FROM (product_definition_schema); *)
ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY product_definition_element_relationship
  SUBTYPE OF (group);
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;
(* USED FROM (Product_breakdown_mim); *)
ENTITY product_definition_group_assignment
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_definition_element_relationship;
  items : SET[1:1] OF product_definition_or_product_definition_relationship;
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_substitute;
  description : OPTIONAL text;
  context_relationship : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (
              MAKE_FROM_USAGE_OPTION,
              ASSEMBLY_COMPONENT_USAGE))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_design_to_individual
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.related_product : product_as_individual;  -- individual_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause

  (* removed : SELF\product_relationship.product_design :  PRODUCT *)
    DERIVE
      individual_product : PRODUCT_AS_INDIVIDUAL := SELF\product_relationship.related_product;  -- RELATED_PRODUCT : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
      product_design : PRODUCT := SELF\product_relationship.relating_product;  -- RELATING_PRODUCT : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE

END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_design_version_to_individual
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual_version;  -- individual_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause

  (* removed : SELF\product_definition_formation_relationship.product_design_version :  PRODUCT_DEFINITION_FORMATION *)
    DERIVE
      individual_product : PRODUCT_AS_INDIVIDUAL_VERSION := SELF\product_definition_formation_relationship.related_product_definition_formation;  -- RELATED_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
      product_design_version : PRODUCT_DEFINITION_FORMATION := SELF\product_definition_formation_relationship.relating_product_definition_formation;  -- RELATING_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE

END_ENTITY;
(* USED FROM (Specified_product_mim); *)
ENTITY product_identification
  SUBTYPE OF (configuration_item, characterized_object);
	SELF\configuration_item.item_concept : product_class;
WHERE
	WR1 : SIZEOF(QUERY 
								( cd <* USEDIN ( SELF ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION' ) 
								|
     						( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) 
     						AND 
    						( SIZEOF ( QUERY 
    												( 
    													prpc <* USEDIN ( cd. design\product_definition_formation.of_product , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') 
    													| 
         											prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
     													) 
     												) 
     											) <=1;
	WR2 : NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) 
				XOR ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) ) ;
END_ENTITY;
(* USED FROM (Product_as_individual_mim); *)
ENTITY product_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_planned;  -- planned_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_realized;  -- realized_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
    DERIVE
      planned_product : PRODUCT_AS_PLANNED := SELF\product_definition_formation_relationship.relating_product_definition_formation;  -- RELATING_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
      realized_product : PRODUCT_AS_REALIZED := SELF\product_definition_formation_relationship.related_product_definition_formation;  -- RELATED_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE

END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;
(* USED FROM (product_definition_schema); *)
ENTITY product_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product : product;
  related_product : product;
END_ENTITY;
(* USED FROM (Specified_product_mim); *)
ENTITY product_specification
  SUBTYPE OF (product_identification, configurable_item);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY projected_zone_definition 
  SUBTYPE OF (tolerance_zone_definition);  
  projection_end   : shape_aspect; 
  projected_length : measure_with_unit;
WHERE 
  WR1: ('NUMBER' IN TYPEOF
       (projected_length\measure_with_unit.value_component)) AND
       (projected_length\measure_with_unit.value_component > 0.0);
  WR2: (derive_dimensional_exponents
       (projected_length\measure_with_unit.unit_component)=
        dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (material_property_definition_schema); *)
ENTITY property_definition_relationship;
  name                       : label;
  description                 : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
                                
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                               := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
   weights_data : LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                      ARRAY [0:v_upper] OF REAL
                 := make_array_of_array(weights_data,0,u_upper,0,v_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
   WR2: surface_weights_positive(SELF);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
   segments      : LIST [1:?] OF LIST [1:?] OF surface_patch;
 DERIVE
   n_u : INTEGER := SIZEOF(segments);
   n_v : INTEGER := SIZEOF(segments[1]);
 WHERE
   WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
   WR2: constraints_rectangular_composite_surface(SELF);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
   basis_surface : surface;
   u1            : parameter_value;
   u2            : parameter_value;
   v1            : parameter_value;
   v2            : parameter_value;
   usense        : BOOLEAN;
   vsense        : BOOLEAN;
 WHERE
   WR1: u1 <> u2;
   WR2: v1 <> v2;
   WR3: (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
       AND  (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR
      ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR (usense = (u2 > u1));
   WR4: (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
          OR
         ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR (vsense = (v2 > v1));
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
   param_length : parameter_value;
 WHERE
   WR1: param_length > 0.0;
 END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : positive_length_measure;
 END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY roundness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
(* USED FROM (shape_tolerance_schema); *)
ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition); 
  orientation  : runout_zone_orientation;
END_ENTITY;

(* Implicit interfaced from: shape_tolerance_schema *)
ENTITY runout_zone_orientation;
  angle : measure_with_unit;
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation); 
  orientation_defining_relationship: shape_aspect_relationship;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY seam_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
           associated_surface(SELF\surface_curve.associated_geometry[2]);
   WR3: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
   WR4: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;
(* USED FROM (security_classification_schema); *)
ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY security_classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
(* USED FROM (security_classification_schema); *)
ENTITY security_classification_level;
  name : label;
END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY shape_aspect_deriving_relationship
       SUBTYPE OF (shape_aspect_relationship);
     WHERE
       WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DERIVED_SHAPE_ASPECT' IN
TYPEOF
            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
     END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
  WR2: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY;
(* USED FROM (shape_dimension_schema); *)
ENTITY shape_dimension_representation
                SUBTYPE OF (shape_representation);
  WHERE
   WR1: SIZEOF (QUERY (temp <* SELF\representation.items | 
    NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF (temp)))) = 0;
   WR2: SIZEOF (SELF\representation.items) <= 3;
   WR3: SIZEOF (QUERY (pos_mri <* QUERY (real_mri <*
        SELF\representation.items | 'REAL' IN TYPEOF
        (real_mri\measure_with_unit.value_component) ) |        
     NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;
(* USED FROM (Geometric_tolerance_mim); *)
ENTITY shape_representation_with_parameters
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF( QUERY( i <* SELF.items | SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLACEMENT', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items);
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   sbsm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_surface_model(SELF);
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   sbwm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_wireframe_model(SELF);
 END_ENTITY;
(* USED FROM (aic_shell_based_wireframe); *)
ENTITY shell_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_CURVE' IN TYPEOF (el.edge_element)) )) = 0) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( pline_el <* 
QUERY ( el <* eloop\path.edge_list| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))) )) = 0) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (vloop\vertex_loop.loop_vertex)) )) = 0) )) = 0) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0) )) = 0;
WR10 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)) )) = 0) )) = 0;
WR11 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0;
WR12 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR13 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
(* USED FROM (measure_schema); *)
ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

(* Implicit interfaced from: geometric_model_schema *)
(* Pruned SUPERTYPE *)
 ENTITY solid_model
   SUPERTYPE OF (ONEOF (
              CSG_SOLID,
              MANIFOLD_SOLID_BREP,
              SWEPT_FACE_SOLID,
              SOLID_REPLICA))
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY solid_replica
   SUBTYPE OF (solid_model);
   parent_solid   : solid_model;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_solid_replica(SELF, parent_solid);
   WR2: parent_solid\geometric_representation_item.dim = 3;
 END_ENTITY;
(* USED FROM (product_structure_schema); *)
ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
   radius : positive_length_measure;
   centre : point;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
   radius   : positive_length_measure;
 END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
(* Pruned SUPERTYPE *)
ENTITY standard_uncertainty
  
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY straightness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
(* USED FROM (geometry_schema); *)
 ENTITY surface
   SUPERTYPE OF (ONEOF (
              ELEMENTARY_SURFACE,
              SWEPT_SURFACE,
              BOUNDED_SURFACE,
              OFFSET_SURFACE,
              SURFACE_REPLICA))
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY surface_curve
   SUPERTYPE OF (ONEOF (
              INTERSECTION_CURVE,
              SEAM_CURVE)
              ANDOR 
              BOUNDED_SURFACE_CURVE)
  SUBTYPE OF (curve);
   curve_3d              : curve;
   associated_geometry   : LIST[1:2] OF pcurve_or_surface;
   master_representation : preferred_surface_curve_representation;
 DERIVE
   basis_surface         : SET[1:2] OF surface
                         := get_basis_surface(SELF);
 WHERE
   WR1: curve_3d.dim = 3;
   WR2: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
   WR3: ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
   WR4: NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
   extrusion_axis      : vector;
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
   axis_position       : axis1_placement;
 DERIVE
   axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY surface_patch
 SUBTYPE OF (founded_item);
   parent_surface : bounded_surface;
   u_transition   : transition_code;
   v_transition   : transition_code;
   u_sense        : BOOLEAN;
   v_sense        : BOOLEAN;
 INVERSE
   using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
 WHERE
   WR1: (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY surface_profile_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
 END_ENTITY ;
(* USED FROM (geometry_schema); *)
 ENTITY surface_replica
   SUBTYPE OF (surface);
   parent_surface : surface;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_surface_replica(SELF, parent_surface);
 END_ENTITY;
(* USED FROM (Surface_conditions_mim); *)
ENTITY surface_texture_representation
  SUBTYPE OF (representation);
WHERE
 WR1: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'VALUE_RANGE' , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) <>1 ) )
     =0;
 WR2: ( SIZEOF ( QUERY ( i <* SELF.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) =1 )
     AND ( SIZEOF ( QUERY ( i <* SELF.items | (
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN
     TYPEOF ( i ) ) AND ( i.name = 'measuring method' ) ) ) =1 )
     ;
 WR3: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) )
     >0;
 WR4: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
     'REP_1' ) ) <=1 ) AND ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
     'REP_2' ) ) =0 ) AND ( SIZEOF ( QUERY ( rr <* USEDIN ( SELF
     , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
     'REP_1' ) | rr. rep_2.name = 'measuring direction' ) ) =
     SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+
     'REP_1' ) ) ) ;
 WR5: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
     <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
     pdr. definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
     'DERIVED_DEFINITION' ) | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
     ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
     ) =1 ) ;
END_ENTITY;

(* Implicit interfaced from: geometric_model_schema *)
(* Pruned SUPERTYPE *)
 ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF (
              EXTRUDED_FACE_SOLID,
              REVOLVED_FACE_SOLID))
  SUBTYPE OF (solid_model);
   swept_face :  face_surface;
 WHERE
   WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLANE' IN TYPEOF(swept_face.face_geometry);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
(* Pruned SUPERTYPE *)
 ENTITY swept_surface
   SUPERTYPE OF (ONEOF (
              SURFACE_OF_LINEAR_EXTRUSION,
              SURFACE_OF_REVOLUTION))
  SUBTYPE OF (surface);
   swept_curve : curve;
 END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET [1:?] OF shape_aspect_relationship
                        FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\symmetric_shape_aspect.basis_relationships |
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF 
       (x\shape_aspect_relationship.related_shape_aspect)))>=1;
END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY symmetry_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
 END_ENTITY ;
(* USED FROM (Surface_conditions_mim); *)
ENTITY tactile_appearance_representation
  SUBTYPE OF (representation);
WHERE
 WR1: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) <>1 )
     ) =0;
 WR2: SIZEOF ( QUERY ( i <* SELF.items | name ='depth' ) ) <=1;
 WR3: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
     <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
     pdr. definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
     'DERIVED_DEFINITION' ) | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
     ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
     ) =1 ) ;
END_ENTITY;
(* USED FROM (shape_aspect_definition_schema); *)
ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
ENTITY time_interval_assignment
   ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;
(* USED FROM (effectivity_schema); *)
ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (date_time_schema); *)
ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY tolerance_value; 
   lower_bound : measure_with_unit; 
   upper_bound : measure_with_unit;
WHERE 
   WR1: upper_bound\measure_with_unit.value_component >
        lower_bound\measure_with_unit.value_component;  
   WR2: upper_bound\measure_with_unit.unit_component =
        lower_bound\measure_with_unit.unit_component;
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET [1:?] OF geometric_tolerance; 
  form               : tolerance_zone_form;
END_ENTITY;
(* USED FROM (shape_tolerance_schema); *)
ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (
              PROJECTED_ZONE_DEFINITION,
              RUNOUT_ZONE_DEFINITION));
  zone : tolerance_zone;
  boundaries: SET [1:?] OF shape_aspect;
END_ENTITY;

(* Implicit interfaced from: shape_tolerance_schema *)
ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF (
              VERTEX,
              EDGE,
              FACE_BOUND,
              FACE,
              VERTEX_SHELL,
              WIRE_SHELL,
              CONNECTED_EDGE_SET,
              CONNECTED_FACE_SET,(
              LOOP
              ANDOR 
              PATH)))
  SUBTYPE OF (representation_item);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 END_ENTITY;
(* USED FROM (geometric_model_schema); *)
 ENTITY torus
   SUBTYPE OF (geometric_representation_item);
   position     : axis1_placement;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1: major_radius > minor_radius;
 END_ENTITY;
(* USED FROM (aic_geometric_tolerances); *)
ENTITY total_runout_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
(* USED FROM (geometry_schema); *)
 ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
   basis_curve           : curve;
   trim_1                : SET[1:2] OF trimming_select;
   trim_2                : SET[1:2] OF trimming_select;
   sense_agreement       : BOOLEAN;
   master_representation : trimming_preference;
 WHERE
   WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
   WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
 END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY type_qualifier;
  name : label;
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF (
              STANDARD_UNCERTAINTY,
              QUALITATIVE_UNCERTAINTY));
  measure_name : label;
  description  : text;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;
(* USED FROM (Extended_measure_representation_mim); *)
ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
  WR2: value_range_wr2 ( item_element );
  WR3: value_range_wr3 ( item_element );
END_ENTITY;
(* USED FROM (representation_schema); *)
ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;
(* USED FROM (geometry_schema); *)
 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;
(* USED FROM (action_schema); *)
ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;

(* Implicit interfaced from: topology_schema *)
 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;
(* USED FROM (Surface_conditions_mim); *)
ENTITY visual_appearance_representation
  SUBTYPE OF (representation);
WHERE
 WR1: ( {2<= SIZEOF ( SELF.items ) <=5} ) AND ( SIZEOF ( QUERY (
     i <* items | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
     i.name IN [ 'colour id' , 'colour name' , 'lustre' ,
     'pattern' , 'transparency'] ) ) ) = SIZEOF ( SELF.items ) )
     ;
 WR2: SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour id' )
     ) =1;
 WR3: SIZEOF ( QUERY ( i <* SELF.items | i.name ='lustre' ) )
     =1;
 WR4: SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour name'
     ) ) <=1;
 WR5: SIZEOF ( QUERY ( i <* SELF.items | i.name ='pattern' ) )
     <=1;
 WR6: SIZEOF ( QUERY ( i <* SELF.items | i.name ='transparency'
     ) ) <=1;
 WR7: ( SIZEOF ( USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
     <* USEDIN ( SELF ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
     'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
     pdr. definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+
     'DERIVED_DEFINITION' ) | ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+
     'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
     ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
     ) =1 ) ;
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;
(* USED FROM (topology_schema); *)
 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);
END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION acyclic_point_replica(rep : point_replica; parent : point)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: product_definition_schema *)
FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
END_FUNCTION; 
(* REFERENCE FROM (product_definition_schema); *)
FUNCTION acyclic_product_definition_relationship
 (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

(* Implicit interfaced from: Extended_basic_geometry_mim *)
FUNCTION acyclic_representation_relationship
 (relation : representation_relationship; relatives : SET[1:?] OF representation; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

(* Implicit interfaced from: geometric_model_schema *)
 FUNCTION acyclic_solid_replica(rep : solid_replica; parent :
                    solid_model) : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION acyclic_surface_replica(rep : surface_replica; parent : surface)
                                              : BOOLEAN;
   IF NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: Catalog_data_information_mim *)
FUNCTION allowed_translations ( ent: GENERIC       ; translatable_attributes: SET OF STRING): LOGICAL;

	LOCAL
	  mlaa: BAG OF multi_language_attribute_assignment;
	  ala: BAG OF attribute_language_assignment;
	END_LOCAL;
			
	IF (SIZEOF(translatable_attributes)=0) THEN
	  RETURN(UNKNOWN);
	END_IF;
			
	mlaa:= USEDIN ( ent , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS' );
			
	REPEAT i:=1 TO HIINDEX(mlaa);
	  IF NOT (mlaa[i].attribute_name IN translatable_attributes) THEN
		RETURN(FALSE);
	  END_IF;
	END_REPEAT;
			
	ala:= USEDIN ( ent , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' );
			
	REPEAT i:=1 TO HIINDEX(ala);
	  IF NOT (ala[i].attribute_name IN translatable_attributes) THEN
		RETURN(FALSE);
	  END_IF;
	END_REPEAT;
			
	RETURN(TRUE);
END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
 END_FUNCTION;

(* Implicit interfaced from: Catalog_data_information_mim *)
FUNCTION at_most_one_class_system (ent: GENERIC       ): LOGICAL;
RETURN(
  SIZEOF ( QUERY (ia <* USEDIN ( ent , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS' ) | 
	ia.role.name = 'class system membership' ) )<=1 );
END_FUNCTION;

(* Implicit interfaced from: Catalog_data_information_mim *)
FUNCTION at_most_one_version_id (ent: GENERIC       ): LOGICAL;
RETURN(
  SIZEOF ( QUERY ( ia <* USEDIN ( ent , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS' ) | 
	ia.role.name ='version' ) ) <=1 );
END_FUNCTION;
(* REFERENCE FROM (support_resource_schema); *)
FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
END_FUNCTION; 

(* Implicit interfaced from: geometry_schema *)
FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                 LIST [2:3] OF 
direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
 END_FUNCTION;
(* REFERENCE FROM (Single_part_representation_mim); *)
FUNCTION categories_of_product
 (obj : product) : SET OF STRING; 
LOCAL
category_assignments: BAG OF product_category;
categories: SET OF STRING:=[];
i: INTEGER;
END_LOCAL;
category_assignments := USEDIN(obj, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);
      END_FUNCTION; 

(* Implicit interfaced from: Classification_with_attributes_mim *)
FUNCTION class_assignment_is_valid (aia: applied_classification_assignment): BOOLEAN;
LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia.role;
IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
  IF(role.name <> 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
  IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;

  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);
END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION constraints_composite_curve_on_surface
               (c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

(* Implicit interfaced from: geometric_model_schema *)
 FUNCTION constraints_geometry_shell_based_surface_model
             (m: shell_based_surface_model): BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

(* Implicit interfaced from: geometric_model_schema *)
 FUNCTION constraints_geometry_shell_based_wireframe_model
                       (m : shell_based_wireframe_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                               knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
   FUNCTION constraints_rectangular_composite_surface
           (s : rectangular_composite_surface) : BOOLEAN;

   (* Check the surface types *)
     REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;
(* REFERENCE FROM (measure_schema); *)
FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; 

(* Implicit interfaced from: geometry_schema *)
FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);

END_FUNCTION;

(* Implicit interfaced from: measure_schema *)
FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; 

(* Implicit interfaced from: geometry_schema *)
 FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: External_properties_mim *)
FUNCTION external_version_assignment_is_valid (aia: applied_external_identification_assignment): BOOLEAN;
LOCAL
  item: identification_item;
  role: identification_role;
END_LOCAL;

role:= aia.role;
IF role.name='version' THEN
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to versionable types
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);

ELSE		-- case where aia does not convey a version id
  RETURN(TRUE);
END_IF;
END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

(* Implicit interfaced from: aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_curve
 (cv : representation_item) : BOOLEAN; 
  IF SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_CURVE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCLE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELLIPSE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg <* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) >= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

(* Implicit interfaced from: aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_point
 (pnt : point) : BOOLEAN; 
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

(* Implicit interfaced from: aic_geometrically_bounded_surface *)
FUNCTION gbsf_check_surface
 (sf : surface) : BOOLEAN; 
  IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SPHERICAL_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TOROIDAL_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_BOUNDED_SURFACE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_REPLICA' IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

(* Implicit interfaced from: geometry_schema *)
FUNCTION get_basis_surface (c : curve_on_surface) : SET[0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION;
(* REFERENCE FROM (basic_attribute_schema); *)
FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 
(* REFERENCE FROM (basic_attribute_schema); *)
FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;
END_FUNCTION; 
(* REFERENCE FROM (basic_attribute_schema); *)
FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 
(* REFERENCE FROM (basic_attribute_schema); *)
FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

(* Implicit interfaced from: Geometric_tolerance_mim *)
FUNCTION get_shape_aspect_property_definition_representations
 (s_a_instance : shape_aspect) : SET OF property_definition_representation; 
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) < 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr <* USEDIN(pd_set[i], 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);      
END_FUNCTION; 

(* Implicit interfaced from: Catalog_data_information_mim *)
FUNCTION item_correlation 
         (items : SET OF GENERIC       ; c_items: SET OF STRING): LOGICAL;
LOCAL
  c_types   : SET OF STRING := [];
  c_hit     : INTEGER := 0;
END_LOCAL;
 
REPEAT i:=1 TO HIINDEX(c_items);
  c_types := c_types + ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.' + c_items[i]];
END_REPEAT;

REPEAT i:=1 TO HIINDEX(items);
  IF (SIZEOF(c_types * TYPEOF(items[i])) = 1) THEN
    c_hit := c_hit + 1;
  END_IF;
END_REPEAT;

RETURN (SIZEOF(items) = c_hit);
END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

(* Implicit interfaced from: date_time_schema *)
FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION; 

(* Implicit interfaced from: topology_schema *)
 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                      low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION make_array_of_array(lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                              low1, u1, low2, u2 : INTEGER):
                 ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;
(* REFERENCE FROM (geometric_model_schema); *)
 FUNCTION msb_shells (brep: manifold_solid_brep) :
                          SET [1:?] OF  closed_shell;
 
     IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
       msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
 END_FUNCTION;

(* Implicit interfaced from: aic_manifold_surface *)
FUNCTION msf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)

(* complex subtypes of curve that are both bounded_curve and
   oneof conic, curve_replica, line, or offset_curve_3d are not
   valid
*)
IF SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.BOUNDED_CURVE',
  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC',
  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE',
  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
  RETURN(FALSE);
END_IF;

(* b_spline_curves shall not self-intersect
 *)
IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE

  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    (* a curve_replica shall reference a valid curve
     *)
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve)); 
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve)); 
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN 

            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);

                (* do for one or two associated_geometrys:
                 *)
                IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF; 
              END_REPEAT;  
              RETURN(TRUE);
            END_IF; 
          ELSE

            (* a polyline shall have at least 3 points
             *)
            IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
END_IF; 
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE); 
END_FUNCTION;

(* Implicit interfaced from: aic_manifold_surface *)
FUNCTION msf_surface_check (surf : surface) : BOOLEAN;

(* This function varifies the validity of a surface in the
   context of a manifold surface model.
*)

  (* elementary_surfaces are valid surface types
   *)
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                      : vector;
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag < 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);
 END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

(* Implicit interfaced from: Surface_conditions_mim *)
FUNCTION surface_condition_correlation (pd: property_definition; rep: representation): LOGICAL;

CASE pd.name OF
'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' : 
	RETURN(pd.name = rep.name);

OTHERWISE : RETURN(UNKNOWN);
END_CASE;

END_FUNCTION;

(* Implicit interfaced from: geometry_schema *)
 FUNCTION surface_weights_positive(b: rational_b_spline_surface) : BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

(* Implicit interfaced from: topology_schema *)
 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;
(* REFERENCE FROM (support_resource_schema); *)
FUNCTION type_check_function
 (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION; 

(* Implicit interfaced from: representation_schema *)
FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;
(* REFERENCE FROM (representation_schema); *)
FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;

(* Implicit interfaced from: aic_geometrically_bounded_2d_wireframe *)
FUNCTION valid_basis_curve_in_2d_wireframe
   (crv: curve) : BOOLEAN;
   -- check for valid basic curve types
  IF SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE',
               'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE',
               'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELLIPSE',
               'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE',
                   'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PARABOLA',
                   'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

(* Implicit interfaced from: date_time_schema *)
FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION; 

(* Implicit interfaced from: Geometric_tolerance_mim *)
FUNCTION valid_datum_target_parameters
 (pdf : placed_datum_target_feature) : BOOLEAN; 
LOCAL

rep_set : SET OF representation := [] ;

parameter_representations: SET OF representation;
END_LOCAL;


REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
rep_set := rep_set + pdf.representation_associations[i].used_representation;
END_REPEAT;
 
parameter_representations := QUERY(rep <* rep_set |
('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));


IF (SIZEOF( QUERY( srwp <* parameter_representations |
          (SIZEOF( QUERY( i <* srwp.items |
          (i.name='orientation') AND
          ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLACEMENT' IN TYPEOF(i)))) = 1))) <> 1) THEN
   RETURN(FALSE);
END_IF;

CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);

'circle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));

'line': RETURN(SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);

'rectangle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp <* parameter_representations |
               (SIZEOF( QUERY( i <* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
OTHERWISE : RETURN(FALSE);
END_CASE;
   END_FUNCTION; 

(* Implicit interfaced from: aic_geometrically_bounded_wireframe *)
FUNCTION valid_geometrically_bounded_wf_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELLIPSE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCLE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TRIMMED_CURVE' IN TYPEOF (crv) THEN 
 IF SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PARABOLA', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.HYPERBOLA' ] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
 END_IF ;
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (crv) THEN 
 RETURN ( SIZEOF ( 
QUERY ( ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve) )) = 0);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;

(* Implicit interfaced from: aic_geometrically_bounded_wireframe *)
FUNCTION valid_geometrically_bounded_wf_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;

(* Implicit interfaced from: representation_schema *)
FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

(* Implicit interfaced from: Part_occurrence_mim *)
FUNCTION valid_selected_instance_representation (pd: product_definition_or_assembly_relationship): LOGICAL;
LOCAL
  properties: SET OF property_definition := bag_to_set(QUERY( prd<* USEDIN ( pd ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION' ) | 
 (prd.name = 'occurrence selection' )));

  property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr <* USEDIN ( properties[1] , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	( pdr.used_representation.name = 'selection criteria' )));

  selected_representation: representation;
END_LOCAL;

IF (SIZEOF( properties)<>1) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF(property_definition_representations)<>1) THEN
	RETURN(FALSE);
END_IF;

selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;

IF (SIZEOF(selected_representation\representation.items) <1) OR (SIZEOF(selected_representation\representation.items) >2) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	( SIZEOF (['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
			'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
 	( i.name = 'selection quantity' ))) <> 1 ) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	( i.name = 'selection control' )))> 1) THEN
	RETURN(FALSE);
END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
 	( i.name = 'selection control' ) ))= 0) AND 
   (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
		'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	RETURN(FALSE);
END_IF;
	
RETURN(TRUE);
END_FUNCTION;

(* Implicit interfaced from: date_time_schema *)
FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; 

(* Implicit interfaced from: measure_schema *)
FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; 

(* Implicit interfaced from: aic_edge_based_wireframe *)
FUNCTION valid_wireframe_edge_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONIC', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.B_SPLINE_CURVE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;

(* Implicit interfaced from: aic_edge_based_wireframe *)
FUNCTION valid_wireframe_vertex_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;

(* Implicit interfaced from: Inertia_characteristics_mim *)
FUNCTION value_range_aggregate_rep_item (agg : AGGREGATE OF representation_item) : BOOLEAN; 
  BEGIN 
  IF (SIZEOF(QUERY(i1 <* agg | ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
	  RETURN (TRUE); 
   ELSE 
	RETURN (FALSE); 
   END_IF; 
   END; 
END_FUNCTION; 

(* Implicit interfaced from: Extended_measure_representation_mim *)
FUNCTION value_range_wr1
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 <* agg | (
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

(* Implicit interfaced from: Extended_measure_representation_mim *)
FUNCTION value_range_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY (i <* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i <* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

(* Implicit interfaced from: Extended_measure_representation_mim *)
FUNCTION value_range_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY(i1 <* agg |
('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 <* agg |
('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
(i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;
      END_FUNCTION; 

(* Implicit interfaced from: geometry_schema *)
 FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

(* Implicit interfaced from: Alternative_solution_mim *)
RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
LOCAL
  solution_versions: SET OF product_definition_formation := [];
END_LOCAL;
  solution_versions :=  QUERY( pdf <* product_definition_formation |
	SIZEOF( QUERY( prpc <* USEDIN(pdf.of_product, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name = 'alternative solution')) = 1);
WHERE 
WR1: SIZEOF( QUERY( pdf <* solution_versions |
SIZEOF( QUERY( pd <* USEDIN(pdf, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION.FORMATION') | 
 pd.frame_of_reference.name = 'alternative definition')) <> 1))= 0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE approval_person_organization_requires_date_time 
    FOR (approval_person_organization);
WHERE
WR1: SIZEOF ( QUERY ( apo <* approval_person_organization | (
     SIZEOF ( QUERY ( u <* USEDIN ( apo , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_DATE_ASSIGNMENT.ITEMS' ) | 
	( u.role.name =  'sign off' ) ) ) + 
   SIZEOF ( QUERY ( u <* USEDIN ( apo , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' ) | 
	( u.role.name =  'sign off' ) ) ) ) <>1 ) ) =  0;
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE approval_requires_approval_assignment FOR (approval);
WHERE
WR1: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF(USEDIN( a, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL' )) =  0 )) =  0;
END_RULE;

(* Implicit interfaced from: Specification_control_mim *)
RULE breakdown_element_requires_product_definition FOR 
	(product_definition_formation);
WHERE
WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
     ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name =  'functionality' ) ) =  1 ) AND 
	( SIZEOF ( QUERY ( pd <* USEDIN ( pdf ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	pd.frame_of_reference.name =  'functional definition' ) ) <1 ) ) ) =  0;
WR2: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
     ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
     prpc.name =  'conceptual design' ) ) =  1 ) AND 
     ( SIZEOF (QUERY ( pd <* USEDIN ( pdf , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION.FORMATION' ) | 
     pd.frame_of_reference.name =  'conceptual definition' ) ) <1) ) ) =  0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
(* Name in originating schema: SUBTYPE_EXCLUSIVENESS_REPRESENTATION *)
RULE Catalog_data_information_and_shape_representation_mim_dot_subtype_exclusiveness_representation  FOR (representation); 
WHERE 
WR1: SIZEOF(QUERY (r <* representation | 
NOT (type_check_function(r, 
['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CONSTRUCTIVE_GEOMETRY_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CONTACT_RATIO_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DEFAULT_TOLERANCE_TABLE', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DEFINITIONAL_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DIRECTION_SHAPE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.HARDNESS_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MOMENTS_OF_INERTIA_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SHAPE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SURFACE_TEXTURE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.TACTILE_APPEARANCE_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.TEXT_STRING_REPRESENTATION', 
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VISUAL_APPEARANCE_REPRESENTATION'] , 3 ) 
))) = 0; 
END_RULE; 

(* Implicit interfaced from: Extended_measure_representation_mim *)
(* Name in originating schema: SUBTYPE_EXCLUSIVENESS_REPRESENTATION_ITEM *)
RULE Catalog_data_information_and_shape_representation_mim_dot_subtype_exclusiveness_representation_item  FOR 
(representation_item);
WHERE
  WR1: SIZEOF(QUERY (cri <* representation_item | NOT (type_check_function(cri,['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM','CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VALUE_REPRESENTATION_ITEM','CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
END_RULE; 

(* Implicit interfaced from: Extended_measure_representation_mim *)
(* Name in originating schema: SUBTYPE_EXCLUSIVENESS_REPRESENTATION_ITEM *)
RULE Catalog_data_information_mim_dot_subtype_exclusiveness_representation_item  FOR 
(representation_item);
WHERE
  WR1: SIZEOF(QUERY (cri <* representation_item | NOT (type_check_function(cri,['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MEASURE_REPRESENTATION_ITEM','CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.VALUE_REPRESENTATION_ITEM','CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
END_RULE; 

(* Implicit interfaced from: geometry_schema *)
RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

(* Implicit interfaced from: Specification_control_mim *)
RULE constraint_definition_requires_constraint_category FOR (product_definition);
LOCAL
  constraint_definitions: SET OF product_definition := [];
END_LOCAL;
  constraint_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'design constraint definition'));
WHERE
WR1: SIZEOF ( QUERY ( pd <* constraint_definitions | 
	( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc. name ='requirement' ) ) =0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_derived_unit FOR
    (derived_unit);
WHERE
 WR1: SIZEOF ( QUERY ( d <* derived_unit | NOT ( SIZEOF ( USEDIN
     ( d , '' ) ) >0 ) ) ) =0;
END_RULE;

RULE dependent_instantiable_dimensional_size FOR
    (dimensional_size);
WHERE
 WR1: SIZEOF ( QUERY ( d <* dimensional_size | NOT ( SIZEOF (
     USEDIN ( d , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_document_usage_role FOR
    (document_usage_role);
WHERE
 WR1: SIZEOF ( QUERY ( d <* document_usage_role | NOT ( SIZEOF (
     USEDIN ( d , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_measure_with_unit FOR
    (measure_with_unit);
WHERE
 WR1: SIZEOF ( QUERY ( m <* measure_with_unit | NOT ( SIZEOF (
     USEDIN ( m , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_named_unit FOR
    (named_unit);
WHERE
 WR1: SIZEOF ( QUERY ( n <* named_unit | NOT ( SIZEOF ( USEDIN (
     n , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_precision_qualifier FOR
    (precision_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( p <* precision_qualifier | NOT ( SIZEOF (
     USEDIN ( p , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_product_definition_context_role FOR
    (product_definition_context_role);
WHERE
 WR1: SIZEOF ( QUERY ( p <* product_definition_context_role |
     NOT ( SIZEOF ( USEDIN ( p , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_standard_uncertainty FOR
    (standard_uncertainty);
WHERE
 WR1: SIZEOF ( QUERY ( s <* standard_uncertainty | NOT ( SIZEOF
     ( USEDIN ( s , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_time_interval_role FOR (time_interval_role);
WHERE
WR1: SIZEOF ( QUERY ( t <* time_interval_role | NOT (
     SIZEOF ( USEDIN ( t , '' ) ) >0 ) ) ) =  0;
END_RULE;

RULE dependent_instantiable_tolerance_value FOR
    (tolerance_value);
WHERE
 WR1: SIZEOF ( QUERY ( t <* tolerance_value | NOT ( SIZEOF (
     USEDIN ( t , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_type_qualifier FOR
    (type_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( t <* type_qualifier | NOT ( SIZEOF (
     USEDIN ( t , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dependent_instantiable_uncertainty_qualifier FOR
    (uncertainty_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( u <* uncertainty_qualifier | NOT ( SIZEOF
     ( USEDIN ( u , '' ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Specification_control_mim *)
RULE design_constraint_requires_product_definition 
    FOR (product_definition_formation);
WHERE
WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | (
     SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name =  'requirement' ) ) >0 ) AND 
     ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION.FORMATION') | 
	pd.frame_of_reference.name = 'design constraint definition' ) ) <1 ) ) ) =  0;
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE dimensionality_is_two_or_three FOR
    (geometric_representation_context);
WHERE
 WR1: SIZEOF ( QUERY ( g <* geometric_representation_context |
     NOT ((g.coordinate_space_dimension =2 ) OR (g.coordinate_space_dimension =3 )))) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE event_occurrence_requires_event_occurrence_assignment FOR
    (event_occurrence);
WHERE
 WR1: SIZEOF ( QUERY ( eo <* event_occurrence | 
	( SIZEOF (USEDIN ( eo, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.RELATIVE_EVENT_OCCURRENCE.BASE_EVENT' ) ) =0 ) AND 
	( SIZEOF ( USEDIN ( eo ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EVENT_OCCURRENCE_ASSIGNMENT.ASSIGNED_EVENT_OCCURRENCE' ) ) =0 )) ) =0;
END_RULE;

(* Implicit interfaced from: External_properties_mim *)
RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia <* applied_external_identification_assignment | 
		NOT external_version_assignment_is_valid(aia)))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE externally_defined_class_with_known_source_requirement FOR 
	(externally_defined_class);
LOCAL
   known_sourced_classes : SET OF externally_defined_class;
END_LOCAL;
  known_sourced_classes := QUERY( edc <* externally_defined_class | 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE
WR1: SIZEOF ( QUERY ( edc <* known_sourced_classes | 
   (SIZEOF ( QUERY ( aoa <* USEDIN ( edc ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' )
     | aoa.role.name =  'class supplier' )) =  0 ))) =  0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE global_length_and_angle_units_2d_or_3d FOR
    (global_unit_assigned_context);
WHERE
WR1: SIZEOF ( QUERY ( guac <* global_unit_assigned_context |
     SIZEOF ( guac. units ) <2 ) ) =0;
WR2: SIZEOF ( QUERY ( guac <* global_unit_assigned_context | (
     SIZEOF ( QUERY ( x <* guac. units | 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LENGTH_UNIT' IN TYPEOF ( x ) ) ) <>1 ) OR 
    ( SIZEOF(QUERY( x <* guac. units | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PLANE_ANGLE_UNIT' IN TYPEOF(x))) <>1 ))) =0;
END_RULE;

(* Implicit interfaced from: Surface_conditions_mim *)
RULE material_for_coating_layer FOR (shape_aspect);
LOCAL
  coating_layers: SET OF shape_aspect := [];
END_LOCAL;
  coating_layers:= QUERY( r <* shape_aspect | 
		(r.name = 'coating layer') );
WHERE 
WR1: SIZEOF( QUERY( r <* coating_layers |
	SIZEOF(USEDIN(r , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.MATERIAL_DESIGNATION.DEFINITIONS'))<>1
	)) = 0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE person_requires_person_and_organization FOR (person);
WHERE
WR1: SIZEOF ( QUERY ( p <* person | 
	SIZEOF ( USEDIN ( p ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PERSON_AND_ORGANIZATION.THE_PERSON' )) =  0 )) =  0;
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE plib_class_reference_requires_version FOR (externally_defined_class); 
LOCAL
   known_sourced_classes : SET OF externally_defined_class;
END_LOCAL;
  known_sourced_classes := QUERY( edc <* externally_defined_class | 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE 
WR1: SIZEOF( QUERY( edc <* known_sourced_classes | 
  (SIZEOF( QUERY( aei <* USEDIN(edc,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
	aei.role.name = 'version' )) <> 1) )) = 0; 
WR2: SIZEOF( QUERY( edc <* known_sourced_classes | 
  (SIZEOF( QUERY( aei <* USEDIN(edc,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
	aei.role.name = 'version' )) > 0) )) = 0; 
END_RULE; 

(* Implicit interfaced from: External_properties_mim *)
RULE plib_property_reference_requires_name_scope FOR (
      externally_defined_general_property);
LOCAL
   known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
  known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
WHERE
WR1: SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
   ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
	( edir.name =  'name scope' ) AND 
      ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
      ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
END_RULE; 

(* Implicit interfaced from: External_properties_mim *)
RULE plib_property_reference_requires_version FOR (externally_defined_general_property); 
	LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	plib_properties := QUERY ( edgp <* externally_defined_general_property | 
		( 'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' + '\PRE_DEFINED_ITEM.NAME' = 'ISO 13584 library' ) ); 
	WHERE 
	WR1: SIZEOF( QUERY( edgp <* plib_properties | 
		(SIZEOF( QUERY( edir <* USEDIN(edgp, 'EXTERNAL_PROPERTIES_MIM' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
		(edir.role.name = 'version') )) <> 1) )) = 0; 
END_RULE;

(* Implicit interfaced from: Product_class_mim *)
RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( pcf <* product_concept_feature |
(SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND 
(SIZEOF ( QUERY ( aga <* USEDIN ( pcf , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | 
( aga.role.name = 'specification category member' ) AND 
('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) <>1 ) ) ) = 0;
END_RULE;

(* Implicit interfaced from: Item_definition_structure_mim *)
RULE product_definition_replacement_requires_effectivity_assignment FOR 
	(product_definition_relationship);
WHERE 
WR1: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'definition replacement') AND 
	(SIZEOF( USEDIN(pdr,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
	 = 0; 
END_RULE; 

(* Implicit interfaced from: Alternative_solution_mim *)
RULE restrict_alternative_definition FOR (product_definition);
LOCAL
  solution_definitions: SET OF product_definition := [];
END_LOCAL;
  solution_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'alternative definition'));
WHERE
WR1: SIZEOF ( QUERY ( pd <* solution_definitions | 
	( SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	pdr.name = 'solution alternative definition' ) ) <>1 ) ) ) = 0;
WR2: SIZEOF ( QUERY ( pd <* solution_definitions | 
	NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0;
WR3: SIZEOF ( QUERY ( pd <* solution_definitions | 
	( pd.name IN ['supplier' , 'technical supplier'] ) AND (
	SIZEOF ( QUERY ( aoa <* USEDIN ( pd.formation ,
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | 
	aoa.role.name = 'supplier' )) <>1 ) )) = 0;
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_applied_event_occurrence_assignment FOR
    (applied_event_occurrence_assignment);
WHERE
WR1: SIZEOF ( QUERY ( eo <* applied_event_occurrence_assignment| 
	( eo\event_occurrence_assignment.role.name ='event context' ) AND 
	( SIZEOF ( eo.items ) >1 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_applied_organizational_project_assignment FOR
    (applied_organizational_project_assignment);
WHERE
WR1: SIZEOF ( QUERY ( aopa <* applied_organizational_project_assignment | 
	( aopa.role.name = 'affecting project' ) AND 
	NOT item_correlation( aopa. items , 
	['PRODUCT_CONCEPT', 'PRODUCT', 'PRODUCT_DEFINITION', 'PRODUCT_DEFINITION_FORMATION'] ) ) ) =0;
WR2: SIZEOF ( QUERY ( aopa <* applied_organizational_project_assignment | 
	( aopa.role.name = 'work program' ) AND 
	NOT item_correlation (aopa.items , ['EXECUTED_ACTION'] ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_approval FOR
    (approval,
     approval_date_time);
WHERE
 WR1: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( USEDIN ( a , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) ) >2 ) ) =0;
 WR2: SIZEOF ( QUERY ( adt <* approval_date_time | 
	( NOT EXISTS( adt.role ) ) OR 
	( NOT ( adt.role.name IN ['actual' , 'planned'] ) ) ) ) =0;
 WR3: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( QUERY ( adt <* USEDIN ( a , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) | 
	adt.role.name ='actual' ) ) >1 ) ) =0;
 WR4: SIZEOF ( QUERY ( a <* approval | 
	SIZEOF ( QUERY ( adt <* USEDIN ( a , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPROVAL_DATE_TIME.DATED_APPROVAL' ) | 
	adt.role.name ='planned' ) ) >1 ) ) =0;
END_RULE;

(* Implicit interfaced from: Item_definition_structure_mim *)
RULE restrict_assembly_category FOR (product_definition);
LOCAL
  assembly_definitions: SET OF product_definition := [];
END_LOCAL;
  assembly_definitions :=  QUERY( pd <* product_definition | 
    SIZEOF( QUERY( pdca <* USEDIN( pd, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
    pdca.frame_of_reference.name= 'assembly definition')) > 0 );
WHERE
WR1: SIZEOF( QUERY( pd <* assembly_definitions | 
   NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

(* Implicit interfaced from: Inertia_characteristics_mim *)
RULE restrict_centre_of_mass_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( r <* representation | 
	( r.name ='centre of mass' ) AND 
	( ( SIZEOF ( r.items ) <>1 ) OR 
	(SIZEOF ( QUERY ( i <* r.items | 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.POINT' IN TYPEOF ( i ) ) AND 
	( i.name = 'centre point' ) )) <>1 ) ) ) ) 
	=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_approval_status FOR
    (approval_status);
WHERE
WR1: SIZEOF ( QUERY ( ent <* approval_status |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_class FOR
    (class);
WHERE
WR1: SIZEOF ( QUERY ( c <* class | 
	SIZEOF ( QUERY ( aca <* USEDIN ( c , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CLASSIFICATION_ASSIGNMENT.ASSIGNED_CLASS' ) | 
	( ( aca.role.name ='class system membership' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT' IN TYPEOF ( aca ) ) ) ) ) >1 ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_descriptive_representation_item FOR
    (descriptive_representation_item);
WHERE
WR1: SIZEOF ( QUERY ( ent <* descriptive_representation_item |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_document_type FOR
    (document_type);
WHERE
WR1: SIZEOF ( QUERY ( ent <* document_type | 
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_planar_extent FOR
 (planar_extent);
WHERE
WR1: SIZEOF ( QUERY ( pe <* planar_extent | 
				( pe\representation_item.name = 'size format' ) AND 
				NOT at_most_one_class_system(pe) ))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_class_system_assignment_for_security_classification_level FOR
    (security_classification_level);
WHERE
WR1: SIZEOF ( QUERY ( ent <* security_classification_level |
	NOT at_most_one_class_system(ent) ))=0; 
END_RULE;

(* Implicit interfaced from: Classification_with_attributes_mim *)
RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE;

(* Implicit interfaced from: Part_collection_mim *)
RULE restrict_collection_category FOR (product_definition);
LOCAL
  collection_definitions: SET OF product_definition := [];
END_LOCAL;
  collection_definitions :=  QUERY( pd <* product_definition | 
  SIZEOF( QUERY( pdca <* USEDIN( pd, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
  pdca.frame_of_reference.name= 'collection definition')) > 0 );
WHERE
WR1: SIZEOF( QUERY( pd <* collection_definitions | 
	NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

(* Implicit interfaced from: Product_class_mim *)
RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
	WR1: SIZEOF ( QUERY ( cfo <* concept_feature_operator | NOT
		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0;
	WR2: SIZEOF ( QUERY ( cfo <* concept_feature_operator | (cfo.name = 'implication' ) AND
	 ( SIZEOF ( QUERY (cfrwc <* USEDIN ( cfo , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
	'CONDITIONAL_OPERATOR' ) | 
		SIZEOF ( QUERY ( ccf <* USEDIN( cfrwc , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | 
		NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) >0 )) >0 ))) = 0;
	WR3: SIZEOF( QUERY (cfo <* concept_feature_operator | (cfo.name = 'not')
	AND (SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | 
		cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature)) >0 ))) = 0;
END_RULE;	

(* Implicit interfaced from: Specification_control_mim *)
RULE restrict_configuration_design_for_class_breakdown_association FOR
    (configuration_design);
WHERE
WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name ='functionality' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR 
	( cd.design\product_definition.frame_of_reference.name<> 'functional definition' ) ) 
	) ) =0;
WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name='realization' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	( cd.design\product_definition.frame_of_reference.name<> 'conceptual definition' ) ) 
	) ) =0;
WR3: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd.name IN ['functionality' , 'realization'] ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) 
	) ) =0;
END_RULE;

(* Implicit interfaced from: Specification_control_mim *)
RULE restrict_configuration_design_for_design_constraint FOR (configuration_design); 
WHERE 
WR1: SIZEOF ( QUERY (cd <* configuration_design | 
	(cd.name = 'design constraint usage') AND 
	(NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	(cd.design\product_definition.frame_of_reference.name <> 'design constraint definition')))) = 0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_configuration_design_for_specified_individual FOR
    (configuration_design);
WHERE
WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd. name ='physical instance basis' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
	( cd. design\product_definition.frame_of_reference.name<> 'physical occurrence' ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
	( cd. name ='physical instance basis' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_IDENTIFICATION' IN TYPEOF (cd.configuration ) ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_date_assignment FOR 
	(applied_date_assignment);
WHERE
WR1: SIZEOF(QUERY(adr <* applied_date_assignment |
  (adr.role.name = 'actual end') AND
   (NOT  item_correlation (adr.items, ['ORGANIZATIONAL_PROJECT', 'EFFECTIVITY'])) 
	))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_document_reference FOR 
	(applied_document_reference);
WHERE
WR1: SIZEOF(QUERY(adr <* applied_document_reference |
 (adr.role.name = 'general tolerance definition') AND 
 (NOT item_correlation (adr.items, ['REPRESENTATION']))
	))=0; 
WR2: SIZEOF(QUERY(adr <* applied_document_reference |
  NOT ((adr.role.name = 'general tolerance definition') OR 
   item_correlation (adr.items, 
	['APPROVAL','CERTIFICATION','CLASS',
	'CLASS_SYSTEM','CONFIGURATION_DESIGN', 
	'CONFIGURATION_ITEM','CONTRACT',
	'GENERAL_PROPERTY','MATERIAL_DESIGNATION', 
	'ORGANIZATION','ORGANIZATIONAL_PROJECT',
	'PERSON','PRODUCT_CONCEPT',
	'PRODUCT_CONCEPT_FEATURE', 'PRODUCT_CONCEPT_FEATURE_CATEGORY',
	'PRODUCT_DEFINITION','PRODUCT_DEFINITION_FORMATION',
	'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP','PRODUCT_DEFINITION_RELATIONSHIP', 
	'PRODUCT_DEFINITION_SUBSTITUTE','PRODUCT_RELATED_PRODUCT_CATEGORY',
	'PROPERTY_DEFINITION', 'REPRESENTATION',
	'SECURITY_CLASSIFICATION','SHAPE_ASPECT', 'SHAPE_ASPECT_RELATIONSHIP']))
	))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_effectivity_assignment_for_class_category_usage FOR 
	(applied_effectivity_assignment);
WHERE
WR1: SIZEOF( QUERY( aea <* applied_effectivity_assignment |
      ((SIZEOF( QUERY( i <* aea.items |
      ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) > 0) AND 
	((SIZEOF( QUERY( i <* aea.items |
      ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) <> SIZEOF(aea.items)) OR
      (SIZEOF(TYPEOF(aea.assigned_effectivity) * 
      ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DATED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LOT_EFFECTIVITY',
       'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']) > 0) OR
      (aea.assigned_effectivity.id <> 'class usage') OR
      (SIZEOF( QUERY ( cueca <* USEDIN(aea,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') |
      'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF (cueca ) )) = 0)) ))) = 0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_effectivity_for_effectivity_relationship FOR
    (effectivity_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( er <* effectivity_relationship | 
	( SIZEOF
     ( ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LOT_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']*TYPEOF( er.relating_effectivity ) ) >0 ) OR 
	( SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LOT_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SERIAL_NUMBERED_EFFECTIVITY' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY']*TYPEOF( er.related_effectivity ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_effectivity_usage FOR (effectivity); 
LOCAL
  other_effectivities : SET OF effectivity ;
END_LOCAL;
  other_effectivities := QUERY( e <* effectivity | 
	(SIZEOF(['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DATED_EFFECTIVITY', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY'] * TYPEOF(e)) =  0));
WHERE 
WR1: SIZEOF( QUERY( e <* other_effectivities | 
	( (SIZEOF( QUERY( er <* USEDIN(e,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY') | 
		er.name = 'inheritance' )) = 0) 
       OR
	  ((e.id = 'configuration validity') AND 
	  (SIZEOF( QUERY ( cea <* USEDIN(e,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY') | 
		'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF ( cea) ) ) = 0)) 
       OR
	  ((e.id = 'class usage') AND 
	  (SIZEOF( QUERY( aea <* USEDIN(e,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY') | 
		('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF ( aea ) ) AND 
		(SIZEOF( QUERY( i <* aea.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i) )) > 0) )) = 0))) 
	)) = 0; 
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_external_identification_assignment FOR 
	(applied_external_identification_assignment);
WHERE
WR1: SIZEOF(QUERY(aeia <* applied_external_identification_assignment |
   (aeia.role.name = 'alternative document id and location') AND 
   (NOT item_correlation (aeia.items, ['DOCUMENT_FILE']))))=0; 
WR2: SIZEOF(QUERY(aeia <* applied_external_identification_assignment |
   (aeia.role.name = 'version') AND 
   (NOT item_correlation (aeia.items, ['EXTERNALLY_DEFINED_CLASS', 'EXTERNALLY_DEFINED_GENERAL_PROPERTY']))
	))=0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_externally_defined_item_relationship FOR
    (externally_defined_item_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( edir <* externally_defined_item_relationship | 
	( edir. name = 'name scope' ) AND 
	( NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY' IN TYPEOF ( edir.relating_item ) ) OR 
	NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir. relating_item.source ) )
     OR 
	NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' IN TYPEOF ( edir. related_item ) ) OR 
	NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_group_assignment FOR 
	(applied_group_assignment);
WHERE
WR2: SIZEOF(QUERY(aeia <* applied_group_assignment |
 (aeia.role.name = 'group membership') AND
  (NOT item_correlation (aeia.items, ['GEOMETRIC_REPRESENTATION_ITEM', 'SHAPE_ASPECT'])) 
	))=0; 
WR3: SIZEOF(QUERY(aeia <* applied_group_assignment |
 (aeia.role.name = 'group membership') AND
 (NOT  ((SIZEOF(aeia.items) = SIZEOF( QUERY( i <* aeia.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(i)))) OR 
  (SIZEOF(aeia.items) = SIZEOF( QUERY( i <* aeia.items | 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SHAPE_ASPECT' IN TYPEOF(i)))))) 
	))=0; 
END_RULE;

(* Implicit interfaced from: Classification_with_attributes_mim *)
RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship); 
WHERE 
WR1: SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'class hierarchy') AND 
  (NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CLASS' IN TYPEOF(gr.related_group)) OR 
  NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CLASS' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

(* Implicit interfaced from: Product_class_mim *)
RULE restrict_group_relationship_for_specification_category FOR (group_relationship); 
WHERE 
WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'specification category hierarchy') AND 
  (NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) 
  OR NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

(* Implicit interfaced from: Multi_linguism_mim *)
RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_alternate_product_relationship FOR
    (alternate_product_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* alternate_product_relationship |
	NOT allowed_translations (ent, ['basis']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_application_context FOR
    (application_context);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* application_context | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_approval_relationship FOR
    (approval_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* approval_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_assembly_component_usage_substitute FOR
    (assembly_component_usage_substitute);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* assembly_component_usage_substitute | 
	NOT allowed_translations (ent, ['definition']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_certification FOR
    (certification);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* certification | 
	NOT allowed_translations (ent, ['purpose', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_configuration_design FOR
    (configuration_design);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* configuration_design | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_configuration_item FOR
    (configuration_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* configuration_item | 
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_contract FOR
    (contract);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* contract | 
	NOT allowed_translations (ent, ['purpose']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_data_environment FOR
    (data_environment);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* data_environment | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_date_role FOR
    (date_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* date_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_date_time_role FOR
    (date_time_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* date_time_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_descriptive_representation_item FOR
    (descriptive_representation_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* descriptive_representation_item |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_document_relationship FOR
    (document_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* document_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_effectivity FOR
    (effectivity);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* effectivity | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_effectivity_relationship FOR
    (effectivity_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* effectivity_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_event_occurrence FOR
    (event_occurrence);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* event_occurrence | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_external_source FOR
    (external_source);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* external_source | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_general_property FOR
    (general_property);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* general_property | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_general_property_relationship FOR
    (general_property_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* general_property_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_geometric_representation_item FOR
    (geometric_representation_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* geometric_representation_item |
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

RULE restrict_multi_language_for_geometric_tolerance FOR
    (geometric_tolerance);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* geometric_tolerance | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_group FOR
    (group);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* group | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_group_relationship FOR
    (group_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* group_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_identification_role FOR
    (identification_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* identification_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_mapped_item FOR
    (mapped_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* mapped_item | 
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_organization_relationship FOR
    (organization_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organization_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_organization_role FOR
    (organization_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organization_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_organizational_project FOR
    (organizational_project);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organizational_project | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_organizational_project_relationship FOR
    (organizational_project_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* organizational_project_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_person_and_organization_role FOR
    (person_and_organization_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* person_and_organization_role |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product FOR
    (product);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_concept FOR
    (product_concept);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_concept_feature FOR
    (product_concept_feature);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_feature | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_concept_feature_association FOR
    (product_concept_feature_association);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_feature_association | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_concept_relationship FOR
    (product_concept_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_concept_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_definition FOR
    (product_definition);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_definition_formation FOR
    (product_definition_formation);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_formation |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_definition_formation_relationship FOR
    (product_definition_formation_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <*
     product_definition_formation_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_definition_relationship FOR
    (product_definition_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_definition_substitute FOR
    (product_definition_substitute);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_definition_substitute |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_product_related_product_category FOR
    (product_related_product_category);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* product_related_product_category |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_property_definition FOR
    (property_definition);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* property_definition | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* representation | 
	NOT allowed_translations (ent, ['description', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_representation_relationship FOR
    (representation_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* representation_relationship |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_security_classification FOR
    (security_classification);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* security_classification | 
	NOT allowed_translations (ent, ['purpose', 'name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_shape_aspect FOR
    (shape_aspect);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* shape_aspect | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_shape_aspect_relationship FOR
    (shape_aspect_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* shape_aspect_relationship | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_time_interval_role FOR
    (time_interval_role);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* time_interval_role | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

RULE restrict_multi_language_for_topological_representation_item FOR
    (topological_representation_item);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* topological_representation_item |
	NOT allowed_translations (ent, ['name']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_uncertainty_measure_with_unit FOR
    (uncertainty_measure_with_unit);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* uncertainty_measure_with_unit |
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_multi_language_for_uncertainty_qualifier FOR
    (uncertainty_qualifier);
WHERE
 WR1: SIZEOF ( QUERY ( ent <* uncertainty_qualifier | 
	NOT allowed_translations (ent, ['description']) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_name_for_known_source FOR (known_source); 
WHERE 
WR1: SIZEOF( QUERY( ks <* known_source | (ks.name <> 'ISO 13584 library') )) = 0; 
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_organization_assignment FOR
	(applied_organization_assignment);
WHERE
WR1: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'organization in contract') AND 
  (NOT item_correlation (aoa.items, ['CONTRACT'])) 
	))= 0;
WR2: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'signing for contract') AND 
  (NOT item_correlation (aoa.items, ['APPLIED_ORGANIZATION_ASSIGNMENT'])) 
	))= 0;
WR3: SIZEOF(QUERY(aoa <* applied_organization_assignment |
  (aoa.role.name = 'validity context') AND
  (NOT item_correlation (aoa.items, ['PROPERTY_DEFINITION'])) 
	))= 0;
WR4: SIZEOF(QUERY(aoa <* applied_organization_assignment |
 (aoa.role.name = 'alias scope') AND 
  (NOT  item_correlation (aoa.items, ['APPLIED_IDENTIFICATION_ASSIGNMENT']))
	))= 0;
END_RULE;

(* Implicit interfaced from: Part_occurrence_mim *)
RULE restrict_part_occurrence FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := QUERY(pd <* product_definition | 
	( pd.frame_of_reference.name = 'part occurrence' ));
END_LOCAL;
WHERE
WR1: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( NOT( pd.name IN 
['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
WR2: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	(SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	pdr.name = 'definition usage' ) ) <>1 ) AND 
	( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
	( cd.name = 'occurrence usage definition' ) AND 
	( NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
WR3: SIZEOF ( QUERY ( pd <* part_occurrences |  
	(SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
 	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
 	( SIZEOF ( USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
WR4: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'selected instance' ) AND 
	NOT valid_selected_instance_representation(pd) ))=0;
WR5: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	( pd.name = 'quantified instance' ) AND 
	( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION' ) |
 	( ppd.name ='occurrence quantity' ) AND 
	( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
	pdr.used_representation.name = 'quantity' ) AND 
	(SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
 	(SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
	('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
	( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
WR6: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'specified instance' ) AND 
	( SIZEOF ( QUERY (
pdor <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
END_RULE;

(* Implicit interfaced from: Part_occurrence_mim *)
RULE restrict_part_occurrence_category FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := QUERY( pd <* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));
END_LOCAL;
WHERE
WR1: SIZEOF( QUERY( pd <* part_occurrences | 
(SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
  prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_person_and_organization_assignment FOR
	(applied_person_and_organization_assignment);
WHERE
WR1: SIZEOF(QUERY(aoa <* applied_person_and_organization_assignment |
 (aoa.role.name = 'signing for contract') AND
    (NOT item_correlation (aoa.items, ['APPLIED_ORGANIZATION_ASSIGNMENT']))
	))= 0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_categories_for_tool_part_relationship FOR
    (product_definition_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name = 'tool part relationship' ) AND 
	( ( SIZEOF (QUERY ( prpc <* USEDIN ( pdr.relating_product_definition.formation.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='tool') ) <1 ) OR 
	( SIZEOF ( QUERY (prpc <* USEDIN ( pdr. related_product_definition.formation.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name ='part') ) <1 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_category_for_product FOR (product); 
WHERE 
WR1: SIZEOF(QUERY(p <* product | 
  SIZEOF(QUERY(prpc <* USEDIN(p, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
   prpc.name IN ['part','document','functionality', 'conceptual product','alternative solution','requirement', 'physically realized product','tool','raw material'] ) ) 
	<> 1 )) = 0; 
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_definition_context_for_external_properties FOR
    (product_definition);
WHERE
WR1: SIZEOF ( QUERY (pd <* product_definition | 
	(SIZEOF (QUERY ( propd <* USEDIN ( pd, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' ) | 
	  SIZEOF ( QUERY (gpa <* USEDIN ( propd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION' )| 
	  'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY' IN TYPEOF (gpa.base_definition ) ) ) > 0 ) ) > 0 ) AND 
	  ( SIZEOF (QUERY ( pdca <* USEDIN ( pd, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION' )| 
		(pdca.frame_of_reference.name = 'external') AND
      	(pdca.role.name = 'external') ) ) = 0 ) ) ) = 0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_definition_context_for_product FOR
    (product_definition);
WHERE
WR2: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name = 'functional definition' ) AND 
	(SIZEOF ( QUERY ( prpc <* USEDIN ( pd. formation.of_product,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='functionality' ) ) =0 ) ) ) =0;
WR3: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name = 'conceptual definition' ) AND 
	(SIZEOF ( QUERY ( prpc <* USEDIN ( pd. formation.of_product,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
 	prpc.name = 'conceptual product' ) ) =0 ) ) ) =0;
WR7: SIZEOF ( QUERY ( pd <* product_definition | 
	( pd.frame_of_reference.name IN ['physical document definition',
	'digital document definition',
	'physical model_occurrence'] ) AND 
	( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	prpc.name ='document' ) ) =0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_definition_substitute FOR
    (product_definition_substitute);
WHERE
WR1: SIZEOF ( QUERY ( pds <* product_definition_substitute | 
	(SIZEOF ( USEDIN ( pds ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS' ) ) =0 ) ) ) =0;
WR2: SIZEOF ( QUERY ( pds <* product_definition_substitute |
     pds.substitute_definition.frame_of_reference.name <> 'part occurrence' ) ) =0;
WR3: SIZEOF ( QUERY ( pds <* product_definition_substitute | (
     ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( pds.context_relationship ) ) AND 
     ( SIZEOF (USEDIN ( pds.context_relationship , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE_USAGE' ) ) =0 ) ) AND 
	(( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF ( pds.context_relationship ) ) AND 
	( pds.context_relationship.related_product_definition.frame_of_reference.name <> 'part occurrence' ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Alternative_solution_mim *)
RULE restrict_product_definitions_for_base_element FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'solution alternative definition' ) AND 
	( NOT( pdr. relating_product_definition.frame_of_reference.name
     IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'alternative definition' ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Part_collection_mim *)
RULE restrict_product_definitions_for_collection FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'collection membership' ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name<>'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' ) OR 
	( SIZEOF ( QUERY ( pdca <* USEDIN (pdr.relating_product_definition ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | 
	( pdca.role.name = 'part definition type' ) AND 
	( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Part_occurrence_mim *)
RULE restrict_product_definitions_for_definition_usage FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name = 'definition usage' ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
END_RULE;

(* Implicit interfaced from: Specification_control_mim *)
RULE restrict_product_definitions_for_design_constraint_association FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr. name = 'design constraint association' ) AND 
	( (pdr. relating_product_definition.frame_of_reference.name<>'design constraint definition' ) OR 
	NOT ( pdr.related_product_definition.frame_of_reference.name IN 
	['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Item_definition_structure_mim *)
RULE restrict_product_definitions_for_part_definition_relationship FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_product_definitions_for_product_definition_relationship FOR
    (product_definition_relationship);
WHERE
WR3: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( pdr ) ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <> 'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <> 'part definition' ) ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <>'physical occurrence' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <>'physical occurrence' ) ) ) ) =0;
WR5: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'physical realization') AND 
	((pdr.relating_product_definition.frame_of_reference.name <> 'part definition') OR 
	(pdr.related_product_definition.frame_of_reference.name <> 'physical occurrence')) )) = 0; 
WR6: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'physical occurrence usage') AND 
	(NOT('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr)) OR 
	(pdr.relating_product_definition.frame_of_reference.name <> 'physical occurrence') OR 
	(pdr.related_product_definition.frame_of_reference.name <> 'physical occurrence')) )) = 0; 
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_properties_of_document_file FOR
    (document_file);
WHERE
WR1: SIZEOF ( QUERY ( df <* document_file | 
	SIZEOF ( QUERY ( pd <* USEDIN ( df ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' )| 
	pd.name = 'document property' ) ) >1 ) ) =0;
WR2: SIZEOF ( QUERY ( df <* document_file | 
	SIZEOF ( QUERY ( rt<* df.representation_types | 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DOCUMENT_REPRESENTATION_TYPE' IN TYPEOF ( rt ) ) AND 
	( rt.name IN ['digital' , 'physical'] ) ) ) =0 ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_properties_of_document_representation FOR
    (product_definition);
WHERE
 WR1: SIZEOF ( QUERY ( pd <* product_definition | 
	(pd.frame_of_reference.name IN 
	  ['physical document definition', 'digital document definition' ,'physical model occurrence' ] ) AND 
	( SIZEOF ( QUERY ( pd1 <* USEDIN ( pd , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION.DEFINITION' )| 
	pd1.name = 'document property' ) ) >1 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_representation_for_document_content_property FOR
    (representation,
     representation_item);
LOCAL
  document_content_representations: SET OF representation := [];
END_LOCAL;
  document_content_representations :=  QUERY( r <* representation |
	(r.name ='document content' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_content_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR ( SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri , 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document content' ) ) >0 ) AND 
	NOT ( ri. name IN ['detail level' , 'geometry type' , 'real world scale' ] ) )) =0;
WR3: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |( it.name = 'detail level' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( it ) ) ) ) >1) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |
     ( it.name = 'geometry type' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( it ) ) ) ) >1 ) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_content_representations | 
	( SIZEOF ( QUERY ( it <* r.items |( it.name = 'real world scale' ) AND 
	( SIZEOF (
     ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF( it ) ) =1 ) ) ) >1 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_representation_for_document_creation_property FOR
    (representation,
     representation_item);
LOCAL
  document_creation_representations: SET OF representation := [];
END_LOCAL;
  document_creation_representations :=  QUERY( r <* representation |
	(r.name ='document creation' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document creation' ) ) >0 ) AND 
	NOT ( ri. name IN [ 'creating interface' , 'creating system' ,'operating system' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'creating interface' ) AND (
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) >1 ) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'creating system' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) <>1 ) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_creation_representations | 
	( SIZEOF ( QUERY ( i <* r.items |
     ( i.name = 'operating system' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i )))) >1) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_representation_for_document_format_property FOR
    (representation,
     representation_item);
LOCAL
  document_format_representations: SET OF representation := [];
END_LOCAL;
  document_format_representations :=  QUERY( r <* representation |
	(r.name ='document format' ));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_format_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >3 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | 
	( SIZEOF (QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document format' ) ) >0 ) AND 
	NOT ( ri. name IN ['character code' , 'data format' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'character code' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) ) >1) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'data format' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) ) >1) ) ) =0;
WR5: SIZEOF ( QUERY ( r <* document_format_representations | 
	( SIZEOF ( QUERY ( i <* r.items| ( i.name =  'size format' ) AND 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PLANAR_EXTENT' IN TYPEOF ( i ) ) ) ) >1 ) ) ) =  0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_representation_for_document_properties FOR
    (property_definition,
     representation,
     representation_context);
WHERE
WR1: SIZEOF ( QUERY ( pd <* property_definition | 
	( pd. name ='document property' ) AND 
	( SIZEOF ( QUERY ( pdr <* USEDIN( pd ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	NOT ( pdr.used_representation.name IN ['document content' , 'document creation' ,
     'document format' , 'document size' ] ) ) ) >0 ) ) ) =0;
WR2: SIZEOF ( QUERY ( r <* representation | 
	( r.name IN [ 'document content' , 'document creation' , 'document format' , 'document size' ] ) AND 
	( SIZEOF (QUERY ( pdr <* USEDIN ( r ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
	( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PROPERTY_DEFINITION' IN TYPEOF( pdr. definition ) ) AND 
	( pdr. definition.name = 'document property' ) ) ) =0 ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* representation | 
	( r.name IN ['document content' , 'document creation' , 'document format' , 'document size' ] ) AND 
	(r.context_of_items.context_type<> 'document parameters' )) ) =0;
WR4: SIZEOF ( QUERY ( rc <* representation_context | 
	( rc.context_type = 'document parameters' ) AND 
	( SIZEOF ( QUERY( r <* USEDIN ( rc ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REPRESENTATION.CONTEXT_OF_ITEMS' ) | 
	NOT( r.name IN [ 'document content' , 'document creation' ,
     'document format' , 'document size' ] ) ) ) >0 ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_representation_for_document_size_property FOR
    (representation,
     representation_item);
LOCAL
  document_size_representations: SET OF representation := [];
END_LOCAL;
  document_size_representations :=  QUERY( r <* representation |
	(r.name ='document size'));
WHERE
WR1: SIZEOF ( QUERY ( r <* document_size_representations | 
	( ( SIZEOF ( r.items ) <1 ) OR (SIZEOF ( r.items ) >2 ) ) ) ) =0;
WR2: SIZEOF ( QUERY ( ri <* representation_item | ( SIZEOF (
     QUERY ( r <* USEDIN ( ri ,'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REPRESENTATION.ITEMS' ) | 
	r.name ='document size' ) ) >0 ) AND 
	NOT ( ri. name IN ['file size' , 'page count' ] ) ) ) =0;
WR3: SIZEOF ( QUERY ( r <* document_size_representations| 
	( SIZEOF ( QUERY ( i <* r.items | (i.name = 'file size' ) AND 
	( SIZEOF (
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_RANGE' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) =1 ) ) ) >1 ) ) ) =0;
WR4: SIZEOF ( QUERY ( r <* document_size_representations | 
	( SIZEOF ( QUERY ( i <* r.items | ( i.name = 'page count' ) AND 
	( SIZEOF ( 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' ,
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_RANGE' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) =1 ) ) ) >1 )) ) =0;
END_RULE;

(* Implicit interfaced from: Surface_conditions_mim *)
RULE restrict_representation_for_surface_condition FOR (property_definition_representation);
WHERE
WR1 : SIZEOF(QUERY(pdr <* property_definition_representation | 
	NOT surface_condition_correlation(pdr.definition, pdr.used_representation) ))=0;
END_RULE;

RULE restrict_representation_item_for_hybrid_geometric_model_3d FOR
    (shape_representation);
WHERE
WR1: SIZEOF ( QUERY ( sr <* shape_representation | 
	( sr. name ='hybrid 3d shape representation' ) AND 
	( SIZEOF ( QUERY ( i <* sr. items | 
	NOT ( 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) ) >0 )) ) =0;
END_RULE;

(* Implicit interfaced from: Surface_conditions_mim *)
RULE restrict_treatment_result FOR (representation);
LOCAL
  treatment_results: SET OF representation := [];
END_LOCAL;
  treatment_results:= QUERY( r <* representation | 
		(r.name = 'treatment result') );
WHERE 
WR1: (SIZEOF( QUERY( r <* treatment_results | (SIZEOF(r.items) > 2) )) = 0) AND
     (SIZEOF( QUERY( r <* treatment_results |
	 (SIZEOF( QUERY( i <* r.items | 
	NOT ('CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) > 0) )) 
	= 0); 
WR2: SIZEOF( QUERY( r <* treatment_results | 
	(SIZEOF( QUERY( i <* r.items | i.name = 'result' )) = 0) )) = 0; 
WR3: SIZEOF( QUERY( r <* treatment_results | 
	(SIZEOF( QUERY( i <* r.items | i.name = 'purpose' )) > 1) )) = 0; 
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_applied_identification_assignment FOR
    (applied_identification_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ent <* applied_identification_assignment| 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_class FOR
    (class);
WHERE
WR1: SIZEOF ( QUERY ( ent <* class | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_configuration_item FOR
    (configuration_item);
WHERE
WR1: SIZEOF ( QUERY ( ent <* configuration_item | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_document_file FOR
    (document_file);
WHERE
WR1: SIZEOF ( QUERY ( ent <* document_file | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_effectivity FOR
    (effectivity);
WHERE
WR1: SIZEOF ( QUERY ( ent <* effectivity | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_general_property FOR
    (general_property);
WHERE
WR1: SIZEOF ( QUERY ( ent <* general_property | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_product_concept FOR
    (product_concept);
WHERE
WR1: SIZEOF ( QUERY ( ent <* product_concept | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_product_concept_feature FOR
    (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( ent <* product_concept_feature | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE restrict_version_assignment_for_shape_representation FOR
    (shape_representation);
WHERE
WR1: SIZEOF ( QUERY ( ent <* shape_representation | 
	NOT at_most_one_version_id (ent) ))=0;
END_RULE;

RULE restrict_zone_boundary FOR
    (tolerance_zone_definition);
WHERE
WR1: SIZEOF ( QUERY ( tzd <* tolerance_zone_definition | 
	SIZEOF( tzd. boundaries ) >2 ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE security_classification_requires_security_classification_assignment FOR
    (security_classification);
WHERE
 WR1: SIZEOF ( QUERY ( sc <* security_classification | 
	SIZEOF (USEDIN ( sc ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SECURITY_CLASSIFICATION_ASSIGNMENT.ASSIGNED_SECURITY_CLASSIFICATION' ) ) =0 ) ) =0;
END_RULE;

(* Implicit interfaced from: Part_occurrence_mim *)
RULE selected_instance_usage_requires_representation FOR
    (assembly_component_usage);
LOCAL
  selected_instance_usages: SET OF assembly_component_usage := QUERY( acr <* assembly_component_usage|
		(acr.name = 'selected instance usage'));
END_LOCAL;
WHERE
WR1: SIZEOF ( QUERY ( acr <* selected_instance_usages | 
	NOT valid_selected_instance_representation(acr) ))=0;
END_RULE;

(* Implicit interfaced from: Alternative_solution_mim *)
RULE solution_definition_requires_solution_category FOR (product_definition);
LOCAL
  solution_definitions: SET OF product_definition := [];
END_LOCAL;
  solution_definitions :=  QUERY( pd <* product_definition |
	(pd.frame_of_reference.name = 'alternative definition'));
WHERE
WR1: SIZEOF( QUERY( pd <* solution_definitions | 
(SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	prpc.name = 'alternative solution')) = 0 ) )) = 0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_characterized_object FOR
    (characterized_object);
WHERE
WR1: SIZEOF ( QUERY ( co <* characterized_object | NOT (
     type_check_function ( co , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CHARACTERIZED_CLASS' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DOCUMENT_FILE' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.FEATURE_COMPONENT_DEFINITION' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.FEATURE_DEFINITION' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CLASS' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_IDENTIFICATION'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_classification_assignment FOR
    (classification_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ca <* classification_assignment | NOT (
     type_check_function ( ca , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_CLASSIFICATION_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LANGUAGE_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_compound_representation_item FOR
    (compound_representation_item);
WHERE
WR1: SIZEOF ( QUERY ( cri <* compound_representation_item | NOT
     ( type_check_function ( cri , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DEFAULT_TOLERANCE_TABLE_CELL' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_RANGE'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_document_reference FOR
    (document_reference);
WHERE
 WR1: SIZEOF ( QUERY ( dr <* document_reference | NOT (
     type_check_function ( dr , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_DOCUMENT_REFERENCE' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DRAUGHTING_SPECIFICATION_REFERENCE'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_effectivity FOR
    (effectivity);
WHERE
 WR1: SIZEOF ( QUERY ( e <* effectivity | NOT (
     type_check_function ( e , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_EFFECTIVITY' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.TIME_INTERVAL_BASED_EFFECTIVITY'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_effectivity_assignment FOR
    (effectivity_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ea <* effectivity_assignment | NOT (
     type_check_function ( ea , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_EFFECTIVITY_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_INEFFECTIVITY_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_effectivity_context_assignment FOR
    (effectivity_context_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( eca <* effectivity_context_assignment |
     NOT ( type_check_function ( eca , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_externally_defined_item FOR
    (externally_defined_item);
WHERE
 WR1: SIZEOF ( QUERY ( edi <* externally_defined_item | NOT (
     type_check_function ( edi , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CHARACTER_GLYPH' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CURVE_FONT' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_FEATURE_DEFINITION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY',
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_HATCH_STYLE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_STYLE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_SYMBOL' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_TEXT_FONT' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_TILE_STYLE'] , 3
     ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_founded_item FOR
    (founded_item);
WHERE
 WR1: SIZEOF ( QUERY ( fi <* founded_item | NOT (
     type_check_function ( fi , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.COMPOSITE_CURVE_SEGMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SURFACE_PATCH' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.VIEW_VOLUME'] , 3
     ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Geometric_tolerance_mim *)
RULE subtype_exclusiveness_geometric_tolerance FOR 
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ANGULARITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COAXIALITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONCENTRICITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CYLINDRICITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FLATNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE_PROFILE_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PARALLELISM_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PERPENDICULARITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POSITION_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ROUNDNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.STRAIGHTNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SYMMETRY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 3)))) = 0;
END_RULE; 

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_group FOR
    (group);
WHERE
 WR1: SIZEOF ( QUERY ( g <* group | NOT ( type_check_function ( g , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CLASS' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.CLASS_SYSTEM' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.LANGUAGE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REP_ITEM_GROUP'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_group_assignment FOR
    (group_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ga <* group_assignment | NOT (
     type_check_function ( ga , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_GROUP_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_identification_assignment FOR
    (identification_assignment);
WHERE
 WR1: SIZEOF ( QUERY ( ia <* identification_assignment | NOT (
     type_check_function ( ia , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.APPLIED_IDENTIFICATION_ASSIGNMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNAL_IDENTIFICATION_ASSIGNMENT'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_property_definition FOR
    (property_definition);
WHERE
 WR1: SIZEOF ( QUERY ( pd <* property_definition | NOT (
     type_check_function ( pd , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MATERIAL_PROPERTY' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_DEFINITION_SHAPE'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_property_definition_representation FOR
    (property_definition_representation);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* property_definition_representation| 
	NOT ( type_check_function ( pdr , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MATERIAL_PROPERTY_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.SHAPE_DEFINITION_REPRESENTATION'] ,3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( r <* representation | NOT (
     type_check_function ( r ,
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.CONTACT_RATIO_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.DEFAULT_TOLERANCE_TABLE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.DEFINITIONAL_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.HARDNESS_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.MOMENTS_OF_INERTIA_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.PRESENTATION_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SURFACE_TEXTURE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SYMBOL_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.TACTILE_APPEARANCE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.TEXT_STRING_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.VISUAL_APPEARANCE_REPRESENTATION'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_exclusiveness_representation_item FOR
    (representation_item);
WHERE
WR1: SIZEOF ( QUERY ( ri <* representation_item | NOT (
     type_check_function ( ri , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.COMPOUND_REPRESENTATION_ITEM' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.MEASURE_REPRESENTATION_ITEM' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.REP_ITEM_GROUP' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.VALUE_REPRESENTATION_ITEM'] , 3 ) ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_shape_aspect_relationship FOR
    (shape_aspect_relationship);
WHERE
 WR1: SIZEOF ( QUERY ( sar <* shape_aspect_relationship | NOT (
     type_check_function ( sar , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.DIMENSIONAL_LOCATION' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SHAPE_ASPECT_ASSOCIATIVITY' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SHAPE_ASPECT_DERIVING_RELATIONSHIP'] , 3 )
     ) ) ) =0;
END_RULE;

RULE subtype_exclusiveness_shape_representation_geometry FOR
    (shape_representation);
WHERE
WR1: SIZEOF ( QUERY ( sr <* shape_representation | NOT (
     type_check_function ( sr , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.ADVANCED_BREP_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.CSG_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.FACETED_BREP_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] , 3 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_mandatory_address FOR
    (address);
WHERE
WR1: SIZEOF ( QUERY ( a <* address | NOT ( type_check_function( a , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.ORGANIZATIONAL_ADDRESS' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PERSONAL_ADDRESS'] , 0 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_mandatory_configurable_item FOR
    (configurable_item);
WHERE
 WR1: SIZEOF ( QUERY ( ci <* configurable_item | NOT (
     type_check_function ( ci , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.PRODUCT_SPECIFICATION'] , 0 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_mandatory_document_product_association FOR
    (document_product_association);
WHERE
 WR1: SIZEOF ( QUERY ( dpa <* document_product_association | NOT
     ( type_check_function ( dpa , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.DOCUMENT_PRODUCT_EQUIVALENCE'] , 0 ) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Catalog_data_information_mim *)
RULE subtype_mandatory_externally_defined_item FOR
    (externally_defined_item);
WHERE
 WR1: SIZEOF ( QUERY ( edi <* externally_defined_item | NOT (
     type_check_function ( edi , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CHARACTER_GLYPH' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CLASS' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_CURVE_FONT' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_FEATURE_DEFINITION' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_GENERAL_PROPERTY',
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_HATCH_STYLE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_STYLE' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_SYMBOL' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_TEXT_FONT' ,
     'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF' + '.EXTERNALLY_DEFINED_TILE_STYLE'] , 0 ) ) ) ) =0;
END_RULE;

RULE subtype_mandatory_founded_item FOR
    (founded_item);
WHERE
 WR1: SIZEOF ( QUERY ( fi <* founded_item | NOT (
     type_check_function ( fi , 
	['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.COMPOSITE_CURVE_SEGMENT' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.SURFACE_PATCH' , 
	'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION' + '.VIEW_VOLUME'] , 0) ) ) ) =0;
END_RULE;

(* Implicit interfaced from: Geometric_tolerance_mim *)
RULE subtype_mandatory_geometric_tolerance FOR 
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ANGULARITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.COAXIALITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CONCENTRICITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.CYLINDRICITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.FLATNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.LINE_PROFILE_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PARALLELISM_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.PERPENDICULARITY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.POSITION_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.ROUNDNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.STRAIGHTNESS_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.SYMMETRY_TOLERANCE', 'CATALOG_DATA_INFORMATION_AND_SHAPE_REPRESENTATION_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 0)))) = 0;
END_RULE; 

(*** 2003=>1994 conversion: insert a rule to control if instances are legal according to USE/REF clauses ***)

RULE validate_dependently_instantiable_entity_data_types FOR
      (attribute_value_role,bounded_curve,bounded_surface,cartesian_transformation_operator,concept_feature_relationship,concept_feature_relationship_with_condition,connected_edge_set,contract_type,document_usage_constraint,effectivity_context_role,event_occurrence_role,local_time,loop,oriented_face,oriented_open_shell,oriented_path,product_context,product_definition_effectivity,runout_zone_orientation,solid_model,swept_face_solid,tolerance_zone_form,vertex --<list this first and all subsequent relevant referencedentity data types here>
      );
LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := attribute_value_role + bounded_curve + bounded_surface + cartesian_transformation_operator + concept_feature_relationship + concept_feature_relationship_with_condition + connected_edge_set + contract_type + document_usage_constraint + effectivity_context_role + event_occurrence_role + local_time + loop + oriented_face + oriented_open_shell + oriented_path + product_context + product_definition_effectivity + runout_zone_orientation + solid_model + swept_face_solid + tolerance_zone_form + vertex;--<make a union of all implicit populations of the FOR-clause>
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;

WHERE
  WR1: dependently_instantiated(all_instances, set_of_input_types,
                                previous_in_chain);
END_RULE;

FUNCTION dependently_instantiated(
            set_of_input_instances : SET OF GENERIC:igen;
            set_of_input_types     : SET OF STRING;
            previous_in_chain      : LIST OF GENERIC:cgen): BOOLEAN;
(*'dependently_instantiated' To test whether all instances in the
  input set_of_input_instances are referenced by independently
  instantiable instances. If so, this function returns true.
  Set_of_input_types includes the type strings for all input instances.
  The instances in previous_in_chain are used to detect cyclic
  references during recursive calls to this function. The parameter
  lists already tested instances in a chain of references.
*)
LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types <= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all => invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);
END_FUNCTION; -- end dependently_instantiated



END_SCHEMA;

