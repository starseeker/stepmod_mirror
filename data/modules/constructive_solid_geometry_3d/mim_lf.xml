<?xml version="1.0"?>
<!-- $Id: express2xml.js,v 1.8 2002/02/15 12:21:31 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.8"
    source="../data/modules/constructive_solid_geometry_3d/mim_lf.exp"/>

  <schema name="constructive_solid_geometry_3d_mim">
    <type name="attribute_type">
      <select
        selectitems="label text">
      </select>

    </type>
    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>

    </type>
    <type name="b_spline_curve_form">
      <enumeration
        items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified">
      </enumeration>


    </type>
    <type name="b_spline_surface_form">
      <enumeration
        items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified">
      </enumeration>


    </type>
    <type name="boolean_operand">
      <select
        selectitems="solid_model half_space_solid csg_primitive boolean_result">
      </select>

    </type>
    <type name="boolean_operator">
      <enumeration
        items="union intersection difference">
      </enumeration>


    </type>
    <type name="characterized_definition">
      <select
        selectitems="characterized_product_definition shape_definition">
      </select>

    </type>
    <type name="characterized_product_definition">
      <select
        selectitems="product_definition">
      </select>

    </type>
    <type name="csg_primitive">
      <select
        selectitems="sphere ellipsoid block right_angular_wedge faceted_primitive rectangular_pyramid torus right_circular_cone eccentric_cone right_circular_cylinder cyclide_segment_solid">
      </select>

    </type>
    <type name="csg_select">
      <select
        selectitems="boolean_result csg_primitive">
      </select>

    </type>
    <type name="curve_on_surface">
      <select
        selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>

    </type>
    <type name="derived_property_select">
      <select
        selectitems="property_definition">
      </select>

    </type>
    <type name="description_attribute_select">
      <select
        selectitems="application_context organization_role person_and_organization_role person_and_organization representation">
      </select>

    </type>
    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>


      <where
        label="WHERE"
        expression="(SELF &gt; 0)">
      </where>
    </type>
    <type name="founded_item_select">
      <select
        selectitems="founded_item representation_item">
      </select>

    </type>
    <type name="geometric_set_select">
      <select
        selectitems="point curve surface">
      </select>

    </type>
    <type name="id_attribute_select">
      <select
        selectitems="application_context representation">
      </select>

    </type>
    <type name="identification_item">
      <select
        selectitems="applied_identification_assignment">
      </select>

    </type>
    <type name="identification_organization_item">
      <select
        selectitems="organization_item">
      </select>

    </type>
    <type name="identification_person_and_organization_item">
      <select
        selectitems="person_and_organization_item">
      </select>

    </type>
    <type name="identifier">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified">
      </enumeration>


    </type>
    <type name="label">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="length_measure">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="list_of_reversible_topology_item">
      <aggregate
        type="LIST"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>

    </type>
    <type name="measure_value">
      <select
        selectitems="length_measure plane_angle_measure parameter_value positive_length_measure">
      </select>

    </type>
    <type name="name_attribute_select">
      <select
        selectitems="person_and_organization product_definition">
      </select>

    </type>
    <type name="organization_item">
      <select
        selectitems="applied_organization_assignment">
      </select>

    </type>
    <type name="parameter_value">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="pcurve_or_surface">
      <select
        selectitems="pcurve surface">
      </select>

    </type>
    <type name="person_and_organization_item">
      <select
        selectitems="applied_person_and_organization_assignment">
      </select>

    </type>
    <type name="person_organization_select">
      <select
        selectitems="person organization person_and_organization">
      </select>

    </type>
    <type name="plane_angle_measure">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="positive_length_measure">
      <typename
        name="length_measure"/>

      <where
        label="WHERE"
        expression="(SELF &gt; 0)">
      </where>
    </type>
    <type name="preferred_surface_curve_representation">
      <enumeration
        items="curve_3d pcurve_s1 pcurve_s2">
      </enumeration>


    </type>
    <type name="representation_identification_item">
      <select
        selectitems="representation">
      </select>

    </type>
    <type name="represented_definition">
      <select
        selectitems="property_definition shape_aspect shape_aspect_relationship">
      </select>

    </type>
    <type name="reversible_topology">
      <select
        selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item">
      </select>

    </type>
    <type name="reversible_topology_item">
      <select
        selectitems="edge path face face_bound closed_shell open_shell">
      </select>

    </type>
    <type name="set_of_reversible_topology_item">
      <aggregate
        type="SET"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>

    </type>
    <type name="shape_definition">
      <select
        selectitems="product_definition_shape shape_aspect shape_aspect_relationship">
      </select>

    </type>
    <type name="shell">
      <select
        selectitems="open_shell closed_shell">
      </select>

    </type>
    <type name="surface_boundary">
      <select
        selectitems="boundary_curve degenerate_pcurve">
      </select>

    </type>
    <type name="text">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="transformation">
      <select
        selectitems="item_defined_transformation functionally_defined_transformation">
      </select>

    </type>
    <type name="transition_code">
      <enumeration
        items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature">
      </enumeration>


    </type>
    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value">
      </select>

    </type>
    <type name="unit">
      <select
        selectitems="named_unit">
      </select>

    </type>
    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>

    </type>
    <entity
      name="address">
      <explicit
        name="internal_location"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_box"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="town"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="region"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_code"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="country"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="facsimile_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telephone_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="electronic_mail_address"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telex_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(               electronic_mail_address) OR EXISTS(telex_number))">
      </where>
    </entity>

    <entity
      name="advanced_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MANIFOLD_SOLID_BREP',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AXIS2_PLACEMENT_3D'] *                TYPEOF(it)) = 1)) )) = 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MANIFOLD_SOLID_BREP',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM'] * TYPEOF(               it)) = 1) )) &gt; 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* SELF.items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MANIFOLD_SOLID_BREP' IN                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(msb)                | (NOT (SIZEOF(QUERY ( fcs &lt;* csh\connected_face_set.               cfs_faces | (NOT (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ADVANCED_FACE' IN                TYPEOF(fcs))) )) = 0)) )) = 0)) )) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MANIFOLD_SOLID_BREP' IN                TYPEOF(it)) ) | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_CLOSED_SHELL'                IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY ( brv &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BREP_WITH_VOIDS' IN                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh &lt;* brv\               brep_with_voids.voids | csh\oriented_closed_shell.               orientation )) = 0)) )) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM' IN TYPEOF(               it)) ) | (NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ADVANCED_BREP_SHAPE_REPRESENTATION'                IN TYPEOF(mi\mapped_item.mapping_source.               mapped_representation))) )) = 0)">
      </where>
    </entity>

    <entity
      name="advanced_face"
      supertypes="face_surface">
      <where
        label="wr1"
        expression="(SIZEOF([                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ELEMENTARY_SURFACE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.B_SPLINE_SURFACE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SWEPT_SURFACE'] *                 TYPEOF(face_geometry)) = 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN TYPEOF(                bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound                \path.edge_list | (NOT (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_CURVE' IN TYPEOF(                oe\oriented_edge.edge_element))) )) = 0)) )) = 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN TYPEOF(                bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound                \path.edge_list | (NOT (SIZEOF([                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.LINE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CONIC',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLYLINE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.B_SPLINE_CURVE'] *                 TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1)) ))                 = 0)) )) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN TYPEOF(                bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound                \path.edge_list | (NOT ((                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VERTEX_POINT' IN                 TYPEOF(oe\edge.edge_start)) AND (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CARTESIAN_POINT' IN                 TYPEOF(oe\edge.edge_start\vertex_point.vertex_geometry))                 AND ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VERTEX_POINT' IN                 TYPEOF(oe\edge.edge_end)) AND (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CARTESIAN_POINT' IN                 TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))) ))                 = 0)) )) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN TYPEOF(                bnds.bound)) ) | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_PATH' IN                 TYPEOF(elp_fbnds.bound)) )) = 0)">
      </where>
      <where
        label="wr6"
        expression="((NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SWEPT_SURFACE' IN                 TYPEOF(face_geometry))) OR (SIZEOF([                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.LINE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CONIC',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLYLINE',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.B_SPLINE_CURVE'] *                 TYPEOF(face_geometry\swept_surface.swept_curve)) = 1))">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY ( vlp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VERTEX_LOOP' IN TYPEOF(                bnds.bound)) ) | (NOT ((                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VERTEX_POINT' IN                 TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex))                 AND ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CARTESIAN_POINT'                 IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.                loop_vertex\vertex_point.vertex_geometry)))) )) = 0)">
      </where>
      <where
        label="wr8"
        expression="(SIZEOF(QUERY ( bnd &lt;* bounds | (NOT (SIZEOF([                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP',                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VERTEX_LOOP'] * TYPEOF(                bnd.bound)) = 1)) )) = 0)">
      </where>
      <where
        label="wr9"
        expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN TYPEOF(                bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound                \path.edge_list | ((                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE' IN                 TYPEOF(oe\oriented_edge.edge_element\edge_curve.                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag &lt;* oe.                edge_element\edge_curve.edge_geometry\surface_curve.                associated_geometry | (NOT (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(sc_ag))) ))                 = 0))) )) = 0)) )) = 0)">
      </where>
      <where
        label="wr10"
        expression="(((NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SWEPT_SURFACE' IN                 TYPEOF(face_geometry))) OR (NOT (                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLYLINE' IN TYPEOF(                face_geometry\swept_surface.swept_curve))) OR (SIZEOF(                face_geometry\swept_surface.swept_curve\polyline.points) &gt;=                 3)) AND (SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;*                 bounds | ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE_LOOP' IN                 TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;*                 elp_fbnds.bound\path.edge_list | ((                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLYLINE' IN TYPEOF(oe\                oriented_edge.edge_element\edge_curve.edge_geometry)) AND (                NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.                edge_geometry\polyline.points) &gt;= 3))) )) = 0)) )) = 0))">
      </where>
    </entity>

    <entity
      name="application_context">
      <explicit
        name="application">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <inverse
        name="context_elements"
        entity="application_context_element"
        attribute="frame_of_reference">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="application_context_element"
      super.expression="(ONEOF (product_context,product_definition_context))">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="applied_identification_assignment"
      supertypes="identification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="identification_item"/>
      </explicit>
    </entity>

    <entity
      name="applied_organization_assignment"
      supertypes="organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization_item"/>
      </explicit>
    </entity>

    <entity
      name="applied_person_and_organization_assignment"
      supertypes="person_and_organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person_and_organization_item"/>
      </explicit>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis),dummy_gri || direction([0,0,1]))">
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\placement.location.dim = 3)">
      </where>
      <where
        label="wr2"
        expression="((NOT EXISTS(axis)) OR (axis.dim = 3))">
      </where>
      <where
        label="wr3"
        expression="((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3))">
      </where>
      <where
        label="wr4"
        expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (               cross_product(axis,ref_direction).magnitude &gt; 0))">
      </where>
    </entity>

    <entity
      name="b_spline_curve"
      super.expression="(ONEOF (uniform_curve,b_spline_curve_with_knots,        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)"
      supertypes="bounded_curve">
      <explicit
        name="degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename
          name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="SIZEOF(                                         control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(                                         control_points_list,0,                                         upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="cartesian_point"/>
      </derived>
      <where
        label="wr1"
        expression="(('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.UNIFORM_CURVE' IN TYPEOF(               SELF)) OR (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.QUASI_UNIFORM_CURVE' IN                TYPEOF(SELF)) OR (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BEZIER_CURVE' IN TYPEOF(               SELF)) OR ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.B_SPLINE_CURVE_WITH_KNOTS'                IN TYPEOF(SELF)))">
      </where>
    </entity>

    <entity
      name="b_spline_curve_with_knots"
      supertypes="b_spline_curve">
      <explicit
        name="knot_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="constraints_param_b_spline(degree,upper_index_on_knots,               upper_index_on_control_points,knot_multiplicities,knots)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(knot_multiplicities) = upper_index_on_knots)">
      </where>
    </entity>

    <entity
      name="b_spline_surface"
      super.expression="(ONEOF (b_spline_surface_with_knots,uniform_surface,        quasi_uniform_surface,bezier_surface) ANDOR         rational_b_spline_surface)"
      supertypes="bounded_surface">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="surface_form">
        <typename
          name="b_spline_surface_form"/>
      </explicit>
      <explicit
        name="u_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="v_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array(                          control_points_list,0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="wr1"
        expression="(('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.UNIFORM_SURFACE' IN                TYPEOF(SELF)) OR (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.QUASI_UNIFORM_SURFACE'                IN TYPEOF(SELF)) OR (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BEZIER_SURFACE' IN                TYPEOF(SELF)) OR ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.B_SPLINE_SURFACE_WITH_KNOTS'                IN TYPEOF(SELF)))">
      </where>
    </entity>

    <entity
      name="b_spline_surface_with_knots"
      supertypes="b_spline_surface">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,               u_knots)">
      </where>
      <where
        label="wr2"
        expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,               v_knots)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(u_multiplicities) = knot_u_upper)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(v_multiplicities) = knot_v_upper)">
      </where>
    </entity>

    <entity
      name="bezier_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="bezier_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="block"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="boolean_result"
      supertypes="geometric_representation_item">
      <explicit
        name="operator">
        <typename
          name="boolean_operator"/>
      </explicit>
      <explicit
        name="first_operand">
        <typename
          name="boolean_operand"/>
      </explicit>
      <explicit
        name="second_operand">
        <typename
          name="boolean_operand"/>
      </explicit>
    </entity>

    <entity
      name="boundary_curve"
      supertypes="composite_curve_on_surface">
      <where
        label="wr1"
        expression="SELF\composite_curve.closed_curve">
      </where>
    </entity>

    <entity
      name="bounded_curve"
      super.expression="(ONEOF (polyline,b_spline_curve,composite_curve))"
      supertypes="curve">
    </entity>

    <entity
      name="bounded_surface"
      super.expression="(ONEOF (b_spline_surface,curve_bounded_surface))"
      supertypes="surface">
    </entity>

    <entity
      name="box_domain">
      <explicit
        name="corner">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="xlength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ylength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="zlength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( item &lt;* USEDIN(SELF,'') | (NOT (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BOXED_HALF_SPACE' IN                TYPEOF(item))) )) = 0)">
      </where>
    </entity>

    <entity
      name="boxed_half_space"
      supertypes="half_space_solid">
      <explicit
        name="enclosure">
        <typename
          name="box_domain"/>
      </explicit>
    </entity>

    <entity
      name="brep_with_voids"
      supertypes="manifold_solid_brep">
      <explicit
        name="voids">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="oriented_closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_point"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(ONEOF (cartesian_transformation_operator_2d,        cartesian_transformation_operator_3d))"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale,1)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="wr1"
        expression="(scl &gt; 0)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_2d"
      supertypes="cartesian_transformation_operator">
      <derived
        name="u"
        expression="base_axis(2,SELF\             cartesian_transformation_operator.axis1,SELF\             cartesian_transformation_operator.axis2,?)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3,SELF\             cartesian_transformation_operator.axis1,SELF\             cartesian_transformation_operator.axis2,axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="circle"
      supertypes="conic">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="closed_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="composite_curve"
      supertypes="bounded_curve">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt;                         discontinuous">
        <builtintype
          type="LOGICAL"/>
      </derived>
      <where
        label="wr1"
        expression="(((NOT closed_curve) AND (SIZEOF(QUERY ( temp &lt;* segments | (               temp.transition = discontinuous) )) = 1)) OR (closed_curve                AND (SIZEOF(QUERY ( temp &lt;* segments | (temp.transition =                discontinuous) )) = 0)))">
      </where>
    </entity>

    <entity
      name="composite_curve_on_surface"
      super.expression="(boundary_curve)"
      supertypes="composite_curve">
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="0"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(basis_surface) &gt; 0)">
      </where>
      <where
        label="wr2"
        expression="constraints_composite_curve_on_surface(SELF)">
      </where>
    </entity>

    <entity
      name="composite_curve_segment"
      supertypes="founded_item">
      <explicit
        name="transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BOUNDED_CURVE' IN TYPEOF(               parent_curve))">
      </where>
    </entity>

    <entity
      name="conic"
      super.expression="(ONEOF (circle,ellipse,hyperbola,parabola))"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
    </entity>

    <entity
      name="conical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(radius &gt;= 0)">
      </where>
    </entity>

    <entity
      name="connected_face_set"
      super.expression="(ONEOF (closed_shell,open_shell))"
      supertypes="topological_representation_item">
      <explicit
        name="cfs_faces">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
      </explicit>
    </entity>

    <entity
      name="convex_hexahedron"
      supertypes="faceted_primitive">
      <where
        label="wr1"
        expression="(SIZEOF(points) = 8)">
      </where>
      <where
        label="wr2"
        expression="(above_plane(points[1],points[2],points[3],points[4]) = 0)">
      </where>
      <where
        label="wr3"
        expression="(above_plane(points[5],points[8],points[7],points[6]) = 0)">
      </where>
      <where
        label="wr4"
        expression="(above_plane(points[1],points[4],points[8],points[5]) = 0)">
      </where>
      <where
        label="wr5"
        expression="(above_plane(points[4],points[3],points[7],points[8]) = 0)">
      </where>
      <where
        label="wr6"
        expression="(above_plane(points[3],points[2],points[6],points[7]) = 0)">
      </where>
      <where
        label="wr7"
        expression="(above_plane(points[1],points[5],points[6],points[2]) = 0)">
      </where>
      <where
        label="wr8"
        expression="same_side([points[1],points[2],points[3]],[points[5],points[6],                points[7],points[8]])">
      </where>
      <where
        label="wr9"
        expression="same_side([points[1],points[4],points[8]],[points[3],points[7],                points[6],points[2]])">
      </where>
      <where
        label="wr10"
        expression="same_side([points[1],points[2],points[5]],[points[3],points[7],                points[8],points[4]])">
      </where>
      <where
        label="wr11"
        expression="same_side([points[5],points[6],points[7]],[points[1],points[2],                points[3],points[4]])">
      </where>
      <where
        label="wr12"
        expression="same_side([points[3],points[7],points[6]],[points[1],points[4],                points[8],points[5]])">
      </where>
      <where
        label="wr13"
        expression="same_side([points[3],points[7],points[8]],[points[1],points[5],                points[6],points[2]])">
      </where>
    </entity>

    <entity
      name="csg_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SELF.context_of_items\geometric_representation_context.               coordinate_space_dimension = 3)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CSG_SOLID',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AXIS2_PLACEMENT_3D',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SOLID_REPLICA',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REVOLVED_FACE_SOLID',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EXTRUDED_FACE_SOLID'] *                TYPEOF(it)) &lt;&gt; 1) )) = 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM' IN TYPEOF(               it)) ) | (NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CSG_SHAPE_REPRESENTATION'                IN TYPEOF(mi\mapped_item.mapping_source.               mapped_representation))) )) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY ( sr &lt;* QUERY ( it &lt;* SELF.items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SOLID_REPLICA' IN                TYPEOF(it)) ) | (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CSG_SOLID',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REVOLVED_FACE_SOLID',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EXTRUDED_FACE_SOLID'] *                TYPEOF(sr\solid_replica.parent_solid)) = 0) )) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AXIS2_PLACEMENT_3D' IN                TYPEOF(it))) )) &gt; 0)">
      </where>
    </entity>

    <entity
      name="csg_solid"
      supertypes="solid_model">
      <explicit
        name="tree_root_expression">
        <typename
          name="csg_select"/>
      </explicit>
    </entity>

    <entity
      name="curve"
      super.expression="(ONEOF (line,conic,pcurve,surface_curve))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="curve_bounded_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="surface_boundary"/>
      </explicit>
      <explicit
        name="implicit_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="wr1"
        expression="(NOT (implicit_outer AND (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.OUTER_BOUNDARY_CURVE' IN                TYPEOF(boundaries))))">
      </where>
      <where
        label="wr2"
        expression="((NOT implicit_outer) OR (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BOUNDED_SURFACE' IN                TYPEOF(basis_surface)))">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY ( temp &lt;* boundaries | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.OUTER_BOUNDARY_CURVE' IN                TYPEOF(temp)) )) &lt;= 1)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY ( temp &lt;* QUERY ( bndc &lt;* boundaries | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BOUNDARY_CURVE' IN                TYPEOF(bndc)) ) | (temp\composite_curve_on_surface.               basis_surface[1] &lt;&gt; SELF.basis_surface) )) = 0)">
      </where>
    </entity>

    <entity
      name="cyclide_segment_solid"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="radius1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="radius2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="cone_angle1">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="cone_angle2">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="turn_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
    </entity>

    <entity
      name="cylindrical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="definitional_representation"
      supertypes="representation">
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PARAMETRIC_REPRESENTATION_CONTEXT'                IN TYPEOF(SELF\representation.context_of_items))">
      </where>
    </entity>

    <entity
      name="degenerate_pcurve"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(reference_to_curve\representation.items) = 1)">
      </where>
      <where
        label="wr2"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CURVE' IN TYPEOF(               reference_to_curve\representation.items[1]))">
      </where>
      <where
        label="wr3"
        expression="(reference_to_curve\representation.items[1]\               geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="degenerate_toroidal_surface"
      supertypes="toroidal_surface">
      <explicit
        name="select_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="wr1"
        expression="(major_radius &lt; minor_radius)">
      </where>
    </entity>

    <entity
      name="description_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="described_item">
        <typename
          name="description_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="dimensional_exponents">
      <explicit
        name="length_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="mass_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="time_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="electric_current_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="thermodynamic_temperature_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="amount_of_substance_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="luminous_intensity_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <typename
          name="REAL"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( tmp &lt;* direction_ratios | (tmp &lt;&gt; 0) )) &gt; 0)">
      </where>
    </entity>

    <entity
      name="eccentric_cone"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="x_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="y_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="ratio">
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="wr1"
        expression="(ratio &gt;= 0)">
      </where>
    </entity>

    <entity
      name="edge"
      super.expression="(ONEOF (edge_curve,oriented_edge))"
      supertypes="topological_representation_item">
      <explicit
        name="edge_start">
        <typename
          name="vertex"/>
      </explicit>
      <explicit
        name="edge_end">
        <typename
          name="vertex"/>
      </explicit>
    </entity>

    <entity
      name="edge_curve"
      supertypes="edge geometric_representation_item">
      <explicit
        name="edge_geometry">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="edge_loop"
      supertypes="loop path">
      <derived
        name="ne"
        expression="SIZEOF(SELF\path.edge_list)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].               edge_end)">
      </where>
    </entity>

    <entity
      name="elementary_surface"
      super.expression="(ONEOF (plane,cylindrical_surface,conical_surface,        spherical_surface,toroidal_surface))"
      supertypes="surface">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
    </entity>

    <entity
      name="ellipse"
      supertypes="conic">
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="ellipsoid"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_3">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="extruded_area_solid"
      supertypes="swept_area_solid">
      <explicit
        name="extruded_direction">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="depth">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(dot_product(SELF\swept_area_solid.swept_area.basis_surface\               elementary_surface.position.p[3],extruded_direction) &lt;&gt; 0)">
      </where>
    </entity>

    <entity
      name="extruded_face_solid"
      supertypes="swept_face_solid">
      <explicit
        name="extruded_direction">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="depth">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(dot_product(SELF\swept_face_solid.swept_face.face_geometry\               elementary_surface.position.p[3],extruded_direction) &lt;&gt; 0)">
      </where>
    </entity>

    <entity
      name="face"
      super.expression="(ONEOF (face_surface,oriented_face))"
      supertypes="topological_representation_item">
      <explicit
        name="bounds">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face_bound"/>
      </explicit>
      <where
        label="wr1"
        expression="(NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))))">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY ( temp &lt;* bounds | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE_OUTER_BOUND' IN                TYPEOF(temp)) )) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="face_bound"
      supertypes="topological_representation_item">
      <explicit
        name="bound">
        <typename
          name="loop"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="face_outer_bound"
      supertypes="face_bound">
    </entity>

    <entity
      name="face_surface"
      supertypes="face geometric_representation_item">
      <explicit
        name="face_geometry">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="wr1"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_SURFACE' IN                TYPEOF(face_geometry)))">
      </where>
    </entity>

    <entity
      name="faceted_brep"
      supertypes="manifold_solid_brep">
    </entity>

    <entity
      name="faceted_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( it &lt;* items | (NOT (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AXIS2_PLACEMENT_3D'] *                TYPEOF(it)) = 1)) )) = 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY ( it &lt;* items | (SIZEOF([               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM'] * TYPEOF(               it)) = 1) )) &gt; 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY ( fbrep &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP' IN TYPEOF(               it)) ) | (NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(fbrep) | (               NOT (SIZEOF(QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces                | (NOT (('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE_SURFACE'                IN TYPEOF(fcs)) AND (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PLANE' IN TYPEOF(fcs\               face_surface.face_geometry)) AND (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CARTESIAN_POINT' IN                TYPEOF(fcs\face_surface.face_geometry\elementary_surface.               position.location)))) )) = 0)) )) = 0)) )) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY ( fbrep &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP' IN TYPEOF(               it)) ) | (NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(fbrep) | (               NOT (SIZEOF(QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces                | (NOT (SIZEOF(QUERY ( bnds &lt;* fcs.bounds | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE_OUTER_BOUND' IN                TYPEOF(bnds)) )) = 1)) )) = 0)) )) = 0)) )) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MANIFOLD_SOLID_BREP' IN                TYPEOF(it)) ) | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_CLOSED_SHELL'                IN TYPEOF(msb\manifold_solid_brep.outer)) )) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY ( brv &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.BREP_WITH_VOIDS' IN                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( csh &lt;* brv\               brep_with_voids.voids | csh\oriented_closed_shell.               orientation )) = 0)) )) = 0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* items | (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM' IN TYPEOF(               it)) ) | (NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACETED_BREP_SHAPE_REPRESENTATION'                IN TYPEOF(mi\mapped_item.mapping_source.               mapped_representation))) )) = 0)">
      </where>
    </entity>

    <entity
      name="faceted_primitive"
      super.expression="(ONEOF (tetrahedron,convex_hexahedron))"
      supertypes="geometric_representation_item">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="4"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </explicit>
      <where
        label="wr1"
        expression="(points[1].dim = 3)">
      </where>
    </entity>

    <entity
      name="founded_item">
    </entity>

    <entity
      name="functionally_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF (point,direction,vector,placement,        cartesian_transformation_operator,curve,surface,edge_curve,        face_surface,poly_loop,vertex_point,solid_model,boolean_result,        sphere,right_circular_cone,right_circular_cylinder,torus,block,        right_angular_wedge,ellipsoid,faceted_primitive,rectangular_pyramid,        cyclide_segment_solid,volume,half_space_solid))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( using_rep &lt;* using_representations(SELF) | (               NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.GEOMETRIC_REPRESENTATION_CONTEXT'                IN TYPEOF(using_rep.context_of_items))) )) = 0)">
      </where>
    </entity>

    <entity
      name="global_unit_assigned_context"
      supertypes="representation_context">
      <explicit
        name="units">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="unit"/>
      </explicit>
    </entity>

    <entity
      name="half_space_solid"
      supertypes="geometric_representation_item">
      <explicit
        name="base_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="agreement_flag">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="hyperbola"
      supertypes="conic">
      <explicit
        name="semi_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="id_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="identified_item">
        <typename
          name="id_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="identification_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="identification_role"/>
      </explicit>
    </entity>

    <entity
      name="identification_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="item_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="transform_item_1">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="transform_item_2">
        <typename
          name="representation_item"/>
      </explicit>
    </entity>

    <entity
      name="length_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.LENGTH_UNIT' IN TYPEOF(               SELF\measure_with_unit.unit_component))">
      </where>
    </entity>

    <entity
      name="line"
      supertypes="curve">
      <explicit
        name="pnt">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename
          name="vector"/>
      </explicit>
      <where
        label="wr1"
        expression="(dir.dim = pnt.dim)">
      </where>
    </entity>

    <entity
      name="loop"
      super.expression="(ONEOF (vertex_loop,edge_loop,poly_loop))"
      supertypes="topological_representation_item">
    </entity>

    <entity
      name="manifold_solid_brep"
      supertypes="solid_model">
      <explicit
        name="outer">
        <typename
          name="closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="mapped_item"
      supertypes="representation_item">
      <explicit
        name="mapping_source">
        <typename
          name="representation_map"/>
      </explicit>
      <explicit
        name="mapping_target">
        <typename
          name="representation_item"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_mapped_representation(using_representations(SELF),[SELF])">
      </where>
    </entity>

    <entity
      name="measure_with_unit"
      super.expression="(length_measure_with_unit)">
      <explicit
        name="value_component">
        <typename
          name="measure_value"/>
      </explicit>
      <explicit
        name="unit_component">
        <typename
          name="unit"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_units(SELF)">
      </where>
    </entity>

    <entity
      name="name_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="named_item">
        <typename
          name="name_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="named_unit">
      <explicit
        name="dimensions">
        <typename
          name="dimensional_exponents"/>
      </explicit>
    </entity>

    <entity
      name="open_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="organization">
      <explicit
        name="id"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organization_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_organization">
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="organization_role"/>
      </explicit>
    </entity>

    <entity
      name="organization_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="organizational_address"
      supertypes="address">
      <explicit
        name="organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="oriented_closed_shell"
      supertypes="closed_shell">
      <explicit
        name="closed_shell_element">
        <typename
          name="closed_shell"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="SELF\connected_face_set.cfs_faces"
        expression="conditional_reverse(SELF.                                             orientation,SELF.                                             closed_shell_element.cfs_faces)">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
      </derived>
      <where
        label="wr1"
        expression="(NOT (               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_CLOSED_SHELL'                IN TYPEOF(SELF.closed_shell_element)))">
      </where>
    </entity>

    <entity
      name="oriented_edge"
      supertypes="edge">
      <explicit
        name="edge_element">
        <typename
          name="edge"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="SELF\edge.edge_start"
        expression="boolean_choose(SELF.orientation,                                SELF.edge_element.edge_start,SELF.                                edge_element.edge_end)">
        <typename
          name="vertex"/>
      </derived>
      <derived
        name="SELF\edge.edge_end"
        expression="boolean_choose(SELF.orientation,                                SELF.edge_element.edge_end,SELF.                                edge_element.edge_start)">
        <typename
          name="vertex"/>
      </derived>
      <where
        label="wr1"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_EDGE' IN                TYPEOF(SELF.edge_element)))">
      </where>
    </entity>

    <entity
      name="oriented_face"
      supertypes="face">
      <explicit
        name="face_element">
        <typename
          name="face"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="SELF\face.bounds"
        expression="conditional_reverse(                            SELF.orientation,SELF.face_element.bounds)">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face_bound"/>
      </derived>
      <where
        label="wr1"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_FACE' IN                TYPEOF(SELF.face_element)))">
      </where>
    </entity>

    <entity
      name="oriented_open_shell"
      supertypes="open_shell">
      <explicit
        name="open_shell_element">
        <typename
          name="open_shell"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="SELF\connected_face_set.cfs_faces"
        expression="conditional_reverse(SELF.                                             orientation,SELF.                                             open_shell_element.cfs_faces)">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
      </derived>
      <where
        label="wr1"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_OPEN_SHELL'                IN TYPEOF(SELF.open_shell_element)))">
      </where>
    </entity>

    <entity
      name="oriented_path"
      supertypes="path">
      <explicit
        name="path_element">
        <typename
          name="path"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="SELF\path.edge_list"
        expression="conditional_reverse(SELF.orientation,SELF.                               path_element.edge_list)">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </derived>
      <where
        label="wr1"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_PATH' IN                TYPEOF(SELF.path_element)))">
      </where>
    </entity>

    <entity
      name="parabola"
      supertypes="conic">
      <explicit
        name="focal_dist">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(focal_dist &lt;&gt; 0)">
      </where>
    </entity>

    <entity
      name="parametric_representation_context"
      supertypes="representation_context">
    </entity>

    <entity
      name="path"
      super.expression="(ONEOF (edge_loop,oriented_path))"
      supertypes="topological_representation_item">
      <explicit
        name="edge_list">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </explicit>
      <where
        label="wr1"
        expression="path_head_to_tail(SELF)">
      </where>
    </entity>

    <entity
      name="pcurve"
      supertypes="curve">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(reference_to_curve\representation.items) = 1)">
      </where>
      <where
        label="wr2"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CURVE' IN TYPEOF(               reference_to_curve\representation.items[1]))">
      </where>
      <where
        label="wr3"
        expression="(reference_to_curve\representation.items[1]\               geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="person">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="last_name"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="first_name"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="middle_names"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="prefix_titles"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="suffix_titles"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(EXISTS(last_name) OR EXISTS(first_name))">
      </where>
    </entity>

    <entity
      name="person_and_organization">
      <explicit
        name="the_person">
        <typename
          name="person"/>
      </explicit>
      <explicit
        name="the_organization">
        <typename
          name="organization"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="person_and_organization_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_person_and_organization">
        <typename
          name="person_and_organization"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="person_and_organization_role"/>
      </explicit>
    </entity>

    <entity
      name="person_and_organization_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="personal_address"
      supertypes="address">
      <explicit
        name="people">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="placement"
      super.expression="(ONEOF (axis1_placement,axis2_placement_2d,        axis2_placement_3d))"
      supertypes="geometric_representation_item">
      <explicit
        name="location">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="plane"
      supertypes="elementary_surface">
    </entity>

    <entity
      name="point"
      super.expression="(ONEOF (cartesian_point,degenerate_pcurve))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="poly_loop"
      supertypes="loop geometric_representation_item">
      <explicit
        name="polygon">
        <aggregate
          type="LIST"
          lower="3"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </explicit>
    </entity>

    <entity
      name="polyline"
      supertypes="bounded_curve">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="product">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="product_context"/>
      </explicit>
    </entity>

    <entity
      name="product_context"
      supertypes="application_context_element">
      <explicit
        name="discipline_type">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="product_definition">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="formation">
        <typename
          name="product_definition_formation"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="product_definition_context"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="product_definition_context"
      supertypes="application_context_element">
      <explicit
        name="life_cycle_stage">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="product_definition_formation">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="of_product">
        <typename
          name="product"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="id"/>
        <unique.attribute
          attribute="of_product"/>
      </unique>
    </entity>

    <entity
      name="product_definition_shape"
      supertypes="property_definition">
      <unique
        label="ur1">
        <unique.attribute
          attribute="definition"/>
      </unique>
      <where
        label="wr1"
        expression="(SIZEOF(['CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CHARACTERIZED_PRODUCT_DEFINITION',               'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CHARACTERIZED_OBJECT'] *                TYPEOF(SELF\property_definition.definition)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="property_definition">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="definition">
        <typename
          name="characterized_definition"/>
      </explicit>
    </entity>

    <entity
      name="quasi_uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="quasi_uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="rational_b_spline_curve"
      supertypes="b_spline_curve">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
      <derived
        name="weights"
        expression="list_to_array(weights_data,0,                   upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="REAL"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.               control_points_list))">
      </where>
      <where
        label="wr2"
        expression="curve_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rational_b_spline_surface"
      supertypes="b_spline_surface">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <derived
        name="weights"
        expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="wr1"
        expression="((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(               SELF\b_spline_surface.control_points_list[1])))">
      </where>
      <where
        label="wr2"
        expression="surface_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rectangular_pyramid"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="xlength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ylength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="representation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="context_of_items">
        <typename
          name="representation_context"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="representation_context">
      <explicit
        name="context_identifier">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="context_type">
        <typename
          name="text"/>
      </explicit>
      <inverse
        name="representations_in_context"
        entity="representation"
        attribute="context_of_items">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
    </entity>

    <entity
      name="representation_item">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(using_representations(SELF)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="representation_map">
      <explicit
        name="mapping_origin">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="mapped_representation">
        <typename
          name="representation"/>
      </explicit>
      <inverse
        name="map_usage"
        entity="mapped_item"
        attribute="mapping_source">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="item_in_context(SELF.mapping_origin,SELF.mapped_representation.               context_of_items)">
      </where>
    </entity>

    <entity
      name="representation_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="rep_1">
        <typename
          name="representation"/>
      </explicit>
      <explicit
        name="rep_2">
        <typename
          name="representation"/>
      </explicit>
    </entity>

    <entity
      name="representation_relationship_with_transformation"
      supertypes="representation_relationship">
      <explicit
        name="transformation_operator">
        <typename
          name="transformation"/>
      </explicit>
      <where
        label="wr1"
        expression="(SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;:                SELF\representation_relationship.rep_2.context_of_items)">
      </where>
    </entity>

    <entity
      name="revolved_area_solid"
      supertypes="swept_area_solid">
      <explicit
        name="axis">
        <typename
          name="axis1_placement"/>
      </explicit>
      <explicit
        name="angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="axis_line"
        expression="dummy_gri || curve() || line(axis.location,                     dummy_gri || vector(axis.z,1))">
        <typename
          name="line"/>
      </derived>
    </entity>

    <entity
      name="revolved_face_solid"
      supertypes="swept_face_solid">
      <explicit
        name="axis">
        <typename
          name="axis1_placement"/>
      </explicit>
      <explicit
        name="angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="axis_line"
        expression="dummy_gri || curve() || line(axis.location,                     dummy_gri || vector(axis.z,1))">
        <typename
          name="line"/>
      </derived>
    </entity>

    <entity
      name="right_angular_wedge"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ltx">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="((0 &lt;= ltx) AND (ltx &lt; x))">
      </where>
    </entity>

    <entity
      name="right_circular_cone"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(radius &gt;= 0)">
      </where>
    </entity>

    <entity
      name="right_circular_cylinder"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="shape_aspect">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="of_shape">
        <typename
          name="product_definition_shape"/>
      </explicit>
      <explicit
        name="product_definitional">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="shape_aspect_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_shape_aspect">
        <typename
          name="shape_aspect"/>
      </explicit>
      <explicit
        name="related_shape_aspect">
        <typename
          name="shape_aspect"/>
      </explicit>
    </entity>

    <entity
      name="shape_aspect_transition"
      supertypes="shape_aspect_relationship">
    </entity>

    <entity
      name="shape_representation"
      supertypes="representation">
    </entity>

    <entity
      name="shape_representation_relationship"
      supertypes="representation_relationship">
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SHAPE_REPRESENTATION' IN (               TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF               \representation_relationship.rep_2)))">
      </where>
    </entity>

    <entity
      name="solid_model"
      super.expression="(ONEOF (csg_solid,manifold_solid_brep,swept_face_solid,        swept_area_solid,solid_replica,trimmed_volume))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="solid_replica"
      supertypes="solid_model">
      <explicit
        name="parent_solid">
        <typename
          name="solid_model"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator_3d"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_solid_replica(SELF,parent_solid)">
      </where>
      <where
        label="wr2"
        expression="(parent_solid\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="sphere"
      supertypes="geometric_representation_item">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="centre">
        <typename
          name="point"/>
      </explicit>
    </entity>

    <entity
      name="spherical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="surface"
      super.expression="(ONEOF (elementary_surface,swept_surface,bounded_surface))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="surface_curve"
      supertypes="curve">
      <explicit
        name="curve_3d">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="associated_geometry">
        <aggregate
          type="LIST"
          lower="1"
          upper="2"/>
        <typename
          name="pcurve_or_surface"/>
      </explicit>
      <explicit
        name="master_representation">
        <typename
          name="preferred_surface_curve_representation"/>
      </explicit>
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="wr1"
        expression="(curve_3d.dim = 3)">
      </where>
      <where
        label="wr2"
        expression="(('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(               associated_geometry[1])) OR (master_representation &lt;&gt;                pcurve_s1))">
      </where>
      <where
        label="wr3"
        expression="(('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(               associated_geometry[2])) OR (master_representation &lt;&gt;                pcurve_s2))">
      </where>
      <where
        label="wr4"
        expression="(NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(               curve_3d)))">
      </where>
    </entity>

    <entity
      name="surface_curve_swept_area_solid"
      supertypes="swept_area_solid">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="start_param">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="end_param">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="reference_surface">
        <typename
          name="surface"/>
      </explicit>
      <where
        label="wr1"
        expression="((NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE' IN                TYPEOF(directrix))) OR (reference_surface IN directrix\               surface_curve.basis_surface))">
      </where>
    </entity>

    <entity
      name="surface_curve_swept_face_solid"
      supertypes="swept_face_solid">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="start_param">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="end_param">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="reference_surface">
        <typename
          name="surface"/>
      </explicit>
      <where
        label="wr1"
        expression="((NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE' IN                TYPEOF(directrix))) OR (reference_surface IN directrix\               surface_curve.basis_surface))">
      </where>
    </entity>

    <entity
      name="surface_of_linear_extrusion"
      supertypes="swept_surface">
      <explicit
        name="extrusion_axis">
        <typename
          name="vector"/>
      </explicit>
    </entity>

    <entity
      name="surface_of_revolution"
      supertypes="swept_surface">
      <explicit
        name="axis_position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <derived
        name="axis_line"
        expression="dummy_gri || line(axis_position.location,                     dummy_gri || vector(axis_position.z,1))">
        <typename
          name="line"/>
      </derived>
    </entity>

    <entity
      name="swept_area_solid"
      super.expression="(ONEOF (revolved_area_solid,extruded_area_solid,        surface_curve_swept_area_solid))"
      supertypes="solid_model">
      <explicit
        name="swept_area">
        <typename
          name="curve_bounded_surface"/>
      </explicit>
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PLANE' IN TYPEOF(               swept_area.basis_surface))">
      </where>
    </entity>

    <entity
      name="swept_face_solid"
      super.expression="(ONEOF (extruded_face_solid,revolved_face_solid,        surface_curve_swept_face_solid))"
      supertypes="solid_model">
      <explicit
        name="swept_face">
        <typename
          name="face_surface"/>
      </explicit>
      <where
        label="wr1"
        expression="('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PLANE' IN TYPEOF(               swept_face.face_geometry))">
      </where>
    </entity>

    <entity
      name="swept_surface"
      super.expression="(ONEOF (surface_of_linear_extrusion,surface_of_revolution))"
      supertypes="surface">
      <explicit
        name="swept_curve">
        <typename
          name="curve"/>
      </explicit>
    </entity>

    <entity
      name="tetrahedron"
      supertypes="faceted_primitive">
      <where
        label="wr1"
        expression="(SIZEOF(points) = 4)">
      </where>
      <where
        label="wr2"
        expression="(above_plane(points[1],points[2],points[3],points[4]) &lt;&gt; 0)">
      </where>
    </entity>

    <entity
      name="topological_representation_item"
      supertypes="representation_item">
    </entity>

    <entity
      name="toroidal_surface"
      supertypes="elementary_surface">
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="torus"
      supertypes="geometric_representation_item">
      <explicit
        name="position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(major_radius &gt; minor_radius)">
      </where>
    </entity>

    <entity
      name="trimmed_volume"
      supertypes="solid_model">
      <explicit
        name="basis_volume">
        <typename
          name="volume"/>
      </explicit>
      <explicit
        name="u1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="u2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="w1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="w2">
        <typename
          name="parameter_value"/>
      </explicit>
      <where
        label="wr1"
        expression="(u1 &lt;&gt; u2)">
      </where>
      <where
        label="wr2"
        expression="(v1 &lt;&gt; v2)">
      </where>
      <where
        label="wr3"
        expression="(w1 &lt;&gt; w2)">
      </where>
    </entity>

    <entity
      name="uncertainty_measure_with_unit"
      supertypes="measure_with_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_measure_value(SELF\measure_with_unit.value_component)">
      </where>
    </entity>

    <entity
      name="uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="value_representation_item"
      supertypes="representation_item">
      <explicit
        name="value_component">
        <typename
          name="measure_value"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( rep &lt;* using_representations(SELF) | (NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.GLOBAL_UNIT_ASSIGNED_CONTEXT'                IN TYPEOF(rep.context_of_items))) )) = 0)">
      </where>
    </entity>

    <entity
      name="vector"
      supertypes="geometric_representation_item">
      <explicit
        name="orientation">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="magnitude">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(magnitude &gt;= 0)">
      </where>
    </entity>

    <entity
      name="vertex"
      supertypes="topological_representation_item">
    </entity>

    <entity
      name="vertex_loop"
      supertypes="loop">
      <explicit
        name="loop_vertex">
        <typename
          name="vertex"/>
      </explicit>
    </entity>

    <entity
      name="vertex_point"
      supertypes="vertex geometric_representation_item">
      <explicit
        name="vertex_geometry">
        <typename
          name="point"/>
      </explicit>
    </entity>

    <entity
      name="volume"
      supertypes="geometric_representation_item">
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <rule
      name="compatible_dimension"
      appliesto="cartesian_point direction representation_context geometric_representation_context">
      <algorithm>

  WHERE
    wr1: (SIZEOF(QUERY ( x &lt;* cartesian_point | (SIZEOF(QUERY ( y &lt;* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension)) )) &gt; 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x &lt;* direction | (SIZEOF(QUERY ( y &lt;* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)) )) 
             &gt; 0) )) = 0);

      </algorithm>

    </rule>

    <function
      name="above_plane">
      <parameter
        name="p1">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p2">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p3">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p4">
        <typename
          name="cartesian_point"/>
      </parameter>
      <builtintype
        type="REAL"/>
      <algorithm>

    LOCAL
      val  : REAL;
      mag  : REAL;
      dir4 : direction := dummy_gri || direction([1,0,0]);
      dir3 : direction := dummy_gri || direction([1,0,0]);
      dir2 : direction := dummy_gri || direction([1,0,0]);
    END_LOCAL;
    IF p1.dim &lt;&gt; 3 THEN
      RETURN(?);
    END_IF;
    REPEAT i := 1 TO 3 BY 1;
      dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
      dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
      dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
      mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
    END_REPEAT;
    mag := SQRT(mag);
    val := mag * dot_product(dir4,cross_product(dir2,dir3).orientation);
    RETURN(val);

      </algorithm>

    </function>

    <function
      name="acyclic_mapped_representation">
      <parameter
        name="parent_set">
        <aggregate
          type="SET"/>
        <typename
          name="representation"/>
      </parameter>
      <parameter
        name="children_set">
        <aggregate
          type="SET"/>
        <typename
          name="representation_item"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z &lt;* children_set | (
        'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MAPPED_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z &lt;* bag_to_set(USEDIN(x[i],'')) | (
            'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION_ITEM' IN 
            TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="acyclic_solid_replica">
      <parameter
        name="rep">
        <typename
          name="solid_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="solid_model"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
    IF NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SOLID_REPLICA' IN TYPEOF(
        parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_solid_replica(rep,parent\solid_replica.parent_solid));
    END_IF;

      </algorithm>

    </function>

    <function
      name="associated_surface">
      <parameter
        name="arg">
        <typename
          name="pcurve_or_surface"/>
      </parameter>
      <typename
        name="surface"/>
      <algorithm>

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

      </algorithm>

    </function>

    <function
      name="bag_to_set">
      <parameter
        name="the_bag">
        <aggregate
          type="BAG"/>
        <typename
          name="GENERICintype"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="GENERICintype"/>
      <algorithm>

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

      </algorithm>

    </function>

    <function
      name="base_axis">
      <parameter
        name="dim">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="axis1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis2">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis3">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor &lt; 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

      </algorithm>

    </function>

    <function
      name="boolean_choose">
      <parameter
        name="b">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="choice1">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="choice2">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <builtintype
        type="GENERIC"/>
      <algorithm>
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

      </algorithm>

    </function>

    <function
      name="build_2axes">
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="2"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

      </algorithm>

    </function>

    <function
      name="build_axes">
      <parameter
        name="axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="3"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

      </algorithm>

    </function>

    <function
      name="closed_shell_reversed">
      <parameter
        name="a_shell">
        <typename
          name="closed_shell"/>
      </parameter>
      <typename
        name="oriented_closed_shell"/>
      <algorithm>

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_CLOSED_SHELL' IN 
        TYPEOF(a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="conditional_reverse">
      <parameter
        name="p">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="an_item">
        <typename
          name="reversible_topology"/>
      </parameter>
      <typename
        name="reversible_topology"/>
      <algorithm>
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

      </algorithm>

    </function>

    <function
      name="constraints_composite_curve_on_surface">
      <parameter
        name="c">
        <typename
          name="composite_curve_on_surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.COMPOSITE_CURVE_ON_SURFACE' 
          IN TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="constraints_param_b_spline">
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_cp">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="knot_mult">
        <aggregate
          type="LIST"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <parameter
        name="knots">
        <aggregate
          type="LIST"/>
        <typename
          name="parameter_value"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR (sum &lt;&gt; (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k &lt; 1) OR (k &gt; (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i &lt; up_knots) AND (k &gt; degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k &gt; (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="cross_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

      </algorithm>

    </function>

    <function
      name="curve_weights_positive">
      <parameter
        name="b">
        <typename
          name="rational_b_spline_curve"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] &lt;= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="derive_dimensional_exponents">
      <parameter
        name="x">
        <typename
          name="unit"/>
      </parameter>
      <typename
        name="dimensional_exponents"/>
      <algorithm>

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.DERIVED_UNIT' IN TYPEOF(x)
         THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="dimension_of">
      <parameter
        name="item">
        <typename
          name="geometric_representation_item"/>
      </parameter>
      <typename
        name="dimension_count"/>
      <algorithm>

    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

      </algorithm>

    </function>

    <function
      name="dot_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <builtintype
        type="REAL"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim &lt;&gt; arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

      </algorithm>

    </function>

    <function
      name="edge_reversed">
      <parameter
        name="an_edge">
        <typename
          name="edge"/>
      </parameter>
      <typename
        name="oriented_edge"/>
      <algorithm>

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_EDGE' IN TYPEOF(
        an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="face_bound_reversed">
      <parameter
        name="a_face_bound">
        <typename
          name="face_bound"/>
      </parameter>
      <typename
        name="face_bound"/>
      <algorithm>

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE_OUTER_BOUND' IN TYPEOF(
        a_face_bound) THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="face_reversed">
      <parameter
        name="a_face">
        <typename
          name="face"/>
      </parameter>
      <typename
        name="oriented_face"/>
      <algorithm>

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_FACE' IN TYPEOF(a_face)
         THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="first_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios &lt;&gt; [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim &lt;&gt; 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

      </algorithm>

    </function>

    <function
      name="get_basis_surface">
      <parameter
        name="c">
        <typename
          name="curve_on_surface"/>
      </parameter>
      <aggregate
        type="SET"
        lower="0"
        upper="2"/>
      <typename
        name="surface"/>
      <algorithm>

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SURFACE_CURVE' IN TYPEOF(c)
           THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.COMPOSITE_CURVE_ON_SURFACE' IN 
        TYPEOF(c) THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n &gt; 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

      </algorithm>

    </function>

    <function
      name="get_description_value">
      <parameter
        name="obj">
        <typename
          name="description_attribute_select"/>
      </parameter>
      <typename
        name="text"/>
      <algorithm>

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' + 
                         'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="get_id_value">
      <parameter
        name="obj">
        <typename
          name="id_attribute_select"/>
      </parameter>
      <typename
        name="identifier"/>
      <algorithm>

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,
                'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' + 'ID_ATTRIBUTE.' + 
                'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="get_name_value">
      <parameter
        name="obj">
        <typename
          name="name_attribute_select"/>
      </parameter>
      <typename
        name="label"/>
      <algorithm>

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.' + 'NAME_ATTRIBUTE.' 
                  + 'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="item_in_context">
      <parameter
        name="item">
        <typename
          name="representation_item"/>
      </parameter>
      <parameter
        name="cntxt">
        <typename
          name="representation_context"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,
        'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION.ITEMS') * cntxt.
        representations_in_context) &gt; 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z &lt;* USEDIN(item,'') | (
          'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION_ITEM' IN 
          TYPEOF(z)) );
      IF SIZEOF(y) &gt; 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

      </algorithm>

    </function>

    <function
      name="list_face_loops">
      <parameter
        name="f">
        <typename
          name="face"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="0"
        upper="?"/>
      <typename
        name="loop"/>
      <algorithm>

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

      </algorithm>

    </function>

    <function
      name="list_of_topology_reversed">
      <parameter
        name="a_list">
        <typename
          name="list_of_reversible_topology_item"/>
      </parameter>
      <typename
        name="list_of_reversible_topology_item"/>
      <algorithm>

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="list_to_array">
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="0"
          upper="?"/>
        <typename
          name="GENERICt"/>
      </parameter>
      <parameter
        name="low">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"/>
      <typename
        name="GENERICt"/>
      <algorithm>

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n &lt;&gt; ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

      </algorithm>

    </function>

    <function
      name="list_to_set">
      <parameter
        name="l">
        <aggregate
          type="LIST"
          lower="0"
          upper="?"/>
        <typename
          name="GENERICt"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="GENERICt"/>
      <algorithm>

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

      </algorithm>

    </function>

    <function
      name="make_array_of_array">
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <parameter
        name="low1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"/>
      <typename
        name="ARRAY"/>
      <algorithm>

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) &lt;&gt; SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

      </algorithm>

    </function>

    <function
      name="mixed_loop_type_set">
      <parameter
        name="l">
        <aggregate
          type="SET"
          lower="0"
          upper="?"/>
        <typename
          name="loop"/>
      </parameter>
      <builtintype
        type="LOGICAL"/>
      <algorithm>

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) &lt;= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLY_LOOP' IN 
        TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POLY_LOOP' IN TYPEOF(l[i])) 
          &lt;&gt; poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

      </algorithm>

    </function>

    <function
      name="msb_shells">
      <parameter
        name="brep">
        <typename
          name="manifold_solid_brep"/>
      </parameter>
      <aggregate
        type="SET"
        lower="1"
        upper="?"/>
      <typename
        name="closed_shell"/>
      <algorithm>
    IF SIZEOF(QUERY ( msbtype &lt;* TYPEOF(brep) | (msbtype LIKE 
        '*BREP_WITH_VOIDS') )) &gt;= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

      </algorithm>

    </function>

    <function
      name="normalise">
      <parameter
        name="arg">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector_or_direction"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag &gt; 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VECTOR' IN TYPEOF(arg)
             THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="open_shell_reversed">
      <parameter
        name="a_shell">
        <typename
          name="open_shell"/>
      </parameter>
      <typename
        name="oriented_open_shell"/>
      <algorithm>

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_OPEN_SHELL' IN TYPEOF(
        a_shell) THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="orthogonal_complement">
      <parameter
        name="vec">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

      </algorithm>

    </function>

    <function
      name="path_head_to_tail">
      <parameter
        name="a_path">
        <typename
          name="path"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

      </algorithm>

    </function>

    <function
      name="path_reversed">
      <parameter
        name="a_path">
        <typename
          name="path"/>
      </parameter>
      <typename
        name="oriented_path"/>
      <algorithm>

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ORIENTED_PATH' IN TYPEOF(a_path)
         THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="same_side">
      <parameter
        name="plane_pts">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="test_points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      n    : INTEGER;
      val2 : REAL;
      val1 : REAL;
    END_LOCAL;
    IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
      RETURN(?);
    END_IF;
    n := SIZEOF(test_points);
    val1 := above_plane(plane_pts[1],plane_pts[2],plane_pts[3],test_points
        [1]);
    REPEAT i := 2 TO n BY 1;
      val2 := above_plane(plane_pts[1],plane_pts[2],plane_pts[3],
          test_points[i]);
      IF (val1 * val2) &lt;= 0 THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="scalar_times_vector">
      <parameter
        name="scalar">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="vec">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag &lt; 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="second_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="x_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

      </algorithm>

    </function>

    <function
      name="set_of_topology_reversed">
      <parameter
        name="a_set">
        <typename
          name="set_of_reversible_topology_item"/>
      </parameter>
      <typename
        name="set_of_reversible_topology_item"/>
      <algorithm>

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

      </algorithm>

    </function>

    <function
      name="shell_reversed">
      <parameter
        name="a_shell">
        <typename
          name="shell"/>
      </parameter>
      <typename
        name="shell"/>
      <algorithm>
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.CLOSED_SHELL' IN TYPEOF(
          a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

      </algorithm>

    </function>

    <function
      name="surface_weights_positive">
      <parameter
        name="b">
        <typename
          name="rational_b_spline_surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] &lt;= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="topology_reversed">
      <parameter
        name="an_item">
        <typename
          name="reversible_topology"/>
      </parameter>
      <typename
        name="reversible_topology"/>
      <algorithm>
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE_BOUND' IN TYPEOF(an_item)
         THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

      </algorithm>

    </function>

    <function
      name="using_items">
      <parameter
        name="item">
        <typename
          name="founded_item_select"/>
      </parameter>
      <parameter
        name="checked_items">
        <aggregate
          type="SET"/>
        <typename
          name="founded_item_select"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="founded_item_select"/>
      <algorithm>

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z &lt;* bag_to_set(USEDIN(item,'')) | ((
        'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION_ITEM' IN TYPEOF(
        z)) OR ('CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.FOUNDED_ITEM' IN 
        TYPEOF(z))) );
    IF SIZEOF(next_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

      </algorithm>

    </function>

    <function
      name="using_representations">
      <parameter
        name="item">
        <typename
          name="founded_item_select"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="representation"/>
      <algorithm>

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
        'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

      </algorithm>

    </function>

    <function
      name="valid_measure_value">
      <parameter
        name="m">
        <typename
          name="measure_value"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m &gt; 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m &gt; 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

      </algorithm>

    </function>

    <function
      name="valid_units">
      <parameter
        name="m">
        <typename
          name="measure_with_unit"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.MASS_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.TIME_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.ELECTRIC_CURRENT_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.THERMODYNAMIC_TEMPERATURE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AMOUNT_OF_SUBSTANCE_MEASURE' IN
         TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.LUMINOUS_INTENSITY_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.PLANE_ANGLE_MEASURE' IN TYPEOF(
        m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.SOLID_ANGLE_MEASURE' IN TYPEOF(
        m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.AREA_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VOLUME_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.RATIO_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POSITIVE_LENGTH_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.POSITIVE_PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="vector_difference">
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim &lt;&gt; arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VECTOR' IN TYPEOF(arg1)
             THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'CONSTRUCTIVE_SOLID_GEOMETRY_3D_MIM.VECTOR' IN TYPEOF(arg2)
             THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

  </schema>

</express>
