<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="$Date: 2008/10/08 06:13:23 $" rcs.revision="$Revision: 1.94 $" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="fabrication_technology_arm schema_instance"/>
   <schema name="Fabrication_technology_arm">
      <interface kind="use" schema="Constructive_solid_geometry_2d_arm"/>
      <interface kind="use" schema="Extended_geometric_tolerance_arm"/>
      <interface kind="use" schema="Part_template_arm"/>
      <interface kind="use" schema="Layered_interconnect_complex_template_arm"/>
      <interface kind="reference" schema="Specification_document_arm">
         <interfaced.item name="get_document_definition"/>
      </interface>
      <interface kind="reference" schema="Characterizable_object_arm">
         <interfaced.item name="bag_to_set"/>
      </interface>
      <type name="ft_classification_item">
         <select extensible="YES" genericentity="YES" basedon="classification_item" selectitems="Stratum_technology_occurrence_relationship"/>
      </type>
      <type name="ft_documented_element_select">
         <select extensible="YES" genericentity="YES" basedon="documented_element_select" selectitems="Passage_technology Stratum_technology"/>
      </type>
      <type name="ft_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="Design_layer_technology Documentation_layer_technology"/>
      </type>
      <type name="ft_material_item_select">
         <select extensible="YES" genericentity="YES" basedon="material_item_select" selectitems="Passage_technology Stratum_technology"/>
      </type>
      <type name="ft_property_assignment_select">
         <select basedon="property_assignment_select" selectitems="Stratum_technology Passage_technology"/>
      </type>
      <type name="ft_requirement_assignment_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assignment_item" selectitems="Passage_technology Stratum_technology Stratum_technology_occurrence Stratum_technology_occurrence_relationship"/>
      </type>
      <type name="ft_terminus_condition">
         <enumeration extensible="YES" items="bilateral_bond bilateral_complete_removal unilateral_bond"/>
      </type>
      <type name="layer_position_type">
         <enumeration items="secondary all external primary internal"/>
      </type>
      <type name="predefined_design_layer_purpose">
         <enumeration items="other_signal lands_only power_or_ground embedded_passive_capacitor_dielectric embedded_passive_resistor"/>
      </type>
      <type name="predefined_documentation_layer_purpose">
         <enumeration items="soldermask solderpaste silkscreen generic_layer glue gluemask pastemask finish_coating"/>
      </type>
      <type name="stiffness_class">
         <enumeration items="fluid_like_with_constant_thickness fluid_like_with_varying_thickness stiff_laminate"/>
      </type>
      <type name="trace_class">
         <enumeration items="microstrip stripline co_planar_waveguide"/>
      </type>
      <type name="up_or_down">
         <enumeration items="independent precedent subsequent"/>
      </type>
      <entity name="Allocated_passage_minimum_annular_ring" supertypes="Characterizable_object">
         <explicit name="connected_minimum_annular_ring" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="unconnected_minimum_annular_ring" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="associated_passage_allocation">
            <typename name="Passage_technology_allocation_to_stack_model"/>
         </explicit>
         <explicit name="associated_stratum_technology_occurrence">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <where label="WR1" expression="EXISTS(connected_minimum_annular_ring) OR&#10;        EXISTS(unconnected_minimum_annular_ring)"/>
         <where label="WR2" expression="associated_stratum_technology_occurrence IN associated_passage_allocation\Stratum_sub_stack.&#10;                                                        associated_stackup\Stratum_stack_model.composing_occurrence"/>
      </entity>
      <entity name="Copy_stratum_technology_occurrence_relationship" supertypes="Derived_stratum_technology_occurrence_relationship"/>
      <entity name="Default_component_termination_passage_definition" supertypes="Passage_technology">
         <explicit name="allowed_component_terminal_extent">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <explicit name="as_finished_deposition_thickness">
            <typename name="Length_tolerance_characteristic"/>
            <redeclaration entity-ref="Passage_technology"/>
         </explicit>
         <explicit name="as_finished_passage_extent">
            <typename name="Length_tolerance_characteristic"/>
            <redeclaration entity-ref="Passage_technology"/>
         </explicit>
         <inverse name="deposition_material" entity="Passage_deposition_material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="1" upper="1"/>
            <redeclaration entity-ref="Passage_technology"/>
         </inverse>
         <where label="WR1" expression="'CONDUCTIVITY_MATERIAL_ASPECTS_ARM.'+ 'MATERIAL_IDENTIFICATION_WITH_CONDUCTIVITY_CLASSIFICATION' IN TYPEOF (deposition_material[1])"/>
      </entity>
      <entity name="Default_tapered_blind_via_definition" supertypes="Default_via_definition">
         <explicit name="as_finished_interior_passage_extent">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <where label="WR1" expression="less(as_finished_interior_passage_extent, SELF\default_via_definition.as_finished_passage_extent)"/>
      </entity>
      <entity name="Default_unsupported_passage_definition" supertypes="Passage_technology">
         <explicit name="as_finished_passage_extent">
            <typename name="Length_tolerance_characteristic"/>
            <redeclaration entity-ref="Passage_technology"/>
         </explicit>
      </entity>
      <entity name="Default_via_definition" supertypes="Passage_technology">
         <explicit name="as_finished_deposition_thickness">
            <typename name="Length_tolerance_characteristic"/>
            <redeclaration entity-ref="Passage_technology"/>
         </explicit>
         <explicit name="as_finished_passage_extent">
            <typename name="Length_tolerance_characteristic"/>
            <redeclaration entity-ref="Passage_technology"/>
         </explicit>
         <inverse name="deposition_material" entity="Passage_deposition_material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="1" upper="1"/>
            <redeclaration entity-ref="Passage_technology"/>
         </inverse>
         <where label="WR1" expression="'CONDUCTIVITY_MATERIAL_ASPECTS_ARM.'+ 'MATERIAL_IDENTIFICATION_WITH_CONDUCTIVITY_CLASSIFICATION' IN TYPEOF (deposition_material[1])"/>
      </entity>
      <entity name="Derived_stratum_technology_occurrence_relationship" abstract.supertype="YES" supertypes="Stratum_technology_occurrence_relationship" super.expression="ONEOF (Copy_stratum_technology_occurrence_relationship, Inverse_copy_stratum_technology_occurrence_relationship)"/>
      <entity name="Design_layer_technology" supertypes="Stratum_technology">
         <explicit name="design_layer_purpose" optional="YES">
            <typename name="predefined_design_layer_purpose"/>
         </explicit>
         <inverse name="externally_defined_design_layer_purpose" entity="External_source_identification" attribute="item">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <where label="WR1" expression="(SIZEOF([SELF\Stratum_technology.stratum_material[1]\Material_identification_with_conductivity_classification.electrical_conductivity_classification,&#10;           SELF\Stratum_technology.stratum_material[1]\Material_identification_with_conductivity_classification.thermal_conductivity_classification] *&#10;           ['conductive']) &gt;= 1) OR&#10;       (SELF\Stratum_technology.stratum_material[1]\Material_identification_with_conductivity_classification.magnetic_permeability_classification IN ['highly permeable']) OR&#10;       (SELF\Stratum_technology.stratum_material[1]\Material_identification_with_conductivity_classification.optical_insertion_loss_classification IN ['vacuum', 'very low loss', 'low loss'])"/>
         <where label="WR2" expression="(EXISTS (design_layer_purpose)) XOR ((SIZEOF(externally_defined_design_layer_purpose)) = 1)"/>
      </entity>
      <entity name="Design_specific_stratum_technology_mapping_relationship" supertypes="Stratum_technology_mapping_relationship">
         <explicit name="scope">
            <typename name="Library_to_design_stack_model_mapping"/>
         </explicit>
      </entity>
      <entity name="Design_stack_model" supertypes="Stratum_stack_model">
         <explicit name="model_thickness" optional="YES">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <derived name="reference_model" expression="reference_model_relationship[1]\Library_to_design_stack_model_mapping.relating_view">
            <typename name="Library_stack_model"/>
         </derived>
         <inverse name="reference_model_relationship" entity="Library_to_design_stack_model_mapping" attribute="related_view">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <inverse name="sub_stack" entity="Stratum_sub_stack" attribute="associated_stackup">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="NOT EXISTS(reference_model_relationship[1]) OR &#10;          ((SELF\Stratum_stack_model.composing_occurrence * reference_model\Stratum_stack_model.composing_occurrence) = &#10;           SELF\Stratum_stack_model.composing_occurrence)"/>
      </entity>
      <entity name="Documentation_layer_technology" supertypes="Stratum_technology">
         <explicit name="pre_defined_documentation_layer_purpose" optional="YES">
            <typename name="predefined_documentation_layer_purpose"/>
         </explicit>
         <inverse name="externally_defined_documentation_layer_purpose" entity="External_source_identification" attribute="item">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <where label="WR1" expression="(EXISTS (pre_defined_documentation_layer_purpose)) XOR ((SIZEOF(externally_defined_documentation_layer_purpose)) = 1)"/>
      </entity>
      <entity name="Equivalent_stackup_model_definition" supertypes="Product_view_definition View_definition_relationship">
         <explicit name="primary_stackup_model">
            <typename name="Stratum_stack_model"/>
            <redeclaration entity-ref="View_definition_relationship" old_name="relating_view"/>
         </explicit>
         <explicit name="equivalent_stackup_model">
            <typename name="Stratum_stack_model"/>
            <redeclaration entity-ref="View_definition_relationship" old_name="related_view"/>
         </explicit>
         <explicit name="equivalent_sub_stacks">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Equivalent_sub_stack_definition"/>
         </explicit>
         <where label="WR1" expression="primary_stackup_model :&lt;&gt;: equivalent_stackup_model"/>
         <where label="WR2" expression="SIZEOF(QUERY( ess &lt;* equivalent_sub_stacks |&#10;               NOT (ess\Equivalent_sub_stack_definition.equivalent_stack\Stratum_sub_stack.associated_stackup :=: equivalent_stackup_model)&#10;                  )) = 0"/>
         <where label="WR3" expression="acyclic_equivalent_stackup_model_definition(SELF,&#10;                    [equivalent_stackup_model],&#10;                    'FABRICATION_TECHNOLOGY_ARM.EQUIVALENT_STACKUP_MODEL_DEFINITION')"/>
      </entity>
      <entity name="Equivalent_sub_stack_definition" supertypes="Product_view_definition">
         <explicit name="equivalent_stack">
            <typename name="Local_linear_stack"/>
         </explicit>
         <explicit name="primary_sto">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="primary_sto_link">
            <typename name="Stratum_technology_occurrence_link"/>
         </explicit>
         <where label="WR1" expression="primary_sto IN [primary_sto_link\Stratum_technology_occurrence_relationship.sto_1,&#10;                               primary_sto_link\Stratum_technology_occurrence_relationship.sto_2]"/>
         <where label="WR2" expression="equivalent_stack\Stratum_sub_stack.associated_stackup :&lt;&gt;: primary_sto_link\Stratum_technology_occurrence_relationship.scope"/>
      </entity>
      <entity name="Footprint_library_stratum_technology" supertypes="Stratum_technology">
         <where label="WR1" expression="NOT EXISTS(stratum_thickness)"/>
      </entity>
      <entity name="Impedance_measurement_setup_requirement" supertypes="Predefined_requirement_view_definition">
         <explicit name="characterized_stackup">
            <typename name="Stratum_sub_stack"/>
         </explicit>
         <explicit name="measurement_method">
            <typename name="Process_specification"/>
         </explicit>
         <explicit name="measurement_stratum">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="reference_stratum">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <derived name="associated_stratum" expression="reference_stratum + measurement_stratum">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Stratum_technology_occurrence"/>
         </derived>
         <where label="WR1" expression="SELF\Product_view_definition.initial_context.life_cycle_stage = 'test'"/>
         <where label="WR2" expression="NOT EXISTS(SELF\Product_view_definition.id)"/>
         <where label="WR3" expression="SIZEOF([measurement_stratum] * reference_stratum) = 0"/>
         <where label="WR4" expression="SIZEOF(associated_stratum * characterized_stackup\Stratum_sub_stack.associated_stackup\Stratum_stack_model.composing_occurrence)&#10;           = SIZEOF(associated_stratum)"/>
      </entity>
      <entity name="Impedance_requirement" supertypes="Predefined_requirement_view_definition">
         <explicit name="characterized_class">
            <typename name="trace_class"/>
         </explicit>
         <explicit name="characterized_class_range">
            <typename name="Value_range"/>
         </explicit>
         <explicit name="test_bench">
            <typename name="Impedance_measurement_setup_requirement"/>
         </explicit>
         <explicit name="test_method">
            <typename name="Test_specification"/>
         </explicit>
         <explicit name="tolerance">
            <typename name="Tolerance_characteristic"/>
         </explicit>
         <where label="WR1" expression="SELF\Product_view_definition.initial_context.life_cycle_stage = 'test'"/>
         <where label="WR2" expression="NOT EXISTS(SELF\Product_view_definition.id)"/>
      </entity>
      <entity name="Inverse_copy_stratum_technology_occurrence_relationship" supertypes="Derived_stratum_technology_occurrence_relationship"/>
      <entity name="Library_to_design_stack_model_mapping" supertypes="View_definition_relationship">
         <explicit name="relating_view">
            <typename name="Library_stack_model"/>
            <redeclaration entity-ref="View_definition_relationship"/>
         </explicit>
         <explicit name="related_view">
            <typename name="Design_stack_model"/>
            <redeclaration entity-ref="View_definition_relationship"/>
         </explicit>
      </entity>
      <entity name="Local_linear_stack" supertypes="Stratum_sub_stack">
         <explicit name="stratum_technology_sequence">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology_occurrence_link"/>
            <redeclaration entity-ref="Stratum_sub_stack"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(get_stack(stratum_technology_sequence)) = (SIZEOF(stratum_technology_sequence) + 1)"/>
         <where label="WR2" expression="sts_vertex_degree_check(stratum_technology_sequence, 2)"/>
      </entity>
      <entity name="Passage_deposition_material_identification" supertypes="Material_identification">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Passage_technology"/>
            <redeclaration entity-ref="Material_identification"/>
         </explicit>
      </entity>
      <entity name="Passage_filling_material_identification" supertypes="Material_identification">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Passage_technology"/>
            <redeclaration entity-ref="Material_identification"/>
         </explicit>
      </entity>
      <entity name="Passage_technology" supertypes="Characterizable_object Item_shape" super.expression="ONEOF (Default_via_definition, Default_component_termination_passage_definition, Default_unsupported_passage_definition)">
         <explicit name="as_finished_deposition_thickness" optional="YES">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <explicit name="as_finished_passage_extent" optional="YES">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <explicit name="maximum_aspect_ratio" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="minimum_finished_size" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="plated_passage">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="passage_terminus_condition" optional="YES">
            <typename name="ft_terminus_condition"/>
         </explicit>
         <explicit name="minimum_fabrication_allowance" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <derived name="described_element" expression="SELF">
            <typename name="Passage_technology"/>
            <redeclaration entity-ref="Item_shape"/>
         </derived>
         <derived name="specification" expression="get_document_definition(SELF, 'specification', &#10;  			'SPECIFICATION_DOCUMENT_ARM.PROCESS_SPECIFICATION')">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="Document_definition"/>
         </derived>
         <inverse name="deposition_material" entity="Passage_deposition_material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <inverse name="fill_material" entity="Passage_filling_material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <unique label="UR1">
            <unique.attribute entity-ref="Characterizable_object" attribute="name"/>
         </unique>
         <where label="WR1" expression="NOT (SIZEOF(deposition_material) = 1) OR&#10;            ('CONDUCTIVITY_MATERIAL_ASPECTS_ARM.'+ 'MATERIAL_IDENTIFICATION_WITH_CONDUCTIVITY_CLASSIFICATION' IN TYPEOF (deposition_material[1]))"/>
         <where label="WR2" expression="NOT plated_passage OR (SIZEOF(deposition_material) = 1)"/>
         <where label="WR3" expression="NOT EXISTS(as_finished_deposition_thickness) OR (SIZEOF(deposition_material) = 1)"/>
         <where label="WR4" expression="NOT plated_passage OR&#10;            (SIZEOF([deposition_material[1]\Material_identification_with_conductivity_classification.electrical_conductivity_classification,&#10;                    deposition_material[1]\Material_identification_with_conductivity_classification.thermal_conductivity_classification] *&#10;                   ['conductive']) &gt;= 1)"/>
         <where label="WR5" expression="NOT ((passage_terminus_condition = ft_terminus_condition.bilateral_bond) OR&#10;                 (passage_terminus_condition = ft_terminus_condition.unilateral_bond)) OR&#10;            plated_passage"/>
      </entity>
      <entity name="Passage_technology_allocation_to_stack_model" supertypes="Stratum_sub_stack">
         <explicit name="allocated_technology">
            <typename name="Passage_technology"/>
         </explicit>
         <explicit name="single_stratum_passage_location" optional="YES">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="target_stratum" optional="YES">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="connected_minimum_annular_ring" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="unconnected_minimum_annular_ring" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <derived name="terminus_stratum" expression="ft_get_terminus(SELF\Stratum_sub_stack.stratum_technology_sequence)">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Stratum_technology_occurrence"/>
         </derived>
         <where label="WR1" expression="(NOT EXISTS(single_stratum_passage_location) OR&#10;        (single_stratum_passage_location IN&#10;        SELF\Stratum_sub_stack.associated_stackup.composing_occurrence))"/>
         <where label="WR2" expression="EXISTS(SELF\Stratum_sub_stack.stratum_technology_sequence) XOR&#10;           EXISTS(single_stratum_passage_location)"/>
         <where label="WR3" expression="SIZEOF(get_stack(SELF\Stratum_sub_stack.stratum_technology_sequence)) = &#10;                 (SIZEOF(SELF\Stratum_sub_stack.stratum_technology_sequence) + 1)"/>
         <where label="WR4" expression="sts_vertex_degree_check(SELF\Stratum_sub_stack.stratum_technology_sequence, 2)"/>
         <where label="WR5" expression="NOT EXISTS(single_stratum_passage_location) OR NOT EXISTS(target_stratum)"/>
         <where label="WR6" expression="NOT EXISTS(target_stratum) OR&#10;			  ((target_stratum IN SELF\Stratum_sub_stack.associated_stackup.composing_occurrence) AND&#10;	           (target_stratum IN terminus_stratum))"/>
      </entity>
      <entity name="Stratum_stack_model" abstract.supertype="YES" supertypes="Template_definition" super.expression="ONEOF (Design_stack_model, Library_stack_model)">
         <derived name="composing_occurrence" expression="get_stack(composing_link)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology_occurrence"/>
         </derived>
         <inverse name="composing_link" entity="Stratum_technology_occurrence_relationship" attribute="scope">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF(QUERY( cl &lt;* composing_link |&#10;            NOT('FABRICATION_ARM.STRATUM_TECHNOLOGY_OCCURRENCE_LINK' IN TYPEOF(cl))&#10;                  )) = 0"/>
      </entity>
      <entity name="Stratum_sub_stack" abstract.supertype="YES" supertypes="Template_definition" super.expression="ONEOF (Local_linear_stack, Passage_technology_allocation_to_stack_model)">
         <explicit name="stratum_technology_sequence" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology_occurrence_link"/>
         </explicit>
         <explicit name="stack_thickness" optional="YES">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <explicit name="associated_stackup">
            <typename name="Design_stack_model"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(sts &lt;* stratum_technology_sequence | &#10;        NOT(associated_stackup :=: sts\Stratum_technology_occurrence_relationship.scope)) ) = 0"/>
      </entity>
      <entity name="Stratum_surface_technology" supertypes="Shape_element">
         <explicit name="associated_technology">
            <typename name="Stratum_technology"/>
            <redeclaration entity-ref="Shape_element" old_name="containing_shape"/>
         </explicit>
         <derived name="surface_specification" expression="get_document_definition(SELF, 'surface specification',  	&#10;                                      'SPECIFICATION_DOCUMENT_ARM.SURFACE_FINISH_SPECIFICATION')">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="Document_definition"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(USEDIN(SELF,'SURFACE_CONDITIONS_ARM.SURFACE_CONDITION_ASSOCIATION.DESCRIBED_ELEMENT')) &gt; 0) OR &#10;            (SIZEOF(get_document_definition(SELF, 'surface specification', 'SPECIFICATION_DOCUMENT_ARM.SURFACE_FINISH_SPECIFICATION')) = 1)"/>
      </entity>
      <entity name="Stratum_technology" supertypes="Characterizable_object Item_shape" super.expression="ONEOF (Design_layer_technology, Documentation_layer_technology)">
         <explicit name="layer_position">
            <typename name="layer_position_type"/>
         </explicit>
         <explicit name="stratum_thickness" optional="YES">
            <typename name="Length_tolerance_characteristic"/>
         </explicit>
         <explicit name="minimum_finished_feature_size" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="laminate_stiffness_class" optional="YES">
            <typename name="stiffness_class"/>
         </explicit>
         <explicit name="minimum_finished_feature_spacing" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="maximum_feature_size_requirement" optional="YES">
            <typename name="Length_data_element"/>
         </explicit>
         <explicit name="minimum_aspect_ratio" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived name="described_element" expression="SELF">
            <typename name="Stratum_technology"/>
            <redeclaration entity-ref="Item_shape"/>
         </derived>
         <derived name="specification" expression="get_document_definition(SELF, 'specification', &#10;  			'SPECIFICATION_DOCUMENT_ARM.PROCESS_SPECIFICATION')">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="Document_definition"/>
         </derived>
         <derived name="surface_specification" expression="get_document_definition(SELF, 'surface specification', &#10;  			'SPECIFICATION_DOCUMENT_ARM.SURFACE_FINISH_SPECIFICATION')">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="Document_definition"/>
         </derived>
         <inverse name="stratum_material" entity="Material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="1" upper="1"/>
         </inverse>
         <inverse name="surface_technology" entity="Stratum_surface_technology" attribute="associated_technology">
            <inverse.aggregate type="SET" lower="0" upper="2"/>
         </inverse>
         <unique label="UR1">
            <unique.attribute entity-ref="Characterizable_object" attribute="name"/>
         </unique>
         <where label="WR1" expression="NOT (layer_position = layer_position_type.primary) OR ('FABRICATION_TECHNOLOGY_ARM.DESIGN_LAYER_TECHNOLOGY' IN TYPEOF(SELF))"/>
         <where label="WR2" expression="NOT (layer_position = layer_position_type.secondary) OR ('FABRICATION_TECHNOLOGY_ARM.DESIGN_LAYER_TECHNOLOGY' IN TYPEOF(SELF))"/>
         <where label="WR3" expression="'CONDUCTIVITY_MATERIAL_ASPECTS_ARM.'+ 'MATERIAL_IDENTIFICATION_WITH_CONDUCTIVITY_CLASSIFICATION' IN TYPEOF (stratum_material)"/>
         <where label="WR4" expression="NOT((SIZEOF(surface_technology) &gt; 0 ) AND (SIZEOF(surface_specification) = 1))"/>
      </entity>
      <entity name="Stratum_technology_mapping_relationship">
         <explicit name="source_stratum_technology">
            <typename name="Footprint_library_stratum_technology"/>
         </explicit>
         <explicit name="target_stratum_technology">
            <typename name="Stratum_technology"/>
         </explicit>
         <where label="WR1" expression="NOT ('FABRICATION_TECHNOLOGY_ARM.FOOTPRINT_LIBRARY_STRATUM_TECHNOLOGY' IN TYPEOF(target_stratum_technology))"/>
         <where label="WR2" expression="acyclic_stratum_technology_mapping_relationship(SELF,&#10;        [target_stratum_technology], &#10;       'FABRICATION_TECHNOLOGY_ARM.STRATUM_TECHNOLOGY_MAPPING_RELATIONSHIP')"/>
      </entity>
      <entity name="Stratum_technology_occurrence">
         <explicit name="name">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="definition">
            <typename name="Stratum_technology"/>
         </explicit>
         <explicit name="primary" optional="YES">
            <typename name="Stratum_surface_technology"/>
         </explicit>
         <explicit name="rotation" optional="YES">
            <typename name="Angle_data_element"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="name"/>
         </unique>
      </entity>
      <entity name="Stratum_technology_occurrence_feature_constraint" supertypes="Stratum_technology_occurrence_relationship">
         <explicit name="difference_distance" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="intersection_distance" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="distance_unit" optional="YES">
            <typename name="Length_unit"/>
         </explicit>
         <where label="WR1" expression="NOT (EXISTS (difference_distance) OR EXISTS(intersection_distance)) XOR&#10;           EXISTS(distance_unit)"/>
      </entity>
      <entity name="Stratum_technology_occurrence_link" supertypes="Stratum_technology_occurrence_relationship">
         <explicit name="base_stratum_technology_occurrence" optional="YES">
            <typename name="up_or_down"/>
         </explicit>
         <where label="WR1" expression="NOT (SELF\Stratum_technology_occurrence_relationship.sto_1 :=: SELF\Stratum_technology_occurrence_relationship.sto_2) OR &#10;                (SIZEOF(SELF\Stratum_technology_occurrence_relationship.scope\Stratum_stack_model.composing_link) = 1)"/>
      </entity>
      <entity name="Stratum_technology_occurrence_relationship" abstract.supertype="YES" super.expression="ONEOF (Derived_stratum_technology_occurrence_relationship, Stratum_technology_occurrence_link, Stratum_technology_occurrence_swap_relationship, Stratum_technology_occurrence_feature_constraint)">
         <explicit name="sto_1">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="sto_2">
            <typename name="Stratum_technology_occurrence"/>
         </explicit>
         <explicit name="scope">
            <typename name="Stratum_stack_model"/>
         </explicit>
         <where label="WR1" expression="acyclic_stratum_technology_occurrence_relationship(SELF, [sto_2], &#10;           'FABRICATION_TECHNOLOGY_ARM.STRATUM_TECHNOLOGY_OCCURRENCE_RELATIONSHIP')"/>
      </entity>
      <entity name="Stratum_technology_occurrence_swap_relationship" supertypes="Stratum_technology_occurrence_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="Stratum_technology_occurrence_relationship" attribute="sto_1"/>
            <unique.attribute entity-ref="Stratum_technology_occurrence_relationship" attribute="scope"/>
         </unique>
         <unique label="UR2">
            <unique.attribute entity-ref="Stratum_technology_occurrence_relationship" attribute="sto_2"/>
            <unique.attribute entity-ref="Stratum_technology_occurrence_relationship" attribute="scope"/>
         </unique>
         <where label="WR1" expression="SELF\Stratum_technology_occurrence_relationship.sto_1 &lt;&gt; SELF\Stratum_technology_occurrence_relationship.sto_2"/>
         <where label="WR2" expression="(SELF\Stratum_technology_occurrence_relationship.sto_1 IN SELF\Stratum_technology_occurrence_relationship.scope\Stratum_stack_model.composing_occurrence) AND&#10;         (SELF\Stratum_technology_occurrence_relationship.sto_2 IN SELF\Stratum_technology_occurrence_relationship.scope\Stratum_stack_model.composing_occurrence)"/>
      </entity>
      <entity name="Stratum_technology_swap_relationship">
         <explicit name="primary_stratum_technology">
            <typename name="Stratum_technology"/>
         </explicit>
         <explicit name="secondary_stratum_technology">
            <typename name="Stratum_technology"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="primary_stratum_technology"/>
         </unique>
         <unique label="UR2">
            <unique.attribute attribute="secondary_stratum_technology"/>
         </unique>
         <where label="WR1" expression="NOT (('FABRICATION_TECHNOLOGY_ARM.DOCUMENTATION_LAYER_TECHNOLOGY' IN TYPEOF(primary_stratum_technology)) AND&#10;              EXISTS(primary_stratum_technology\Documentation_layer_technology.pre_defined_documentation_layer_purpose))&#10;          OR&#10;          (primary_stratum_technology\Documentation_layer_technology.pre_defined_documentation_layer_purpose =&#10;           secondary_stratum_technology\Documentation_layer_technology.pre_defined_documentation_layer_purpose)"/>
         <where label="WR2" expression="TYPEOF(primary_stratum_technology) = TYPEOF(secondary_stratum_technology)"/>
         <where label="WR3" expression="primary_stratum_technology\Stratum_technology.layer_position = layer_position_type.primary"/>
         <where label="WR4" expression="secondary_stratum_technology\Stratum_technology.layer_position = layer_position_type.secondary"/>
         <where label="WR5" expression="primary_stratum_technology &lt;&gt; secondary_stratum_technology"/>
         <where label="WR6" expression="acyclic_stratum_technology_swap_relationship(SELF,&#10;        [secondary_stratum_technology], &#10;       'FABRICATION_TECHNOLOGY_ARM.STRATUM_TECHNOLOGY_SWAP_RELATIONSHIP')"/>
      </entity>
      <function name="acyclic_equivalent_stackup_model_definition">
         <parameter name="relation">
            <typename name="Equivalent_stackup_model_definition"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_stack_model"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    x : SET OF Equivalent_stackup_model_definition := [];
END_LOCAL;

    IF relation.primary_stackup_model IN relatives THEN
      RETURN (FALSE);
    END_IF;
      x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.primary_stackup_model,
        'FABRICATION_TECHNOLOGY_ARM.' + 'EQUIVALENT_STACKUP_MODEL_DEFINITION.' +
        'EQUIVALENT_STACKUP_MODEL')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_equivalent_stackup_model_definition(x[i], relatives +
        relation.primary_stackup_model, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_stratum_technology_mapping_relationship">
         <parameter name="relation">
            <typename name="Stratum_technology_mapping_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     x : SET OF Stratum_technology_mapping_relationship := [];
  END_LOCAL;

    IF relation.source_stratum_technology IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.source_stratum_technology,
      'FABRICATION_TECHNOLOGY_ARM.' +
      'STRATUM_TECHNOLOGY_MAPPING_RELATIONSHIP.' +
      'TARGET_STRATUM_TECHNOLOGY')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_stratum_technology_mapping_relationship(x[i], relatives +
        relation.source_stratum_technology, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_stratum_technology_occurrence_relationship">
         <parameter name="relation">
            <typename name="Stratum_technology_occurrence_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology_occurrence"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     x : SET OF Stratum_technology_occurrence_relationship := [];
  END_LOCAL;
    IF relation.sto_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.sto_1,
      'FABRICATION_TECHNOLOGY_ARM.' +
      'STRATUM_TECHNOLOGY_OCCURRENCE_RELATIONSHIP.' +
      'STO_2')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_Stratum_technology_occurrence_relationship(x[i], relatives +
        relation.sto_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_stratum_technology_swap_relationship">
         <parameter name="relation">
            <typename name="Stratum_technology_swap_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Stratum_technology"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     x : SET OF Stratum_technology_swap_relationship := [];
  END_LOCAL;

    IF relation.primary_stratum_technology IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.primary_stratum_technology,
      'FABRICATION_TECHNOLOGY_ARM.' +
      'STRATUM_TECHNOLOGY_SWAP_RELATIONSHIP.' +
      'SECONDARY_STRATUM_TECHNOLOGY')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_stratum_technology_swap_relationship(x[i], relatives +
        relation.primary_stratum_technology, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="ft_get_terminus">
         <parameter name="input">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Stratum_technology_occurrence_link"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="Stratum_technology_occurrence"/>
         <algorithm>LOCAL
  sto : SET OF Stratum_technology_occurrence := get_stack(input);
  i : INTEGER := 0;
  j : INTEGER := 0;
  pstoo : SET OF Stratum_technology_occurrence := [];
  sstoo : SET OF Stratum_technology_occurrence := [];
END_LOCAL;
  pstoo := sto;
  sstoo := sto;
 REPEAT i := 1 TO SIZEOF(sto) BY 1;
  REPEAT j := 1 TO SIZEOF(input) BY 1;
	IF (input[j]\Stratum_technology_occurrence_relationship.sto_1 :=: sto[i]) THEN 
	  pstoo := pstoo - sto[i];
	END_IF;  
	IF (input[j]\Stratum_technology_occurrence_relationship.sto_2 :=: sto[i]) THEN 
	  sstoo := sstoo - sto[i];
	END_IF;  
  END_REPEAT;                                     
 END_REPEAT;                                     
RETURN(pstoo + sstoo);</algorithm>
      </function>
      <function name="get_stack">
         <parameter name="input">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Stratum_technology_occurrence_link"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="Stratum_technology_occurrence"/>
         <algorithm>LOCAL
      sto : SET OF Stratum_technology_occurrence := [];
      i : INTEGER := 0;
    END_LOCAL;
    REPEAT  i := 1 TO SIZEOF(input) BY 1;
      sto := sto + input[i]\Stratum_technology_occurrence_relationship.sto_1 + input[i]\Stratum_technology_occurrence_relationship.sto_2;
    END_REPEAT;
    RETURN(sto);</algorithm>
      </function>
      <function name="less">
         <parameter name="input1">
            <typename name="Length_tolerance_characteristic"/>
         </parameter>
         <parameter name="input2">
            <typename name="Length_tolerance_characteristic"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN(TRUE);</algorithm>
      </function>
      <function name="sts_vertex_degree_check">
         <parameter name="input">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Stratum_technology_occurrence_link"/>
         </parameter>
         <parameter name="n">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
   psto : INTEGER := 0;
   ssto : INTEGER := 0;
   sto : SET OF Stratum_technology_occurrence := get_stack(input);
   i : INTEGER := 0;
   j : INTEGER := 0;
   pass : BOOLEAN := TRUE;
 END_LOCAL;
  REPEAT i := 1 TO SIZEOF(sto) BY 1;
   REPEAT j := 1 TO SIZEOF(input) BY 1;
     IF (input[j]\Stratum_technology_occurrence_relationship.sto_1 :=: sto[i]) THEN 
      psto := psto + 1;
      IF (psto = n) THEN
       pass := FALSE; 
       ESCAPE; 
      END_IF;
     END_IF;  
     IF (input[j]\Stratum_technology_occurrence_relationship.sto_2 :=: sto[i]) THEN 
      ssto := ssto + 1;  
      IF (ssto = n) THEN 
       pass := FALSE; 
       ESCAPE; 
      END_IF;
     END_IF;  
   END_REPEAT;                                     
  END_REPEAT;                                     
 RETURN(pass);</algorithm>
      </function>
   </schema>
</express>
