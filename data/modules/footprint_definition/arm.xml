<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="arm_descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO/TS 10303-1646">
   <application name="JSDAI" owner="LKSoft" source="footprint_definition_arm schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="Footprint_definition_arm">
      <interface kind="use" schema="Layered_interconnect_complex_template_arm"/>
      <interface kind="use" schema="Package_arm"/>
      <interface kind="reference" schema="Support_resource_arm">
         <interfaced.item name="bag_to_set"/>
      </interface>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Breakout_footprint_definition" supertypes="Generic_footprint_definition">
         <explicit name="reference_footprint" optional="NO">
            <typename name="Footprint_definition"/>
         </explicit>
         <inverse attribute="assembly" entity="Stratum_feature_template_location_in_breakout_footprint_definition" name="breakout_traces">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SELF\Multi_stratum_structured_template.location = reference_footprint\Multi_stratum_structured_template.location" label="WR1"/>
      <where label="IP1"/>
         <where label="IP2"/>
         <where label="IP3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Breakout_footprint_definition_shape_model" supertypes="Structured_template_planar_shape_model">
         <explicit name="shape_characterized_definition" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="1"/>
            <typename name="Breakout_footprint_definition"/>
            <redeclaration entity-ref="Structured_template_planar_shape_model"/>
         </explicit>
         <explicit name="reference_shape" optional="NO">
            <typename name="Footprint_definition_shape_model"/>
         </explicit>
         <where expression="reference_shape.shape_characterized_definition[1] :=: shape_characterized_definition[1].reference_footprint" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Footprint_definition" supertypes="Generic_footprint_definition">
         <explicit name="reference_package" optional="YES">
            <typename name="Part_usage_view"/>
         </explicit>
         <derived expression="QUERY(trf &lt;* templates | 'FOOTPRINT_DEFINITION_ARM.PART_FEATURE_BASED_TEMPLATE_LOCATION' IN TYPEOF(trf))" name="locations_with_reference_feature">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="Part_feature_based_template_location"/>
         </derived>
         <where expression="SIZEOF (QUERY(shape &lt;* SELF\Structured_template.shapes |&#10;               NOT ('LAYERED_INTERCONNECT_COMPLEX_TEMPLATE_ARM.FOOTPRINT_DEFINITION_SHAPE_MODEL' IN TYPEOF(shape))&#10;              )) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY(tlist &lt;* SELF\Structured_template.templates |&#10;               ('FOOTPRINT_DEFINITION_ARM.FOOTPRINT_DEFINITION' IN TYPEOF(tlist.template))&#10;              )) = 0" label="WR2"/>
         <where expression="(SIZEOF(locations_with_reference_feature) = 0) OR&#10;           NOT EXISTS(reference_package) OR&#10;           (SIZEOF(QUERY( lwrf &lt;* locations_with_reference_feature | NOT(reference_package :=: lwrf\Part_feature_based_template_location.reference_feature\Part_feature.associated_definition))) = 0)" label="WR3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Footprint_definition_shape_model" supertypes="Structured_template_planar_shape_model">
         <explicit name="shape_characterized_definition" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="1"/>
            <typename name="Footprint_definition"/>
            <redeclaration entity-ref="Structured_template_planar_shape_model"/>
         </explicit>
         <explicit name="reference_shape" optional="YES">
            <typename name="lict_physical_unit_shape_model_select"/>
         </explicit>
         <explicit name="reference_seating_plane_placement" optional="YES">
            <typename name="Usage_concept_usage_relationship"/>
         </explicit>
         <where expression="NOT (SIZEOF(['PHYSICAL_UNIT_3D_SHAPE_ARM.PHYSICAL_UNIT_3D_SHAPE_MODEL',&#10;                         'PHYSICAL_UNIT_2D_SHAPE_ARM.PHYSICAL_UNIT_PLANAR_SHAPE_MODEL'] * TYPEOF(reference_shape)) = 1) OR &#10;            NOT ('PHYSICAL_UNIT_USAGE_VIEW_ARM.PART_USAGE_VIEW' IN TYPEOF(reference_shape\Physical_unit_shape_model.shape_characterized_definition)) OR&#10;            NOT ('LAYERED_INTERCONNECT_COMPLEX_TEMPLATE_ARM.FOOTPRINT_DEFINITION' IN TYPEOF(shape_characterized_definition[1])) OR      &#10;                 (shape_characterized_definition[1]\Footprint_definition.reference_package :=: reference_shape\Physical_unit_shape_model.shape_characterized_definition)" label="WR1"/>
         <where expression="NOT (SIZEOF(['PHYSICAL_UNIT_3D_SHAPE_ARM.PHYSICAL_UNIT_3D_SHAPE_MODEL',&#10;                         'PHYSICAL_UNIT_2D_SHAPE_ARM.PHYSICAL_UNIT_PLANAR_SHAPE_MODEL'] * TYPEOF(reference_shape)) = 1) OR &#10;                ('PHYSICAL_UNIT_USAGE_VIEW_ARM.PART_USAGE_VIEW' IN TYPEOF(reference_shape\Physical_unit_shape_model.shape_characterized_definition))" label="WR2"/>
         <where expression="NOT EXISTS(SELF\Representation.description)" label="WR3"/>
         <where expression="NOT EXISTS(reference_shape) OR EXISTS(shape_characterized_definition[1]\Footprint_definition.reference_package)" label="WR4"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR EXISTS(reference_shape)" label="WR5"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR ('PACKAGE_ARM.PACKAGE' IN TYPEOF(shape_characterized_definition[1]\Footprint_definition.reference_package))" label="WR6"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR ('NON_FEATURE_SHAPE_ELEMENT_ARM.SEATING_PLANE' IN &#10;                TYPEOF(reference_seating_plane_placement\Usage_concept_usage_relationship.associated_usage))" label="WR7"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR &#10;                ((reference_seating_plane_placement\Usage_concept_usage_relationship.associating_usage_shape\Usage_view_level_non_feature_shape_model.model_shape) =&#10;                reference_shape)" label="WR8"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR &#10;                ((reference_seating_plane_placement\Usage_concept_usage_relationship.associated_usage\Non_feature_shape_element.associated_definition) =&#10;                shape_characterized_definition[1]\Footprint_definition.reference_package)" label="WR9"/>
         <where expression="NOT EXISTS(reference_seating_plane_placement) OR ('PHYSICAL_UNIT_3D_SHAPE_ARM.PHYSICAL_UNIT_3D_SHAPE_MODEL' IN &#10;                TYPEOF(reference_seating_plane_placement\Usage_concept_usage_relationship.associating_usage_shape\Usage_view_level_non_feature_shape_model.model_shape))" label="WR10"/>
         <where expression="NOT (EXISTS(reference_seating_plane_placement) AND ('PHYSICAL_UNIT_2D_SHAPE_ARM.PHYSICAL_UNIT_PLANAR_SHAPE_MODEL' IN TYPEOF(reference_shape)))" label="WR11"/>
         <where expression="NOT ('PHYSICAL_UNIT_2D_SHAPE_ARM.PHYSICAL_UNIT_PLANAR_SHAPE_MODEL' IN TYPEOF(reference_shape)) OR&#10;                 (SELF\Geometric_model.context_of_items = reference_shape\Geometric_model.context_of_items)" label="WR12"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="Generic_footprint_definition" super.expression="ONEOF (Footprint_definition, Breakout_footprint_definition)" supertypes="Multi_stratum_structured_template">
         <derived expression="get_template_arrangement(padstacks)" name="padstack_based_location">
            <typename name="template_arrangement"/>
         </derived>
         <derived expression="QUERY(tlict &lt;* SELF\Structured_template.templates |&#10;         ('LAYERED_INTERCONNECT_COMPLEX_TEMPLATE_ARM.PADSTACK_DEFINITION' IN TYPEOF(tlict.template)))" name="padstacks">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="Template_location_in_structured_template"/>
         </derived>
         <derived expression="fd_get_single_stratum_components(SELF\Structured_template.templates)" name="single_stratum_components">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="Single_stratum_template"/>
         </derived>
         <where expression="SIZEOF(QUERY(ps &lt;* SELF\Structured_template.templates | (ps\Template_location_in_structured_template.template\Multi_stratum_structured_template.location &lt;&gt; SELF\Multi_stratum_structured_template.location)&#10;              AND (ps\Template_location_in_structured_template.template\Multi_stratum_structured_template.location &lt;&gt; template_arrangement.symmetrical))) = 0" label="WR1"/>
         <where expression="((SELF\Multi_stratum_structured_template.location = template_arrangement.top) AND (SELF\Product_view_definition.initial_context\View_definition_context.description = 'top')) OR &#10;            (NOT (SELF\Multi_stratum_structured_template.location = template_arrangement.top) AND NOT (SELF\Product_view_definition.initial_context\View_definition_context.description = 'top'))" label="WR2"/>
         <where expression="((SELF\Multi_stratum_structured_template.location = template_arrangement.bottom) AND (SELF\Product_view_definition.initial_context\View_definition_context.description = 'bottom')) OR &#10;            (NOT (SELF\Multi_stratum_structured_template.location = template_arrangement.bottom) AND NOT (SELF\Product_view_definition.initial_context\View_definition_context.description = 'bottom'))" label="WR3"/>
         <where expression="((SELF\Multi_stratum_structured_template.location = template_arrangement.symmetrical) AND (SELF\Product_view_definition.initial_context\View_definition_context.description = 'symmetrical')) OR &#10;            (NOT (SELF\Multi_stratum_structured_template.location = template_arrangement.symmetrical) AND NOT (SELF\Product_view_definition.initial_context\View_definition_context.description = 'symmetrical'))" label="WR4"/>
         <where expression="((SELF\Multi_stratum_structured_template.location = template_arrangement.swappable) AND (SELF\Product_view_definition.initial_context\View_definition_context.description = 'swappable')) OR &#10;            (NOT (SELF\Multi_stratum_structured_template.location = template_arrangement.swappable) AND NOT (SELF\Product_view_definition.initial_context\View_definition_context.description = 'swappable'))" label="WR5"/>
         <where expression="NOT (SIZEOF(single_stratum_components) = 0) OR (SELF\Multi_stratum_structured_template.location = padstack_based_location)" label="WR6"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Package_footprint_relationship_definition" supertypes="Product_view_definition">
         <derived expression="fd_get_amodel(SELF)" name="associated_model">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="1"/>
            <typename name="Geometric_model"/>
         </derived>
         <derived expression="fd_get_rmodels(related_elements)" name="related_models">
            <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="2"/>
            <typename name="Geometric_model"/>
         </derived>
         <derived expression="fd_get_transforms(associated_model, related_models)" name="related_transforms">
            <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="2"/>
            <typename name="Geometric_model_relationship_with_transformation"/>
         </derived>
         <inverse attribute="related_view" entity="View_definition_relationship" name="related_elements">
            <inverse.aggregate lower="2" type="SET" upper="2"/>
         </inverse>
         <where expression="SIZEOF(QUERY(re &lt;* related_elements | &#10;            ('PACKAGE_ARM.PACKAGE' IN TYPEOF(re\View_definition_relationship.relating_view))&#10;            )) = 1" label="WR1"/>
         <where expression="SIZEOF(QUERY(re &lt;* related_elements | &#10;            ('FOOTPRINT_DEFINITION_ARM.FOOTPRINT_DEFINITION' IN TYPEOF(re\View_definition_relationship.relating_view))&#10;            )) = 1" label="WR2"/>
         <where expression="SIZEOF(related_models) = 2" label="WR3"/>
         <where expression="SIZEOF(associated_model) = 1" label="WR4"/>
         <where expression="SIZEOF(QUERY(rm &lt;* related_models |&#10;                  ('PHYSICAL_UNIT_2D_SHAPE_ARM.PHYSICAL_UNIT_PLANAR_SHAPE_MODEL' IN TYPEOF(rm))&#10;              )) = 1" label="WR5"/>
         <where expression="SIZEOF(QUERY(rm &lt;* related_models |&#10;                  ('FOOTPRINT_DEFINITION_ARM.FOOTPRINT_DEFINITION_SHAPE_MODEL' IN TYPEOF(rm))&#10;              )) = 1" label="WR6"/>
         <where expression="'LAYERED_2D_SHAPE_ARM.PLANAR_SHAPE_MODEL' IN TYPEOF(associated_model[1])" label="WR7"/>
         <where expression="SIZEOF(related_transforms) = 2" label="WR8"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Part_feature_based_template_location" supertypes="Template_location_in_structured_template">
         <explicit name="reference_feature" optional="NO">
            <typename name="Part_feature"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="Stratum_feature_template_location_in_breakout_footprint_definition" supertypes="Stratum_specific_template_location">
         <explicit name="assembly" optional="NO">
            <typename name="Breakout_footprint_definition"/>
            <redeclaration entity-ref="Template_location_in_structured_template"/>
         </explicit>
         <explicit name="template" optional="NO">
            <typename name="Stratum_feature_template"/>
            <redeclaration entity-ref="Template_location_in_structured_template"/>
         </explicit>
         <explicit name="original_padstack" optional="NO">
            <typename name="Part_feature_based_template_location"/>
         </explicit>
         <explicit name="breakout_padstack" optional="NO">
            <typename name="Template_location_in_structured_template"/>
         </explicit>
         <where expression="original_padstack.assembly :=: assembly.reference_footprint" label="WR1"/>
         <where expression="breakout_padstack.assembly :=: assembly" label="WR2"/>
      </entity>
      <subtype.constraint abstract.supertype="NO" entity="Structured_template_planar_shape_model" name="structured_template_planar_shape_model_subtypes" super.expression="ONEOF (Breakout_footprint_definition_shape_model, Footprint_definition_shape_model)"/>
      <subtype.constraint abstract.supertype="NO" entity="Multi_stratum_structured_template" name="multi_stratum_structured_template_subtypes" super.expression="ONEOF (Padstack_definition, Generic_footprint_definition, Multi_stratum_special_symbol_template)"/>
      <function name="fd_get_amodel">
         <parameter name="input">
            <typename name="Product_view_definition"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="Geometric_model"/>
         <algorithm>LOCAL
      gm : SET OF Geometric_model := [];
      sda : SET OF Shape_description_association := [];      
    END_LOCAL;
    
    -- process input.primary_shape_representation
    if 'ELEMENTAL_GEOMETRIC_SHAPE_ARM.GEOMETRIC_MODEL' IN TYPEOF(input.primary_shape_representation) THEN
    	pm := gm + input.primary_shape_representation;
    END_IF;

    -- process input.auxiliary_shape_representations
    IF (SIZEOF(input.auxiliary_shape_representations ) &gt;= 0) THEN
      REPEAT i := 1 TO HIINDEX(input.auxiliary_shape_representations);
        if 'ELEMENTAL_GEOMETRIC_SHAPE_ARM.GEOMETRIC_MODEL' IN TYPEOF(input.auxiliary_shape_representations[i]) THEN
    	  gm := gm + input.auxiliary_shape_representations[i];
        END_IF;
      END_REPEAT;
    END_IF;

    -- process other SHAPE_DESCRIPTION_ASSOCIATIONs that could still hang around
    sda := bag_to_set(USEDIN(input,'SHAPE_PROPERTY_ASSIGNMENT_ARM.SHAPE_DESCRIPTION_ASSOCIATION.DEFINITION'));
    IF (SIZEOF(sda) &gt;= 0) THEN
      REPEAT i := 1 TO HIINDEX(sda);
        if 'ELEMENTAL_GEOMETRIC_SHAPE_ARM.GEOMETRIC_MODEL' IN TYPEOF(input.primary_shape_representation) THEN
          gm := gm + sda[i]\Property_definition_representation.used_representation;
        END_IF;
      END_REPEAT;    
    END_IF;

    RETURN (gm);</algorithm>
      </function>
      <function name="fd_get_components">
         <parameter name="input">
            <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="2"/>
            <typename name="View_definition_relationship"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="Product_view_definition"/>
         <algorithm>LOCAL
      pvd : SET OF Product_view_definition := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input);
      pvd := pvd + input[i]\View_definition_relationship.relating_view;
    END_REPEAT;
    RETURN (pvd);</algorithm>
      </function>
      <function name="fd_get_rmodels">
         <parameter name="input">
            <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="2"/>
            <typename name="View_definition_relationship"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="Geometric_model"/>
         <algorithm>LOCAL
      gm : SET OF Geometric_model := [];
      pvd : SET OF Product_view_definition := [];
    END_LOCAL;
      pvd := fd_get_components(input);
    IF (SIZEOF(pvd) &gt;= 0) THEN      
      REPEAT i := 1 TO HIINDEX(pvd);
        gm := gm + fd_get_amodel(pvd[i]);
      END_REPEAT;
      RETURN (gm);
    END_IF;
    RETURN(?);</algorithm>
      </function>
      <function name="fd_get_single_stratum_components">
         <parameter name="input">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="Template_location_in_structured_template"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="Single_stratum_template"/>
         <algorithm>LOCAL
      sst : SET OF Single_stratum_template := [];
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(input);
      IF ('LAYERED_INTERCONNECT_SIMPLE_TEMPLATE_ARM.SINGLE_STRATUM_TEMPLATE' IN TYPEOF(input[i]\Template_location_in_structured_template.template))
      THEN      
        sst := sst + input[i]\Template_location_in_structured_template.template;
      END_IF;
    END_REPEAT;
    RETURN (sst);</algorithm>
      </function>
      <function name="fd_get_transforms">
         <parameter name="input1">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="1"/>
            <typename name="Geometric_model"/>
         </parameter>
         <parameter name="input2">
            <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="2"/>
            <typename name="Geometric_model"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="Geometric_model_relationship_with_transformation"/>
         <algorithm>LOCAL
      gmrwt : SET OF Geometric_model_relationship_with_transformation := [];
    END_LOCAL;
    gmrwt := bag_to_set(USEDIN(input1[1],'GEOMETRIC_MODEL_RELATIONSHIP_ARM.GEOMETRIC_MODEL_RELATIONSHIP.REP_1'));
    REPEAT i := 1 TO HIINDEX(gmrwt);
      IF NOT
        ((gmrwt[i]\Geometric_model_relationship.rep_2 IN input2)
         AND
        ('CONTEXTUAL_SHAPE_POSITIONING_ARM.GEOMETRIC_MODEL_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(gmrwt[i])))
      THEN
       RETURN(?);
      END_IF;
    END_REPEAT;
    RETURN(gmrwt);</algorithm>
      </function>
      <function name="get_template_arrangement">
         <parameter name="input">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="Template_location_in_structured_template"/>
         </parameter>
         <typename name="template_arrangement"/>
         <algorithm>LOCAL
      tlist          : SET OF Template_location_in_structured_template := 
        (QUERY(inx &lt;* input | ('LAYERED_INTERCONNECT_COMPLEX_TEMPLATE_ARM.MULTI_STRATUM_STRUCTURED_TEMPLATE' IN TYPEOF(inx.template))));
      pabt           : BAG OF STRING := [];
      pabb           : BAG OF STRING := [];
      pabsymmetrical : BAG OF STRING := [];
      pabswappable   : BAG OF STRING := [];
    END_LOCAL;

    REPEAT i := 1 TO SIZEOF(tlist) BY 1;
      IF (tlist[i].template\Multi_stratum_structured_template.location = template_arrangement.top) THEN
        pabt := pabt + 'top';
      END_IF;
      IF (tlist[i].template\Multi_stratum_structured_template.location = template_arrangement.bottom) THEN
        pabb := pabb + 'bottom';
      END_IF;
      IF (tlist[i].template\Multi_stratum_structured_template.location = template_arrangement.symmetrical) THEN
        pabsymmetrical := pabsymmetrical + 'symmetrical';
      END_IF;
      IF (tlist[i].template\Multi_stratum_structured_template.location = template_arrangement.swappable) THEN
        pabswappable := pabswappable + 'swappable';
      END_IF;
    END_REPEAT;
    IF ((SIZEOF(pabt) &gt; 0) AND (SIZEOF(pabb) = 0)) THEN
      RETURN(template_arrangement.top);
    END_IF;
    IF ((SIZEOF(pabb) &gt; 0) AND (SIZEOF(pabt) = 0)) THEN
      RETURN(template_arrangement.bottom);
    END_IF;
    IF ((SIZEOF(pabb) = 0) AND (SIZEOF(pabt) = 0) AND (SIZEOF(pabsymmetrical) &gt; 0)) THEN
      RETURN(template_arrangement.symmetrical);
    END_IF;
    IF ((SIZEOF(pabb) = 0) AND (SIZEOF(pabt) = 0) AND (SIZEOF(pabsymmetrical) = 0) AND (SIZEOF(pabswappable) &gt; 0)) THEN
      RETURN(template_arrangement.swappable);
    END_IF;
    RETURN(?);</algorithm>
      </function>
   </schema>
</express>
