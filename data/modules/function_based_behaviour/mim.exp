(*
 $Id: mim.exp,v 1.2 2006/04/18 14:24:50 philsp Exp $ ISO TC184/SC4/WG12
 N - ISO/WD 10303-1453 Function based behaviour - EXPRESS MIM*)
(*            UNDER DEVELOPMENT by H.P. Frisch
		This file starts with the mim.exp for this module.
		All referenced mim.exp's and IR schemas needed to generate a 
		long form and for .xml production are appended.  
	      NOTE:  Many duplications exist, they need to be auto-removed.  
	      	Auto-condensation of extensible type lists also need to be done.  
		When done checkability and traceability of mim.exp information 
		detail will be destroyed. 
		This module was hand generated via cut, paste, search and replace.
		To eliminate human error it needs to be auto-generated from the arm.exp.
	      Note: There is no mim.exp explicitly defined for extensible types:
			activity_realization_select
			characterized_activity_definition,
			characterized_resource_select
*)
SCHEMA Function_based_behaviour_mim;

USE FROM Behaviour_description_assignment_mim;

USE FROM Expression_assignment_mim;

USE FROM External_functional_model_mim;

USE FROM General_model_parameter_mim;

USE FROM Required_resource_mim;

USE FROM Resource_property_assignment_mim;

USE FROM Textual_expression_representation_mim;

USE FROM Condition_mim  
  (condition); 
  
USE FROM External_item_identification_assignment_mim  
  (applied_external_identification_assignment); 

USE FROM File_identification_mim  
  (document_file); 
  
USE FROM Task_element_mim  
  (task_element,
  task_element_relationship,
  task_step); 
  
TYPE fbb_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (action_method,
   product_definition_formation_relationship,
   action_resource_requirement,
   action_method,
   action_resource,
   resource_property);
END_TYPE;

TYPE fbb_pmri_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(document_file);
END_TYPE;

TYPE fbb_ss_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(property_definition);
END_TYPE;

TYPE fbb_ap233_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(group,
	condition,
	applied_action_method_assignment
	--Task_io_hierarchy
	);
END_TYPE;

TYPE fbb_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (action_method,
   action_method_relationship,
   applied_action_method_assignment,
   class,
   context_dependent_unit,
   document_file,
   applied_identification_assignment,
   general_property,
   general_property_relationship,
   product,
   product_category,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition,
   representation,
   representation_context,
   representation_item,
   action_resource_requirement,
   action_method,
   action_resource_requirement_relationship,
   action_resource,
   action_method,
   action_resource_relationship,
   resource_property,
   resource_property_representation,
   uncertainty_measure_with_unit,
   named_unit, derived_unit,
   measure_with_unit,
   product_definition_context);
END_TYPE;

TYPE fbb_pmri_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
	(conversion_based_unit,
	derived_unit,
	external_class_library,
	applied_external_identification_assignment,
	applied_external_identification_assignment,
	product_definition_formation_relationship);
END_TYPE;

TYPE fbb_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH
  (action_method_relationship,
   applied_action_method_assignment,
   action_resource_requirement,
   action_method,
   action_resource_requirement_relationship,
   action_resource,
   action_method,
   action_resource_relationship,
   resource_property,
   task_element_relationship);
END_TYPE;

TYPE fbb_ss_condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON condition_action_method_items WITH
	(property_definition,
	resource_property);
END_TYPE;

TYPE fbb2_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (parameter_value_select);
END_TYPE;

TYPE fbb3_pmri_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(applied_classification_assignment,
	applied_identification_assignment,
	property_definition_representation,
	product,
	product_related_product_category,
	product_definition_formation,
	product_definition,
	representation);
END_TYPE;

TYPE fbb3_ss_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(action_method,
	property_definition,
	property_definition_representation,
	action_resource_requirement,
	resource_property,
	resource_property_representation);
END_TYPE;

TYPE fbb_assignment_target_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON assignment_target_select WITH
  (condition);
END_TYPE;

TYPE fbb_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
  (applied_action_method_assignment,
   condition,
   general_property,
   product,
   product_definition_formation,
   product_definition,
   action_resource_requirement,
   action_resource,
   task_step);
END_TYPE;

TYPE fbb_pmri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
	(document_file,
	external_class_library,
	applied_external_identification_assignment,
	document_file,
	general_property,
	general_property_relationship,
	product_category,
	representation);
END_TYPE;

TYPE fbb_ss_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
	(action_method,
	action_method_relationship,
	action_resource_requirement_relationship,
	resource_property,
	task_element,
	task_element_relationship);
END_TYPE;

TYPE fbb_ap233_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
	(applied_action_method_assignment);
END_TYPE;

TYPE fbb5_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (task_step);
END_TYPE;

TYPE fbb4_ss_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(action_method,
	task_element);
END_TYPE;

TYPE fbb2_ap233_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(product,
	product_definition_formation,
	product_definition);
END_TYPE;

TYPE fbb7_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (product,
   product_definition_formation,
   product_definition);
END_TYPE;

TYPE fbb4_ap233_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(action_method);
END_TYPE;

TYPE fbb3_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (product,
   product_definition_formation,
   product_definition);
END_TYPE;

TYPE fbb2_pmri_action_method_items= EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
	(document_file);
END_TYPE;

TYPE fbb4_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH
  (product,
   product_definition_formation,
   product_definition);
END_TYPE;

(*TYPE functional_groupable_item = SELECT BASED_ON groupable_item WITH
  (--Function_based_behaviour_model
  );
END_TYPE;*)

END_SCHEMA;


(*
   $Id: mim.exp,v 1.3 2007/01/14 18:44:55 abhpf Exp $
  ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-1483 Behaviour description assignment - EXPRESS MIM
*) 


SCHEMA Behaviour_description_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Behaviour_view_definition_mim;    -- ISO/CD-TS 10303-1481

USE FROM Group_mim;    -- ISO/TS 10303-1113


TYPE behaviour_item_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (behaviour_definition);
END_TYPE; 

TYPE behaviour_model_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item;
END_TYPE; 

END_SCHEMA;  -- Behaviour_description_assignment_mim


(*
   $Id: mim.exp,v 1.3 2007/01/14 18:47:20 abhpf Exp $
  ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-1481 Behaviour view definition - EXPRESS MIM
*) 


SCHEMA Behaviour_view_definition_mim;

USE FROM Behaviour_identification_and_version_mim;    -- ISO/CD-TS 10303-1482

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE behaviour_definition_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (behaviour_definition);
END_TYPE; 

ENTITY behaviour_definition
  SUBTYPE OF (product_definition);
  SELF\product_definition.formation : behaviour_definition_formation;
END_ENTITY;

END_SCHEMA;  -- Behaviour_view_definition_mim



(*
 $Id: mim.exp,v 1.8 2006/03/24 18:45:20 thendrix Exp $
 ISO TC184/SC4/WG12 N4276 - ISO/TS 10303-1113 Group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3246
*) 


SCHEMA Group_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Basic_attribute_schema(
	id_attribute, 
	id_attribute_select); -- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;

END_SCHEMA;  -- Group_mim


(*
 $Id: mim.exp,v 1.18 2005/07/04 15:18:43 rocc Exp $
 ISO TC184/SC4/WG12 N2556 - ISO/TS 10303-1342 Expression - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1797
*)

SCHEMA Expression_mim;

USE FROM Generic_expression_mim;

USE FROM ISO13584_expressions_schema(
	and_expression,
	binary_boolean_expression,
	binary_function_call,
	binary_numeric_expression,
	boolean_defined_function,
	boolean_expression,
	boolean_literal,
	boolean_variable,
	comparison_equal,
	comparison_expression,
	comparison_greater,
	comparison_greater_equal,
	comparison_less,
	comparison_less_equal,
	comparison_not_equal,
	concat_expression,
	defined_function,
	div_expression,
	equals_expression,
	expression,
	format_function,
	index_expression,
	int_literal,
	int_numeric_variable,
	interval_expression,
	like_expression,
	literal_number,
	minus_expression,
	mod_expression,
	mult_expression,
	multiple_arity_boolean_expression,
	multiple_arity_function_call,
	multiple_arity_numeric_expression,
	not_expression,
	numeric_expression,
	numeric_variable,
	or_expression,
	plus_expression,
	power_expression,
	real_literal,
	real_numeric_variable,
	simple_boolean_expression,
	simple_numeric_expression,
	simple_string_expression,
	slash_expression,
	SQL_mappable_defined_function,
	string_defined_function,
	string_expression,
	string_literal,
	string_variable,
	substring_expression,
	unary_boolean_expression,
	unary_numeric_expression,
	xor_expression
	);
	
END_SCHEMA;

(*
   $Id: mim.exp,v 1.2 2006/05/25 16:22:15 mikeward Exp $
  ISO TC184/SC4/WG12 N - ISO/WD 10303-1491 Expression assignment - EXPRESS MIM
*) 


SCHEMA Expression_assignment_mim;

USE FROM Expression_mim;    -- ISO/TS 10303-1342

USE FROM expression_extensions_schema   -- ISO 10303-57
  (assignment_target_select,
   expression_assignment); 


END_SCHEMA;  -- Expression_assignment_mim


(*
   $Id: mim.exp,v 1.2 2007/01/14 19:37:09 abhpf Exp $
 ISO TC184/SC4/WG12 N - ISO/WD 10303-1478 External_functional_model - EXPRESS MIM
 *)
(* UNDER DEVELOPMENT *)
SCHEMA External_functional_model_mim;
END_SCHEMA;


(*
   $Id: mim.exp,v 1.2 2006/05/25 16:06:38 mikeward Exp $
   ISO TC184/SC4/WG12 N - ISO/WD 10303-1472 General model parameter - EXPRESS MIM
*) 


SCHEMA General_model_parameter_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Group_mim;    -- ISO/TS 10303-1113

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM Independent_property_representation_mim;    -- ISO/TS 10303-1038

USE FROM Parameter_value_specification_mim   -- ISO/WD 10303-1470
  (parameter_value_select); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property,
   general_property_relationship); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM representation_schema   -- ISO 10303-43
  (representation_item); 


TYPE cgpr_required_class_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (constrained_general_parameter_relationship);
END_TYPE; 

TYPE gmp_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (constrained_general_parameter_relationship, 
    general_model_parameter, 
    parameter_value_representation_item);
END_TYPE; 

TYPE parameter_value_representation_item_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (parameter_value_representation_item);
END_TYPE; 

TYPE parameter_value_select_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (parameter_value_select);
END_TYPE; 

ENTITY constrained_general_parameter_relationship
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.related_property : general_model_parameter;
  SELF\general_property_relationship.relating_property : general_model_parameter;
END_ENTITY;

ENTITY general_model_parameter
  SUBTYPE OF (general_property);
END_ENTITY;

ENTITY parameter_value_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;

END_SCHEMA;  -- General_model_parameter_mim

(*
 $Id: mim.exp,v 1.13 2004/11/19 21:37:39 robbod Exp $
 ISO TC184/SC4/WG12 N3119 - ISO/TS 10303-1267 Required resource - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2415
*) 


SCHEMA Required_resource_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_resource_requirement,
   action_resource_requirement_relationship,
   characterized_action_definition,
   characterized_resource_definition,
   requirement_for_action_resource,
   resource_property,
   resource_requirement_type); 

USE FROM Resource_item_mim;    -- ISO/TS 10303-1268

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE required_resource_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_resource_requirement, 
    action_resource_requirement_relationship);
END_TYPE; 

END_SCHEMA;  -- Required_resource_mim


(*
 $Id: mim.exp,v 1.3 2004/11/19 21:37:41 robbod Exp $
 ISO TC184/SC4/WG12 N3158 - ISO/TS 10303-1273 Resource property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2439
*) 


SCHEMA Resource_property_assignment_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM process_property_representation_schema   -- ISO 10303-49
  (resource_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (characterized_resource_definition,
   resource_property); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (derived_property_select,
   general_property_association); 


END_SCHEMA;  -- Resource_property_assignment_mim


(*
$Id: mim.exp,v 1.6 2006/05/25 16:10:26 mikeward Exp $
ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-1367 Textual expression representation - EXPRESS MIM
*) 


SCHEMA Textual_expression_representation_mim;

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (compound_representation_item,
   representation,
   representation_context,
   representation_item,
   representation_map); 


TYPE ter_classification_item = SELECT BASED_ON classification_item WITH 
   (representation_context, 
    text_based_representation);
END_TYPE; 

TYPE text_based_item_select = EXTENSIBLE GENERIC_ENTITY SELECT
   (included_text_based_representation, 
    textual_expression_composition, 
    textual_expression_representation_item);
END_TYPE; 

ENTITY included_text_based_representation
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY text_based_representation
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : text_based_representation_context;
  SELF\representation.items : text_based_item_select;
END_ENTITY;

ENTITY text_based_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY textual_expression_composition
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

ENTITY textual_expression_representation_item
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

END_SCHEMA;  -- Textual_expression_representation_mim

(* 
 $Id: mim.exp,v 1.11 2004/11/30 17:13:38 robbod Exp $
 ISO TC184/SC4/WG12 N3249 - ISO/TS 10303-1114 Classification assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2230 
*)

SCHEMA Classification_assignment_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;

END_SCHEMA;  -- Classification_assignment_mim

(*
 $Id: mim.exp,v 1.9 2004/11/19 21:37:34 robbod Exp $
 ISO TC184/SC4/WG12 N3023 - ISO/TS 10303-1070 Class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2259
*) 


SCHEMA Class_mim;

USE FROM classification_schema   -- ISO 10303-54
  (class,
   class_by_extension,
   class_by_intension); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


END_SCHEMA;  -- Class_mim


(* 
$Id: mim.exp,v 1.17 2006/03/24 18:31:03 thendrix Exp $ 
ISO TC184/SC4/WG12 N4349 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3223
*) 


SCHEMA Foundation_representation_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select); 

USE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   uncertainty_measure_with_unit); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Foundation_representation_mim

(*
 $Id: mim.exp,v 1.13 2004/10/22 15:28:54 darla Exp $
 ISO TC184/SC4/WG12 N1302 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
*)

SCHEMA Value_with_unit_mim;

USE FROM measure_schema;

USE FROM representation_schema
 (uncertainty_measure_with_unit);

END_SCHEMA;


(*
$Id: action_schema.exp,v 1.11 2004/11/25 16:29:38 thendrix Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA action_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   id_attribute,
   name_attribute); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE supported_item = SELECT
   (action, 
    action_directive, 
    action_method);
END_TYPE; 

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET[1:?] OF versioned_action_request;
END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_method_relationship;
  name : label;
  description : OPTIONAL text;
  relating_method : action_method;
  related_method : action_method;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_resource;
  name : label;
  description : OPTIONAL text;
  usage : SET[1:?] OF supported_item;
  kind : action_resource_type;
END_ENTITY;

ENTITY action_resource_relationship;
  name : label;
  description : OPTIONAL text;
  relating_resource : action_resource;
  related_resource : action_resource;
END_ENTITY;

ENTITY action_resource_type;
  name : label;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY versioned_action_request_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_versioned_action_request : versioned_action_request;
  related_versioned_action_request : versioned_action_request;
END_ENTITY;

FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

END_SCHEMA;  -- action_schema

(*
 $Id: mim.exp,v 1.5 2004/11/19 21:37:33 robbod Exp $
 ISO TC184/SC4/WG12 N2999 - ISO/TS 10303-1249 Activity method assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2307
*) 


SCHEMA Activity_method_assignment_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method_relationship); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment); 


TYPE action_method_items = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET[1:?] OF action_method_items;
END_ENTITY;

END_SCHEMA;  -- Activity_method_assignment_mim

(*
 $Id: mim.exp,v 1.13 2004/10/21 14:45:33 darla Exp $
 ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
*)

SCHEMA Activity_method_mim;

USE FROM action_schema    -- ISO 10303-41
(action_method );

END_SCHEMA;

(*
$Id: basic_attribute_schema.exp,v 1.8 2004/11/10 12:39:43 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA basic_attribute_schema; 

REFERENCE FROM action_schema   -- ISO 10303-41
  (action,
   action_request_solution); 

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (application_context); 

REFERENCE FROM approval_schema   -- ISO 10303-41
  (approval_date_time,
   approval_role); 

REFERENCE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_design); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_role,
   date_time_role,
   time_role); 

REFERENCE FROM effectivity_schema   -- ISO 10303-41
  (effectivity); 

REFERENCE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (derived_unit); 

REFERENCE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization_role,
   organizational_project,
   person_and_organization,
   person_and_organization_role,
   person_role); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_definition,
   product_definition_substitute); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (context_dependent_shape_representation,
   property_definition_representation); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


TYPE description_attribute_select = SELECT
   (action_request_solution, 
    application_context, 
    approval_role, 
    configuration_design, 
    context_dependent_shape_representation, 
    date_role, 
    date_time_role, 
    effectivity, 
    external_source, 
    organization_role, 
    person_and_organization, 
    person_and_organization_role, 
    person_role, 
    property_definition_representation, 
    representation, 
    time_role);
END_TYPE; 

TYPE id_attribute_select = SELECT
   (action, 
    address, 
    application_context, 
    group, 
    organizational_project, 
    product_category, 
    property_definition, 
    representation, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

TYPE name_attribute_select = SELECT
   (action_request_solution, 
    address, 
    configuration_design, 
    context_dependent_shape_representation, 
    derived_unit, 
    effectivity, 
    person_and_organization, 
    product_definition, 
    product_definition_substitute, 
    property_definition_representation);
END_TYPE; 

TYPE role_select = SELECT
   (action_assignment, 
    action_request_assignment, 
    approval_assignment, 
    approval_date_time, 
    certification_assignment, 
    contract_assignment, 
    document_reference, 
    effectivity_assignment, 
    external_referent_assignment, 
    group_assignment, 
    name_assignment, 
    security_classification_assignment);
END_TYPE; 

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;
END_FUNCTION; 

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

END_SCHEMA;  -- basic_attribute_schema


(*
   $Id: mim.exp,v 1.3 2007/01/14 18:46:21 abhpf Exp $
   ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-1482 Behaviour identification and version - EXPRESS MIM
*) 


SCHEMA Behaviour_identification_and_version_mim;

USE FROM Alias_identification_mim;    -- ISO/TS 10303-1025

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition_formation,
   product_definition_formation_relationship); 

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020


TYPE behaviour_and_version_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (behaviour, 
    behaviour_definition_formation);
END_TYPE; 

ENTITY behaviour
  SUBTYPE OF (product);
END_ENTITY;

ENTITY behaviour_definition_formation
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.of_product : behaviour;
END_ENTITY;

ENTITY behaviour_definition_formation_sequence
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.related_product_definition_formation : behaviour_definition_formation;
  SELF\product_definition_formation_relationship.relating_product_definition_formation : behaviour_definition_formation;
END_ENTITY;

END_SCHEMA;  -- Behaviour_identification_and_version_mim

(* 
$Id: classification_schema.exp,v 1.10 2005/01/05 00:07:15 thendrix Exp $
ISO TC184/SC4/WG12 N3213 - ISO/IS 10303-54 Classification and set theory - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1510
*) 


SCHEMA classification_schema;

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE complete_membership_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET[1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF (classification,
         complete_membership);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- classification_schema


(*
$Id: expression_extensions_schema.exp,v 1.11 2003/02/26 17:56:03 shiangyulee Exp $
  WG12N1826 - ISO 10303-57 expression_extensions_schema
*)

SCHEMA expression_extensions_schema; 

REFERENCE FROM iso13584_expressions_schema   -- ISO 13584-20
  (defined_function,
   expression); 

REFERENCE FROM iso13584_generic_expressions_schema   -- ISO 13584-20
  (generic_literal,
   generic_variable); 

REFERENCE FROM iso13584_iec61360_dictionary_schema   -- ISO 13584-42
  (entity_instance_type); 


TYPE assignment_target_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE entity_instance_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY entity_expression
  SUBTYPE OF (entity_instance_type, expression);
  SELF\entity_instance_type.type_name RENAMED entity_name : SET[1:1] OF STRING;
END_ENTITY;

ENTITY entity_instance
  SUBTYPE OF (generic_literal);
  entity_definition : entity_expression;
  the_instance : entity_instance_select;
END_ENTITY;

ENTITY expression_assignment;
  assigned_expression : expression;
  assigned_to_object : assignment_target_select;
  role : STRING;
END_ENTITY;

ENTITY expression_relationship;
  description : OPTIONAL STRING;
  name : OPTIONAL STRING;
  related : expression;
  relating : expression;
  role : STRING;
END_ENTITY;

ENTITY literal_assignment;
  base : expression;
  literal_value : generic_literal;
  value_context : OPTIONAL entity_instance;
END_ENTITY;

ENTITY named_function
  SUBTYPE OF (defined_function);
  name : STRING;
END_ENTITY;

ENTITY named_variable
  SUBTYPE OF (generic_variable);
  name : STRING;
END_ENTITY;

ENTITY variable_assignment;
  the_function : defined_function;
  the_variable : generic_variable;
END_ENTITY;

ENTITY variable_entity_type
  SUBTYPE OF (entity_expression, generic_variable);
END_ENTITY;

END_SCHEMA;  -- expression_extensions_schema


(*
 $Id: mim.exp,v 1.14 2004/11/19 21:37:35 robbod Exp $
 ISO TC184/SC4/WG12 N3050 - ISO/TS 10303-1275 External class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2265
*) 


SCHEMA External_class_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select); 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
   (external_class_library);
END_TYPE; 

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

END_SCHEMA;  -- External_class_mim


(* 
 $Id: mim.exp,v 1.20 2005/05/02 11:30:44 rocc Exp $
 ISO TC184/SC4/WG12 N2553 - ISO/TS 10303-1341 Generic expression - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1794
*)

SCHEMA Generic_expression_mim;

USE FROM ISO13584_generic_expressions_schema(
	binary_generic_expression,
	environment,
	generic_expression,
	generic_literal,
	generic_variable,
	multiple_arity_generic_expression,
	simple_generic_expression,
	unary_generic_expression,
	variable_semantics
	);
	
USE FROM ISO13584_expressions_schema(
	variable);

END_SCHEMA;


(*
$Id: group_schema.exp,v 1.5 2004/11/12 18:17:25 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA group_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   id_attribute); 


ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY group_relationship;
  name : label;
  description : OPTIONAL text;
  relating_group : group;
  related_group : group;
END_ENTITY;

FUNCTION acyclic_group_relationship
 (relation : group_relationship; relatives : SET[1:?] OF group; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- group_schema


(*
 $Id: mim.exp,v 1.11 2004/10/28 16:58:42 darla Exp $
 ISO TC184/SC4/WG12 N2915 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
*)

SCHEMA Identification_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment,
   identification_role); 


TYPE identification_item = EXTENSIBLE SELECT;
END_TYPE; 

TYPE versionable_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

END_SCHEMA;  -- Identification_assignment_mim


(*
 $Id: mim.exp,v 1.10 2004/10/22 14:15:40 darla Exp $
 ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
*)
SCHEMA Independent_property_mim;

USE FROM product_property_definition_schema
(general_property,
 general_property_relationship);

END_SCHEMA;


(*
 $Id: mim.exp,v 1.11 2006/05/18 11:42:07 liutkuviene Exp $
 ISO TC184/SC4/WG12 N4372 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1244
*)
SCHEMA Independent_property_representation_mim;

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

END_SCHEMA;



(* Genenerated from: ISO.exp *)

SCHEMA ISO13584_expressions_schema;

REFERENCE FROM ISO13584_generic_expressions_schema(
			generic_expression,
			simple_generic_expression,
			generic_variable,
			generic_literal,
			unary_generic_expression,
			binary_generic_expression,
			multiple_arity_generic_expression);

ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,
				boolean_expression,
				string_expression))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable,
				boolean_variable,
					string_variable))
SUBTYPE OF(generic_variable);
END_ENTITY;

ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function,
				string_defined_function,
				boolean_defined_function)
				)
				ANDOR SQL_mappable_defined_function);
END_ENTITY;

ENTITY SQL_mappable_defined_function
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
								unary_numeric_expression,
								binary_numeric_expression,
								multiple_arity_numeric_expression,
								length_function,
								value_function,
								numeric_defined_function))
SUBTYPE OF (expression);
DERIVE
	is_int: BOOLEAN := is_int_expr (SELF);
	sql_mappable: BOOLEAN := is_SQL_mappable (SELF);
END_ENTITY;

ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;

ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;

ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;

ENTITY numeric_variable
SUPERTYPE OF (ONEOF (int_numeric_variable,
			          real_numeric_variable))
SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;

ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (unary_function_call))
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;

ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,
				div_expression,
				mod_expression,
				slash_expression,
				power_expression,
				binary_function_call))
SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,
				mult_expression,
				multiple_arity_function_call))
SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;

ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY value_function
SUPERTYPE OF (int_value_function)
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;

ENTITY numeric_defined_function
ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function,
				real_defined_function))
SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (abs_function,
				minus_function,
				sin_function,
				cos_function,
				tan_function,
				asin_function,
				acos_function,
				exp_function,
				log_function,
				log2_function,
				log10_function,
				square_root_function))
SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (atan_function))
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, 
				minimum_function))
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY integer_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY real_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression,
				unary_boolean_expression,
				binary_boolean_expression,
				multiple_arity_Boolean_expression,
				comparison_expression,
				interval_expression,
				boolean_defined_function))
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal,
				boolean_variable))
SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;

ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;

ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(SELF\numeric_expression);
END_ENTITY;

ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;

ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal,
				comparison_greater,
				comparison_greater_equal,
				comparison_less,
				comparison_less_equal,
				comparison_not_equal,
				like_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;

ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 

ENTITY boolean_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;

ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression,
				index_expression,
				substring_expression,
				concat_expression,
				format_function,
				string_defined_function)) 
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (string_literal,
				string_variable))
SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;

ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;

ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;

ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;

ENTITY string_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;

FUNCTION is_int_expr (arg: numeric_expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

FUNCTION is_SQL_mappable (arg: expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions (arg : expression) : SET OF defined_function;

LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\like_expression.operands[1])
		+ used_functions (arg\like_expression.operands[2]));
END_IF;
RETURN ([ ]);

END_FUNCTION; -- used_functions

END_SCHEMA;


(*
  $Id: management_resources_schema.exp,v 1.22 2004/11/10 13:38:35 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA management_resources_schema;

REFERENCE FROM action_schema;    -- ISO 10303-41

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (library_context); 

REFERENCE FROM approval_schema;    -- ISO 10303-41

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_role,
   object_role,
   role_association); 

REFERENCE FROM certification_schema;    -- ISO 10303-41

REFERENCE FROM contract_schema;    -- ISO 10303-41

REFERENCE FROM date_time_schema;    -- ISO 10303-41

REFERENCE FROM document_schema;    -- ISO 10303-41

REFERENCE FROM effectivity_schema;    -- ISO 10303-41

REFERENCE FROM experience_schema;    -- ISO 10303-41

REFERENCE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

REFERENCE FROM group_schema;    -- ISO 10303-41

REFERENCE FROM location_schema;    -- ISO 10303-41

REFERENCE FROM person_organization_schema;    -- ISO 10303-41

REFERENCE FROM qualifications_schema;    -- ISO 10303-41

REFERENCE FROM security_classification_schema;    -- ISO 10303-41

REFERENCE FROM support_resource_schema;    -- ISO 10303-41


TYPE attribute_type = SELECT
   (label, 
    text);
END_TYPE; 

ENTITY action_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_method : action_method;
  role : action_method_role;
END_ENTITY;

ENTITY action_method_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE ;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY certification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  role : classification_role;
END_ENTITY;

ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE ;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date : date;
  role : date_role;
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE ;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE ;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity_assignment : effectivity_assignment;
  role : effectivity_context_role;
END_ENTITY;

ENTITY effectivity_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role : event_occurrence_context_role;
END_ENTITY;

ENTITY experience_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience : experience;
  role : experience_role;
END_ENTITY;

ENTITY experience_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience_type : experience_type;
  role : experience_type_role;
END_ENTITY;

ENTITY experience_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

ENTITY group_assignment
  ABSTRACT SUPERTYPE ;
  assigned_group : group;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_assignment_relationship;
  name : label;
  description : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment : identification_assignment;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY library_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY;

ENTITY location_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_location : location;
  role : location_role;
END_ENTITY;

ENTITY location_representation_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  represented_location : location;
  role : location_representation_role;
END_ENTITY;

ENTITY location_representation_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY name_assignment
  ABSTRACT SUPERTYPE ;
  assigned_name : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_organization_type : organization_type;
  role : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;

ENTITY person_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person : person;
  role : person_role;
END_ENTITY;

ENTITY person_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type : person_type;
  role : person_type_role;
END_ENTITY;

ENTITY person_type_definition_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type_definition : person_type_definition;
  role : person_type_definition_role;
END_ENTITY;

ENTITY person_type_definition_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization : position_in_organization;
  role : position_in_organization_role;
END_ENTITY;

ENTITY position_in_organization_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization_type : position_in_organization_type;
  role : position_in_organization_type_role;
END_ENTITY;

ENTITY position_in_organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification : qualification;
  role : qualification_role;
END_ENTITY;

ENTITY qualification_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification_type : qualification_type;
  role : qualification_type_role;
END_ENTITY;

ENTITY qualification_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time : local_time;
  role : time_role;
END_ENTITY;

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;

FUNCTION acyclic_identification_assignment_relationship
 (relation : identification_assignment_relationship; relatives : SET[1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);

END_FUNCTION; 

END_SCHEMA;  -- management_resources_schema



(*
$Id: measure_schema.exp,v 1.7 2004/11/10 13:18:30 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA measure_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_name_value,
   name_attribute); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context); 

REFERENCE FROM support_resource_schema;    -- ISO 10303-41


TYPE amount_of_substance_measure = REAL;
END_TYPE; 

TYPE area_measure = REAL;
END_TYPE; 

TYPE celsius_temperature_measure = REAL;
END_TYPE; 

TYPE context_dependent_measure = REAL;
END_TYPE; 

TYPE count_measure = NUMBER;
END_TYPE; 

TYPE descriptive_measure = STRING;
END_TYPE; 

TYPE electric_current_measure = REAL;
END_TYPE; 

TYPE length_measure = REAL;
END_TYPE; 

TYPE luminous_intensity_measure = REAL;
END_TYPE; 

TYPE mass_measure = REAL;
END_TYPE; 

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE; 

TYPE numeric_measure = NUMBER;
END_TYPE; 

TYPE parameter_value = REAL;
END_TYPE; 

TYPE plane_angle_measure = REAL;
END_TYPE; 

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE ratio_measure = REAL;
END_TYPE; 

TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE; 

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE; 

TYPE solid_angle_measure = REAL;
END_TYPE; 

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; 

TYPE time_measure = REAL;
END_TYPE; 

TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE; 

TYPE volume_measure = REAL;
END_TYPE; 

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit,
                       mass_measure_with_unit,
                       time_measure_with_unit,
                       electric_current_measure_with_unit,
                       thermodynamic_temperature_measure_with_unit,
                       celsius_temperature_measure_with_unit,
                       amount_of_substance_measure_with_unit,
                       luminous_intensity_measure_with_unit,
                       plane_angle_measure_with_unit,
                       solid_angle_measure_with_unit,
                       area_measure_with_unit,
                       volume_measure_with_unit,
                       ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit,
                       conversion_based_unit,
                       context_dependent_unit)
               ANDOR ONEOF (length_unit,
                    mass_unit,
                    time_unit,
                    electric_current_unit,
                    thermodynamic_temperature_unit,
                    amount_of_substance_unit,
                    luminous_intensity_unit,
                    plane_angle_unit,
                    solid_angle_unit,
                    area_unit,
                    volume_unit,
                    ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; 

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; 

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- measure_schema



(*
$Id: mim.exp,v 1.2 2006/05/25 17:21:08 mikeward Exp $
ISO TC184/SC4/WG12 N - ISO/WD 10303-1470 Parameter value specification - EXPRESS MIM
*) 


SCHEMA Parameter_value_specification_mim;

USE FROM Group_mim   -- ISO/TS 10303-1113
  (applied_group_assignment,
   groupable_item); 

USE FROM ISO13584_generic_expressions_schema   -- ISO 13584-20
  (generic_expression,
   variable_semantics); 

USE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit); 

USE FROM Name_assignment_mim   -- ISO/TS 10303-1340
  (applied_name_assignment,
   name_item); 


TYPE generic_expression_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (generic_expression);
END_TYPE; 

TYPE named_variable_semantics_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (named_variable_semantics);
END_TYPE; 

TYPE named_variable_semantics_variable_context_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (named_variable_semantics);
END_TYPE; 

TYPE parameter_value_select = EXTENSIBLE GENERIC_ENTITY SELECT
   (generic_expression, 
    measure_with_unit);
END_TYPE; 

ENTITY named_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

END_SCHEMA;  -- Parameter_value_specification_mim


(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_representation_schema;

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM process_property_schema
    (action_property, 
     resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

END_SCHEMA; -- process_property_representation_schema


(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_schema;

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema


(*
$Id: product_definition_schema.exp,v 1.4 2004/11/10 12:11:25 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_definition_schema;

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (product_context,
   product_definition_context); 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM document_schema   -- ISO 10303-41
  (document); 

REFERENCE FROM effectivity_schema   -- ISO 10303-41
  (effectivity); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE source = ENUMERATION OF 
   (made,
    bought,
    not_known);
END_TYPE; 

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;

ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;

ENTITY product_definition_substitute;
  description : OPTIONAL text;
  context_relationship : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY product_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product : product;
  related_product : product;
END_ENTITY;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_formation_relationship
 (relation : product_definition_formation_relationship; relatives : SET[1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_relationship
 (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_relationship
 (relation : product_relationship; relatives : SET[1:?] OF product; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_product_definitions
 (c_def_instance : product) : SET OF product_definition; 
  LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_definition_schema

(*
 $Id: mim.exp,v 1.16 2006/03/24 19:03:52 thendrix Exp $
 ISO TC184/SC4/WG12 N4352 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2928
*) 


SCHEMA Product_view_definition_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (product_definition_context); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (name_attribute,
   name_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_context_association); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_view_definition_mim



(*
 $Id: mim.exp,v 1.14 2006/03/24 19:06:27 thendrix Exp $
 ISO TC184/SC4/WG12 N4375 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2129
*) 


SCHEMA Property_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property_association,
   property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 


END_SCHEMA;  -- Property_assignment_mim

(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA qualified_measure_schema;

REFERENCE FROM support_resource_schema
     (label,
      text);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM representation_schema
     (representation_item);

TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

END_SCHEMA;  -- qualified_measure_schema

(* Genenerated from: ../../irs/wg12n458.exp *)

SCHEMA representation_schema;

REFERENCE FROM basic_attribute_schema
  (get_description_value,
   get_id_value);

REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF (SELF\representation.context_of_items );
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'REPRESENTATION_SCHEMA.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);
END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

END_SCHEMA; -- representation_schema


(*
 $Id: mim.exp,v 1.12 2004/11/19 21:37:40 robbod Exp $
 ISO TC184/SC4/WG12 N3146 - ISO/TS 10303-1268 Resource item - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2427
*) 


SCHEMA Resource_item_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_resource,
   action_resource_relationship,
   action_resource_type,
   supported_item); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role); 

USE FROM process_property_representation_schema   -- ISO 10303-49
  (resource_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (characterized_resource_definition,
   resource_property); 

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item,
   value_representation_item); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE resource_item_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_resource, 
    action_resource_relationship);
END_TYPE; 

END_SCHEMA;  -- Resource_item_mim


(*
  $Id: product_property_definition_schema.exp,v 1.5 2004/11/10 13:29:26 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_property_definition_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   id_attribute); 

REFERENCE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   resource_property); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE characterized_definition = SELECT
   (characterized_object, 
    characterized_product_definition, 
    shape_definition);
END_TYPE; 

TYPE characterized_product_definition = SELECT
   (product_definition, 
    product_definition_relationship);
END_TYPE; 

TYPE derived_property_select = SELECT
   (action_property, 
    property_definition, 
    resource_property);
END_TYPE; 

TYPE shape_definition = SELECT
   (product_definition_shape, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY characterized_object_relationship;
  name : label;
  description : OPTIONAL text;
  relating_object : characterized_object;
  related_object : characterized_object;
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

FUNCTION acyclic_characterized_object_relationship
 (relation : characterized_object_relationship; relatives : SET[1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_general_property_relationship
 (relation : general_property_relationship; relatives : SET[1:?] OF general_property; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_shape_aspect_relationship
 (relation : shape_aspect_relationship; relatives : SET[1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_shape_aspects
 (c_def_instance : characterized_definition) : SET OF shape_aspect; 
  LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_property_definition_schema

(*
  $Id: product_property_representation_schema.exp,v 1.5 2004/11/10 12:16:33 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_property_representation_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM material_property_definition_schema   -- ISO 10303-45
  (property_definition_relationship); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_definition,
   general_property,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   text); 


TYPE represented_definition = SELECT
   (general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY item_identified_representation_usage;
  name : label;
  description : OPTIONAL text;
  definition : represented_definition;
  used_representation : representation;
  identified_item : representation_item;
WHERE
  WR1: SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
  WR2: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;

FUNCTION relatives_of_product_definitions
 (definition_set : SET OF product_definition; relation_subtype : STRING) : SET OF product_definition; 
FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
END_FUNCTION; 

FUNCTION relatives_of_shape_representations
 (shape_representation_set : SET OF shape_representation) : SET OF shape_representation; 
 FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));      
END_FUNCTION; 

FUNCTION get_property_definition_representations
 (c_def_instance : characterized_definition) : SET OF property_definition_representation; 
LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_property_representation_schema

(*
  $Id: support_resource_schema.exp,v 1.7 2004/11/10 13:09:41 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA support_resource_schema;


TYPE identifier = STRING;
END_TYPE; 

TYPE label = STRING;
END_TYPE; 

TYPE text = STRING;
END_TYPE; 

FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
END_FUNCTION; 

FUNCTION type_check_function
 (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION; 

END_SCHEMA;  -- support_resource_schema

(*
$Id: application_context_schema.exp,v 1.5 2004/11/09 18:43:13 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA application_context_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   id_attribute); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (year_number); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (library_context,
                       product_concept_context,
                       product_context,
                       product_definition_context));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;

ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

END_SCHEMA;  -- application_context_schema

(*
$Id: approval_schema.exp,v 1.5 2004/11/09 18:43:45 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA approval_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_role,
   object_role,
   role_association); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_time_select); 

REFERENCE FROM person_organization_schema   -- ISO 10303-41
  (person_organization_select); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   text); 


ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;

ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

FUNCTION acyclic_approval_relationship
 (relation : approval_relationship; relatives : SET[1:?] OF approval; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- approval_schema


(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA configuration_management_schema;

  REFERENCE FROM product_definition_schema
    (product_definition,
     product_definition_formation,
     product_definition_effectivity);

  REFERENCE FROM product_structure_schema
    (product_definition_usage);

  REFERENCE FROM product_concept_schema
    (product_concept,
     product_concept_feature_association);

  REFERENCE FROM basic_attribute_schema
    (get_description_value,
     get_name_value);

  REFERENCE FROM support_resource_schema
    (text, label, identifier, bag_to_set);

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

END_SCHEMA; -- configuration_management_schema

(*
$Id: date_time_schema.exp,v 1.6 2004/11/10 12:56:51 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA date_time_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (time_measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE; 

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE; 

TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE; 

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; 

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; 

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; 

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; 

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; 

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; 

TYPE year_number = INTEGER;
END_TYPE; 

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION; 

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION; 

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; 

END_SCHEMA;  -- date_time_schema

(*
$Id: effectivity_schema.exp,v 1.4 2004/11/10 11:51:52 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA effectivity_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_time_or_event_occurrence,
   time_interval); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity,
                       dated_effectivity,
                       lot_effectivity,
                       time_interval_based_effectivity));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

FUNCTION acyclic_effectivity_relationship
 (relation : effectivity_relationship; relatives : SET[1:?] OF effectivity; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- effectivity_schema


(*
$Id: external_reference_schema.exp,v 1.4 2004/11/10 11:57:16 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA external_reference_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE message = STRING;
END_TYPE; 

TYPE source_item = SELECT
   (identifier, 
    message);
END_TYPE; 

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY external_source_relationship;
  name : label;
  description : OPTIONAL text;
  relating_source : external_source;
  related_source : external_source;
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;

ENTITY externally_defined_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item : externally_defined_item;
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

FUNCTION acyclic_external_source_relationship
 (relation : external_source_relationship; relatives : SET[1:?] OF external_source; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_externally_defined_item_relationship
 (relation : externally_defined_item_relationship; relatives : SET[1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- external_reference_schema


(*
  $Id: person_organization_schema.exp,v 1.17 2005/04/12 21:19:36 thendrix Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA person_organization_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   get_role,
   id_attribute,
   name_attribute,
   object_role,
   role_association); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE; 

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_organization_type : organization_type;
  related_organization_type : organization_type;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value (SELF);
  description : text := get_description_value(SELF);
  
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_definition;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  formation : person_type_definition_formation;
END_ENTITY;

ENTITY person_type_definition_formation;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  of_person_type : person_type;
END_ENTITY;

ENTITY person_type_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition : person_type_definition;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization : position_in_organization;
END_ENTITY;

ENTITY position_in_organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_organization_type_relationship
 (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_person_type_definition_relationship
 (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_position_in_organization_relationship
 (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- person_organization_schema

(*
 $Id: mim.exp,v 1.12 2006/10/20 03:29:35 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2907 - ISO/TS 10303-1025 Alias identification - EXPRESS MIM
*)
 


SCHEMA Alias_identification_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

TYPE ai_identification_item = SELECT BASED_ON identification_item WITH
 (aliasable_item);
END_TYPE; 

TYPE aliasable_item = EXTENSIBLE SELECT;
END_TYPE; 

END_SCHEMA;  -- Alias_identification_mim

(*
 $Id: mim.exp,v 1.6 2006/03/24 19:02:40 thendrix Exp $
 ISO TC184/SC4/WG12 N4355 - ISO/TS 10303-1020 Product version relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1130
*)
   
SCHEMA Product_version_relationship_mim;

USE FROM Product_version_mim; 	--ISO 10303-1018

USE FROM product_definition_schema 	-- ISO 10303-41
  (product_definition_formation_relationship);
   
END_SCHEMA;


SCHEMA ISO13584_generic_expressions_schema;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_generic_expression,
								unary_generic_expression,
								binary_generic_expression,
								multiple_arity_generic_expression));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
END_ENTITY; 

ENTITY generic_variable
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;

END_FUNCTION; -- acyclic

FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' 
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables

END_SCHEMA; 

SCHEMA ISO13584_IEC61360_dictionary_schema;


REFERENCE FROM support_resource_schema(identifier, label, text); 

 
REFERENCE FROM person_organization_schema(organization, address); 

 
REFERENCE FROM measure_schema;

 
REFERENCE FROM ISO13584_IEC61360_language_resource_schema; 



CONSTANT 
    property_code_len: INTEGER := 14; 
    class_code_len: INTEGER := 14;
    data_type_code_len:INTEGER := 14;
    supplier_code_len: INTEGER := 70;
    version_len: INTEGER := 9; 
    revision_len: INTEGER := 3; 
    value_code_len: INTEGER :=18; 
    pref_name_len: INTEGER := 70;
    short_name_len: INTEGER := 15;
    syn_name_len: INTEGER := pref_name_len;
    DET_classification_len: INTEGER := 3;
    source_doc_len: INTEGER := 80;
    value_format_len: INTEGER := 80;
    sep_cv: STRING := '-';
    sep_id: STRING := '.'; 
END_CONSTANT;


ENTITY basic_semantic_unit
ABSTRACT SUPERTYPE OF(ONEOF(
    supplier_BSU,
    class_BSU,
    property_BSU,
    data_type_BSU,
    supplier_related_BSU,
    class_related_BSU));
    
    code: code_type;
    version: version_type;
DERIVE
    dic_identifier: identifier := code + sep_cv + version;
INVERSE
    definition: SET [0:1] OF dictionary_element FOR 
    identified_by;
    referenced_by: SET [0:1] OF content_item 
        FOR dictionary_definition;
END_ENTITY; -- basic_semantic_unit


ENTITY dictionary_element
ABSTRACT SUPERTYPE OF(ONEOF(
    supplier_element,
    class_and_property_elements,
    data_type_element));

    identified_by: basic_semantic_unit;
    time_stamps: OPTIONAL dates;
    revision: revision_type;
END_ENTITY; -- dictionary_element


ENTITY content_item
ABSTRACT SUPERTYPE;
    dictionary_definition: basic_semantic_unit;
END_ENTITY; -- content_item


ENTITY supplier_related_BSU
ABSTRACT SUPERTYPE
SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- supplier_related_BSU


ENTITY class_related_BSU
ABSTRACT SUPERTYPE
SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- class_related_BSU


ENTITY supplier_BSU_relationship
ABSTRACT SUPERTYPE;
    relating_supplier: supplier_element;
    related_tokens: SET [1:?] OF supplier_related_BSU;
END_ENTITY; -- supplier_BSU_relationship


ENTITY class_BSU_relationship
ABSTRACT SUPERTYPE;
    relating_class: class;
    related_tokens: SET [1:?] OF class_related_BSU;
END_ENTITY; -- class_BSU_relationship


ENTITY supplier_BSU 
SUBTYPE OF(basic_semantic_unit); 
    SELF\basic_semantic_unit.code: supplier_code_type; 
DERIVE 
    SELF\basic_semantic_unit.version: version_type := '1';
    absolute_id: identifier := SELF\basic_semantic_unit.code; 
UNIQUE 
    UR1: absolute_id; 
END_ENTITY; -- supplier_BSU


ENTITY supplier_element
SUBTYPE OF(dictionary_element);
    SELF\dictionary_element.identified_by: supplier_BSU;
    org: organization;
    addr: address;
INVERSE
    associated_items: SET [0:?] OF supplier_BSU_relationship 
        FOR relating_supplier;
END_ENTITY; -- supplier_element


ENTITY class_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: class_code_type;
    defined_by: supplier_BSU;
DERIVE
    absolute_id: identifier 
        := defined_by.absolute_id + sep_id + dic_identifier; 
    known_visible_properties : SET [0:?]OF property_BSU
        :=compute_known_visible_properties(SELF);
    known_visible_data_types: SET [0:?]OF data_type_BSU
        :=compute_known_visible_data_types(SELF);
INVERSE
    subclasses: SET [0:?] OF class FOR its_superclass;
    added_visible_properties:SET [0:?] OF property_BSU 
        FOR name_scope;
    added_visible_data_types:SET [0:?] OF data_type_BSU 
        FOR name_scope;
UNIQUE
    UR1: absolute_id; 
END_ENTITY; -- class_BSU


ENTITY class_and_property_elements
ABSTRACT SUPERTYPE OF(ONEOF(
    property_DET, 
    class))
SUBTYPE OF(dictionary_element);
    names: item_names;
    definition: definition_type;
    source_doc_of_definition: OPTIONAL document;
    note: OPTIONAL note_type;
    remark: OPTIONAL remark_type;
END_ENTITY; -- class_and_property_elements


ENTITY class
ABSTRACT SUPERTYPE OF(item_class)
SUBTYPE OF(class_and_property_elements);
    SELF\dictionary_element.identified_by: class_BSU;
    its_superclass: OPTIONAL class_BSU;
    described_by: LIST [0:?] OF UNIQUE property_BSU;
    defined_types: SET [0:?] OF data_type_BSU;
DERIVE
    subclasses: SET [0:?] OF class := identified_by.subclasses;
    known_applicable_properties: SET [0:?] OF property_BSU
        := compute_known_applicable_properties(
            SELF\dictionary_element.identified_by);
    known_applicable_data_types: SET [0:?] OF data_type_BSU
        := compute_known_applicable_data_types(
            SELF\dictionary_element.identified_by);
INVERSE
    associated_items: SET [0:?] OF class_BSU_relationship 
        FOR relating_class;
WHERE
    WR1: acyclic_superclass_relationship(SELF.identified_by, []);
    WR2: NOT all_class_descriptions_reachable(
        SELF\dictionary_element.identified_by)
        OR (list_to_set(SELF.described_by) <= 
        SELF\dictionary_element.identified_by
        \class_BSU.known_visible_properties);
    WR3: NOT all_class_descriptions_reachable(
        SELF\dictionary_element.identified_by)
        OR (SELF.defined_types <= 
        SELF\dictionary_element.identified_by
        \class_BSU.known_visible_data_types); 
    WR4: check_properties_applicability(SELF);
    WR5: check_datatypes_applicability(SELF);
END_ENTITY; -- class


ENTITY item_class 
SUPERTYPE OF(ONEOF(component_class, material_class))
SUBTYPE OF(class);
    simplified_drawing: OPTIONAL graphics;
    sub_class_properties: SET [0:?] OF property_BSU;
    class_constant_values: SET [0:?] 
        OF class_value_assignment;
    coded_name: OPTIONAL value_code_type;
WHERE
    WR1: QUERY(p <* sub_class_properties
        | NOT(p IN SELF.described_by)) = [];
    WR2: NOT all_class_descriptions_reachable(SELF.identified_by) OR
        (QUERY(va <* class_constant_values | SIZEOF(QUERY(c <*
        va.super_class_defined_property.describes_classes |
        is_subclass(SELF, c) 
        AND (va.super_class_defined_property 
        IN c\item_class.sub_class_properties))) <> 1) = []);
END_ENTITY; -- item_class


ENTITY component_class 
SUBTYPE OF(item_class);
END_ENTITY; -- component_class


ENTITY material_class 
SUBTYPE OF(item_class);
END_ENTITY; -- material_class


ENTITY property_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: property_code_type;
    name_scope: class_BSU;
DERIVE
    absolute_id: identifier :=
        name_scope.defined_by.absolute_id
        + sep_id + name_scope.dic_identifier
        + sep_id + dic_identifier;
INVERSE
    describes_classes: SET OF class FOR described_by;
UNIQUE
    UR1: absolute_id;
WHERE
    WR1: QUERY(c <* describes_classes |
        NOT(is_subclass(c, name_scope.definition[1])))= [];
END_ENTITY; -- property_BSU


ENTITY property_DET
ABSTRACT SUPERTYPE OF(ONEOF(
    condition_DET, dependent_P_DET, non_dependent_P_DET))
SUBTYPE OF(class_and_property_elements);
    SELF\dictionary_element.identified_by: property_BSU;
    preferred_symbol: OPTIONAL mathematical_string;
    synonymous_symbols: SET [0:2] OF mathematical_string;
    figure: OPTIONAL graphics;
    det_classification: OPTIONAL DET_classification_type;
    domain: data_type;
    formula: OPTIONAL mathematical_string;
DERIVE
    describes_classes: SET [0:?] OF class
        := identified_by.describes_classes;
END_ENTITY; -- property_DET


ENTITY condition_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- condition_DET


ENTITY dependent_P_DET
SUBTYPE OF(property_DET);
    depends_on: SET [1:?] OF property_BSU;
WHERE
    WR1: QUERY(p <* depends_on | NOT(definition_available_implies(
        p, ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CONDITION_DET'
        IN TYPEOF(p.definition[1]))))) = [];
END_ENTITY; -- dependent_P_DET


ENTITY non_dependent_P_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- non_dependent_P_DET


ENTITY class_value_assignment;
    super_class_defined_property: property_BSU;
    assigned_value: value_code_type;
WHERE
    WR1: definition_available_implies(super_class_defined_property, 
        ('ISO13584_IEC61360_DICTIONARY_SCHEMA'
        +'.NON_QUANTITATIVE_CODE_TYPE' IN TYPEOF(
        super_class_defined_property.
        definition[1]\property_DET.domain)));
    WR2: definition_available_implies(super_class_defined_property, 
        (SIZEOF(QUERY(v <* 
        super_class_defined_property.
        definition[1]\property_DET.domain
        \non_quantitative_code_type.domain.its_values |
        assigned_value = v.value_code)) = 1));
END_ENTITY; -- class_value_assignment


ENTITY data_type_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: data_type_code_type;
    name_scope: class_BSU;
DERIVE
    absolute_id: identifier := 
        name_scope.defined_by.absolute_id   
        + sep_id + name_scope.dic_identifier    
        + sep_id + dic_identifier;          
INVERSE
    defining_class: SET [0:1] OF class FOR defined_types;
UNIQUE
    absolute_id;
WHERE
    WR1: is_subclass(defining_class[1], name_scope.definition[1]); 
END_ENTITY; -- data_type_BSU


ENTITY data_type_element
SUBTYPE OF(dictionary_element);
    SELF\dictionary_element.identified_by: data_type_BSU;
    names: item_names;
    type_definition: data_type;
END_ENTITY; -- data_type_element


ENTITY data_type
ABSTRACT SUPERTYPE OF(ONEOF(
    simple_type,
    complex_type,
    named_type));
END_ENTITY; -- data_type


ENTITY simple_type
ABSTRACT SUPERTYPE OF(ONEOF(
    number_type,
    boolean_type,
    string_type))
SUBTYPE OF(data_type);
    value_format: value_format_type;
END_ENTITY; -- simple_type


ENTITY number_type
SUPERTYPE OF(ONEOF(
    int_type,
    real_type))
SUBTYPE OF(simple_type); 
END_ENTITY; -- number_type


ENTITY int_type
SUPERTYPE OF(ONEOF(
    int_measure_type,
    int_currency_type,
    non_quantitative_int_type))
SUBTYPE OF(number_type);
END_ENTITY; -- int_type


ENTITY int_measure_type
SUBTYPE OF(int_type);
    unit: dic_unit;
END_ENTITY; -- int_measure_type


ENTITY int_currency_type
SUBTYPE OF(int_type);
    currency: OPTIONAL currency_code; 
END_ENTITY; -- int_currency_type


ENTITY non_quantitative_int_type
SUBTYPE OF(int_type);
    domain: value_domain;
WHERE
    WR1: QUERY(v <* domain.its_values | 
        'ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN
        TYPEOF(v.value_code)) = [];
END_ENTITY; -- non_quantitative_int_type


ENTITY real_type
SUPERTYPE OF(ONEOF(
    real_measure_type,
    real_currency_type))
SUBTYPE OF(number_type);
END_ENTITY; -- real_type


ENTITY real_measure_type
SUBTYPE OF(real_type);
    unit: dic_unit;
END_ENTITY; -- real_measure_type


ENTITY real_currency_type
SUBTYPE OF(real_type);
    currency: OPTIONAL currency_code; 
END_ENTITY; -- real_currency_type


ENTITY boolean_type
SUBTYPE OF(simple_type);
END_ENTITY; -- boolean_type


ENTITY string_type
SUBTYPE OF(simple_type);
END_ENTITY; -- string_type


ENTITY non_quantitative_code_type
SUBTYPE OF(string_type);
    domain: value_domain;
WHERE
    WR1: QUERY(v <* domain.its_values | 
        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN
        TYPEOF(v.value_code))) = [];
END_ENTITY; -- non_quantitative_code_type


ENTITY complex_type
ABSTRACT SUPERTYPE OF(ONEOF(
    level_type,
    class_instance_type,
    entity_instance_type))
SUBTYPE OF(data_type);
END_ENTITY; -- complex_type


ENTITY level_type
SUBTYPE OF(complex_type);
    levels: LIST [1:4] OF UNIQUE level;
    value_type: simple_type;
WHERE
    WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'
        IN TYPEOF(value_type);
END_ENTITY; -- level_type


TYPE level = ENUMERATION OF(
    min,        
    nom,        
    typ,        
    max);   
END_TYPE; -- level 


ENTITY class_instance_type
SUBTYPE OF(complex_type);
    domain: class_BSU;
END_ENTITY; -- class_instance_type


ENTITY entity_instance_type
SUBTYPE OF(complex_type);
    type_name: SET OF STRING;
END_ENTITY; -- entity_instance_type


ENTITY placement_type
SUPERTYPE OF(ONEOF(
    axis1_placement_type,
    axis2_placement_2d_type,
    axis2_placement_3d_type))
SUBTYPE OF(entity_instance_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.PLACEMENT' 
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- placement_type


ENTITY axis1_placement_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS1_PLACEMENT' IN
        SELF\entity_instance_type.type_name;
END_ENTITY; -- axis1_placement_type


ENTITY axis2_placement_2d_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D'
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_2d_type


ENTITY axis2_placement_3d_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' 
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_3d_type


ENTITY named_type
SUBTYPE OF(data_type );
    referred_type: data_type_BSU;
END_ENTITY; -- named_type


ENTITY value_domain;
    its_values: LIST [2:?] OF dic_value;
    source_doc_of_value_domain: OPTIONAL document;
    languages: OPTIONAL present_translations;
    terms: LIST [0:?] OF item_names;
WHERE
    WR1: NOT EXISTS(languages) OR (QUERY(v <* its_values |
        languages :<>: v.meaning.languages) = []);
    WR2: codes_are_unique(its_values);
END_ENTITY; -- value_domain


TYPE integer_type = INTEGER; 
END_TYPE; -- integer_type

TYPE value_type = SELECT(value_code_type, integer_type); 
END_TYPE; -- value_type


ENTITY dic_value;
    value_code: value_type;
    meaning: item_names;
    source_doc_of_value: OPTIONAL document;
END_ENTITY; -- dic_value


ENTITY non_si_unit
SUBTYPE OF(named_unit);
    name: label;
END_ENTITY; -- non_si_unit


RULE assert_ONEOF FOR(named_unit);
WHERE
    QUERY(u <* named_unit | 
        ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' 
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u))
        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' 
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u))
        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT'
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u))
        ) = []; 
END_RULE; -- assert_ONEOF


ENTITY dic_unit;
    structured_representation: unit; 
    string_representation: OPTIONAL mathematical_string;
END_ENTITY; -- dic_unit


TYPE class_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= class_code_len;
END_TYPE; -- class_code_type


TYPE code_type = identifier; 
WHERE 
    WR1: NOT(SELF LIKE '*.*');
    WR2: NOT(SELF LIKE '*-*');
    WR3: NOT(SELF LIKE '* *');
    WR4: NOT(SELF = '');
END_TYPE; -- code_type


TYPE currency_code = identifier;
WHERE
    WR1: LENGTH(SELF) = 3;
END_TYPE; -- currency_code


TYPE data_type_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) = data_type_code_len;
END_TYPE; -- data_type_code_type


TYPE date_type = STRING(10) FIXED;
END_TYPE; -- date_type


TYPE definition_type = translatable_text;
END_TYPE; -- definition_type


TYPE DET_classification_type = identifier;
WHERE
    WR1: LENGTH(SELF) = DET_classification_len; 
END_TYPE; -- DET_classification_type


TYPE note_type = translatable_text;
END_TYPE; -- note_type


TYPE pref_name_type = translatable_label;
WHERE
    WR1: check_label_length(SELF, pref_name_len);
END_TYPE; -- pref_name_type


TYPE property_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= property_code_len;
END_TYPE; -- property_code_type


TYPE remark_type = translatable_text; 
END_TYPE; -- remark_type


TYPE revision_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= revision_len; 
END_TYPE; -- revision_type


TYPE short_name_type = translatable_label;
WHERE
    WR1: check_label_length(SELF, short_name_len); 
END_TYPE; -- short_name_type


TYPE supplier_code_type = code_type;
WHERE
    WR1: LENGTH(SELF) <= supplier_code_len; 
END_TYPE; -- supplier_code_type


TYPE syn_name_type = SELECT(label_with_language, label);
WHERE
    WR1: check_syn_length(SELF, syn_name_len); 
END_TYPE; -- syn_name_type


TYPE value_code_type = identifier;
WHERE
    WR1: LENGTH(SELF) <= value_code_len; 
END_TYPE; -- value_code_type


TYPE value_format_type = identifier;
WHERE
    WR1: LENGTH(SELF) <= value_format_len; 
END_TYPE; -- value_format_type


TYPE version_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= version_len; 
    WR2: EXISTS(VALUE(SELF)) AND ('INTEGER' IN TYPEOF(VALUE(SELF)))
        AND (VALUE(SELF) >= 0);
END_TYPE; -- version_type


TYPE source_doc_type = identifier; 
WHERE
    WR1: LENGTH(SELF) <= source_doc_len; 
END_TYPE; -- source_doc_type


ENTITY dates;
    date_of_original_definition: date_type;
    date_of_current_version: date_type;
    date_of_current_revision: OPTIONAL date_type;
END_ENTITY; -- dates


ENTITY document
ABSTRACT SUPERTYPE;
END_ENTITY; -- document


ENTITY graphics
ABSTRACT SUPERTYPE;
END_ENTITY; -- graphics


ENTITY identified_document
SUBTYPE OF(document);
    document_identifier: source_doc_type;
END_ENTITY; -- identified_document


ENTITY item_names;
    preferred_name: pref_name_type;
    synonymous_names: SET OF syn_name_type;
    short_name: short_name_type;
    languages: OPTIONAL present_translations;
    icon : OPTIONAL graphics;
WHERE
    WR1: NOT(EXISTS(languages )) OR (
        ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'
        + '.TRANSLATED_LABEL' IN TYPEOF(preferred_name))
        AND (languages :=: preferred_name\translated_label.languages)
        AND ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'
        + '.TRANSLATED_LABEL' IN TYPEOF(short_name))
        AND (languages :=: short_name\translated_label.languages)
        AND (QUERY(s <* synonymous_names |
        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
        '.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []));
    WR2: NOT EXISTS(languages) OR (QUERY(s <* synonymous_names |
        EXISTS(s.language) AND NOT(s.language IN
        QUERY(l <* languages.language_codes | TRUE
        ))) = []);
    WR3: at_most_two_synonyms_per_language(languages, 
        synonymous_names);
END_ENTITY; -- item_names


ENTITY label_with_language;
    l: label;
    language: language_code;
END_ENTITY; -- label_with_language


ENTITY mathematical_string;
    text_representation: text; 
    SGML_representation: OPTIONAL text;
END_ENTITY; -- mathematical_string


FUNCTION acyclic_superclass_relationship(
    current: class_BSU; visited: SET OF class): LOGICAL;

IF SIZEOF(current.definition) = 1 THEN 
    IF current.definition[1] IN visited THEN
        RETURN(FALSE);
    
    ELSE
        IF EXISTS(current.definition[1]\class.its_superclass)
        THEN 
            RETURN(acyclic_superclass_relationship(
                current.definition[1]\class.its_superclass,
                visited + current.definition[1])); 
        ELSE
            RETURN(TRUE);
        END_IF;
    END_IF;
ELSE
    RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- acyclic_superclass_relationship


FUNCTION at_most_two_synonyms_per_language(
    languages: present_translations;
    synonymous_names: SET OF syn_name_type): BOOLEAN;

IF EXISTS(languages) THEN
    REPEAT i := 1 TO SIZEOF(languages.language_codes);
        IF SIZEOF(QUERY(s <* synonymous_names |
            s.language = languages.language_codes[i])) > 2
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;
    RETURN(TRUE);
ELSE
    RETURN(SIZEOF(synonymous_names) <= 2);
END_IF;
END_FUNCTION; -- at_most_two_synonyms_per_language


FUNCTION check_syn_length(s: syn_name_type; s_length: INTEGER):BOOLEAN;

IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA.LABEL_WITH_LANGUAGE' 
    IN TYPEOF(s)
THEN 
    RETURN(LENGTH(s.l) <= s_length); 
ELSE
    RETURN(LENGTH(s) <= s_length); 
END_IF;
END_FUNCTION; -- check_syn_length 


FUNCTION codes_are_unique(values: LIST OF dic_value): BOOLEAN;
LOCAL
    ls: SET OF STRING := [];
    li: SET OF INTEGER := [];
END_LOCAL;

IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN 
    TYPEOF(values[1].value_code))
THEN
    REPEAT i := 1 TO SIZEOF(values);
        ls := ls + values[i].value_code;
    END_REPEAT;

    RETURN(SIZEOF(values) = SIZEOF(ls));
ELSE
    IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.INTEGER_TYPE' IN 
        TYPEOF(values[1].value_code))
    THEN
        REPEAT i := 1 TO SIZEOF(values);
            li := li + values[i].value_code;
        END_REPEAT;

        RETURN(SIZEOF(values) = SIZEOF(li));
    ELSE
        RETURN(UNKNOWN);
    END_IF;
END_IF;

END_FUNCTION; -- codes_are_unique


FUNCTION definition_available_implies(
    BSU: basic_semantic_unit;
    expression: LOGICAL): LOGICAL;

RETURN(NOT(SIZEOF(BSU.definition) = 1) OR expression);

END_FUNCTION; -- definition_available_implies


FUNCTION is_subclass(sub, super: class): LOGICAL;
    IF (NOT EXISTS(sub)) OR (NOT EXISTS(super)) THEN
        RETURN(UNKNOWN);
    END_IF;
    
    IF sub = super
    THEN
        RETURN(TRUE);
    END_IF;
    
    IF NOT EXISTS(sub.its_superclass) 
    THEN
        
        RETURN(FALSE); 
    END_IF;
    
    IF SIZEOF(sub.its_superclass.definition) = 1 
    THEN


        IF (sub.its_superclass.definition[1] = super) 
        THEN
            RETURN(TRUE);
        ELSE
            RETURN(is_subclass(sub.its_superclass.definition[1],
                super));
        END_IF;
    ELSE
        RETURN(UNKNOWN);
    END_IF;

END_FUNCTION; -- is_subclass


FUNCTION string_for_derived_unit(u: derived_unit): STRING;

    FUNCTION string_for_derived_unit_element(
        u: derived_unit_element; neg_exp: BOOLEAN
        ): STRING;
        

    
    LOCAL
        result: STRING;
    END_LOCAL;
        
    result := string_for_named_unit(u.unit);
    IF (u.exponent <> 0) 
    THEN 
        IF (u.exponent > 0) OR NOT neg_exp 
        THEN
            result := result + '**' + FORMAT(
                ABS(u.exponent), '2I')[2];
        ELSE
            result := result + '**' + FORMAT(u.exponent, '2I')[2];
        END_IF;
    END_IF;
        RETURN(result); 
    END_FUNCTION; -- string_for_derived_unit_element

LOCAL
    pos, neg: SET OF derived_unit_element;
    us: STRING;
END_LOCAL;
    

pos := QUERY(ue <* u.elements | ue.exponent > 0); 
neg := QUERY(ue <* u.elements | ue.exponent < 0); 
us := '';
IF SIZEOF(pos) > 0 THEN
    
    REPEAT i := LOINDEX(pos) TO HIINDEX(pos);
        us := us + string_for_derived_unit_element(pos[i], FALSE);
        IF i <> HIINDEX(pos) 
        THEN
            us := us + '.'; 
        END_IF;
    END_REPEAT;

    IF SIZEOF(neg) > 0 
    THEN 
        

        us := us + '/';

        IF SIZEOF(neg) > 1 
        THEN
            us := us + '('; 
        END_IF;

        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], FALSE);
            IF i <> HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;

        IF SIZEOF(neg) > 1 
        THEN 
            us := us + ')'; 
        END_IF;
    END_IF;
ELSE 
    
    IF SIZEOF(neg) > 0 THEN
        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], TRUE);
            IF i <> HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;
    END_IF;
END_IF;

RETURN(us);

END_FUNCTION; -- string_for_derived_unit


FUNCTION string_for_named_unit(u: named_unit): STRING;

IF 'MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u) THEN
    RETURN(string_for_SI_unit(u));
ELSE
    IF 'MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u)
    THEN
        RETURN(u\context_dependent_unit.name);
    ELSE
        IF 'MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u)
        THEN
            RETURN(u\conversion_based_unit.name);
        ELSE
            IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA'
                +'.NON_SI_UNIT' IN TYPEOF(u)
            THEN
                RETURN(u\non_si_unit.name);
            ELSE
                RETURN('name_unknown');
            END_IF;
        END_IF;
    END_IF;
END_IF;

END_FUNCTION; -- string_for_named_unit


FUNCTION string_for_SI_unit(unit: si_unit): STRING;

LOCAL
    prefix_string, unit_string: STRING;
END_LOCAL;

IF EXISTS(unit.prefix) THEN
    CASE unit.prefix OF
        exa     : prefix_string := 'E';
        peta        : prefix_string := 'P';
        tera        : prefix_string := 'T';
        giga        : prefix_string := 'G';
        mega        : prefix_string := 'M';
        kilo        : prefix_string := 'k';
        hecto   : prefix_string := 'h';
        deca        : prefix_string := 'da';
        deci        : prefix_string := 'd';
        centi   : prefix_string := 'c';
        milli   : prefix_string := 'm';
        micro   : prefix_string := 'u';
        nano        : prefix_string := 'n';
        pico        : prefix_string := 'p';
        femto   : prefix_string := 'f';
        atto        : prefix_string := 'a';
    END_CASE;
ELSE
    prefix_string := '';
END_IF;

CASE unit.name OF
    metre           : unit_string:= 'm'; 
    gram                : unit_string := 'g'; 
    second          : unit_string := 's'; 
    ampere          : unit_string := 'A'; 
    kelvin          : unit_string := 'K'; 
    mole                : unit_string := 'mol'; 
    candela         : unit_string := 'cd'; 
    radian          : unit_string := 'rad'; 
    steradian           : unit_string := 'sr'; 
    hertz           : unit_string := 'Hz'; 
    newton          : unit_string := 'N'; 
    pascal          : unit_string := 'Pa'; 
    joule           : unit_string := 'J'; 
    watt                : unit_string := 'W'; 
    coulomb         : unit_string := 'C'; 
    volt                : unit_string := 'V'; 
    farad           : unit_string := 'F'; 
    ohm             : unit_string := 'Ohm';
    siemens         : unit_string := 'S'; 
    weber           : unit_string := 'Wb'; 
    tesla           : unit_string := 'T'; 
    henry           : unit_string := 'H'; 
    degree_Celsius      : unit_string := 'Cel';
    lumen           : unit_string := 'lm'; 
    lux             : unit_string := 'lx'; 
    becquerel           : unit_string := 'Bq'; 
    gray                : unit_string := 'Gy';
    sievert         : unit_string := 'Sv';
END_CASE;

RETURN(prefix_string + unit_string); 

END_FUNCTION; -- string_for_SI_unit


FUNCTION string_for_unit(u: unit): STRING;
    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(u) 
    THEN
        RETURN(string_for_derived_unit(u));
    ELSE 
        RETURN(string_for_named_unit(u));
    END_IF;
END_FUNCTION; -- string_for_unit


FUNCTION all_class_descriptions_reachable(cl: class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN
    RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(FALSE);
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
    RETURN(TRUE);
ELSE
    RETURN(all_class_descriptions_reachable(
        cl.definition[1]\class.its_superclass));
END_IF;

END_FUNCTION; -- all_class_descriptions_reachable


FUNCTION compute_known_visible_properties(cl: class_BSU):
    SET OF property_BSU;
LOCAL
    s: SET OF property_BSU := [];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.PROPERTY_BSU.NAME_SCOPE');
IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) THEN
        s := s + compute_known_visible_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_properties


FUNCTION compute_known_visible_data_types(cl: class_BSU):
    SET OF data_type_BSU;
LOCAL
    s: SET OF data_type_BSU :=[ ];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.DATA_TYPE_BSU.NAME_SCOPE');

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_visible_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_data_types


FUNCTION compute_known_applicable_properties(cl: class_BSU): 
    SET OF property_BSU;

LOCAL 
    s: SET OF property_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition)=0
THEN 
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
        s := s + cl.definition[1]\class.described_by[i];
    END_REPEAT;

    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN 
        s := s + compute_known_applicable_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s); 
END_IF;
END_FUNCTION; -- compute_known_applicable_properties


FUNCTION compute_known_applicable_data_types(cl: class_BSU):
    SET OF data_type_BSU;
LOCAL
    s: SET OF data_type_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
        s := s + cl.definition[1]\class.defined_types[i];
    END_REPEAT;
    
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_applicable_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_applicable_data_types


FUNCTION list_to_set(l: LIST [0:?] OF GENERIC:type_elem):
    SET OF GENERIC: type_elem;

LOCAL
    s: SET OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
END_REPEAT;

RETURN(s);
END_FUNCTION; -- list_to_set


FUNCTION check_properties_applicability(cl: class): LOGICAL;
LOCAL
    inter: SET OF property_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition)=1)
    THEN
        inter := (list_to_set(cl.described_by) * 
            cl.its_superclass.definition[1]\class.
            known_applicable_properties);
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_properties_applicability


FUNCTION check_datatypes_applicability(cl: class): LOGICAL;
LOCAL
    inter: SET OF data_type_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition) = 1)
    THEN
        inter := cl.defined_types * 
            cl.its_superclass.definition[1]\class.
            known_applicable_data_types;
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_datatypes_applicability

END_SCHEMA; -- ISO13584_IEC61360_dictionary_schema


(*
 $Id: mim.exp,v 1.6 2004/11/19 21:37:37 robbod Exp $
 ISO TC184/SC4/WG12 N3086 - ISO/TS 10303-1340 Name assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2283
*) 


SCHEMA Name_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (name_assignment); 


TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

END_SCHEMA;  -- Name_assignment_mim



(*
$Id: certification_schema.exp,v 1.6 2004/11/09 18:42:30 mikeward Exp $
ISO TC184/SC4/WG12 N28872 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA certification_schema; 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;

END_SCHEMA;  -- certification_schema


(*
$Id: contract_schema.exp,v 1.5 2004/11/10 12:32:56 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA contract_schema; 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;

ENTITY contract_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_contract : contract;
  related_contract : contract;
END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

FUNCTION acyclic_contract_relationship
 (relation : contract_relationship; relatives : SET[1:?] OF contract; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- contract_schema

(*
$Id: document_schema.exp,v 1.6 2004/11/25 16:29:38 thendrix Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA document_schema;

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE product_or_formation_or_definition = SELECT
   (product, 
    product_definition_formation, 
    product_definition);
END_TYPE; 

ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;

ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY;

FUNCTION acyclic_document_relationship
 (relation : document_relationship; relatives : SET[1:?] OF document; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- document_schema




(*
$Id: experience_schema.exp,v 1.13 2004/11/10 14:41:44 mikeward Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA experience_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY experience;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience : experience;
  related_experience : experience;
END_ENTITY;

ENTITY experience_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience_type : experience_type;
  related_experience_type : experience_type;
END_ENTITY;

FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- experience_schema


(*
  $Id: location_schema.exp,v 1.11 2004/11/10 15:38:20 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA location_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY location;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_location : location;
  related_location : location;
END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- location_schema

(*
  $Id: qualifications_schema.exp,v 1.10 2004/11/10 15:33:21 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA qualifications_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY qualification;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification : qualification;
  related_qualification : qualification;
END_ENTITY;

ENTITY qualification_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification_type : qualification_type;
  related_qualification_type : qualification_type;
END_ENTITY;

FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- qualifications_schema

(*
  $Id: security_classification_schema.exp,v 1.4 2004/11/10 12:21:16 mikeward Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA security_classification_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;

END_SCHEMA;  -- security_classification_schema



(*
$Id: mim.exp,v 1.9 2005/06/02 20:42:28 thendrix Exp $
ISO TC184/SC4/WG12 N2926 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1103
*) 


SCHEMA Product_identification_mim; 

USE FROM Product_categorization_mim;    -- ISO/TS 10303-1016

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_related_product_category); 


END_SCHEMA;  -- Product_identification_mim


(*
 $Id: mim.exp,v 1.5 2004/10/29 16:40:18 thendrix Exp $
ISO TC184/SC4/WG12 N1100 - ISO/TS 10303-1016 Product categorization - EXPRESS MIM
*) 


SCHEMA Product_categorization_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_category_relationship); 


END_SCHEMA;  -- Product_categorization_mim


(* 
 $Id: mim.exp,v 1.6 2004/01/13 10:15:26 robbod Exp $
 ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1106
*) 


SCHEMA Product_version_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation); 


END_SCHEMA;  -- Product_version_mim

(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA material_property_definition_schema;

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY property_definition_relationship;
  name                       : label;
  description                 : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

ENTITY material_designation;
  name       : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class               : label;
  constituent_amount   : SET [1:?] OF measure_with_unit;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;

  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;

  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality

  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));

  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;

  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema

(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA product_structure_schema;

  REFERENCE FROM product_definition_schema
    (product,
     product_definition,
     product_definition_relationship,
     acyclic_product_definition_relationship);

  REFERENCE FROM measure_schema
     (measure_with_unit);

  REFERENCE FROM support_resource_schema
     (identifier, label, text);

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
                       specified_higher_usage_occurrence,
                       promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

END_SCHEMA; -- product_structure


(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA product_concept_schema;

  REFERENCE FROM support_resource_schema
    (text, label, identifier);

  REFERENCE FROM application_context_schema
    (product_concept_context);

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

END_SCHEMA; -- product_concept_schema


SCHEMA ISO13584_IEC61360_language_resource_schema;

REFERENCE FROM support_resource_schema(identifier, label, text); 
    
 


TYPE language_code = identifier; 
END_TYPE; -- language_code


ENTITY global_language_assignment;
    language: language_code;
END_ENTITY; -- global_language_assignment


ENTITY present_translations; 
    language_codes: LIST [1:?] OF UNIQUE language_code;
UNIQUE
    UR1: language_codes;
END_ENTITY; -- present_translations


TYPE translatable_label = SELECT(label, translated_label);
END_TYPE; -- translatable_label


ENTITY translated_label; 
    labels: LIST [1:?] OF label;
    languages: present_translations; 
WHERE
    WR1: SIZEOF(labels) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_label


TYPE translatable_text = SELECT(text, translated_text);
END_TYPE; -- translatable_text


ENTITY translated_text; 
    texts: LIST [1:?] OF text;
    languages: present_translations; 
WHERE
    WR1: SIZEOF(texts) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_text


FUNCTION check_label_length(l: translatable_label;
    l_length: INTEGER): BOOLEAN;

IF 'ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA.TRANSLATED_LABEL' 
    IN TYPEOF(l) 
THEN 
    REPEAT i :=1 TO SIZEOF(l.labels);
        IF LENGTH(l.labels[i]) > l_length 
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;

    RETURN(TRUE);

ELSE 
    RETURN(LENGTH(l) <= l_length); 
END_IF;
END_FUNCTION; -- check_label_length 


FUNCTION check_text_length(t: translatable_text;
    t_length: INTEGER): BOOLEAN;

IF 'ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA.TRANSLATED_TEXT' 
    IN TYPEOF(t) 
THEN 
    REPEAT i :=1 TO SIZEOF(t.texts);
        IF LENGTH(t.texts[i]) > t_length 
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;

    RETURN(TRUE);

ELSE 
    RETURN(LENGTH(t) <= t_length); 
END_IF;
END_FUNCTION; -- check_text_length 


RULE single_language_assignment FOR(global_language_assignment);
WHERE
    SIZEOF(global_language_assignment) <= 1;
END_RULE; -- single_language_assignment


END_SCHEMA; -- ISO13584_IEC61360_language_resource_schema

(* Genenerated from: ../../irs/wg12n257.exp *)



(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA material_property_representation_schema;

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY data_environment;
  name       : label;
  description : text;
  elements    : SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    : label;
  description              : text;
  relating_data_environment : data_environment;
  related_data_environment  : data_environment;
END_ENTITY;

END_SCHEMA;    -- material_property_representation_schema


(*
 $Id: mim.exp,v 1.20 2004/11/19 21:37:34 robbod Exp $
 ISO TC184/SC4/WG12 N3026 - ISO/TS 10303-1253 Condition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2319
*) 


SCHEMA Condition_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   action_method_role,
   name_assignment); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


TYPE condition_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
   (action_method_relationship);
END_TYPE; 

TYPE condition_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action_method, 
    action_method_relationship, 
    applied_action_method_assignment);
END_TYPE; 

TYPE condition_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (applied_action_method_assignment);
END_TYPE; 

ENTITY condition
  SUBTYPE OF (action_method);
END_ENTITY;

END_SCHEMA;  -- Condition_mim

(*
 $Id: mim.exp,v 1.12 2004/10/21 17:58:55 darla Exp $
 ISO TC184/SC4/WG12 N1208 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
*)


SCHEMA External_item_identification_assignment_mim;

USE FROM management_resources_schema   	-- ISO 10303-41
  (external_identification_assignment); 

USE FROM support_resource_schema		-- ISO 10303-41
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

END_SCHEMA;


(*
 $Id: mim.exp,v 1.15 2004/10/21 18:07:23 darla Exp $
 ISO TC184/SC4/WG12 N1205 - ISO/TS 10303-1127 File identification - EXPRESS MIM
*)

SCHEMA File_identification_mim;

USE FROM Identification_assignment_mim;
 
USE FROM External_item_identification_assignment_mim;

USE FROM document_schema   -- ISO 10303-41
  (document,
   document_representation_type); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

TYPE file_identification_item = SELECT BASED_ON identification_item WITH (document_file);
END_TYPE; 

TYPE file_version_item = SELECT BASED_ON versionable_item WITH
  (document_file);
END_TYPE;

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (document_file);
END_TYPE;

ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;

END_SCHEMA;

(*
   $Id: mim.exp,v 1.3 2007/01/14 21:36:13 abhpf Exp $
   ISO TC184/SC4/WG12 N - ISO/WD 10303-1480 Task_element - EXPRESS MIM *)

(******************************************************************************)
(*                                                                            *)
(*         This file was produced by Eurostep GraphicalEXPRESS V1.4.0         *)
(*                                                                            *)
(******************************************************************************)

(* Original model: ap233 wd3mim.vsd*)
(* Title: *)
(* Author: Phil Spiby*)
(* Comments: *)

(*"Task_element_mim" UNDER DEVELOPMENT *)
SCHEMA Task_element_mim;

USE FROM Activity_method_assignment_mim;

USE FROM Condition_mim;

(*USE FROM method_definition_schema
();*)

ENTITY concurrent_task_element
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY end_task
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY exit_loop
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY looping_element
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_element
SUBTYPE OF (action_method);
END_ENTITY;

ENTITY task_element_relationship
SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY task_element_sequence
SUBTYPE OF (task_element);
END_ENTITY;

ENTITY task_step
SUBTYPE OF (task_element);
END_ENTITY;

SUBTYPE_CONSTRAINT restrict_task_method_subtypes FOR task_element;
  ONEOF(concurrent_task_element, end_task, exit_loop, looping_element, task_element_sequence, task_step);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;


