<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: module.xml,v 1.26 2008/10/16 13:51:37 abhpf Exp $ -->
<!DOCTYPE module SYSTEM "../../../dtd/module.dtd">
<!-- Generated by mkmodule.js, Eurostep Limited, http://www.eurostep.com -->
 <!-- 
     To view the module in IExplorer, open: sys/1_scope.xml
      -->
<module
   name="function_based_behaviour"
   part="1453"
   version="1"
   sc4.working_group="3"
   wg.number="2480"
   wg.number.arm="2481"
   wg.number.mim="2482"
   wg.number.arm_lf="2483"
   wg.number.mim_lf="2484"
   wg.number.supersedes="2286"
   wg.number.arm.supersedes="2287"
   wg.number.mim.supersedes="2288"
   wg.number.arm_lf.supersedes="2289"
   wg.number.mim_lf.supersedes="2290"
   checklist.internal_review="2356"
   checklist.project_leader="2357"
   checklist.convener="2355"
   status="TS"
   language="E"
   publication.year="2009"
   publication.date=""
   published="n"
   rcs.date="$Date: 2008/10/16 13:51:37 $"
   rcs.revision="$Revision: 1.26 $"
   development.folder="dvlp">

 <keywords>
    module, systems engineering, system behaviour, function based behaviour
 </keywords>

<!-- the abstract for the module. If not provided, the XSL will use the in scope -->

 <!-- Reference to contacts detailed in stepmod/data/basic/contacts.xml -->
 <contacts>
  <projlead ref="ap233.projlead2"/> 
   <editor ref="ap233.editor2"/>
 </contacts>

 <!-- Introduction -->
 <!-- The introduction should start as shown: -->
 <purpose>
   <p>
     This part of ISO 10303 specifies an application module for representing 
     the generic elements of the function based behaviour modeling paradigms used 
     for response to excitation analysis.
   </p>
   
   <p>
    One of the essential characteristics of systems that require modeling 
    is the response of the system to excitation. Function based behaviour 
    provides a model for response to excitation that is executable in tools. This
    provides a time line for that response and records logical errors in the 
    model that prevent execution. 
   </p>
   
   <p>This module provides links to generic modeling elements required to view 
   and model system behaviour from the perspective for "function".  This view does 
   not use the concept of "state."
   </p>
   
   <p>
   The concept model used during the development of this module is in Annex 
   <module_ref linkend="function_based_behaviour:f_usage_guide"> F</module_ref>.
   </p>
 </purpose>

 <!-- Items in scope -->
 <inscope>
   <li>provides the identification of a behaviour;</li>
   <li>provides a hierarchy of behaviours;</li>
   <li>provides a function based representation of behaviour;</li>
   <li>provides a hierarchy of functions within a function based behaviour representation;</li>
   <li>provides a means of representing the inputs and outputs of a function, including triggering mechanisms where appropriate;</li>
   <li>provides for the ordering of functions, and identifying decision points;</li>
   <li>supports identification of shared resources used by function;</li>
   <li>supports shared resource properties;</li>
   <li>supports the common graphical representations: Function Flow Block Diagram (FFBD),
   Data Flow Diagram (DFD), N2 (N-Squared) Chart, IDEF0 Diagram, Use Case, Sequence Diagram, 
   Enhanced Function Flow Block Diagram, and Behaviour Diagram (BD).</li>
 </inscope>

 <!-- Items out of scope -->
 <outscope>
   <li>a state based representation of behaviour.</li>
 </outscope>

<!--
 <normrefs/>
-->

<definition>
   <term id="ap233_function">function</term>
   <def>the entity in the context of modeling that transforms an input set of elements 
   into a set of output elements that may be the same or measurably different from the input set
   <note>It is a part of behavior. This is what functions do in mathematics where the 
   input/output are variables. In software the input/output is data. In systems engineering 
   the input/output are elements, matter, energy, and information. An internal function is a 
   kind of function that is allocated to and implemented by the system/structure. An external 
   function is a kind of function that is allocated to and implemented by elements in the environment. 
   </note>
   <example>The function may be "burn gasses" with an input of two moles of hydrogen and one 
   mole of oxygen. The output will be one mole of water, distinctly different from the inputs 
   and a lot of energy. This function may be followed by a function "cool to 90 degrees 
   centigrade". The input had pressure and volume proportional to temperature; the output 
   is now liquid with a well-defined volume, an isotropic compressibility and a viscosity. If 
   the next function is "cool to â€“10 degrees centigrade", then the viscosity goes away and the 
   compressibility becomes a fourth rank tensor relating stress to strain. 
   </example>
   </def>
</definition>

<definition>
   <term id="ap233_input output">input output</term>
   <def>elements consumed by a function are inputs and those generated by a function are outputs
 <note>The name input/output or I/O is used because a given I/O entity is generated by one 
 function and consumed by another. It is a part of behavior. In the general case outputs are 
 different things than inputs, and physical properties, behaviors, values, variances and 
 probability distributions can all change. In this general definition "function" is an element 
 of type information and cannot be realized in the physical world except through elements of 
 type matter or energy that exhibit that function. In the physical world things transform other 
 things. It is this fact of reality that results in the allocation of function to structure 
 which is really a statement that this particular structure entity exhibits this particular 
 function and it will be used to provide that transformation. The thought pattern is to think 
 of the desired transformation, function, to consider alternative things that might be used to 
 provide it, and to select among these, using a trade study based on optimization.</note>
   <example>I/O may trigger functions and it may terminate functions.</example>
    </def>
</definition>

<definition>
   <term id="ap233_function ordering">function ordering</term>
   <def>imposes how/when functions execute, which may be sequential, concurrent, traversed 
   iteratively, or lie on separate alternative path
  <note>David <b>some word-smithing has been done, please check</b> </note>
   <note>It is a part of behavior. There are several ways to represent function ordering. It 
   may be done with ordering operators and triggering input/output as in classical behavior 
   diagrams or it may be done with events, states, and transitions as done in state machines 
   and state charts. For this fine level of detail it is necessary to inter-compare the 
   detailed models in SEDRES with those in the concept model and those emerging from UML 2.0 development.
   </note>
   <example>A function is activated when all preceding threads of functions are complete. 
   At this point the function examines its inputs. If all triggering inputs are present the 
   function proceeds to do its work. If one or more triggering inputs is absent, the function 
   waits for them before doing its work. Triggers that arrive while the functions are running 
   are stored in a first in first out queue. Ordinary input/output that arrives while a function 
   is deactivated is stored in a last in first out queue. If the function is running it is 
   discarded.  A function is deactivated when it completes its work or is deactivated by input/output.</example>
    </def>
</definition>

<definition>
   <term id="ap233_script">script</term>
   <def>an executable textual language statement assigned to a function to define how 
   that function executes
    </def>
</definition>

<definition>
   <term id="ap233_timing">timing</term>
   <def>a time interval assigned to a function that defines the duration of activity of the 
   function or the probability distribution for the duration
   <note>Many probability distributions are used in systems engineering. These may include: 
   Normal, Log-normal, Bernoulli, Beta, Binomial, Negative binomial, Chi squared, Discrete 
   Uniformed, Erlang, Exponential, F, Gamma, Geometric, Laplace, Poisson, T, Triangular, 
   Uniform, Weibull.</note>
    </def>
</definition>

<definition>
   <term id="ap233_and">and</term>
   <def>an ordering operation pair that establishes concurrency among functions
    </def>
</definition>

<definition>
   <term id="ap233_iterate">iterate</term>
   <def>an ordering operation that repeats a function or group of functions 
    </def>
</definition>

<definition>
   <term id="ap233_iterate limit">iterate limit</term>
   <def>an ordering operation that establishes the set over which the iteration is performed
    </def>
</definition>


<definition>
   <term id="ap233_loop">loop</term>
   <def>an ordering operation that repeats a function or group of functions some number of times
    </def>
</definition>

<definition>
   <term id="ap233_loop limit">loop limit</term>
   <def>the number or expression for the number of repetitions in a loop 
    </def>
</definition>

<definition>
   <term id="ap233_loop exit">loop exit</term>
   <def>the ordering operation that terminates a loop and provides correct continuation of the execution path
    </def>
</definition>

<definition>
   <term id="ap233_sequence">sequence</term>
   <def>an ordering operator that establishes sequence among functions
    </def>
</definition>

<definition>
   <term id="ap233_or">or</term>
   <def>an ordering operator pair that establishes alternative paths for a group of functions
    </def>
</definition>

<definition>
   <term id="ap233_multi exit function">multi exit function</term>
   <def>a special function with multiple exit conditions that can serve the same purpose as "or out"
    </def>
</definition>


<!--
 <abbreviations/>
-->

 <!-- Clause 4 ARM  -->
 <arm>
   <!-- Note ARM short form EXPRESS is in arm.xml -->

   <!-- Short form EXPRESS-G -->
   <express-g>
     <imgfile file="armexpg1.xml"/>
     <imgfile file="armexpg2.xml"/>
   </express-g>
 </arm>

<!-- ARM long form (optional) -->
 <!-- If not required, delete this section and the following files:
          arm_lf.xml
          armexpg_lf1.gif
          armexpg_lf1.xml -->
 <arm_lf>
   <!-- Note ARM long form EXPRESS is in arm_lf.xml -->
   <express-g>
     <imgfile file="armexpg_lf1.xml"/>
   </express-g>
 </arm_lf>

 <!-- Clause 5.1 Mapping specification
 <mapping_table>
   <ae entity="xx"/>
 </mapping_table> -->

 <!-- Clause 5.2 MIM -->
 <mim>
   <!--  Note MIM short form express is in mim.xml -->
   <express-g>
     <imgfile file="mimexpg1.xml"/>
     <imgfile file="mimexpg2.xml"/>
   </express-g>
    <shortnames>   
    <shortname name="FCAAMA" entity="fbb_characterized_applied_action_method_assignment"/>
    <shortname name="FCGE" entity="fbb_characterized_generic_expression"/>
    <shortname name="FCGP" entity="fbb_characterized_general_property"/>
    <shortname name="FCGPR" entity="fbb_characterized_general_property_relationship"/>
    <shortname name="FBCHRPR" entity="fbb_characterized_product"/>
    <shortname name="FCPC" entity="fbb_characterized_product_category"/>
    <shortname name="FCPDF" entity="fbb_characterized_product_definition_formation"/>
    <shortname name="FCPDFR" entity="fbb_characterized_product_definition_formation_relationship"/>
    <shortname name="FCPD" entity="fbb_characterized_property_definition"/>
    <shortname name="FCPDR" entity="fbb_characterized_property_definition_representation"/>
    <shortname name="FBCHRP" entity="fbb_characterized_representation"/>
    <shortname name="FCRC" entity="fbb_characterized_representation_context"/>
    <shortname name="FCRI" entity="fbb_characterized_representation_item"/>
  </shortnames>   
 </mim>

 <!-- MIM long form (optional) -->
 <!-- If not required, delete this section and the following files:
          mim_lf.xml
          mimexpg_lf1.gif
          mimexpg_lf1.xml -->
 <mim_lf>
   <!-- Note MIM long form EXPRESS is in mim_lf.xml -->
   <express-g>
     <imgfile file="mimexpg_lf1.xml"/>
   </express-g>
 </mim_lf>

   <usage_guide>
   
   
   	<p>Function Based Behavior clearly depicts Functions and their I/O. It is hierarchical. Ordering 
	of the functions is provided by ordering operations. Functions with their I/O correspond to classic 
	systems engineering N-Squared Charts and related to (but not identical with) data flow diagrams. They 
	provide a functional data model. Functions with their ordering correspond to the Functional Flow 
	Block Diagrams, developed in the 1950â€™s by TRW for the Army ballistic missile program. They modeled 
	functional control. In the 1970â€™s, when Jim Long added I/O to the FFBDâ€™s, these executable diagrams 
	began to be used in systems engineering to capture response to excitation and to generate time lines. 
	They have been called Behavior Diagrams and Extended Functional Flow Block Diagrams, EFFBDâ€™s. </p>
	
	<p>
	During 2006 the SysML program <a href="http://www.omgsysml.org"/> has generated a standard that provides 
	for an equivalent capability with diagrams called Activity Diagrams; reference 
	<a href="http://en.wikipedia.org/wiki/Activity_diagram"/>.  
	These are extensions made to UML 2.0 (see, <a href="http://en.wikipedia.org/wiki/Unified_Modeling_Language"/>)
	via the SysML program (see, <a href="http://en.wikipedia.org/wiki/SysML"/>). </p>
	
	<p>It is possible to define a unifying view for all of these graphical presentation.
	This is capsulated both in AP233 Concept Model and in Jim Long's white paper <i>Relationships 
	between Common Graphical Representations in Systems Engineering</i>.</p>

	<p><b>F.1 AP233 function based behaviour concept model</b></p>
	
   	<p>Function Based Behavior can be defined as a representation of what a system is to do, 
	based on descriptions of the transformations it performs. What a thing does can be 
	described by citing a set of significant transformations it performs. In science and 
	all changes can be represented by transformations that follow well known transformation 
	laws like conservation of matter and energy.</p>
	
	<p>Function is a transformation that consumes engineering things and generates or transforms 
	them into other engineering things. I/O is the output from one Function and the input to another Function.
	In all of the mathematical laws of science engineering things are transformed into other 
	engineering things. </p>

	<p>In the physical world nothing is created, destroyed or deleted. There is only transformation.
	Function embodies this concept and is the representation and basis for change in the physical world.</p>
	
	<figure id="ffb1" number="F-1"> 
	<title>Definitions concerning function based behaviour</title>
	<img src="SEHandBk7.gif"/>	
	</figure>

	
	<p>Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb1"> F-1</module_ref> 
	and the integer tagged definitions below provide the relationships for Function, I/O and Ordering 
	that are essential to the function based behaviour representation problem.</p>
	
	<p>An engineering thing is that for which observable, measurable, and reproducible properties or 
	attributes can be obtained.</p>
	
	<p>Function <i>(31)</i> is a transformation that consumes one set of engineering things and generates or 
	transforms them into another set of engineering things.</p>
	
	<p>I/O <i>(32)</i> is the output from one Function and an input to another Function</p>
	
	<p>Time_interval <i>(36)</i> is a period of time during which a Function produces its I/O. In some disciplines 
	the transitions are found to be fast enough that they can be considered to be instantaneous. 
	Transformation of inputs into outputs takes a finite amount of time. The Time_intervals can be 
	assigned to a complex set of functions and then the time line for the behavior can be calculated 
	from the model. In this manner an overall required time response can be calculated from a 
	design behavior model. That prediction can then be verified by measurement when the system is built. </p>
	
	<p>Function_ordering <i>(37)</i> is an operator that arranges functions as they are to be 
	executed in practice. Functions may occur in sequence or concurrently. It is possible to execute a 
	function repeatedly. These relationships are captured by a set of ordering operations and a set of 
	execution rules for the model.</p>
	
	<p>Script <i>(38)</i> is a set of language elements associated with a Function that define how that Function 
	acts on inputs to generate outputs. By embedding language elements in a Function, the Function 
	can carry out transformation and decision processes on inputs that it receives.</p>
	
	<p>Sequence <i>(39)</i> is an ordering operator that establishes sequence among Functions. In some cases a 
	behavior requires a particular sequence of Functions to get a particular result. </p>
	
	<p>And <i>(40)</i> is an ordering operator that establishes concurrency among functions. Some Functions must 
	be done at the same time to be effective; they must be concurrent.</p>
	
	<p>Or <i>(41)</i> is an ordering operator that establishes alternative paths among a group of  Functions. In 
	many systems there are multiple choices in its behavior. These choices are represented by 
	multiple paths or threads through the behavior. </p>
	
	<p>Multi_exit_function <i>(42)</i> is a Function that acts as an ordering operator that provides multiple 
	exits to alternative paths. One way of representing alternative paths is to use a Function that 
	has multiple exits and internal rules for the choices.</p>
	
	<p>Loop <i>(43)</i> is an  ordering operator that repeats a Functions or group of Functions some number of times.
	Often the same transformation is repeated for some number of times.</p>
	
	<p>Loop_limit <i>(44)</i> is the number or expression for the number of repetitions in a Loop. It is inefficient 
	use of resource to allow a loop to run without a limit to stop it.</p>
	
	<p>Loop_exit <i>(45)</i> is the ordering operation that terminates a loop and provides correct continuation of 
	the execution path. Often when a loop ends there is a transition to an entry point in the behavior.</p>
	
	<p>Iterate <i>(46)</i> is an ordering operator that repeats a Function or group of Functions. It is possible for 
	the termination of a repeated transformation not to be based on a number. It may be based on a 
	condition or a set of conditions.</p>
	
	<p>Iterate_limit <i>(47)</i> is an ordering operation that establishes the set over which the iteration is 
	to be performed. In the games of checkers and chess there is no set number of moves that are made. 
	Rather the game proceeds by a set rules until a final rule or condition is met.</p>

	<p><b>F.2 Background</b></p> 

	<p>The following text has been extracted (with permission) from Jim Long's White Paper "Relationships
	between Common Graphical Representations in Systems Engineering".  This work is harmonized with
	both the AP233 Concept Model and the EXPRESS model defined within the Function Based behaviour
 	module set. The full/original white paper entitiled can be downloaded at:
	<a href="http://www.vitechcorp.com/library/papers.php"/>	</p>				

	<p>Over the past several years, systems engineers have
	evolved to a few graphical representations to present the functional and data flow
	characteristics of their system design. The most common of these are the Function Flow
 	Block Diagram (FFBD),Data Flow Diagram (DFD), N2 (N-Squared) Chart, IDEF0 Diagram,
 	Use Case, Sequence Diagram, Enhanced Function Flow Block Diagram, and behaviour Diagram (BD).
	Most of these graphical representations allow the engineer to decompose the functional
	and/or data models hierarchically.</p> 		

	<p>The objective of AP233's Function based behaviour capability is to provide a data model that 
	can be used as a neutral format for 	all of the graphical representations defined herein.  
	This data model is "complete", relative 	to the function based behaviour representation 
	needs of systems engineering. </p>		
	
	<p><b>F.3 Terminology</b></p>	
	<p>Let us introduce two terms that we use in describing the conditions that allow/cause a
	function to begin execution. Considering the control and data environment, a function can
	begin execution if it is both enabled (by control) and triggered (by data). In the case where
	there is no data trigger specified, a function begins execution upon being enabled. A
	function is enabled if the function(s) that precede it in the control flow specification
	have completed execution (e.g., satisfied their completion criteria). A function is triggered
	when the required stimulus data item becomes available to the function. We are not concerned
	here with other execution requirements (such as the availability of necessary resources, except
	in the case of the Dynamic Timeline Diagrams) that could be represented by either control or
	data structures as necessary.</p>		
	
	<p><b>F.3.1 Function Flow Block Diagram</b></p>	
	<p>The Function Flow Block Diagram (FFBD) was the first to be favored by systems engineers and
	continues to be widely used today (DSMC 1989, Blanchard and Fabrycky 1990 book "Systems 
	Engineering and Analysis"). 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb2"> F-2</module_ref> 
	shows a sample FFBD. An FFBD shows the functions that a 
	system is to perform and the order in which they are to be enabled (and performed). The order 
	of performance is specified from the set of available control constructs shown in 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb2"> F-3</module_ref> . The 
	control enablement of the first function is shown by the reference node(s) which precede it, 
	and the reference node(s) at the end of the function logic indicate what functions are enabled next. 
	The FFBD also shows completion criterion for functions as needed for specification (for example, 
	the exits for the multi-exit function in Figure 1). The FFBD does not contain any information relating 
	to the flow of data between functions, and therefore does not represent any data triggering of 
	functions. The FFBD only presents the control sequencing for the functions.</p>		
		
		<figure id="ffb2" number="F-2">
		<title>Sample Function Flow Block Diagram (FFBD)</title>			
		<img src="Vitech_fig_1.gif"/>
		</figure>		
		
		<figure id="ffb3" number="F-3">
		<title>Control Constructs for Function Flow Block Diagrams</title>			
		<img src="Vitech_fig_2.gif"/>		
		</figure>
	
	<p><b>F.3.2 Data Flow Diagram</b></p>		
	<p>The Data Flow Diagram (DFD), shown in 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb4"> F-4</module_ref>, 
	shows required data flow between the functions of
	a system (DeMarco 1979). This representation has been widely used by software engineers and serves
	as the basis of many software engineering methodologies and automated tools. The figure shows that
	data repositories, external sources, and external sinks can also be represented by DFDs. However,
	DFDs do not show any control constructs for function sequencing or enablement.</p>
	
		<figure id="ffb4" number="F-4">
		<title>Sample Data Flow Diagram</title>			
		<img src="Vitech_fig_3.gif"/>	
		</figure>
	
	<p><b>F.3.3 N-Squared (N2) Chart</b></p>		
	<p>The N-Squared (N2) Chart, shown in 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb5"> F-5</module_ref>, 
	was developed to show and specify interfaces
	between the elements of a system (Long et al. 1968, Lano 1977). 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb5"> F-5</module_ref>
	is the N2 Chart that
	corresponds to the Enhanced FFBD in 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb7"> F-7</module_ref>.
	When used to show the interfaces between the
	functions in a system, the N2 chart is equivalent to a DFD - it contains all the information and
	differs only in format. The N2 chart is commonly used as a complement to the FFBD to provide the
	data flow information as inputs and outputs of the system functions.</p>

		<figure id="ffb5" number="F-5">
		<title>Sample N-squared (N2) Chart</title>
		<img src="Vitech_fig_4.gif"/>		
		</figure>
	
	<p>The N2 Chart is structured by locating the functions on the diagonal, resulting in an N squared matrix
	for a set of N functions. For a given function, all outputs are located in the row of that function
	and all inputs are in the column of the function. If the functions are placed on the diagonal in
	the nominal order of execution, then data items located above the diagonal represent normal flowdown
	of data. Data items below the diagonal represent data item feedback. External inputs can optionally
	be shown in the row above the first function on the diagonal, and external outputs can be shown in 
	the right-hand column. If desired, data repositories can be represented by placing them on the diagonal
	with the functions.</p>	
	
	<p><b>F.3.4 IDEF0 Diagram</b></p>	
	<p>The IDEF0 Diagram (see 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb6"> F-6</module_ref>)
	appears to be a derivative of the DFD with a format like the
	N2 Chart (Groveston, 1989 and FIPS-183, 1993). The primary content of the IDEF0 Diagram is the
	specification of data flow between system functions. An IDEF0 diagram is often supported by an
	IDEF1 or IDEF1x diagram indicating data keys with the objective of preserving referential integrity.
	The IDEF0 diagram does allow the specification of control as an input to a function but does not have
	the capability to characterize that control in terms of constructs, as the FFBD, EFFBD, and behaviour
	Diagrams do. The specification of control with the IDEF0 notation is incomplete and, therefore, not
	executable. The IDEF0 Diagram also represents the mechanism (usually the component to which the
	function is allocated) which performs the function. 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb6"> F-6</module_ref> 
	is the IDEF0 Diagram that corresponds 
	to the EFFBD in 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb7"> F-7</module_ref>.</p>
	
		<figure id="ffb6" number="F-6">
		<title>Sample IDEF0 Diagram</title>
		<img src="Vitech_fig_5.gif"/>		
		</figure>
	
	<p><b>F.3.5 Enhanced FFBD</b></p>	
	<p>The EFFBD displays the control dimension of the functional model in an FFBD format with a data
	flow overlay to effectively capture data dependencies. Thus, the Enhanced FFBD represents:
	(1) functions, (2) control flows, and (3) data flows. The logic constructs allow you to indicate
	the control structure and sequencing relationships of all functions accomplished by the system being
	analyzed and specified. When displaying the data flow as an overlay on the control flow, the EFFBD
	graphically distinguishes between triggering and non-triggering data inputs. Triggering data is 
	required before a function can begin execution. Therefore, triggers are actually data items with
	control implications. 
	In Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb7"> F-7</module_ref>, 
	triggers are shown with green backgrounds and with the
	double-headed arrows. Non-triggering data inputs are shown with gray backgrounds and with
	single-headed arrows.</p>		
	
		<figure id="ffb7" number="F-7">
		<title>Sample Enhanced FFBD</title>
		<img src="Vitech_fig_8.gif"/>		
		</figure>
	
	<p>The Enhanced FFBD specification of a system is complete enough that it is executable as a
	discrete event model, providing the capability of dynamic, as well as static, validation. A 
	fundamental rule in the interpretation of an EFFBD specification is that a function must be 
	enabled (by completion of the function(s) preceding it in the control construct) and triggered
	(if any data input to it is identified as a trigger) before it can execute. This allows the
	engineer maximum freedom to use either control constructs or data triggers (or a combination
	of both) to specify execution conditions for individual system functions. By augmenting the EFFBD
	with function duration estimates/budgets and resource constraints and utilization, trade studies 
	can be done using dynamic simulation outputs. 
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb8"> F-8</module_ref> 
	shows the output of such a simulation.
	This figure shows timelines for a resource (MIPS). It also shows timelines for the integrated
	system functions, indicating the delays in function execution due to waiting for triggers and
	resources (MIPS). This dynamic view is also capable of showing the status of the queuing of 
	triggering data.</p>

		<figure id="ffb8" number="F-8">
		<title>Dynamic Timeline</title>
		<img src="Vitech_fig_9.png"/>		
		</figure>
		
	<p><b>F.3.6 Behaviour Diagram (BD)</b></p>	
	<p>The behaviour Diagram (BD) 
	(Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb9"> F-9</module_ref>) 
	is a graphical representation equivalent to the
	Enhanced FFBD 
	(Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb7"> F-7</module_ref>). 
	The primary difference is in the orientation of the control flow:
	in the EFFBD, control sequencing is from left to right; in the BD, control sequencing is
	from top to bottom. While it is not shown on the graphical construct, the BD model allows
	data inputs to a function to be characterized as either triggering (a control capability)
	or data update (not a control implementation).</p>		

		<figure id="ffb9" number="F-9">
		<title>Sample Behaviour Diagram</title>
		<img src="Vitech_fig_10.gif"/>		
		</figure>

		<p>As with the Enhanced FFBD, the behaviour Diagram specification of a system is sufficient
	to form an executable model allowing dynamic validation via discrete event simulation methods.</p>
	
	
	<p><b>F.4 Relationships between the diagrams</b></p>

	<p>From the descriptions of the graphic representations, it is seen that the FFBD
	characterizes only the functional control model and the DFD characterizes only the
	functional data model for a system. The Enhanced FFBD and behaviour Diagram capture both
	these limiting models and the continuum between them.  
	Figure <module_ref linkend="function_based_behaviour:f_usage_guide:figure:ffb10"> F-10</module_ref> 
	shows where all these
	graphical representations fit on the behaviour spectrum and, therefore, places them in
	perspective relative to each other in the sense of specifying control and triggering
	for functions.</p>	
	
		<figure id="ffb10" number="F-10">
		<title>Relationships of All Graphical Representations - FFBD and DFDs Are Limiting Cases</title>
		<img src="Vitech_fig_12.png"/>		
		</figure>
	
	<p><b>F.5 Conclusions</b></p>	
	
	<p>The graphical representations that systems engineers commonly use to describe and
	specify the functionality and data requirements of a system are very closely related
	when analyzed in the context of data and functional control capabilities. In particular,
	the FFBD and DFD are limiting cases of the EFFBD/behaviour Diagram representation
	The N2 Chart is equivalent to the DFD: so it is, likewise, a limiting case of the EFFBD/BD
	on the data modeling end of the spectrum. The IDEF0 is essentially a DFD, except that some
	control capability (no control constructs) is added. The IDEF0 also allows the explicit
	representation of functional allocation (i.e., what system component performs each function).</p>
     </usage_guide>
     
     
	<bibliography>

		<bibitem id="fabrycky" published="y">
		<pubdate>1998</pubdate>
		<stdtitle> Systems Engineering and Analysis</stdtitle> 
		<subtitle>Benjamin S. Blanchard and Wolter J. Fabrycky</subtitle> 
		</bibitem>

		<bibitem id="DSMC" published="y">
		<pubdate>1989</pubdate>
		<stdtitle> Systems Engineering Management Guide</stdtitle> 
		<subtitle>Defense Systems Management College, U.S. Government Printing Office</subtitle> 
		</bibitem>

		<bibitem id="DeMarco" published="y">
		<pubdate>1979</pubdate>
		<stdtitle> Structured Analysis and System Specification</stdtitle> 
		<subtitle>Prentice Hall </subtitle> 
		</bibitem>

		<bibitem id="FIPS" published="y">
		<pubdate>1993</pubdate>
		<stdtitle> Draft Federal Information Processing Standards Publication</stdtitle> 
		<subtitle>FIPS-183 NIST </subtitle> 
		</bibitem>

		<bibitem published="y">
		<pubdate>2002</pubdate>
		<stdtitle> Relationships between Common Graphical Representations in Systems Engineering</stdtitle> 
		<subtitle>Jim Long, ViTech Corporation  http://www.vitechcorp.com/library/papers.php</subtitle> 
		</bibitem>

		<bibitem published="y">
		<pubdate>2008</pubdate>
		<stdtitle> OMG System Modeling Language</stdtitle> 
		<subtitle>http://www.omgsysml.org/</subtitle> 
		</bibitem>

		<bibitem published="n">
		<pubdate>2009</pubdate>
		<orgname>ISO-Wg12</orgname>
		<stdtitle> Rules for extensions to Extensible select types and defining their mapping specification</stdtitle> 
		<subtitle>Allison Barnard-Feeney and David Price</subtitle> 
		<stdnumber>ISO TC184/WG12 N#### - Draft needs more work, due early </stdnumber>          
		</bibitem>

</bibliography>


</module>
