<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: module.xml,v 1.15 2007/08/31 21:32:29 abhpf Exp $ -->
<!DOCTYPE module SYSTEM "../../../dtd/module.dtd">
<!-- Generated by mkmodule.js, Eurostep Limited, http://www.eurostep.com -->
 <!-- 
     To view the module in IExplorer, open: sys/1_scope.xml
      -->
<module
   name="function_based_behaviour"
   part="1453"
   version="1"
   sc4.working_group="3"
   wg.number="2286"
   wg.number.arm="2287"
   wg.number.mim="2288"
   wg.number.arm_lf="2289"
   wg.number.mim_lf="2290"
   checklist.internal_review="2356"
   checklist.project_leader="2357"
   checklist.convener="2355"
   status="CD-TS"
   language="E"
   publication.year=""
   publication.date=""
   published="n"
   rcs.date="$Date: 2007/08/31 21:32:29 $"
   rcs.revision="$Revision: 1.15 $"
   development.folder="dvlp">

 <keywords>
    module, systems engineering, system behaviour, function based behaviour
 </keywords>

<!-- the abstract for the module. If not provided, the XSL will use the in scope -->

 <!-- Reference to contacts detailed in stepmod/data/basic/contacts.xml -->
 <contacts>
  <projlead ref="ap233.projlead2"/> 
   <editor ref="ap233.editor2"/>
 </contacts>

 <!-- Introduction -->
 <!-- The introduction should start as shown: -->
 <purpose>
   <p>
     This part of ISO 10303 specifies an application module for the representation 
     of the generic elements of the function based behaviour modeling paradigms used 
     for response to excitation analysis.
   </p>
   
   <p>
    One of the essential characteristics of systems that require modeling 
    is the response of the system to excitation. Function based behaviour 
    provides a model for response to excitation that is executable in tools to 
    provide a time line for that response and to record logical errors in the 
    model that prevent execution. 
   </p>
   
   <p>This module provides links to the generic modeling elements required to view 
   and model system behaviour from the perspective for "function".  This view does 
   not use the concept of "state."
   </p>
 </purpose>

 <!-- Items in scope -->
 <inscope>
   <li>provides the identification of a behaviour;</li>
   <li>provides a hierarchy of behaviours;</li>
   <li>provides a function based representation of behaviour;</li>
   <li>provides a hierarchy of functions within a function based behaviour representation;</li>
   <li>provides a means of representing the inputs and outputs of a function, including triggering mechanisms where appropriate;</li>
   <li>provides for the ordering of functions, and identifying decision points;</li>
   <li>supports identification of shared resources used by function;</li>
   <li>supports shared resource properties.</li>
 </inscope>

 <!-- Items out of scope -->
 <outscope>
   <li>Scheduling.</li>
 </outscope>

<!--
 <normrefs/>

 <definition/>

 <abbreviations/>
-->

 <!-- Clause 4 ARM  -->
 <arm>
   <!-- Note ARM short form EXPRESS is in arm.xml -->

   <!-- Short form EXPRESS-G -->
   <express-g>
     <imgfile file="armexpg1.xml"/>
 <!--      <imgfile file="armexpg2.xml"/>
     <imgfile file="armexpg3.xml"/>
     <imgfile file="armexpg4.xml"/>
     <imgfile file="armexpg5.xml"/>
     <imgfile file="armexpg6.xml"/>  -->
   </express-g>
 </arm>

<!-- ARM long form (optional) -->
 <!-- If not required, delete this section and the following files:
          arm_lf.xml
          armexpg_lf1.gif
          armexpg_lf1.xml -->
 <arm_lf>
   <!-- Note ARM long form EXPRESS is in arm_lf.xml -->
   <express-g>
     <imgfile file="armexpg_lf1.xml"/>
   </express-g>
 </arm_lf>

 <!-- Clause 5.1 Mapping specification
 <mapping_table>
   <ae entity="xx"/>
 </mapping_table> -->

 <!-- Clause 5.2 MIM -->
 <mim>
   <!--  Note MIM short form express is in mim.xml -->
   <express-g>
     <imgfile file="mimexpg1.xml"/>
   </express-g>
    <shortnames>   
    <shortname name="FCAM" entity="fbb_characterized_action_method"/>
    <shortname name="FCPD" entity="fbb_characterized_property_definition"/>
    <shortname name="FCAAMA" entity="fbb_characterized_applied_action_method_assignment"/>
    <shortname name="FCGE" entity="fbb_characterized_generic_expression"/>
    <shortname name="FCGP" entity="fbb_characterized_general_property"/>
    <shortname name="FCGPR" entity="fbb_characterized_general_property_relationship"/>
    <shortname name="FBCHRPR" entity="fbb_characterized_product"/>
    <shortname name="FCPC" entity="fbb_characterized_product_category"/>
    <shortname name="FCPDF" entity="fbb_characterized_product_definition_formation"/>
    <shortname name="FCPDFR" entity="fbb_characterized_product_definition_formation_relationship"/>
    <shortname name="FCPDR" entity="fbb_characterized_property_definition_representation"/>
    <shortname name="FBCHRP" entity="fbb_characterized_representation"/>
    <shortname name="FCRC" entity="fbb_characterized_representation_context"/>
    <shortname name="FCRI" entity="fbb_characterized_representation_item"/>
  </shortnames>   
 </mim>

 <!-- MIM long form (optional) -->
 <!-- If not required, delete this section and the following files:
          mim_lf.xml
          mimexpg_lf1.gif
          mimexpg_lf1.xml -->
 <mim_lf>
   <!-- Note MIM long form EXPRESS is in mim_lf.xml -->
   <express-g>
     <imgfile file="mimexpg_lf1.xml"/>
   </express-g>
 </mim_lf>

   <usage_guide>
   
   	<p>Function Based Behavior clearly depicts Functions and their I/O. It is hierarchical. Ordering 
	of the functions is provided by ordering operations. Functions with their I/O correspond to classic 
	systems engineering N-Squared Charts and related to (but not identical with) data flow diagrams. They 
	provide a functional data model. Functions with their ordering correspond to the Functional Flow 
	Block Diagrams, developed in the 1950’s by TRW for the Army ballistic missile program. They modeled 
	functional control. In the 1970’s, when Jim Long added I/O to the FFBD’s, these executable diagrams 
	began to be used in systems engineering to capture response to excitation and to generate time lines. 
	They have been called Behavior Diagrams and Extended Functional Flow block diagrams, EFFBD’s. 
	During 2006 the SysML program has generated a standard for the SysML Program that provides for 
	equivalent capability with diagrams called Activity Diagrams; reference - [Bock, C, SysML and UML Support for 
	Modeling, Journal of Systems Engineering, Vol 9, 2, pp 160-186, 2006, also Wiley InterScience 
	(www.interscience.wiley.com)].  These are extensions to UML 2.0 because it does not fully incorporate 
	this capability.</p>
	
	<p>It is possible to define a unifying view for all of these graphical presentation.
	This is capsulated both in AP233 Concept Model and in Jim Long's white paper</p>

	<p><b>AP233 concept model</b></p>
	
   	<p>Function Based Behavior can be defined as a representation of what a system is to do 
	based on descriptions of the transformations it performs. What a thing does can be 
	described by citing a set of significant transformations it performs. In science and 
	all changes can be represented by transformations that follow well known transformation 
	laws like conservation of matter and energy.</p>
	
	<p>Function is a transformation that consumes engineering_things and generates or transforms 
	them into other engineering things. I/O is the output from one Function and the input to another Function.
	In all of the mathematical laws of science engineering things are transformed into other 
	engineering things. </p>

	<p>In the physical world nothing is created, destroyed or deleted. There is only transformation.
	Function embodies this concept and is the representation and basis for change in the physical world.</p>
	
	<figure>
	<title>SE Handbook Chapter 33 Figure 7</title>
	<img src="SEHandBk7.gif"/>		</figure>
	
	<p>The figure above and definitions below provide the relationships for Function, I/O and Odering 
	that are essential to the function based behaviour representation problem.</p>
	
	<p>An engineering thing is that for which observable, measurable, and reproducible properties or 
	attributes can be obtained.</p>
	
	<p>Function is a transformation that consumes one set of engineering things and generates or 
	transforms them into another set of engineering things.</p>
	
	<p>I/O is the output from one Function and an input to another Function</p>
	
	<p>Time_interval is a period of time during which a Function produces its I/O. In some disciplines 
	the transitions are found to be fast enough that they can be considered to be instantaneous. 
	Transformation of inputs into outputs takes a finite amount of time. The Time_intervals can be 
	assigned to a complex set of functions and then the time line for the behavior can be calculated 
	from the model. In this manner an overall required time response can be calculated from a 
	design behavior model. That prediction can then be verified by measurement when the system is built. </p>
	
	<p>Function_ordering is an operator that arranges functions as they are to be 
	executed in practice. Functions may occur in sequence or concurrently. It is possible to execute a 
	function repeatedly. These relationships are captured by a set of ordering operations and a set of 
	execution rules for the model.</p>
	
	<p>Script is a set of language elements associated with a Function that define how that Function 
	acts on inputs to generate outputs. By embedding language elements in a Function, the Function 
	can carry out transformation and decision processes on inputs that it receives.</p>
	
	<p>Sequence is an ordering operator that establishes sequence among Functions. In some cases a 
	behavior requires a particular sequence of Functions to get a particular result. </p>
	
	<p>And is an ordering operator that establishes concurrency among functions. Some Functions must 
	be done at the same time to be effective; they must be concurrent.</p>
	
	<p>Or is an ordering operator that establishes alternative paths among a group of  Functions. In 
	many systems there are multiple choices in its behavior. These choices are represented by 
	multiple paths or threads through the behavior. </p>
	
	<p>Multi_exit_function is a Function that acts as an ordering operator that provides multiple 
	exits to alternative paths. One way of representing alternative paths is to use a Function that 
	has multiple exits and internal rules for the choices.</p>
	
	<p>Loop is an  ordering operator that repeats a Functions or group of Functions some number of times.
	Often the same transformation is repeated for some number of times.</p>
	
	<p>Loop_limit is the number or expression for the number of repetitions in a Loop. It is inefficient 
	use of resource to allow a loop to run without a limit to stop it.</p>
	
	<p>Loop_exit is the ordering operation that terminates a loop and provides correct continuation of 
	the execution path. Often when a loop ends there is a transition to an entry point in the behavior.</p>
	
	<p>Iterate is an ordering operator that repeats a Function or group of Functions. It is possible for 
	the termination of a repeated transformation not to be based on a number. It may be based on a 
	condition or a set of conditions.</p>
	
	<p>Iterate_limit is an ordering operation that establishes the set over which the iteration is 
	to be performed. In the games of checkers and chess there is no set number of moves that are made. 
	Rather the game proceeds by a set rules until a final rule or condition is met.</p>

	<p><b>Background</b></p> 

	<p>The following text has been copied (with permission) from Jim Long's White Paper "Relationships
	between Common Graphical Representations in System Engineering".This work is harmonized with
	both the AP233 Concept Model and the EXPRESS model defined within the Function Based behaviour
 	module set. The full/original white paper can be downloaded at:
	<a href="http://www.vitechcorp.com/infocenter/papers/CommonGraphicalRepresentations_2002.pdf"/>	</p>				

	<p>Over the past several years, systems engineers have
	evolved to a few graphical representations to present the functional and data flow
	characteristics of their system design. The most common of these are the Function Flow
 	Block Diagram (FFBD),Data Flow Diagram (DFD), N2 (N-Squared) Chart, IDEF0 Diagram,
 	Use Case, Sequence Diagram, Enhanced Function Flow Block Diagram, and behaviour Diagram (BD).
	Most of these graphical representations allow the engineer to decompose the functional
	and/or data models hierarchically.</p> 		

	<p>The objective of AP233's Function based behaviour capability is to provide a data model that 
	can be used as a neutral format for 	all of the graphical representations defined herein.  
	This data model is "complete", relative 	to the function based behaviour representation 
	needs of systems engineering. </p>		
	
	<p><b>Terminology</b></p>	
	<p>Let us introduce two terms that we use in describing the conditions that allow/cause a
	function to begin execution. Considering the control and data environment, a function can
	begin execution if it is both enabled (by control) and triggered (by data). In the case where
	there is no data trigger specified, a function begins execution upon being enabled. A
	function is enabled if the function(s) that precede it in the control flow specification
	have completed execution (e.g., satisfied their completion criteria). A function is triggered
	when the required stimulus data item becomes available to the function. We are not concerned
	here with other execution requirements (such as the availability of necessary resources, except
	in the case of the Dynamic Timeline Diagrams) that could be represented by either control or
	data structures as necessary.</p>		
	
	<p><b>Function Flow Block Diagram</b></p>	
	<p>The Function Flow Block Diagram (FFBD) was the first to be favored by systems engineers and
	continues to be widely used today (DSMC 1989, Blanchard and Fabrycky 1990 book "Systems 
	Engineering and Analysis"). Figure 1 shows a sample FFBD. An FFBD shows the functions that a 
	system is to perform and the order in which they are to be enabled (and performed). The order 
	of performance is specified from the set of available control constructs shown in Figure 2. The 
	control enablement of the first function is shown by the reference node(s) which precede it, 
	and the reference node(s) at the end of the function logic indicate what functions are enabled next. 
	The FFBD also shows completion criterion for functions as needed for specification (for example, 
	the exits for the multi-exit function in Figure 1). The FFBD does not contain any information relating 
	to the flow of data between functions, and therefore does not represent any data triggering of 
	functions. The FFBD only presents the control sequencing for the functions.</p>		
	
	<note>It may be desirable to create a list of the different graphical representations identified
	within the module <express_ref linkend="function_based_behaviour:arm:Function_based_behaviour_arm"/>.	
	The contents required for each could then be precisely defined and each could be versioned separately.	
	In application, users tend to use a single view for a while and then switch to another when a need 	
	to change views occurs.  One version number for all views seems to be undesirable.  	
	####  Issue - Discussion needed.	</note>	
	
	<figure><title>Jim Long white paper Figure 1</title>			
	<img src="Vitech_fig_1.gif"/>		</figure>
		<figure><title>Jim Long white paper Figure 2</title>			
		<img src="Vitech_fig_2.gif"/>		</figure>
	
	<p><b>Data Flow Diagram</b></p>		
	<p>The Data Flow Diagram (DFD), shown in Figure 3, shows required data flow between the functions of
	a system (DeMarco 1979). This representation has been widely used by software engineers and serves
	as the basis of many software engineering methodologies and automated tools. The figure shows that
	data repositories, external sources, and external sinks can also be represented by DFDs. However,
	DFDs do not show any control constructs for function sequencing or enablement.</p>
	
	<figure><title>Jim Long white paper Figure 3</title>			
	<img src="Vitech_fig_3.gif"/>		</figure>
	
	<p><b>N-Squared (N2) Chart</b></p>		
	<p>The N-Squared (N2) Chart, shown in Figure 4, was developed to show and specify interfaces
	between the elements of a system (Long et al. 1968, Lano 1977). Figure 4 is the N2 Chart that
	corresponds to the Enhanced FFBD in Figure 8. When used to show the interfaces between the
	functions in a system, the N2 chart is equivalent to a DFD - it contains all the information and
	differs only in format. The N2 chart is commonly used as a complement to the FFBD to provide the
	data flow information as inputs and outputs of the system functions.</p>
	<p>The N2 Chart is structured by locating the functions on the diagonal, resulting in an N squared matrix
	for a set of N functions. For a given function, all outputs are located in the row of that function
	and all inputs are in the column of the function. If the functions are placed on the diagonal in
	the nominal order of execution, then data items located above the diagonal represent normal flowdown
	of data. Data items below the diagonal represent data item feedback. External inputs can optionally
	be shown in the row above the first function on the diagonal, and external outputs can be shown in 
	the right-hand column. If desired, data repositories can be represented by placing them on the diagonal
	with the functions.</p>	
	
	<figure><title>Jim Long white paper Figure 4</title>
	<img src="Vitech_fig_4.gif"/>		</figure>
	
	<p><b>IDEF0 Diagram</b></p>	
	<p>The IDEF0 Diagram (see Figure 5) appears to be a derivative of the DFD with a format like the
	N2 Chart (Groveston, 1989 and FIPS-183, 1993). The primary content of the IDEF0 Diagram is the
	specification of data flow between system functions. An IDEF0 diagram is often supported by an
	IDEF1 or IDEF1x diagram indicating data keys with the objective of preserving referential integrity.
	The IDEF0 diagram does allow the specification of control as an input to a function but does not have
	the capability to characterize that control in terms of constructs, as the FFBD, EFFBD, and behaviour
	Diagrams do. The specification of control with the IDEF0 notation is incomplete and, therefore, not
	executable. The IDEF0 Diagram also represents the mechanism (usually the component to which the
	function is allocated) which performs the function. Figure 5 is the IDEF0 Diagram that corresponds 
	to the EFFBD in Figure 8.</p>
	
	<figure><title>Jim Long white paper Figure 5</title>
	<img src="Vitech_fig_5.gif"/>		</figure>
	
	<p><b>Enhanced FFBD</b></p>	
	<p>The EFFBD displays the control dimension of the functional model in an FFBD format with a data
	flow overlay to effectively capture data dependencies. Thus, the Enhanced FFBD represents:
	(1) functions, (2) control flows, and (3) data flows. The logic constructs allow you to indicate
	the control structure and sequencing relationships of all functions accomplished by the system being
	analyzed and specified. When displaying the data flow as an overlay on the control flow, the EFFBD
	graphically distinguishes between triggering and non-triggering data inputs. Triggering data is 
	required before a function can begin execution. Therefore, triggers are actually data items with
	control implications. In Figure 8, triggers are shown with green backgrounds and with the
	double-headed arrows. Non-triggering data inputs are shown with gray backgrounds and with
	single-headed arrows.</p>		
	
	<p>The Enhanced FFBD specification of a system is complete enough that it is executable as a
	discrete event model, providing the capability of dynamic, as well as static, validation. A 
	fundamental rule in the interpretation of an EFFBD specification is that a function must be 
	enabled (by completion of the function(s) preceding it in the control construct) and triggered
	(if any data input to it is identified as a trigger) before it can execute. This allows the
	engineer maximum freedom to use either control constructs or data triggers (or a combination
	of both) to specify execution conditions for individual system functions. By augmenting the EFFBD
	with function duration estimates/budgets and resource constraints and utilization, trade studies 
	can be done using dynamic simulation outputs. Figure 9 shows the output of such a simulation.
	This figure shows timelines for a resource (MIPS). It also shows timelines for the integrated
	system functions, indicating the delays in function execution due to waiting for triggers and
	resources (MIPS). This dynamic view is also capable of showing the status of the queuing of 
	triggering data.</p>
	
	<figure><title>Jim Long white paper Figure 8</title>
	<img src="Vitech_fig_8.gif"/>		</figure>
	
	<p><b>Behaviour Diagram (BD)</b></p>	
	<p>The behaviour Diagram (BD) (Figure 10) is a graphical representation equivalent to the
	Enhanced FFBD (Figure 8). The primary difference is in the orientation of the control flow:
	in the EFFBD, control sequencing is from left to right; in the BD, control sequencing is
	from top to bottom. While it is not shown on the graphical construct, the BD model allows
	data inputs to a function to be characterized as either triggering (a control capability)
	or data update (not a control implementation).</p>		
	<p>As with the Enhanced FFBD, the behaviour Diagram specification of a system is sufficient
	to form an executable model allowing dynamic validation via discrete event simulation methods.</p>
	
	<figure><title>Jim Long white paper Figure 9</title>
	<img src="Vitech_fig_9.gif"/>		</figure>
	
	<figure><title>Jim Long white paper Figure 10</title>
	<img src="Vitech_fig_10.gif"/>		</figure>
	
	<p><b>Relationships between the diagrams</b></p>

	<p>From the descriptions of the graphic representations, it is seen that the FFBD
	characterizes only the functional control model and the DFD characterizes only the
	functional data model for a system. The Enhanced FFBD and behaviour Diagram capture both
	these limiting models and the continuum between them.  Figure 12 shows where all these
	graphical representations fit on the behaviour spectrum and, therefore, places them in
	perspective relative to each other in the sense of specifying control and triggering
	for functions.</p>	
	
	<figure><title>Jim Long white paper Figure 12</title>
	<img src="Vitech_fig_12.gif"/>		</figure>
	
	<p><b>Conclusions</b></p>	
	
	<p>The graphical representations that systems engineers commonly use to describe and
	specify the functionality and data requirements of a system are very closely related
	when analyzed in the context of data and functional control capabilities. In particular,
	the FFBD and DFD are limiting cases of the EFFBD/behaviour Diagram representation
	. 	The N2 Chart is equivalent to the DFD: so it is, likewise, a limiting case of the EFFBD/BD
	on the data modeling end of the spectrum. The IDEF0 is essentially a DFD, except that some
	control capability (no control constructs) is added. The IDEF0 also allows the explicit
	representation of functional allocation (i.e., what system component performs each function).</p>
	
	<note>Permission to reproduce copyrighted material (above) has been obtained:  Harold:  
	As long as the work is 	properly referred, you have my permission to cut and paste material
	from my paper Common Graphical 	Representations in Systems Engineering for use in the ISO 
	documentation that you are preparing.	Best regards, Jim Long, Vitech Corporation.  Date: 
	Mon, 25 Apr 2005.</note>	
     </usage_guide>
</module>
