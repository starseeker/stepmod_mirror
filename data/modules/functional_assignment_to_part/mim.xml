<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-02-11T13:32:42" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="functional_assignment_to_part_mim schema_instance"/>
   <schema name="Functional_assignment_to_part_mim">
      <interface kind="use" schema="Network_functional_usage_view_mim"/>
      <interface kind="use" schema="Physical_unit_usage_view_mim"/>
      <entity name="part_connected_terminals_definition" supertypes="shape_aspect">
         <unique label="UR1">
            <unique.attribute entity-ref="part_connected_terminals_definition" attribute="name"/>
         </unique>
         <where label="WR1" expression="SIZEOF (QUERY (mct &lt;* QUERY (sar &lt;* USEDIN (SELF,&#10;       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |&#10;       sar\shape_aspect_relationship.name = 'member connected terminal') |&#10;       SIZEOF (['FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'ASSEMBLY_MODULE_TERMINAL',&#10;       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'BARE_DIE_TERMINAL',&#10;       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'INTERCONNECT_MODULE_TERMINAL',&#10;       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'PACKAGE_TERMINAL',&#10;       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +&#10;       'PACKAGED_PART_TERMINAL'] *&#10;       TYPEOF (mct.related_shape_aspect)) = 1)) &gt;= 2"/>
      </entity>
      <rule name="functional_usage_view_to_part_terminal_assignment_constraint" appliesto="shape_aspect_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(sar &lt;* shape_aspect_relationship |&#10;       (sar\shape_aspect_relationship.name = 'functional terminal allocation')&#10;       AND NOT(('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'&#10;       + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN&#10;       TYPEOF(sar.relating_shape_aspect)) AND&#10;       (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')&#10;       ))) = 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(sar &lt;* shape_aspect_relationship |&#10;       (sar\shape_aspect_relationship.name = 'functional terminal allocation')&#10;       AND NOT(('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'&#10;       + 'ASSEMBLY_MODULE_TERMINAL' IN&#10;       TYPEOF(sar.related_shape_aspect)) OR&#10;       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'&#10;       + 'BARE_DIE_TERMINAL' IN&#10;       TYPEOF(sar.related_shape_aspect)) OR&#10;       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'&#10;       + 'INTERCONNECT_MODULE_TERMINAL' IN&#10;       TYPEOF(sar.related_shape_aspect)) OR&#10;       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'&#10;       + 'PACKAGED_PART_TERMINAL' IN&#10;       TYPEOF(sar.related_shape_aspect))&#10;       ))) = 0"/>
      </rule>
      <rule name="functional_usage_view_to_part_terminal_assignment_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm>LOCAL
  fuvtpta : BAG OF shape_aspect_relationship := 
QUERY( r &lt;* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'functional terminal allocation'));
  futd_bag : BAG OF functional_unit_terminal_definition := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fuvtpta) by 1;
  IF EXISTS( fuvtpta[i].relating_shape_aspect ) THEN
    IF ( fuvtpta[i].relating_shape_aspect\shape_aspect.description = 
                                             'scalar terminal' ) THEN
      IF ( NOT ( fuvtpta[i].relating_shape_aspect IN futd_bag ) ) THEN
        futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(futd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar &lt;* fuvtpta | 
        ((sar.relating_shape_aspect :=: futd_bag[i]) AND
(SIZEOF(['FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'ASSEMBLY_MODULE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'BARE_DIE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'INTERCONNECT_MODULE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'PACKAGED_PART_TERMINAL'] * TYPEOF(sar.related_shape_aspect))&gt;0)) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;</algorithm>
         <where label="WR1" expression="pass"/>
      </rule>
   </schema>
</express>
