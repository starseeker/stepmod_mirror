(*
 $Id: mim_lf.exp,v 1.1 2003/12/08 16:58:24 robbod Exp $
 ISO TC184/SC4/WG12 N1219 - ISO/CD-TS 10303-1151 Functional data - EXPRESS MIM Long form
*) 


(* ===================================================================================== *)
(* Long form schema generated by The EXPRESS Data Manager  compiler version 9.5B3        *)
(* Fri Dec 12 15:01:39 2003                                                              *)
(* The schema is converted from ISO10303 P11-2003 to ISO10303 P11-1994                   *)
(* ===================================================================================== *)

SCHEMA Functional_data_mim_lf;


CONSTANT
  schema_prefix : STRING := 'FUNCTIONAL_DATA_MIM_LF.';

  the_empty_space : finite_space := make_finite_space([]);

END_CONSTANT;

TYPE action_items = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_person,
   class_of_product,
   composition_of_individual_activity,
   composition_of_individual_product,
   connection_of_individual_activity,
   connection_of_individual_product,
   containment_of_individual_product,
   individual_activity,
   individual_involvement_in_activity,
   involvement_of_individual_product_in_connection,
   organization,
   organization_type,
   person,
   person_and_organization,
   possession_of_property_by_activity,
   possession_of_property_by_product,
   product_as_individual,
   property_condition_for_activity,
   property_condition_for_product);
END_TYPE;


TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE area_measure = REAL;
END_TYPE;

TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;

TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;

TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE characterized_action_definition = SELECT (
   action,
   action_method,
   action_relationship);
END_TYPE;


(* Zapped by David Leal *)
TYPE characterized_definition = SELECT (
   characterized_product_definition);
END_TYPE; 

TYPE characterized_product_definition = SELECT (
   product_definition);
END_TYPE; 


(* Pruned unused type: class_of_activity_relationship  *)


(* Pruned unused type: class_of_product_relationship  *)


TYPE classification_select = SELECT (
   composition_of_individual_activity,
   composition_of_individual_product,
   connection_of_individual_activity,
   connection_of_individual_product,
   containment_of_individual_product,
   individual_activity,
   individual_involvement_in_activity,
   involvement_of_individual_product_in_connection,
   product_as_individual);
END_TYPE;


(* Pruned unused type: complete_membership_individual_activity_or_activity_relationship  *)


(* Pruned unused type: complete_membership_individual_product_or_product_relationship  *)


TYPE complete_membership_select = SELECT (
   composition_of_individual_activity,
   composition_of_individual_product,
   connection_of_individual_activity,
   connection_of_individual_product,
   containment_of_individual_product,
   individual_activity,
   individual_involvement_in_activity,
   involvement_of_individual_product_in_connection,
   product_as_individual);
END_TYPE;


TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE count_measure = NUMBER;
END_TYPE;

TYPE derived_property_select = SELECT (
   action_property,
   property_definition);
END_TYPE;


TYPE description_attribute_select = SELECT (
   application_context,
   external_source,
   person_and_organization,
   property_definition_representation,
   representation);
END_TYPE;


TYPE descriptive_measure = STRING;
END_TYPE;

TYPE electric_current_measure = REAL;
END_TYPE;

TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;

TYPE external_identification_item = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_product);
END_TYPE;


(* Pruned unused type: externally_identified_class_of_activity_or_relationship  *)


(* Pruned unused type: externally_identified_class_of_product_or_relationship  *)


TYPE founded_item_select = SELECT (
   representation_item);
END_TYPE;


(* Pruned unused type: functional_involved_class_select  *)


(* Pruned unused type: functional_involved_item_select  *)


TYPE id_attribute_select = SELECT (
   action,
   address,
   application_context,
   group,
   product_category,
   property_definition,
   representation);
END_TYPE;


TYPE identification_item = SELECT (
   product_as_individual);
END_TYPE;


TYPE identifier = STRING;
END_TYPE;

(* Pruned unused type: individual_activity_or_activity_relationship  *)


(* Pruned unused type: individual_product_or_product_relationship  *)


TYPE involved_class_select = action_items;
WHERE
  wr1 : NOT ('FUNCTIONAL_DATA_MIM.COMPOSITION_OF_INDIVIDUAL_ACTIVITY' IN TYPEOF(SELF));
  wr2 : NOT ('FUNCTIONAL_DATA_MIM.COMPOSITION_OF_INDIVIDUAL_PRODUCT' IN TYPEOF(SELF));
  wr3 : NOT ('FUNCTIONAL_DATA_MIM.CONNECTION_OF_INDIVIDUAL_ACTIVITY' IN TYPEOF(SELF));
  wr4 : NOT ('FUNCTIONAL_DATA_MIM.CONNECTION_OF_INDIVIDUAL_PRODUCT' IN TYPEOF(SELF));
  wr5 : NOT ('FUNCTIONAL_DATA_MIM.CONTAINMENT_OF_INDIVIDUAL_PRODUCT' IN TYPEOF(SELF));
  wr6 : NOT ('FUNCTIONAL_DATA_MIM.INDIVIDUAL_ACTIVITY' IN TYPEOF(SELF));
  wr7 : NOT ('FUNCTIONAL_DATA_MIM.INDIVIDUAL_INVOLVEMENT_IN_ACTIVITY' IN TYPEOF(SELF));
  wr8 : NOT ('FUNCTIONAL_DATA_MIM.INVOLVEMENT_OF_INDIVIDUAL_PRODUCT_IN_CONNECTION' IN TYPEOF(SELF));
  wr9 : NOT ('FUNCTIONAL_DATA_MIM.ORGANIZATION' IN TYPEOF(SELF));
  wr10 : NOT ('FUNCTIONAL_DATA_MIM.PERSON' IN TYPEOF(SELF));
  wr11 : NOT ('FUNCTIONAL_DATA_MIM.PERSON_AND_ORGANIZATION' IN TYPEOF(SELF));
  wr12 : NOT ('FUNCTIONAL_DATA_MIM.POSSESSION_OF_PROPERTY_BY_ACTIVITY' IN TYPEOF(SELF));
  wr13 : NOT ('FUNCTIONAL_DATA_MIM.POSSESSION_OF_PROPERTY_BY_PRODUCT' IN TYPEOF(SELF));
  wr14 : NOT ('FUNCTIONAL_DATA_MIM.PRODUCT_AS_INDIVIDUAL' IN TYPEOF(SELF));
END_TYPE;


TYPE involved_select = action_items;
END_TYPE;


TYPE label = STRING;
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;

TYPE maths_boolean = BOOLEAN;
END_TYPE;

TYPE maths_enum_atom = SELECT (
   elementary_space_enumerators,
   open_closed);
END_TYPE;


(* Pruned unused type: maths_expression  *)


TYPE maths_integer = INTEGER;
END_TYPE;

TYPE maths_real = REAL;
END_TYPE;

TYPE maths_simple_atom = SELECT (
   maths_real,
   maths_integer,
   maths_boolean);
END_TYPE;


(* Pruned unused type: maths_space_or_function  *)


TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;

TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE;

TYPE name_attribute_select = SELECT (
   address,
   derived_unit,
   person_and_organization,
   property_definition_representation);
END_TYPE;


TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;

TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;

TYPE organization_type_item = SELECT (
   organization);
END_TYPE;


TYPE parameter_value = REAL;
END_TYPE;

(* Pruned unused type: person_organization_select  *)


TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

(* Pruned unused type: product_as_individual_identification_item  *)


TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

(* Pruned unused type: real_interval  *)


TYPE relationship_select = space_context_select;
WHERE
  wr1 : NOT ('FUNCTIONAL_DATA_MIM.CLASS_OF_COMPOSITION_OF_PRODUCT' IN TYPEOF(SELF));
  wr2 : NOT ('FUNCTIONAL_DATA_MIM.CLASS_OF_CONNECTION_OF_PRODUCT' IN TYPEOF(SELF));
  wr3 : NOT ('FUNCTIONAL_DATA_MIM.CLASS_OF_CONTAINMENT_OF_PRODUCT' IN TYPEOF(SELF));
  wr4 : NOT ('FUNCTIONAL_DATA_MIM.CLASS_OF_INVOLVEMENT_OF_PRODUCT_IN_CONNECTION' IN TYPEOF(SELF));
END_TYPE;


TYPE represented_definition = SELECT (
   general_property,
   property_definition);
END_TYPE;


TYPE role_select = SELECT (
   action_assignment);
END_TYPE;


TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE;

TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE source_item = SELECT (
   identifier);
END_TYPE;


TYPE space_context_select = SELECT (
   action,
   action_method,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   general_property,
   representation_item);
END_TYPE;


(* Pruned unused type: supported_item  *)


TYPE text = STRING;
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_measure = REAL;
END_TYPE;

(* Pruned unused type: tuple_space  *)


TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE;

TYPE value_context_select = SELECT (
   action,
   action_method,
   general_property,
   representation_item);
END_TYPE;


(* Pruned unused type: versionable_item  *)


TYPE volume_measure = REAL;
END_TYPE;

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY application_context_element
  ;
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_select;
END_ENTITY;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

ENTITY applied_organization_type_assignment
  SUBTYPE OF (organization_type_assignment);
  items : SET[1:?] OF organization_type_item;
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY cardinality_of_related_class
  SUBTYPE OF (maths_space_context);
  SELF\maths_space_context.physical_space : relationship_select;
END_ENTITY;

ENTITY cardinality_of_relating_class
  SUBTYPE OF (maths_space_context);
  SELF\maths_space_context.physical_space : relationship_select;
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY class
  SUPERTYPE OF (ONEOF (
              CLASS_BY_EXTENSION,
              CLASS_BY_INTENSION))
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_of_activity
  SUBTYPE OF (executed_action, class);
END_ENTITY;

ENTITY class_of_composition_of_activity
  SUBTYPE OF (action_relationship, class);
  SELF\action_relationship.relating_action : class_of_activity;
  SELF\action_relationship.related_action : class_of_activity;
END_ENTITY;

ENTITY class_of_composition_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_connection_of_activity
  SUBTYPE OF (action_relationship, class);
  SELF\action_relationship.relating_action : class_of_activity;
  SELF\action_relationship.related_action : class_of_activity;
END_ENTITY;

ENTITY class_of_connection_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_connection_of_product_with_involvements
  SUBTYPE OF (class_of_connection_of_product, class_of_product);
END_ENTITY;

ENTITY class_of_containment_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_involvement_in_activity
  SUBTYPE OF (applied_action_assignment, class);
  SELF\action_assignment.assigned_action : class_of_activity;
  SELF\applied_action_assignment.items : SET[1:1] OF involved_class_select;
END_ENTITY;

ENTITY class_of_involvement_of_product_in_connection
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_connection_of_product_with_involvements;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_person
  SUBTYPE OF (person_type, class);
END_ENTITY;

ENTITY class_of_product
  SUBTYPE OF (product_definition_formation, class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (applied_classification_assignment);
  SELF\applied_classification_assignment.items : SET[1:1] OF classification_select;
DERIVE
  classified  : classification_select := SELF\applied_classification_assignment.items[1];
  classifier  : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY classification_assignment
   ABSTRACT SUPERTYPE OF (ONEOF (
                       APPLIED_CLASSIFICATION_ASSIGNMENT,
                       COMPLETE_MEMBERSHIP) ) ;
  assigned_class : group;
  role : classification_role;
END_ENTITY;

ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY complement;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  set_1       : class;
  set_2       : class;
  universe    : class;
WHERE
  complement_different : NOT identical_sets(set_1, set_2);
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
  members        : SET[0:?] OF complete_membership_select;
DERIVE
  containing_set : class :=
                         SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY composition_of_individual_activity
  SUBTYPE OF (action_relationship);
  SELF\action_relationship.relating_action : individual_activity;
  SELF\action_relationship.related_action : individual_activity;
END_ENTITY;

ENTITY composition_of_individual_product
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_individual;
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual;
END_ENTITY;

ENTITY compound_maths_space_context
  SUBTYPE OF (maths_space_context);
  components  :  LIST [2:?] OF maths_space_context;
END_ENTITY;

ENTITY condition_property
  SUBTYPE OF (general_property_association);
  SELF\general_property_association.base_definition : independent_property_definition;
WHERE
  link_to_condition: ('FUNCTIONAL_DATA_MIM_LF.PROPERTY_CONDITION_FOR_ACTIVITY' IN TYPEOF(SELF\general_property_association.derived_definition)) OR ('FUNCTIONAL_DATA_MIM_LF.PROPERTY_CONDITION_FOR_PRODUCT' IN TYPEOF(SELF\general_property_association.derived_definition));

END_ENTITY;

ENTITY connection_of_individual_activity
  SUBTYPE OF (action_relationship);
  SELF\action_relationship.relating_action : individual_activity;
  SELF\action_relationship.related_action : individual_activity;
END_ENTITY;

ENTITY connection_of_individual_product
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_individual;
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual;
END_ENTITY;

ENTITY connection_of_individual_product_with_involvements
  SUBTYPE OF (connection_of_individual_product, product_as_individual);
END_ENTITY;

ENTITY containment_of_individual_product
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_individual;
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual;
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY defined_maths_space_context
  SUBTYPE OF (maths_space_context);
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY explicitly_enumerated_maths_space_context
  SUBTYPE OF (maths_space_context);
  members  :  SET [1:?] OF maths_value_context;
END_ENTITY;

ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : product_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_source;
  source_id   : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' +

                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY;

ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;

ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;

ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'FUNCTIONAL_DATA_MIM_LF.GENERIC_EXPRESSION' IN TYPEOF (member))

       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'FUNCTIONAL_DATA_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;

  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_GENERIC_EXPRESSION,
                       UNARY_GENERIC_EXPRESSION,
                       BINARY_GENERIC_EXPRESSION,
                       MULTIPLE_ARITY_GENERIC_EXPRESSION));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
END_ENTITY;

ENTITY generic_variable
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY independent_property_definition
  SUPERTYPE OF (ONEOF (
              POINT_PROPERTY_DEFINITION,
              RANGE_PROPERTY_DEFINITION))
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY individual_activity
  SUBTYPE OF (executed_action);
END_ENTITY;

ENTITY individual_involvement_in_activity
  SUBTYPE OF (applied_action_assignment);
  SELF\action_assignment.assigned_action : individual_activity;
  SELF\applied_action_assignment.items : SET[1:1] OF involved_select;
END_ENTITY;

ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;

ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;

ENTITY intersection;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  operand     : SET[2:?] OF class;
  resultant   : class;
END_ENTITY;

ENTITY involvement_of_individual_product_in_connection
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : connection_of_individual_product_with_involvements;
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (
                       ELEMENTARY_SPACE,
                       FINITE_INTEGER_INTERVAL,
                       INTEGER_INTERVAL_FROM_MIN,
                       INTEGER_INTERVAL_TO_MAX,
                       FINITE_REAL_INTERVAL,
                       REAL_INTERVAL_FROM_MIN,
                       REAL_INTERVAL_TO_MAX,
                       FINITE_SPACE,
                       UNIFORM_PRODUCT_SPACE,
                       LISTED_PRODUCT_SPACE,
                       EXTENDED_TUPLE_SPACE))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY maths_space_context
  SUPERTYPE OF (ONEOF (
              COMPOUND_MATHS_SPACE_CONTEXT,
              DEFINED_MATHS_SPACE_CONTEXT,
              EXPLICITLY_ENUMERATED_MATHS_SPACE_CONTEXT));
  id              :  identifier;
  name            :  label;
  description     :  OPTIONAL text; 
  abstract_space  :  maths_space;
  physical_space  :  space_context_select;
END_ENTITY;

ENTITY maths_value_context;
  id              :  identifier;
  name            :  label;
  description     :  OPTIONAL text; 
  abstract_value  :  maths_value;
  physical_value  :  value_context_select;
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY membership_of_maths_space_context;
  space_context  :  maths_space_context;
  value_context  :  maths_value_context;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_organization_type : organization_type;
  role : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY person_and_organization_address 
SUBTYPE OF (organizational_address, personal_address); 
  SELF\personal_address.people: SET[1:1] of person;
  SELF\organizational_address.organizations: SET[1:1] of organization;
WHERE 
WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'FUNCTIONAL_DATA_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | 

   pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1; 
END_ENTITY;

ENTITY person_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY point_property_definition
  SUBTYPE OF (independent_property_definition);
END_ENTITY;

ENTITY possessed_property
  SUBTYPE OF (general_property_association);
  SELF\general_property_association.base_definition : independent_property_definition;
WHERE
  link_to_possession: ('FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_ACTIVITY' IN TYPEOF(SELF\general_property_association.derived_definition)) OR ('FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_PRODUCT' IN TYPEOF(SELF\general_property_association.derived_definition));

END_ENTITY;

ENTITY possession_of_property_by_activity
  SUBTYPE OF (action_property);
  SELF\action_property.definition : individual_activity;
END_ENTITY;

ENTITY possession_of_property_by_product
  SUBTYPE OF (property_definition);
WHERE
  link_to_individual: 'FUNCTIONAL_DATA_MIM_LF.PRODUCT_AS_INDIVIDUAL' IN TYPEOF(SELF\property_definition.definition.formation);

END_ENTITY;

ENTITY power_set;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  base        : class;
  derived     : class;
WHERE
  derived_different : NOT identical_sets(base, derived);
END_ENTITY;

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_as_individual
  ABSTRACT SUPERTYPE OF (ONEOF (
                       PRODUCT_AS_PLANNED,
                       PRODUCT_AS_REALIZED))
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

ENTITY product_as_planned
  SUBTYPE OF (product_as_individual);
END_ENTITY;

ENTITY product_as_realized
  SUBTYPE OF (product_as_individual);
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_design_to_individual
  SUBTYPE OF (product_definition_formation_relationship);

  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_individual;  -- individual_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
    DERIVE
      individual_product : PRODUCT_AS_INDIVIDUAL := SELF\product_definition_formation_relationship.related_product_definition_formation;  -- RELATED_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
      product_version : PRODUCT_DEFINITION_FORMATION := SELF\product_definition_formation_relationship.relating_product_definition_formation;  -- RELATING_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
END_ENTITY;

ENTITY product_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);

  SELF\product_definition_formation_relationship.relating_product_definition_formation : product_as_planned;  -- planned_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
  SELF\product_definition_formation_relationship.related_product_definition_formation : product_as_realized;  -- realized_product : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, an attribute with the new name is in the DERIVE clause
    DERIVE
      planned_product : PRODUCT_AS_PLANNED := SELF\product_definition_formation_relationship.relating_product_definition_formation;  -- RELATING_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
      realized_product : PRODUCT_AS_REALIZED := SELF\product_definition_formation_relationship.related_product_definition_formation;  -- RELATED_PRODUCT_DEFINITION_FORMATION : This ATTRIBUTE was RENAMED in the EXPRESS E2 source, this is the new name implemented as DERIVE
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY proper_subset
  SUBTYPE OF (subset);
WHERE
  subset_different : NOT identical_sets(superset, subset);
END_ENTITY;

ENTITY property_condition_for_activity
  SUBTYPE OF (action_property);
  SELF\action_property.definition : class_of_activity;
END_ENTITY;

ENTITY property_condition_for_product
  SUBTYPE OF (property_definition);
WHERE
  link_to_class: 'FUNCTIONAL_DATA_MIM_LF.CLASS_OF_PRODUCT' IN TYPEOF(SELF\property_definition.definition.formation);

END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY property_space
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY property_symmetry
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY property_symmetry_by_library_reference
  SUBTYPE OF (property_symmetry, externally_defined_item);
END_ENTITY;

ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;

ENTITY range_property_definition
  SUBTYPE OF (independent_property_definition);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;

ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'FUNCTIONAL_DATA_MIM_LF.' +

                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_context_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  representation_basis  :  representation_context;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

ENTITY same_membership;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  set_1       : class;
  set_2       : class;
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       GENERIC_LITERAL,
                       GENERIC_VARIABLE))

SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY space_for_property_definition
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : property_space;
  SELF\general_property_relationship.related_property : independent_property_definition;
END_ENTITY;

ENTITY standard_property_symmetry
  SUBTYPE OF (property_symmetry_by_library_reference);
WHERE
  valid_standard_class: (SELF\property_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1099') AND (SELF\property_symmetry_by_library_reference\externally_defined_item.item_id IN ['PS001', 'PS002', 'PS003', 'PS004', 'PS005', 'PS006', 'PS007', 'PS008', 'PS009', 'PS010', 'PS011', 'PS012', 'PS013']);
END_ENTITY;

ENTITY standard_tensor_order_and_symmetry
  SUBTYPE OF (tensor_order_and_symmetry_by_library_reference);
WHERE
  valid_standard_class: (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1080') AND (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.item_id IN ['TO001', 'TO002', 'TO003', 'TO004', 'TO005', 'TO006', 'TO007', 'TO008', 'TO009']);
END_ENTITY;

ENTITY subset;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  subset      : class;
  superset    : class;
END_ENTITY;

ENTITY symmetry_for_property_definition
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : property_symmetry;
  SELF\general_property_relationship.related_property : independent_property_definition;
END_ENTITY;

ENTITY tensor_order_and_symmetry
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY tensor_order_and_symmetry_by_library_reference
  SUBTYPE OF (tensor_order_and_symmetry, externally_defined_item);
END_ENTITY;

ENTITY tensor_order_and_symmetry_for_property_space
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : tensor_order_and_symmetry;
  SELF\general_property_relationship.related_property : property_space;
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;

ENTITY union;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  operand     : SET[2:?] OF class;
  resultant   : class;
END_ENTITY;

ENTITY unit_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  unit_basis  :  unit;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'FUNCTIONAL_DATA_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('FUNCTIONAL_DATA_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'FUNCTIONAL_DATA_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'FUNCTIONAL_DATA_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'FUNCTIONAL_DATA_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 

	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;


END_FUNCTION;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'FUNCTIONAL_DATA_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));

    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;

RETURN (TRUE);      END_FUNCTION;

FUNCTION bag_to_set
 (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype; 
   LOCAL
    the_set: SET OF GENERIC : intype := [];
  END_LOCAL;
  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);

END_FUNCTION;

FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);

END_FUNCTION;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'FUNCTIONAL_DATA_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN

    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);

      END_FUNCTION;

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;

		      END_FUNCTION;

FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));

END_FUNCTION;

FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);

END_FUNCTION;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'FUNCTIONAL_DATA_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));

  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'FUNCTIONAL_DATA_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));

END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;

END_FUNCTION;

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'FUNCTIONAL_DATA_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));

  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'FUNCTIONAL_DATA_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));

  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION identical_sets
  (set_a : class;
   set_b : class) : BOOLEAN;
  
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;
  
  IF (set_a = set_b) THEN
    RETURN (TRUE);
  END_IF;
  
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));

END_FUNCTION;

FUNCTION identical_to_one_of_set_of_sets
  (set_a       : class;
   set_of_sets : SET OF class) : BOOLEAN;
  
  LOCAL
    i                            : INTEGER;
    initial_size                 : INTEGER;
    augmented_size               : INTEGER;
    set_of_forward_equivalences  : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets        : SET OF class := [];
  END_LOCAL;
  
  --  test membership of the specified set of sets
  
  IF (set_a IN set_of_sets) THEN
    RETURN (TRUE);
  END_IF;
  
  --  extend the specified set to include all sets that have the same membership
  --  as an existing member
  
  initial_size := SIZEOF(set_of_sets);
  IF (initial_size = 0) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'FUNCTIONAL_DATA_MIM_LF.SAME_MEMBERSHIP.SET_1');
    set_of_backward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'FUNCTIONAL_DATA_MIM_LF.SAME_MEMBERSHIP.SET_2');

  END_REPEAT;
  
  augmented_set_of_sets := set_of_sets;
  IF (SIZEOF(set_of_forward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(set_of_backward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  
  -- if the specified set of sets has been augmented, then test membership
  
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));

END_FUNCTION;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));

END_FUNCTION;

FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );

END_FUNCTION;

FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);

END_FUNCTION;

FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);

END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('FUNCTIONAL_DATA_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));

  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);

END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'FUNCTIONAL_DATA_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'FUNCTIONAL_DATA_MIM_LF.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);

END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;

END_FUNCTION;

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'FUNCTIONAL_DATA_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'FUNCTIONAL_DATA_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 

  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);

		      END_FUNCTION;

FUNCTION version_assignment_is_valid
 (aia : applied_identification_assignment) : BOOLEAN; 
LOCAL
  item: identification_item;
  role: identification_role;
END_LOCAL;

role:= aia.role;
IF role.name='version' THEN
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['FUNCTIONAL_DATA_MIM_LF.' + 'VERSIONABLE_ITEM']*TYPEOF(item))=0) THEN

	RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);

ELSE
  RETURN(TRUE);
END_IF;

      END_FUNCTION;

RULE version_assignments_are_valid FOR 
(applied_identification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia <* applied_identification_assignment | NOT version_assignment_is_valid(aia)))=0;
END_RULE;

(* E2: SUBTYPE_CONSTRAINT classification_or_complete_membership FOR CLASSIFICATION_ASSIGNMENT; *)

(*** 2003=>1994 conversion: insert a rule to control if instances are legal according to USE/REF clauses ***)

  RULE validate_dependently_instantiable_entity_data_types FOR
      (application_context,application_context_element,applied_classification_assignment,binary_generic_expression,classification_assignment,classification_role,description_attribute,environment,extended_tuple_space,generic_expression,generic_literal,generic_variable,multiple_arity_generic_expression,name_attribute,organization_type_role,product_context,quantifier_expression,role_association,simple_generic_expression,unary_generic_expression,variable_semantics --<list this first and all subsequent relevant referencedentity data types here>
      );
  LOCAL
    number_of_input_instances : INTEGER;
    previous_in_chain         : LIST OF  GENERIC := []; 
    set_of_input_types        : SET OF STRING := [];
    all_instances             : SET OF  GENERIC := []; 
  END_LOCAL;

  all_instances := application_context + application_context_element + applied_classification_assignment + binary_generic_expression + classification_assignment + classification_role + description_attribute + environment + extended_tuple_space + generic_expression + generic_literal + generic_variable + multiple_arity_generic_expression + name_attribute + organization_type_role + product_context + quantifier_expression + role_association + simple_generic_expression + unary_generic_expression + variable_semantics;--<make a union of all implicit populations of the FOR-clause>
  number_of_input_instances := SIZEOF(all_instances);
  (* Collect all type strings of all FOR instances into one set. *)
  REPEAT i:=1 TO number_of_input_instances;
    set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
  END_REPEAT;

  WHERE
   WR1: dependently_instantiated(all_instances, set_of_input_types,
                                 previous_in_chain);
  END_RULE;

  FUNCTION dependently_instantiated(
          set_of_input_instances : SET OF GENERIC;
          set_of_input_types     : SET OF STRING;
          previous_in_chain      : LIST OF GENERIC): BOOLEAN;
  (*'dependently_instantiated' To test whether all instances in the
    input set_of_input_instances are referenced by independently
    instantiable instances. If so, this function returns true.
    Set_of_input_types includes the type strings for all input instances.
    The instances in previous_in_chain are used to detect cyclic
    references during recursive calls to this function. The parameter
    lists already tested instances in a chain of references.
   *)
  LOCAL
    number_of_input_instances     : INTEGER;
    number_of_referring_instances : INTEGER;
    bag_of_referring_instances    : BAG OF  GENERIC := [];  
    dependently_instantiated_flag : BOOLEAN;
    previous_in_chain_plus        : LIST OF GENERIC := [];
    recursion                     : BOOLEAN;
    result                        : BOOLEAN := true;
    set_of_types                  : SET OF STRING := [];
  END_LOCAL;

  IF EXISTS(set_of_input_instances) THEN
    number_of_input_instances := SIZEOF(set_of_input_instances);
    (* Add the declared type of bag_of_referring_instances to the set of
       types of the REFERENCEd instances for the subset comparison later.
     *)
    set_of_input_types := set_of_input_types + 'GENERIC';
    REPEAT i:=1 TO number_of_input_instances;
      (* Determine all references to the current input instance. *)
      bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
      IF EXISTS(bag_of_referring_instances) THEN
        number_of_referring_instances := SIZEOF(bag_of_referring_instances);
        dependently_instantiated_flag := false;
        REPEAT j:=1 TO number_of_referring_instances;
          (* Determine the type strings of the current referencing instance.
           *)
          set_of_types := TYPEOF(bag_of_referring_instances[j]);
          (* If the referencing instance is of one of the types of the
             only dependently instantiable select items, the current input
             instance may still be invalidly instantiated.
             Otherwise it is OK, and the next input instance is tested.
           *)
          IF set_of_types <= set_of_input_types THEN -- subset operator
            (* The referring instance is of one of the restricted types.
               However, it may itself be referred to by a valid instance;
               then also the current instance would be valid.
               Thus, call this function recursively with the referring
               instance as input.
               To avoid an infinite loop in case a set of instances
               reference each other in a closed loop, test first whether
               the current referencing instance is in the list of
               previously processed chain members.
             *)
            IF EXISTS(previous_in_chain) THEN
              recursion := true;
              REPEAT k:=1 TO SIZEOF(previous_in_chain);
                IF previous_in_chain[k] :=: bag_of_referring_instances[j]
                  THEN
                  (* No recursion. *)
                  recursion := false;
                  ESCAPE;
                END_IF;
              END_REPEAT;
            END_IF;
            IF recursion THEN
              previous_in_chain_plus := previous_in_chain +
                                        set_of_input_instances[i];
              IF dependently_instantiated([bag_of_referring_instances[j]],
                                          set_of_input_types,
                                          previous_in_chain_plus) THEN
                dependently_instantiated_flag := true;
                ESCAPE; -- dependently instantiated; next input instance
              ELSE
                (* Not dependently instantiated: go to next referring
                   instance. *)
                SKIP;
              END_IF;
            END_IF;
          ELSE
            dependently_instantiated_flag := true;
            ESCAPE; -- dependently instantiated; take next input instance
          END_IF;
        END_REPEAT;
        IF NOT dependently_instantiated_flag THEN
          RETURN(false);
        END_IF;
      ELSE
        RETURN(false); -- not referenced at all => invalidly instantiated
      END_IF;
    END_REPEAT;
  ELSE
    RETURN(false); -- no input
  END_IF;

  RETURN(true);
  END_FUNCTION; -- end dependently_instantiated



END_SCHEMA;

