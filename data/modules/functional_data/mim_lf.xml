<?xml version='1.0' encoding='UTF-8'?>
<!-- $Id: mim_lf.xml,v 1.4 2004/09/01 12:01:43 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<express
  language_version="1"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name=" Eurostep EXPRESS Parser (Eep!)"
    owner="Eurostep Limited"
    url="www.eurostep.com"
    version="1, 3, 10, 12"
    source="mim_lf.exp"/>

  <schema name="Functional_data_mim_lf">
    <constant
      name="cnlit"
      expression="schema_prefix + &apos;COMPLEX_NUMBER_LITERAL&apos;">
      <builtintype type="STRING"
      />
    </constant>
    <constant
      name="dummy_gri"
      expression="representation_item(&apos;&apos;)||geometric_representation_item()">
      <typename name="geometric_representation_item"/>
    </constant>
    <constant
      name="schema_prefix"
      expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos;">
      <builtintype type="STRING"
      />
    </constant>
    <constant
      name="the_binarys"
      expression="make_elementary_space(es_binarys)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_booleans"
      expression="make_elementary_space(es_booleans)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_complex_numbers"
      expression="make_elementary_space(es_complex_numbers)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_complex_tuples"
      expression="make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers)">
      <typename name="extended_tuple_space"/>
    </constant>
    <constant
      name="the_empty_maths_tuple"
      expression="[]">
      <typename name="maths_tuple"/>
    </constant>
    <constant
      name="the_empty_space"
      expression="make_finite_space([])">
      <typename name="finite_space"/>
    </constant>
    <constant
      name="the_generics"
      expression="make_elementary_space(es_generics)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_integer_tuples"
      expression="make_extended_tuple_space(the_zero_tuple_space, the_integers)">
      <typename name="extended_tuple_space"/>
    </constant>
    <constant
      name="the_integers"
      expression="make_elementary_space(es_integers)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_logicals"
      expression="make_elementary_space(es_logicals)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_maths_spaces"
      expression="make_elementary_space(es_maths_spaces)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_neg1_one_interval"
      expression="make_finite_real_interval( - 1.000000, closed, 1.000000, closed)">
      <typename name="finite_real_interval"/>
    </constant>
    <constant
      name="the_neghalfpi_halfpi_interval"
      expression="make_finite_real_interval( - 0.500000 * PI, closed, 0.500000 * PI, closed)">
      <typename name="finite_real_interval"/>
    </constant>
    <constant
      name="the_negpi_pi_interval"
      expression="make_finite_real_interval( - PI, open, PI, closed)">
      <typename name="finite_real_interval"/>
    </constant>
    <constant
      name="the_nonnegative_reals"
      expression="make_real_interval_from_min(0.000000, closed)">
      <typename name="real_interval_from_min"/>
    </constant>
    <constant
      name="the_numbers"
      expression="make_elementary_space(es_numbers)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_real_tuples"
      expression="make_extended_tuple_space(the_zero_tuple_space, the_reals)">
      <typename name="extended_tuple_space"/>
    </constant>
    <constant
      name="the_reals"
      expression="make_elementary_space(es_reals)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_strings"
      expression="make_elementary_space(es_strings)">
      <typename name="elementary_space"/>
    </constant>
    <constant
      name="the_tuples"
      expression="make_extended_tuple_space(the_zero_tuple_space, the_generics)">
      <typename name="extended_tuple_space"/>
    </constant>
    <constant
      name="the_zero_pi_interval"
      expression="make_finite_real_interval(0.000000, closed, PI, closed)">
      <typename name="finite_real_interval"/>
    </constant>
    <constant
      name="the_zero_tuple_space"
      expression="make_listed_product_space([])">
      <typename name="listed_product_space"/>
    </constant>
    <type name="action_items">
      <select
        selectitems="class_of_activity class_of_composition_of_activity class_of_composition_of_product class_of_connection_of_activity class_of_connection_of_product class_of_containment_of_product class_of_involvement_in_activity class_of_involvement_of_product_in_connection class_of_person class_of_product composition_of_individual_activity composition_of_individual_product connection_of_individual_activity connection_of_individual_product containment_of_individual_product drawing_revision_class_of_document drawing_sheet_revision_class_of_document individual_activity individual_involvement_in_activity involvement_of_individual_product_in_connection organization organization_type person person_and_organization possession_of_property_by_activity possession_of_property_by_product product_as_individual property_condition_for_activity property_condition_for_product schematic_element symbolization_by_schematic_element"
      />
    </type>

    <type name="amount_of_substance_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="approved_item">
      <select
        selectitems="drawing_revision drawing_sheet_revision"
      />
    </type>

    <type name="area_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="atom_based_value">
      <select
        selectitems="maths_atom"
      />
    </type>

    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d"
      />
    </type>

    <type name="b_spline_curve_form">
      <enumeration
        items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"
      />
    </type>

    <type name="box_characteristic_select">
      <select
        selectitems="box_height box_width box_slant_angle box_rotate_angle"
      />
    </type>

    <type name="box_height">
      <typename name="positive_ratio_measure"/>
    </type>

    <type name="box_rotate_angle">
      <typename name="plane_angle_measure"/>
    </type>

    <type name="box_slant_angle">
      <typename name="plane_angle_measure"/>
    </type>

    <type name="box_width">
      <typename name="positive_ratio_measure"/>
    </type>

    <type name="celsius_temperature_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="character_spacing_select">
      <select
        selectitems="length_measure ratio_measure measure_with_unit descriptive_measure"
      />
    </type>

    <type name="character_style_select">
      <select
        selectitems="text_style_for_defined_font"
      />
    </type>

    <type name="characterized_action_definition">
      <select
        selectitems="action action_method action_relationship"
      />
    </type>

    <type name="characterized_definition">
      <select
        selectitems="characterized_product_definition"
      />
    </type>

    <type name="characterized_product_definition">
      <select
        selectitems="product_definition"
      />
    </type>

    <type name="classification_select">
      <select
        selectitems="composition_of_individual_activity composition_of_individual_product connection_of_individual_activity connection_of_individual_product containment_of_individual_product individual_activity individual_involvement_in_activity involvement_of_individual_product_in_connection product_as_individual"
      />
    </type>

    <type name="classified_item">
      <select
        selectitems="drawing_revision drawing_sheet_revision"
      />
    </type>

    <type name="complete_membership_select">
      <select
        selectitems="composition_of_individual_activity composition_of_individual_product connection_of_individual_activity connection_of_individual_product containment_of_individual_product individual_activity individual_involvement_in_activity involvement_of_individual_product_in_connection product_as_individual"
      />
    </type>

    <type name="context_dependent_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="contracted_item">
      <select
        selectitems="drawing_revision"
      />
    </type>

    <type name="count_measure">
      <builtintype type="NUMBER"
      />
    </type>

    <type name="curve_font_or_scaled_curve_font_select">
      <select
        selectitems="curve_style_font_select"
      />
    </type>

    <type name="curve_style_font_select">
      <select
        selectitems="curve_style_font pre_defined_curve_font externally_defined_curve_font"
      />
    </type>

    <type name="date_time_select">
      <select
        selectitems="date"
      />
    </type>

    <type name="day_in_month_number">
      <builtintype type="INTEGER"
      />
      <where
        label="wr1"
        expression="{1 &lt;= SELF &lt;= 31}">
      </where>
    </type>

    <type name="defined_symbol_select">
      <select
        selectitems="pre_defined_symbol externally_defined_symbol"
      />
    </type>

    <type name="derived_property_select">
      <select
        selectitems="action_property property_definition"
      />
    </type>

    <type name="description_attribute_select">
      <select
        selectitems="application_context approval_role external_source organization_role person_and_organization person_and_organization_role person_role property_definition_representation representation"
      />
    </type>

    <type name="descriptive_measure">
      <builtintype type="STRING"
      />
    </type>

    <type name="dimension_count">
      <builtintype type="INTEGER"
      />
      <where
        label="wr1"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="draughting_callout_element">
      <select
        selectitems="annotation_text_occurrence annotation_symbol_occurrence annotation_curve_occurrence"
      />
    </type>

    <type name="draughting_organization_item">
      <select
        selectitems="product_definition_formation drawing_revision drawing_sheet_revision"
      />
    </type>

    <type name="draughting_presented_item_select">
      <select
        selectitems="product_definition_formation"
      />
    </type>

    <type name="draughting_titled_item">
      <select
        selectitems="drawing_revision drawing_sheet_revision"
      />
    </type>

    <type name="electric_current_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="elementary_function_enumerators">
      <enumeration
        items="ef_and ef_or ef_not ef_xor ef_negate_i ef_add_i ef_subtract_i ef_multiply_i ef_divide_i ef_mod_i ef_exponentiate_i ef_eq_i ef_ne_i ef_gt_i ef_lt_i ef_ge_i ef_le_i ef_abs_i ef_max_i ef_min_i ef_if_i ef_negate_r ef_reciprocal_r ef_add_r ef_subtract_r ef_multiply_r ef_divide_r ef_mod_r ef_exponentiate_r ef_exponentiate_ri ef_eq_r ef_ne_r ef_gt_r ef_lt_r ef_ge_r ef_le_r ef_abs_r ef_max_r ef_min_r ef_acos_r ef_asin_r ef_atan2_r ef_cos_r ef_exp_r ef_ln_r ef_log2_r ef_log10_r ef_sin_r ef_sqrt_r ef_tan_r ef_if_r ef_form_c ef_rpart_c ef_ipart_c ef_negate_c ef_reciprocal_c ef_add_c ef_subtract_c ef_multiply_c ef_divide_c ef_exponentiate_c ef_exponentiate_ci ef_eq_c ef_ne_c ef_conjugate_c ef_abs_c ef_arg_c ef_cos_c ef_exp_c ef_ln_c ef_sin_c ef_sqrt_c ef_tan_c ef_if_c ef_subscript_s ef_eq_s ef_ne_s ef_gt_s ef_lt_s ef_ge_s ef_le_s ef_subsequence_s ef_concat_s ef_size_s ef_format ef_value ef_like ef_if_s ef_subscript_b ef_eq_b ef_ne_b ef_gt_b ef_lt_b ef_ge_b ef_le_b ef_subsequence_b ef_concat_b ef_size_b ef_if_b ef_subscript_t ef_eq_t ef_ne_t ef_concat_t ef_size_t ef_entuple ef_detuple ef_insert ef_remove ef_if_t ef_sum_it ef_product_it ef_add_it ef_subtract_it ef_scalar_mult_it ef_dot_prod_it ef_sum_rt ef_product_rt ef_add_rt ef_subtract_rt ef_scalar_mult_rt ef_dot_prod_rt ef_norm_rt ef_sum_ct ef_product_ct ef_add_ct ef_subtract_ct ef_scalar_mult_ct ef_dot_prod_ct ef_norm_ct ef_if ef_ensemble ef_member_of"
      />
    </type>

    <type name="elementary_space_enumerators">
      <enumeration
        items="es_numbers es_complex_numbers es_reals es_integers es_logicals es_booleans es_strings es_binarys es_maths_spaces es_maths_functions es_generics"
      />
    </type>

    <type name="extension_options">
      <enumeration
        items="eo_none eo_cont eo_cont_right eo_cont_left"
      />
    </type>

    <type name="external_identification_item">
      <select
        selectitems="class_of_activity class_of_composition_of_activity class_of_composition_of_product class_of_connection_of_activity class_of_connection_of_product class_of_containment_of_product class_of_involvement_in_activity class_of_involvement_of_product_in_connection class_of_person class_of_product drawing_revision_class_of_document drawing_sheet_revision_class_of_document implicit_schematic_element_definition organization_type property_condition_for_activity property_condition_for_product schematic_element symbolization_by_schematic_element"
      />
    </type>

    <type name="fill_area_style_tile_shape_select">
      <select
        selectitems="fill_area_style_tile_symbol_with_style"
      />
    </type>

    <type name="fill_style_select">
      <select
        selectitems="fill_area_style_colour externally_defined_tile_style fill_area_style_tiles externally_defined_hatch_style fill_area_style_hatching"
      />
    </type>

    <type name="font_select">
      <select
        selectitems="pre_defined_text_font externally_defined_text_font"
      />
    </type>

    <type name="founded_item_select">
      <select
        selectitems="founded_item representation_item"
      />
    </type>

    <type name="geometric_set_select">
      <select
        selectitems="point curve surface"
      />
    </type>

    <type name="id_attribute_select">
      <select
        selectitems="action address application_context group product_category property_definition representation"
      />
    </type>

    <type name="identification_item">
      <select
        selectitems="product_as_individual"
      />
    </type>

    <type name="identifier">
      <builtintype type="STRING"
      />
    </type>

    <type name="input_selector">
      <typename name="positive_integer"/>
    </type>

    <type name="invisibility_context">
      <select
        selectitems="presentation_representation presentation_set"
      />
    </type>

    <type name="invisible_item">
      <select
        selectitems="styled_item representation"
      />
    </type>

    <type name="involved_class_select">
      <typename name="action_items"/>
      <where
        label="wr1"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITION_OF_INDIVIDUAL_ACTIVITY&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr2"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITION_OF_INDIVIDUAL_PRODUCT&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr3"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.CONNECTION_OF_INDIVIDUAL_ACTIVITY&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr4"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.CONNECTION_OF_INDIVIDUAL_PRODUCT&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr5"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.CONTAINMENT_OF_INDIVIDUAL_PRODUCT&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr6"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.INDIVIDUAL_ACTIVITY&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr7"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.INDIVIDUAL_INVOLVEMENT_IN_ACTIVITY&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr8"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.INVOLVEMENT_OF_INDIVIDUAL_PRODUCT_IN_CONNECTION&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr9"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ORGANIZATION&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr10"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.PERSON&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr11"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.PERSON_AND_ORGANIZATION&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr12"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_ACTIVITY&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr13"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_PRODUCT&apos; IN TYPEOF(SELF))">
      </where>
      <where
        label="wr14"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.PRODUCT_AS_INDIVIDUAL&apos; IN TYPEOF(SELF))">
      </where>
    </type>

    <type name="involved_select">
      <typename name="action_items"/>
    </type>

    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"
      />
    </type>

    <type name="label">
      <builtintype type="STRING"
      />
    </type>

    <type name="length_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="luminous_intensity_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="mass_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="maths_atom">
      <select
        selectitems="maths_simple_atom maths_enum_atom"
      />
    </type>

    <type name="maths_binary">
      <builtintype type="BINARY"
      />
    </type>

    <type name="maths_boolean">
      <builtintype type="BOOLEAN"
      />
    </type>

    <type name="maths_enum_atom">
      <select
        selectitems="elementary_space_enumerators ordering_type elementary_function_enumerators open_closed space_constraint_type repackage_options extension_options"
      />
    </type>

    <type name="maths_expression">
      <select
        selectitems="atom_based_value maths_tuple generic_expression"
      />
    </type>

    <type name="maths_function_select">
      <select
        selectitems="maths_function elementary_function_enumerators"
      />
    </type>

    <type name="maths_integer">
      <builtintype type="INTEGER"
      />
    </type>

    <type name="maths_logical">
      <builtintype type="LOGICAL"
      />
    </type>

    <type name="maths_number">
      <builtintype type="NUMBER"
      />
    </type>

    <type name="maths_real">
      <builtintype type="REAL"
      />
    </type>

    <type name="maths_simple_atom">
      <select
        selectitems="maths_number maths_real maths_integer maths_logical maths_boolean maths_string maths_binary"
      />
    </type>

    <type name="maths_space_or_function">
      <select
        selectitems="maths_space maths_function"
      />
    </type>

    <type name="maths_string">
      <builtintype type="STRING"
      />
    </type>

    <type name="maths_tuple">
      <aggregate type="LIST"
      />
      <typename name="maths_value"/>
    </type>

    <type name="maths_value">
      <select
        selectitems="atom_based_value maths_tuple generic_expression"
      />
      <where
        label="constancy"
        expression="NOT (&apos;GENERIC_EXPRESSION&apos; IN stripped_typeof(SELF)) OR expression_is_constant(SELF)">
      </where>
    </type>

    <type name="measure_value">
      <select
        selectitems="amount_of_substance_measure area_measure celsius_temperature_measure context_dependent_measure count_measure descriptive_measure electric_current_measure length_measure luminous_intensity_measure mass_measure numeric_measure parameter_value plane_angle_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure ratio_measure solid_angle_measure thermodynamic_temperature_measure time_measure volume_measure"
      />
    </type>

    <type name="month_in_year_number">
      <builtintype type="INTEGER"
      />
      <where
        label="wr1"
        expression="{1 &lt;= SELF &lt;= 12}">
      </where>
    </type>

    <type name="name_attribute_select">
      <select
        selectitems="address derived_unit person_and_organization product_definition property_definition_representation"
      />
    </type>

    <type name="nonnegative_integer">
      <builtintype type="INTEGER"
      />
      <where
        label="nonnegativity"
        expression="SELF &gt;= 0">
      </where>
    </type>

    <type name="null_style">
      <enumeration
        items="null"
      />
    </type>

    <type name="numeric_measure">
      <builtintype type="NUMBER"
      />
    </type>

    <type name="one_or_two">
      <typename name="positive_integer"/>
      <where
        label="in_range"
        expression="(SELF = 1) OR (SELF = 2)">
      </where>
    </type>

    <type name="open_closed">
      <enumeration
        items="open closed"
      />
    </type>

    <type name="ordering_type">
      <enumeration
        items="by_rows by_columns"
      />
    </type>

    <type name="organization_type_item">
      <select
        selectitems="organization"
      />
    </type>

    <type name="parameter_value">
      <builtintype type="REAL"
      />
    </type>

    <type name="person_organization_select">
      <select
        selectitems="organization person person_and_organization"
      />
    </type>

    <type name="plane_angle_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="positive_integer">
      <typename name="nonnegative_integer"/>
      <where
        label="positivity"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="positive_length_measure">
      <typename name="length_measure"/>
      <where
        label="wr1"
        expression="SELF &gt; 0.000000">
      </where>
    </type>

    <type name="positive_plane_angle_measure">
      <typename name="plane_angle_measure"/>
      <where
        label="wr1"
        expression="SELF &gt; 0.000000">
      </where>
    </type>

    <type name="positive_ratio_measure">
      <typename name="ratio_measure"/>
      <where
        label="wr1"
        expression="SELF &gt; 0.000000">
      </where>
    </type>

    <type name="presentable_text">
      <builtintype type="STRING"
      />
    </type>

    <type name="presentation_representation_select">
      <select
        selectitems="presentation_representation presentation_set"
      />
    </type>

    <type name="presentation_size_assignment_select">
      <select
        selectitems="presentation_view presentation_area area_in_set"
      />
    </type>

    <type name="presentation_style_select">
      <select
        selectitems="curve_style symbol_style fill_area_style text_style null_style"
      />
    </type>

    <type name="product_space">
      <select
        selectitems="uniform_product_space listed_product_space"
      />
    </type>

    <type name="ratio_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="real_interval">
      <select
        selectitems="real_interval_from_min real_interval_to_max finite_real_interval elementary_space"
      />
      <where
        label="wr1"
        expression="NOT (&apos;ELEMENTARY_SPACE&apos; IN stripped_typeof(SELF)) OR (SELF\elementary_space.space_id = es_reals)">
      </where>
    </type>

    <type name="relationship_select">
      <typename name="space_context_select"/>
    </type>

    <type name="repackage_options">
      <enumeration
        items="ro_nochange ro_wrap_as_tuple ro_unwrap_tuple"
      />
    </type>

    <type name="represented_definition">
      <select
        selectitems="general_property property_definition"
      />
    </type>

    <type name="role_select">
      <select
        selectitems="action_assignment approval_assignment approval_date_time contract_assignment document_reference security_classification_assignment"
      />
    </type>

    <type name="si_prefix">
      <enumeration
        items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto"
      />
    </type>

    <type name="si_unit_name">
      <enumeration
        items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_celsius lumen lux becquerel gray sievert"
      />
    </type>

    <type name="size_select">
      <select
        selectitems="positive_length_measure measure_with_unit descriptive_measure"
      />
    </type>

    <type name="solid_angle_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="source_item">
      <select
        selectitems="identifier"
      />
    </type>

    <type name="space_constraint_type">
      <enumeration
        items="sc_equal sc_subspace sc_member"
      />
    </type>

    <type name="space_context_select">
      <select
        selectitems="action action_method class_of_composition_of_activity class_of_composition_of_product class_of_connection_of_activity class_of_connection_of_product class_of_containment_of_product class_of_involvement_in_activity class_of_involvement_of_product_in_connection general_property product_definition representation_item"
      />
    </type>

    <type name="specified_item">
      <select
        selectitems="drawing_revision"
      />
    </type>

    <type name="style_context_select">
      <select
        selectitems="group representation representation_item presentation_set"
      />
    </type>

    <type name="symbol_style_select">
      <select
        selectitems="symbol_colour"
      />
    </type>

    <type name="symbolized_class_select">
      <select
        selectitems="class_of_activity class_of_composition_of_activity class_of_composition_of_product class_of_connection_of_activity class_of_connection_of_product class_of_containment_of_product class_of_involvement_in_activity class_of_involvement_of_product_in_connection class_of_person class_of_product drawing_revision_class_of_document drawing_sheet_revision_class_of_document organization_type property_condition_for_activity property_condition_for_product schematic_element symbolization_by_schematic_element"
      />
    </type>

    <type name="symbolized_item_select">
      <select
        selectitems="class_of_activity class_of_composition_of_activity class_of_composition_of_product class_of_connection_of_activity class_of_connection_of_product class_of_containment_of_product class_of_involvement_in_activity class_of_involvement_of_product_in_connection class_of_person class_of_product composition_of_individual_activity composition_of_individual_product connection_of_individual_activity connection_of_individual_product containment_of_individual_product drawing_revision_class_of_document drawing_sheet_revision_class_of_document individual_activity individual_involvement_in_activity involvement_of_individual_product_in_connection organization organization_type person person_and_organization possession_of_property_by_activity possession_of_property_by_product product_as_individual property_condition_for_activity property_condition_for_product schematic_element symbolization_by_schematic_element"
      />
    </type>

    <type name="text">
      <builtintype type="STRING"
      />
    </type>

    <type name="text_alignment">
      <typename name="label"/>
    </type>

    <type name="text_delineation">
      <typename name="label"/>
    </type>

    <type name="text_or_character">
      <select
        selectitems="annotation_text composite_text text_literal"
      />
    </type>

    <type name="text_path">
      <enumeration
        items="left right up down"
      />
    </type>

    <type name="thermodynamic_temperature_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="time_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="transition_code">
      <enumeration
        items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"
      />
    </type>

    <type name="trimming_preference">
      <enumeration
        items="cartesian parameter unspecified"
      />
    </type>

    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value"
      />
    </type>

    <type name="tuple_space">
      <select
        selectitems="product_space extended_tuple_space"
      />
    </type>

    <type name="unit">
      <select
        selectitems="derived_unit named_unit"
      />
    </type>

    <type name="value_context_select">
      <select
        selectitems="action action_method general_property product_definition representation_item"
      />
    </type>

    <type name="vector_or_direction">
      <select
        selectitems="vector direction"
      />
    </type>

    <type name="volume_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="year_number">
      <builtintype type="INTEGER"
      />
    </type>

    <type name="zero_or_one">
      <typename name="nonnegative_integer"/>
      <where
        label="in_range"
        expression="(SELF = 0) OR (SELF = 1)">
      </where>
    </type>

    <entity name="abs_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="abstracted_expression_function"
      supertypes="maths_function quantifier_expression"
    >
      <derived
        name="variables"
        expression="remove_first(SELF\multiple_arity_generic_expression.operands)">
        <aggregate type="LIST"
          unique="YES"
          lower="1"
          upper="?"
        />
        <typename name="generic_variable"/>
        <redeclaration
          entity-ref="quantifier_expression"/>
      </derived>
      <derived
        name="expr"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(operand &lt;* SELF\multiple_arity_generic_expression.operands | NOT has_values_space(operand))) = 0">
      </where>
    </entity>

    <entity name="acos_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="action"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="chosen_method">
        <typename name="action_method"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="action_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_action">
        <typename name="action"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="action_method"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="consequence">
        <typename name="text"/>
      </explicit>
      <explicit
        name="purpose">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="action_property"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename name="text"/>
      </explicit>
      <explicit
        name="definition">
        <typename name="characterized_action_definition"/>
      </explicit>
    </entity>

    <entity name="action_property_representation"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename name="text"/>
      </explicit>
      <explicit
        name="property">
        <typename name="action_property"/>
      </explicit>
      <explicit
        name="representation">
        <typename name="representation"/>
      </explicit>
    </entity>

    <entity name="action_relationship"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="relating_action">
        <typename name="action"/>
      </explicit>
      <explicit
        name="related_action">
        <typename name="action"/>
      </explicit>
    </entity>

    <entity name="action_status"
    >
      <explicit
        name="status">
        <typename name="label"/>
      </explicit>
      <explicit
        name="assigned_action">
        <typename name="executed_action"/>
      </explicit>
    </entity>

    <entity name="address"
    >
      <explicit
        name="internal_location"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="street_number"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="street"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="postal_box"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="town"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="region"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="postal_code"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="country"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="facsimile_number"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="telephone_number"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="electronic_mail_address"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="telex_number"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename name="label"/>
      </derived>
      <derived
        name="url"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number)">
      </where>
    </entity>

    <entity name="amount_of_substance_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="amount_of_substance_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="and_expression"
      supertypes="multiple_arity_boolean_expression"
    >
    </entity>

    <entity name="annotation_curve_occurrence"
      supertypes="annotation_occurrence"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.CURVE&apos; IN TYPEOF(SELF\styled_item.item)">
      </where>
    </entity>

    <entity name="annotation_fill_area"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="boundaries">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="curve"/>
      </explicit>
    </entity>

    <entity name="annotation_fill_area_occurrence"
      supertypes="annotation_occurrence"
    >
      <explicit
        name="fill_style_target">
        <typename name="point"/>
      </explicit>
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_FILL_AREA&apos; IN TYPEOF(SELF.item)">
      </where>
    </entity>

    <entity name="annotation_occurrence"
      supertypes="styled_item"
      super.expression="ONEOF(annotation_curve_occurrence, annotation_fill_area_occurrence, annotation_text_occurrence, annotation_symbol_occurrence)"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM&apos; IN TYPEOF(SELF)">
      </where>
    </entity>

    <entity name="annotation_subfigure_occurrence"
      supertypes="annotation_symbol_occurrence"
    >
      <where
        label="wr1"
        expression="SIZEOF(QUERY(sty &lt;* SELF.styles | NOT (SIZEOF(sty.styles) = 1))) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(sty &lt;* SELF.styles | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.NULL_STYLE&apos; IN TYPEOF(sty.styles[1])))) = 0">
      </where>
      <where
        label="wr3"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL&apos; IN TYPEOF(SELF.item)">
      </where>
      <where
        label="wr4"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_SUBFIGURE_REPRESENTATION&apos; IN TYPEOF(SELF.item\mapped_item.mapping_source.mapped_representation)">
      </where>
    </entity>

    <entity name="annotation_symbol"
      supertypes="mapped_item"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_REPRESENTATION_MAP&apos; IN TYPEOF(SELF\mapped_item.mapping_source)">
      </where>
      <where
        label="wr2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_TARGET&apos; IN TYPEOF(SELF\mapped_item.mapping_target)">
      </where>
      <where
        label="wr3"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM&apos; IN TYPEOF(SELF)">
      </where>
    </entity>

    <entity name="annotation_symbol_occurrence"
      supertypes="annotation_occurrence"
    >
      <where
        label="wr1"
        expression="SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.DEFINED_SYMBOL&apos;] * TYPEOF(SELF\styled_item.item)) &gt; 0">
      </where>
    </entity>

    <entity name="annotation_text"
      supertypes="mapped_item"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos; IN TYPEOF(SELF\mapped_item.mapping_target)">
      </where>
      <where
        label="wr2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_STRING_REPRESENTATION&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="wr3"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM&apos; IN TYPEOF(SELF)">
      </where>
    </entity>

    <entity name="annotation_text_occurrence"
      supertypes="annotation_occurrence"
    >
      <where
        label="wr1"
        expression="SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_CHARACTER&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.DEFINED_CHARACTER_GLYPH&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos;] * TYPEOF(SELF\styled_item.item)) &gt; 0">
      </where>
    </entity>

    <entity name="application_context"
    >
      <explicit
        name="application">
        <typename name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <inverse
        name="context_elements"
        entity="application_context_element"
        attribute="frame_of_reference">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="application_context_element"
      super.expression="ONEOF(product_context, product_definition_context)"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename name="application_context"/>
      </explicit>
    </entity>

    <entity name="application_defined_function"
      supertypes="maths_function"
    >
      <explicit
        name="explicit_domain">
        <typename name="tuple_space"/>
      </explicit>
      <explicit
        name="explicit_range">
        <typename name="tuple_space"/>
      </explicit>
      <explicit
        name="parameters">
        <aggregate type="LIST"
        />
        <typename name="maths_value"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(explicit_domain)">
      </where>
      <where
        label="wr2"
        expression="expression_is_constant(explicit_range)">
      </where>
    </entity>

    <entity name="applied_action_assignment"
      supertypes="action_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="action_items"/>
      </explicit>
    </entity>

    <entity name="applied_classification_assignment"
      supertypes="classification_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="classification_select"/>
      </explicit>
    </entity>

    <entity name="applied_external_identification_assignment"
      supertypes="external_identification_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="external_identification_item"/>
      </explicit>
    </entity>

    <entity name="applied_identification_assignment"
      supertypes="identification_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="identification_item"/>
      </explicit>
    </entity>

    <entity name="applied_organization_type_assignment"
      supertypes="organization_type_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="organization_type_item"/>
      </explicit>
    </entity>

    <entity name="approval"
    >
      <explicit
        name="status">
        <typename name="approval_status"/>
      </explicit>
      <explicit
        name="level">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="approval_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_approval">
        <typename name="approval"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="approval_date_time"
    >
      <explicit
        name="date_time">
        <typename name="date_time_select"/>
      </explicit>
      <explicit
        name="dated_approval">
        <typename name="approval"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="approval_person_organization"
    >
      <explicit
        name="person_organization">
        <typename name="person_organization_select"/>
      </explicit>
      <explicit
        name="authorized_approval">
        <typename name="approval"/>
      </explicit>
      <explicit
        name="role">
        <typename name="approval_role"/>
      </explicit>
    </entity>

    <entity name="approval_role"
    >
      <explicit
        name="role">
        <typename name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="approval_status"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="area_in_set"
    >
      <explicit
        name="area">
        <typename name="presentation_area"/>
      </explicit>
      <explicit
        name="in_set">
        <typename name="presentation_set"/>
      </explicit>
    </entity>

    <entity name="area_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.AREA_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="area_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 2.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="asin_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="atan_function"
      supertypes="binary_function_call"
    >
    </entity>

    <entity name="atom_based_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <typename name="atom_based_value"/>
      </explicit>
    </entity>

    <entity name="axis2_placement_2d"
      supertypes="placement"
    >
      <explicit
        name="ref_direction"
        optional="YES">
        <typename name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="SELF\geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity name="b_spline_basis"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="degree">
        <typename name="nonnegative_integer"/>
      </explicit>
      <explicit
        name="repeated_knots">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <builtintype type="REAL"
        />
      </explicit>
      <derived
        name="order"
        expression="degree + 1">
        <typename name="positive_integer"/>
      </derived>
      <derived
        name="num_basis"
        expression="SIZEOF(repeated_knots) - order">
        <typename name="positive_integer"/>
      </derived>
      <where
        label="wr1"
        expression="num_basis &gt;= order">
      </where>
      <where
        label="wr2"
        expression="nondecreasing(repeated_knots)">
      </where>
      <where
        label="wr3"
        expression="repeated_knots[order] &lt; repeated_knots[num_basis + 1]">
      </where>
    </entity>

    <entity name="b_spline_curve"
      supertypes="bounded_curve"
      super.expression="ONEOF(uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve"
    >
      <explicit
        name="degree">
        <builtintype type="INTEGER"
        />
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype type="LOGICAL"
        />
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype type="LOGICAL"
        />
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype type="INTEGER"
        />
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(control_points_list, 0, upper_index_on_control_points)">
        <aggregate type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"
        />
        <typename name="cartesian_point"/>
      </derived>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.UNIFORM_CURVE&apos; IN TYPEOF(SELF)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.QUASI_UNIFORM_CURVE&apos; IN TYPEOF(SELF)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.BEZIER_CURVE&apos; IN TYPEOF(SELF)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS&apos; IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="b_spline_curve_with_knots"
      supertypes="b_spline_curve"
    >
      <explicit
        name="knot_multiplicities">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <builtintype type="INTEGER"
        />
      </explicit>
      <explicit
        name="knots">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype type="INTEGER"
        />
      </derived>
      <where
        label="wr1"
        expression="constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(knot_multiplicities) = upper_index_on_knots">
      </where>
    </entity>

    <entity name="b_spline_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="basis">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="b_spline_basis"/>
      </explicit>
      <derived
        name="coef"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="function_is_table(coef)">
      </where>
      <where
        label="wr2"
        expression="(space_dimension(coef.range) = 1) AND (number_superspace_of(factor1(coef.range)) = the_reals)">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(basis) &lt;= SIZEOF(shape_of_array(coef))">
      </where>
      <where
        label="wr4"
        expression="compare_basis_and_coef(basis, coef)">
      </where>
    </entity>

    <entity name="basic_sparse_matrix"
      supertypes="explicit_table_function multiple_arity_generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="3"
          upper="3"
        />
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </explicit>
      <explicit
        name="default_entry">
        <typename name="maths_value"/>
      </explicit>
      <explicit
        name="order">
        <typename name="ordering_type"/>
      </explicit>
      <derived
        name="index"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename name="maths_function"/>
      </derived>
      <derived
        name="loc"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename name="maths_function"/>
      </derived>
      <derived
        name="val"
        expression="SELF\multiple_arity_generic_expression.operands[3]">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="function_is_1d_table(index)">
      </where>
      <where
        label="wr2"
        expression="function_is_1d_table(loc)">
      </where>
      <where
        label="wr3"
        expression="function_is_1d_table(val)">
      </where>
      <where
        label="wr4"
        expression="check_sparse_index_domain(index.domain, index_base, shape, order)">
      </where>
      <where
        label="wr5"
        expression="check_sparse_index_to_loc(index.range, loc.domain)">
      </where>
      <where
        label="wr6"
        expression="loc.domain = val.domain">
      </where>
      <where
        label="wr7"
        expression="check_sparse_loc_range(loc.range, index_base, shape, order)">
      </where>
      <where
        label="wr8"
        expression="member_of(default_entry, val.range)">
      </where>
    </entity>

    <entity name="bezier_curve"
      supertypes="b_spline_curve"
    >
    </entity>

    <entity name="binary_boolean_expression"
      abstract.supertype="YES"
      supertypes="boolean_expression binary_generic_expression"
      super.expression="ONEOF(xor_expression, equals_expression)"
    >
    </entity>

    <entity name="binary_function_call"
      abstract.supertype="YES"
      supertypes="binary_numeric_expression"
      super.expression="ONEOF(atan_function)"
    >
    </entity>

    <entity name="binary_generic_expression"
      abstract.supertype="YES"
      supertypes="generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="generic_expression"/>
      </explicit>
    </entity>

    <entity name="binary_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <builtintype type="BINARY"
        />
      </explicit>
    </entity>

    <entity name="binary_numeric_expression"
      abstract.supertype="YES"
      supertypes="numeric_expression binary_generic_expression"
      super.expression="ONEOF(minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="numeric_expression"/>
        <redeclaration
          entity-ref="binary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="boolean_defined_function"
      abstract.supertype="YES"
      supertypes="defined_function boolean_expression"
    >
    </entity>

    <entity name="boolean_expression"
      abstract.supertype="YES"
      supertypes="expression"
      super.expression="ONEOF(simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function)"
    >
    </entity>

    <entity name="boolean_literal"
      supertypes="simple_boolean_expression generic_literal"
    >
      <explicit
        name="the_value">
        <builtintype type="BOOLEAN"
        />
      </explicit>
    </entity>

    <entity name="boolean_variable"
      supertypes="simple_boolean_expression variable"
    >
    </entity>

    <entity name="bounded_curve"
      supertypes="curve"
      super.expression="ONEOF(polyline, b_spline_curve, trimmed_curve, composite_curve)"
    >
    </entity>

    <entity name="calendar_date"
      supertypes="date"
    >
      <explicit
        name="day_component">
        <typename name="day_in_month_number"/>
      </explicit>
      <explicit
        name="month_component">
        <typename name="month_in_year_number"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_calendar_date(SELF)">
      </where>
    </entity>

    <entity name="camera_image"
      supertypes="mapped_item"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.CAMERA_USAGE&apos; IN TYPEOF(SELF\mapped_item.mapping_source)">
      </where>
      <where
        label="wr2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.PLANAR_BOX&apos; IN TYPEOF(SELF\mapped_item.mapping_target)">
      </where>
      <where
        label="wr3"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM&apos; IN TYPEOF(SELF)">
      </where>
    </entity>

    <entity name="cardinality_of_related_class"
      supertypes="maths_space_context"
    >
      <explicit
        name="physical_space">
        <typename name="relationship_select"/>
        <redeclaration
          entity-ref="maths_space_context"/>
      </explicit>
    </entity>

    <entity name="cardinality_of_relating_class"
      supertypes="maths_space_context"
    >
      <explicit
        name="physical_space">
        <typename name="relationship_select"/>
        <redeclaration
          entity-ref="maths_space_context"/>
      </explicit>
    </entity>

    <entity name="cartesian_complex_number_region"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="real_constraint">
        <typename name="real_interval"/>
      </explicit>
      <explicit
        name="imag_constraint">
        <typename name="real_interval"/>
      </explicit>
      <where
        label="wr1"
        expression="min_exists(real_constraint) OR max_exists(real_constraint) OR min_exists(imag_constraint) OR max_exists(imag_constraint)">
      </where>
    </entity>

    <entity name="cartesian_point"
      supertypes="point"
    >
      <explicit
        name="coordinates">
        <aggregate type="LIST"
          lower="1"
          upper="3"
        />
        <typename name="length_measure"/>
      </explicit>
    </entity>

    <entity name="cartesian_transformation_operator"
      supertypes="geometric_representation_item functionally_defined_transformation"
    >
      <explicit
        name="axis1"
        optional="YES">
        <typename name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype type="REAL"
        />
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale, 1.000000)">
        <builtintype type="REAL"
        />
      </derived>
      <where
        label="wr1"
        expression="scl &gt; 0.000000">
      </where>
    </entity>

    <entity name="celsius_temperature_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="circle"
      supertypes="conic"
    >
      <explicit
        name="radius">
        <typename name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity name="class"
      supertypes="group"
      super.expression="ONEOF(class_by_extension, class_by_intension)"
    >
    </entity>

    <entity name="class_by_extension"
      supertypes="class"
    >
    </entity>

    <entity name="class_by_intension"
      supertypes="class"
    >
    </entity>

    <entity name="class_of_activity"
      supertypes="executed_action class"
    >
    </entity>

    <entity name="class_of_composition_of_activity"
      supertypes="action_relationship class"
    >
      <explicit
        name="relating_action">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
      <explicit
        name="related_action">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_composition_of_product"
      supertypes="product_definition_formation_relationship class"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_connection_of_activity"
      supertypes="action_relationship class"
    >
      <explicit
        name="relating_action">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
      <explicit
        name="related_action">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_connection_of_product"
      supertypes="product_definition_formation_relationship class"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_connection_of_product_with_involvements"
      supertypes="class_of_connection_of_product class_of_product"
    >
    </entity>

    <entity name="class_of_containment_of_product"
      supertypes="product_definition_formation_relationship class"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_involvement_in_activity"
      supertypes="applied_action_assignment class"
    >
      <explicit
        name="assigned_action">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_assignment"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="1"
        />
        <typename name="involved_class_select"/>
        <redeclaration
          entity-ref="applied_action_assignment"/>
      </explicit>
    </entity>

    <entity name="class_of_involvement_of_product_in_connection"
      supertypes="product_definition_formation_relationship class"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="class_of_connection_of_product_with_involvements"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="class_of_product"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="class_of_person"
      supertypes="person_type class"
    >
    </entity>

    <entity name="class_of_possession_of_property_by_activity"
      supertypes="action_property"
    >
      <explicit
        name="definition">
        <typename name="class_of_activity"/>
        <redeclaration
          entity-ref="action_property"/>
      </explicit>
    </entity>

    <entity name="class_of_possession_of_property_by_product"
      supertypes="property_definition"
    >
      <where
        label="link_to_class"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.CLASS_OF_PRODUCT&apos; IN TYPEOF(SELF\property_definition.definition.formation)">
      </where>
    </entity>

    <entity name="class_of_product"
      supertypes="product_definition_formation class"
    >
    </entity>

    <entity name="classification"
      supertypes="applied_classification_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="1"
        />
        <typename name="classification_select"/>
        <redeclaration
          entity-ref="applied_classification_assignment"/>
      </explicit>
      <derived
        name="classified"
        expression="SELF\applied_classification_assignment.items[1]">
        <typename name="classification_select"/>
      </derived>
      <derived
        name="classifier"
        expression="SELF\classification_assignment.assigned_class">
        <typename name="class"/>
      </derived>
    </entity>

    <entity name="classification_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_class">
        <typename name="group"/>
      </explicit>
      <explicit
        name="role">
        <typename name="classification_role"/>
      </explicit>
    </entity>

    <entity name="classification_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="colour"
    >
    </entity>

    <entity name="colour_rgb"
      supertypes="colour_specification"
    >
      <explicit
        name="red">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="green">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="blue">
        <builtintype type="REAL"
        />
      </explicit>
      <where
        label="wr1"
        expression="{0.000000 &lt;= red &lt;= 1.000000}">
      </where>
      <where
        label="wr2"
        expression="{0.000000 &lt;= green &lt;= 1.000000}">
      </where>
      <where
        label="wr3"
        expression="{0.000000 &lt;= blue &lt;= 1.000000}">
      </where>
    </entity>

    <entity name="colour_specification"
      supertypes="colour"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="comparison_equal"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="comparison_expression"
      abstract.supertype="YES"
      supertypes="boolean_expression binary_generic_expression"
      super.expression="ONEOF(comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="expression"/>
        <redeclaration
          entity-ref="binary_generic_expression"/>
      </explicit>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[2])) OR (&apos;FUNCTIONAL_DATA_MIM_LF.BOOLEAN_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND (&apos;FUNCTIONAL_DATA_MIM_LF.BOOLEAN_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[2])) OR (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[2]))">
      </where>
    </entity>

    <entity name="comparison_greater"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="comparison_greater_equal"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="comparison_less"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="comparison_less_equal"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="comparison_not_equal"
      supertypes="comparison_expression"
    >
    </entity>

    <entity name="complement"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="set_1">
        <typename name="class"/>
      </explicit>
      <explicit
        name="set_2">
        <typename name="class"/>
      </explicit>
      <explicit
        name="universe">
        <typename name="class"/>
      </explicit>
      <where
        label="complement_different"
        expression="NOT identical_sets(set_1, set_2)">
      </where>
    </entity>

    <entity name="complete_membership"
      supertypes="classification_assignment"
    >
      <explicit
        name="members">
        <aggregate type="SET"
        />
        <typename name="complete_membership_select"/>
      </explicit>
      <derived
        name="containing_set"
        expression="SELF\classification_assignment.assigned_class">
        <typename name="class"/>
      </derived>
    </entity>

    <entity name="complex_number_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="real_part">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="imag_part">
        <builtintype type="REAL"
        />
      </explicit>
    </entity>

    <entity name="composite_curve"
      supertypes="bounded_curve"
    >
      <explicit
        name="segments">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype type="LOGICAL"
        />
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype type="INTEGER"
        />
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt; discontinuous">
        <builtintype type="LOGICAL"
        />
      </derived>
      <where
        label="wr1"
        expression="NOT closed_curve AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 1) OR closed_curve AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 0)">
      </where>
    </entity>

    <entity name="composite_curve_segment"
      supertypes="founded_item"
    >
      <explicit
        name="transition">
        <typename name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <explicit
        name="parent_curve">
        <typename name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"
        />
      </inverse>
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.BOUNDED_CURVE&apos; IN TYPEOF(parent_curve)">
      </where>
    </entity>

    <entity name="composite_text"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="collected_text">
        <aggregate type="SET"
          lower="2"
          upper="?"
        />
        <typename name="text_or_character"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_composite_text(SELF, SELF.collected_text)">
      </where>
    </entity>

    <entity name="composite_text_with_associated_curves"
      supertypes="composite_text"
    >
      <explicit
        name="associated_curves">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="curve"/>
      </explicit>
    </entity>

    <entity name="composite_text_with_blanking_box"
      supertypes="composite_text"
    >
      <explicit
        name="blanking">
        <typename name="planar_box"/>
      </explicit>
    </entity>

    <entity name="composite_text_with_extent"
      supertypes="composite_text"
    >
      <explicit
        name="extent">
        <typename name="planar_extent"/>
      </explicit>
    </entity>

    <entity name="composition_of_individual_activity"
      supertypes="action_relationship"
    >
      <explicit
        name="relating_action">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
      <explicit
        name="related_action">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
    </entity>

    <entity name="composition_of_individual_product"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="composition_of_schematic_element_occurrence"
      supertypes="mapped_item"
    >
      <where
        label="schematic_element_occurrence_as_part"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="schematic_element_occurrence_as_whole"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(using_representations(SELF))">
      </where>
    </entity>

    <entity name="compound_maths_space_context"
      supertypes="maths_space_context"
    >
      <explicit
        name="components">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="maths_space_context"/>
      </explicit>
    </entity>

    <entity name="concat_expression"
      supertypes="string_expression multiple_arity_generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="string_expression"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="condition_property"
      supertypes="general_property_association"
    >
      <explicit
        name="base_definition">
        <typename name="physical_quantity_range"/>
        <redeclaration
          entity-ref="general_property_association"/>
      </explicit>
      <where
        label="link_to_condition"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.PROPERTY_CONDITION_FOR_ACTIVITY&apos; IN TYPEOF(SELF\general_property_association.derived_definition)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.PROPERTY_CONDITION_FOR_PRODUCT&apos; IN TYPEOF(SELF\general_property_association.derived_definition))">
      </where>
    </entity>

    <entity name="conic"
      supertypes="curve"
      super.expression="ONEOF(circle, ellipse, hyperbola, parabola)"
    >
      <explicit
        name="position">
        <typename name="axis2_placement"/>
      </explicit>
    </entity>

    <entity name="connection_of_individual_activity"
      supertypes="action_relationship"
    >
      <explicit
        name="relating_action">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
      <explicit
        name="related_action">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_relationship"/>
      </explicit>
    </entity>

    <entity name="connection_of_individual_product"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="connection_of_individual_product_with_involvements"
      supertypes="connection_of_individual_product product_as_individual"
    >
    </entity>

    <entity name="connection_of_schematic_element_occurrence"
      supertypes="mapped_item"
    >
      <where
        label="schematic_element_occurrence_as_side_1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="schematic_element_occurrence_as_side_2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(using_representations(SELF))">
      </where>
    </entity>

    <entity name="constant_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="sole_output">
        <typename name="maths_value"/>
      </explicit>
      <explicit
        name="source_of_domain">
        <typename name="maths_space_or_function"/>
      </explicit>
      <where
        label="wr1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="wr2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
    </entity>

    <entity name="containment_of_individual_product"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="context_dependent_invisibility"
      supertypes="invisibility"
    >
      <explicit
        name="presentation_context">
        <typename name="invisibility_context"/>
      </explicit>
    </entity>

    <entity name="context_dependent_unit"
      supertypes="named_unit"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="contract"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename name="contract_type"/>
      </explicit>
    </entity>

    <entity name="contract_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_contract">
        <typename name="contract"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="contract_type"
    >
      <explicit
        name="description">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="conversion_based_unit"
      supertypes="named_unit"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="conversion_factor">
        <typename name="measure_with_unit"/>
      </explicit>
    </entity>

    <entity name="cos_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="curve"
      supertypes="geometric_representation_item"
      super.expression="ONEOF(line, conic, offset_curve_2d, curve_replica)"
    >
    </entity>

    <entity name="curve_replica"
      supertypes="curve"
    >
      <explicit
        name="parent_curve">
        <typename name="curve"/>
      </explicit>
      <explicit
        name="transformation">
        <typename name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="wr1"
        expression="transformation.dim = parent_curve.dim">
      </where>
      <where
        label="wr2"
        expression="acyclic_curve_replica(SELF, parent_curve)">
      </where>
    </entity>

    <entity name="curve_style"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="curve_font">
        <typename name="curve_font_or_scaled_curve_font_select"/>
      </explicit>
      <explicit
        name="curve_width">
        <typename name="size_select"/>
      </explicit>
      <explicit
        name="curve_colour">
        <typename name="colour"/>
      </explicit>
    </entity>

    <entity name="curve_style_font"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="pattern_list">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="curve_style_font_pattern"/>
      </explicit>
    </entity>

    <entity name="curve_style_font_pattern"
    >
      <explicit
        name="visible_segment_length">
        <typename name="positive_length_measure"/>
      </explicit>
      <explicit
        name="invisible_segment_length">
        <typename name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity name="date"
      super.expression="calendar_date"
    >
      <explicit
        name="year_component">
        <typename name="year_number"/>
      </explicit>
    </entity>

    <entity name="defined_function"
      abstract.supertype="YES"
      super.expression="ONEOF(numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR sql_mappable_defined_function"
    >
    </entity>

    <entity name="defined_maths_space_context"
      supertypes="maths_space_context"
    >
    </entity>

    <entity name="defined_symbol"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="definition">
        <typename name="defined_symbol_select"/>
      </explicit>
      <explicit
        name="target">
        <typename name="symbol_target"/>
      </explicit>
    </entity>

    <entity name="definite_integral_expression"
      supertypes="quantifier_expression"
    >
      <explicit
        name="lower_limit_neg_infinity">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <explicit
        name="upper_limit_pos_infinity">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <derived
        name="integrand"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="variable_of_integration"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename name="maths_variable"/>
      </derived>
      <derived
        name="variables"
        expression="[variable_of_integration]">
        <aggregate type="LIST"
          unique="YES"
          lower="1"
          upper="1"
        />
        <typename name="generic_variable"/>
        <redeclaration
          entity-ref="quantifier_expression"/>
      </derived>
      <where
        label="wr1"
        expression="has_values_space(integrand)">
      </where>
      <where
        label="wr2"
        expression="space_is_continuum(values_space_of(integrand))">
      </where>
      <where
        label="wr3"
        expression="definite_integral_expr_check(SELF\multiple_arity_generic_expression.operands, lower_limit_neg_infinity, upper_limit_pos_infinity)">
      </where>
    </entity>

    <entity name="definite_integral_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="variable_of_integration">
        <typename name="input_selector"/>
      </explicit>
      <explicit
        name="lower_limit_neg_infinity">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <explicit
        name="upper_limit_pos_infinity">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <derived
        name="integrand"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="space_is_continuum(integrand.range)">
      </where>
      <where
        label="wr2"
        expression="definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity, upper_limit_pos_infinity)">
      </where>
    </entity>

    <entity name="definition_of_schematic_element_occurrence"
      supertypes="mapped_item"
    >
      <where
        label="schematic_element_as_superset"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="schematic_element_occurrence_as_subset"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(using_representations(SELF))">
      </where>
    </entity>

    <entity name="derivation_of_schematic_element_definition"
      supertypes="mapped_item"
    >
      <where
        label="schematic_element_definition_as_base"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_DEFINITION&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="implicit_schematic_element_definition_as_derived"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;IMPLICIT_SCHEMATIC_ELEMENT_DEFINITION&apos; IN TYPEOF(using_representations(SELF))">
      </where>
    </entity>

    <entity name="derived_unit"
    >
      <explicit
        name="elements">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="derived_unit_element"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename name="label"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(elements) &gt; 1) OR (SIZEOF(elements) = 1) AND (elements[1].exponent &lt;&gt; 1.000000)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="derived_unit_element"
    >
      <explicit
        name="unit">
        <typename name="named_unit"/>
      </explicit>
      <explicit
        name="exponent">
        <builtintype type="REAL"
        />
      </explicit>
    </entity>

    <entity name="description_attribute"
    >
      <explicit
        name="attribute_value">
        <typename name="text"/>
      </explicit>
      <explicit
        name="described_item">
        <typename name="description_attribute_select"/>
      </explicit>
    </entity>

    <entity name="descriptive_representation_item"
      supertypes="representation_item"
    >
      <explicit
        name="description">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="dimensional_exponents"
    >
      <explicit
        name="length_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="mass_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="time_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="electric_current_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="thermodynamic_temperature_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="amount_of_substance_exponent">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="luminous_intensity_exponent">
        <builtintype type="REAL"
        />
      </explicit>
    </entity>

    <entity name="direction"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="direction_ratios">
        <aggregate type="LIST"
          lower="2"
          upper="3"
        />
        <builtintype type="REAL"
        />
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.000000)) &gt; 0">
      </where>
    </entity>

    <entity name="div_expression"
      supertypes="binary_numeric_expression"
    >
    </entity>

    <entity name="document"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename name="document_type"/>
      </explicit>
      <inverse
        name="representation_types"
        entity="document_representation_type"
        attribute="represented_document">
        <inverse.aggregate
          type="SET"
        />
      </inverse>
    </entity>

    <entity name="document_reference"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_document">
        <typename name="document"/>
      </explicit>
      <explicit
        name="source">
        <typename name="label"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="document_representation_type"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="represented_document">
        <typename name="document"/>
      </explicit>
    </entity>

    <entity name="document_type"
    >
      <explicit
        name="product_data_type">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="draughting_annotation_occurrence"
      supertypes="annotation_occurrence"
    >
      <where
        label="wr1"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_CURVE_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(QUERY(sty &lt;* SELF.styles | NOT ((SIZEOF(sty.styles) = 1) AND (&apos;FUNCTIONAL_DATA_MIM_LF.CURVE_STYLE&apos; IN TYPEOF(sty.styles[1]))))) = 0)">
      </where>
      <where
        label="wr2"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(QUERY(sty &lt;* SELF.styles | NOT ((SIZEOF(sty.styles) = 1) AND (&apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE&apos; IN TYPEOF(sty.styles[1]))))) = 0)">
      </where>
      <where
        label="wr3"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(QUERY(bound &lt;* SELF.item\annotation_fill_area.boundaries | NOT (SIZEOF(QUERY(si &lt;* USEDIN(bound, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM.ITEM&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;ANNOTATION_CURVE_OCCURRENCE&apos; IN TYPEOF(si))) &gt; 0))) = 0)">
      </where>
      <where
        label="wr4"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(QUERY(sty &lt;* SELF.styles | NOT ((SIZEOF(sty.styles) = 1) AND (SIZEOF(TYPEOF(sty.styles[1]) * [&apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_STYLE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.NULL_STYLE&apos;]) = 1)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL&apos; IN TYPEOF(SELF.item))) OR (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DRAUGHTING_SYMBOL_REPRESENTATION&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DRAUGHTING_SUBFIGURE_REPRESENTATION&apos;] * TYPEOF(SELF.item\mapped_item.mapping_source.mapped_representation)) = 1)">
      </where>
      <where
        label="wr6"
        expression="NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(QUERY(sty &lt;* SELF.styles | NOT ((SIZEOF(sty.styles) = 1) AND (&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_STYLE&apos; IN TYPEOF(sty.styles[1]))))) = 0)">
      </where>
      <where
        label="wr7"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) OR (SIZEOF(TYPEOF(SELF.item) * [&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos;]) = 1)">
      </where>
      <where
        label="wr8"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(SELF.item))) OR (SIZEOF(QUERY(tl &lt;* SELF.item\composite_text.collected_text | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos; IN TYPEOF(tl)))) = 0)">
      </where>
      <where
        label="wr9"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos; IN TYPEOF(SELF.item))) OR (SELF.item\text_literal.alignment IN [&apos;baseline left&apos;, &apos;baseline centre&apos;, &apos;baseline right&apos;])">
      </where>
      <where
        label="wr10"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(SELF.item))) OR (SIZEOF(QUERY(tl &lt;* QUERY(text &lt;* SELF.item\composite_text.collected_text | &apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos; IN TYPEOF(text)) | NOT (tl\text_literal.alignment IN [&apos;baseline left&apos;, &apos;baseline centre&apos;, &apos;baseline right&apos;]))) = 0)">
      </where>
      <where
        label="wr11"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(SELF.item))) OR check_text_alignment(SELF.item)">
      </where>
      <where
        label="wr12"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(SELF.item))) OR check_text_font(SELF.item)">
      </where>
      <where
        label="wr13"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(SELF.item))) OR (SIZEOF(QUERY(tl &lt;* QUERY(text &lt;* SELF.item\composite_text.collected_text | &apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL&apos; IN TYPEOF(text)) | NOT (SIZEOF(TYPEOF(tl) * [&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;TEXT_LITERAL_WITH_BLANKING_BOX&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;TEXT_LITERAL_WITH_ASSOCIATED_CURVES&apos;]) = 0))) = 0)">
      </where>
      <where
        label="wr14"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.TEXT_LITERAL_WITH_ASSOCIATED_CURVES&apos; IN TYPEOF(SELF.item))) OR (SIZEOF(QUERY(crv &lt;* SELF.item\text_literal_with_associated_curves.associated_curves | NOT (SIZEOF(QUERY(si &lt;* USEDIN(crv, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM.ITEM&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_CURVE_OCCURRENCE&apos; IN TYPEOF(si))) &gt; 0))) = 0)">
      </where>
      <where
        label="wr15"
        expression="NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos; IN TYPEOF(SELF)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES&apos; IN TYPEOF(SELF.item))) OR (SIZEOF(QUERY(crv &lt;* SELF.item\composite_text_with_associated_curves.associated_curves | NOT (SIZEOF(QUERY(si &lt;* USEDIN(crv, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM.ITEM&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_CURVE_OCCURRENCE&apos; IN TYPEOF(si))) &gt; 0))) = 0)">
      </where>
      <where
        label="wr16"
        expression="SIZEOF(QUERY(cs &lt;* QUERY(sty &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.CURVE_STYLE&apos; IN TYPEOF(sty.styles[1])) | NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.LENGTH_MEASURE_WITH_UNIT&apos; IN TYPEOF(cs.styles[1]\curve_style.curve_width)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.POSITIVE_LENGTH_MEASURE&apos; IN TYPEOF(cs.styles[1]\curve_style.curve_width\measure_with_unit.value_component))))) = 0">
      </where>
      <where
        label="wr17"
        expression="SIZEOF(QUERY(fas &lt;* QUERY(sty &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE&apos; IN TYPEOF(sty.styles[1])) | NOT ((SIZEOF(QUERY(fs &lt;* fas.styles[1]\fill_area_style.fill_styles | &apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE_TILES&apos; IN TYPEOF(fs))) &lt;= 1) AND (SIZEOF(QUERY(fst &lt;* QUERY(fs &lt;* fas.styles[1]\fill_area_style.fill_styles | &apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE_TILES&apos; IN TYPEOF(fs)) | NOT (SIZEOF(fst\fill_area_style_tiles.tiles) = 1))) = 0)))) = 0">
      </where>
      <where
        label="wr18"
        expression="SIZEOF(QUERY(fas &lt;* QUERY(sty &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE&apos; IN TYPEOF(sty.styles[1])) | NOT (SIZEOF(QUERY(fsh &lt;* QUERY(fs &lt;* fas.styles[1]\fill_area_style.fill_styles | &apos;FUNCTIONAL_DATA_MIM_LF.FILL_AREA_STYLE_HATCHING&apos; IN TYPEOF(fs)) | NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=: fsh\fill_area_style_hatching.pattern_start))) = 0))) = 0">
      </where>
      <where
        label="wr19"
        expression="SIZEOF(QUERY(ts &lt;* QUERY(sty &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.TEXT_STYLE&apos; IN TYPEOF(sty.styles[1])) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;TEXT_STYLE_WITH_BOX_CHARACTERISTICS&apos; IN TYPEOF(ts.styles[1])))) = 0">
      </where>
      <where
        label="wr20"
        expression="SIZEOF(QUERY(ts &lt;* QUERY(sty &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.TEXT_STYLE_WITH_BOX_CHARACTERISTICS&apos; IN TYPEOF(sty.styles[1])) | NOT (SIZEOF(ts.styles[1]\text_style_with_box_characteristics.characteristics) = 4))) = 0">
      </where>
    </entity>

    <entity name="draughting_approval_assignment"
      supertypes="approval_assignment"
    >
      <explicit
        name="approved_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="approved_item"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(item &lt;* approved_items | &apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_REVISION&apos; IN TYPEOF(item))) &lt;= 1">
      </where>
    </entity>

    <entity name="draughting_callout"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="contents">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_callout_element"/>
      </explicit>
    </entity>

    <entity name="draughting_contract_assignment"
      supertypes="contract_assignment"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="contracted_item"/>
      </explicit>
    </entity>

    <entity name="draughting_drawing_revision"
      supertypes="drawing_revision"
    >
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;)) &gt;= 1) AND (SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_SHEET_REVISION&apos; IN TYPEOF(ais.area)))) = 0)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(app_ass &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS&apos;) | NOT (SIZEOF(USEDIN(app_ass.assigned_approval, &apos;FUNCTIONAL_DATA_MIM_LF.APPROVAL_DATE_TIME.DATED_APPROVAL&apos;)) = 1))) = 0">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(app_ass &lt;* USEDIN(ais.area, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS&apos;) | NOT (SIZEOF(USEDIN(app_ass.assigned_approval, &apos;FUNCTIONAL_DATA_MIM_LF.APPROVAL_DATE_TIME.DATED_APPROVAL&apos;)) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr4"
        expression="SIZEOF(QUERY(app_ass &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS&apos;) | NOT (SIZEOF(USEDIN(app_ass.assigned_approval, &apos;FUNCTIONAL_DATA_MIM_LF.APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL&apos;)) &gt;= 1))) = 0">
      </where>
      <where
        label="wr5"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(app_ass &lt;* USEDIN(ais.area, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS&apos;) | NOT (SIZEOF(USEDIN(app_ass.assigned_approval, &apos;FUNCTIONAL_DATA_MIM_LF.APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL&apos;)) &gt;= 1))) = 0))) = 0">
      </where>
      <where
        label="wr6"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_TITLE.ITEMS&apos;)) &lt;= 1">
      </where>
      <where
        label="wr7"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(USEDIN(ais.area, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_TITLE.ITEMS&apos;)) &lt;= 1))) = 0">
      </where>
      <where
        label="wr8"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(item &lt;* ais.area.items | NOT (SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.PLANAR_BOX&apos;]) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr9"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(item &lt;* ais.area.items | SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos;]) = 1)) &gt; 0))) = 0">
      </where>
      <where
        label="wr10"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(p_b &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.PLANAR_BOX&apos; IN TYPEOF(item)) | NOT (SIZEOF(USEDIN(p_b, &apos;FUNCTIONAL_DATA_MIM_LF.PRESENTATION_SIZE.SIZE&apos;)) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr11"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.PRESENTATION_VIEW&apos; IN TYPEOF(mi.mapping_source.mapped_representation)))) = 0))) = 0">
      </where>
      <where
        label="wr12"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(a2p &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos; IN TYPEOF(item)) | NOT (SIZEOF(USEDIN(a2p, &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM.MAPPING_TARGET&apos;)) &gt; 0))) = 0))) = 0">
      </where>
      <where
        label="wr13"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(ais.area.context_of_items.representations_in_context) = 1))) = 0">
      </where>
      <where
        label="wr14"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (SIZEOF(USEDIN(mi.mapping_source.mapped_representation, &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION&apos;)) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr15"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(pv_item &lt;* mi.mapping_source.mapped_representation.items | NOT (SIZEOF(TYPEOF(pv_item) * [&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;STYLED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.CAMERA_IMAGE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;AXIS2_PLACEMENT&apos;]) = 1))) = 0))) = 0))) = 0">
      </where>
      <where
        label="wr16"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(pv_item &lt;* mi.mapping_source.mapped_representation.items | &apos;FUNCTIONAL_DATA_MIM_LF.CAMERA_IMAGE&apos; IN TYPEOF(pv_item))) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr17"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(a2p &lt;* QUERY(pv_item &lt;* mi.mapping_source.mapped_representation.items | &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos; IN TYPEOF(pv_item)) | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;REPRESENTATION_MAP.MAPPING_SOURCE&apos; IN ROLESOF(a2p))) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr18"
        expression="SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.IN_SET&apos;) | NOT (SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* ais.area.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (SIZEOF(mi.mapping_source.mapped_representation.context_of_items.representations_in_context) = 1))) = 0))) = 0">
      </where>
    </entity>

    <entity name="draughting_model"
      supertypes="representation"
    >
      <unique
        label="unique_id">
        <unique.attribute
          entity-ref="representation"
          attribute="name"/>
      </unique>
      <where
        label="valid_draughting_model_items"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | NOT (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos;] * TYPEOF(it)) = 1))) = 0">
      </where>
      <where
        label="valid_mapped_items"
        expression="SIZEOF(QUERY(mi &lt;* QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(it)) | NOT (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.SHAPE_REPRESENTATION&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_MODEL&apos;] * TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) = 1))) = 0">
      </where>
      <where
        label="valid_use_of_style"
        expression="SIZEOF(QUERY(smi &lt;* QUERY(si &lt;* QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos; IN TYPEOF(it)) | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(si\styled_item.item)) | NOT ((&apos;FUNCTIONAL_DATA_MIM_LF.SHAPE_REPRESENTATION&apos; IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(sty &lt;* smi\styled_item.styles | NOT (SIZEOF(QUERY(psa &lt;* sty.styles | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.CURVE_STYLE&apos; IN TYPEOF(psa)))) = 1))) = 1)))) = 0">
      </where>
    </entity>

    <entity name="draughting_organization_assignment"
      supertypes="organization_assignment"
    >
      <explicit
        name="assigned_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_organization_item"/>
      </explicit>
    </entity>

    <entity name="draughting_person_and_organization_assignment"
      supertypes="person_and_organization_assignment"
    >
      <explicit
        name="assigned_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_organization_item"/>
      </explicit>
    </entity>

    <entity name="draughting_person_assignment"
      supertypes="person_assignment"
    >
      <explicit
        name="assigned_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_organization_item"/>
      </explicit>
    </entity>

    <entity name="draughting_presented_item"
      supertypes="presented_item"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_presented_item_select"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(pir &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.PRESENTED_ITEM_REPRESENTATION.ITEM&apos;) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_REVISION&apos; IN TYPEOF(pir.presentation)))) = 0">
      </where>
    </entity>

    <entity name="draughting_security_classification_assignment"
      supertypes="security_classification_assignment"
    >
      <explicit
        name="assigned_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="classified_item"/>
      </explicit>
    </entity>

    <entity name="draughting_specification_reference"
      supertypes="document_reference"
    >
      <explicit
        name="specified_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="specified_item"/>
      </explicit>
      <where
        label="wr1"
        expression="SELF.assigned_document.kind.product_data_type = &apos;draughting specification&apos;">
      </where>
    </entity>

    <entity name="draughting_subfigure_representation"
      supertypes="symbol_representation"
    >
      <where
        label="wr1"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | NOT (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_CALLOUT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos;] * TYPEOF(item)) = 1))) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_CALLOUT&apos;] * TYPEOF(item)) = 1)) &gt;= 1">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(QUERY(srm &lt;* QUERY(rm &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_REPRESENTATION_MAP&apos; IN TYPEOF(rm)) | NOT (SIZEOF(QUERY(a_s &lt;* QUERY(mi &lt;* srm.map_usage | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL&apos; IN TYPEOF(mi)) | NOT (SIZEOF(QUERY(aso &lt;* USEDIN(a_s, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM.ITEM&apos;) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE&apos; IN TYPEOF(aso)))) = 0))) = 0))) &gt; 0">
      </where>
      <where
        label="wr4"
        expression="NOT acyclic_mapped_item_usage(SELF)">
      </where>
      <where
        label="wr5"
        expression="SIZEOF(SELF.context_of_items.representations_in_context) = 1">
      </where>
    </entity>

    <entity name="draughting_symbol_representation"
      supertypes="symbol_representation"
    >
      <unique
        label="ur1">
        <unique.attribute
          entity-ref="representation"
          attribute="name"/>
      </unique>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | NOT (SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_CURVE_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos;]) = 1))) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_CURVE_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT_OCCURRENCE&apos;]) = 1)) &gt;= 1">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE&apos; IN TYPEOF(item))) = 0">
      </where>
      <where
        label="wr4"
        expression="SIZEOF(QUERY(srm &lt;* QUERY(rm &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_REPRESENTATION_MAP&apos; IN TYPEOF(rm)) | NOT (SIZEOF(QUERY(a_s &lt;* QUERY(mi &lt;* srm.map_usage | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL&apos; IN TYPEOF(mi)) | NOT (SIZEOF(QUERY(aso &lt;* USEDIN(a_s, &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM.ITEM&apos;) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE&apos; IN TYPEOF(aso)))) = 0))) = 0))) &gt; 0">
      </where>
      <where
        label="wr5"
        expression="NOT acyclic_mapped_item_usage(SELF)">
      </where>
      <where
        label="wr6"
        expression="SIZEOF(SELF.context_of_items.representations_in_context) = 1">
      </where>
    </entity>

    <entity name="draughting_text_literal_with_delineation"
      supertypes="text_literal_with_delineation"
    >
      <where
        label="wr1"
        expression="SELF.delineation IN [&apos;underline&apos;, &apos;overline&apos;]">
      </where>
    </entity>

    <entity name="draughting_title"
    >
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="draughting_titled_item"/>
      </explicit>
      <explicit
        name="language">
        <typename name="label"/>
      </explicit>
      <explicit
        name="contents">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="drawing_definition"
    >
      <explicit
        name="drawing_number">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="drawing_type"
        optional="YES">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="drawing_revision"
      supertypes="presentation_set"
    >
      <explicit
        name="revision_identifier">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="drawing_identifier">
        <typename name="drawing_definition"/>
      </explicit>
      <explicit
        name="intended_scale"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="revision_identifier"/>
        <unique.attribute
          attribute="drawing_identifier"/>
      </unique>
    </entity>

    <entity name="drawing_revision_class_of_document"
      supertypes="class product_definition_formation drawing_revision"
    >
      <where
        label="appropriate_category"
        expression="SELF.of_product.name = &apos;document&apos;">
      </where>
    </entity>

    <entity name="drawing_sheet_revision"
      supertypes="presentation_area"
    >
      <explicit
        name="revision_identifier">
        <typename name="identifier"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(item &lt;* SELF\representation.items | (&apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_SHEET_REVISION&apos; IN TYPEOF(item\mapped_item.mapping_source.mapped_representation)))) = 0">
      </where>
    </entity>

    <entity name="drawing_sheet_revision_class_of_document"
      supertypes="class product_definition_formation drawing_sheet_revision"
    >
      <where
        label="appropriate_category"
        expression="SELF.of_product.name = &apos;document&apos;">
      </where>
    </entity>

    <entity name="drawing_sheet_revision_usage"
      supertypes="area_in_set"
    >
      <explicit
        name="sheet_number">
        <typename name="identifier"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="sheet_number"/>
        <unique.attribute
          entity-ref="area_in_set"
          attribute="in_set"/>
      </unique>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_SHEET_REVISION&apos; IN TYPEOF(SELF\area_in_set.area)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.DRAWING_REVISION&apos; IN TYPEOF(SELF\area_in_set.in_set))">
      </where>
    </entity>

    <entity name="electric_current_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.ELECTRIC_CURRENT_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="electric_current_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="elementary_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="func_id">
        <typename name="elementary_function_enumerators"/>
      </explicit>
    </entity>

    <entity name="elementary_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="space_id">
        <typename name="elementary_space_enumerators"/>
      </explicit>
    </entity>

    <entity name="ellipse"
      supertypes="conic"
    >
      <explicit
        name="semi_axis_1">
        <typename name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity name="environment"
    >
      <explicit
        name="syntactic_representation">
        <typename name="generic_variable"/>
      </explicit>
      <explicit
        name="semantics">
        <typename name="variable_semantics"/>
      </explicit>
    </entity>

    <entity name="equals_expression"
      supertypes="binary_boolean_expression"
    >
    </entity>

    <entity name="executed_action"
      supertypes="action"
    >
    </entity>

    <entity name="exp_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="explicit_schematic_element_definition"
      supertypes="schematic_element_definition"
    >
      <where
        label="not_derived_or_defined_by_assembly"
        expression="(SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION&apos; IN TYPEOF(it))) = 0) AND (SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(it))) &gt;= 0)">
      </where>
    </entity>

    <entity name="explicit_table_function"
      abstract.supertype="YES"
      supertypes="maths_function"
      super.expression="ONEOF(listed_real_data, listed_integer_data, listed_logical_data, listed_string_data, listed_complex_number_data, listed_data, externally_listed_data, linearized_table_function, basic_sparse_matrix)"
    >
      <explicit
        name="index_base">
        <typename name="zero_or_one"/>
      </explicit>
      <explicit
        name="shape">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
      </explicit>
    </entity>

    <entity name="explicitly_enumerated_maths_space_context"
      supertypes="maths_space_context"
    >
      <explicit
        name="members">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="maths_value_context"/>
      </explicit>
    </entity>

    <entity name="expression"
      abstract.supertype="YES"
      supertypes="generic_expression"
      super.expression="ONEOF(numeric_expression, boolean_expression, string_expression)"
    >
    </entity>

    <entity name="expression_denoted_function"
      supertypes="maths_function unary_generic_expression"
    >
      <derived
        name="expr"
        expression="SELF\unary_generic_expression.operand">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="schema_prefix + &apos;FUNCTION_SPACE&apos; IN TYPEOF(values_space_of(expr))">
      </where>
    </entity>

    <entity name="extended_tuple_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="base">
        <typename name="product_space"/>
      </explicit>
      <explicit
        name="extender">
        <typename name="maths_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(base) AND expression_is_constant(extender)">
      </where>
      <where
        label="wr2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="wr3"
        expression="extender &lt;&gt; the_empty_space">
      </where>
    </entity>

    <entity name="external_identification_assignment"
      abstract.supertype="YES"
      supertypes="identification_assignment"
    >
      <explicit
        name="source">
        <typename name="external_source"/>
      </explicit>
    </entity>

    <entity name="external_source"
    >
      <explicit
        name="source_id">
        <typename name="source_item"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="externally_defined_curve_font"
      supertypes="externally_defined_item"
    >
    </entity>

    <entity name="externally_defined_hatch_style"
      supertypes="externally_defined_item geometric_representation_item"
    >
    </entity>

    <entity name="externally_defined_item"
    >
      <explicit
        name="item_id">
        <typename name="source_item"/>
      </explicit>
      <explicit
        name="source">
        <typename name="external_source"/>
      </explicit>
    </entity>

    <entity name="externally_defined_symbol"
      supertypes="externally_defined_item"
    >
    </entity>

    <entity name="externally_defined_text_font"
      supertypes="externally_defined_item"
    >
    </entity>

    <entity name="externally_defined_tile_style"
      supertypes="externally_defined_item geometric_representation_item"
    >
    </entity>

    <entity name="externally_listed_data"
      supertypes="explicit_table_function generic_literal externally_defined_item"
    >
      <explicit
        name="value_range">
        <typename name="maths_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(value_range)">
      </where>
    </entity>

    <entity name="fill_area_style"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="fill_styles">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="fill_style_select"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(fill_style &lt;* SELF.fill_styles | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;FILL_AREA_STYLE_COLOUR&apos; IN TYPEOF(fill_style))) &lt;= 1">
      </where>
    </entity>

    <entity name="fill_area_style_colour"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="fill_colour">
        <typename name="colour"/>
      </explicit>
    </entity>

    <entity name="fill_area_style_hatching"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="hatch_line_appearance">
        <typename name="curve_style"/>
      </explicit>
      <explicit
        name="start_of_next_hatch_line">
        <typename name="one_direction_repeat_factor"/>
      </explicit>
      <explicit
        name="point_of_reference_hatch_line">
        <typename name="cartesian_point"/>
      </explicit>
      <explicit
        name="pattern_start">
        <typename name="cartesian_point"/>
      </explicit>
      <explicit
        name="hatch_line_angle">
        <typename name="plane_angle_measure"/>
      </explicit>
    </entity>

    <entity name="fill_area_style_tile_symbol_with_style"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="symbol">
        <typename name="annotation_symbol_occurrence"/>
      </explicit>
    </entity>

    <entity name="fill_area_style_tiles"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="tiling_pattern">
        <typename name="two_direction_repeat_factor"/>
      </explicit>
      <explicit
        name="tiles">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="fill_area_style_tile_shape_select"/>
      </explicit>
      <explicit
        name="tiling_scale">
        <typename name="positive_ratio_measure"/>
      </explicit>
    </entity>

    <entity name="finite_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="pairs">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="maths_value"/>
      </explicit>
      <where
        label="wr1"
        expression="VALUE_UNIQUE(list_selected_components(pairs, 1))">
      </where>
    </entity>

    <entity name="finite_integer_interval"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="min">
        <builtintype type="INTEGER"
        />
      </explicit>
      <explicit
        name="max">
        <builtintype type="INTEGER"
        />
      </explicit>
      <derived
        name="size"
        expression="max - min + 1">
        <typename name="positive_integer"/>
      </derived>
      <where
        label="wr1"
        expression="min &lt;= max">
      </where>
    </entity>

    <entity name="finite_real_interval"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="min">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="min_closure">
        <typename name="open_closed"/>
      </explicit>
      <explicit
        name="max">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="max_closure">
        <typename name="open_closed"/>
      </explicit>
      <where
        label="wr1"
        expression="min &lt; max">
      </where>
    </entity>

    <entity name="finite_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="members">
        <aggregate type="SET"
        />
        <typename name="maths_value"/>
      </explicit>
      <where
        label="wr1"
        expression="VALUE_UNIQUE(members)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(expr &lt;* QUERY(member &lt;* members | &apos;FUNCTIONAL_DATA_MIM_LF.GENERIC_EXPRESSION&apos; IN TYPEOF(member)) | NOT expression_is_constant(expr))) = 0">
      </where>
      <where
        label="wr3"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
    </entity>

    <entity name="format_function"
      supertypes="string_expression binary_generic_expression"
    >
      <derived
        name="value_to_format"
        expression="SELF\binary_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="format_string"
        expression="SELF\binary_generic_expression.operands[2]">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(value_to_format)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(format_string))">
      </where>
    </entity>

    <entity name="founded_item"
    >
    </entity>

    <entity name="function_application"
      supertypes="multiple_arity_generic_expression"
    >
      <explicit
        name="func">
        <typename name="maths_function_select"/>
      </explicit>
      <explicit
        name="arguments">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_expression"/>
      </explicit>
      <derived
        name="operands"
        expression="">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="generic_expression"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="function_applicability(func, arguments)">
      </where>
    </entity>

    <entity name="function_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="domain_constraint">
        <typename name="space_constraint_type"/>
      </explicit>
      <explicit
        name="domain_argument">
        <typename name="maths_space"/>
      </explicit>
      <explicit
        name="range_constraint">
        <typename name="space_constraint_type"/>
      </explicit>
      <explicit
        name="range_argument">
        <typename name="maths_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(domain_argument) AND expression_is_constant(range_argument)">
      </where>
      <where
        label="wr2"
        expression="(domain_argument &lt;&gt; the_empty_space) AND (range_argument &lt;&gt; the_empty_space)">
      </where>
      <where
        label="wr3"
        expression="(domain_constraint &lt;&gt; sc_member) OR NOT member_of(the_empty_space, domain_argument)">
      </where>
      <where
        label="wr4"
        expression="(range_constraint &lt;&gt; sc_member) OR NOT member_of(the_empty_space, range_argument)">
      </where>
      <where
        label="wr5"
        expression="NOT (any_space_satisfies(domain_constraint, domain_argument) AND any_space_satisfies(range_constraint, range_argument))">
      </where>
    </entity>

    <entity name="functionally_defined_transformation"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="general_linear_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="sum_index">
        <typename name="one_or_two"/>
      </explicit>
      <derived
        name="mat"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="function_is_2d_table(mat)">
      </where>
      <where
        label="wr2"
        expression="(space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers)">
      </where>
    </entity>

    <entity name="general_property"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="general_property_association"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="base_definition">
        <typename name="general_property"/>
      </explicit>
      <explicit
        name="derived_definition">
        <typename name="derived_property_select"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(derived_definition, &apos;FUNCTIONAL_DATA_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION&apos;)) = 1">
      </where>
      <where
        label="wr2"
        expression="derived_definition.name = base_definition.name">
      </where>
    </entity>

    <entity name="general_property_relationship"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="relating_property">
        <typename name="general_property"/>
      </explicit>
      <explicit
        name="related_property">
        <typename name="general_property"/>
      </explicit>
    </entity>

    <entity name="generic_expression"
      abstract.supertype="YES"
      super.expression="ONEOF(simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression)"
    >
      <where
        label="wr1"
        expression="is_acyclic(SELF)">
      </where>
    </entity>

    <entity name="generic_literal"
      abstract.supertype="YES"
      supertypes="simple_generic_expression"
    >
    </entity>

    <entity name="generic_variable"
      abstract.supertype="YES"
      supertypes="simple_generic_expression"
    >
      <inverse
        name="interpretation"
        entity="environment"
        attribute="syntactic_representation">
      </inverse>
    </entity>

    <entity name="geometric_curve_set"
      supertypes="geometric_set"
    >
      <where
        label="wr1"
        expression="SIZEOF(QUERY(temp &lt;* SELF\geometric_set.elements | &apos;FUNCTIONAL_DATA_MIM_LF.SURFACE&apos; IN TYPEOF(temp))) = 0">
      </where>
    </entity>

    <entity name="geometric_representation_context"
      supertypes="representation_context"
    >
      <explicit
        name="coordinate_space_dimension">
        <typename name="dimension_count"/>
      </explicit>
    </entity>

    <entity name="geometric_representation_item"
      supertypes="representation_item"
      super.expression="ONEOF(point, direction, vector, placement, cartesian_transformation_operator, curve, surface, volume, geometric_set)"
    >
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename name="dimension_count"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(using_rep &lt;* using_representations(SELF) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT&apos; IN TYPEOF(using_rep.context_of_items)))) = 0">
      </where>
    </entity>

    <entity name="geometric_set"
      supertypes="geometric_representation_item"
      super.expression="geometric_curve_set"
    >
      <explicit
        name="elements">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="geometric_set_select"/>
      </explicit>
    </entity>

    <entity name="geometrically_bounded_2d_wireframe_representation"
      supertypes="shape_representation"
    >
      <where
        label="wr1"
        expression="SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(item &lt;* SELF.items | NOT (SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_CURVE_SET&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT_2D&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos;]) = 1))) = 0">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(QUERY(item &lt;* SELF.items | SIZEOF(TYPEOF(item) * [&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_CURVE_SET&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos;]) = 1)) &gt;= 1">
      </where>
      <where
        label="wr4"
        expression="SIZEOF(QUERY(mi &lt;* QUERY(item &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item)) | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION&apos; IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0">
      </where>
      <where
        label="wr5"
        expression="SIZEOF(QUERY(gcs &lt;* QUERY(item &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_CURVE_SET&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(elem &lt;* gcs\geometric_set.elements | NOT (SIZEOF(TYPEOF(elem) * [&apos;FUNCTIONAL_DATA_MIM_LF.B_SPLINE_CURVE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.CIRCLE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_CURVE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ELLIPSE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.OFFSET_CURVE_2D&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.POINT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.POLYLINE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.TRIMMED_CURVE&apos;]) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr6"
        expression="SIZEOF(QUERY(gcs &lt;* QUERY(item &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_CURVE_SET&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(crv &lt;* QUERY(elem &lt;* gcs\geometric_set.elements | &apos;FUNCTIONAL_DATA_MIM_LF.CURVE&apos; IN TYPEOF(elem)) | NOT valid_basis_curve_in_2d_wireframe(crv))) = 0))) = 0">
      </where>
      <where
        label="wr7"
        expression="SIZEOF(QUERY(gcs &lt;* QUERY(item &lt;* SELF.items | &apos;AIC_- GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(pnt &lt;* QUERY(elem &lt;* gcs\geometric_set.elements | &apos;FUNCTIONAL_DATA_MIM_LF.POINT&apos; IN TYPEOF(elem)) | NOT (SIZEOF(TYPEOF(pnt) * [&apos;FUNCTIONAL_DATA_MIM_LF.CARTESIAN_POINT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.POINT_ON_CURVE&apos;]) = 1))) = 0))) = 0">
      </where>
      <where
        label="wr8"
        expression="SIZEOF(QUERY(gcs &lt;* QUERY(item &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_CURVE_SET&apos; IN TYPEOF(item)) | NOT (SIZEOF(QUERY(pl &lt;* QUERY(elem &lt;* gcs\geometric_set.elements | &apos;FUNCTIONAL_DATA_MIM_LF.POLYLINE&apos; IN TYPEOF(elem)) | NOT (SIZEOF(pl\polyline.points) &gt; 2))) = 0))) = 0">
      </where>
    </entity>

    <entity name="global_uncertainty_assigned_context"
      supertypes="representation_context"
    >
      <explicit
        name="uncertainty">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="uncertainty_measure_with_unit"/>
      </explicit>
    </entity>

    <entity name="global_unit_assigned_context"
      supertypes="representation_context"
    >
      <explicit
        name="units">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="unit"/>
      </explicit>
    </entity>

    <entity name="group"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="homogeneous_linear_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="sum_index">
        <typename name="one_or_two"/>
      </explicit>
      <derived
        name="mat"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="function_is_2d_table(mat)">
      </where>
      <where
        label="wr2"
        expression="(space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers)">
      </where>
    </entity>

    <entity name="hyperbola"
      supertypes="conic"
    >
      <explicit
        name="semi_axis">
        <typename name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity name="id_attribute"
    >
      <explicit
        name="attribute_value">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="identified_item">
        <typename name="id_attribute_select"/>
      </explicit>
    </entity>

    <entity name="identification_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="role">
        <typename name="identification_role"/>
      </explicit>
    </entity>

    <entity name="identification_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="implicit_schematic_element_definition"
      supertypes="schematic_element_definition"
    >
      <where
        label="no_styled_item"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos; IN TYPEOF(it))) = 0">
      </where>
      <where
        label="either_derived_once_or_defined_by_assembly"
        expression="(SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION&apos; IN TYPEOF(it))) = 1) OR (SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(it))) &gt;= 1)">
      </where>
    </entity>

    <entity name="imported_curve_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="geometry">
        <typename name="curve"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename name="tuple_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity name="imported_point_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="geometry">
        <typename name="point"/>
      </explicit>
    </entity>

    <entity name="imported_surface_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="geometry">
        <typename name="surface"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename name="tuple_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity name="imported_volume_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="geometry">
        <typename name="volume"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename name="tuple_space"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity name="index_expression"
      supertypes="string_expression binary_generic_expression"
    >
      <derived
        name="operand"
        expression="SELF\binary_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="index"
        expression="SELF\binary_generic_expression.operands[2]">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(operand)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(index))">
      </where>
      <where
        label="wr2"
        expression="is_int_expr(index)">
      </where>
    </entity>

    <entity name="individual_activity"
      supertypes="executed_action"
    >
    </entity>

    <entity name="individual_involvement_in_activity"
      supertypes="applied_action_assignment"
    >
      <explicit
        name="assigned_action">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_assignment"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="1"
        />
        <typename name="involved_select"/>
        <redeclaration
          entity-ref="applied_action_assignment"/>
      </explicit>
    </entity>

    <entity name="int_literal"
      supertypes="literal_number"
    >
      <explicit
        name="the_value">
        <builtintype type="INTEGER"
        />
        <redeclaration
          entity-ref="literal_number"/>
      </explicit>
    </entity>

    <entity name="integer_defined_function"
      abstract.supertype="YES"
      supertypes="numeric_defined_function"
    >
    </entity>

    <entity name="integer_interval_from_min"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="min">
        <builtintype type="INTEGER"
        />
      </explicit>
    </entity>

    <entity name="integer_interval_to_max"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="max">
        <builtintype type="INTEGER"
        />
      </explicit>
    </entity>

    <entity name="integer_tuple_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="INTEGER"
        />
      </explicit>
    </entity>

    <entity name="intersection"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="operand">
        <aggregate type="SET"
          lower="2"
          upper="?"
        />
        <typename name="class"/>
      </explicit>
      <explicit
        name="resultant">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="interval_expression"
      supertypes="boolean_expression multiple_arity_generic_expression"
    >
      <derived
        name="interval_low"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="interval_item"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="interval_high"
        expression="SELF\multiple_arity_generic_expression.operands[3]">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.EXPRESSION&apos; IN TYPEOF(interval_low)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.EXPRESSION&apos; IN TYPEOF(interval_item)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.EXPRESSION&apos; IN TYPEOF(interval_high))">
      </where>
      <where
        label="wr2"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_low)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_high)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_item)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_low)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF.interval_item)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF.interval_high))">
      </where>
    </entity>

    <entity name="intra_page_connector"
      supertypes="page_connector"
    >
    </entity>

    <entity name="invisibility"
    >
      <explicit
        name="invisible_items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="invisible_item"/>
      </explicit>
    </entity>

    <entity name="involvement_of_individual_product_in_connection"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="connection_of_individual_product_with_involvements"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
    </entity>

    <entity name="length_function"
      supertypes="numeric_expression unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="string_expression"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="length_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.LENGTH_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="length_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 1.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="like_expression"
      supertypes="comparison_expression"
    >
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(SELF\binary_generic_expression.operands[2]))">
      </where>
    </entity>

    <entity name="line"
      supertypes="curve"
    >
      <explicit
        name="pnt">
        <typename name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename name="vector"/>
      </explicit>
      <where
        label="wr1"
        expression="dir.dim = pnt.dim">
      </where>
    </entity>

    <entity name="linearized_table_function"
      supertypes="explicit_table_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="first">
        <builtintype type="INTEGER"
        />
      </explicit>
      <derived
        name="source"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="function_is_1d_array(source)">
      </where>
      <where
        label="wr2"
        expression="member_of(first, source.domain)">
      </where>
    </entity>

    <entity name="listed_complex_number_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <builtintype type="REAL"
        />
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values) / 2]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
      <where
        label="wr1"
        expression="NOT ODD(SIZEOF(values))">
      </where>
    </entity>

    <entity name="listed_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_value"/>
      </explicit>
      <explicit
        name="value_range">
        <typename name="maths_space"/>
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values)]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
      <where
        label="wr1"
        expression="expression_is_constant(value_range)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(val &lt;* values | NOT member_of(val, value_range))) = 0">
      </where>
    </entity>

    <entity name="listed_integer_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="INTEGER"
        />
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values)]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
    </entity>

    <entity name="listed_logical_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="LOGICAL"
        />
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values)]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
    </entity>

    <entity name="listed_product_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="factors">
        <aggregate type="LIST"
        />
        <typename name="maths_space"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(space &lt;* factors | NOT expression_is_constant(space))) = 0">
      </where>
      <where
        label="wr2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="wr3"
        expression="NOT (the_empty_space IN factors)">
      </where>
    </entity>

    <entity name="listed_real_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="REAL"
        />
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values)]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
    </entity>

    <entity name="listed_string_data"
      supertypes="explicit_table_function generic_literal"
    >
      <explicit
        name="values">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="STRING"
        />
      </explicit>
      <derived
        name="shape"
        expression="[SIZEOF(values)]">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
        <redeclaration
          entity-ref="explicit_table_function"/>
      </derived>
    </entity>

    <entity name="literal_number"
      abstract.supertype="YES"
      supertypes="simple_numeric_expression generic_literal"
      super.expression="ONEOF(int_literal, real_literal)"
    >
      <explicit
        name="the_value">
        <builtintype type="NUMBER"
        />
      </explicit>
    </entity>

    <entity name="log10_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="log2_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="log_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="logical_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <builtintype type="LOGICAL"
        />
      </explicit>
    </entity>

    <entity name="luminous_intensity_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.LUMINOUS_INTENSITY_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="luminous_intensity_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.000000)">
      </where>
    </entity>

    <entity name="mapped_item"
      supertypes="representation_item"
    >
      <explicit
        name="mapping_source">
        <typename name="representation_map"/>
      </explicit>
      <explicit
        name="mapping_target">
        <typename name="representation_item"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_mapped_representation(using_representations(SELF), [SELF])">
      </where>
    </entity>

    <entity name="mass_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.MASS_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="mass_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 1.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="maths_enum_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <typename name="maths_enum_atom"/>
      </explicit>
    </entity>

    <entity name="maths_function"
      abstract.supertype="YES"
      supertypes="generic_expression"
      super.expression="ONEOF(finite_function, constant_function, selector_function, elementary_function, restriction_function, repackaging_function, reindexed_array_function, series_composed_function, parallel_composed_function, explicit_table_function, homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function, rationalize_function, partial_derivative_function, definite_integral_function, abstracted_expression_function, expression_denoted_function, imported_point_function, imported_curve_function, imported_surface_function, imported_volume_function, application_defined_function)"
    >
      <derived
        name="domain"
        expression="derive_function_domain(SELF)">
        <typename name="tuple_space"/>
      </derived>
      <derived
        name="range"
        expression="derive_function_range(SELF)">
        <typename name="tuple_space"/>
      </derived>
    </entity>

    <entity name="maths_space"
      abstract.supertype="YES"
      supertypes="generic_expression"
      super.expression="ONEOF(elementary_space, finite_integer_interval, integer_interval_from_min, integer_interval_to_max, finite_real_interval, real_interval_from_min, real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region, finite_space, uniform_product_space, listed_product_space, extended_tuple_space, function_space)"
    >
    </entity>

    <entity name="maths_space_context"
      super.expression="ONEOF(compound_maths_space_context, defined_maths_space_context, explicitly_enumerated_maths_space_context)"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="abstract_space">
        <typename name="maths_space"/>
      </explicit>
      <explicit
        name="physical_space">
        <typename name="space_context_select"/>
      </explicit>
    </entity>

    <entity name="maths_tuple_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <aggregate type="LIST"
        />
        <typename name="maths_value"/>
      </explicit>
    </entity>

    <entity name="maths_value_context"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="abstract_value">
        <typename name="maths_value"/>
      </explicit>
      <explicit
        name="physical_value">
        <typename name="value_context_select"/>
      </explicit>
    </entity>

    <entity name="maths_variable"
      supertypes="generic_variable"
    >
      <explicit
        name="values_space">
        <typename name="maths_space"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(values_space)">
      </where>
    </entity>

    <entity name="maximum_function"
      supertypes="multiple_arity_function_call"
    >
    </entity>

    <entity name="measure_with_unit"
      super.expression="ONEOF(length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit)"
    >
      <explicit
        name="value_component">
        <typename name="measure_value"/>
      </explicit>
      <explicit
        name="unit_component">
        <typename name="unit"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_units(SELF)">
      </where>
    </entity>

    <entity name="membership_of_maths_space_context"
    >
      <explicit
        name="space_context">
        <typename name="maths_space_context"/>
      </explicit>
      <explicit
        name="value_context">
        <typename name="maths_value_context"/>
      </explicit>
    </entity>

    <entity name="minimum_function"
      supertypes="multiple_arity_function_call"
    >
    </entity>

    <entity name="minus_expression"
      supertypes="binary_numeric_expression"
    >
    </entity>

    <entity name="minus_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="mod_expression"
      supertypes="binary_numeric_expression"
    >
    </entity>

    <entity name="mult_expression"
      supertypes="multiple_arity_numeric_expression"
    >
    </entity>

    <entity name="multiple_arity_boolean_expression"
      abstract.supertype="YES"
      supertypes="boolean_expression multiple_arity_generic_expression"
      super.expression="ONEOF(and_expression, or_expression)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="boolean_expression"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="multiple_arity_function_call"
      abstract.supertype="YES"
      supertypes="multiple_arity_numeric_expression"
      super.expression="ONEOF(maximum_function, minimum_function)"
    >
    </entity>

    <entity name="multiple_arity_generic_expression"
      abstract.supertype="YES"
      supertypes="generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="generic_expression"/>
      </explicit>
    </entity>

    <entity name="multiple_arity_numeric_expression"
      abstract.supertype="YES"
      supertypes="numeric_expression multiple_arity_generic_expression"
      super.expression="ONEOF(plus_expression, mult_expression, multiple_arity_function_call)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="numeric_expression"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="name_attribute"
    >
      <explicit
        name="attribute_value">
        <typename name="label"/>
      </explicit>
      <explicit
        name="named_item">
        <typename name="name_attribute_select"/>
      </explicit>
    </entity>

    <entity name="named_unit"
      super.expression="ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)"
    >
      <explicit
        name="dimensions">
        <typename name="dimensional_exponents"/>
      </explicit>
    </entity>

    <entity name="not_expression"
      supertypes="unary_boolean_expression"
    >
      <explicit
        name="operand">
        <typename name="boolean_expression"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="numeric_defined_function"
      abstract.supertype="YES"
      supertypes="numeric_expression defined_function"
      super.expression="ONEOF(integer_defined_function, real_defined_function)"
    >
    </entity>

    <entity name="numeric_expression"
      abstract.supertype="YES"
      supertypes="expression"
      super.expression="ONEOF(simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function)"
    >
      <derived
        name="is_int"
        expression="is_int_expr(SELF)">
        <builtintype type="BOOLEAN"
        />
      </derived>
      <derived
        name="sql_mappable"
        expression="is_sql_mappable(SELF)">
        <builtintype type="BOOLEAN"
        />
      </derived>
    </entity>

    <entity name="numeric_variable"
      supertypes="simple_numeric_expression variable"
    >
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.INT_NUMERIC_VARIABLE&apos; IN TYPEOF(SELF)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.REAL_NUMERIC_VARIABLE&apos; IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="object_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="odd_function"
      supertypes="unary_boolean_expression"
    >
      <explicit
        name="operand">
        <typename name="numeric_expression"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <where
        label="wr1"
        expression="is_int_expr(SELF\numeric_expression)">
      </where>
    </entity>

    <entity name="off_page_connector"
      supertypes="page_connector"
    >
    </entity>

    <entity name="offset_curve_2d"
      supertypes="curve"
    >
      <explicit
        name="basis_curve">
        <typename name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype type="LOGICAL"
        />
      </explicit>
      <where
        label="wr1"
        expression="basis_curve.dim = 2">
      </where>
    </entity>

    <entity name="on_page_connector"
      supertypes="page_connector"
    >
    </entity>

    <entity name="one_direction_repeat_factor"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="repeat_factor">
        <typename name="vector"/>
      </explicit>
    </entity>

    <entity name="or_expression"
      supertypes="multiple_arity_boolean_expression"
    >
    </entity>

    <entity name="organization"
    >
      <explicit
        name="id"
        optional="YES">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="organization_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_organization">
        <typename name="organization"/>
      </explicit>
      <explicit
        name="role">
        <typename name="organization_role"/>
      </explicit>
    </entity>

    <entity name="organization_relationship"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="relating_organization">
        <typename name="organization"/>
      </explicit>
      <explicit
        name="related_organization">
        <typename name="organization"/>
      </explicit>
    </entity>

    <entity name="organization_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="organization_type"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="organization_type_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="assigned_organization_type">
        <typename name="organization_type"/>
      </explicit>
      <explicit
        name="role">
        <typename name="organization_type_role"/>
      </explicit>
    </entity>

    <entity name="organization_type_role"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="organizational_address"
      supertypes="address"
    >
      <explicit
        name="organizations">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="organization"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="page_connector"
      supertypes="schematic_element_definition"
    >
    </entity>

    <entity name="parabola"
      supertypes="conic"
    >
      <explicit
        name="focal_dist">
        <typename name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="focal_dist &lt;&gt; 0.000000">
      </where>
    </entity>

    <entity name="parallel_composed_function"
      supertypes="maths_function multiple_arity_generic_expression"
    >
      <explicit
        name="source_of_domain">
        <typename name="maths_space_or_function"/>
      </explicit>
      <explicit
        name="prep_functions">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_function"/>
      </explicit>
      <explicit
        name="final_function">
        <typename name="maths_function_select"/>
      </explicit>
      <derived
        name="operands"
        expression="convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function)">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="generic_expression"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="wr2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
      <where
        label="wr3"
        expression="parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions)">
      </where>
      <where
        label="wr4"
        expression="parallel_composed_function_composability_check(prep_functions, final_function)">
      </where>
    </entity>

    <entity name="partial_derivative_expression"
      supertypes="unary_generic_expression"
    >
      <explicit
        name="d_variables">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_variable"/>
      </explicit>
      <explicit
        name="extension">
        <typename name="extension_options"/>
      </explicit>
      <derived
        name="derivand"
        expression="SELF\unary_generic_expression.operand">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="has_values_space(derivand)">
      </where>
      <where
        label="wr2"
        expression="space_is_continuum(values_space_of(derivand))">
      </where>
      <where
        label="wr3"
        expression="SIZEOF(QUERY(vbl &lt;* d_variables | NOT subspace_of(values_space_of(vbl), the_reals) AND NOT subspace_of(values_space_of(vbl), the_complex_numbers))) = 0">
      </where>
    </entity>

    <entity name="partial_derivative_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="d_variables">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="input_selector"/>
      </explicit>
      <explicit
        name="extension">
        <typename name="extension_options"/>
      </explicit>
      <derived
        name="derivand"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="space_is_continuum(derivand.range)">
      </where>
      <where
        label="wr2"
        expression="partial_derivative_check(derivand.domain, d_variables)">
      </where>
    </entity>

    <entity name="person"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="last_name"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="first_name"
        optional="YES">
        <typename name="label"/>
      </explicit>
      <explicit
        name="middle_names"
        optional="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="label"/>
      </explicit>
      <explicit
        name="prefix_titles"
        optional="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="label"/>
      </explicit>
      <explicit
        name="suffix_titles"
        optional="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="EXISTS(last_name) OR EXISTS(first_name)">
      </where>
    </entity>

    <entity name="person_and_organization"
    >
      <explicit
        name="the_person">
        <typename name="person"/>
      </explicit>
      <explicit
        name="the_organization">
        <typename name="organization"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename name="label"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM&apos;)) &lt;= 1">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="person_and_organization_address"
      supertypes="organizational_address personal_address"
    >
      <explicit
        name="people">
        <aggregate type="SET"
          lower="1"
          upper="1"
        />
        <typename name="person"/>
        <redeclaration
          entity-ref="personal_address"/>
      </explicit>
      <explicit
        name="organizations">
        <aggregate type="SET"
          lower="1"
          upper="1"
        />
        <typename name="organization"/>
        <redeclaration
          entity-ref="organizational_address"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(pao &lt;* USEDIN(SELF\personal_address.people[1], &apos;FUNCTIONAL_DATA_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON&apos;) | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1">
      </where>
    </entity>

    <entity name="person_and_organization_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_person_and_organization">
        <typename name="person_and_organization"/>
      </explicit>
      <explicit
        name="role">
        <typename name="person_and_organization_role"/>
      </explicit>
    </entity>

    <entity name="person_and_organization_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="person_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_person">
        <typename name="person"/>
      </explicit>
      <explicit
        name="role">
        <typename name="person_role"/>
      </explicit>
    </entity>

    <entity name="person_role"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="person_type"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="personal_address"
      supertypes="address"
    >
      <explicit
        name="people">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="person"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
    </entity>

    <entity name="physical_quantity_range"
      supertypes="physical_quantity_space"
    >
    </entity>

    <entity name="physical_quantity_space"
      supertypes="general_property class"
    >
    </entity>

    <entity name="physical_quantity_symmetry"
      supertypes="general_property class"
    >
    </entity>

    <entity name="physical_quantity_symmetry_by_library_reference"
      supertypes="physical_quantity_symmetry externally_defined_item"
    >
    </entity>

    <entity name="physical_quantity_value"
      supertypes="general_property class"
    >
    </entity>

    <entity name="placement"
      supertypes="geometric_representation_item"
      super.expression="axis2_placement_2d"
    >
      <explicit
        name="location">
        <typename name="cartesian_point"/>
      </explicit>
    </entity>

    <entity name="planar_box"
      supertypes="planar_extent"
    >
      <explicit
        name="placement">
        <typename name="axis2_placement"/>
      </explicit>
    </entity>

    <entity name="planar_extent"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="size_in_x">
        <typename name="length_measure"/>
      </explicit>
      <explicit
        name="size_in_y">
        <typename name="length_measure"/>
      </explicit>
    </entity>

    <entity name="plane_angle_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.PLANE_ANGLE_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="plane_angle_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="plus_expression"
      supertypes="multiple_arity_numeric_expression"
    >
    </entity>

    <entity name="point"
      supertypes="geometric_representation_item"
      super.expression="ONEOF(cartesian_point, point_on_curve)"
    >
    </entity>

    <entity name="point_on_curve"
      supertypes="point"
    >
      <explicit
        name="basis_curve">
        <typename name="curve"/>
      </explicit>
      <explicit
        name="point_parameter">
        <typename name="parameter_value"/>
      </explicit>
    </entity>

    <entity name="polar_complex_number_region"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="centre">
        <typename name="complex_number_literal"/>
      </explicit>
      <explicit
        name="distance_constraint">
        <typename name="real_interval"/>
      </explicit>
      <explicit
        name="direction_constraint">
        <typename name="finite_real_interval"/>
      </explicit>
      <where
        label="wr1"
        expression="min_exists(distance_constraint) AND (real_min(distance_constraint) &gt;= 0.000000)">
      </where>
      <where
        label="wr2"
        expression="{ - PI &lt;= direction_constraint.min &lt; PI}">
      </where>
      <where
        label="wr3"
        expression="direction_constraint.max - direction_constraint.min &lt;= 2.000000 * PI">
      </where>
      <where
        label="wr4"
        expression="(direction_constraint.max - direction_constraint.min &lt; 2.000000 * PI) OR (direction_constraint.min_closure = open)">
      </where>
      <where
        label="wr5"
        expression="(direction_constraint.max - direction_constraint.min &lt; 2.000000 * PI) OR (direction_constraint.max_closure = open) OR (direction_constraint.min =  - PI)">
      </where>
      <where
        label="wr6"
        expression="(real_min(distance_constraint) &gt; 0.000000) OR max_exists(distance_constraint) OR (direction_constraint.max - direction_constraint.min &lt; 2.000000 * PI) OR (direction_constraint.max_closure = open)">
      </where>
    </entity>

    <entity name="polyline"
      supertypes="bounded_curve"
    >
      <explicit
        name="points">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="cartesian_point"/>
      </explicit>
    </entity>

    <entity name="possessed_physical_quantity_space"
      supertypes="general_property_association"
    >
      <explicit
        name="base_definition">
        <typename name="physical_quantity_space"/>
        <redeclaration
          entity-ref="general_property_association"/>
      </explicit>
      <where
        label="link_to_possession"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.CLASS_OF_POSSESSION_OF_PROPERTY_BY_ACTIVITY&apos; IN TYPEOF(SELF\general_property_association.derived_definition)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.CLASS_OF_POSSESSION_OF_PROPERTY_BY_PRODUCT&apos; IN TYPEOF(SELF\general_property_association.derived_definition))">
      </where>
    </entity>

    <entity name="possessed_property"
      supertypes="general_property_association"
    >
      <explicit
        name="base_definition">
        <typename name="physical_quantity_value"/>
        <redeclaration
          entity-ref="general_property_association"/>
      </explicit>
      <where
        label="link_to_possession"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_ACTIVITY&apos; IN TYPEOF(SELF\general_property_association.derived_definition)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.POSSESSION_OF_PROPERTY_BY_PRODUCT&apos; IN TYPEOF(SELF\general_property_association.derived_definition))">
      </where>
    </entity>

    <entity name="possession_of_property_by_activity"
      supertypes="action_property"
    >
      <explicit
        name="definition">
        <typename name="individual_activity"/>
        <redeclaration
          entity-ref="action_property"/>
      </explicit>
    </entity>

    <entity name="possession_of_property_by_product"
      supertypes="property_definition"
    >
      <where
        label="link_to_individual"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.PRODUCT_AS_INDIVIDUAL&apos; IN TYPEOF(SELF\property_definition.definition.formation)">
      </where>
    </entity>

    <entity name="power_expression"
      supertypes="binary_numeric_expression"
    >
    </entity>

    <entity name="power_set"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="base">
        <typename name="class"/>
      </explicit>
      <explicit
        name="derived">
        <typename name="class"/>
      </explicit>
      <where
        label="derived_different"
        expression="NOT identical_sets(base, derived)">
      </where>
    </entity>

    <entity name="pre_defined_colour"
      supertypes="pre_defined_item colour"
    >
    </entity>

    <entity name="pre_defined_curve_font"
      supertypes="pre_defined_item"
    >
    </entity>

    <entity name="pre_defined_item"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="pre_defined_symbol"
      supertypes="pre_defined_item"
    >
    </entity>

    <entity name="pre_defined_text_font"
      supertypes="pre_defined_item"
    >
    </entity>

    <entity name="presentation_area"
      supertypes="presentation_representation"
    >
      <where
        label="wr1"
        expression="(SIZEOF(QUERY(ais &lt;* USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET.AREA&apos;) | SIZEOF(USEDIN(ais, &apos;FUNCTIONAL_DATA_MIM_LF.PRESENTATION_SIZE.UNIT&apos;)) = 1)) &gt; 0) OR (SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.PRESENTATION_SIZE.UNIT&apos;)) = 1)">
      </where>
    </entity>

    <entity name="presentation_representation"
      supertypes="representation"
    >
      <where
        label="wr1"
        expression="SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2">
      </where>
      <where
        label="wr2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT&apos; IN TYPEOF(SELF\representation.context_of_items)">
      </where>
    </entity>

    <entity name="presentation_set"
    >
      <inverse
        name="areas"
        entity="area_in_set"
        attribute="in_set">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
    </entity>

    <entity name="presentation_size"
    >
      <explicit
        name="unit">
        <typename name="presentation_size_assignment_select"/>
      </explicit>
      <explicit
        name="size">
        <typename name="planar_box"/>
      </explicit>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.PRESENTATION_REPRESENTATION&apos; IN TYPEOF(SELF.unit)) AND item_in_context(SELF.size, SELF.unit\representation.context_of_items) OR (&apos;FUNCTIONAL_DATA_MIM_LF.AREA_IN_SET&apos; IN TYPEOF(SELF.unit)) AND (SIZEOF(QUERY(ais &lt;* SELF.unit\area_in_set.in_set.areas | NOT item_in_context(SELF.size, ais.area\representation.context_of_items))) = 0)">
      </where>
    </entity>

    <entity name="presentation_style_assignment"
    >
      <explicit
        name="styles">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="presentation_style_select"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(style1 &lt;* SELF.styles | NOT (SIZEOF(QUERY(style2 &lt;* SELF.styles - style1 | NOT ((TYPEOF(style1) &lt;&gt; TYPEOF(style2)) OR (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SURFACE_STYLE_USAGE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;EXTERNALLY_DEFINED_STYLE&apos;] * TYPEOF(style1)) = 1)))) = 0))) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(style1 &lt;* SELF.styles | &apos;FUNCTIONAL_DATA_MIM_LF.SURFACE_STYLE_USAGE&apos; IN TYPEOF(style1))) &lt;= 2">
      </where>
    </entity>

    <entity name="presentation_style_by_context"
      supertypes="presentation_style_assignment"
    >
      <explicit
        name="style_context">
        <typename name="style_context_select"/>
      </explicit>
    </entity>

    <entity name="presentation_view"
      supertypes="presentation_representation"
    >
    </entity>

    <entity name="presented_item"
      abstract.supertype="YES"
    >
    </entity>

    <entity name="presented_item_representation"
    >
      <explicit
        name="presentation">
        <typename name="presentation_representation_select"/>
      </explicit>
      <explicit
        name="item">
        <typename name="presented_item"/>
      </explicit>
    </entity>

    <entity name="product"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="product_context"/>
      </explicit>
    </entity>

    <entity name="product_as_individual"
      abstract.supertype="YES"
      supertypes="product_definition_formation"
      super.expression="ONEOF(product_as_planned, product_as_realized)"
    >
    </entity>

    <entity name="product_as_planned"
      supertypes="product_as_individual"
    >
    </entity>

    <entity name="product_as_realized"
      supertypes="product_as_individual"
    >
    </entity>

    <entity name="product_category"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="product_category_relationship"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="category">
        <typename name="product_category"/>
      </explicit>
      <explicit
        name="sub_category">
        <typename name="product_category"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_product_category_relationship(SELF, [SELF.sub_category])">
      </where>
    </entity>

    <entity name="product_context"
      supertypes="application_context_element"
    >
      <explicit
        name="discipline_type">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="product_definition"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="formation">
        <typename name="product_definition_formation"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename name="product_definition_context"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename name="label"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="product_definition_context"
      supertypes="application_context_element"
    >
      <explicit
        name="life_cycle_stage">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="product_definition_formation"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="of_product">
        <typename name="product"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="id"/>
        <unique.attribute
          attribute="of_product"/>
      </unique>
    </entity>

    <entity name="product_definition_formation_relationship"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="relating_product_definition_formation">
        <typename name="product_definition_formation"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_definition_formation"/>
      </explicit>
    </entity>

    <entity name="product_design_to_individual"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_individual"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <derived
        name="individual_product"
        expression="SELF\product_definition_formation_relationship.related_product_definition_formation">
        <typename name="product_as_individual"/>
      </derived>
      <derived
        name="product_version"
        expression="SELF\product_definition_formation_relationship.relating_product_definition_formation">
        <typename name="product_definition_formation"/>
      </derived>
    </entity>

    <entity name="product_planned_to_realized"
      supertypes="product_definition_formation_relationship"
    >
      <explicit
        name="relating_product_definition_formation">
        <typename name="product_as_planned"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <explicit
        name="related_product_definition_formation">
        <typename name="product_as_realized"/>
        <redeclaration
          entity-ref="product_definition_formation_relationship"/>
      </explicit>
      <derived
        name="planned_product"
        expression="SELF\product_definition_formation_relationship.relating_product_definition_formation">
        <typename name="product_as_planned"/>
      </derived>
      <derived
        name="realized_product"
        expression="SELF\product_definition_formation_relationship.related_product_definition_formation">
        <typename name="product_as_realized"/>
      </derived>
    </entity>

    <entity name="product_related_product_category"
      supertypes="product_category"
    >
      <explicit
        name="products">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="product"/>
      </explicit>
    </entity>

    <entity name="proper_subset"
      supertypes="subset"
    >
      <where
        label="subset_different"
        expression="NOT identical_sets(superset, subset)">
      </where>
    </entity>

    <entity name="property_condition_for_activity"
      supertypes="class_of_possession_of_property_by_activity"
    >
    </entity>

    <entity name="property_condition_for_product"
      supertypes="class_of_possession_of_property_by_product"
    >
    </entity>

    <entity name="property_definition"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="definition">
        <typename name="characterized_definition"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="property_definition_representation"
    >
      <explicit
        name="definition">
        <typename name="represented_definition"/>
      </explicit>
      <explicit
        name="used_representation">
        <typename name="representation"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename name="label"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="quantifier_expression"
      abstract.supertype="YES"
      supertypes="multiple_arity_generic_expression"
    >
      <explicit
        name="variables">
        <aggregate type="LIST"
          unique="YES"
          lower="1"
          upper="?"
        />
        <typename name="generic_variable"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(vrbl &lt;* variables | NOT (vrbl IN SELF\multiple_arity_generic_expression.operands))) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(vrbl &lt;* variables | NOT (schema_prefix + &apos;BOUND_VARIABLE_SEMANTICS&apos; IN TYPEOF(vrbl.interpretation.semantics)))) = 0">
      </where>
    </entity>

    <entity name="quasi_uniform_curve"
      supertypes="b_spline_curve"
    >
    </entity>

    <entity name="ratio_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.RATIO_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="ratio_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="rational_b_spline_curve"
      supertypes="b_spline_curve"
    >
      <explicit
        name="weights_data">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <builtintype type="REAL"
        />
      </explicit>
      <derived
        name="weights"
        expression="list_to_array(weights_data, 0, upper_index_on_control_points)">
        <aggregate type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"
        />
        <builtintype type="REAL"
        />
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list)">
      </where>
      <where
        label="wr2"
        expression="curve_weights_positive(SELF)">
      </where>
    </entity>

    <entity name="rationalize_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <derived
        name="fun"
        expression="SELF\unary_generic_expression.operand">
        <typename name="maths_function"/>
      </derived>
      <where
        label="wr1"
        expression="(space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1)">
      </where>
      <where
        label="wr2"
        expression="number_tuple_subspace_check(factor1(fun.range))">
      </where>
      <where
        label="wr3"
        expression="space_dimension(factor1(fun.range)) &gt; 1">
      </where>
    </entity>

    <entity name="real_defined_function"
      abstract.supertype="YES"
      supertypes="numeric_defined_function"
    >
    </entity>

    <entity name="real_interval_from_min"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="min">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="min_closure">
        <typename name="open_closed"/>
      </explicit>
    </entity>

    <entity name="real_interval_to_max"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="max">
        <builtintype type="REAL"
        />
      </explicit>
      <explicit
        name="max_closure">
        <typename name="open_closed"/>
      </explicit>
    </entity>

    <entity name="real_literal"
      supertypes="literal_number"
    >
      <explicit
        name="the_value">
        <builtintype type="REAL"
        />
        <redeclaration
          entity-ref="literal_number"/>
      </explicit>
    </entity>

    <entity name="real_tuple_literal"
      supertypes="generic_literal"
    >
      <explicit
        name="lit_value">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="REAL"
        />
      </explicit>
    </entity>

    <entity name="reference_between_page_connectors"
      supertypes="representation_relationship"
    >
      <explicit
        name="rep_1">
        <typename name="page_connector"/>
        <redeclaration
          entity-ref="representation_relationship"/>
      </explicit>
      <explicit
        name="rep_2">
        <typename name="page_connector"/>
        <redeclaration
          entity-ref="representation_relationship"/>
      </explicit>
    </entity>

    <entity name="reindexed_array_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="starting_indices">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <builtintype type="INTEGER"
        />
      </explicit>
      <where
        label="wr1"
        expression="function_is_array(SELF\unary_generic_expression.operand)">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(starting_indices) = SIZEOF(shape_of_array(SELF\unary_generic_expression.operand))">
      </where>
    </entity>

    <entity name="repackaging_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
      <explicit
        name="input_repack">
        <typename name="repackage_options"/>
      </explicit>
      <explicit
        name="output_repack">
        <typename name="repackage_options"/>
      </explicit>
      <explicit
        name="selected_output">
        <typename name="nonnegative_integer"/>
      </explicit>
      <where
        label="wr1"
        expression="(input_repack &lt;&gt; ro_wrap_as_tuple) OR (space_dimension(operand.domain) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(operand.domain)))">
      </where>
      <where
        label="wr2"
        expression="(output_repack &lt;&gt; ro_unwrap_tuple) OR (space_dimension(operand.range) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(operand.range)))">
      </where>
      <where
        label="wr3"
        expression="selected_output &lt;= space_dimension(repackage(operand.range, output_repack))">
      </where>
    </entity>

    <entity name="representation"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="representation_item"/>
      </explicit>
      <explicit
        name="context_of_items">
        <typename name="representation_context"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename name="identifier"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename name="text"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;)) &lt;= 1">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="representation_context"
    >
      <explicit
        name="context_identifier">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="context_type">
        <typename name="text"/>
      </explicit>
      <inverse
        name="representations_in_context"
        entity="representation"
        attribute="context_of_items">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
    </entity>

    <entity name="representation_context_defined_maths_space_context"
      supertypes="defined_maths_space_context"
    >
      <explicit
        name="representation_basis">
        <typename name="representation_context"/>
      </explicit>
    </entity>

    <entity name="representation_item"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(using_representations(SELF)) &gt; 0">
      </where>
    </entity>

    <entity name="representation_map"
    >
      <explicit
        name="mapping_origin">
        <typename name="representation_item"/>
      </explicit>
      <explicit
        name="mapped_representation">
        <typename name="representation"/>
      </explicit>
      <inverse
        name="map_usage"
        entity="mapped_item"
        attribute="mapping_source">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
      <where
        label="wr1"
        expression="item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items)">
      </where>
    </entity>

    <entity name="representation_relationship"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="rep_1">
        <typename name="representation"/>
      </explicit>
      <explicit
        name="rep_2">
        <typename name="representation"/>
      </explicit>
    </entity>

    <entity name="restriction_function"
      supertypes="maths_function unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="maths_space"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="role_association"
    >
      <explicit
        name="role">
        <typename name="object_role"/>
      </explicit>
      <explicit
        name="item_with_role">
        <typename name="role_select"/>
      </explicit>
    </entity>

    <entity name="same_membership"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="set_1">
        <typename name="class"/>
      </explicit>
      <explicit
        name="set_2">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="schematic_drawing"
      supertypes="schematic_element_definition drawing_sheet_revision"
    >
    </entity>

    <entity name="schematic_element"
      abstract.supertype="YES"
      supertypes="class draughting_model presentation_representation"
      super.expression="ONEOF(schematic_element_definition, schematic_element_occurrence)"
    >
      <where
        label="valid_mapping"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | (&apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(it)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.DRAUGHTING_MODEL&apos; IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)) AND NOT (SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;DEFINITION_OF_SCHEMATIC_ELEMENT_OCCURRENCE&apos;] * TYPEOF(it)) = 1))) = 0">
      </where>
    </entity>

    <entity name="schematic_element_definition"
      supertypes="schematic_element"
      super.expression="ONEOF(explicit_schematic_element_definition, implicit_schematic_element_definition)"
    >
    </entity>

    <entity name="schematic_element_occurrence"
      supertypes="schematic_element"
    >
      <inverse
        name="usage_in_map"
        entity="representation_map"
        attribute="mapped_representation">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
      <where
        label="no_styled_item"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | &apos;FUNCTIONAL_DATA_MIM_LF.STYLED_ITEM&apos; IN TYPEOF(it))) = 0">
      </where>
    </entity>

    <entity name="security_classification"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename name="text"/>
      </explicit>
      <explicit
        name="security_level">
        <typename name="security_classification_level"/>
      </explicit>
    </entity>

    <entity name="security_classification_assignment"
      abstract.supertype="YES"
    >
      <explicit
        name="assigned_security_classification">
        <typename name="security_classification"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="SIZEOF(USEDIN(SELF, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;)) &lt;= 1">
      </where>
    </entity>

    <entity name="security_classification_level"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
    </entity>

    <entity name="selector_function"
      supertypes="maths_function generic_literal"
    >
      <explicit
        name="selector">
        <typename name="input_selector"/>
      </explicit>
      <explicit
        name="source_of_domain">
        <typename name="maths_space_or_function"/>
      </explicit>
      <where
        label="wr1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="wr2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
    </entity>

    <entity name="series_composed_function"
      supertypes="maths_function multiple_arity_generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="maths_function"/>
        <redeclaration
          entity-ref="multiple_arity_generic_expression"/>
      </explicit>
      <where
        label="wr1"
        expression="composable_sequence(SELF\multiple_arity_generic_expression.operands)">
      </where>
    </entity>

    <entity name="shape_representation"
      supertypes="representation"
    >
    </entity>

    <entity name="si_unit"
      supertypes="named_unit"
    >
      <explicit
        name="prefix"
        optional="YES">
        <typename name="si_prefix"/>
      </explicit>
      <explicit
        name="name">
        <typename name="si_unit_name"/>
      </explicit>
      <derived
        name="dimensions"
        expression="dimensions_for_si_unit(name)">
        <typename name="dimensional_exponents"/>
        <redeclaration
          entity-ref="named_unit"/>
      </derived>
    </entity>

    <entity name="simple_boolean_expression"
      abstract.supertype="YES"
      supertypes="boolean_expression simple_generic_expression"
      super.expression="ONEOF(boolean_literal, boolean_variable)"
    >
    </entity>

    <entity name="simple_generic_expression"
      abstract.supertype="YES"
      supertypes="generic_expression"
      super.expression="ONEOF(generic_literal, generic_variable)"
    >
    </entity>

    <entity name="simple_numeric_expression"
      abstract.supertype="YES"
      supertypes="numeric_expression simple_generic_expression"
      super.expression="ONEOF(literal_number, numeric_variable)"
    >
    </entity>

    <entity name="simple_string_expression"
      abstract.supertype="YES"
      supertypes="string_expression simple_generic_expression"
      super.expression="ONEOF(string_literal, string_variable)"
    >
    </entity>

    <entity name="sin_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="slash_expression"
      supertypes="binary_numeric_expression"
    >
    </entity>

    <entity name="solid_angle_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.SOLID_ANGLE_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="solid_angle_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="space_for_physical_quantity"
      supertypes="general_property_relationship"
    >
      <explicit
        name="relating_property">
        <typename name="physical_quantity_space"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
      <explicit
        name="related_property">
        <typename name="physical_quantity_value"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
    </entity>

    <entity name="sql_mappable_defined_function"
      abstract.supertype="YES"
      supertypes="defined_function"
    >
    </entity>

    <entity name="square_root_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="standard_physical_quantity_symmetry"
      supertypes="physical_quantity_symmetry_by_library_reference"
    >
      <where
        label="valid_standard_class"
        expression="(SELF\physical_quantity_symmetry_by_library_reference\externally_defined_item.source.source_id = &apos;ISO-TS-10303-1099&apos;) AND (SELF\physical_quantity_symmetry_by_library_reference\externally_defined_item.item_id IN [&apos;PS001&apos;, &apos;PS002&apos;, &apos;PS003&apos;, &apos;PS004&apos;, &apos;PS005&apos;, &apos;PS006&apos;, &apos;PS007&apos;, &apos;PS008&apos;, &apos;PS009&apos;, &apos;PS010&apos;, &apos;PS011&apos;, &apos;PS012&apos;, &apos;PS013&apos;])">
      </where>
    </entity>

    <entity name="standard_tensor_order_and_symmetry"
      supertypes="tensor_order_and_symmetry_by_library_reference"
    >
      <where
        label="valid_standard_class"
        expression="(SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.source.source_id = &apos;ISO-TS-10303-1080&apos;) AND (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.item_id IN [&apos;TO001&apos;, &apos;TO002&apos;, &apos;TO003&apos;, &apos;TO004&apos;, &apos;TO005&apos;, &apos;TO006&apos;, &apos;TO007&apos;, &apos;TO008&apos;, &apos;TO009&apos;])">
      </where>
    </entity>

    <entity name="string_defined_function"
      abstract.supertype="YES"
      supertypes="defined_function string_expression"
    >
    </entity>

    <entity name="string_expression"
      abstract.supertype="YES"
      supertypes="expression"
      super.expression="ONEOF(simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function)"
    >
    </entity>

    <entity name="string_literal"
      supertypes="simple_string_expression generic_literal"
    >
      <explicit
        name="the_value">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="string_variable"
      supertypes="simple_string_expression variable"
    >
    </entity>

    <entity name="styled_item"
      supertypes="representation_item"
    >
      <explicit
        name="styles">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="presentation_style_assignment"/>
      </explicit>
      <explicit
        name="item">
        <typename name="representation_item"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY(pres_style &lt;* SELF.styles | NOT (&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;PRESENTATION_STYLE_BY_CONTEXT&apos; IN TYPEOF(pres_style)))) = 0)">
      </where>
    </entity>

    <entity name="subset"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="subset">
        <typename name="class"/>
      </explicit>
      <explicit
        name="superset">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="substring_expression"
      supertypes="string_expression multiple_arity_generic_expression"
    >
      <derived
        name="operand"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="index1"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename name="generic_expression"/>
      </derived>
      <derived
        name="index2"
        expression="SELF\multiple_arity_generic_expression.operands[3]">
        <typename name="generic_expression"/>
      </derived>
      <where
        label="wr1"
        expression="(&apos;FUNCTIONAL_DATA_MIM_LF.STRING_EXPRESSION&apos; IN TYPEOF(operand)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(index1)) AND (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_EXPRESSION&apos; IN TYPEOF(index2))">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3">
      </where>
      <where
        label="wr3"
        expression="is_int_expr(index1)">
      </where>
      <where
        label="wr4"
        expression="is_int_expr(index2)">
      </where>
    </entity>

    <entity name="surface"
      supertypes="geometric_representation_item"
    >
    </entity>

    <entity name="symbol_colour"
    >
      <explicit
        name="colour_of_symbol">
        <typename name="colour"/>
      </explicit>
    </entity>

    <entity name="symbol_representation"
      supertypes="representation"
    >
    </entity>

    <entity name="symbol_representation_map"
      supertypes="representation_map"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.SYMBOL_REPRESENTATION&apos; IN TYPEOF(SELF\representation_map.mapped_representation)">
      </where>
      <where
        label="wr2"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.AXIS2_PLACEMENT&apos; IN TYPEOF(SELF\representation_map.mapping_origin)">
      </where>
    </entity>

    <entity name="symbol_style"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="style_of_symbol">
        <typename name="symbol_style_select"/>
      </explicit>
    </entity>

    <entity name="symbol_target"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="placement">
        <typename name="axis2_placement"/>
      </explicit>
      <explicit
        name="x_scale">
        <typename name="positive_ratio_measure"/>
      </explicit>
      <explicit
        name="y_scale">
        <typename name="positive_ratio_measure"/>
      </explicit>
    </entity>

    <entity name="symbolization_by_schematic_element"
      supertypes="class presented_item_representation"
    >
      <explicit
        name="presentation">
        <typename name="schematic_element"/>
        <redeclaration
          entity-ref="presented_item_representation"/>
      </explicit>
      <explicit
        name="item">
        <typename name="symbolized_item"/>
        <redeclaration
          entity-ref="presented_item_representation"/>
      </explicit>
    </entity>

    <entity name="symbolization_of_member_or_subclass_by_schematic_element"
      supertypes="class presented_item_representation"
    >
      <explicit
        name="presentation">
        <typename name="schematic_element_definition"/>
        <redeclaration
          entity-ref="presented_item_representation"/>
      </explicit>
      <explicit
        name="item">
        <typename name="symbolized_class"/>
        <redeclaration
          entity-ref="presented_item_representation"/>
      </explicit>
    </entity>

    <entity name="symbolized_class"
      supertypes="presented_item"
    >
      <explicit
        name="item">
        <typename name="symbolized_class_select"/>
      </explicit>
    </entity>

    <entity name="symbolized_item"
      supertypes="presented_item"
    >
      <explicit
        name="item">
        <typename name="symbolized_item_select"/>
      </explicit>
    </entity>

    <entity name="symmetry_for_physical_quantity"
      supertypes="general_property_relationship"
    >
      <explicit
        name="relating_property">
        <typename name="physical_quantity_symmetry"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
      <explicit
        name="related_property">
        <typename name="physical_quantity_value"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
    </entity>

    <entity name="tan_function"
      supertypes="unary_function_call"
    >
    </entity>

    <entity name="tensor_order_and_symmetry"
      supertypes="general_property class"
    >
    </entity>

    <entity name="tensor_order_and_symmetry_by_library_reference"
      supertypes="tensor_order_and_symmetry externally_defined_item"
    >
    </entity>

    <entity name="tensor_order_and_symmetry_for_physical_quantity_space"
      supertypes="general_property_relationship"
    >
      <explicit
        name="relating_property">
        <typename name="tensor_order_and_symmetry"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
      <explicit
        name="related_property">
        <typename name="physical_quantity_space"/>
        <redeclaration
          entity-ref="general_property_relationship"/>
      </explicit>
    </entity>

    <entity name="terminator_symbol"
      supertypes="annotation_symbol_occurrence"
    >
      <explicit
        name="annotated_curve">
        <typename name="annotation_curve_occurrence"/>
      </explicit>
    </entity>

    <entity name="text_literal"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="literal">
        <typename name="presentable_text"/>
      </explicit>
      <explicit
        name="placement">
        <typename name="axis2_placement"/>
      </explicit>
      <explicit
        name="alignment">
        <typename name="text_alignment"/>
      </explicit>
      <explicit
        name="path">
        <typename name="text_path"/>
      </explicit>
      <explicit
        name="font">
        <typename name="font_select"/>
      </explicit>
    </entity>

    <entity name="text_literal_with_associated_curves"
      supertypes="text_literal"
    >
      <explicit
        name="associated_curves">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="curve"/>
      </explicit>
    </entity>

    <entity name="text_literal_with_blanking_box"
      supertypes="text_literal"
    >
      <explicit
        name="blanking">
        <typename name="planar_box"/>
      </explicit>
    </entity>

    <entity name="text_literal_with_delineation"
      supertypes="text_literal"
    >
      <explicit
        name="delineation">
        <typename name="text_delineation"/>
      </explicit>
    </entity>

    <entity name="text_literal_with_extent"
      supertypes="text_literal"
    >
      <explicit
        name="extent">
        <typename name="planar_extent"/>
      </explicit>
    </entity>

    <entity name="text_style"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="character_appearance">
        <typename name="character_style_select"/>
      </explicit>
    </entity>

    <entity name="text_style_for_defined_font"
    >
      <explicit
        name="text_colour">
        <typename name="colour"/>
      </explicit>
    </entity>

    <entity name="text_style_with_box_characteristics"
      supertypes="text_style"
    >
      <explicit
        name="characteristics">
        <aggregate type="SET"
          lower="1"
          upper="4"
        />
        <typename name="box_characteristic_select"/>
      </explicit>
      <where
        label="wr1"
        expression="SIZEOF(QUERY(c1 &lt;* SELF.characteristics | SIZEOF(QUERY(c2 &lt;* SELF.characteristics - c1 | TYPEOF(c1) = TYPEOF(c2))) &gt; 0)) = 0">
      </where>
    </entity>

    <entity name="text_style_with_mirror"
      supertypes="text_style"
    >
      <explicit
        name="mirror_placement">
        <typename name="axis2_placement"/>
      </explicit>
    </entity>

    <entity name="text_style_with_spacing"
      supertypes="text_style"
    >
      <explicit
        name="character_spacing">
        <typename name="character_spacing_select"/>
      </explicit>
    </entity>

    <entity name="thermodynamic_temperature_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="thermodynamic_temperature_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="time_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.TIME_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="time_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 1.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="trimmed_curve"
      supertypes="bounded_curve"
    >
      <explicit
        name="basis_curve">
        <typename name="curve"/>
      </explicit>
      <explicit
        name="trim_1">
        <aggregate type="SET"
          lower="1"
          upper="2"
        />
        <typename name="trimming_select"/>
      </explicit>
      <explicit
        name="trim_2">
        <aggregate type="SET"
          lower="1"
          upper="2"
        />
        <typename name="trimming_select"/>
      </explicit>
      <explicit
        name="sense_agreement">
        <builtintype type="BOOLEAN"
        />
      </explicit>
      <explicit
        name="master_representation">
        <typename name="trimming_preference"/>
      </explicit>
      <where
        label="wr1"
        expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))">
      </where>
      <where
        label="wr2"
        expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))">
      </where>
    </entity>

    <entity name="two_direction_repeat_factor"
      supertypes="one_direction_repeat_factor"
    >
      <explicit
        name="second_repeat_factor">
        <typename name="vector"/>
      </explicit>
    </entity>

    <entity name="unary_boolean_expression"
      abstract.supertype="YES"
      supertypes="boolean_expression unary_generic_expression"
      super.expression="ONEOF(not_expression, odd_function)"
    >
    </entity>

    <entity name="unary_function_call"
      abstract.supertype="YES"
      supertypes="unary_numeric_expression"
      super.expression="ONEOF(abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function)"
    >
    </entity>

    <entity name="unary_generic_expression"
      abstract.supertype="YES"
      supertypes="generic_expression"
    >
      <explicit
        name="operand">
        <typename name="generic_expression"/>
      </explicit>
    </entity>

    <entity name="unary_numeric_expression"
      abstract.supertype="YES"
      supertypes="numeric_expression unary_generic_expression"
      super.expression="ONEOF(unary_function_call)"
    >
      <explicit
        name="operand">
        <typename name="numeric_expression"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="uncertainty_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_measure_value(SELF\measure_with_unit.value_component)">
      </where>
    </entity>

    <entity name="uniform_curve"
      supertypes="b_spline_curve"
    >
    </entity>

    <entity name="uniform_product_space"
      supertypes="maths_space generic_literal"
    >
      <explicit
        name="base">
        <typename name="maths_space"/>
      </explicit>
      <explicit
        name="exponent">
        <typename name="positive_integer"/>
      </explicit>
      <where
        label="wr1"
        expression="expression_is_constant(base)">
      </where>
      <where
        label="wr2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="wr3"
        expression="base &lt;&gt; the_empty_space">
      </where>
    </entity>

    <entity name="union"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="operand">
        <aggregate type="SET"
          lower="2"
          upper="?"
        />
        <typename name="class"/>
      </explicit>
      <explicit
        name="resultant">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="unit_defined_maths_space_context"
      supertypes="defined_maths_space_context"
    >
      <explicit
        name="unit_basis">
        <typename name="unit"/>
      </explicit>
    </entity>

    <entity name="usage_of_schematic_element_occurrence"
      supertypes="mapped_item"
    >
      <where
        label="schematic_element_occurrence_as_part"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;SCHEMATIC_ELEMENT_OCCURRENCE&apos; IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)">
      </where>
      <where
        label="implicit_schematic_element_definition_as_whole"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;IMPLICIT_SCHEMATIC_ELEMENT_DEFINITION&apos; IN TYPEOF(using_representations(SELF))">
      </where>
    </entity>

    <entity name="value_function"
      supertypes="numeric_expression unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="string_expression"/>
        <redeclaration
          entity-ref="unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="variable"
      abstract.supertype="YES"
      supertypes="generic_variable"
      super.expression="ONEOF(numeric_variable, boolean_variable, string_variable)"
    >
    </entity>

    <entity name="variable_semantics"
      abstract.supertype="YES"
    >
    </entity>

    <entity name="vector"
      supertypes="geometric_representation_item"
    >
      <explicit
        name="orientation">
        <typename name="direction"/>
      </explicit>
      <explicit
        name="magnitude">
        <typename name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="magnitude &gt;= 0.000000">
      </where>
    </entity>

    <entity name="volume"
      supertypes="geometric_representation_item"
    >
      <where
        label="wr1"
        expression="SELF\geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity name="volume_measure_with_unit"
      supertypes="measure_with_unit"
    >
      <where
        label="wr1"
        expression="&apos;FUNCTIONAL_DATA_MIM_LF.VOLUME_UNIT&apos; IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity name="volume_unit"
      supertypes="named_unit"
    >
      <where
        label="wr1"
        expression="(SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
      </where>
    </entity>

    <entity name="xor_expression"
      supertypes="binary_boolean_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="boolean_expression"/>
        <redeclaration
          entity-ref="binary_generic_expression"/>
      </explicit>
    </entity>

    <function name="acyclic">
      <parameter name="arg1">
        <typename name="generic_expression"/>
      </parameter>
      <parameter name="arg2">
        <aggregate type="SET"
        />
        <typename name="generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    result : BOOLEAN;
  END_LOCAL;

  IF &apos;FUNCTIONAL_DATA_MIM_LF.SIMPLE_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    RETURN (TRUE);
  END_IF;
  IF arg1 IN arg2 THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.UNARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    RETURN (acyclic(arg1\unary_generic_expression.operand, arg2 + [arg1]));
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.BINARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    RETURN (acyclic(arg1\binary_generic_expression.operands[1], arg2 + [arg1]) AND acyclic(arg1\binary_generic_expression.operands[2], arg2 + [arg1]));
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    result := TRUE;
    REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
      result := result AND acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2 + [arg1]);
    END_REPEAT;
    RETURN (result);
  END_IF;
      </algorithm>
    </function>

    <function name="acyclic_composite_text">
      <parameter name="start_composite">
        <typename name="composite_text"/>
      </parameter>
      <parameter name="child_text">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="text_or_character"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
    local_composite_text : SET OF composite_text;
    local_annotation_text : SET OF annotation_text;
    local_children : SET OF text_or_character;
  END_LOCAL;

  local_composite_text := QUERY(child &lt;* child_text | &apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos; IN TYPEOF(child));
  IF SIZEOF(local_composite_text) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(local_composite_text);
      IF start_composite :=: local_composite_text[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  local_children := child_text;
  IF SIZEOF(local_composite_text) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(local_composite_text);
      local_children := local_children + local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;
  local_annotation_text := QUERY(child &lt;* child_text | &apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT&apos; IN TYPEOF(child));
  IF SIZEOF(local_annotation_text) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(local_annotation_text);
      local_children := local_children + QUERY(item &lt;* local_annotation_text[i]\mapped_item.mapping_source.mapped_representation.items | SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.ANNOTATION_TEXT&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_TEXT&apos;] * TYPEOF(item)) &gt; 0);
    END_REPEAT;
  END_IF;
  IF local_children :&lt;&gt;: child_text THEN
    RETURN (acyclic_composite_text(start_composite, local_children));
  ELSE
    RETURN (TRUE);
  END_IF;
      </algorithm>
    </function>

    <function name="acyclic_curve_replica">
      <parameter name="rep">
        <typename name="curve_replica"/>
      </parameter>
      <parameter name="parent">
        <typename name="curve"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF NOT (&apos;FUNCTIONAL_DATA_MIM_LF.CURVE_REPLICA&apos; IN TYPEOF(parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_curve_replica(rep, parent\curve_replica.parent_curve));
  END_IF;
      </algorithm>
    </function>

    <function name="acyclic_mapped_item_usage">
      <parameter name="rep">
        <typename name="representation"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    items : SET OF representation_item;
  END_LOCAL;

  items := QUERY(item &lt;* rep.items | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(item));
  IF SIZEOF(items) = 0 THEN
    RETURN (FALSE);
  ELSE
    REPEAT i := 1 TO HIINDEX(items);
      IF items[i]\mapped_item.mapping_source.mapped_representation :=: rep THEN
        RETURN (TRUE);
      ELSE
        RETURN (acyclic_mapped_item_usage(items[i]\mapped_item.mapping_source.mapped_representation));
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
      </algorithm>
    </function>

    <function name="acyclic_mapped_representation">
      <parameter name="parent_set">
        <aggregate type="SET"
        />
        <typename name="representation"/>
      </parameter>
      <parameter name="children_set">
        <aggregate type="SET"
        />
        <typename name="representation_item"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    x : SET OF representation_item;
    y : SET OF representation_item;
  END_LOCAL;

  x := QUERY(z &lt;* children_set | &apos;FUNCTIONAL_DATA_MIM_LF.MAPPED_ITEM&apos; IN TYPEOF(z));
  IF SIZEOF(x) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item.mapping_source.mapped_representation, x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  x := children_set - x;
  IF SIZEOF(x) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      y := QUERY(z &lt;* bag_to_set(USEDIN(x[i], &apos;&apos;)) | &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_ITEM&apos; IN TYPEOF(z));
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="acyclic_product_category_relationship">
      <parameter name="relation">
        <typename name="product_category_relationship"/>
      </parameter>
      <parameter name="children">
        <aggregate type="SET"
        />
        <typename name="product_category"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    x : SET OF product_category_relationship;
    local_children : SET OF product_category;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(children);
    IF relation.category :=: children[i] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN(relation.category, &apos;FUNCTIONAL_DATA_MIM_LF.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY&apos;));
  local_children := children + relation.category;
  IF SIZEOF(x) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="all_members_of_es">
      <parameter name="sv">
        <aggregate type="SET"
        />
        <typename name="maths_value"/>
      </parameter>
      <parameter name="es">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  CONSTANT
    base_types : SET OF STRING := [&apos;NUMBER&apos;, &apos;COMPLEX_NUMBER_LITERAL&apos;, &apos;REAL&apos;, &apos;INTEGER&apos;, &apos;LOGICAL&apos;, &apos;BOOLEAN&apos;, &apos;STRING&apos;, &apos;BINARY&apos;, &apos;MATHS_SPACE&apos;, &apos;MATHS_FUNCTION&apos;, &apos;LIST&apos;, &apos;ELEMENTARY_SPACE_ENUMERATORS&apos;, &apos;ORDERING_TYPE&apos;, &apos;LOWER_UPPER&apos;, &apos;SYMMETRY_TYPE&apos;, &apos;ELEMENTARY_FUNCTION_ENUMERATORS&apos;, &apos;OPEN_CLOSED&apos;, &apos;SPACE_CONSTRAINT_TYPE&apos;, &apos;REPACKAGE_OPTIONS&apos;, &apos;EXTENSION_OPTIONS&apos;];
  END_CONSTANT;

  LOCAL
    v : maths_value;
    key_type : STRING := &apos;&apos;;
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;

  IF NOT EXISTS(sv) OR NOT EXISTS(es) THEN
    RETURN (FALSE);
  END_IF;
  CASE es OF 
    es_numbers:
      key_type := &apos;NUMBER&apos;;
    es_complex_numbers:
      key_type := &apos;COMPLEX_NUMBER_LITERAL&apos;;
    es_reals:
      key_type := &apos;REAL&apos;;
    es_integers:
      key_type := &apos;INTEGER&apos;;
    es_logicals:
      key_type := &apos;LOGICAL&apos;;
    es_booleans:
      key_type := &apos;BOOLEAN&apos;;
    es_strings:
      key_type := &apos;STRING&apos;;
    es_binarys:
      key_type := &apos;BINARY&apos;;
    es_maths_spaces:
      key_type := &apos;MATHS_SPACE&apos;;
    es_maths_functions:
      key_type := &apos;MATHS_FUNCTION&apos;;
    es_generics:
      RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF(sv);
    IF NOT EXISTS(sv[i]) THEN
      RETURN (FALSE);
    END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN
      SKIP;
    END_IF;
    IF (es = es_numbers) AND (&apos;COMPLEX_NUMBER_LITERAL&apos; IN types) THEN
      SKIP;
    END_IF;
    IF SIZEOF(base_types * types) &gt; 0 THEN
      RETURN (FALSE);
    END_IF;
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc, es) THEN
        IF NOT compatible_spaces(vspc, make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (cum);
      </algorithm>
    </function>

    <function name="any_space_satisfies">
      <parameter name="sc">
        <typename name="space_constraint_type"/>
      </parameter>
      <parameter name="spc">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;

  IF (sc = sc_equal) OR NOT (&apos;ELEMENTARY_SPACE&apos; IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="assoc_product_space">
      <parameter name="ts1">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="ts2">
        <typename name="tuple_space"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    types1 : SET OF STRING := stripped_typeof(ts1);
    types2 : SET OF STRING := stripped_typeof(ts2);
    up1 : uniform_product_space := make_uniform_product_space(the_reals, 1);
    up2 : uniform_product_space := make_uniform_product_space(the_reals, 1);
    lp1 : listed_product_space := the_zero_tuple_space;
    lp2 : listed_product_space := the_zero_tuple_space;
    lps : listed_product_space := the_zero_tuple_space;
    et1 : extended_tuple_space := the_tuples;
    et2 : extended_tuple_space := the_tuples;
    ets : extended_tuple_space := the_tuples;
    use_up1 : BOOLEAN;
    use_up2 : BOOLEAN;
    use_lp1 : BOOLEAN;
    use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;

  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types1 THEN
    up1 := ts1;
    use_up1 := TRUE;
    use_lp1 := FALSE;
  ELSE
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN types1 THEN
      lp1 := ts1;
      use_up1 := FALSE;
      use_lp1 := TRUE;
    ELSE
      IF NOT (&apos;EXTENDED_TUPLE_SPACE&apos; IN types1) THEN
        RETURN (?);
      END_IF;
      et1 := ts1;
      use_up1 := FALSE;
      use_lp1 := FALSE;
    END_IF;
  END_IF;
  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types2 THEN
    up2 := ts2;
    use_up2 := TRUE;
    use_lp2 := FALSE;
  ELSE
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN types2 THEN
      lp2 := ts2;
      use_up2 := FALSE;
      use_lp2 := TRUE;
    ELSE
      IF NOT (&apos;EXTENDED_TUPLE_SPACE&apos; IN types2) THEN
        RETURN (?);
      END_IF;
      et2 := ts2;
      use_up2 := FALSE;
      use_lp2 := FALSE;
    END_IF;
  END_IF;
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base:up1.exponent, up2.base:up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        factors := [up1.base:up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        factors := [up2.base:up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF(factors);
            IF et1.extender &lt;&gt; factors[i] THEN
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
      </algorithm>
    </function>

    <function name="atan2">
      <parameter name="y">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="x">
        <builtintype type="REAL"
        />
      </parameter>
      <builtintype type="REAL"
      />
      <algorithm>
  LOCAL
    r : REAL;
  END_LOCAL;

  IF (y = 0.000000) AND (x = 0.000000) THEN
    RETURN (?);
  END_IF;
  r := ATAN(y, x);
  IF x &lt; 0.000000 THEN
    IF y &lt; 0.000000 THEN
      r := r - PI;
    ELSE
      r := r + PI;
    END_IF;
  END_IF;
  RETURN (r);
      </algorithm>
    </function>

    <function name="bag_to_set">
      <parameter name="the_bag">
        <aggregate type="BAG"
        />
        <builtintype type="GENERIC"
          typelabel="intype"
        />
      </parameter>
      <aggregate type="SET"
      />
      <builtintype type="GENERIC"
        typelabel="intype"
      />
      <algorithm>
  LOCAL
    the_set : SET OF GENERIC:intype := [];
  END_LOCAL;

  IF SIZEOF(the_bag) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
      </algorithm>
    </function>

    <function name="bool">
      <parameter name="lgcl">
        <builtintype type="LOGICAL"
        />
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF NOT EXISTS(lgcl) THEN
    RETURN (FALSE);
  END_IF;
  IF lgcl &lt;&gt; TRUE THEN
    RETURN (FALSE);
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="build_2axes">
      <parameter name="ref_direction">
        <typename name="direction"/>
      </parameter>
      <aggregate type="LIST"
        lower="2"
        upper="2"
      />
      <typename name="direction"/>
      <algorithm>
  LOCAL
    d : direction := NVL(normalise(ref_direction), dummy_gri||direction([1.000000, 0.000000]));
  END_LOCAL;

  RETURN ([d, orthogonal_complement(d)]);
      </algorithm>
    </function>

    <function name="check_sparse_index_domain">
      <parameter name="idxdom">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="base">
        <typename name="zero_or_one"/>
      </parameter>
      <parameter name="shape">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
      </parameter>
      <parameter name="order">
        <typename name="ordering_type"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;

  mthspc := factor1(idxdom);
  interval := mthspc;
  IF order = by_rows THEN
    i := 1;
  ELSE
    i := 2;
  END_IF;
  RETURN (bool((interval.min &lt;= base) AND (interval.max &gt;= base + shape[i])));
      </algorithm>
    </function>

    <function name="check_sparse_index_to_loc">
      <parameter name="index_range">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="loc_domain">
        <typename name="tuple_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    temp : maths_space;
    idx_rng_itvl : finite_integer_interval;
    loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;

  temp := factor1(index_range);
  IF schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(temp) THEN
    temp := factor1(temp);
  END_IF;
  IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1(loc_domain);
  IF schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(temp) THEN
    temp := factor1(temp);
  END_IF;
  IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min &lt;= idx_rng_itvl.min) AND (idx_rng_itvl.max &lt;= loc_dmn_itvl.max + 1)));
      </algorithm>
    </function>

    <function name="check_sparse_loc_range">
      <parameter name="locrng">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="base">
        <typename name="zero_or_one"/>
      </parameter>
      <parameter name="shape">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="positive_integer"/>
      </parameter>
      <parameter name="order">
        <typename name="ordering_type"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;

  IF space_dimension(locrng) &lt;&gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  mthspc := factor1(locrng);
  IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN
    i := 2;
  ELSE
    i := 1;
  END_IF;
  RETURN (bool((interval.min &gt;= base) AND (interval.max &lt;= base + shape[i] - 1)));
      </algorithm>
    </function>

    <function name="check_text_alignment">
      <parameter name="ct">
        <typename name="composite_text"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;
  RETURN (SIZEOF(a) = 1);
      </algorithm>
    </function>

    <function name="check_text_font">
      <parameter name="ct">
        <typename name="composite_text"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;
  RETURN (SIZEOF(f) &lt;= 1);
      </algorithm>
    </function>

    <function name="compare_basis_and_coef">
      <parameter name="basis">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="b_spline_basis"/>
      </parameter>
      <parameter name="coef">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;

  IF NOT EXISTS(basis) OR NOT EXISTS(coef) THEN
    RETURN (FALSE);
  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS(shape) THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(shape) &lt; SIZEOF(basis) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF(basis);
    IF (basis[i].num_basis = shape[i]) &lt;&gt; TRUE THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="compatible_complex_number_regions">
      <parameter name="sp1">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="sp2">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(sp1);
    crgn1 : cartesian_complex_number_region;
    crgn2 : cartesian_complex_number_region;
    prgn1 : polar_complex_number_region;
    prgn2 : polar_complex_number_region;
    prgn1c2 : polar_complex_number_region;
    prgn2c1 : polar_complex_number_region;
    sp1_is_crgn : BOOLEAN;
    sp2_is_crgn : BOOLEAN;
  END_LOCAL;

  IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof(sp2);
  IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint) AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND (prgn1.centre.real_part = prgn2.centre.real_part) AND (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    IF NOT compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    IF (prgn1.direction_constraint.max &gt; PI) AND (prgn2.direction_constraint.max &lt; PI) THEN
      RETURN (compatible_intervals(prgn2.direction_constraint, make_finite_real_interval( - PI, open, prgn1.direction_constraint.max - 2.000000 * PI, prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max &gt; PI) AND (prgn1.direction_constraint.max &lt; PI) THEN
      RETURN (compatible_intervals(prgn1.direction_constraint, make_finite_real_interval( - PI, open, prgn2.direction_constraint.max - 2.000000 * PI, prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1, prgn2c1) AND compatible_complex_number_regions(prgn1c2, prgn2));
      </algorithm>
    </function>

    <function name="compatible_es_values">
      <parameter name="esval1">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <parameter name="esval2">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    esval1_is_numeric : LOGICAL;
    esval2_is_numeric : LOGICAL;
  END_LOCAL;

  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 &gt;= es_numbers) AND (esval1 &lt;= es_integers);
  esval2_is_numeric := (esval2 &gt;= es_numbers) AND (esval2 &lt;= es_integers);
  IF esval1_is_numeric AND (esval2 = es_numbers) OR esval2_is_numeric AND (esval1 = es_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF (esval1 = es_logicals) AND (esval2 = es_booleans) OR (esval1 = es_booleans) AND (esval2 = es_logicals) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="compatible_intervals">
      <parameter name="sp1">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="sp2">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    amin : REAL;
    amax : REAL;
  END_LOCAL;

  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);
    amax := real_max(sp2);
    IF amin &gt; amax THEN
      RETURN (FALSE);
    END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);
    amax := real_max(sp1);
    IF amin &gt; amax THEN
      RETURN (FALSE);
    END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="compatible_spaces">
      <parameter name="sp1">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="sp2">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types1 : SET OF STRING := stripped_typeof(sp1);
    types2 : SET OF STRING := stripped_typeof(sp2);
    lgcl : LOGICAL := UNKNOWN;
    m : INTEGER;
    n : INTEGER;
    s1 : maths_space;
    s2 : maths_space;
  END_LOCAL;

  IF &apos;FINITE_SPACE&apos; IN types1 THEN
    REPEAT i := 1 TO SIZEOF(sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF &apos;FINITE_SPACE&apos; IN types2 THEN
    REPEAT i := 1 TO SIZEOF(sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF &apos;ELEMENTARY_SPACE&apos; IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, sp2\elementary_space.space_id));
    END_IF;
    IF (&apos;FINITE_INTEGER_INTERVAL&apos; IN types2) OR (&apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types2) OR (&apos;INTEGER_INTERVAL_TO_MAX&apos; IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF (&apos;FINITE_REAL_INTERVAL&apos; IN types2) OR (&apos;REAL_INTERVAL_FROM_MIN&apos; IN types2) OR (&apos;REAL_INTERVAL_TO_MAX&apos; IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF (&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types2) OR (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF &apos;TUPLE_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;FUNCTION_SPACE&apos; IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN (TRUE);
  END_IF;
  IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF (&apos;FINITE_INTEGER_INTERVAL&apos; IN types1) OR (&apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types1) OR (&apos;INTEGER_INTERVAL_TO_MAX&apos; IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF (&apos;FINITE_REAL_INTERVAL&apos; IN types1) OR (&apos;REAL_INTERVAL_FROM_MIN&apos; IN types1) OR (&apos;REAL_INTERVAL_TO_MAX&apos; IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF (&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types1) OR (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF &apos;TUPLE_SPACE&apos; IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;FUNCTION_SPACE&apos; IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1, es_integers) THEN
    IF subspace_of_es(sp2, es_integers) THEN
      RETURN (compatible_intervals(sp1, sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_reals) THEN
    IF subspace_of_es(sp2, es_reals) THEN
      RETURN (compatible_intervals(sp1, sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1, es_complex_numbers) THEN
    IF subspace_of_es(sp2, es_complex_numbers) THEN
      RETURN (compatible_complex_number_regions(sp1, sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2, es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types1 THEN
    IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types2 THEN
      IF sp1\uniform_product_space.exponent &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base, sp2\uniform_product_space.base));
    END_IF;
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN types2 THEN
      n := SIZEOF(sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent &lt;&gt; n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base, sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m &lt; n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(sp2\extended_tuple_space.base, make_uniform_product_space(sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF &apos;FUNCTION_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN types1 THEN
    n := SIZEOF(sp1\listed_product_space.factors);
    IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types2 THEN
      IF n &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base, sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN types2 THEN
      IF n &lt;&gt; SIZEOF(sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i], sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(sp2\extended_tuple_space.base, make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF schema_prefix + &apos;FUNCTION_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types1 THEN
    IF (&apos;UNIFORM_PRODUCT_SPACE&apos; IN types2) OR (&apos;LISTED_PRODUCT_SPACE&apos; IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender, sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base, make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)), sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base, sp2\extended_tuple_space.base));
      END_IF;
      IF n &gt; m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base, assoc_product_space(sp2\extended_tuple_space.base, make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF &apos;FUNCTION_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTION_SPACE&apos; IN types1 THEN
    IF &apos;FUNCTION_SPACE&apos; IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF 
        sc_equal:
          BEGIN
            CASE sp2\function_space.domain_constraint OF 
              sc_equal:
                lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
              sc_subspace:
                lgcl := subspace_of(s1, s2);
              sc_member:
                lgcl := member_of(s1, s2);
              sc_subspace:
                BEGIN
                  CASE sp2\function_space.domain_constraint OF 
                    sc_equal:
                      lgcl := subspace_of(s2, s1);
                    sc_subspace:
                      lgcl := compatible_spaces(s1, s2);
                    sc_member:
                      lgcl := UNKNOWN;
                    sc_member:
                      BEGIN
                        CASE sp2\function_space.domain_constraint OF 
                          sc_equal:
                            lgcl := member_of(s2, s1);
                          sc_subspace:
                            lgcl := UNKNOWN;
                          sc_member:
                            lgcl := compatible_spaces(s1, s2);
                        END_CASE;
                      END;
                  END_CASE;
                END;
            END_CASE;
          END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF 
        sc_equal:
          BEGIN
            CASE sp2\function_space.range_constraint OF 
              sc_equal:
                lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
              sc_subspace:
                lgcl := subspace_of(s1, s2);
              sc_member:
                lgcl := member_of(s1, s2);
              sc_subspace:
                BEGIN
                  CASE sp2\function_space.range_constraint OF 
                    sc_equal:
                      lgcl := subspace_of(s2, s1);
                    sc_subspace:
                      lgcl := compatible_spaces(s1, s2);
                    sc_member:
                      lgcl := UNKNOWN;
                    sc_member:
                      BEGIN
                        CASE sp2\function_space.range_constraint OF 
                          sc_equal:
                            lgcl := member_of(s2, s1);
                          sc_subspace:
                            lgcl := UNKNOWN;
                          sc_member:
                            lgcl := compatible_spaces(s1, s2);
                        END_CASE;
                      END;
                  END_CASE;
                END;
            END_CASE;
          END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="composable_sequence">
      <parameter name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  REPEAT i := 1 TO SIZEOF(operands) - 1;
    IF NOT compatible_spaces(operands[i].range, operands[i + 1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="constraints_param_b_spline">
      <parameter name="degree">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="up_knots">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="up_cp">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="knot_mult">
        <aggregate type="LIST"
        />
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="knots">
        <aggregate type="LIST"
        />
        <typename name="parameter_value"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    result : BOOLEAN := TRUE;
    k : INTEGER;
    sum : INTEGER;
  END_LOCAL;

  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots;
    sum := sum + knot_mult[i];
  END_REPEAT;
  IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR (sum &lt;&gt; degree + up_cp + 2) THEN
    result := FALSE;
    RETURN (result);
  END_IF;
  k := knot_mult[1];
  IF (k &lt; 1) OR (k &gt; degree + 1) THEN
    result := FALSE;
    RETURN (result);
  END_IF;
  REPEAT i := 2 TO up_knots;
    IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
    k := knot_mult[i];
    IF (i &lt; up_knots) AND (k &gt; degree) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
    IF (i = up_knots) AND (k &gt; degree + 1) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
      </algorithm>
    </function>

    <function name="convert_to_literal">
      <parameter name="val">
        <typename name="maths_atom"/>
      </parameter>
      <typename name="generic_literal"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(val);
  END_LOCAL;

  IF &apos;INTEGER&apos; IN types THEN
    RETURN (make_int_literal(val));
  END_IF;
  IF &apos;REAL&apos; IN types THEN
    RETURN (make_real_literal(val));
  END_IF;
  IF &apos;BOOLEAN&apos; IN types THEN
    RETURN (make_boolean_literal(val));
  END_IF;
  IF &apos;STRING&apos; IN types THEN
    RETURN (make_string_literal(val));
  END_IF;
  IF &apos;LOGICAL&apos; IN types THEN
    RETURN (make_logical_literal(val));
  END_IF;
  IF &apos;BINARY&apos; IN types THEN
    RETURN (make_binary_literal(val));
  END_IF;
  IF schema_prefix + &apos;MATHS_ENUM_ATOM&apos; IN types THEN
    RETURN (make_maths_enum_literal(val));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="convert_to_maths_function">
      <parameter name="func">
        <typename name="maths_function_select"/>
      </parameter>
      <typename name="maths_function"/>
      <algorithm>
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;

  IF schema_prefix + &apos;MATHS_FUNCTION&apos; IN TYPEOF(func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function(efenum);
  END_IF;
  RETURN (mthfun);
      </algorithm>
    </function>

    <function name="convert_to_maths_value">
      <parameter name="val">
        <builtintype type="GENERIC"
          typelabel="g"
        />
      </parameter>
      <typename name="maths_value"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(val);
    ival : maths_integer;
    rval : maths_real;
    nval : maths_number;
    tfval : maths_boolean;
    lval : maths_logical;
    sval : maths_string;
    bval : maths_binary;
    tval : maths_tuple := the_empty_maths_tuple;
    mval : maths_value;
  END_LOCAL;

  IF schema_prefix + &apos;MATHS_VALUE&apos; IN types THEN
    RETURN (val);
  END_IF;
  IF &apos;INTEGER&apos; IN types THEN
    ival := val;
    RETURN (ival);
  END_IF;
  IF &apos;REAL&apos; IN types THEN
    rval := val;
    RETURN (rval);
  END_IF;
  IF &apos;NUMBER&apos; IN types THEN
    nval := val;
    RETURN (nval);
  END_IF;
  IF &apos;BOOLEAN&apos; IN types THEN
    tfval := val;
    RETURN (tfval);
  END_IF;
  IF &apos;LOGICAL&apos; IN types THEN
    lval := val;
    RETURN (lval);
  END_IF;
  IF &apos;STRING&apos; IN types THEN
    sval := val;
    RETURN (sval);
  END_IF;
  IF &apos;BINARY&apos; IN types THEN
    bval := val;
    RETURN (bval);
  END_IF;
  IF &apos;LIST&apos; IN types THEN
    REPEAT i := 1 TO SIZEOF(val);
      mval := convert_to_maths_value(val[i]);
      IF NOT EXISTS(mval) THEN
        RETURN (?);
      END_IF;
      INSERT(tval, mval, i - 1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="convert_to_operand">
      <parameter name="val">
        <typename name="maths_value"/>
      </parameter>
      <typename name="generic_expression"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(val);
  END_LOCAL;

  IF &apos;GENERIC_EXPRESSION&apos; IN types THEN
    RETURN (val);
  END_IF;
  IF &apos;MATHS_ATOM&apos; IN types THEN
    RETURN (convert_to_literal(val));
  END_IF;
  IF &apos;ATOM_BASED_VALUE&apos; IN types THEN
    RETURN (make_atom_based_literal(val));
  END_IF;
  IF &apos;MATHS_TUPLE&apos; IN types THEN
    RETURN (make_maths_tuple_literal(val));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="convert_to_operands">
      <parameter name="values">
        <typename name="maths_value"/>
      </parameter>
      <aggregate type="LIST"
      />
      <typename name="generic_expression"/>
      <algorithm>
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;

  IF NOT EXISTS(values) THEN
    RETURN (?);
  END_IF;
  REPEAT i := LOINDEX(values) TO HIINDEX(values);
    INSERT(operands, convert_to_operand(values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
      </algorithm>
    </function>

    <function name="convert_to_operands_prcmfn">
      <parameter name="srcdom">
        <typename name="maths_space_or_function"/>
      </parameter>
      <parameter name="prepfun">
        <aggregate type="LIST"
        />
        <typename name="maths_function"/>
      </parameter>
      <parameter name="finfun">
        <typename name="maths_function_select"/>
      </parameter>
      <aggregate type="LIST"
        lower="2"
        upper="?"
      />
      <typename name="generic_expression"/>
      <algorithm>
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;

  INSERT(operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF(prepfun);
    INSERT(operands, prepfun[i], i);
  END_REPEAT;
  INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun) + 1);
  RETURN (operands);
      </algorithm>
    </function>

    <function name="curve_weights_positive">
      <parameter name="b">
        <typename name="rational_b_spline_curve"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    result : BOOLEAN := TRUE;
  END_LOCAL;

  REPEAT i := 0 TO b.upper_index_on_control_points;
    IF b.weights[i] &lt;= 0.000000 THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
      </algorithm>
    </function>

    <function name="definite_integral_check">
      <parameter name="domain">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="vrblint">
        <typename name="input_selector"/>
      </parameter>
      <parameter name="lowerinf">
        <builtintype type="BOOLEAN"
        />
      </parameter>
      <parameter name="upperinf">
        <builtintype type="BOOLEAN"
        />
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;

  IF (space_dimension(domain) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(domain))) THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  k := vrblint;
  IF k &gt; dim THEN
    RETURN (FALSE);
  END_IF;
  fspc := factor_space(domn, k);
  IF NOT (schema_prefix + &apos;REAL_INTERVAL&apos; IN TYPEOF(fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists(fspc) THEN
    RETURN (FALSE);
  END_IF;
  IF upperinf AND max_exists(fspc) THEN
    RETURN (FALSE);
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="definite_integral_expr_check">
      <parameter name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="generic_expression"/>
      </parameter>
      <parameter name="lowerinf">
        <builtintype type="BOOLEAN"
        />
      </parameter>
      <parameter name="upperinf">
        <builtintype type="BOOLEAN"
        />
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;

  IF NOT lowerinf THEN
    nops := nops + 1;
  END_IF;
  IF NOT upperinf THEN
    nops := nops + 1;
  END_IF;
  IF SIZEOF(operands) &lt;&gt; nops THEN
    RETURN (FALSE);
  END_IF;
  IF NOT (&apos;GENERIC_VARIABLE&apos; IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space(operands[2]) THEN
    RETURN (FALSE);
  END_IF;
  vspc := values_space_of(operands[2]);
  IF NOT (&apos;REAL_INTERVAL&apos; IN stripped_typeof(vspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf THEN
    IF min_exists(vspc) THEN
      RETURN (FALSE);
    END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space(operands[3]) THEN
      RETURN (FALSE);
    END_IF;
    bspc := values_space_of(operands[3]);
    IF NOT compatible_spaces(bspc, vspc) THEN
      RETURN (FALSE);
    END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists(vspc) THEN
      RETURN (FALSE);
    END_IF;
  ELSE
    IF NOT has_values_space(operands[k]) THEN
      RETURN (FALSE);
    END_IF;
    bspc := values_space_of(operands[k]);
    IF NOT compatible_spaces(bspc, vspc) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="derive_definite_integral_domain">
      <parameter name="igrl">
        <typename name="definite_integral_function"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  FUNCTION process_product_space (spc : product_space; idx : INTEGER; prefix : INTEGER; vdomn : maths_space):product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;

    IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN TYPEOF(spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx &lt;= uspc.exponent THEN
        expnt := expnt - 1;
      END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base, expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx &lt;= SIZEOF(factors) THEN
        REMOVE(factors, idx);
      END_IF;
      IF prefix &gt; 0 THEN
        INSERT(factors, vdomn, 0);
        IF prefix &gt; 1 THEN
          INSERT(factors, vdomn, 0);
        END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;

  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF(idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool((space_dimension(idomn) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN types));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;

  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF(idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN
    prefix := prefix + 1;
  END_IF;
  IF igrl.upper_limit_pos_infinity THEN
    prefix := prefix + 1;
  END_IF;
  vdomn := factor_space(idomn, idx);
  IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
  ELSE
    idomn := process_product_space(idomn, idx, prefix, vdomn);
  END_IF;
  IF tupled THEN
    RETURN (one_tuples_of(idomn));
  ELSE
    RETURN (idomn);
  END_IF;
      </algorithm>
    </function>

    <function name="derive_dimensional_exponents">
      <parameter name="x">
        <typename name="unit"/>
      </parameter>
      <typename name="dimensional_exponents"/>
      <algorithm>
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000);
  END_LOCAL;

  IF &apos;FUNCTIONAL_DATA_MIM_LF.DERIVED_UNIT&apos; IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent;
      result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent;
      result.time_exponent := result.time_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent;
      result.electric_current_exponent := result.electric_current_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent;
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent;
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent;
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent;
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
      </algorithm>
    </function>

    <function name="derive_elementary_function_domain">
      <parameter name="ef_val">
        <typename name="elementary_function_enumerators"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  IF NOT EXISTS(ef_val) THEN
    RETURN (?);
  END_IF;
  CASE ef_val OF 
    ef_and:
      RETURN (make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_or:
      RETURN (make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_not:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_xor:
      RETURN (make_uniform_product_space(the_logicals, 2));
    ef_negate_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_add_i:
      RETURN (the_integer_tuples);
    ef_subtract_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_multiply_i:
      RETURN (the_integer_tuples);
    ef_divide_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_mod_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_exponentiate_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_eq_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_ne_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_gt_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_lt_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_ge_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_le_i:
      RETURN (make_uniform_product_space(the_integers, 2));
    ef_abs_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_if_i:
      RETURN (make_listed_product_space([the_logicals, the_integers, the_integers]));
    ef_negate_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_add_r:
      RETURN (the_real_tuples);
    ef_subtract_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_multiply_r:
      RETURN (the_real_tuples);
    ef_divide_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_mod_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_exponentiate_r:
      RETURN (make_listed_product_space([the_nonnegative_reals, the_reals]));
    ef_exponentiate_ri:
      RETURN (make_listed_product_space([the_reals, the_integers]));
    ef_eq_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_ne_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_gt_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_lt_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_ge_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_le_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_abs_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_acos_r:
      RETURN (make_uniform_product_space(the_neg1_one_interval, 1));
    ef_asin_r:
      RETURN (make_uniform_product_space(the_neg1_one_interval, 1));
    ef_atan2_r:
      RETURN (make_uniform_product_space(the_reals, 2));
    ef_cos_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_exp_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_ln_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log2_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log10_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_sin_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_sqrt_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_if_r:
      RETURN (make_listed_product_space([the_logicals, the_reals, the_reals]));
    ef_negate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c:
      RETURN (the_complex_tuples);
    ef_subtract_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 2));
    ef_multiply_c:
      RETURN (the_complex_tuples);
    ef_divide_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_ci:
      RETURN (make_listed_product_space([the_complex_numbers, the_integers]));
    ef_eq_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 2));
    ef_ne_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 2));
    ef_conjugate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_arg_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_cos_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c:
      RETURN (make_listed_product_space([the_logicals, the_complex_numbers, the_complex_numbers]));
    ef_subscript_s:
      RETURN (make_listed_product_space([the_strings, the_integers]));
    ef_eq_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_ne_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_gt_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_lt_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_ge_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_le_s:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_subsequence_s:
      RETURN (make_listed_product_space([the_strings, the_integers, the_integers]));
    ef_concat_s:
      RETURN (make_extended_tuple_space(the_zero_tuple_space, the_strings));
    ef_size_s:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_format:
      RETURN (make_listed_product_space([the_numbers, the_strings]));
    ef_value:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_like:
      RETURN (make_uniform_product_space(the_strings, 2));
    ef_if_s:
      RETURN (make_listed_product_space([the_logicals, the_strings, the_strings]));
    ef_subscript_b:
      RETURN (make_listed_product_space([the_binarys, the_integers]));
    ef_eq_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_ne_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_gt_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_lt_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_ge_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_le_b:
      RETURN (make_uniform_product_space(the_binarys, 2));
    ef_subsequence_b:
      RETURN (make_listed_product_space([the_binarys, the_integers, the_integers]));
    ef_concat_b:
      RETURN (make_extended_tuple_space(the_zero_tuple_space, the_binarys));
    ef_size_b:
      RETURN (make_uniform_product_space(the_binarys, 1));
    ef_if_b:
      RETURN (make_listed_product_space([the_logicals, the_binarys, the_binarys]));
    ef_subscript_t:
      RETURN (make_listed_product_space([the_tuples, the_integers]));
    ef_eq_t:
      RETURN (make_uniform_product_space(the_tuples, 2));
    ef_ne_t:
      RETURN (make_uniform_product_space(the_tuples, 2));
    ef_concat_t:
      RETURN (make_extended_tuple_space(the_zero_tuple_space, the_tuples));
    ef_size_t:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_entuple:
      RETURN (the_tuples);
    ef_detuple:
      RETURN (make_uniform_product_space(the_generics, 1));
    ef_insert:
      RETURN (make_listed_product_space([the_tuples, the_generics, the_integers]));
    ef_remove:
      RETURN (make_listed_product_space([the_tuples, the_integers]));
    ef_if_t:
      RETURN (make_listed_product_space([the_logicals, the_tuples, the_tuples]));
    ef_sum_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 1));
    ef_product_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 1));
    ef_add_it:
      RETURN (make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
    ef_subtract_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 2));
    ef_scalar_mult_it:
      RETURN (make_listed_product_space([the_integers, the_integer_tuples]));
    ef_dot_prod_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 2));
    ef_sum_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_product_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_add_rt:
      RETURN (make_extended_tuple_space(the_real_tuples, the_real_tuples));
    ef_subtract_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 2));
    ef_scalar_mult_rt:
      RETURN (make_listed_product_space([the_reals, the_real_tuples]));
    ef_dot_prod_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 2));
    ef_norm_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_sum_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_product_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_add_ct:
      RETURN (make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
    ef_subtract_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 2));
    ef_scalar_mult_ct:
      RETURN (make_listed_product_space([the_complex_numbers, the_complex_tuples]));
    ef_dot_prod_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 2));
    ef_norm_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_if:
      RETURN (make_listed_product_space([the_logicals, the_generics, the_generics]));
    ef_ensemble:
      RETURN (the_tuples);
    ef_member_of:
      RETURN (make_listed_product_space([the_generics, the_maths_spaces]));
    OTHERWISE:
      RETURN (?);
  END_CASE;
      </algorithm>
    </function>

    <function name="derive_elementary_function_range">
      <parameter name="ef_val">
        <typename name="elementary_function_enumerators"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  IF NOT EXISTS(ef_val) THEN
    RETURN (?);
  END_IF;
  CASE ef_val OF 
    ef_and:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_or:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_not:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_xor:
      RETURN (make_uniform_product_space(the_logicals, 2));
    ef_negate_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_add_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_subtract_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_multiply_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_divide_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_mod_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_exponentiate_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_eq_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_gt_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_lt_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ge_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_le_i:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_abs_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_if_i:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_negate_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_add_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_subtract_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_multiply_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_divide_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_mod_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_exponentiate_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_exponentiate_ri:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_eq_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_gt_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_lt_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ge_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_le_r:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_abs_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_acos_r:
      RETURN (make_uniform_product_space(the_zero_pi_interval, 1));
    ef_asin_r:
      RETURN (make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
    ef_atan2_r:
      RETURN (make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_r:
      RETURN (make_uniform_product_space(the_neg1_one_interval, 1));
    ef_exp_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_ln_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_log2_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_log10_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_sin_r:
      RETURN (make_uniform_product_space(the_neg1_one_interval, 1));
    ef_sqrt_r:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_if_r:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_negate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_subtract_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_multiply_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_divide_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_ci:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_eq_c:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_c:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_conjugate_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_arg_c:
      RETURN (make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_subscript_s:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_eq_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_gt_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_lt_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ge_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_le_s:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_subsequence_s:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_concat_s:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_size_s:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_format:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_value:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_like:
      RETURN (make_uniform_product_space(the_booleans, 1));
    ef_if_s:
      RETURN (make_uniform_product_space(the_strings, 1));
    ef_subscript_b:
      RETURN (make_uniform_product_space(the_binarys, 1));
    ef_eq_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_gt_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_lt_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ge_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_le_b:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_subsequence_b:
      RETURN (make_uniform_product_space(the_binarys, 1));
    ef_concat_b:
      RETURN (make_uniform_product_space(the_binarys, 1));
    ef_size_b:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_if_b:
      RETURN (make_uniform_product_space(the_binarys, 1));
    ef_subscript_t:
      RETURN (make_uniform_product_space(the_generics, 1));
    ef_eq_t:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_ne_t:
      RETURN (make_uniform_product_space(the_logicals, 1));
    ef_concat_t:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_size_t:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_entuple:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_detuple:
      RETURN (the_tuples);
    ef_insert:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_remove:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_if_t:
      RETURN (make_uniform_product_space(the_tuples, 1));
    ef_sum_it:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_product_it:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_add_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 1));
    ef_subtract_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 1));
    ef_scalar_mult_it:
      RETURN (make_uniform_product_space(the_integer_tuples, 1));
    ef_dot_prod_it:
      RETURN (make_uniform_product_space(the_integers, 1));
    ef_sum_rt:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_product_rt:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_add_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_subtract_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_scalar_mult_rt:
      RETURN (make_uniform_product_space(the_real_tuples, 1));
    ef_dot_prod_rt:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_norm_rt:
      RETURN (make_uniform_product_space(the_reals, 1));
    ef_sum_ct:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_product_ct:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_add_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_subtract_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_scalar_mult_ct:
      RETURN (make_uniform_product_space(the_complex_tuples, 1));
    ef_dot_prod_ct:
      RETURN (make_uniform_product_space(the_complex_numbers, 1));
    ef_norm_ct:
      RETURN (make_uniform_product_space(the_nonnegative_reals, 1));
    ef_if:
      RETURN (make_uniform_product_space(the_generics, 1));
    ef_ensemble:
      RETURN (make_uniform_product_space(the_maths_spaces, 1));
    ef_member_of:
      RETURN (make_uniform_product_space(the_logicals, 1));
    OTHERWISE:
      RETURN (?);
  END_CASE;
      </algorithm>
    </function>

    <function name="derive_finite_function_domain">
      <parameter name="pairs">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;

  result := result + list_selected_components(pairs, 1);
  RETURN (one_tuples_of(make_finite_space(result)));
      </algorithm>
    </function>

    <function name="derive_finite_function_range">
      <parameter name="pairs">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;

  result := result + list_selected_components(pairs, 2);
  RETURN (one_tuples_of(make_finite_space(result)));
      </algorithm>
    </function>

    <function name="derive_function_domain">
      <parameter name="func">
        <typename name="maths_function"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space([]);
    shape : LIST OF positive_integer;
    sidxs : LIST OF INTEGER := [0];
    itvl : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;

  IF &apos;FINITE_FUNCTION&apos; IN typenames THEN
    RETURN (derive_finite_function_domain(func\finite_function.pairs));
  END_IF;
  IF &apos;CONSTANT_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF &apos;SELECTOR_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF &apos;ELEMENTARY_FUNCTION&apos; IN typenames THEN
    RETURN (derive_elementary_function_domain(func\elementary_function.func_id));
  END_IF;
  IF &apos;RESTRICTION_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF &apos;REPACKAGING_FUNCTION&apos; IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1(func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of(func\repackaging_function.operand.domain));
    END_IF;
    RETURN (?);
  END_IF;
  IF &apos;REINDEXED_ARRAY_FUNCTION&apos; IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[i], sidxs[i] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] &lt;&gt; shape[1] THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN (make_listed_product_space(factors));
  END_IF;
  IF &apos;SERIES_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  IF &apos;EXPLICIT_TABLE_FUNCTION&apos; IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[1], sidxs[1] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] &lt;&gt; shape[1] THEN
        is_uniform := FALSE;
      END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN (make_listed_product_space(factors));
  END_IF;
  IF &apos;HOMOGENEOUS_LINEAR_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range), func\homogeneous_linear_function.mat\explicit_table_function.shape[func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF &apos;GENERAL_LINEAR_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range), func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF &apos;B_SPLINE_BASIS&apos; IN typenames THEN
    RETURN (one_tuples_of(make_finite_real_interval(func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed, func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis + 1], closed)));
  END_IF;
  IF &apos;B_SPLINE_FUNCTION&apos; IN typenames THEN
    REPEAT i := 1 TO SIZEOF(func\b_spline_function.basis);
      tspace := assoc_product_space(tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of(tspace));
  END_IF;
  IF &apos;RATIONALIZE_FUNCTION&apos; IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF &apos;PARTIAL_DERIVATIVE_FUNCTION&apos; IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF &apos;DEFINITE_INTEGRAL_FUNCTION&apos; IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF &apos;ABSTRACTED_EXPRESSION_FUNCTION&apos; IN typenames THEN
    REPEAT i := 1 TO SIZEOF(func\abstracted_expression_function.variables);
      tspace := assoc_product_space(tspace, one_tuples_of(values_space_of(func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF &apos;EXPRESSION_DENOTED_FUNCTION&apos; IN typenames THEN
    RETURN (values_space_of(func\expression_denoted_function.expr)\function_space.domain_argument);
  END_IF;
  IF &apos;IMPORTED_POINT_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_listed_product_space([])));
  END_IF;
  IF &apos;IMPORTED_CURVE_FUNCTION&apos; IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF &apos;IMPORTED_SURFACE_FUNCTION&apos; IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF &apos;IMPORTED_VOLUME_FUNCTION&apos; IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF &apos;APPLICATION_DEFINED_FUNCTION&apos; IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="derive_function_range">
      <parameter name="func">
        <typename name="maths_function"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space([]);
    m : nonnegative_integer := 0;
    n : nonnegative_integer := 0;
  END_LOCAL;

  IF &apos;FINITE_FUNCTION&apos; IN typenames THEN
    RETURN (derive_finite_function_range(func\finite_function.pairs));
  END_IF;
  IF &apos;CONSTANT_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_finite_space([func\constant_function.sole_output])));
  END_IF;
  IF &apos;SELECTOR_FUNCTION&apos; IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(tspace)) THEN
      tspace := factor1(tspace);
    END_IF;
    RETURN (one_tuples_of(factor_space(tspace, func\selector_function.selector)));
  END_IF;
  IF &apos;ELEMENTARY_FUNCTION&apos; IN typenames THEN
    RETURN (derive_elementary_function_range(func\elementary_function.func_id));
  END_IF;
  IF &apos;RESTRICTION_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF &apos;REPACKAGING_FUNCTION&apos; IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of(tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1(tspace);
    END_IF;
    IF func\repackaging_function.selected_output &gt; 0 THEN
      tspace := one_tuples_of(factor_space(tspace, func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF &apos;REINDEXED_ARRAY_FUNCTION&apos; IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF &apos;SERIES_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF(func\series_composed_function.operands)].range);
  END_IF;
  IF &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF &apos;EXPLICIT_TABLE_FUNCTION&apos; IN typenames THEN
    IF &apos;LISTED_REAL_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(the_reals));
    END_IF;
    IF &apos;LISTED_INTEGER_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(the_integers));
    END_IF;
    IF &apos;LISTED_LOGICAL_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(the_logicals));
    END_IF;
    IF &apos;LISTED_STRING_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(the_strings));
    END_IF;
    IF &apos;LISTED_COMPLEX_NUMBER_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(the_complex_numbers));
    END_IF;
    IF &apos;LISTED_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(func\listed_data.value_range));
    END_IF;
    IF &apos;EXTERNALLY_LISTED_DATA&apos; IN typenames THEN
      RETURN (one_tuples_of(func\externally_listed_data.value_range));
    END_IF;
    IF &apos;LINEARIZED_TABLE_FUNCTION&apos; IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF &apos;BASIC_SPARSE_MATRIX&apos; IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    RETURN (?);
  END_IF;
  IF &apos;HOMOGENEOUS_LINEAR_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range), func\homogeneous_linear_function.mat\explicit_table_function.shape[3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF &apos;GENERAL_LINEAR_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(factor1(func\general_linear_function.mat.range), func\general_linear_function.mat\explicit_table_function.shape[3 - func\general_linear_function.sum_index])));
  END_IF;
  IF &apos;B_SPLINE_BASIS&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(the_reals, func\b_spline_basis.num_basis)));
  END_IF;
  IF &apos;B_SPLINE_FUNCTION&apos; IN typenames THEN
    tspace := factor1(func\b_spline_function.coef.domain);
    m := SIZEOF(func\b_spline_function.basis);
    n := space_dimension(tspace);
    IF m = n THEN
      RETURN (one_tuples_of(the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of(make_uniform_product_space(the_reals, factor_space(tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors(tspace, m + 1, n);
    RETURN (one_tuples_of(make_function_space(sc_equal, tspace, sc_subspace, number_superspace_of(func\b_spline_function.coef.range))));
  END_IF;
  IF &apos;RATIONALIZE_FUNCTION&apos; IN typenames THEN
    tspace := factor1(func\rationalize_function.fun.range);
    n := space_dimension(tspace);
    RETURN (one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
  END_IF;
  IF &apos;PARTIAL_DERIVATIVE_FUNCTION&apos; IN typenames THEN
    RETURN (drop_numeric_constraints(func\partial_derivative_function.derivand.range));
  END_IF;
  IF &apos;DEFINITE_INTEGRAL_FUNCTION&apos; IN typenames THEN
    RETURN (drop_numeric_constraints(func\definite_integral_function.integrand.range));
  END_IF;
  IF &apos;ABSTRACTED_EXPRESSION_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF &apos;EXPRESSION_DENOTED_FUNCTION&apos; IN typenames THEN
    RETURN (values_space_of(func\expression_denoted_function.expr)\function_space.range_argument);
  END_IF;
  IF &apos;IMPORTED_POINT_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func\imported_point_function.geometry))));
  END_IF;
  IF &apos;IMPORTED_CURVE_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func\imported_curve_function.geometry))));
  END_IF;
  IF &apos;IMPORTED_SURFACE_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func\imported_surface_function.geometry))));
  END_IF;
  IF &apos;IMPORTED_VOLUME_FUNCTION&apos; IN typenames THEN
    RETURN (one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func\imported_volume_function.geometry))));
  END_IF;
  IF &apos;APPLICATION_DEFINED_FUNCTION&apos; IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="dimension_of">
      <parameter name="item">
        <typename name="geometric_representation_item"/>
      </parameter>
      <typename name="dimension_count"/>
      <algorithm>
  LOCAL
    x : SET OF representation;
    y : representation_context;
    dim : dimension_count;
  END_LOCAL;

  IF &apos;FUNCTIONAL_DATA_MIM_LF.CARTESIAN_POINT&apos; IN TYPEOF(item) THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN (dim);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.DIRECTION&apos; IN TYPEOF(item) THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.VECTOR&apos; IN TYPEOF(item) THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  x := using_representations(item);
  y := x[1].context_of_items;
  dim := y\geometric_representation_context.coordinate_space_dimension;
  RETURN (dim);
      </algorithm>
    </function>

    <function name="dimensions_for_si_unit">
      <parameter name="n">
        <typename name="si_unit_name"/>
      </parameter>
      <typename name="dimensional_exponents"/>
      <algorithm>
  CASE n OF 
    metre:
      RETURN (dimensional_exponents(1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    gram:
      RETURN (dimensional_exponents(0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    second:
      RETURN (dimensional_exponents(0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    ampere:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000));
    kelvin:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000));
    mole:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000));
    candela:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000));
    radian:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    steradian:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    hertz:
      RETURN (dimensional_exponents(0.000000, 0.000000,  - 1.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    newton:
      RETURN (dimensional_exponents(1.000000, 1.000000,  - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    pascal:
      RETURN (dimensional_exponents( - 1.000000, 1.000000,  - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    joule:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    watt:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 3.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    coulomb:
      RETURN (dimensional_exponents(0.000000, 0.000000, 1.000000, 1.000000, 0.000000, 0.000000, 0.000000));
    volt:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 3.000000,  - 1.000000, 0.000000, 0.000000, 0.000000));
    farad:
      RETURN (dimensional_exponents( - 2.000000,  - 1.000000, 4.000000, 1.000000, 0.000000, 0.000000, 0.000000));
    ohm:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 3.000000,  - 2.000000, 0.000000, 0.000000, 0.000000));
    siemens:
      RETURN (dimensional_exponents( - 2.000000,  - 1.000000, 3.000000, 2.000000, 0.000000, 0.000000, 0.000000));
    weber:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 2.000000,  - 1.000000, 0.000000, 0.000000, 0.000000));
    tesla:
      RETURN (dimensional_exponents(0.000000, 1.000000,  - 2.000000,  - 1.000000, 0.000000, 0.000000, 0.000000));
    henry:
      RETURN (dimensional_exponents(2.000000, 1.000000,  - 2.000000,  - 2.000000, 0.000000, 0.000000, 0.000000));
    degree_celsius:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000));
    lumen:
      RETURN (dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000));
    lux:
      RETURN (dimensional_exponents( - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000));
    becquerel:
      RETURN (dimensional_exponents(0.000000, 0.000000,  - 1.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    gray:
      RETURN (dimensional_exponents(2.000000, 0.000000,  - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    sievert:
      RETURN (dimensional_exponents(2.000000, 0.000000,  - 2.000000, 0.000000, 0.000000, 0.000000, 0.000000));
    OTHERWISE:
      RETURN (?);
  END_CASE;
      </algorithm>
    </function>

    <function name="domain_from">
      <parameter name="ref">
        <typename name="maths_space_or_function"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func : maths_function;
  END_LOCAL;

  IF NOT EXISTS(ref) THEN
    RETURN (?);
  END_IF;
  IF &apos;TUPLE_SPACE&apos; IN typenames THEN
    RETURN (ref);
  END_IF;
  IF &apos;MATHS_SPACE&apos; IN typenames THEN
    RETURN (one_tuples_of(ref));
  END_IF;
  func := ref;
  IF &apos;CONSTANT_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF &apos;SELECTOR_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
      </algorithm>
    </function>

    <function name="drop_numeric_constraints">
      <parameter name="spc">
        <typename name="maths_space"/>
      </parameter>
      <typename name="maths_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;

  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN typenames THEN
    RETURN (make_uniform_product_space(drop_numeric_constraints(spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF(tspc.factors);
      INSERT(factors, drop_numeric_constraints(tspc.factors[i]), i - 1);
    END_REPEAT;
    RETURN (make_listed_product_space(factors));
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
  END_IF;
  IF subspace_of_es(spc, es_numbers) THEN
    RETURN (number_superspace_of(spc));
  END_IF;
  RETURN (spc);
      </algorithm>
    </function>

    <function name="enclose_cregion_in_pregion">
      <parameter name="crgn">
        <typename name="cartesian_complex_number_region"/>
      </parameter>
      <parameter name="centre">
        <typename name="complex_number_literal"/>
      </parameter>
      <typename name="polar_complex_number_region"/>
      <algorithm>
  FUNCTION angle (a : REAL):REAL;
    REPEAT WHILE a &gt; PI;
      a := a - 2.000000 * PI;
    END_REPEAT;
    REPEAT WHILE a &lt;=  - PI;
      a := a + 2.000000 * PI;
    END_REPEAT;
    RETURN (a);
  END_FUNCTION;

  FUNCTION strictly_in (z : REAL; zitv : real_interval):LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z &gt; real_min(zitv))) AND (NOT max_exists(zitv) OR (z &lt; real_max(zitv))));
  END_FUNCTION;

  PROCEDURE angle_minmax (ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN
      amin_in := amin_in OR a_in;
    END_IF;
    IF amin &gt; a THEN
      amin := a;
      amin_in := a_in;
    END_IF;
    IF amax = a THEN
      amax_in := amax_in OR a_in;
    END_IF;
    IF amax &lt; a THEN
      amax := a;
      amax_in := a_in;
    END_IF;
  END_PROCEDURE;

  PROCEDURE range_max (VAR r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);
    IF rmax = r THEN
      rmax_in := rmax_in OR incl;
    END_IF;
    IF rmax &lt; r THEN
      rmax := r;
      rmax_in := incl;
    END_IF;
  END_PROCEDURE;

  PROCEDURE range_min (VAR r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);
    IF rmin = r THEN
      rmin_in := rmin_in OR incl;
    END_IF;
    IF (rmin &lt; 0.000000) OR (rmin &gt; r) THEN
      rmin := r;
      rmin_in := incl;
    END_IF;
  END_PROCEDURE;

  LOCAL
    xitv : real_interval;
    yitv : real_interval;
    is_xmin : BOOLEAN;
    is_xmax : BOOLEAN;
    is_ymin : BOOLEAN;
    is_ymax : BOOLEAN;
    xmin : REAL := 0.000000;
    xmax : REAL := 0.000000;
    ymin : REAL := 0.000000;
    ymax : REAL := 0.000000;
    xc : REAL := 0.000000;
    yc : REAL := 0.000000;
    xmin_in : BOOLEAN := FALSE;
    xmax_in : BOOLEAN := FALSE;
    ymin_in : BOOLEAN := FALSE;
    ymax_in : BOOLEAN := FALSE;
    rmin : REAL :=  - 1.000000;
    rmax : REAL :=  - 1.000000;
    amin : REAL := 4.000000;
    amax : REAL :=  - 4.000000;
    rmax_exists : BOOLEAN := TRUE;
    outside : BOOLEAN := TRUE;
    rmin_in : BOOLEAN := FALSE;
    rmax_in : BOOLEAN := FALSE;
    amin_in : BOOLEAN := FALSE;
    amax_in : BOOLEAN := FALSE;
    ab : REAL := 0.000000;
    a : REAL := 0.000000;
    r : REAL := 0.000000;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo : open_closed := open;
    maxclo : open_closed := open;
  END_LOCAL;

  IF NOT EXISTS(crgn) OR NOT EXISTS(centre) THEN
    RETURN (?);
  END_IF;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN
    xmin := real_min(xitv);
    xmin_in := min_included(xitv);
  END_IF;
  IF is_xmax THEN
    xmax := real_max(xitv);
    xmax_in := max_included(xitv);
  END_IF;
  IF is_ymin THEN
    ymin := real_min(yitv);
    ymin_in := min_included(yitv);
  END_IF;
  IF is_ymax THEN
    ymax := real_max(yitv);
    ymax_in := max_included(yitv);
  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  IF is_xmin AND (xc &lt;= xmin) THEN
    ab := 0.000000;
  ELSE
    IF is_ymin AND (yc &lt;= ymin) THEN
      ab := 0.500000 * PI;
    ELSE
      IF is_ymax AND (yc &gt;= ymax) THEN
        ab :=  - 0.500000 * PI;
      ELSE
        IF is_xmax AND (xc &gt;= xmax) THEN
          ab := PI;
        ELSE
          outside := FALSE;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);
  END_IF;
  IF is_xmin AND (xc &lt;= xmin) AND strictly_in(yc, yitv) THEN
    rmin := xmin - xc;
    rmin_in := xmin_in;
  ELSE
    IF is_ymin AND (yc &lt;= ymin) AND strictly_in(xc, xitv) THEN
      rmin := ymin - yc;
      rmin_in := ymin_in;
    ELSE
      IF is_ymax AND (yc &gt;= ymax) AND strictly_in(xc, xitv) THEN
        rmin := yc - ymax;
        rmin_in := ymax_in;
      ELSE
        IF is_xmax AND (xc &gt;= xmax) AND strictly_in(yc, yitv) THEN
          rmin := xc - xmax;
          rmin_in := xmax_in;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN
      r := SQRT((xmin - xc)**2 + (ymin - yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside THEN
        IF r &gt; 0.000000 THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmin - xc) - ab);
          IF xc = xmin THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymin THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.000000;
          rmin_in := xmin_in AND ymin_in;
          amin := angle(0.000000 - ab);
          amin_in := ymin_in;
          amax := angle(0.500000 * PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF xc &lt;= xmin THEN
        angle_minmax(ab,  - 0.500000 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymax AND (xc &lt;= xmin) THEN
      angle_minmax(ab, 0.500000 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN
      r := SQRT((xmax - xc)**2 + (ymin - yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside THEN
        IF r &gt; 0.000000 THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmax - xc) - ab);
          IF xc = xmax THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymin THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.000000;
          rmin_in := xmax_in AND ymin_in;
          amin := angle(0.500000 * PI - ab);
          amin_in := ymin_in;
          amax := angle(PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF yc &lt;= ymin THEN
        angle_minmax(ab, 0.000000, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmin AND (yc &lt;= ymin) THEN
      angle_minmax(ab, PI, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN
      r := SQRT((xmax - xc)**2 + (ymax - yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside THEN
        IF r &gt; 0.000000 THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmax - xc) - ab);
          IF xc = xmax THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymax THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.000000;
          rmin_in := xmax_in AND ymax_in;
          amin := angle( - PI - ab);
          amin_in := ymax_in;
          amax := angle( - 0.500000 * PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF xc &gt;= xmax THEN
        angle_minmax(ab, 0.500000 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymin AND (xc &gt;= xmax) THEN
      angle_minmax(ab,  - 0.500000 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN
      r := SQRT((xmin - xc)**2 + (ymax - yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside THEN
        IF r &gt; 0.000000 THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmin - xc) - ab);
          IF xc = xmin THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymax THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.000000;
          rmin_in := xmin_in AND ymax_in;
          amin := angle(0.500000 * PI - ab);
          amin_in := ymax_in;
          amax := angle(PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF yc &gt;= ymax THEN
        angle_minmax(ab, PI, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmax AND (yc &gt;= ymax) THEN
      angle_minmax(ab, 0.000000, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF outside THEN
    amin := angle(amin + ab);
    IF amin = PI THEN
      amin :=  - PI;
    END_IF;
    amax := angle(amax + ab);
    IF amax &lt;= amin THEN
      amax := amax + 2.000000 * PI;
    END_IF;
  ELSE
    amin :=  - PI;
    amin_in := FALSE;
    amax := PI;
    amax_in := FALSE;
  END_IF;
  IF amin_in THEN
    minclo := closed;
  END_IF;
  IF amax_in THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  minclo := open;
  IF rmin_in THEN
    minclo := closed;
  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre, ritv, aitv));
      </algorithm>
    </function>

    <function name="enclose_pregion_in_cregion">
      <parameter name="prgn"
        varying="YES">
        <typename name="polar_complex_number_region"/>
      </parameter>
      <typename name="cartesian_complex_number_region"/>
      <algorithm>
  PROCEDURE nearest_good_direction (VAR acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);
    a := acart;
    a_in := TRUE;
    IF a &lt; aitv.min THEN
      IF a + 2.000000 * PI &lt; aitv.max THEN
        RETURN;
      END_IF;
      IF a + 2.000000 * PI = aitv.max THEN
        a_in := max_included(aitv);
        RETURN;
      END_IF;
    ELSE
      IF a = aitv.min THEN
        a_in := min_included(aitv);
        RETURN;
      ELSE
        IF a &lt; aitv.max THEN
          RETURN;
        ELSE
          IF a = aitv.max THEN
            a_in := max_included(aitv);
            RETURN;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF COS(acart - aitv.max) &gt;= COS(acart - aitv.min) THEN
      a := aitv.max;
      a_in := max_included(aitv);
    ELSE
      a := aitv.min;
      a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;

  LOCAL
    xc : REAL := 0.000000;
    yc : REAL := 0.000000;
    xmin : REAL := 0.000000;
    xmax : REAL := 0.000000;
    ymin : REAL := 0.000000;
    ymax : REAL := 0.000000;
    ritv : real_interval;
    xitv : real_interval;
    yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists : BOOLEAN;
    xmax_exists : BOOLEAN;
    ymin_exists : BOOLEAN;
    ymax_exists : BOOLEAN;
    xmin_in : BOOLEAN := FALSE;
    xmax_in : BOOLEAN := FALSE;
    ymin_in : BOOLEAN := FALSE;
    ymax_in : BOOLEAN := FALSE;
    a : REAL := 0.000000;
    r : REAL := 0.000000;
    a_in : BOOLEAN := FALSE;
    min_clo : open_closed := open;
    max_clo : open_closed := open;
  END_LOCAL;

  IF NOT EXISTS(prgn) THEN
    RETURN (?);
  END_IF;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  nearest_good_direction(PI, aitv, a, a_in);
  IF COS(a) &gt;= 0.000000 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv) * COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.000000));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv) * COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  nearest_good_direction(0.000000, aitv, a, a_in);
  IF COS(a) &lt;= 0.000000 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv) * COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.000000));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv) * COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  nearest_good_direction( - 0.500000 * PI, aitv, a, a_in);
  IF SIN(a) &gt;= 0.000000 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv) * SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.000000));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv) * SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  nearest_good_direction(0.500000 * PI, aitv, a, a_in);
  IF SIN(a) &lt;= 0.000000 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv) * SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.000000));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv) * SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);
  END_IF;
  IF xmin_exists THEN
    IF xmin_in THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin, min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_real_interval_to_max(xmax, max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  IF ymin_exists THEN
    IF ymin_in THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin, min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_real_interval_to_max(ymax, max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  RETURN (make_cartesian_complex_number_region(xitv, yitv));
      </algorithm>
    </function>

    <function name="enclose_pregion_in_pregion">
      <parameter name="prgn"
        varying="YES">
        <typename name="polar_complex_number_region"/>
      </parameter>
      <parameter name="centre"
        varying="YES">
        <typename name="complex_number_literal"/>
      </parameter>
      <typename name="polar_complex_number_region"/>
      <algorithm>
  FUNCTION angle (VAR a : REAL):REAL;
    REPEAT WHILE a &gt; PI;
      a := a - 2.000000 * PI;
    END_REPEAT;
    REPEAT WHILE a &lt;=  - PI;
      a := a + 2.000000 * PI;
    END_REPEAT;
    RETURN (a);
  END_FUNCTION;

  FUNCTION strictly_in (VAR a : REAL; VAR aitv : finite_real_interval):LOGICAL;
    a := angle(a);
    RETURN ({aitv.min &lt; a &lt; aitv.max} OR {aitv.min &lt; a + 2.000000 * PI &lt; aitv.max});
  END_FUNCTION;

  PROCEDURE angle_range (VAR amin : REAL; VAR amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN
      amin :=  - PI;
    END_IF;
    amax := angle(amax);
    IF amax &lt;= amin THEN
      amax := amax + 2.000000 * PI;
    END_IF;
  END_PROCEDURE;

  PROCEDURE find_aminmax (VAR ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN; in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;

    amin := angle(a0 - ab);
    amin_in := in0;
    amax := amin;
    amax_in := in0;
    a := angle(a1 - ab);
    IF a = amin THEN
      amin_in := amin_in OR in1;
    END_IF;
    IF a &lt; amin THEN
      amin := a;
      amin_in := in1;
    END_IF;
    IF a = amax THEN
      amax_in := amax_in OR in1;
    END_IF;
    IF a &gt; amax THEN
      amax := a;
      amax_in := in1;
    END_IF;
    a := angle(a2 - ab);
    IF a = amin THEN
      amin_in := amin_in OR in2;
    END_IF;
    IF a &lt; amin THEN
      amin := a;
      amin_in := in2;
    END_IF;
    IF a = amax THEN
      amax_in := amax_in OR in2;
    END_IF;
    IF a &gt; amax THEN
      amax := a;
      amax_in := in2;
    END_IF;
    a := angle(a3 - ab);
    IF a = amin THEN
      amin_in := amin_in OR in3;
    END_IF;
    IF a &lt; amin THEN
      amin := a;
      amin_in := in3;
    END_IF;
    IF a = amax THEN
      amax_in := amax_in OR in3;
    END_IF;
    IF a &gt; amax THEN
      amax := a;
      amax_in := in3;
    END_IF;
    amin := amin + ab;
    amax := amax + ab;
    angle_range(amin, amax);
  END_PROCEDURE;

  LOCAL
    ritp : real_interval;
    ritv : real_interval;
    aitp : finite_real_interval;
    aitv : finite_real_interval;
    xp : REAL := 0.000000;
    yp : REAL := 0.000000;
    xc : REAL := 0.000000;
    yc : REAL := 0.000000;
    rmax : REAL := 0.000000;
    rmin : REAL := 0.000000;
    amin : REAL := 0.000000;
    amax : REAL := 0.000000;
    rc : REAL := 0.000000;
    acp : REAL := 0.000000;
    apc : REAL := 0.000000;
    rmax_in : BOOLEAN := FALSE;
    rmin_in : BOOLEAN := FALSE;
    amin_in : BOOLEAN := FALSE;
    amax_in : BOOLEAN := FALSE;
    rmxp : REAL := 0.000000;
    rmnp : REAL := 0.000000;
    x : REAL := 0.000000;
    y : REAL := 0.000000;
    r : REAL := 0.000000;
    a : REAL := 0.000000;
    ab : REAL := 0.000000;
    r0 : REAL := 0.000000;
    a0 : REAL := 0.000000;
    r1 : REAL := 0.000000;
    a1 : REAL := 0.000000;
    r2 : REAL := 0.000000;
    a2 : REAL := 0.000000;
    r3 : REAL := 0.000000;
    a3 : REAL := 0.000000;
    in0 : BOOLEAN := FALSE;
    in1 : BOOLEAN := FALSE;
    in2 : BOOLEAN := FALSE;
    in3 : BOOLEAN := FALSE;
    inn : BOOLEAN := FALSE;
    minclo : open_closed := open;
    maxclo : open_closed := open;
  END_LOCAL;

  IF NOT EXISTS(prgn) OR NOT EXISTS(centre) THEN
    RETURN (?);
  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN
    RETURN (prgn);
  END_IF;
  rc := SQRT((xp - xc)**2 + (yp - yc)**2);
  acp := atan2(yp - yc, xp - xc);
  apc := atan2(yc - yp, xc - xp);
  rmnp := real_min(ritp);
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.000000 * PI THEN
      inn := NOT max_included(aitp);
      a := angle(aitp.min);
      rmax := rc + rmxp;
      rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN
        rmax_in := FALSE;
      END_IF;
      IF rc &gt; rmxp THEN
        a0 := ASIN(rmxp / rc);
        amin := angle(acp - a0);
        amin_in := max_included(ritp);
        IF amin = PI THEN
          amin :=  - PI;
        END_IF;
        amax := angle(acp + a0);
        amax_in := amin_in;
        IF amax &lt; amin THEN
          amax := amax + 2.000000 * PI;
        END_IF;
        rmin := rc - rmxp;
        rmin_in := amin_in;
        IF inn THEN
          IF apc = a THEN
            rmin_in := FALSE;
          END_IF;
          IF angle(amin + 0.500000 * PI) = a THEN
            amin_in := FALSE;
          END_IF;
          IF angle(amax - 0.500000 * PI) = a THEN
            amax_in := FALSE;
          END_IF;
        END_IF;
      ELSE
        IF rc = rmxp THEN
          amin := angle(acp - 0.500000 * PI);
          amin_in := FALSE;
          IF amin = PI THEN
            amin :=  - PI;
          END_IF;
          amax := angle(acp + 0.500000 * PI);
          amax_in := FALSE;
          IF amax &lt; amin THEN
            amax := amax + 2.000000 * PI;
          END_IF;
          rmin := 0.000000;
          rmin_in := max_included(ritp);
          IF inn AND (apc = a) THEN
            rmin_in := FALSE;
          END_IF;
        ELSE
          IF rc &gt; rmnp THEN
            IF inn AND (apc = a) THEN
              rmin := 0.000000;
              rmin_in := FALSE;
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            ELSE
              rmin := 0.000000;
              rmin_in := TRUE;
              amin :=  - PI;
              amin_in := FALSE;
              amax := PI;
              amax_in := TRUE;
            END_IF;
          ELSE
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
            amin :=  - PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
            IF inn THEN
              IF apc = a THEN
                rmin_in := FALSE;
                amin := aitp.min;
                amin_in := FALSE;
                amax := aitp.max;
                amax_in := FALSE;
              ELSE
                IF acp = a THEN
                  amin := aitp.min;
                  amin_in := FALSE;
                  amax := aitp.max;
                  amax_in := FALSE;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      x := xp + rmxp * COS(aitp.min) - xc;
      y := yp + rmxp * SIN(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 &lt;&gt; 0.000000 THEN
        a0 := atan2(y, x);
      END_IF;
      x := xp + rmxp * COS(aitp.max) - xc;
      y := yp + rmxp * SIN(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 &lt;&gt; 0.000000 THEN
        a1 := atan2(y, x);
      END_IF;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 &lt;&gt; 0.000000 THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      IF r1 = 0.000000 THEN
        a1 := a2;
        in1 := in2;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 &lt;&gt; 0.000000 THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF r0 = 0.000000 THEN
        a0 := a3;
        in0 := in3;
      END_IF;
      IF rmnp = 0.000000 THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(acp, aitp) THEN
        rmax := rc + rmxp;
        rmax_in := max_included(ritp);
      ELSE
        rmax := r0;
        rmax_in := in0;
        IF rmax = r1 THEN
          rmax_in := rmax_in OR in1;
        END_IF;
        IF rmax &lt; r1 THEN
          rmax := r1;
          rmax_in := in1;
        END_IF;
        IF rmax = r2 THEN
          rmax_in := rmax_in OR in2;
        END_IF;
        IF rmax &lt; r2 THEN
          rmax := r2;
          rmax_in := in2;
        END_IF;
        IF rmax = r3 THEN
          rmax_in := rmax_in OR in3;
        END_IF;
        IF rmax &lt; r3 THEN
          rmax := r3;
          rmax_in := in3;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp) THEN
        IF rc &gt;= rmxp THEN
          rmin := rc - rmxp;
          rmin_in := max_included(ritp);
        ELSE
          IF rc &lt;= rmnp THEN
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
          ELSE
            rmin := 0.000000;
            rmin_in := TRUE;
          END_IF;
        END_IF;
      ELSE
        rmin := r0;
        rmin_in := in0;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF {rmnp &lt; r &lt; rmxp} THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF {rmnp &lt; r &lt; rmxp} THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r &lt; rmin THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r1 = rmin THEN
          rmin_in := rmin_in OR in1;
        END_IF;
        IF r1 &lt; rmin THEN
          rmin := r1;
          rmin_in := in1;
        END_IF;
        IF r2 = rmin THEN
          rmin_in := rmin_in OR in2;
        END_IF;
        IF r2 &lt; rmin THEN
          rmin := r2;
          rmin_in := in2;
        END_IF;
        IF r3 = rmin THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 &lt; rmin THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      IF rc &gt;= rmxp THEN
        ab := acp;
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        a := ACOS(rmxp / rc);
        IF strictly_in(apc - a, aitp) THEN
          amin := ab - ASIN(rmxp / rc);
          amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc + a, aitp) THEN
          amax := ab + ASIN(rmxp / rc);
          amax_in := max_included(ritp);
        END_IF;
        angle_range(amin, amax);
      ELSE
        IF rc &gt; rmnp THEN
          ab := angle(0.500000 * (aitp.min + aitp.max));
          find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        ELSE
          ab := angle(0.500000 * (aitp.min + aitp.max));
          a0 := angle(a0 - ab);
          a1 := angle(a1 - ab);
          a2 := angle(a2 - ab);
          a3 := angle(a3 - ab);
          IF a3 &gt; a2 THEN
            a2 := a2 + 2.000000 * PI;
          END_IF;
          IF a0 &gt; a1 THEN
            a0 := a0 + 2.000000 * PI;
          END_IF;
          IF a3 &lt; a0 THEN
            amin := a3;
            amin_in := in3;
          ELSE
            amin := a0;
            amin_in := in0;
          END_IF;
          IF a2 &gt; a1 THEN
            amax := a2;
            amax_in := in2;
          ELSE
            amax := a1;
            amax_in := in1;
          END_IF;
          IF (amax - amin &gt; 2.000000 * PI) OR (amax - amin = 2.000000 * PI) AND (amin_in OR amax_in) THEN
            amin :=  - PI;
            amin_in := FALSE;
            amax := PI;
            amax_in := TRUE;
          ELSE
            amin := amin + ab;
            amax := amax + ab;
            angle_range(amin, amax);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN
      minclo := closed;
    END_IF;
    IF rmax_in THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    IF (rc &gt; rmnp) AND strictly_in(apc, aitp) THEN
      RETURN (?);
    END_IF;
    IF aitp.max - aitp.min = 2.000000 * PI THEN
      a := angle(aitp.min);
      IF rc &gt; rmnp THEN
        IF max_included(aitp) THEN
          RETURN (?);
        END_IF;
        rmin := 0.000000;
        rmin_in := FALSE;
        amin := aitp.min;
        amin_in := FALSE;
        amax := aitp.max;
        amax_in := FALSE;
      ELSE
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
        amin :=  - PI;
        amin_in := FALSE;
        amax := PI;
        amax_in := TRUE;
        IF NOT max_included(aitp) THEN
          IF apc = a THEN
            rmin_in := FALSE;
            amin := aitp.min;
            amin_in := FALSE;
            amax := aitp.max;
            amax_in := FALSE;
          ELSE
            IF acp = a THEN
              amin := aitp.min;
              amin_in := FALSE;
              amax := aitp.max;
              amax_in := FALSE;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 &lt;&gt; 0.000000 THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 &lt;&gt; 0.000000 THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF rmnp = 0.000000 THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp) THEN
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
      ELSE
        rmin := r2;
        rmin_in := in2;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF rmnp &lt; r THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF rmnp &lt; r THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r &lt; rmin THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r3 = rmin THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 &lt; rmin THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      ab := angle(0.500000 * (aitp.min + aitp.max));
      IF rc &gt; rmnp THEN
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
      ELSE
        a0 := angle(a0 - ab);
        a1 := angle(a1 - ab);
        a2 := angle(a2 - ab);
        a3 := angle(a3 - ab);
        IF a3 &gt; a2 THEN
          a2 := a2 + 2.000000 * PI;
        END_IF;
        IF a0 &gt; a1 THEN
          a0 := a0 + 2.000000 * PI;
        END_IF;
        IF a3 &lt; a0 THEN
          amin := a3;
          amin_in := in3;
        ELSE
          amin := a0;
          amin_in := in0;
        END_IF;
        IF a2 &gt; a1 THEN
          amax := a2;
          amax_in := in2;
        ELSE
          amax := a1;
          amax_in := in1;
        END_IF;
        IF (amax - amin &gt; 2.000000 * PI) OR (amax - amin = 2.000000 * PI) AND (amin_in OR amax_in) THEN
          amin :=  - PI;
          amin_in := FALSE;
          amax := PI;
          amax_in := TRUE;
          IF (rmin = 0.000000) AND rmin_in THEN
            RETURN (?);
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin, amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN
      minclo := closed;
    END_IF;
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  minclo := open;
  maxclo := open;
  IF amin_in THEN
    minclo := closed;
  END_IF;
  IF amax_in THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  RETURN (make_polar_complex_number_region(centre, ritv, aitv));
      </algorithm>
    </function>

    <function name="equal_cregion_pregion">
      <parameter name="crgn"
        varying="YES">
        <typename name="cartesian_complex_number_region"/>
      </parameter>
      <parameter name="prgn"
        varying="YES">
        <typename name="polar_complex_number_region"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    arng : REAL;
    amin : REAL;
    xc : REAL;
    yc : REAL;
    aitv : real_interval;
    xitv : real_interval;
    yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;

  IF NOT EXISTS(crgn) OR NOT EXISTS(prgn) THEN
    RETURN (FALSE);
  END_IF;
  IF max_exists(prgn.distance_constraint) THEN
    RETURN (FALSE);
  END_IF;
  IF real_min(prgn.distance_constraint) &lt;&gt; 0.000000 THEN
    RETURN (FALSE);
  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.500000 * PI THEN
    IF amin = 0.000000 THEN
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv) AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND min_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND NOT min_included(yitv) OR NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND min_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND NOT min_included(yitv)));
    END_IF;
    IF amin = 0.500000 * PI THEN
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND min_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND NOT min_included(yitv) OR NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND min_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND NOT min_included(yitv)));
    END_IF;
    IF amin =  - PI THEN
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND max_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND NOT max_included(yitv) OR NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND max_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND NOT max_included(yitv)));
    END_IF;
    IF amin =  - 0.500000 * PI THEN
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv) AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND max_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND NOT max_included(yitv) OR NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND max_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND NOT max_included(yitv)));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.000000 THEN
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND min_exists(yitv) AND (real_min(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND min_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(yitv)));
    END_IF;
    IF amin = 0.500000 * PI THEN
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv)));
    END_IF;
    IF amin =  - PI THEN
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND (real_max(yitv) = yc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND max_included(yitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(yitv)));
    END_IF;
    IF amin =  - 0.500000 * PI THEN
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv) AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) OR NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv)));
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="equal_maths_functions">
      <parameter name="fun1"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <parameter name="fun2"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    cum : LOGICAL;
  END_LOCAL;

  IF fun1 = fun2 THEN
    RETURN (TRUE);
  END_IF;
  cum := equal_maths_spaces(fun1.domain, fun2.domain);
  IF cum = FALSE THEN
    RETURN (FALSE);
  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
  IF cum = FALSE THEN
    RETURN (FALSE);
  END_IF;
  RETURN (UNKNOWN);
      </algorithm>
    </function>

    <function name="equal_maths_spaces">
      <parameter name="spc1"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="spc2"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1 : SET OF maths_value;
    set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1 : function_space;
    fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;

  IF spc1 = spc2 THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FINITE_SPACE&apos; IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF &apos;FINITE_SPACE&apos; IN spc2types THEN
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF(set1);
        cum := cum AND member_of(set1[i], spc2);
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF(set2);
          cum := cum AND member_of(set2[i], spc1);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF &apos;FINITE_INTEGER_INTERVAL&apos; IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1, make_finite_space(set2)));
    END_IF;
  END_IF;
  IF (&apos;FINITE_INTEGER_INTERVAL&apos; IN spc1types) AND (&apos;FINITE_SPACE&apos; IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1), spc2));
  END_IF;
  IF (&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN spc1types) AND (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN spc2types) THEN
    RETURN (equal_cregion_pregion(spc1, spc2));
  END_IF;
  IF (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN spc1types) AND (&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN spc2types) THEN
    RETURN (equal_cregion_pregion(spc2, spc1));
  END_IF;
  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN spc2types THEN
      IF expnt &lt;&gt; spc2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (equal_maths_spaces(base, spc2\uniform_product_space.base));
    END_IF;
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt &lt;&gt; SIZEOF(factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN spc2types THEN
      IF spc2\uniform_product_space.exponent &lt;&gt; SIZEOF(factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF &apos;LISTED_PRODUCT_SPACE&apos; IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF(factors) &lt;&gt; SIZEOF(factors2) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(factors[i], factors2[i]);
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF (&apos;EXTENDED_TUPLE_SPACE&apos; IN spc1types) AND (&apos;EXTENDED_TUPLE_SPACE&apos; IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender, spc2\extended_tuple_space.extender) AND equal_maths_spaces(spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF (&apos;FUNCTION_SPACE&apos; IN spc1types) AND (&apos;FUNCTION_SPACE&apos; IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint &lt;&gt; fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF fs1.domain_constraint &lt;&gt; sc_subspace THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint &lt;&gt; sc_subspace) OR (fs2.domain_constraint &lt;&gt; sc_member) THEN
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint, fs1.domain_argument) &lt;&gt; any_space_satisfies(fs2.domain_constraint, fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT (&apos;FINITE_SPACE&apos; IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF([&apos;FINITE_SPACE&apos;, &apos;FINITE_INTEGER_INTERVAL&apos;] * stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
    IF cum = FALSE THEN
      RETURN (FALSE);
    END_IF;
    IF fs1.range_constraint &lt;&gt; fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF fs1.range_constraint &lt;&gt; sc_subspace THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint &lt;&gt; sc_subspace) OR (fs2.range_constraint &lt;&gt; sc_member) THEN
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint, fs1.range_argument) &lt;&gt; any_space_satisfies(fs2.range_constraint, fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT (&apos;FINITE_SPACE&apos; IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF([&apos;FINITE_SPACE&apos;, &apos;FINITE_INTEGER_INTERVAL&apos;] * stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="equal_maths_values">
      <parameter name="val1"
        varying="YES">
        <typename name="maths_value"/>
      </parameter>
      <parameter name="val2"
        varying="YES">
        <typename name="maths_value"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  FUNCTION mem_of_vs (VAR val1 : maths_value; VAR val2 : maths_value):LOGICAL;
    IF NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT member_of(val1, values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;

  LOCAL
    types1 : SET OF STRING;
    types2 : SET OF STRING;
    list1 : LIST OF maths_value;
    list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;

  IF NOT EXISTS(val1) OR NOT EXISTS(val2) THEN
    RETURN (FALSE);
  END_IF;
  IF val1 = val2 THEN
    RETURN (TRUE);
  END_IF;
  types1 := stripped_typeof(val1);
  types2 := stripped_typeof(val2);
  IF (&apos;MATHS_ATOM&apos; IN types1) OR (&apos;COMPLEX_NUMBER_LITERAL&apos; IN types1) THEN
    IF &apos;MATHS_ATOM&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;COMPLEX_NUMBER_LITERAL&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;LIST&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;MATHS_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;MATHS_FUNCTION&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;GENERIC_EXPRESSION&apos; IN types2 THEN
      RETURN (mem_of_vs(val1, val2));
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF (&apos;MATHS_ATOM&apos; IN types2) OR (&apos;COMPLEX_NUMBER_LITERAL&apos; IN types2) THEN
    RETURN (equal_maths_values(val2, val1));
  END_IF;
  IF &apos;LIST&apos; IN types1 THEN
    IF &apos;LIST&apos; IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF(list1) &lt;&gt; SIZEOF(list2) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO SIZEOF(list1);
        cum := cum AND equal_maths_values(list1[i], list2[i]);
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF &apos;MATHS_SPACE&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;MATHS_FUNCTION&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;GENERIC_EXPRESSION&apos; IN types2 THEN
      RETURN (mem_of_vs(val1, val2));
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF &apos;LIST&apos; IN types2 THEN
    RETURN (equal_maths_values(val2, val1));
  END_IF;
  IF &apos;MATHS_SPACE&apos; IN types1 THEN
    IF &apos;MATHS_SPACE&apos; IN types2 THEN
      RETURN (equal_maths_spaces(val1, val2));
    END_IF;
    IF &apos;MATHS_FUNCTION&apos; IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF &apos;GENERIC_EXPRESSION&apos; IN types2 THEN
      RETURN (mem_of_vs(val1, val2));
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF &apos;MATHS_SPACE&apos; IN types2 THEN
    RETURN (equal_maths_values(val2, val1));
  END_IF;
  IF &apos;MATHS_FUNCTION&apos; IN types1 THEN
    IF &apos;MATHS_FUNCTION&apos; IN types2 THEN
      RETURN (equal_maths_functions(val1, val2));
    END_IF;
    IF &apos;GENERIC_EXPRESSION&apos; IN types2 THEN
      RETURN (mem_of_vs(val1, val2));
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF &apos;MATHS_FUNCTION&apos; IN types2 THEN
    RETURN (equal_maths_values(val2, val1));
  END_IF;
  IF (&apos;GENERIC_EXPRESSION&apos; IN types1) AND (&apos;GENERIC_EXPRESSION&apos; IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
      </algorithm>
    </function>

    <function name="es_subspace_of_es">
      <parameter name="es1"
        varying="YES">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <parameter name="es2"
        varying="YES">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF NOT EXISTS(es1) OR NOT EXISTS(es2) THEN
    RETURN (FALSE);
  END_IF;
  IF es1 = es2 THEN
    RETURN (TRUE);
  END_IF;
  IF es2 = es_generics THEN
    RETURN (TRUE);
  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN
    RETURN (TRUE);
  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR (es1 = es_integers)) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="expression_is_constant">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  RETURN (bool(SIZEOF(free_variables_of(expr)) = 0));
      </algorithm>
    </function>

    <function name="extract_factors">
      <parameter name="tspace"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="m"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="n"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;

  REPEAT i := m TO n;
    tsp := assoc_product_space(tsp, factor_space(tspace, i));
  END_REPEAT;
  RETURN (tsp);
      </algorithm>
    </function>

    <function name="factor1">
      <parameter name="tspace"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <typename name="maths_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF(tspace);
  END_LOCAL;

  IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF schema_prefix + &apos;LISTED_PRODUCT_SPACE&apos; IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
  END_IF;
  IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN typenames THEN
    RETURN (factor1(tspace\extended_tuple_space.base));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="factor_space">
      <parameter name="tspace"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="idx"
        varying="YES">
        <typename name="positive_integer"/>
      </parameter>
      <typename name="maths_space"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF(tspace);
  END_LOCAL;

  IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN typenames THEN
    IF idx &lt;= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF schema_prefix + &apos;LISTED_PRODUCT_SPACE&apos; IN typenames THEN
    IF idx &lt;= SIZEOF(tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN typenames THEN
    IF idx &lt;= space_dimension(tspace\extended_tuple_space.base) THEN
      RETURN (factor_space(tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="free_variables_of">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <aggregate type="SET"
      />
      <typename name="generic_variable"/>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;

  IF &apos;GENERIC_LITERAL&apos; IN typenames THEN
    RETURN (result);
  END_IF;
  IF &apos;GENERIC_VARIABLE&apos; IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF &apos;QUANTIFIER_EXPRESSION&apos; IN typenames THEN
    exprs := QUERY(ge &lt;* expr\multiple_arity_generic_expression.operands | NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF(exprs);
      result := result + free_variables_of(exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF &apos;UNARY_GENERIC_EXPRESSION&apos; IN typenames THEN
    RETURN (free_variables_of(expr\unary_generic_expression.operand));
  END_IF;
  IF &apos;BINARY_GENERIC_EXPRESSION&apos; IN typenames THEN
    result := free_variables_of(expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of(expr\binary_generic_expression.operands[2]));
  END_IF;
  IF &apos;MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN typenames THEN
    REPEAT i := 1 TO SIZEOF(expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of(expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  RETURN (result);
      </algorithm>
    </function>

    <function name="function_applicability">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function_select"/>
      </parameter>
      <parameter name="arguments"
        varying="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_value"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF(domain);
    narg : positive_integer := SIZEOF(arguments);
    arg : generic_expression;
  END_LOCAL;

  IF schema_prefix + &apos;PRODUCT_SPACE&apos; IN domain_types THEN
    IF space_dimension(domain) &lt;&gt; narg THEN
      RETURN (FALSE);
    END_IF;
  ELSE
    IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN domain_types THEN
      IF space_dimension(domain) &gt; narg THEN
        RETURN (FALSE);
      END_IF;
    ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand(arguments[i]);
    IF NOT has_values_space(arg) THEN
      RETURN (FALSE);
    END_IF;
    IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="function_is_1d_array">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    temp : maths_space;
  END_LOCAL;

  IF NOT EXISTS(func) THEN
    RETURN (FALSE);
  END_IF;
  IF space_dimension(func.domain) &lt;&gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF schema_prefix + &apos;PRODUCT_SPACE&apos; IN TYPEOF(temp) THEN
    IF space_dimension(temp) &lt;&gt; 1 THEN
      RETURN (FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="function_is_1d_table">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;

  IF NOT EXISTS(func) THEN
    RETURN (FALSE);
  END_IF;
  IF space_dimension(func.domain) &lt;&gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF schema_prefix + &apos;PRODUCT_SPACE&apos; IN TYPEOF(temp) THEN
    IF space_dimension(temp) &lt;&gt; 1 THEN
      RETURN (FALSE);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="function_is_2d_table">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1 : finite_integer_interval;
    itvl2 : finite_integer_interval;
  END_LOCAL;

  IF NOT EXISTS(func) THEN
    RETURN (FALSE);
  END_IF;
  IF space_dimension(func.domain) &lt;&gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1(func.domain);
  IF NOT (&apos;PRODUCT_SPACE&apos; IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  pspace := temp;
  IF space_dimension(pspace) &lt;&gt; 2 THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1(pspace);
  IF NOT (&apos;FINITE_INTEGER_INTERVAL&apos; IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space(pspace, 2);
  IF NOT (&apos;FINITE_INTEGER_INTERVAL&apos; IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
      </algorithm>
    </function>

    <function name="function_is_array">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;

  IF NOT EXISTS(func) THEN
    RETURN (FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(tspace))) THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT (schema_prefix + &apos;PRODUCT_SPACE&apos; IN TYPEOF(tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="function_is_table">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;

  IF NOT EXISTS(func) THEN
    RETURN (FALSE);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(tspace))) THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT (schema_prefix + &apos;PRODUCT_SPACE&apos; IN TYPEOF(tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1(tspace);
  IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base &lt;&gt; 0) AND (base &lt;&gt; 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min &lt;&gt; base THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="get_description_value">
      <parameter name="obj"
        varying="YES">
        <typename name="description_attribute_select"/>
      </parameter>
      <typename name="text"/>
      <algorithm>
  LOCAL
    description_bag : BAG OF description_attribute := USEDIN(obj, &apos;FUNCTIONAL_DATA_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM&apos;);
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
      </algorithm>
    </function>

    <function name="get_id_value">
      <parameter name="obj"
        varying="YES">
        <typename name="id_attribute_select"/>
      </parameter>
      <typename name="identifier"/>
      <algorithm>
  LOCAL
    id_bag : BAG OF id_attribute := USEDIN(obj, &apos;FUNCTIONAL_DATA_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM&apos;);
  END_LOCAL;

  IF SIZEOF(id_bag) = 1 THEN
    RETURN (id_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
      </algorithm>
    </function>

    <function name="get_name_value">
      <parameter name="obj"
        varying="YES">
        <typename name="name_attribute_select"/>
      </parameter>
      <typename name="label"/>
      <algorithm>
  LOCAL
    name_bag : BAG OF name_attribute := USEDIN(obj, &apos;FUNCTIONAL_DATA_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM&apos;);
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
      </algorithm>
    </function>

    <function name="get_role">
      <parameter name="obj"
        varying="YES">
        <typename name="role_select"/>
      </parameter>
      <typename name="object_role"/>
      <algorithm>
  LOCAL
    role_bag : BAG OF role_association := USEDIN(obj, &apos;FUNCTIONAL_DATA_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE&apos;);
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
      </algorithm>
    </function>

    <function name="has_values_space">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
  END_LOCAL;

  IF &apos;EXPRESSION&apos; IN typenames THEN
    RETURN (bool((&apos;NUMERIC_EXPRESSION&apos; IN typenames) OR (&apos;STRING_EXPRESSION&apos; IN typenames) OR (&apos;BOOLEAN_EXPRESSION&apos; IN typenames)));
  END_IF;
  IF &apos;MATHS_FUNCTION&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTION_APPLICATION&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;MATHS_SPACE&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;MATHS_VARIABLE&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;DEPENDENT_VARIABLE_DEFINITION&apos; IN typenames THEN
    RETURN (has_values_space(expr\unary_generic_expression.operand));
  END_IF;
  IF &apos;COMPLEX_NUMBER_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;LOGICAL_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;BINARY_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;MATHS_ENUM_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;REAL_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;INTEGER_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;ATOM_BASED_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;MATHS_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;PARTIAL_DERIVATIVE_EXPRESSION&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;DEFINITE_INTEGRAL_EXPRESSION&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="identical_sets">
      <parameter name="set_a"
        varying="YES">
        <typename name="class"/>
      </parameter>
      <parameter name="set_b"
        varying="YES">
        <typename name="class"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;

  IF set_a = set_b THEN
    RETURN (TRUE);
  END_IF;
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));
      </algorithm>
    </function>

    <function name="identical_to_one_of_set_of_sets">
      <parameter name="set_a"
        varying="YES">
        <typename name="class"/>
      </parameter>
      <parameter name="set_of_sets"
        varying="YES">
        <aggregate type="SET"
        />
        <typename name="class"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
    initial_size : INTEGER;
    augmented_size : INTEGER;
    set_of_forward_equivalences : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets : SET OF class := [];
  END_LOCAL;

  IF set_a IN set_of_sets THEN
    RETURN (TRUE);
  END_IF;
  initial_size := SIZEOF(set_of_sets);
  IF initial_size = 0 THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences + USEDIN(set_of_sets[i], &apos;FUNCTIONAL_DATA_MIM_LF.SAME_MEMBERSHIP.SET_1&apos;);
    set_of_backward_equivalences := set_of_forward_equivalences + USEDIN(set_of_sets[i], &apos;FUNCTIONAL_DATA_MIM_LF.SAME_MEMBERSHIP.SET_2&apos;);
  END_REPEAT;
  augmented_set_of_sets := set_of_sets;
  IF SIZEOF(set_of_forward_equivalences) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets + set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF SIZEOF(set_of_backward_equivalences) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets + set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));
      </algorithm>
    </function>

    <function name="is_acyclic">
      <parameter name="arg"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  RETURN (acyclic(arg, []));
      </algorithm>
    </function>

    <function name="is_int_expr">
      <parameter name="arg"
        varying="YES">
        <typename name="numeric_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
  END_LOCAL;

  IF &apos;FUNCTIONAL_DATA_MIM_LF.INT_LITERAL&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.REAL_LITERAL&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.INT_NUMERIC_VARIABLE&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.REAL_NUMERIC_VARIABLE&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.ABS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.MINUS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.SIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.TAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ASIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ACOS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ATAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.EXP_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG2_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG10_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.SQUARE_ROOT_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.PLUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MULT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MAXIMUM_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MINIMUM_FUNCTION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.MINUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.POWER_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (is_int_expr(arg\binary_numeric_expression.operands[1]) AND is_int_expr(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.DIV_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MOD_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.SLASH_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.LENGTH_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.VALUE_FUNCTION&apos; IN TYPEOF(arg) THEN
    IF &apos;FUNCTIONAL_DATA_MIM_LF.INT_VALUE_FUNCTION&apos; IN TYPEOF(arg) THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.INTEGER_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.REAL_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.BOOLEAN_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.STRING_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="is_sql_mappable">
      <parameter name="arg"
        varying="YES">
        <typename name="expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
  END_LOCAL;

  IF &apos;FUNCTIONAL_DATA_MIM_LF.SIMPLE_NUMERIC_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.MINUS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (is_sql_mappable(arg\unary_numeric_expression.operand));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.ABS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.SIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.TAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ASIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ACOS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.ATAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.EXP_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG2_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LOG10_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.SQUARE_ROOT_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.VALUE_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LENGTH_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.PLUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MULT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MAXIMUM_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MINIMUM_FUNCTION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.MINUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.SLASH_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (is_sql_mappable(arg\binary_numeric_expression.operands[1]) AND is_sql_mappable(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.DIV_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.MOD_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.POWER_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.NOT_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (is_sql_mappable(arg\unary_generic_expression.operand));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.ODD_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.XOR_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.AND_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.OR_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.EQUALS_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (is_sql_mappable(arg\binary_generic_expression.operands[1]) AND is_sql_mappable(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_GREATER&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_GREATER_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_LESS&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_LESS_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.COMPARISON_NOT_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.LIKE_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (is_sql_mappable(arg\comparison_expression.operands[1]) AND is_sql_mappable(arg\comparison_expression.operands[2]));
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.INTERVAL_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (is_sql_mappable(arg\interval_expression.interval_low) AND is_sql_mappable(arg\interval_expression.interval_high) AND is_sql_mappable(arg\interval_expression.interval_item));
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.NUMERIC_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.BOOLEAN_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.STRING_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.SIMPLE_STRING_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF (&apos;FUNCTIONAL_DATA_MIM_LF.INDEX_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.SUBSTRING_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.CONCAT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.FORMAT_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="item_in_context">
      <parameter name="item"
        varying="YES">
        <typename name="representation_item"/>
      </parameter>
      <parameter name="cntxt"
        varying="YES">
        <typename name="representation_context"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;

  IF SIZEOF(USEDIN(item, &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION.ITEMS&apos;) * cntxt.representations_in_context) &gt; 0 THEN
    RETURN (TRUE);
  ELSE
    y := QUERY(z &lt;* USEDIN(item, &apos;&apos;) | &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_ITEM&apos; IN TYPEOF(z));
    IF SIZEOF(y) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="leap_year">
      <parameter name="year"
        varying="YES">
        <typename name="year_number"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF (year MOD 4 = 0) AND (year MOD 100 &lt;&gt; 0) OR (year MOD 400 = 0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
      </algorithm>
    </function>

    <function name="list_selected_components">
      <parameter name="aggr"
        varying="YES">
        <aggregate type="LIST"
        />
        <typename name="maths_value"/>
      </parameter>
      <parameter name="k"
        varying="YES">
        <typename name="positive_integer"/>
      </parameter>
      <aggregate type="LIST"
      />
      <typename name="maths_value"/>
      <algorithm>
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;

  REPEAT i := LOINDEX(aggr) TO HIINDEX(aggr);
    IF k &lt;= SIZEOF(aggr[i]) THEN
      INSERT(result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
      </algorithm>
    </function>

    <function name="list_to_array">
      <parameter name="lis"
        varying="YES">
        <aggregate type="LIST"
        />
        <builtintype type="GENERIC"
          typelabel="t"
        />
      </parameter>
      <parameter name="low"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="u"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <aggregate type="ARRAY"
        lower="low"
        upper="u"
      />
      <builtintype type="GENERIC"
        typelabel="t"
      />
      <algorithm>
  LOCAL
    n : INTEGER;
    res : ARRAY [low:u] OF GENERIC:t;
  END_LOCAL;

  n := SIZEOF(lis);
  IF n &lt;&gt; u - low + 1 THEN
    RETURN (?);
  ELSE
    res := [lis[1]:n];
    REPEAT i := 2 TO n;
      res[low + i - 1] := lis[i];
    END_REPEAT;
    RETURN (res);
  END_IF;
      </algorithm>
    </function>

    <function name="make_atom_based_literal">
      <parameter name="lit_value"
        varying="YES">
        <typename name="atom_based_value"/>
      </parameter>
      <typename name="atom_based_literal"/>
      <algorithm>
  RETURN (atom_based_literal(lit_value)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_binary_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="BINARY"
        />
      </parameter>
      <typename name="binary_literal"/>
      <algorithm>
  RETURN (binary_literal(lit_value)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_boolean_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="BOOLEAN"
        />
      </parameter>
      <typename name="boolean_literal"/>
      <algorithm>
  RETURN (boolean_literal(lit_value)||simple_boolean_expression()||boolean_expression()||expression()||generic_expression()||simple_generic_expression()||generic_literal());
      </algorithm>
    </function>

    <function name="make_cartesian_complex_number_region">
      <parameter name="real_constraint"
        varying="YES">
        <typename name="real_interval"/>
      </parameter>
      <parameter name="imag_constraint"
        varying="YES">
        <typename name="real_interval"/>
      </parameter>
      <typename name="cartesian_complex_number_region"/>
      <algorithm>
  RETURN (cartesian_complex_number_region(real_constraint, imag_constraint)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_complex_number_literal">
      <parameter name="rpart"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="ipart"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <typename name="complex_number_literal"/>
      <algorithm>
  RETURN (complex_number_literal(rpart, ipart)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_elementary_function">
      <parameter name="func_id"
        varying="YES">
        <typename name="elementary_function_enumerators"/>
      </parameter>
      <typename name="elementary_function"/>
      <algorithm>
  RETURN (elementary_function(func_id)||maths_function()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_elementary_space">
      <parameter name="space_id"
        varying="YES">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <typename name="elementary_space"/>
      <algorithm>
  RETURN (elementary_space(space_id)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_extended_tuple_space">
      <parameter name="base"
        varying="YES">
        <typename name="product_space"/>
      </parameter>
      <parameter name="extender"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="extended_tuple_space"/>
      <algorithm>
  RETURN (extended_tuple_space(base, extender)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_finite_integer_interval">
      <parameter name="min"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <parameter name="max"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <typename name="finite_integer_interval"/>
      <algorithm>
  RETURN (finite_integer_interval(min, max)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_finite_real_interval">
      <parameter name="min"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="minclo"
        varying="YES">
        <typename name="open_closed"/>
      </parameter>
      <parameter name="max"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="maxclo"
        varying="YES">
        <typename name="open_closed"/>
      </parameter>
      <typename name="finite_real_interval"/>
      <algorithm>
  RETURN (finite_real_interval(min, minclo, max, maxclo)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_finite_space">
      <parameter name="members"
        varying="YES">
        <aggregate type="SET"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="finite_space"/>
      <algorithm>
  RETURN (finite_space(members)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_function_application">
      <parameter name="afunction"
        varying="YES">
        <typename name="maths_function_select"/>
      </parameter>
      <parameter name="arguments"
        varying="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="function_application"/>
      <algorithm>
  RETURN (function_application(afunction, arguments)||multiple_arity_generic_expression(convert_to_maths_function(afunction) + convert_to_operands(arguments))||generic_expression());
      </algorithm>
    </function>

    <function name="make_function_space">
      <parameter name="domain_constraint"
        varying="YES">
        <typename name="space_constraint_type"/>
      </parameter>
      <parameter name="domain_argument"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="range_constraint"
        varying="YES">
        <typename name="space_constraint_type"/>
      </parameter>
      <parameter name="range_argument"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="function_space"/>
      <algorithm>
  RETURN (function_space(domain_constraint, domain_argument, range_constraint, range_argument)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_int_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="INTEGER"
        />
      </parameter>
      <typename name="int_literal"/>
      <algorithm>
  RETURN (int_literal()||literal_number(lit_value)||simple_numeric_expression()||numeric_expression()||expression()||generic_expression()||simple_generic_expression()||generic_literal());
      </algorithm>
    </function>

    <function name="make_listed_product_space">
      <parameter name="factors"
        varying="YES">
        <aggregate type="LIST"
        />
        <typename name="maths_space"/>
      </parameter>
      <typename name="listed_product_space"/>
      <algorithm>
  RETURN (listed_product_space(factors)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_logical_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="LOGICAL"
        />
      </parameter>
      <typename name="logical_literal"/>
      <algorithm>
  RETURN (logical_literal(lit_value)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_maths_enum_literal">
      <parameter name="lit_value"
        varying="YES">
        <typename name="maths_enum_atom"/>
      </parameter>
      <typename name="maths_enum_literal"/>
      <algorithm>
  RETURN (maths_enum_literal(lit_value)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_maths_tuple_literal">
      <parameter name="lit_value"
        varying="YES">
        <aggregate type="LIST"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="maths_tuple_literal"/>
      <algorithm>
  RETURN (maths_tuple_literal(lit_value)||generic_literal()||simple_generic_expression()||generic_expression());
      </algorithm>
    </function>

    <function name="make_parallel_composed_function">
      <parameter name="srcdom"
        varying="YES">
        <typename name="maths_space_or_function"/>
      </parameter>
      <parameter name="prepfuncs"
        varying="YES">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="maths_function"/>
      </parameter>
      <parameter name="finfunc"
        varying="YES">
        <typename name="maths_function_select"/>
      </parameter>
      <typename name="parallel_composed_function"/>
      <algorithm>
  RETURN (parallel_composed_function(srcdom, prepfuncs, finfunc)||maths_function()||generic_expression()||multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
      </algorithm>
    </function>

    <function name="make_polar_complex_number_region">
      <parameter name="centre"
        varying="YES">
        <typename name="complex_number_literal"/>
      </parameter>
      <parameter name="dis_constraint"
        varying="YES">
        <typename name="real_interval"/>
      </parameter>
      <parameter name="dir_constraint"
        varying="YES">
        <typename name="finite_real_interval"/>
      </parameter>
      <typename name="polar_complex_number_region"/>
      <algorithm>
  RETURN (polar_complex_number_region(centre, dis_constraint, dir_constraint)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_real_interval_from_min">
      <parameter name="min"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="minclo"
        varying="YES">
        <typename name="open_closed"/>
      </parameter>
      <typename name="real_interval_from_min"/>
      <algorithm>
  RETURN (real_interval_from_min(min, minclo)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_real_interval_to_max">
      <parameter name="max"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <parameter name="maxclo"
        varying="YES">
        <typename name="open_closed"/>
      </parameter>
      <typename name="real_interval_to_max"/>
      <algorithm>
  RETURN (real_interval_to_max(max, maxclo)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="make_real_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="REAL"
        />
      </parameter>
      <typename name="real_literal"/>
      <algorithm>
  RETURN (real_literal()||literal_number(lit_value)||simple_numeric_expression()||numeric_expression()||expression()||generic_expression()||simple_generic_expression()||generic_literal());
      </algorithm>
    </function>

    <function name="make_string_literal">
      <parameter name="lit_value"
        varying="YES">
        <builtintype type="STRING"
        />
      </parameter>
      <typename name="string_literal"/>
      <algorithm>
  RETURN (string_literal(lit_value)||simple_string_expression()||string_expression()||expression()||generic_expression()||simple_generic_expression()||generic_literal());
      </algorithm>
    </function>

    <function name="make_uniform_product_space">
      <parameter name="base"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="exponent"
        varying="YES">
        <typename name="positive_integer"/>
      </parameter>
      <typename name="uniform_product_space"/>
      <algorithm>
  RETURN (uniform_product_space(base, exponent)||maths_space()||generic_expression()||generic_literal()||simple_generic_expression());
      </algorithm>
    </function>

    <function name="max_exists">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  RETURN (bool((schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (schema_prefix + &apos;INTEGER_INTERVAL_TO_MAX&apos; IN types) OR (schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types) OR (schema_prefix + &apos;REAL_INTERVAL_TO_MAX&apos; IN types)));
      </algorithm>
    </function>

    <function name="max_included">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  IF (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (schema_prefix + &apos;INTEGER_INTERVAL_TO_MAX&apos; IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF schema_prefix + &apos;REAL_INTERVAL_TO_MAX&apos; IN types THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="member_of">
      <parameter name="val"
        varying="YES">
        <builtintype type="GENERIC"
          typelabel="g"
        />
      </parameter>
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    v : maths_value := simplify_maths_value(convert_to_maths_value(val));
    vtypes : SET OF STRING := stripped_typeof(v);
    s : maths_space := simplify_maths_space(spc);
    stypes : SET OF STRING := stripped_typeof(s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl : LOGICAL;
    cum : LOGICAL;
    vspc : maths_space;
    sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;

  IF NOT EXISTS(s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS(v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF (&apos;GENERIC_EXPRESSION&apos; IN vtypes) AND NOT (&apos;MATHS_SPACE&apos; IN vtypes) AND NOT (&apos;MATHS_FUNCTION&apos; IN vtypes) AND NOT (&apos;COMPLEX_NUMBER_LITERAL&apos; IN vtypes) THEN
    IF has_values_space(v) THEN
      vspc := values_space_of(v);
      IF subspace_of(vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces(vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF &apos;ELEMENTARY_SPACE&apos; IN stypes THEN
    CASE s\elementary_space.space_id OF 
      es_numbers:
        RETURN ((&apos;NUMBER&apos; IN vtypes) OR (&apos;COMPLEX_NUMBER_LITERAL&apos; IN vtypes));
      es_complex_numbers:
        RETURN (&apos;COMPLEX_NUMBER_LITERAL&apos; IN vtypes);
      es_reals:
        RETURN ((&apos;REAL&apos; IN vtypes) AND NOT (&apos;INTEGER&apos; IN vtypes));
      es_integers:
        RETURN (&apos;INTEGER&apos; IN vtypes);
      es_logicals:
        RETURN (&apos;LOGICAL&apos; IN vtypes);
      es_booleans:
        RETURN (&apos;BOOLEAN&apos; IN vtypes);
      es_strings:
        RETURN (&apos;STRING&apos; IN vtypes);
      es_binarys:
        RETURN (&apos;BINARY&apos; IN vtypes);
      es_maths_spaces:
        RETURN (&apos;MATHS_SPACE&apos; IN vtypes);
      es_maths_functions:
        RETURN (&apos;MATHS_FUNCTION&apos; IN vtypes);
      es_generics:
        RETURN (TRUE);
    END_CASE;
  END_IF;
  IF &apos;FINITE_INTEGER_INTERVAL&apos; IN stypes THEN
    IF &apos;INTEGER&apos; IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min &lt;= tmp_int &lt;= s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN stypes THEN
    IF &apos;INTEGER&apos; IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min &lt;= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;INTEGER_INTERVAL_TO_MAX&apos; IN stypes THEN
    IF &apos;INTEGER&apos; IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int &lt;= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FINITE_REAL_INTERVAL&apos; IN stypes THEN
    IF (&apos;REAL&apos; IN vtypes) AND NOT (&apos;INTEGER&apos; IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min &lt;= tmp_real &lt;= s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min &lt;= tmp_real &lt; s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min &lt; tmp_real &lt;= s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min &lt; tmp_real &lt; s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;REAL_INTERVAL_FROM_MIN&apos; IN stypes THEN
    IF (&apos;REAL&apos; IN vtypes) AND NOT (&apos;INTEGER&apos; IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min &lt;= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min &lt; tmp_real);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;REAL_INTERVAL_TO_MAX&apos; IN stypes THEN
    IF (&apos;REAL&apos; IN vtypes) AND NOT (&apos;INTEGER&apos; IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real &lt;= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real &lt; s\real_interval_to_max.max);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN stypes THEN
    IF &apos;COMPLEX_NUMBER_LITERAL&apos; IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part, s\cartesian_complex_number_region.real_constraint) AND member_of(v\complex_number_literal.imag_part, s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN stypes THEN
    IF &apos;COMPLEX_NUMBER_LITERAL&apos; IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part - s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part - s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT(tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real, s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.000000 THEN
        RETURN (TRUE);
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
      RETURN (member_of(tmp_real, s\polar_complex_number_region.direction_constraint) OR member_of(tmp_real + 2.000000 * PI, s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FINITE_SPACE&apos; IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF(smem);
      cum := cum OR equal_maths_values(v, smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN stypes THEN
    IF &apos;LIST&apos; IN vtypes THEN
      IF SIZEOF(v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN stypes THEN
    IF &apos;LIST&apos; IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF(v) = SIZEOF(factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], factors[i]);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN stypes THEN
    IF &apos;LIST&apos; IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF(v) &gt;= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i], factor_space(sspc, i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int + 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTION_SPACE&apos; IN stypes THEN
    IF &apos;MATHS_FUNCTION&apos; IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF 
        sc_equal:
          cum := equal_maths_spaces(vspc, sspc);
        sc_subspace:
          cum := subspace_of(vspc, sspc);
        sc_member:
          cum := member_of(vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF 
        sc_equal:
          cum := cum AND equal_maths_spaces(vspc, sspc);
        sc_subspace:
          cum := cum AND subspace_of(vspc, sspc);
        sc_member:
          cum := cum AND member_of(vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  RETURN (UNKNOWN);
      </algorithm>
    </function>

    <function name="min_exists">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  RETURN (bool((schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (schema_prefix + &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types) OR (schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types) OR (schema_prefix + &apos;REAL_INTERVAL_FROM_MIN&apos; IN types)));
      </algorithm>
    </function>

    <function name="min_included">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  IF (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (schema_prefix + &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF schema_prefix + &apos;REAL_INTERVAL_FROM_MIN&apos; IN types THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="no_cyclic_domain_reference">
      <parameter name="ref"
        varying="YES">
        <typename name="maths_space_or_function"/>
      </parameter>
      <parameter name="used"
        varying="YES">
        <aggregate type="SET"
        />
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF(ref);
    func : maths_function;
  END_LOCAL;

  IF NOT EXISTS(ref) OR NOT EXISTS(used) THEN
    RETURN (FALSE);
  END_IF;
  IF schema_prefix + &apos;MATHS_SPACE&apos; IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF schema_prefix + &apos;CONSTANT_FUNCTION&apos; IN typenames THEN
    RETURN (no_cyclic_domain_reference(func\constant_function.source_of_domain, used + [func]));
  END_IF;
  IF schema_prefix + &apos;SELECTOR_FUNCTION&apos; IN typenames THEN
    RETURN (no_cyclic_domain_reference(func\selector_function.source_of_domain, used + [func]));
  END_IF;
  IF schema_prefix + &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN typenames THEN
    RETURN (no_cyclic_domain_reference(func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="no_cyclic_space_reference">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="refs"
        varying="YES">
        <aggregate type="SET"
        />
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;

  IF spc IN refs THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF(spc);
  refs_plus := refs + spc;
  IF schema_prefix + &apos;FINITE_SPACE&apos; IN types THEN
    RETURN (bool(SIZEOF(QUERY(sp &lt;* QUERY(mem &lt;* spc\finite_space.members | schema_prefix + &apos;MATHS_SPACE&apos; IN TYPEOF(mem)) | NOT no_cyclic_space_reference(sp, refs_plus))) = 0));
  END_IF;
  IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN types THEN
    RETURN (no_cyclic_space_reference(spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF schema_prefix + &apos;LISTED_PRODUCT_SPACE&apos; IN types THEN
    RETURN (bool(SIZEOF(QUERY(fac &lt;* spc\listed_product_space.factors | NOT no_cyclic_space_reference(fac, refs_plus))) = 0));
  END_IF;
  IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN types THEN
    RETURN (no_cyclic_space_reference(spc\extended_tuple_space.base, refs_plus) AND no_cyclic_space_reference(spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="nondecreasing">
      <parameter name="lr"
        varying="YES">
        <aggregate type="LIST"
        />
        <builtintype type="REAL"
        />
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF NOT EXISTS(lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF(lr);
    IF lr[j] &lt; lr[j - 1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="normalise">
      <parameter name="arg"
        varying="YES">
        <typename name="vector_or_direction"/>
      </parameter>
      <typename name="vector_or_direction"/>
      <algorithm>
  LOCAL
    ndim : INTEGER;
    v : direction;
    result : vector_or_direction;
    vec : vector;
    mag : REAL;
  END_LOCAL;

  IF NOT EXISTS(arg) THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF &apos;FUNCTIONAL_DATA_MIM_LF.VECTOR&apos; IN TYPEOF(arg) THEN
      v := dummy_gri||direction(arg.orientation.direction_ratios);
      IF arg.magnitude = 0.000000 THEN
        RETURN (?);
      ELSE
        vec := dummy_gri||vector(v, 1.000000);
      END_IF;
    ELSE
      v := dummy_gri||direction(arg.direction_ratios);
    END_IF;
    mag := 0.000000;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag &gt; 0.000000 THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i] / mag;
      END_REPEAT;
      IF &apos;FUNCTIONAL_DATA_MIM_LF.VECTOR&apos; IN TYPEOF(arg) THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
  RETURN (result);
      </algorithm>
    </function>

    <function name="number_superspace_of">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="elementary_space"/>
      <algorithm>
  IF subspace_of_es(spc, es_integers) THEN
    RETURN (the_integers);
  END_IF;
  IF subspace_of_es(spc, es_reals) THEN
    RETURN (the_reals);
  END_IF;
  IF subspace_of_es(spc, es_complex_numbers) THEN
    RETURN (the_complex_numbers);
  END_IF;
  IF subspace_of_es(spc, es_numbers) THEN
    RETURN (the_numbers);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="number_tuple_subspace_check">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;

  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base, es_numbers));
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      cum := cum AND subspace_of_es(factors[i], es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender, es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="one_tuples_of">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  RETURN (make_uniform_product_space(spc, 1));
      </algorithm>
    </function>

    <function name="orthogonal_complement">
      <parameter name="vec"
        varying="YES">
        <typename name="direction"/>
      </parameter>
      <typename name="direction"/>
      <algorithm>
  LOCAL
    result : direction;
  END_LOCAL;

  IF (vec.dim &lt;&gt; 2) OR NOT EXISTS(vec) THEN
    RETURN (?);
  ELSE
    result := dummy_gri||direction([ - vec.direction_ratios[2], vec.direction_ratios[1]]);
    RETURN (result);
  END_IF;
      </algorithm>
    </function>

    <function name="parallel_composed_function_composability_check">
      <parameter name="funcs"
        varying="YES">
        <aggregate type="LIST"
        />
        <typename name="maths_function"/>
      </parameter>
      <parameter name="final"
        varying="YES">
        <typename name="maths_function_select"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function(final);
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(funcs);
    tplsp := assoc_product_space(tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces(tplsp, finfun.domain));
      </algorithm>
    </function>

    <function name="parallel_composed_function_domain_check">
      <parameter name="comdom"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="funcs"
        varying="YES">
        <aggregate type="LIST"
        />
        <typename name="maths_function"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  REPEAT i := 1 TO SIZEOF(funcs);
    IF NOT compatible_spaces(comdom, funcs[i].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="partial_derivative_check">
      <parameter name="domain"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="d_vars"
        varying="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="input_selector"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;

  IF (space_dimension(domain) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(domain))) THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  REPEAT i := 1 TO SIZEOF(d_vars);
    k := d_vars[i];
    IF k &gt; dim THEN
      RETURN (FALSE);
    END_IF;
    fspc := factor_space(domn, k);
    IF NOT subspace_of_es(fspc, es_reals) AND NOT subspace_of_es(fspc, es_complex_numbers) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="real_max">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="REAL"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  IF schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF schema_prefix + &apos;INTEGER_INTERVAL_TO_MAX&apos; IN types THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF schema_prefix + &apos;REAL_INTERVAL_TO_MAX&apos; IN types THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="real_min">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="REAL"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(spc);
  END_LOCAL;

  IF schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN types THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF schema_prefix + &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF schema_prefix + &apos;FINITE_REAL_INTERVAL&apos; IN types THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF schema_prefix + &apos;REAL_INTERVAL_FROM_MIN&apos; IN types THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="remove_first">
      <parameter name="alist"
        varying="YES">
        <aggregate type="LIST"
        />
        <builtintype type="GENERIC"
          typelabel="gen"
        />
      </parameter>
      <aggregate type="LIST"
      />
      <builtintype type="GENERIC"
        typelabel="gen"
      />
      <algorithm>
  LOCAL
    blist : LIST OF GENERIC:gen := alist;
  END_LOCAL;

  IF SIZEOF(blist) &gt; 0 THEN
    REMOVE(blist, 1);
  END_IF;
  RETURN (blist);
      </algorithm>
    </function>

    <function name="repackage">
      <parameter name="tspace"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <parameter name="repckg"
        varying="YES">
        <typename name="repackage_options"/>
      </parameter>
      <typename name="tuple_space"/>
      <algorithm>
  CASE repckg OF 
    ro_nochange:
      RETURN (tspace);
    ro_wrap_as_tuple:
      RETURN (one_tuples_of(tspace));
    ro_unwrap_tuple:
      RETURN (factor1(tspace));
    OTHERWISE:
      RETURN (?);
  END_CASE;
      </algorithm>
    </function>

    <function name="shape_of_array">
      <parameter name="func"
        varying="YES">
        <typename name="maths_function"/>
      </parameter>
      <aggregate type="LIST"
      />
      <typename name="positive_integer"/>
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;

  IF schema_prefix + &apos;EXPLICIT_TABLE_FUNCTION&apos; IN TYPEOF(func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND (schema_prefix + &apos;TUPLE_SPACE&apos; IN TYPEOF(factor1(tspace))) THEN
    tspace := factor1(tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT (schema_prefix + &apos;FINITE_INTEGER_INTERVAL&apos; IN TYPEOF(temp)) THEN
      RETURN (?);
    END_IF;
    INSERT(result, temp\finite_integer_interval.size, i - 1);
  END_REPEAT;
  RETURN (result);
      </algorithm>
    </function>

    <function name="simplify_function_application">
      <parameter name="expr"
        varying="YES">
        <typename name="function_application"/>
      </parameter>
      <typename name="maths_value"/>
      <algorithm>
  FUNCTION ctmv (VAR x : GENERIC:g):maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;

  FUNCTION makec (VAR x : REAL; VAR y : REAL):complex_number_literal;
    RETURN (make_complex_number_literal(x, y));
  END_FUNCTION;

  FUNCTION good_t (VAR v : maths_value; VAR tn : STRING):BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;

    IF &apos;LIST&apos; IN TYPEOF(v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF(tpl);
        IF NOT (tn IN TYPEOF(tpl[i])) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;

  PROCEDURE parts (VAR c : complex_number_literal; VAR x : REAL; VAR y : REAL);
    x := c.real_part;
    y := c.imag_part;
  END_PROCEDURE;

  CONSTANT
    cnlit : STRING := schema_prefix + &apos;COMPLEX_NUMBER_LITERAL&apos;;
  END_CONSTANT;

  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v : maths_value;
    v1 : maths_value;
    v2 : maths_value;
    v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc : LOGICAL;
    cum : LOGICAL;
    j : INTEGER;
    k : INTEGER;
    n : INTEGER;
    p : REAL;
    q : REAL;
    r : REAL;
    s : REAL;
    t : REAL;
    u : REAL;
    str : STRING;
    st2 : STRING;
    bin : BINARY;
    bi2 : BINARY;
    tpl : LIST OF maths_value;
    tp2 : LIST OF maths_value;
    mem : SET OF maths_value := [];
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT(vlist, v, i - 1);
  END_REPEAT;
  IF SIZEOF(vlist) &gt;= 1 THEN
    v1 := vlist[1];
  END_IF;
  IF SIZEOF(vlist) &gt;= 2 THEN
    v2 := vlist[2];
  END_IF;
  IF SIZEOF(vlist) &gt;= 3 THEN
    v3 := vlist[3];
  END_IF;
  IF &apos;ELEMENTARY_FUNCTION_ENUMERATORS&apos; IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF &apos;ELEMENTARY_FUNCTION&apos; IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF 
      ef_and:
        BEGIN
          cum := TRUE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;LOGICAL&apos; IN TYPEOF(vlist[i]) THEN
              lgc := vlist[i];
              cum := cum AND lgc;
              IF lgc = FALSE THEN
                RETURN (ctmv(FALSE));
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(cum));
          END_IF;
          IF cum &lt;&gt; TRUE THEN
            INSERT(vlist, ctmv(cum), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_or:
        BEGIN
          cum := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;LOGICAL&apos; IN TYPEOF(vlist[i]) THEN
              lgc := vlist[i];
              cum := cum OR lgc;
              IF lgc = TRUE THEN
                RETURN (ctmv(TRUE));
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(cum));
          END_IF;
          IF cum &lt;&gt; FALSE THEN
            INSERT(vlist, ctmv(cum), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_not:
        IF &apos;LOGICAL&apos; IN TYPEOF(v1) THEN
          lgc := v1;
          RETURN (ctmv(NOT lgc));
        END_IF;
      ef_xor:
        BEGIN
          IF &apos;LOGICAL&apos; IN TYPEOF(v1) THEN
            lgc := v1;
            IF &apos;LOGICAL&apos; IN TYPEOF(v2) THEN
              cum := v2;
              RETURN (ctmv(lgc XOR cum));
            ELSE
              IF lgc = FALSE THEN
                RETURN (ctmv(v2));
              ELSE
                IF lgc = UNKNOWN THEN
                  RETURN (ctmv(UNKNOWN));
                ELSE
                  RETURN (make_function_application(ef_not, [v2]));
                END_IF;
              END_IF;
            END_IF;
          ELSE
            IF &apos;LOGICAL&apos; IN TYPEOF(v2) THEN
              lgc := v2;
              IF lgc = FALSE THEN
                RETURN (ctmv(v1));
              ELSE
                IF lgc = UNKNOWN THEN
                  RETURN (ctmv(UNKNOWN));
                ELSE
                  RETURN (make_function_application(ef_not, [v1]));
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END;
      ef_negate_i:
        IF &apos;INTEGER&apos; IN TYPEOF(v1) THEN
          j := v1;
          RETURN (ctmv( - j));
        END_IF;
      ef_add_i:
        BEGIN
          j := 0;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;INTEGER&apos; IN TYPEOF(vlist[i]) THEN
              k := vlist[i];
              j := j + k;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(j));
          END_IF;
          IF j &lt;&gt; 0 THEN
            INSERT(vlist, ctmv(j), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j - k));
        END_IF;
      ef_multiply_i:
        BEGIN
          j := 1;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;INTEGER&apos; IN TYPEOF(vlist[i]) THEN
              k := vlist[i];
              j := j * k;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(j));
          END_IF;
          IF j &lt;&gt; 1 THEN
            INSERT(vlist, ctmv(j), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_divide_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j DIV k));
        END_IF;
      ef_mod_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j MOD k));
        END_IF;
      ef_exponentiate_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          n := 1;
          REPEAT i := 1 TO ABS(k);
            n := n * j;
          END_REPEAT;
          IF k &lt; 0 THEN
            n := 1 DIV n;
          END_IF;
          RETURN (ctmv(n));
        END_IF;
      ef_eq_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j = k));
        END_IF;
      ef_ne_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j &lt;&gt; k));
        END_IF;
      ef_gt_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j &gt; k));
        END_IF;
      ef_lt_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j &lt; k));
        END_IF;
      ef_ge_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j &gt;= k));
        END_IF;
      ef_le_i:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          j := v1;
          k := v2;
          RETURN (ctmv(j &lt;= k));
        END_IF;
      ef_abs_i:
        IF &apos;INTEGER&apos; IN TYPEOF(v1) THEN
          j := v1;
          RETURN (ctmv(ABS(j)));
        END_IF;
      ef_max_i:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;INTEGER&apos; IN TYPEOF(vlist[i]) THEN
              IF boo THEN
                k := vlist[i];
                IF k &gt; j THEN
                  j := k;
                END_IF;
              ELSE
                j := vlist[i];
                boo := TRUE;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(j));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(j), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_min_i:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;INTEGER&apos; IN TYPEOF(vlist[i]) THEN
              IF boo THEN
                k := vlist[i];
                IF k &lt; j THEN
                  j := k;
                END_IF;
              ELSE
                j := vlist[i];
                boo := TRUE;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(j));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(j), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_negate_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv( - r));
        END_IF;
      ef_reciprocal_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(1.000000 / r));
        END_IF;
      ef_add_r:
        BEGIN
          r := 0.000000;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;REAL&apos; IN TYPEOF(vlist[i]) THEN
              s := vlist[i];
              r := r + s;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(r));
          END_IF;
          IF r &lt;&gt; 0.000000 THEN
            INSERT(vlist, ctmv(r), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r - s));
        END_IF;
      ef_multiply_r:
        BEGIN
          r := 1.000000;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;REAL&apos; IN TYPEOF(vlist[i]) THEN
              s := vlist[i];
              r := r * s;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(r));
          END_IF;
          IF r &lt;&gt; 1.000000 THEN
            INSERT(vlist, ctmv(r), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_divide_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r / s));
        END_IF;
      ef_mod_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          t := r / s;
          j := t DIV 1;
          IF (t &lt; 0.000000) AND (j &lt;&gt; t) THEN
            j := j - 1;
          END_IF;
          RETURN (ctmv(r - j * s));
        END_IF;
      ef_exponentiate_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r**s));
        END_IF;
      ef_exponentiate_ri:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          r := v1;
          k := v2;
          t := 1.000000;
          REPEAT i := 1 TO ABS(k);
            t := t * r;
          END_REPEAT;
          IF k &lt; 0 THEN
            t := 1.000000 / t;
          END_IF;
          RETURN (ctmv(t));
        END_IF;
      ef_eq_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r = s));
        END_IF;
      ef_ne_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r &lt;&gt; s));
        END_IF;
      ef_gt_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r &gt; s));
        END_IF;
      ef_lt_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r &lt; s));
        END_IF;
      ef_ge_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r &gt;= s));
        END_IF;
      ef_le_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(r &lt;= s));
        END_IF;
      ef_abs_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(ABS(r)));
        END_IF;
      ef_max_r:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;REAL&apos; IN TYPEOF(vlist[i]) THEN
              IF boo THEN
                s := vlist[i];
                IF s &gt; r THEN
                  r := s;
                END_IF;
              ELSE
                r := vlist[i];
                boo := TRUE;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(r));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(r), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_min_r:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;REAL&apos; IN TYPEOF(vlist[i]) THEN
              IF boo THEN
                s := vlist[i];
                IF s &lt; r THEN
                  r := s;
                END_IF;
              ELSE
                r := vlist[i];
                boo := TRUE;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(r));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(r), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_acos_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(ACOS(r)));
        END_IF;
      ef_asin_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(ASIN(r)));
        END_IF;
      ef_atan2_r:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (ctmv(atan2(r, s)));
        END_IF;
      ef_cos_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(COS(r)));
        END_IF;
      ef_exp_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(EXP(r)));
        END_IF;
      ef_ln_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(LOG(r)));
        END_IF;
      ef_log2_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(LOG2(r)));
        END_IF;
      ef_log10_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(LOG10(r)));
        END_IF;
      ef_sin_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(SIN(r)));
        END_IF;
      ef_sqrt_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(SQRT(r)));
        END_IF;
      ef_tan_r:
        IF &apos;REAL&apos; IN TYPEOF(v1) THEN
          r := v1;
          RETURN (ctmv(TAN(r)));
        END_IF;
      ef_form_c:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND (&apos;REAL&apos; IN TYPEOF(v2)) THEN
          r := v1;
          s := v2;
          RETURN (makec(r, s));
        END_IF;
      ef_rpart_c:
        IF cnlit IN TYPEOF(v1) THEN
          RETURN (ctmv(v1\complex_number_literal.real_part));
        END_IF;
      ef_ipart_c:
        IF cnlit IN TYPEOF(v1) THEN
          RETURN (ctmv(v1\complex_number_literal.imag_part));
        END_IF;
      ef_negate_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (makec( - p,  - q));
        END_IF;
      ef_reciprocal_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          t := p * p + q * q;
          RETURN (makec(p / t,  - q / t));
        END_IF;
      ef_add_c:
        BEGIN
          p := 0.000000;
          q := 0.000000;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF cnlit IN TYPEOF(vlist[i]) THEN
              parts(vlist[i], r, s);
              p := p + r;
              q := q + s;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (makec(p, q));
          END_IF;
          IF p * p + q * q &lt;&gt; 0.000000 THEN
            INSERT(vlist, makec(p, q), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_c:
        IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          parts(v2, r, s);
          RETURN (makec(p - r, q - s));
        END_IF;
      ef_multiply_c:
        BEGIN
          p := 1.000000;
          q := 0.000000;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF cnlit IN TYPEOF(vlist[i]) THEN
              parts(vlist[i], r, s);
              p := p * r - q * s;
              q := p * s + q * r;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (makec(p, q));
          END_IF;
          IF (p &lt;&gt; 1.000000) OR (q &lt;&gt; 0.000000) THEN
            INSERT(vlist, makec(p, q), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_divide_c:
        IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          parts(v2, r, s);
          t := r * r + s * s;
          RETURN (makec((p * r + q * s) / t, (q * r - p * s) / t));
        END_IF;
      ef_exponentiate_c:
        IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          parts(v2, r, s);
          t := 0.500000 * LOG(p * p + q * q);
          u := atan2(q, p);
          p := r * t - s * u;
          q := r * u + s * t;
          r := EXP(p);
          RETURN (makec(r * COS(q), r * SIN(q)));
        END_IF;
      ef_exponentiate_ci:
        IF (cnlit IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          k := v2;
          r := 1.000000;
          s := 0.000000;
          REPEAT i := 1 TO ABS(k);
            r := p * r - q * s;
            s := p * s + q * r;
          END_REPEAT;
          IF k &lt; 0 THEN
            t := r * r + s * s;
            r := r / t;
            s :=  - s / t;
          END_IF;
          RETURN (makec(r, s));
        END_IF;
      ef_eq_c:
        IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          parts(v2, r, s);
          RETURN (ctmv((p = r) AND (q = s)));
        END_IF;
      ef_ne_c:
        IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2)) THEN
          parts(v1, p, q);
          parts(v2, r, s);
          RETURN (ctmv((p &lt;&gt; r) OR (q &lt;&gt; s)));
        END_IF;
      ef_conjugate_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (makec(p,  - q));
        END_IF;
      ef_abs_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (ctmv(SQRT(p * p + q * q)));
        END_IF;
      ef_arg_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (ctmv(atan2(q, p)));
        END_IF;
      ef_cos_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          t := 0.500000 * EXP( - q);
          u := 0.500000 * EXP(q);
          RETURN (makec((t + u) * COS(p), (t - u) * SIN(p)));
        END_IF;
      ef_exp_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (makec(EXP(p) * COS(q), EXP(p) * SIN(q)));
        END_IF;
      ef_ln_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          RETURN (makec(0.500000 * LOG(p * p + q * q), atan2(q, p)));
        END_IF;
      ef_sin_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          t := 0.500000 * EXP( - q);
          u := 0.500000 * EXP(q);
          RETURN (makec((t + u) * SIN(p), (u - t) * COS(p)));
        END_IF;
      ef_sqrt_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          t := SQRT(SQRT(p * p + q * q));
          u := 0.500000 * atan2(q, p);
          RETURN (makec(t * COS(u), t * SIN(u)));
        END_IF;
      ef_tan_c:
        IF cnlit IN TYPEOF(v1) THEN
          parts(v1, p, q);
          t := EXP(2.000000 * q) + EXP( - 2.000000 * q) + 2.000000 * COS(2.000000 * p);
          RETURN (makec(2.000000 * SIN(2.000000 * p) / t, (EXP( - 2.000000 * q) - EXP(2.000000 * q)) / t));
        END_IF;
      ef_subscript_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          str := v1;
          k := v2;
          RETURN (ctmv(str[k]));
        END_IF;
      ef_eq_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str = st2));
        END_IF;
      ef_ne_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str &lt;&gt; st2));
        END_IF;
      ef_gt_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str &gt; st2));
        END_IF;
      ef_lt_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str &lt; st2));
        END_IF;
      ef_ge_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str &gt;= st2));
        END_IF;
      ef_le_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          str := v1;
          st2 := v2;
          RETURN (ctmv(str &lt;= st2));
        END_IF;
      ef_subsequence_s:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) AND (&apos;INTEGER&apos; IN TYPEOF(v3)) THEN
          str := v1;
          j := v2;
          k := v3;
          RETURN (ctmv(str[j:k]));
        END_IF;
      ef_concat_s:
        BEGIN
          str := &apos;&apos;;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;STRING&apos; IN TYPEOF(vlist[i]) THEN
              st2 := vlist[i];
              str := str + st2;
              REMOVE(vlist, i);
            ELSE
              IF str &lt;&gt; &apos;&apos; THEN
                INSERT(vlist, ctmv(str), i);
                str := &apos;&apos;;
              END_IF;
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(str));
          END_IF;
          IF str &lt;&gt; &apos;&apos; THEN
            INSERT(vlist, ctmv(str), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_size_s:
        IF &apos;STRING&apos; IN TYPEOF(v1) THEN
          str := v1;
          RETURN (ctmv(LENGTH(str)));
        END_IF;
      ef_format:
        IF (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          RETURN (ctmv(FORMAT(v1, v2)));
        END_IF;
      ef_value:
        IF &apos;STRING&apos; IN TYPEOF(v1) THEN
          str := v1;
          RETURN (ctmv(VALUE(str)));
        END_IF;
      ef_like:
        IF (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
          RETURN (ctmv(v1 LIKE v2));
        END_IF;
      ef_subscript_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          k := v2;
          RETURN (ctmv(bin[k]));
        END_IF;
      ef_eq_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin = bi2));
        END_IF;
      ef_ne_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin &lt;&gt; bi2));
        END_IF;
      ef_gt_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin &gt; bi2));
        END_IF;
      ef_lt_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin &lt; bi2));
        END_IF;
      ef_ge_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin &gt;= bi2));
        END_IF;
      ef_le_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;BINARY&apos; IN TYPEOF(v2)) THEN
          bin := v1;
          bi2 := v2;
          RETURN (ctmv(bin &lt;= bi2));
        END_IF;
      ef_subsequence_b:
        IF (&apos;BINARY&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) AND (&apos;INTEGER&apos; IN TYPEOF(v3)) THEN
          bin := v1;
          j := v2;
          k := v3;
          RETURN (ctmv(bin[j:k]));
        END_IF;
      ef_concat_b:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;BINARY&apos; IN TYPEOF(vlist[i]) THEN
              IF boo THEN
                bi2 := vlist[i];
                bin := bin + bi2;
              ELSE
                bin := vlist[i];
                boo := TRUE;
              END_IF;
              REMOVE(vlist, i);
            ELSE
              IF boo THEN
                INSERT(vlist, ctmv(bin), i);
                boo := FALSE;
              END_IF;
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(bin));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(bin), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_size_b:
        IF &apos;BINARY&apos; IN TYPEOF(v1) THEN
          bin := v1;
          RETURN (ctmv(BLENGTH(bin)));
        END_IF;
      ef_subscript_t:
        IF (&apos;LIST&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          tpl := v1;
          k := v2;
          RETURN (ctmv(tpl[k]));
        END_IF;
      ef_eq_t:
        IF (&apos;LIST&apos; IN TYPEOF(v1)) AND (&apos;LIST&apos; IN TYPEOF(v2)) THEN
          lgc := equal_maths_values(v1, v2);
          IF lgc &lt;&gt; UNKNOWN THEN
            RETURN (ctmv(lgc));
          END_IF;
        END_IF;
      ef_ne_t:
        IF (&apos;LIST&apos; IN TYPEOF(v1)) AND (&apos;LIST&apos; IN TYPEOF(v2)) THEN
          lgc := equal_maths_values(v1, v2);
          IF lgc &lt;&gt; UNKNOWN THEN
            RETURN (ctmv(NOT lgc));
          END_IF;
        END_IF;
      ef_concat_t:
        BEGIN
          tpl := [];
          REPEAT i := SIZEOF(vlist) TO 1;
            IF &apos;STRING&apos; IN TYPEOF(vlist[i]) THEN
              tp2 := vlist[i];
              tpl := tpl + tp2;
              REMOVE(vlist, i);
            ELSE
              IF SIZEOF(tpl) &lt;&gt; 0 THEN
                INSERT(vlist, ctmv(tpl), i);
                tpl := [];
              END_IF;
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(tpl));
          END_IF;
          IF SIZEOF(tpl) &lt;&gt; 0 THEN
            INSERT(vlist, ctmv(tpl), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_size_t:
        IF &apos;LIST&apos; IN TYPEOF(v1) THEN
          tpl := v1;
          RETURN (ctmv(SIZEOF(tpl)));
        END_IF;
      ef_entuple:
        RETURN (ctmv(vlist));
      ef_detuple:
        IF &apos;LIST&apos; IN TYPEOF(v1) THEN
          tpl := v1;
          RETURN (ctmv(tpl[1]));
        END_IF;
      ef_insert:
        IF (&apos;LIST&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v3)) THEN
          tpl := v1;
          k := v3;
          INSERT(tpl, v2, k);
          RETURN (ctmv(tpl));
        END_IF;
      ef_remove:
        IF (&apos;LIST&apos; IN TYPEOF(v1)) AND (&apos;INTEGER&apos; IN TYPEOF(v2)) THEN
          tpl := v1;
          k := v2;
          REMOVE(tpl, k);
          RETURN (ctmv(tpl));
        END_IF;
      ef_sum_it:
        IF good_t(v1, &apos;INTEGER&apos;) THEN
          tpl := v1;
          j := 0;
          REPEAT i := 1 TO SIZEOF(tpl);
            j := j + tpl[i];
          END_REPEAT;
          RETURN (ctmv(j));
        END_IF;
      ef_product_it:
        IF good_t(v1, &apos;INTEGER&apos;) THEN
          tpl := v1;
          j := 1;
          REPEAT i := 1 TO SIZEOF(tpl);
            j := j * tpl[i];
          END_REPEAT;
          RETURN (ctmv(j));
        END_IF;
      ef_add_it:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF good_t(vlist[i], &apos;INTEGER&apos;) THEN
              IF NOT boo THEN
                tpl := vlist[i];
                boo := TRUE;
              ELSE
                tp2 := vlist[i];
                IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
                  RETURN (?);
                END_IF;
                REPEAT l := 1 TO SIZEOF(tpl);
                  tpl[j] := tpl[j] + tp2[j];
                END_REPEAT;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(tpl));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(tpl), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_it:
        IF good_t(v1, &apos;INTEGER&apos;) AND good_t(v2, &apos;INTEGER&apos;) THEN
          tpl := v1;
          tp2 := v2;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            tpl[i] := tpl[i] - tp2[i];
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_scalar_mult_it:
        IF (&apos;INTEGER&apos; IN TYPEOF(v1)) AND good_t(v2, &apos;INTEGER&apos;) THEN
          j := v1;
          tpl := v2;
          REPEAT i := 1 TO SIZEOF(tpl);
            tpl[i] := j * tpl[i];
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_dot_prod_it:
        IF good_t(v1, &apos;INTEGER&apos;) AND good_t(v2, &apos;INTEGER&apos;) THEN
          tpl := v1;
          tp2 := v2;
          j := 0;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            j := j + tpl[i] * tp2[i];
          END_REPEAT;
          RETURN (ctmv(j));
        END_IF;
      ef_sum_rt:
        IF good_t(v1, &apos;REAL&apos;) THEN
          tpl := v1;
          r := 0.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            r := r + tpl[i];
          END_REPEAT;
          RETURN (ctmv(r));
        END_IF;
      ef_product_rt:
        IF good_t(v1, &apos;REAL&apos;) THEN
          tpl := v1;
          r := 1.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            r := r * tpl[i];
          END_REPEAT;
          RETURN (ctmv(r));
        END_IF;
      ef_add_rt:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF good_t(vlist[i], &apos;REAL&apos;) THEN
              IF NOT boo THEN
                tpl := vlist[i];
                boo := TRUE;
              ELSE
                tp2 := vlist[i];
                IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
                  RETURN (?);
                END_IF;
                REPEAT l := 1 TO SIZEOF(tpl);
                  tpl[j] := tpl[j] + tp2[j];
                END_REPEAT;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(tpl));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(tpl), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_rt:
        IF good_t(v1, &apos;REAL&apos;) AND good_t(v2, &apos;REAL&apos;) THEN
          tpl := v1;
          tp2 := v2;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            tpl[i] := tpl[i] - tp2[i];
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_scalar_mult_rt:
        IF (&apos;REAL&apos; IN TYPEOF(v1)) AND good_t(v2, &apos;REAL&apos;) THEN
          r := v1;
          tpl := v2;
          REPEAT i := 1 TO SIZEOF(tpl);
            tpl[i] := r * tpl[i];
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_dot_prod_rt:
        IF good_t(v1, &apos;REAL&apos;) AND good_t(v2, &apos;REAL&apos;) THEN
          tpl := v1;
          tp2 := v2;
          r := 0;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            r := r + tpl[i] * tp2[i];
          END_REPEAT;
          RETURN (ctmv(r));
        END_IF;
      ef_norm_rt:
        IF good_t(v1, &apos;REAL&apos;) THEN
          tpl := v1;
          r := 0.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            r := r + tpl[i] * tpl[i];
          END_REPEAT;
          RETURN (ctmv(SQRT(r)));
        END_IF;
      ef_sum_ct:
        IF good_t(v1, cnlit) THEN
          tpl := v1;
          p := 0.000000;
          q := 0.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], r, s);
            p := p + r;
            q := q + s;
          END_REPEAT;
          RETURN (makec(p, q));
        END_IF;
      ef_product_ct:
        IF good_t(v1, cnlit) THEN
          tpl := v1;
          p := 1.000000;
          q := 0.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], r, s);
            p := p * r - q * s;
            q := p * s + q * r;
          END_REPEAT;
          RETURN (makec(p, q));
        END_IF;
      ef_add_ct:
        BEGIN
          boo := FALSE;
          REPEAT i := SIZEOF(vlist) TO 1;
            IF good_t(vlist[i], cnlit) THEN
              IF NOT boo THEN
                tpl := vlist[i];
                boo := TRUE;
              ELSE
                tp2 := vlist[i];
                IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
                  RETURN (?);
                END_IF;
                REPEAT l := 1 TO SIZEOF(tpl);
                  parts(tpl[j], p, q);
                  parts(tp2[j], r, s);
                  tpl[j] := makec(p + r, q + s);
                END_REPEAT;
              END_IF;
              REMOVE(vlist, i);
            END_IF;
          END_REPEAT;
          IF SIZEOF(vlist) = 0 THEN
            RETURN (ctmv(tpl));
          END_IF;
          IF boo THEN
            INSERT(vlist, ctmv(tpl), 0);
          END_IF;
          IF SIZEOF(vlist) = 1 THEN
            RETURN (vlist[1]);
          END_IF;
        END;
      ef_subtract_ct:
        IF good_t(v1, cnlit) AND good_t(v2, cnlit) THEN
          tpl := v1;
          tp2 := v2;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], p, q);
            parts(tp2[i], r, s);
            tpl[i] := makec(p - r, q - s);
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_scalar_mult_ct:
        IF (cnlit IN TYPEOF(v1)) AND good_t(v2, cnlit) THEN
          parts(v1, p, q);
          tpl := v2;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], r, s);
            tpl[i] := makec(p * r - q * s, p * s + q * r);
          END_REPEAT;
          RETURN (ctmv(tpl));
        END_IF;
      ef_dot_prod_ct:
        IF good_t(v1, cnlit) AND good_t(v2, cnlit) THEN
          tpl := v1;
          tp2 := v2;
          t := 0.000000;
          u := 0.000000;
          IF SIZEOF(tpl) &lt;&gt; SIZEOF(tp2) THEN
            RETURN (?);
          END_IF;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], p, q);
            parts(tp2[i], r, s);
            t := t + p * r + q * s;
            u := u + q * r - p * s;
          END_REPEAT;
          RETURN (makec(t, u));
        END_IF;
      ef_norm_ct:
        IF good_t(v1, cnlit) THEN
          tpl := v1;
          r := 0.000000;
          REPEAT i := 1 TO SIZEOF(tpl);
            parts(tpl[i], p, q);
            r := r + p * p + q * q;
          END_REPEAT;
          RETURN (ctmv(SQRT(r)));
        END_IF;
      ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t:
        IF &apos;LOGICAL&apos; IN TYPEOF(v1) THEN
          lgc := v1;
          IF lgc THEN
            RETURN (v2);
          ELSE
            RETURN (v3);
          END_IF;
        END_IF;
      ef_ensemble:
        RETURN (make_finite_space(mem + vlist));
      ef_member_of:
        IF schema_prefix + &apos;MATHS_SPACE&apos; IN TYPEOF(v2) THEN
          lgc := member_of(v1, v2);
          IF lgc &lt;&gt; UNKNOWN THEN
            RETURN (ctmv(lgc));
          END_IF;
        END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func, vlist));
  END_IF;
  IF &apos;ABSTRACTED_EXPRESSION_FUNCTION&apos; IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr, expr.func\quantifier_expression.variables, vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF &apos;FINITE_FUNCTION&apos; IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF(pairs);
      IF equal_maths_values(vlist[1], pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func, vlist));
  END_IF;
  RETURN (expr);
      </algorithm>
    </function>

    <function name="simplify_generic_expression">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <typename name="maths_value"/>
      <algorithm>
  FUNCTION restore_unary (VAR expr : unary_generic_expression; VAR opnd : generic_expression):generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;

  FUNCTION restore_binary (VAR expr : binary_generic_expression; VAR opd1 : generic_expression; VAR opd2 : generic_expression):generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;

  FUNCTION restore_mulary (VAR expr : multiple_arity_generic_expression; VAR ops : LIST OF generic_expression):generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;

  FUNCTION make_number_literal (VAR nmb : NUMBER):generic_literal;
    IF &apos;INTEGER&apos; IN TYPEOF(nmb) THEN
      RETURN (make_int_literal(nmb));
    END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;

  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    v1 : maths_value;
    v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1 : generic_expression;
    op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n : INTEGER;
    m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;

  IF &apos;INT_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\int_literal.the_value));
  END_IF;
  IF &apos;REAL_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\real_literal.the_value));
  END_IF;
  IF &apos;BOOLEAN_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\boolean_literal.the_value));
  END_IF;
  IF &apos;STRING_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\string_literal.the_value));
  END_IF;
  IF &apos;COMPLEX_NUMBER_LITERAL&apos; IN types THEN
    RETURN (expr);
  END_IF;
  IF &apos;LOGICAL_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\logical_literal.lit_value));
  END_IF;
  IF &apos;BINARY_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\binary_literal.lit_value));
  END_IF;
  IF &apos;MATHS_ENUM_LITERAL&apos; IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF &apos;REAL_TUPLE_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\real_tuple_literal.lit_value));
  END_IF;
  IF &apos;INTEGER_TUPLE_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\integer_tuple_literal.lit_value));
  END_IF;
  IF &apos;ATOM_BASED_LITERAL&apos; IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF &apos;MATHS_TUPLE_LITERAL&apos; IN types THEN
    RETURN (convert_to_maths_value(expr\maths_tuple_literal.lit_value));
  END_IF;
  IF &apos;MATHS_SPACE&apos; IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  IF &apos;FUNCTION_APPLICATION&apos; IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  IF &apos;UNARY_GENERIC_EXPRESSION&apos; IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF &apos;BINARY_GENERIC_EXPRESSION&apos; IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF &apos;MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT(vlist, v1, i - 1);
      INSERT(oplist, convert_to_operand(v1), i - 1);
    END_REPEAT;
  END_IF;
  IF &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN types THEN
    v1 := vlist[1];
    n := SIZEOF(vlist);
    finfun := vlist[n];
    REMOVE(vlist, n);
    REMOVE(vlist, 1);
    RETURN (make_parallel_composed_function(v1, vlist, finfun));
  END_IF;
  IF (&apos;ABS_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(ABS(v1)));
  END_IF;
  IF (&apos;ACOS_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(ACOS(v1)));
  END_IF;
  IF &apos;AND_EXPRESSION&apos; IN types THEN
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;BOOLEAN&apos; IN TYPEOF(vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN
          RETURN (convert_to_maths_value(FALSE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(TRUE));
    END_IF;
    IF SIZEOF(oplist) = 1 THEN
      RETURN (oplist[1]);
    END_IF;
  END_IF;
  IF (&apos;ASIN_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(ASIN(v1)));
  END_IF;
  IF (&apos;ATAN_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(ATAN(v1, v2)));
  END_IF;
  IF (&apos;COMPARISON_EXPRESSION&apos; IN types) AND ((&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) OR (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) OR (&apos;BOOLEAN&apos; IN TYPEOF(v1)) AND (&apos;BOOLEAN&apos; IN TYPEOF(v2))) THEN
    IF &apos;COMPARISON_EQUAL&apos; IN types THEN
      boo := bool(v1 = v2);
    ELSE
      IF &apos;COMPARISON_GREATER&apos; IN types THEN
        boo := bool(v1 &gt; v2);
      ELSE
        IF &apos;COMPARISON_GREATER_EQUAL&apos; IN types THEN
          boo := bool(v1 &gt;= v2);
        ELSE
          IF &apos;COMPARISON_LESS&apos; IN types THEN
            boo := bool(v1 &lt; v2);
          ELSE
            IF &apos;COMPARISON_LESS_EQUAL&apos; IN types THEN
              boo := bool(v1 &lt;= v2);
            ELSE
              IF &apos;COMPARISON_NOT_EQUAL&apos; IN types THEN
                boo := bool(v1 &lt;&gt; v2);
              ELSE
                IF &apos;LIKE_EXPRESSION&apos; IN types THEN
                  boo := bool(v1 LIKE v2);
                ELSE
                  RETURN (?);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN (convert_to_maths_value(boo));
  END_IF;
  IF &apos;CONCAT_EXPRESSION&apos; IN types THEN
    str := &apos;&apos;;
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;STRING&apos; IN TYPEOF(vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE(oplist, i);
      ELSE
        IF LENGTH(str) &gt; 0 THEN
          INSERT(oplist, make_string_literal(str), i);
          str := &apos;&apos;;
        END_IF;
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(str));
    END_IF;
    IF LENGTH(str) &gt; 0 THEN
      INSERT(oplist, make_string_literal(str), 0);
    END_IF;
    IF SIZEOF(oplist) = 1 THEN
      RETURN (oplist[1]);
    END_IF;
  END_IF;
  IF (&apos;COS_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(COS(v1)));
  END_IF;
  IF (&apos;DIV_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1 DIV v2));
  END_IF;
  IF &apos;EQUALS_EXPRESSION&apos; IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value(opnds[1] :=: opnds[2]));
  END_IF;
  IF (&apos;EXP_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(EXP(v1)));
  END_IF;
  IF (&apos;FORMAT_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;STRING&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(FORMAT(v1, v2)));
  END_IF;
  IF (&apos;INDEX_EXPRESSION&apos; IN types) AND (&apos;STRING&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    str := v1;
    n := v2;
    RETURN (convert_to_maths_value(str[n]));
  END_IF;
  IF (&apos;INT_VALUE_EXPRESSION&apos; IN types) AND (&apos;STRING&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF &apos;INTERVAL_EXPRESSION&apos; IN types THEN
    str := &apos;&apos;;
    IF &apos;NUMBER&apos; IN TYPEOF(vlist[1]) THEN
      str := &apos;NUMBER&apos;;
    END_IF;
    IF &apos;STRING&apos; IN TYPEOF(vlist[1]) THEN
      str := &apos;STRING&apos;;
    END_IF;
    IF &apos;BOOLEAN&apos; IN TYPEOF(vlist[1]) THEN
      str := &apos;BOOLEAN&apos;;
    END_IF;
    IF (LENGTH(str) &gt; 0) AND (str IN TYPEOF(vlist[2])) AND (str IN TYPEOF(vlist[3])) THEN
      RETURN (convert_to_maths_value({ &lt;=  &lt;= }));
    END_IF;
  END_IF;
  IF (&apos;LENGTH_EXPRESSION&apos; IN types) AND (&apos;STRING&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(LENGTH(v1)));
  END_IF;
  IF (&apos;LOG_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(LOG(v1)));
  END_IF;
  IF (&apos;LOG10_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(LOG10(v1)));
  END_IF;
  IF (&apos;LOG2_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(LOG2(v1)));
  END_IF;
  IF &apos;MAXIMUM_EXPRESSION&apos; IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;NUMBER&apos; IN TYPEOF(vlist[i]) THEN
        IF boo THEN
          IF nmb &lt; vlist[i] THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(nmb));
    END_IF;
    IF boo THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF &apos;MINIMUM_EXPRESSION&apos; IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;NUMBER&apos; IN TYPEOF(vlist[i]) THEN
        IF boo THEN
          IF nmb &gt; vlist[i] THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := TRUE;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(nmb));
    END_IF;
    IF boo THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF (&apos;MINUS_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1 - v2));
  END_IF;
  IF (&apos;MOD_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1 MOD v2));
  END_IF;
  IF &apos;MULT_EXPRESSION&apos; IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;NUMBER&apos; IN TYPEOF(vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(nmb));
    END_IF;
    IF nmb &lt;&gt; 1 THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1 THEN
      RETURN (oplist[1]);
    END_IF;
  END_IF;
  IF (&apos;NOT_EXPRESSION&apos; IN types) AND (&apos;BOOLEAN&apos; IN TYPEOF(v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value(NOT boo));
  END_IF;
  IF (&apos;ODD_EXPRESSION&apos; IN types) AND (&apos;INTEGER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(ODD(v1)));
  END_IF;
  IF &apos;OR_EXPRESSION&apos; IN types THEN
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;BOOLEAN&apos; IN TYPEOF(vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN
          RETURN (convert_to_maths_value(TRUE));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(FALSE));
    END_IF;
    IF SIZEOF(oplist) = 1 THEN
      RETURN (oplist[1]);
    END_IF;
  END_IF;
  IF &apos;PLUS_EXPRESSION&apos; IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF(vlist) TO 1;
      IF &apos;NUMBER&apos; IN TYPEOF(vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0 THEN
      RETURN (convert_to_maths_value(nmb));
    END_IF;
    IF nmb &lt;&gt; 0 THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1 THEN
      RETURN (oplist[1]);
    END_IF;
  END_IF;
  IF (&apos;POWER_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1**v2));
  END_IF;
  IF (&apos;SIN_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(SIN(v1)));
  END_IF;
  IF (&apos;SLASH_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) AND (&apos;NUMBER&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1 / v2));
  END_IF;
  IF (&apos;SQUARE_ROOT_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(SQRT(v1)));
  END_IF;
  IF (&apos;SUBSTRING_EXPRESSION&apos; IN types) AND (&apos;STRING&apos; IN TYPEOF(vlist[1])) AND (&apos;NUMBER&apos; IN TYPEOF(vlist[2])) AND (&apos;NUMBER&apos; IN TYPEOF(vlist[3])) THEN
    str := vlist[1];
    n := vlist[2];
    m := vlist[3];
    RETURN (convert_to_maths_value(str[n:m]));
  END_IF;
  IF (&apos;TAN_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(TAN(v1)));
  END_IF;
  IF (&apos;UNARY_MINUS_EXPRESSION&apos; IN types) AND (&apos;NUMBER&apos; IN TYPEOF(v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value( - nmb));
  END_IF;
  IF (&apos;VALUE_EXPRESSION&apos; IN types) AND (&apos;STRING&apos; IN TYPEOF(v1)) THEN
    RETURN (convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF (&apos;XOR_EXPRESSION&apos; IN types) AND (&apos;BOOLEAN&apos; IN TYPEOF(v1)) AND (&apos;BOOLEAN&apos; IN TYPEOF(v2)) THEN
    RETURN (convert_to_maths_value(v1 XOR v2));
  END_IF;
  IF &apos;UNARY_GENERIC_EXPRESSION&apos; IN types THEN
    RETURN (restore_unary(expr, op1));
  END_IF;
  IF &apos;BINARY_GENERIC_EXPRESSION&apos; IN types THEN
    RETURN (restore_binary(expr, op1, op2));
  END_IF;
  IF &apos;MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN types THEN
    RETURN (restore_mulary(expr, oplist));
  END_IF;
  RETURN (expr);
      </algorithm>
    </function>

    <function name="simplify_maths_space">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="maths_space"/>
      <algorithm>
  LOCAL
    stypes : SET OF STRING := stripped_typeof(spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint : INTEGER;
    zmin : INTEGER;
    zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;

  IF &apos;FINITE_SPACE&apos; IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF(sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND (&apos;INTEGER&apos; IN TYPEOF(zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint &lt; zmin THEN
            zmin := zint;
          END_IF;
          IF zint &gt; zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax - zmin + 1) THEN
      RETURN (make_finite_integer_interval(zmin, zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF &apos;UNIFORM_PRODUCT_SPACE&apos; IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc, spc\uniform_product_space.exponent));
  END_IF;
  IF &apos;LISTED_PRODUCT_SPACE&apos; IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      INSERT(zfactors, simplify_maths_space(factors[i]), i - 1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc, rspc));
  END_IF;
  IF &apos;FUNCTION_SPACE&apos; IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint, zspc, spc\function_space.range_constraint, rspc));
  END_IF;
  RETURN (spc);
      </algorithm>
    </function>

    <function name="simplify_maths_value">
      <parameter name="val"
        varying="YES">
        <typename name="maths_value"/>
      </parameter>
      <typename name="maths_value"/>
      <algorithm>
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;

  IF &apos;GENERIC_EXPRESSION&apos; IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF &apos;LIST&apos; IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF(vlist);
      INSERT(nlist, simplify_maths_value(vlist[i]), i - 1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
      </algorithm>
    </function>

    <function name="singleton_member_of">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <typename name="maths_value"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;

  IF &apos;FINITE_SPACE&apos; IN types THEN
    IF SIZEOF(spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF &apos;FINITE_INTEGER_INTERVAL&apos; IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="space_dimension">
      <parameter name="tspace"
        varying="YES">
        <typename name="tuple_space"/>
      </parameter>
      <typename name="nonnegative_integer"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(tspace);
  END_LOCAL;

  IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF schema_prefix + &apos;LISTED_PRODUCT_SPACE&apos; IN types THEN
    RETURN (SIZEOF(tspace\listed_product_space.factors));
  END_IF;
  IF schema_prefix + &apos;EXTENDED_TUPLE_SPACE&apos; IN types THEN
    RETURN (space_dimension(tspace\extended_tuple_space.base));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="space_is_continuum">
      <parameter name="space"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF(space);
    factors : LIST OF maths_space;
  END_LOCAL;

  IF NOT EXISTS(space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space, es_reals) OR subspace_of_es(space, es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF schema_prefix + &apos;UNIFORM_PRODUCT_SPACE&apos; IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF schema_prefix + &apos;LISTED_PRODUCT_SPACE&apos; IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF(factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="space_is_singleton">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;

  IF &apos;FINITE_SPACE&apos; IN types THEN
    RETURN (bool(SIZEOF(spc\finite_space.members) = 1));
  END_IF;
  IF &apos;FINITE_INTEGER_INTERVAL&apos; IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="stripped_typeof">
      <parameter name="arg"
        varying="YES">
        <builtintype type="GENERIC"
          typelabel="g"
        />
      </parameter>
      <aggregate type="SET"
      />
      <builtintype type="STRING"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF(arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH(schema_prefix);
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(types);
    IF types[i][1:n] = schema_prefix THEN
      stypes := ;
    ELSE
      stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
      </algorithm>
    </function>

    <function name="subspace_of">
      <parameter name="space1"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="space2"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof(spc1);
    types2 : SET OF STRING := stripped_typeof(spc2);
    lgcl : LOGICAL;
    cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1 : REAL;
    bnd2 : REAL;
    n : INTEGER;
    sp1 : maths_space;
    sp2 : maths_space;
    prgn1 : polar_complex_number_region;
    prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;

  IF NOT EXISTS(spc1) OR NOT EXISTS(spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;ELEMENTARY_SPACE&apos; IN types1 THEN
    IF NOT (&apos;ELEMENTARY_SPACE&apos; IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    CASE spc1\elementary_space.space_id OF 
      es_numbers:
        RETURN (FALSE);
      es_complex_numbers:
        RETURN (es_val = es_numbers);
      es_reals:
        RETURN (es_val = es_numbers);
      es_integers:
        RETURN (es_val = es_numbers);
      es_logicals:
        RETURN (FALSE);
      es_booleans:
        RETURN (es_val = es_logicals);
      es_strings:
        RETURN (FALSE);
      es_binarys:
        RETURN (FALSE);
      es_maths_spaces:
        RETURN (FALSE);
      es_maths_functions:
        RETURN (FALSE);
      es_generics:
        RETURN (FALSE);
    END_CASE;
    RETURN (UNKNOWN);
  END_IF;
  IF &apos;FINITE_INTEGER_INTERVAL&apos; IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of(i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF &apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min &gt;= spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;INTEGER_INTERVAL_TO_MAX&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF &apos;INTEGER_INTERVAL_TO_MAX&apos; IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max &lt;= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FINITE_REAL_INTERVAL&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF (&apos;FINITE_REAL_INTERVAL&apos; IN types2) OR (&apos;REAL_INTERVAL_FROM_MIN&apos; IN types2) OR (&apos;REAL_INTERVAL_TO_MAX&apos; IN types2) THEN
      IF min_exists(spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min(spc2);
        IF (bnd1 &lt; bnd2) OR (bnd1 = bnd2) AND min_included(spc1) AND NOT min_included(spc2) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists(spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max(spc2);
        IF (bnd1 &gt; bnd2) OR (bnd1 = bnd2) AND max_included(spc1) AND NOT max_included(spc2) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;REAL_INTERVAL_FROM_MIN&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF &apos;REAL_INTERVAL_FROM_MIN&apos; IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 &lt; bnd1) OR (bnd2 = bnd1) AND (min_included(spc2) OR NOT min_included(spc1)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;REAL_INTERVAL_TO_MAX&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF &apos;REAL_INTERVAL_TO_MAX&apos; IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 &gt; bnd1) OR (bnd2 = bnd1) AND (max_included(spc2) OR NOT max_included(spc1)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint, spc2\cartesian_complex_number_region.real_constraint) AND subspace_of(spc1\cartesian_complex_number_region.imag_constraint, spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1, spc2\polar_complex_number_region.centre), spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF &apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1), spc2));
    END_IF;
    IF &apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max &gt; PI THEN
          aitv := make_finite_real_interval( - PI, open, prgn2.direction_constraint.max - 2.000000 * PI, prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND (subspace_of(prgn1.direction_constraint, prgn2.direction_constraint) OR subspace_of(prgn1.direction_constraint, aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FINITE_SPACE&apos; IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF(spc1\finite_space.members);
      cum := cum AND member_of(spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF &apos;PRODUCT_SPACE&apos; IN types1 THEN
    IF &apos;PRODUCT_SPACE&apos; IN types2 THEN
      IF space_dimension(spc1) = space_dimension(spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types2 THEN
      IF space_dimension(spc1) &gt;= space_dimension(spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types1 THEN
    IF &apos;EXTENDED_TUPLE_SPACE&apos; IN types2 THEN
      n := space_dimension(spc1);
      IF n &lt; space_dimension(spc2) THEN
        n := space_dimension(spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n + 1;
        cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF &apos;FUNCTION_SPACE&apos; IN types1 THEN
    IF &apos;ELEMENTARY_SPACE&apos; IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF &apos;FUNCTION_SPACE&apos; IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF 
        sc_equal:
          BEGIN
            CASE spc2\function_space.domain_constraint OF 
              sc_equal:
                cum := cum AND equal_maths_spaces(sp1, sp2);
              sc_subspace:
                cum := cum AND subspace_of(sp1, sp2);
              sc_member:
                cum := cum AND member_of(sp1, sp2);
              sc_subspace:
                BEGIN
                  CASE spc2\function_space.domain_constraint OF 
                    sc_equal:
                      RETURN (FALSE);
                    sc_subspace:
                      cum := cum AND subspace_of(sp1, sp2);
                    sc_member:
                      BEGIN
                        IF NOT member_of(sp1, sp2) THEN
                          RETURN (FALSE);
                        END_IF;
                        cum := UNKNOWN;
                      END;
                    sc_member:
                      BEGIN
                        CASE spc2\function_space.domain_constraint OF 
                          sc_equal:
                            cum := cum AND space_is_singleton(sp1) AND equal_maths_spaces(singleton_member_of(sp1), sp2);
                          sc_subspace:
                            BEGIN
                              IF NOT member_of(sp2, sp1) THEN
                                RETURN (FALSE);
                              END_IF;
                              cum := UNKNOWN;
                            END;
                          sc_member:
                            cum := cum AND subspace_of(sp1, sp2);
                        END_CASE;
                      END;
                  END_CASE;
                END;
            END_CASE;
          END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF 
        sc_equal:
          BEGIN
            CASE spc2\function_space.range_constraint OF 
              sc_equal:
                cum := cum AND equal_maths_spaces(sp1, sp2);
              sc_subspace:
                cum := cum AND subspace_of(sp1, sp2);
              sc_member:
                cum := cum AND member_of(sp1, sp2);
              sc_subspace:
                BEGIN
                  CASE spc2\function_space.domain_constraint OF 
                    sc_equal:
                      RETURN (FALSE);
                    sc_subspace:
                      cum := cum AND subspace_of(sp1, sp2);
                    sc_member:
                      BEGIN
                        IF NOT member_of(sp1, sp2) THEN
                          RETURN (FALSE);
                        END_IF;
                        cum := UNKNOWN;
                      END;
                    sc_member:
                      BEGIN
                        CASE spc2\function_space.domain_constraint OF 
                          sc_equal:
                            cum := cum AND space_is_singleton(sp1) AND equal_maths_spaces(singleton_member_of(sp1), sp2);
                          sc_subspace:
                            BEGIN
                              IF NOT member_of(sp2, sp1) THEN
                                RETURN (FALSE);
                              END_IF;
                              cum := UNKNOWN;
                            END;
                          sc_member:
                            cum := cum AND subspace_of(sp1, sp2);
                        END_CASE;
                      END;
                  END_CASE;
                END;
            END_CASE;
          END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  RETURN (UNKNOWN);
      </algorithm>
    </function>

    <function name="subspace_of_es">
      <parameter name="spc"
        varying="YES">
        <typename name="maths_space"/>
      </parameter>
      <parameter name="es"
        varying="YES">
        <typename name="elementary_space_enumerators"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;

  IF NOT EXISTS(spc) OR NOT EXISTS(es) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;ELEMENTARY_SPACE&apos; IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id, es));
  END_IF;
  IF &apos;FINITE_SPACE&apos; IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members, es));
  END_IF;
  CASE es OF 
    es_numbers:
      RETURN ((&apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (&apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types) OR (&apos;INTEGER_INTERVAL_TO_MAX&apos; IN types) OR (&apos;FINITE_REAL_INTERVAL&apos; IN types) OR (&apos;REAL_INTERVAL_FROM_MIN&apos; IN types) OR (&apos;REAL_INTERVAL_TO_MAX&apos; IN types) OR (&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types) OR (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types));
    es_complex_numbers:
      RETURN ((&apos;CARTESIAN_COMPLEX_NUMBER_REGION&apos; IN types) OR (&apos;POLAR_COMPLEX_NUMBER_REGION&apos; IN types));
    es_reals:
      RETURN ((&apos;FINITE_REAL_INTERVAL&apos; IN types) OR (&apos;REAL_INTERVAL_FROM_MIN&apos; IN types) OR (&apos;REAL_INTERVAL_TO_MAX&apos; IN types));
    es_integers:
      RETURN ((&apos;FINITE_INTEGER_INTERVAL&apos; IN types) OR (&apos;INTEGER_INTERVAL_FROM_MIN&apos; IN types) OR (&apos;INTEGER_INTERVAL_TO_MAX&apos; IN types));
    es_logicals:
      RETURN (FALSE);
    es_booleans:
      RETURN (FALSE);
    es_strings:
      RETURN (FALSE);
    es_binarys:
      RETURN (FALSE);
    es_maths_spaces:
      RETURN (FALSE);
    es_maths_functions:
      RETURN (&apos;FUNCTION_SPACE&apos; IN types);
    es_generics:
      RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
      </algorithm>
    </function>

    <function name="substitute">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <parameter name="vars"
        varying="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="generic_variable"/>
      </parameter>
      <parameter name="vals"
        varying="YES">
        <aggregate type="LIST"
          lower="1"
          upper="?"
        />
        <typename name="maths_value"/>
      </parameter>
      <typename name="generic_expression"/>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1 : generic_expression;
    op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;

  IF SIZEOF(vars) &lt;&gt; SIZEOF(vals) THEN
    RETURN (?);
  END_IF;
  IF &apos;GENERIC_LITERAL&apos; IN types THEN
    RETURN (expr);
  END_IF;
  IF &apos;GENERIC_VARIABLE&apos; IN types THEN
    REPEAT i := 1 TO SIZEOF(vars);
      IF expr :=: vars[i] THEN
        RETURN (vals[i]);
      END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF &apos;QUANTIFIER_EXPRESSION&apos; IN types THEN
    qvars := expr\quantifier_expression.variables;
    REPEAT i := SIZEOF(vars) TO 1;
      IF vars[i] IN qvars THEN
        REMOVE(vars, i);
        REMOVE(vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
      END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF &apos;UNARY_GENERIC_EXPRESSION&apos; IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
  END_IF;
  IF &apos;BINARY_GENERIC_EXPRESSION&apos; IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
  END_IF;
  IF &apos;PARALLEL_COMPOSED_FUNCTION&apos; IN types THEN
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom, vars, vals);
    REPEAT i := 1 TO SIZEOF(prpfun);
      prpfun[i] := substitute(prpfun[i], vars, vals);
    END_REPEAT;
    IF &apos;MATHS_FUNCTION&apos; IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun, vars, vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom, prpfun, finfun));
  END_IF;
  IF &apos;MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
    END_REPEAT;
  END_IF;
  RETURN (expr);
      </algorithm>
    </function>

    <function name="using_items">
      <parameter name="item"
        varying="YES">
        <typename name="founded_item_select"/>
      </parameter>
      <parameter name="checked_items"
        varying="YES">
        <aggregate type="SET"
        />
        <typename name="founded_item_select"/>
      </parameter>
      <aggregate type="SET"
      />
      <typename name="founded_item_select"/>
      <algorithm>
  LOCAL
    new_check_items : SET OF founded_item_select;
    result_items : SET OF founded_item_select;
    next_items : SET OF founded_item_select;
  END_LOCAL;

  result_items := [];
  new_check_items := checked_items + item;
  next_items := QUERY(z &lt;* bag_to_set(USEDIN(item, &apos;&apos;)) | (&apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION_ITEM&apos; IN TYPEOF(z)) OR (&apos;FUNCTIONAL_DATA_MIM_LF.FOUNDED_ITEM&apos; IN TYPEOF(z)));
  IF SIZEOF(next_items) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] + using_items(next_items[i], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (result_items);
      </algorithm>
    </function>

    <function name="using_representations">
      <parameter name="item"
        varying="YES">
        <typename name="founded_item_select"/>
      </parameter>
      <aggregate type="SET"
      />
      <typename name="representation"/>
      <algorithm>
  LOCAL
    results : SET OF representation;
    result_bag : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;

  results := [];
  result_bag := USEDIN(item, &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION.ITEMS&apos;);
  IF SIZEOF(result_bag) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  intermediate_items := using_items(item, []);
  IF SIZEOF(intermediate_items) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i], &apos;FUNCTIONAL_DATA_MIM_LF.REPRESENTATION.ITEMS&apos;);
      IF SIZEOF(result_bag) &gt; 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (results);
      </algorithm>
    </function>

    <function name="valid_basis_curve_in_2d_wireframe">
      <parameter name="crv"
        varying="YES">
        <typename name="curve"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.POLYLINE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.B_SPLINE_CURVE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.ELLIPSE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.CIRCLE&apos;] * TYPEOF(crv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF &apos;FUNCTIONAL_DATA_MIM_LF.TRIMMED_CURVE&apos; IN TYPEOF(crv) THEN
      IF SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.LINE&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.PARABOLA&apos;, &apos;FUNCTIONAL_DATA_MIM_LF.HYPERBOLA&apos;] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1 THEN
        RETURN (TRUE);
      ELSE
        RETURN (valid_basis_curve_in_2d_wireframe(crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      IF &apos;FUNCTIONAL_DATA_MIM_LF.OFFSET_CURVE_2D&apos; IN TYPEOF(crv) THEN
        RETURN (valid_basis_curve_in_2d_wireframe(crv\offset_curve_2d.basis_curve));
      ELSE
        IF &apos;FUNCTIONAL_DATA_MIM_LF.CURVE_REPLICA&apos; IN TYPEOF(crv) THEN
          RETURN (valid_basis_curve_in_2d_wireframe(crv\curve_replica.parent_curve));
        ELSE
          IF &apos;FUNCTIONAL_DATA_MIM_LF.COMPOSITE_CURVE&apos; IN TYPEOF(crv) THEN
            RETURN (SIZEOF(QUERY(ccs &lt;* crv\composite_curve.segments | NOT valid_basis_curve_in_2d_wireframe(ccs.parent_curve))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="valid_calendar_date">
      <parameter name="date"
        varying="YES">
        <typename name="calendar_date"/>
      </parameter>
      <builtintype type="LOGICAL"
      />
      <algorithm>
  CASE date.month_component OF 
    1:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    2:
      BEGIN
        IF leap_year(date.year_component) THEN
          RETURN ({1 &lt;= date.day_component &lt;= 29});
        ELSE
          RETURN ({1 &lt;= date.day_component &lt;= 28});
        END_IF;
      END;
    3:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    4:
      RETURN ({1 &lt;= date.day_component &lt;= 30});
    5:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    6:
      RETURN ({1 &lt;= date.day_component &lt;= 30});
    7:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    8:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    9:
      RETURN ({1 &lt;= date.day_component &lt;= 30});
    10:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
    11:
      RETURN ({1 &lt;= date.day_component &lt;= 30});
    12:
      RETURN ({1 &lt;= date.day_component &lt;= 31});
  END_CASE;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="valid_measure_value">
      <parameter name="m"
        varying="YES">
        <typename name="measure_value"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF &apos;REAL&apos; IN TYPEOF(m) THEN
    RETURN (m &gt; 0.000000);
  ELSE
    IF &apos;INTEGER&apos; IN TYPEOF(m) THEN
      RETURN (m &gt; 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
      </algorithm>
    </function>

    <function name="valid_units">
      <parameter name="m"
        varying="YES">
        <typename name="measure_with_unit"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF &apos;FUNCTIONAL_DATA_MIM_LF.LENGTH_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.MASS_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.TIME_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.ELECTRIC_CURRENT_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.CELSIUS_TEMPERATURE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.LUMINOUS_INTENSITY_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.PLANE_ANGLE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.SOLID_ANGLE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.AREA_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(2.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.VOLUME_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(3.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.RATIO_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.POSITIVE_LENGTH_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(1.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;FUNCTIONAL_DATA_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE&apos; IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) &lt;&gt; dimensional_exponents(0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
      </algorithm>
    </function>

    <function name="values_space_of">
      <parameter name="expr"
        varying="YES">
        <typename name="generic_expression"/>
      </parameter>
      <typename name="maths_space"/>
      <algorithm>
  LOCAL
    e_prefix : STRING := &apos;FUNCTIONAL_DATA_MIM_LF.&apos;;
    typenames : SET OF STRING := TYPEOF(expr);
  END_LOCAL;

  IF schema_prefix + &apos;MATHS_VARIABLE&apos; IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF e_prefix + &apos;EXPRESSION&apos; IN typenames THEN
    IF e_prefix + &apos;NUMERIC_EXPRESSION&apos; IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF e_prefix + &apos;INT_LITERAL&apos; IN typenames THEN
          RETURN (make_finite_space([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF e_prefix + &apos;REAL_LITERAL&apos; IN typenames THEN
          RETURN (make_finite_space([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF e_prefix + &apos;BOOLEAN_EXPRESSION&apos; IN typenames THEN
      IF e_prefix + &apos;BOOLEAN_LITERAL&apos; IN typenames THEN
        RETURN (make_finite_space([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF e_prefix + &apos;STRING_EXPRESSION&apos; IN typenames THEN
      IF e_prefix + &apos;STRING_LITERAL&apos; IN typenames THEN
        RETURN (make_finite_space([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);
  END_IF;
  IF schema_prefix + &apos;MATHS_FUNCTION&apos; IN typenames THEN
    IF expression_is_constant(expr) THEN
      RETURN (make_finite_space([expr]));
    ELSE
      RETURN (make_function_space(sc_equal, expr\maths_function.domain, sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF schema_prefix + &apos;FUNCTION_APPLICATION&apos; IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF schema_prefix + &apos;MATHS_SPACE&apos; IN typenames THEN
    IF expression_is_constant(expr) THEN
      RETURN (make_finite_space([expr]));
    ELSE
      RETURN (make_elementary_space(es_maths_spaces));
    END_IF;
  END_IF;
  IF schema_prefix + &apos;DEPENDENT_VARIABLE_DEFINITION&apos; IN typenames THEN
    RETURN (values_space_of(expr\unary_generic_expression.operand));
  END_IF;
  IF schema_prefix + &apos;COMPLEX_NUMBER_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr]));
  END_IF;
  IF schema_prefix + &apos;LOGICAL_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\logical_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;BINARY_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\binary_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;MATHS_ENUM_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;REAL_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;INTEGER_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;ATOM_BASED_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\atom_based_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;MATHS_TUPLE_LITERAL&apos; IN typenames THEN
    RETURN (make_finite_space([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF schema_prefix + &apos;PARTIAL_DERIVATIVE_EXPRESSION&apos; IN typenames THEN
    RETURN (drop_numeric_constraints(values_space_of(expr\partial_derivative_expression.derivand)));
  END_IF;
  IF schema_prefix + &apos;DEFINITE_INTEGRAL_EXPRESSION&apos; IN typenames THEN
    RETURN (drop_numeric_constraints(values_space_of(expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);
      </algorithm>
    </function>

    <function name="version_assignment_is_valid">
      <parameter name="aia"
        varying="YES">
        <typename name="applied_identification_assignment"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    item : identification_item;
    role : identification_role;
  END_LOCAL;

  role := aia.role;
  IF role.name = &apos;version&apos; THEN
    REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items);
      item := aia.items[i];
      IF SIZEOF([&apos;FUNCTIONAL_DATA_MIM_LF.&apos; + &apos;VERSIONABLE_ITEM&apos;] * TYPEOF(item)) = 0 THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  ELSE
    RETURN (TRUE);
  END_IF;
      </algorithm>
    </function>

    <rule name="compatible_dimension"
      appliesto="cartesian_point direction representation_context geometric_representation_context">
      <where
        label="wr1"
        expression="SIZEOF(QUERY(x &lt;* cartesian_point | SIZEOF(QUERY(y &lt;* geometric_representation_context | item_in_context(x, y) AND (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF(QUERY(y &lt;* geometric_representation_context | item_in_context(x, y) AND (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) = 0">
      </where>
    </rule>

    <rule name="version_assignments_are_valid"
      appliesto="applied_identification_assignment">
      <where
        label="wr1"
        expression="SIZEOF(QUERY(aia &lt;* applied_identification_assignment | NOT version_assignment_is_valid(aia))) = 0">
      </where>
    </rule>

  </schema>

</express>