<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-01-24T12:02:40" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="functional_decomposition_to_design_mim schema_instance"/>
   <schema name="Functional_decomposition_to_design_mim">
      <interface kind="use" schema="Characteristic_mim"/>
      <interface kind="use" schema="Design_management_mim"/>
      <interface kind="use" schema="Network_functional_design_view_mim"/>
      <interface kind="use" schema="Physical_unit_design_view_mim"/>
      <rule name="design_functional_unit_allocation_to_assembly_component_constraint" appliesto="product_definition_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) AND ( NOT ( ( pdr . relating_product_definition \ product_definition . description = 'design definition path' ) AND ( pdr . relating_product_definition . id = 'design composition path' ) ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) AND ( NOT ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_DEFINITION' IN TYPEOF ( pdr . related_product_definition ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="design_functional_unit_allocation_to_assembly_component_unique_constraint" appliesto="product_definition_relationship">
         <algorithm> LOCAL dfuatac : BAG OF product_definition_relationship := QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) ) ; cd_bag : BAG OF component_definition := [ ] ; pdr_bag : BAG OF product_definition_relationship ; pass : BOOLEAN := TRUE ; id_bag : BAG OF STRING ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( dfuatac ) by 1 ; IF EXISTS ( dfuatac [ i ] . related_product_definition ) THEN IF ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_DEFINITION' IN TYPEOF ( dfuatac [ i ] . related_product_definition ) ) THEN IF ( NOT ( dfuatac [ i ] . related_product_definition IN cd_bag ) ) THEN cd_bag := cd_bag + dfuatac [ i ] . related_product_definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( cd_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdr_bag := QUERY ( pdr &lt;* dfuatac | ( pdr . related_product_definition :=: cd_bag [ i ] ) ) ; id_bag := [ ] ; REPEAT j := 1 to SIZEOF ( pdr_bag ) by 1 ; IF EXISTS ( pdr_bag [ j ] . id ) THEN IF ( pdr_bag [ j ] . id IN id_bag ) THEN pass := FALSE ; ESCAPE ; ELSE id_bag := id_bag + pdr_bag [ j ] . id ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="reference_composition_path_constraint" appliesto="product_definition_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference composition path' ) AND NOT ( ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF ( pdr . relating_product_definition ) ) AND ( pdr . relating_product_definition \ product_definition . description = 'reference definition path' ) AND ( pdr . relating_product_definition . frame_of_reference . name = 'functional occurrence' ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference composition path' ) AND NOT ( ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF ( pdr . related_product_definition ) ) AND ( pdr . related_product_definition . frame_of_reference . name = 'functional occurrence' ) ) ) ) = 0 "/>
      </rule>
      <rule name="reference_functional_unit_assignment_to_part_constraint" appliesto="product_definition_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference functional unit assignment to part' ) AND NOT ( ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'PRODUCT_DEFINITION' IN TYPEOF ( pdr . related_product_definition ) ) AND ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF ( pdr . related_product_definition . frame_of_reference ) ) AND ( ( pdr . relating_product_definition . frame_of_reference . name = 'physical design' ) OR ( pdr . relating_product_definition . frame_of_reference . name = 'physical design usage' ) ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference functional unit assignment to part' ) AND NOT ( ( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'PRODUCT_DEFINITION' IN TYPEOF ( pdr . relating_product_definition ) ) AND ( pdr . relating_product_definition \ product_definition . description = 'design definition path' ) AND ( pdr . relating_product_definition . id = 'reference composition path' ) ) ) ) = 0 "/>
      </rule>
      <rule name="reference_functional_unit_assignment_to_part_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm> LOCAL sar : BAG OF shape_aspect_relationship := QUERY ( r &lt;* shape_aspect_relationship | ( r \ shape_aspect_relationship . name = 'reference functional unit assignment to part' ) ) ; d_bag : BAG OF STRING := [ ] ; sar_bag : BAG OF shape_aspect_relationship ; pass : BOOLEAN := TRUE ; pd_bag : BAG OF product_definition ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( sar ) by 1 ; IF EXISTS ( sar [ i ] \ shape_aspect_relationship . description ) THEN IF ( NOT ( sar [ i ] \ shape_aspect_relationship . description IN d_bag ) ) THEN d_bag := d_bag + sar [ i ] \ shape_aspect_relationship . description ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( d_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; sar_bag := QUERY ( r &lt;* sar | ( r \ shape_aspect_relationship . description = d_bag [ i ] ) ) ; pd_bag := [ ] ; REPEAT j := 1 to SIZEOF ( sar_bag ) by 1 ; IF EXISTS ( sar_bag [ j ] . related_shape_aspect . of_shape . definition ) THEN IF ( sar_bag [ j ] . related_shape_aspect . of_shape . definition IN pd_bag ) THEN pass := FALSE ; ESCAPE ; ELSE pd_bag := pd_bag + sar_bag [ j ] . related_shape_aspect . of_shape . definition ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
   </schema>
</express>
