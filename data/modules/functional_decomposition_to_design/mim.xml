<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:55:30" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="functional_decomposition_to_design_mim schema_instance"/>
   <schema name="FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM">
      <interface kind="use" schema="CHARACTERISTIC_MIM"/>
      <interface kind="use" schema="DESIGN_MANAGEMENT_MIM"/>
      <interface kind="use" schema="NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_DESIGN_VIEW_MIM"/>
      <type name="fdtd_managed_design_object">
         <select extensible="YES" genericentity="YES" basedon="managed_design_object" selectitems="product_definition_relationship property_definition_relationship"/>
      </type>
      <rule name="design_functional_unit_allocation_to_assembly_component_constraint" appliesto="product_definition_relationship">
         <where label="wr1" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) and ( not ( ( pdr . relating_product_definition \ product_definition . description = 'design definition path' ) and ( pdr . relating_product_definition . id = 'design composition path' ) ) ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) and ( not ( 'functional_decomposition_to_design_mim.' + 'component_definition' in typeof ( pdr . related_product_definition ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="design_functional_unit_allocation_to_assembly_component_unique_constraint" appliesto="product_definition_relationship">
         <algorithm> local dfuatac : bag of product_definition_relationship := query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'design functional unit allocation to assembly component' ) ) ; cd_bag : bag of component_definition := [ ] ; pdr_bag : bag of product_definition_relationship ; pass : boolean := true ; id_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( dfuatac ) by 1 ; if exists ( dfuatac [ i ] . related_product_definition ) then if ( 'functional_decomposition_to_design_mim.' + 'component_definition' in typeof ( dfuatac [ i ] . related_product_definition ) ) then if ( not ( dfuatac [ i ] . related_product_definition in cd_bag ) ) then cd_bag := cd_bag + dfuatac [ i ] . related_product_definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( cd_bag ) by 1 ; if ( not pass ) then escape ; end_if ; pdr_bag := query ( pdr &lt;* dfuatac | ( pdr . related_product_definition :=: cd_bag [ i ] ) ) ; id_bag := [ ] ; repeat j := 1 to sizeof ( pdr_bag ) by 1 ; if exists ( pdr_bag [ j ] . id ) then if ( pdr_bag [ j ] . id in id_bag ) then pass := false ; escape ; else id_bag := id_bag + pdr_bag [ j ] . id ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="reference_composition_path_constraint" appliesto="product_definition_relationship">
         <where label="wr1" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference composition path' ) and not ( ( 'functional_decomposition_to_design_mim.' + 'component_functional_unit' in typeof ( pdr . relating_product_definition ) ) and ( pdr . relating_product_definition \ product_definition . description = 'reference definition path' ) and ( pdr . relating_product_definition . frame_of_reference . name = 'functional occurrence' ) ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference composition path' ) and not ( ( 'functional_decomposition_to_design_mim.' + 'component_functional_unit' in typeof ( pdr . related_product_definition ) ) and ( pdr . related_product_definition . frame_of_reference . name = 'functional occurrence' ) ) ) ) = 0 "/>
      </rule>
      <rule name="reference_functional_unit_assignment_to_part_constraint" appliesto="product_definition_relationship">
         <where label="wr1" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference functional unit assignment to part' ) and not ( ( 'functional_decomposition_to_design_mim.' + 'product_definition' in typeof ( pdr . related_product_definition ) ) and ( 'functional_decomposition_to_design_mim.' + 'application_context_element' in typeof ( pdr . related_product_definition . frame_of_reference ) ) and ( ( pdr . relating_product_definition . frame_of_reference . name = 'physical design' ) or ( pdr . relating_product_definition . frame_of_reference . name = 'physical design usage' ) ) ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . name = 'reference functional unit assignment to part' ) and not ( ( 'functional_decomposition_to_design_mim.' + 'product_definition' in typeof ( pdr . relating_product_definition ) ) and ( pdr . relating_product_definition \ product_definition . description = 'design definition path' ) and ( pdr . relating_product_definition . id = 'reference composition path' ) ) ) ) = 0 "/>
      </rule>
      <rule name="reference_functional_unit_assignment_to_part_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm> local sar : bag of shape_aspect_relationship := query ( r &lt;* shape_aspect_relationship | ( r \ shape_aspect_relationship . name = 'reference functional unit assignment to part' ) ) ; d_bag : bag of string := [ ] ; sar_bag : bag of shape_aspect_relationship ; pass : boolean := true ; pd_bag : bag of product_definition ; end_local ; repeat i := 1 to sizeof ( sar ) by 1 ; if exists ( sar [ i ] \ shape_aspect_relationship . description ) then if ( not ( sar [ i ] \ shape_aspect_relationship . description in d_bag ) ) then d_bag := d_bag + sar [ i ] \ shape_aspect_relationship . description ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( d_bag ) by 1 ; if ( not pass ) then escape ; end_if ; sar_bag := query ( r &lt;* sar | ( r \ shape_aspect_relationship . description = d_bag [ i ] ) ) ; pd_bag := [ ] ; repeat j := 1 to sizeof ( sar_bag ) by 1 ; if exists ( sar_bag [ j ] . related_shape_aspect . of_shape . definition ) then if ( sar_bag [ j ] . related_shape_aspect . of_shape . definition in pd_bag ) then pass := false ; escape ; else pd_bag := pd_bag + sar_bag [ j ] . related_shape_aspect . of_shape . definition ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
   </schema>
</express>
