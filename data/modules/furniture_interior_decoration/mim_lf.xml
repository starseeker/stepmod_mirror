<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: express2xml.js,v 1.38 2004/08/24 16:58:55 thendrix Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express language_version="2" rcs.date="$Date: $" rcs.revision="$Revision: $">
	<application name="express2xml2.js" owner="Eurostep Limited" url="http://www.eurostep.com" version="1.38" source="../data/modules/furniture_interior_decoration/mim_lf.exp"/>
	<schema name="Furniture_interior_decoration_mim_lf">
		<constant name="DUMMY_GRI" expression="representation_item('')|| geometric_representation_item()">
			<typename name="geometric_representation_item"/>
		</constant>
		<constant name="DUMMY_TRI" expression="representation_item('')|| topological_representation_item()">
			<typename name="topological_representation_item"/>
		</constant>
		<type name="ahead_or_behind">
			<enumeration items="AHEAD EXACT BEHIND">
      </enumeration>
		</type>
		<type name="aliasable_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="amount_of_substance_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="angle_relator">
			<enumeration items="EQUAL LARGE SMALL">
      </enumeration>
		</type>
		<type name="approval_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="area_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="attribute_language_item">
			<select extensible="YES" genericentity="YES" selectitems="multi_language_attribute_assignment">
      </select>
		</type>
		<type name="axis2_placement">
			<select selectitems="axis2_placement_2d axis2_placement_3d">
      </select>
		</type>
		<type name="b_spline_curve_form">
			<enumeration items="POLYLINE_FORM CIRCULAR_ARC ELLIPTIC_ARC PARABOLIC_ARC HYPERBOLIC_ARC UNSPECIFIED">
      </enumeration>
		</type>
		<type name="b_spline_surface_form">
			<enumeration items="PLANE_SURF CYLINDRICAL_SURF CONICAL_SURF SPHERICAL_SURF TOROIDAL_SURF SURF_OF_REVOLUTION RULED_SURF GENERALISED_CONE QUADRIC_SURF SURF_OF_LINEAR_EXTRUSION UNSPECIFIED">
      </enumeration>
		</type>
		<type name="boolean_operand">
			<select selectitems="solid_model half_space_solid csg_primitive boolean_result half_space_2d">
      </select>
		</type>
		<type name="boolean_operator">
			<enumeration items="UNION INTERSECTION DIFFERENCE">
      </enumeration>
		</type>
		<type name="category_usage_item">
			<select selectitems="product_class">
      </select>
		</type>
		<type name="celsius_temperature_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="certification_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="characterized_definition">
			<select selectitems="characterized_object characterized_product_definition shape_definition">
      </select>
		</type>
		<type name="characterized_material_property">
			<select selectitems="product_material_composition_relationship">
      </select>
		</type>
		<type name="characterized_resource_definition">
			<select selectitems="action_resource_requirement action_resource_requirement_relationship">
      </select>
		</type>
		<type name="class_system_item">
			<select extensible="YES" genericentity="YES" selectitems="characterized_class">
      </select>
		</type>
		<type name="classification_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="classification_item_extended">
			<select extensible="YES" genericentity="YES" basedon="CLASSIFICATION_ITEM" selectitems="characterized_class">
      </select>
		</type>
		<type name="classification_select">
			<select extensible="YES">
      </select>
		</type>
		<type name="classified_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="complete_membership_select">
			<select extensible="YES">
      </select>
		</type>
		<type name="compound_item_definition">
			<select selectitems="list_representation_item set_representation_item">
      </select>
		</type>
		<type name="configured_effectivity_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="context_dependent_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="contract_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="count_measure">
			<builtintype type="NUMBER">
      </builtintype>
		</type>
		<type name="csg_primitive">
			<select selectitems="sphere ellipsoid block right_angular_wedge faceted_primitive rectangular_pyramid torus right_circular_cone eccentric_cone right_circular_cylinder cyclide_segment_solid primitive_2d">
      </select>
		</type>
		<type name="csg_select">
			<select selectitems="boolean_result csg_primitive">
      </select>
		</type>
		<type name="curve_on_surface">
			<select selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>
		</type>
		<type name="date_and_time_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="date_and_time_item_approval">
			<select basedon="DATE_AND_TIME_ITEM">
      </select>
		</type>
		<type name="date_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="date_item_approval">
			<select basedon="DATE_ITEM">
      </select>
		</type>
		<type name="date_time_or_event_occurrence">
			<select selectitems="date_time_select event_occurrence">
      </select>
		</type>
		<type name="date_time_select">
			<select selectitems="date date_and_time local_time">
      </select>
		</type>
		<type name="day_in_month_number">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{1 &lt;= SELF &lt;= 31}">
      </where>
		</type>
		<type name="day_in_week_number">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{ 1 &lt;= SELF &lt;= 7 }">
      </where>
		</type>
		<type name="day_in_year_number">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{1 &lt;= SELF &lt;= 366}">
      </where>
		</type>
		<type name="derived_property_select">
			<select selectitems="property_definition">
      </select>
		</type>
		<type name="descriptive_measure">
			<builtintype type="STRING">
      </builtintype>
		</type>
		<type name="dimension_count">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="SELF &gt; 0">
      </where>
		</type>
		<type name="dimension_identification_item">
			<select basedon="IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="dimension_tolerance_document_reference_item">
			<select basedon="DOCUMENT_REFERENCE_ITEM" selectitems="externally_defined_dimension_definition">
      </select>
		</type>
		<type name="dimensional_characteristic">
			<select selectitems="dimensional_location dimensional_size">
      </select>
		</type>
		<type name="document_location_select">
			<select basedon="EXTERNAL_IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="document_reference_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="effectivity_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="effectivity_item_for_replacement">
			<select basedon="EFFECTIVITY_ITEM">
      </select>
		</type>
		<type name="effectivity_specification_for_replacement">
			<select basedon="EFFECTIVITY_ITEM">
      </select>
		</type>
		<type name="electric_current_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="event_occurrence_date_and_time_item">
			<select extensible="YES" genericentity="YES" basedon="DATE_AND_TIME_ITEM">
      </select>
		</type>
		<type name="event_occurrence_date_item">
			<select extensible="YES" genericentity="YES" basedon="DATE_ITEM">
      </select>
		</type>
		<type name="event_occurrence_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="extent_enumeration">
			<enumeration items="INVALID ZERO FINITE_NON_ZERO INFINITE">
      </enumeration>
		</type>
		<type name="external_class_name_item">
			<select basedon="NAME_ITEM" selectitems="external_class_library">
      </select>
		</type>
		<type name="external_identification_for_plib_property">
			<select basedon="EXTERNAL_IDENTIFICATION_ITEM" selectitems="externally_defined_general_property">
      </select>
		</type>
		<type name="external_identification_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="externally_versioned_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="file_identification_item">
			<select basedon="IDENTIFICATION_ITEM" selectitems="document_file">
      </select>
		</type>
		<type name="file_location_select">
			<select basedon="EXTERNAL_IDENTIFICATION_ITEM" selectitems="document_file">
      </select>
		</type>
		<type name="file_version_item">
			<select basedon="VERSIONABLE_ITEM" selectitems="document_file">
      </select>
		</type>
		<type name="founded_item_select">
			<select selectitems="founded_item representation_item">
      </select>
		</type>
		<type name="groupable_item">
			<select extensible="YES" genericentity="YES">
      </select>
			<where label="WR1" expression="NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF))">
      </where>
		</type>
		<type name="hour_in_day">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{ 0 &lt;= SELF &lt; 24 }">
      </where>
		</type>
		<type name="id_for_class">
			<select basedon="IDENTIFICATION_ITEM" selectitems="characterized_class">
      </select>
		</type>
		<type name="id_for_product_identification">
			<select basedon="IDENTIFICATION_ITEM" selectitems="product_identification">
      </select>
		</type>
		<type name="identification_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="identifier">
			<builtintype type="STRING">
      </builtintype>
		</type>
		<type name="idrm_marked_item">
			<select extensible="YES" basedon="CLASSIFICATION_ITEM">
      </select>
		</type>
		<type name="instance_usage_context_select">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="knot_type">
			<enumeration items="UNIFORM_KNOTS QUASI_UNIFORM_KNOTS PIECEWISE_BEZIER_KNOTS UNSPECIFIED">
      </enumeration>
		</type>
		<type name="label">
			<builtintype type="STRING">
      </builtintype>
		</type>
		<type name="length_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="limit_condition">
			<enumeration items="MAXIMUM_MATERIAL_CONDITION LEAST_MATERIAL_CONDITION REGARDLESS_OF_FEATURE_SIZE">
      </enumeration>
		</type>
		<type name="list_of_reversible_topology_item">
			<aggregate type="LIST"/>
			<typename name="reversible_topology_item"/>
		</type>
		<type name="list_representation_item">
			<aggregate type="LIST" lower="1" upper="?"/>
			<typename name="representation_item"/>
		</type>
		<type name="luminous_intensity_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="mass_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="mce_organization_item">
			<select basedon="ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="measure_value">
			<select selectitems="amount_of_substance_measure area_measure celsius_temperature_measure context_dependent_measure count_measure descriptive_measure electric_current_measure length_measure luminous_intensity_measure mass_measure numeric_measure parameter_value plane_angle_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure ratio_measure solid_angle_measure thermodynamic_temperature_measure time_measure volume_measure">
      </select>
		</type>
		<type name="message">
			<builtintype type="STRING">
      </builtintype>
		</type>
		<type name="minute_in_hour">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{ 0 &lt;= SELF &lt;= 59 }">
      </where>
		</type>
		<type name="month_in_year_number">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{ 1 &lt;= SELF &lt;= 12 }">
      </where>
		</type>
		<type name="mri_aliasable_item">
			<select extensible="YES" basedon="ALIASABLE_ITEM">
      </select>
		</type>
		<type name="mri_approval_item">
			<select extensible="YES" genericentity="YES" basedon="APPROVAL_ITEM">
      </select>
		</type>
		<type name="mri_attribute_language_item">
			<select extensible="YES" genericentity="YES" basedon="ATTRIBUTE_LANGUAGE_ITEM">
      </select>
		</type>
		<type name="mri_date_and_time_item">
			<select extensible="YES" genericentity="YES" basedon="DATE_AND_TIME_ITEM">
      </select>
		</type>
		<type name="mri_date_item">
			<select extensible="YES" genericentity="YES" basedon="DATE_ITEM">
      </select>
		</type>
		<type name="mri_identification_item">
			<select extensible="YES" genericentity="YES" basedon="IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="mri_multi_language_attribute_item">
			<select extensible="YES" genericentity="YES" basedon="MULTI_LANGUAGE_ATTRIBUTE_ITEM">
      </select>
		</type>
		<type name="mri_organization_item">
			<select extensible="YES" genericentity="YES" basedon="ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="mri_person_and_organization_item">
			<select extensible="YES" genericentity="YES" basedon="PERSON_AND_ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="multi_language_attribute_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="name_item">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="numeric_measure">
			<builtintype type="NUMBER">
      </builtintype>
		</type>
		<type name="organization_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="organization_item_solution">
			<select basedon="ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="parameter_value">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="pcurve_or_surface">
			<select selectitems="pcurve surface">
      </select>
		</type>
		<type name="person_and_organization_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="person_organization_select">
			<select selectitems="organization person person_and_organization">
      </select>
		</type>
		<type name="plane_angle_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="plib_class_identification_item">
			<select basedon="EXTERNAL_IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="plib_class_organization_item">
			<select basedon="ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="positive_length_measure">
			<typename name="length_measure"/>
			<where label="WR1" expression="SELF &gt; 0.0">
      </where>
		</type>
		<type name="positive_plane_angle_measure">
			<typename name="plane_angle_measure"/>
			<where label="WR1" expression="SELF &gt; 0.0">
      </where>
		</type>
		<type name="positive_ratio_measure">
			<typename name="ratio_measure"/>
			<where label="WR1" expression="SELF &gt; 0.0">
      </where>
		</type>
		<type name="preferred_surface_curve_representation">
			<enumeration items="CURVE_3D PCURVE_S1 PCURVE_S2">
      </enumeration>
		</type>
		<type name="product_as_individual_identification_item">
			<select basedon="IDENTIFICATION_ITEM" selectitems="product_as_individual product_as_individual_version product_as_individual_view">
      </select>
		</type>
		<type name="product_definition_or_breakdown_element_usage">
			<select extensible="YES" genericentity="YES" selectitems="breakdown_element_usage">
      </select>
		</type>
		<type name="product_definition_or_product_definition_relationship">
			<select extensible="YES" genericentity="YES">
      </select>
		</type>
		<type name="project_as_date_and_time_item">
			<select basedon="DATE_AND_TIME_ITEM">
      </select>
		</type>
		<type name="project_as_date_item">
			<select basedon="DATE_ITEM">
      </select>
		</type>
		<type name="project_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="ratio_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="representation_identification_item">
			<select basedon="IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="representation_version_item">
			<select basedon="VERSIONABLE_ITEM">
      </select>
		</type>
		<type name="requirement_identification_and_version_mri_identification_item">
			<select extensible="YES" genericentity="YES" basedon="MRI_IDENTIFICATION_ITEM">
      </select>
		</type>
		<type name="reversible_topology">
			<select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item">
      </select>
		</type>
		<type name="reversible_topology_item">
			<select selectitems="edge path face face_bound closed_shell open_shell">
      </select>
		</type>
		<type name="second_in_minute">
			<builtintype type="REAL">
      </builtintype>
			<where label="WR1" expression="{ 0 &lt;= SELF &lt;= 60.0 }">
      </where>
		</type>
		<type name="security_classification_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="set_of_reversible_topology_item">
			<aggregate type="SET"/>
			<typename name="reversible_topology_item"/>
		</type>
		<type name="set_representation_item">
			<aggregate type="SET" lower="1" upper="?"/>
			<typename name="representation_item"/>
		</type>
		<type name="shape_definition">
			<select selectitems="product_definition_shape shape_aspect shape_aspect_relationship">
      </select>
		</type>
		<type name="shape_tolerance_select">
			<select selectitems="geometric_tolerance plus_minus_tolerance">
      </select>
		</type>
		<type name="shell">
			<select selectitems="vertex_shell wire_shell open_shell closed_shell">
      </select>
		</type>
		<type name="si_prefix">
			<enumeration items="EXA PETA TERA GIGA MEGA KILO HECTO DECA DECI CENTI MILLI MICRO NANO PICO FEMTO ATTO">
      </enumeration>
		</type>
		<type name="si_unit_name">
			<enumeration items="METRE GRAM SECOND AMPERE KELVIN MOLE CANDELA RADIAN STERADIAN HERTZ NEWTON PASCAL JOULE WATT COULOMB VOLT FARAD OHM SIEMENS WEBER TESLA HENRY DEGREE_CELSIUS LUMEN LUX BECQUEREL GRAY SIEVERT">
      </enumeration>
		</type>
		<type name="solid_angle_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="source">
			<enumeration items="MADE BOUGHT NOT_KNOWN">
      </enumeration>
		</type>
		<type name="source_item">
			<select selectitems="message">
      </select>
		</type>
		<type name="specification_for_category">
			<select basedon="GROUPABLE_ITEM" selectitems="package_product_concept_feature">
      </select>
		</type>
		<type name="spr_document_reference_item">
			<select basedon="DOCUMENT_REFERENCE_ITEM">
      </select>
		</type>
		<type name="spr_organization_item">
			<select extensible="YES" basedon="ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="spr_person_and_organization_item">
			<select extensible="YES" basedon="PERSON_AND_ORGANIZATION_ITEM">
      </select>
		</type>
		<type name="supported_item">
			<select selectitems="action action_directive action_method">
      </select>
		</type>
		<type name="surface_boundary">
			<select selectitems="boundary_curve degenerate_pcurve">
      </select>
		</type>
		<type name="surface_model">
			<select selectitems="shell_based_surface_model face_based_surface_model">
      </select>
		</type>
		<type name="text">
			<builtintype type="STRING">
      </builtintype>
		</type>
		<type name="thermodynamic_temperature_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="time_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="tolerance_method_definition">
			<select selectitems="tolerance_value limits_and_fits">
      </select>
		</type>
		<type name="transformation">
			<select selectitems="item_defined_transformation functionally_defined_transformation">
      </select>
		</type>
		<type name="transition_code">
			<enumeration items="DISCONTINUOUS CONTINUOUS CONT_SAME_GRADIENT CONT_SAME_GRADIENT_SAME_CURVATURE">
      </enumeration>
		</type>
		<type name="trimming_preference">
			<enumeration items="CARTESIAN PARAMETER UNSPECIFIED">
      </enumeration>
		</type>
		<type name="trimming_select">
			<select selectitems="cartesian_point">
      </select>
		</type>
		<type name="unit">
			<select selectitems="derived_unit named_unit">
      </select>
		</type>
		<type name="value_qualifier">
			<select selectitems="precision_qualifier type_qualifier uncertainty_qualifier">
      </select>
		</type>
		<type name="vector_or_direction">
			<select selectitems="vector direction">
      </select>
		</type>
		<type name="version_for_class">
			<select basedon="VERSIONABLE_ITEM" selectitems="characterized_class">
      </select>
		</type>
		<type name="version_for_plib_property">
			<select basedon="externally_versioned_item" selectitems="externally_defined_general_property">
      </select>
		</type>
		<type name="version_for_product_identification">
			<select basedon="VERSIONABLE_ITEM" selectitems="product_identification">
      </select>
		</type>
		<type name="versionable_item">
			<select extensible="YES">
      </select>
		</type>
		<type name="volume_measure">
			<builtintype type="REAL">
      </builtintype>
		</type>
		<type name="week_in_year_number">
			<builtintype type="INTEGER">
      </builtintype>
			<where label="WR1" expression="{ 1 &lt;= SELF &lt;= 53 }">
      </where>
		</type>
		<type name="wireframe_model">
			<select selectitems="shell_based_wireframe_model edge_based_wireframe_model">
      </select>
		</type>
		<type name="year_number">
			<builtintype type="INTEGER">
      </builtintype>
		</type>
		<entity name="action">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="chosen_method">
				<typename name="action_method"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
      </where>
		</entity>
		<entity name="action_assignment" abstract.supertype="YES">
			<explicit name="assigned_action">
				<typename name="ACTION"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
      </where>
		</entity>
		<entity name="action_directive">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="analysis">
				<typename name="text"/>
			</explicit>
			<explicit name="comment">
				<typename name="text"/>
			</explicit>
			<explicit name="requests">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="versioned_action_request"/>
			</explicit>
		</entity>
		<entity name="action_method">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="consequence">
				<typename name="text"/>
			</explicit>
			<explicit name="purpose">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="action_method_assignment" abstract.supertype="YES">
			<explicit name="assigned_action_method">
				<typename name="ACTION_METHOD"/>
			</explicit>
			<explicit name="role">
				<typename name="action_method_role"/>
			</explicit>
		</entity>
		<entity name="action_method_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_method">
				<typename name="action_method"/>
			</explicit>
			<explicit name="related_method">
				<typename name="action_method"/>
			</explicit>
		</entity>
		<entity name="action_method_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="action_property">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="definition">
				<typename name="characterized_action_definition"/>
			</explicit>
		</entity>
		<entity name="action_property_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_action_property">
				<typename name="action_property"/>
			</explicit>
			<explicit name="related_action_property">
				<typename name="action_property"/>
			</explicit>
			<where label="WR1" expression="relating_action_property :&lt;&gt;: related_action_property">
      </where>
		</entity>
		<entity name="action_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_action">
				<typename name="action"/>
			</explicit>
			<explicit name="related_action">
				<typename name="action"/>
			</explicit>
		</entity>
		<entity name="action_request_assignment" abstract.supertype="YES">
			<explicit name="assigned_action_request">
				<typename name="VERSIONED_ACTION_REQUEST"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
      </where>
		</entity>
		<entity name="action_request_solution">
			<explicit name="method">
				<typename name="action_method"/>
			</explicit>
			<explicit name="request">
				<typename name="versioned_action_request"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
      </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
      </where>
		</entity>
		<entity name="action_request_status">
			<explicit name="status">
				<typename name="label"/>
			</explicit>
			<explicit name="assigned_request">
				<typename name="versioned_action_request"/>
			</explicit>
		</entity>
		<entity name="action_resource">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="usage">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="supported_item"/>
			</explicit>
			<explicit name="kind">
				<typename name="action_resource_type"/>
			</explicit>
		</entity>
		<entity name="action_resource_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_resource">
				<typename name="action_resource"/>
			</explicit>
			<explicit name="related_resource">
				<typename name="action_resource"/>
			</explicit>
		</entity>
		<entity name="action_resource_requirement">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="kind">
				<typename name="resource_requirement_type"/>
			</explicit>
			<explicit name="operations">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="characterized_action_definition"/>
			</explicit>
		</entity>
		<entity name="action_resource_requirement_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_action_resource_requirement">
				<typename name="action_resource_requirement"/>
			</explicit>
			<explicit name="related_action_resource_requirement">
				<typename name="action_resource_requirement"/>
			</explicit>
			<where label="WR1" expression="relating_action_resource_requirement :&lt;&gt;: related_action_resource_requirement">
      </where>
		</entity>
		<entity name="action_resource_type">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="action_status">
			<explicit name="status">
				<typename name="label"/>
			</explicit>
			<explicit name="assigned_action">
				<typename name="executed_action"/>
			</explicit>
		</entity>
		<entity name="address">
			<explicit name="internal_location" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="street_number" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="street" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="postal_box" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="town" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="region" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="postal_code" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="country" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="facsimile_number" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="telephone_number" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="electronic_mail_address" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="telex_number" optional="YES">
				<typename name="label"/>
			</explicit>
			<derived name="name" expression="get_name_value(SELF)">
				<typename name="label"/>
			</derived>
			<derived name="url" expression="get_id_value(SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number)">
      </where>
		</entity>
		<entity name="advanced_face" supertypes="face_surface">
			<where label="WR1" expression="SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1">
      </where>
			<where label="WR2" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)))) = 0))) = 0">
      </where>
			<where label="WR3" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| NOT (SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0">
      </where>
			<where label="WR4" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))))) = 0))) = 0">
      </where>
			<where label="WR5" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)))) = 0">
      </where>
			<where label="WR6" expression="NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1)">
      </where>
			<where label="WR7" expression="SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)))| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0">
      </where>
			<where label="WR8" expression="SIZEOF (QUERY (bnd &lt;* bounds| NOT (SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1))) = 0">
      </where>
			<where label="WR9" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF (QUERY (sc_ag &lt;* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)))) = 0))) = 0))) = 0">
      </where>
			<where label="WR10" expression="(NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR (SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) &gt;= 3))) AND (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)))| NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) &gt;= 3))) = 0))) = 0)">
      </where>
		</entity>
		<entity name="alternate_product_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="definition" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="alternate">
				<typename name="product"/>
			</explicit>
			<explicit name="base">
				<typename name="product"/>
			</explicit>
			<explicit name="basis">
				<typename name="text"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="alternate"/>
				<unique.attribute attribute="base"/>
			</unique>
			<where label="WR1" expression="alternate :&lt;&gt;: base">
      </where>
		</entity>
		<entity name="amount_of_substance_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
      </where>
		</entity>
		<entity name="amount_of_substance_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
      </where>
		</entity>
		<entity name="angular_location" supertypes="dimensional_location">
			<explicit name="angle_selection">
				<typename name="angle_relator"/>
			</explicit>
		</entity>
		<entity name="angular_size" supertypes="dimensional_size">
			<explicit name="angle_selection">
				<typename name="angle_relator"/>
			</explicit>
		</entity>
		<entity name="apex" supertypes="derived_shape_aspect">
    </entity>
		<entity name="application_context">
			<explicit name="application">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<inverse name="context_elements" entity="application_context_element" attribute="frame_of_reference">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
      </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
      </where>
		</entity>
		<entity name="application_context_element" super.expression="(ONEOF ( LIBRARY_CONTEXT, PRODUCT_CONCEPT_CONTEXT, PRODUCT_CONTEXT, PRODUCT_DEFINITION_CONTEXT))">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="frame_of_reference">
				<typename name="application_context"/>
			</explicit>
		</entity>
		<entity name="application_context_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_context">
				<typename name="application_context"/>
			</explicit>
			<explicit name="related_context">
				<typename name="application_context"/>
			</explicit>
		</entity>
		<entity name="application_protocol_definition">
			<explicit name="status">
				<typename name="label"/>
			</explicit>
			<explicit name="application_interpreted_model_schema_name">
				<typename name="label"/>
			</explicit>
			<explicit name="application_protocol_year">
				<typename name="year_number"/>
			</explicit>
			<explicit name="application">
				<typename name="application_context"/>
			</explicit>
		</entity>
		<entity name="applied_approval_assignment" supertypes="approval_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="approval_item"/>
			</explicit>
		</entity>
		<entity name="applied_certification_assignment" supertypes="certification_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="certification_item"/>
			</explicit>
		</entity>
		<entity name="applied_classification_assignment" supertypes="classification_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="classification_item"/>
			</explicit>
		</entity>
		<entity name="applied_contract_assignment" supertypes="contract_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="contract_item"/>
			</explicit>
		</entity>
		<entity name="applied_date_and_time_assignment" supertypes="date_and_time_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="date_and_time_item"/>
			</explicit>
		</entity>
		<entity name="applied_date_assignment" supertypes="date_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="date_item"/>
			</explicit>
		</entity>
		<entity name="applied_document_reference" supertypes="document_reference">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="document_reference_item"/>
			</explicit>
		</entity>
		<entity name="applied_document_usage_constraint_assignment" supertypes="document_usage_constraint_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="document_reference_item"/>
			</explicit>
		</entity>
		<entity name="applied_effectivity_assignment" supertypes="effectivity_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="effectivity_item"/>
			</explicit>
		</entity>
		<entity name="applied_event_occurrence_assignment" supertypes="event_occurrence_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="event_occurrence_item"/>
			</explicit>
		</entity>
		<entity name="applied_external_identification_assignment" supertypes="external_identification_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="external_identification_item"/>
			</explicit>
		</entity>
		<entity name="applied_group_assignment" supertypes="group_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="groupable_item"/>
			</explicit>
		</entity>
		<entity name="applied_identification_assignment" supertypes="identification_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="identification_item"/>
			</explicit>
		</entity>
		<entity name="applied_name_assignment" supertypes="name_assignment">
			<explicit name="item">
				<typename name="name_item"/>
			</explicit>
		</entity>
		<entity name="applied_organization_assignment" supertypes="organization_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="organization_item"/>
			</explicit>
		</entity>
		<entity name="applied_organizational_project_assignment" supertypes="organizational_project_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="project_item"/>
			</explicit>
		</entity>
		<entity name="applied_person_and_organization_assignment" supertypes="person_and_organization_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="person_and_organization_item"/>
			</explicit>
		</entity>
		<entity name="applied_security_classification_assignment" supertypes="security_classification_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="security_classification_item"/>
			</explicit>
		</entity>
		<entity name="approval">
			<explicit name="status">
				<typename name="approval_status"/>
			</explicit>
			<explicit name="level">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="approval_assignment" abstract.supertype="YES">
			<explicit name="assigned_approval">
				<typename name="APPROVAL"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
      </where>
		</entity>
		<entity name="approval_date_time">
			<explicit name="date_time">
				<typename name="date_time_select"/>
			</explicit>
			<explicit name="dated_approval">
				<typename name="approval"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
      </where>
		</entity>
		<entity name="approval_person_organization">
			<explicit name="person_organization">
				<typename name="person_organization_select"/>
			</explicit>
			<explicit name="authorized_approval">
				<typename name="approval"/>
			</explicit>
			<explicit name="role">
				<typename name="approval_role"/>
			</explicit>
		</entity>
		<entity name="approval_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_approval">
				<typename name="approval"/>
			</explicit>
			<explicit name="related_approval">
				<typename name="approval"/>
			</explicit>
		</entity>
		<entity name="approval_role">
			<explicit name="role">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
      </where>
		</entity>
		<entity name="approval_status">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="area_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
      </where>
		</entity>
		<entity name="area_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
      </where>
		</entity>
		<entity name="assembly_component_usage" super.expression="(ONEOF ( NEXT_ASSEMBLY_USAGE_OCCURRENCE, SPECIFIED_HIGHER_USAGE_OCCURRENCE, PROMISSORY_USAGE_OCCURRENCE) ANDOR QUANTIFIED_ASSEMBLY_COMPONENT_USAGE)" supertypes="product_definition_usage">
			<explicit name="reference_designator" optional="YES">
				<typename name="identifier"/>
			</explicit>
		</entity>
		<entity name="assembly_component_usage_substitute">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="definition" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="base">
				<typename name="assembly_component_usage"/>
			</explicit>
			<explicit name="substitute">
				<typename name="assembly_component_usage"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="base"/>
				<unique.attribute attribute="substitute"/>
			</unique>
			<where label="WR1" expression="base.relating_product_definition :=: substitute.relating_product_definition">
      </where>
			<where label="WR2" expression="base :&lt;&gt;: substitute">
      </where>
		</entity>
		<entity name="assembly_component_usage_substitute_with_ranking" supertypes="assembly_component_usage_substitute">
			<explicit name="ranking">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="ranking_rationale">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="attribute_classification_assignment" abstract.supertype="YES">
			<explicit name="assigned_class">
				<typename name="GROUP"/>
			</explicit>
			<explicit name="attribute_name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="role">
				<typename name="classification_role"/>
			</explicit>
		</entity>
		<entity name="attribute_language_assignment" supertypes="attribute_classification_assignment">
			<explicit name="assigned_class">
				<typename name="language"/>
				<redeclaration entity-ref="attribute_classification_assignment"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="attribute_language_item"/>
			</explicit>
			<where label="WR1" expression="SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']">
        </where>
			<where label="WR2" expression="SELF\attribute_classification_assignment.attribute_name&lt;&gt; ''">
        </where>
		</entity>
		<entity name="attribute_value_assignment" abstract.supertype="YES">
			<explicit name="attribute_name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="attribute_value">
				<typename name="attribute_type"/>
			</explicit>
			<explicit name="role">
				<typename name="attribute_value_role"/>
			</explicit>
		</entity>
		<entity name="attribute_value_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="axis1_placement" supertypes="placement">
			<explicit name="axis" optional="YES">
				<typename name="direction"/>
			</explicit>
			<derived name="z" expression="NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]))">
				<typename name="direction"/>
			</derived>
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 3">
        </where>
		</entity>
		<entity name="axis2_placement_2d" supertypes="placement">
			<explicit name="ref_direction" optional="YES">
				<typename name="direction"/>
			</explicit>
			<derived name="p" expression="build_2axes(ref_direction)">
				<aggregate type="LIST" lower="2" upper="2"/>
				<typename name="direction"/>
			</derived>
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 2">
        </where>
		</entity>
		<entity name="axis2_placement_3d" supertypes="placement">
			<explicit name="axis" optional="YES">
				<typename name="direction"/>
			</explicit>
			<explicit name="ref_direction" optional="YES">
				<typename name="direction"/>
			</explicit>
			<derived name="p" expression="build_axes(axis,ref_direction)">
				<aggregate type="LIST" lower="3" upper="3"/>
				<typename name="direction"/>
			</derived>
			<where label="WR1" expression="SELF\placement.location.dim = 3">
        </where>
			<where label="WR2" expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)">
        </where>
			<where label="WR3" expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)">
        </where>
			<where label="WR4" expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR(cross_product(axis,ref_direction).magnitude &gt; 0.0)">
        </where>
		</entity>
		<entity name="b_spline_curve" super.expression="(ONEOF ( UNIFORM_CURVE, B_SPLINE_CURVE_WITH_KNOTS, QUASI_UNIFORM_CURVE, BEZIER_CURVE) ANDOR RATIONAL_B_SPLINE_CURVE)" supertypes="bounded_curve">
			<explicit name="degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="control_points_list">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="curve_form">
				<typename name="b_spline_curve_form"/>
			</explicit>
			<explicit name="closed_curve">
				<builtintype type="LOGICAL"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
			<derived name="upper_index_on_control_points" expression="(SIZEOF(control_points_list) - 1)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="control_points" expression="list_to_array(control_points_list,0, upper_index_on_control_points)">
				<aggregate type="ARRAY" lower="0" upper="100"/>
				<typename name="cartesian_point"/>
			</derived>
			<where label="WR1" expression="('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))">
        </where>
		</entity>
		<entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
			<explicit name="knot_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="knot_spec">
				<typename name="knot_type"/>
			</explicit>
			<derived name="upper_index_on_knots" expression="SIZEOF(knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots)">
        </where>
			<where label="WR2" expression="SIZEOF(knot_multiplicities) = upper_index_on_knots">
        </where>
		</entity>
		<entity name="b_spline_surface" super.expression="(ONEOF ( B_SPLINE_SURFACE_WITH_KNOTS, UNIFORM_SURFACE, QUASI_UNIFORM_SURFACE, BEZIER_SURFACE) ANDOR RATIONAL_B_SPLINE_SURFACE)" supertypes="bounded_surface">
			<explicit name="u_degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="v_degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="control_points_list">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="LIST"/>
			</explicit>
			<explicit name="surface_form">
				<typename name="b_spline_surface_form"/>
			</explicit>
			<explicit name="u_closed">
				<builtintype type="LOGICAL"/>
			</explicit>
			<explicit name="v_closed">
				<builtintype type="LOGICAL"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
			<derived name="u_upper" expression="SIZEOF(control_points_list) - 1">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="v_upper" expression="SIZEOF(control_points_list[1]) - 1">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="control_points" expression="make_array_of_array(control_points_list,0,u_upper,0,v_upper)">
				<aggregate type="ARRAY" lower="0" upper="100"/>
				<typename name="ARRAY"/>
			</derived>
			<where label="WR1" expression="('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))">
        </where>
		</entity>
		<entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
			<explicit name="u_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="v_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="u_knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v_knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="knot_spec">
				<typename name="knot_type"/>
			</explicit>
			<derived name="knot_u_upper" expression="SIZEOF(u_knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="knot_v_upper" expression="SIZEOF(v_knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots)">
        </where>
			<where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots)">
        </where>
			<where label="WR3" expression="SIZEOF(u_multiplicities) = knot_u_upper">
        </where>
			<where label="WR4" expression="SIZEOF(v_multiplicities) = knot_v_upper">
        </where>
		</entity>
		<entity name="b_spline_volume" super.expression="(ONEOF ( B_SPLINE_VOLUME_WITH_KNOTS, UNIFORM_VOLUME, QUASI_UNIFORM_VOLUME, BEZIER_VOLUME) ANDOR RATIONAL_B_SPLINE_VOLUME)" supertypes="volume">
			<explicit name="u_degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="v_degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="w_degree">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="control_points_list">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="LIST"/>
			</explicit>
			<derived name="u_upper" expression="SIZEOF(control_points_list) - 1">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="v_upper" expression="SIZEOF(control_points_list[1]) - 1">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="w_upper" expression="SIZEOF(control_points_list[1][1]) - 1">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="control_points" expression="make_array_of_array_of_array (control_points_list,0,u_upper,0,v_upper,0,w_upper)">
				<aggregate type="ARRAY" lower="0" upper="100"/>
				<typename name="ARRAY"/>
			</derived>
			<where label="WR1" expression="('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF))">
        </where>
		</entity>
		<entity name="b_spline_volume_with_knots" supertypes="b_spline_volume">
			<explicit name="u_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="v_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="w_multiplicities">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="u_knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v_knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="w_knots">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="parameter_value"/>
			</explicit>
			<derived name="knot_u_upper" expression="SIZEOF(u_knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="knot_v_upper" expression="SIZEOF(v_knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="knot_w_upper" expression="SIZEOF(w_knots)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper, u_multiplicities, u_knots)">
        </where>
			<where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper, v_multiplicities, v_knots)">
        </where>
			<where label="WR3" expression="constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper, w_multiplicities, w_knots)">
        </where>
			<where label="WR4" expression="SIZEOF(u_multiplicities) = knot_u_upper">
        </where>
			<where label="WR5" expression="SIZEOF(v_multiplicities) = knot_v_upper">
        </where>
			<where label="WR6" expression="SIZEOF(w_multiplicities) = knot_w_upper">
        </where>
		</entity>
		<entity name="bezier_curve" supertypes="b_spline_curve">
      </entity>
		<entity name="bezier_surface" supertypes="b_spline_surface">
      </entity>
		<entity name="bezier_volume" supertypes="b_spline_volume">
      </entity>
		<entity name="block" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="x">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="y">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="z">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="block_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="x">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="y">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="z">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="boolean_result" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="operator">
				<typename name="boolean_operator"/>
			</explicit>
			<explicit name="first_operand">
				<typename name="boolean_operand"/>
			</explicit>
			<explicit name="second_operand">
				<typename name="boolean_operand"/>
			</explicit>
		</entity>
		<entity name="boundary_curve" supertypes="composite_curve_on_surface">
			<where label="WR1" expression="SELF\composite_curve.closed_curve">
        </where>
		</entity>
		<entity name="bounded_curve" super.expression="(ONEOF ( POLYLINE, B_SPLINE_CURVE, TRIMMED_CURVE, BOUNDED_PCURVE, BOUNDED_SURFACE_CURVE, COMPOSITE_CURVE))" supertypes="curve">
      </entity>
		<entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
			<where label="WR1" expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]))">
        </where>
		</entity>
		<entity name="bounded_surface" super.expression="(ONEOF ( B_SPLINE_SURFACE, RECTANGULAR_TRIMMED_SURFACE, CURVE_BOUNDED_SURFACE, RECTANGULAR_COMPOSITE_SURFACE))" supertypes="surface">
      </entity>
		<entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
			<where label="WR1" expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d))">
        </where>
		</entity>
		<entity name="box_domain" supertypes="founded_item">
			<explicit name="corner">
				<typename name="CARTESIAN_POINT"/>
			</explicit>
			<explicit name="xlength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ylength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="zlength">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(item &lt;* USEDIN(SELF,'')| NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0">
        </where>
		</entity>
		<entity name="boxed_half_space" supertypes="half_space_solid">
			<explicit name="enclosure">
				<typename name="box_domain"/>
			</explicit>
		</entity>
		<entity name="breakdown_context" supertypes="product_definition_relationship">
      </entity>
		<entity name="breakdown_element_group_assignment" supertypes="group_assignment">
			<explicit name="assigned_group">
				<typename name="product_definition_element_relationship"/>
				<redeclaration entity-ref="group_assignment"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="1"/>
				<typename name="product_definition_or_breakdown_element_usage"/>
			</explicit>
		</entity>
		<entity name="breakdown_element_realization" supertypes="CHARACTERIZED_OBJECT product_definition_element_relationship">
        </entity>
		<entity name="breakdown_element_usage" supertypes="product_definition_relationship">
        </entity>
		<entity name="breakdown_of" supertypes="product_definition_relationship">
        </entity>
		<entity name="brep_2d" supertypes="solid_model">
			<explicit name="extent">
				<typename name="FACE"/>
			</explicit>
			<where label="WR1" expression="SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE','TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] * TYPEOF (SELF.extent)) = 0">
          </where>
			<where label="WR2" expression="SIZEOF (QUERY (bnds &lt;* extent.bounds | NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))) = 0">
          </where>
			<where label="WR3" expression="SIZEOF (QUERY (bnds &lt;* extent.bounds |'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1">
          </where>
			<where label="WR4" expression="SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* extent.bounds |'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT(('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND(oe.edge_element\geometric_representation_item.dim = 2)))) =0))) = 0">
          </where>
		</entity>
		<entity name="brep_with_voids" supertypes="manifold_solid_brep">
			<explicit name="voids">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="ORIENTED_CLOSED_SHELL"/>
			</explicit>
		</entity>
		<entity name="calendar_date" supertypes="date">
			<explicit name="day_component">
				<typename name="day_in_month_number"/>
			</explicit>
			<explicit name="month_component">
				<typename name="month_in_year_number"/>
			</explicit>
			<where label="WR1" expression="valid_calendar_date (SELF)">
          </where>
		</entity>
		<entity name="cartesian_point" super.expression="(ONEOF ( CYLINDRICAL_POINT, POLAR_POINT, SPHERICAL_POINT))" supertypes="point">
			<explicit name="coordinates">
				<aggregate type="LIST" lower="1" upper="3"/>
				<typename name="length_measure"/>
			</explicit>
		</entity>
		<entity name="cartesian_transformation_operator" super.expression="(ONEOF ( CARTESIAN_TRANSFORMATION_OPERATOR_2D, CARTESIAN_TRANSFORMATION_OPERATOR_3D))" supertypes="geometric_representation_item functionally_defined_transformation">
			<explicit name="axis1" optional="YES">
				<typename name="direction"/>
			</explicit>
			<explicit name="axis2" optional="YES">
				<typename name="direction"/>
			</explicit>
			<explicit name="local_origin">
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="scale" optional="YES">
				<builtintype type="REAL"/>
			</explicit>
			<derived name="scl" expression="NVL(scale, 1.0)">
				<builtintype type="REAL"/>
			</derived>
			<where label="WR1" expression="scl &gt; 0.0">
          </where>
		</entity>
		<entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
			<derived name="u" expression="base_axis(2,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,?)">
				<aggregate type="LIST" lower="2" upper="2"/>
				<typename name="direction"/>
			</derived>
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 2">
          </where>
		</entity>
		<entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
			<explicit name="axis3" optional="YES">
				<typename name="direction"/>
			</explicit>
			<derived name="u" expression="base_axis(3,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,axis3)">
				<aggregate type="LIST" lower="3" upper="3"/>
				<typename name="direction"/>
			</derived>
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 3">
          </where>
		</entity>
		<entity name="celsius_temperature_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
          </where>
		</entity>
		<entity name="centre_of_symmetry" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF(QUERY(sadr&lt;*SELF\derived_shape_aspect.deriving_relationships| NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(sadr\shape_aspect_relationship.related_shape_aspect))))=0">
          </where>
		</entity>
		<entity name="certification">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="purpose">
				<typename name="text"/>
			</explicit>
			<explicit name="kind">
				<typename name="certification_type"/>
			</explicit>
		</entity>
		<entity name="certification_assignment" abstract.supertype="YES">
			<explicit name="assigned_certification">
				<typename name="CERTIFICATION"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
          </where>
		</entity>
		<entity name="certification_type">
			<explicit name="description">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="characterized_class" supertypes="characterized_object CLASS">
        </entity>
		<entity name="characterized_object">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="characterized_object_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_object">
				<typename name="characterized_object"/>
			</explicit>
			<explicit name="related_object">
				<typename name="characterized_object"/>
			</explicit>
		</entity>
		<entity name="circle" supertypes="conic">
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="circular_area" supertypes="primitive_2d">
			<explicit name="centre">
				<typename name="CARTESIAN_POINT"/>
			</explicit>
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="circular_involute" supertypes="curve">
			<explicit name="position">
				<typename name="axis2_placement"/>
			</explicit>
			<explicit name="base_radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="class" supertypes="group">
        </entity>
		<entity name="class_by_extension" supertypes="class">
        </entity>
		<entity name="class_by_intension" supertypes="class">
        </entity>
		<entity name="class_system" supertypes="group">
        </entity>
		<entity name="class_usage_effectivity_context_assignment" supertypes="EFFECTIVITY_CONTEXT_ASSIGNMENT">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="class_usage_effectivity_context_item"/>
			</explicit>
			<where label="WR1" expression="SELF.role.name = 'class usage influence'">
          </where>
			<where label="WR2" expression="SIZEOF(QUERY(i &lt;* SELF.items | NOT ('SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)))) = 0">
          </where>
			<where label="WR3" expression="('SPECIFICATION_CONTROL_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND(SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity)) = 1) AND(SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND(SIZEOF(QUERY(i &lt;* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | NOT('SPECIFICATION_CONTROL_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)))) = 0)">
          </where>
		</entity>
		<entity name="classification" supertypes="classification_assignment">
			<explicit name="classified">
				<typename name="classification_select"/>
			</explicit>
			<derived name="classifier" expression="SELF\classification_assignment.assigned_class">
				<typename name="class"/>
			</derived>
		</entity>
		<entity name="classification_assignment" abstract.supertype="YES">
			<explicit name="assigned_class">
				<typename name="GROUP"/>
			</explicit>
			<explicit name="role">
				<typename name="classification_role"/>
			</explicit>
		</entity>
		<entity name="classification_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="closed_shell" supertypes="connected_face_set">
        </entity>
		<entity name="clothoid" supertypes="curve">
			<explicit name="position">
				<typename name="axis2_placement"/>
			</explicit>
			<explicit name="clothoid_constant">
				<typename name="length_measure"/>
			</explicit>
		</entity>
		<entity name="complete_membership" supertypes="classification_assignment">
			<derived name="containing_set" expression="SELF\classification_assignment.assigned_class">
				<typename name="class"/>
			</derived>
		</entity>
		<entity name="complete_membership_of_empty_set" supertypes="complete_membership">
        </entity>
		<entity name="complete_membership_of_non_empty_set" supertypes="complete_membership">
			<explicit name="members">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="complete_membership_select"/>
			</explicit>
		</entity>
		<entity name="composite_curve" supertypes="bounded_curve">
			<explicit name="segments">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="composite_curve_segment"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
			<derived name="n_segments" expression="SIZEOF(segments)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="closed_curve" expression="segments[n_segments].transition &lt;&gt; discontinuous">
				<builtintype type="LOGICAL"/>
			</derived>
			<where label="WR1" expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 1)) OR((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 0))">
          </where>
		</entity>
		<entity name="composite_curve_on_surface" supertypes="composite_curve">
			<derived name="basis_surface" expression="get_basis_surface(SELF)">
				<aggregate type="SET" lower="0" upper="2"/>
				<typename name="surface"/>
			</derived>
			<where label="WR1" expression="SIZEOF(basis_surface) &gt; 0">
          </where>
			<where label="WR2" expression="constraints_composite_curve_on_surface(SELF)">
          </where>
		</entity>
		<entity name="composite_curve_segment" supertypes="founded_item">
			<explicit name="transition">
				<typename name="transition_code"/>
			</explicit>
			<explicit name="same_sense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<explicit name="parent_curve">
				<typename name="curve"/>
			</explicit>
			<inverse name="using_curves" entity="composite_curve" attribute="segments">
				<inverse.aggregate type="BAG" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))">
          </where>
		</entity>
		<entity name="composite_shape_aspect" supertypes="shape_aspect">
			<inverse name="component_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
				<inverse.aggregate type="SET" lower="2" upper="?"/>
			</inverse>
		</entity>
		<entity name="compound_representation_item" supertypes="representation_item">
			<explicit name="item_element">
				<typename name="compound_item_definition"/>
			</explicit>
		</entity>
		<entity name="concept_feature_operator">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="concept_feature_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_product_concept_feature">
				<typename name="product_concept_feature"/>
			</explicit>
			<explicit name="related_product_concept_feature">
				<typename name="product_concept_feature"/>
			</explicit>
		</entity>
		<entity name="concept_feature_relationship_with_condition" supertypes="concept_feature_relationship">
			<explicit name="conditional_operator">
				<typename name="concept_feature_operator"/>
			</explicit>
		</entity>
		<entity name="conditional_concept_feature" supertypes="product_concept_feature">
			<explicit name="condition">
				<typename name="concept_feature_relationship_with_condition"/>
			</explicit>
		</entity>
		<entity name="configurable_item" supertypes="configuration_item">
			<explicit name="item_concept_feature">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product_concept_feature_association"/>
			</explicit>
		</entity>
		<entity name="configuration_design">
			<explicit name="configuration">
				<typename name="configuration_item"/>
			</explicit>
			<explicit name="design">
				<typename name="configuration_design_item"/>
			</explicit>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<unique label="UR1">
				<unique.attribute attribute="configuration"/>
				<unique.attribute attribute="design"/>
			</unique>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
          </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
          </where>
		</entity>
		<entity name="configuration_effectivity" supertypes="product_definition_effectivity">
			<explicit name="configuration">
				<typename name="configuration_design"/>
			</explicit>
			<where label="WR1" expression="'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN TYPEOF (SELF\product_definition_effectivity.usage)">
          </where>
		</entity>
		<entity name="configuration_item">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="item_concept">
				<typename name="product_concept"/>
			</explicit>
			<explicit name="purpose" optional="YES">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="configuration_item_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_configuration_item">
				<typename name="configuration_item"/>
			</explicit>
			<explicit name="related_configuration_item">
				<typename name="configuration_item"/>
			</explicit>
		</entity>
		<entity name="configured_effectivity_assignment" supertypes="EFFECTIVITY_ASSIGNMENT">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="configured_effectivity_item"/>
			</explicit>
			<where label="WR1" expression="(SIZEOF(['SPECIFICATION_BASED_CONFIGURATION_MIM.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity)) = 1) AND (SELF.assigned_effectivity.id = 'configuration validity')">
          </where>
			<where label="WR2" expression="SIZEOF(SELF.items) = 1">
          </where>
			<where label="WR3" expression="SIZEOF(QUERY(i &lt;* SELF.items | NOT ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']))) = 0">
          </where>
			<where label="WR4" expression="SELF.role.name IN ['design', 'usage']">
          </where>
			<where label="WR5" expression="(SELF.role.name &lt;&gt; 'design') OR (SIZEOF(QUERY(i &lt;* SELF.items | ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence'))) = 0)">
          </where>
			<where label="WR6" expression="(SELF.role.name &lt;&gt; 'usage') OR (SIZEOF(QUERY(i &lt;* SELF.items | ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition'))) = 0)">
          </where>
			<where label="WR7" expression="SELF.role.description IN ['exception', 'inherited', 'local']">
          </where>
			<where label="WR8" expression="SIZEOF(QUERY(x &lt;* USEDIN(SELF,'SPECIFICATION_BASED_CONFIGURATION_MIM.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'SPECIFICATION_BASED_CONFIGURATION_MIM.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x))) = 1">
          </where>
		</entity>
		<entity name="configured_effectivity_context_assignment" supertypes="effectivity_context_assignment">
			<explicit name="assigned_effectivity_assignment">
				<typename name="configured_effectivity_assignment"/>
				<redeclaration entity-ref="effectivity_context_assignment"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="configured_effectivity_context_item"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(SELF.items) = 1">
            </where>
		</entity>
		<entity name="conic" super.expression="(ONEOF ( CIRCLE, ELLIPSE, HYPERBOLA, PARABOLA))" supertypes="curve">
			<explicit name="position">
				<typename name="axis2_placement"/>
			</explicit>
		</entity>
		<entity name="conical_surface" supertypes="elementary_surface">
			<explicit name="radius">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="semi_angle">
				<typename name="plane_angle_measure"/>
			</explicit>
			<where label="WR1" expression="radius &gt;= 0.0">
            </where>
		</entity>
		<entity name="connected_edge_set" supertypes="topological_representation_item">
			<explicit name="ces_edges">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="edge"/>
			</explicit>
		</entity>
		<entity name="connected_face_set" super.expression="(ONEOF ( CLOSED_SHELL, OPEN_SHELL) ANDOR CONNECTED_FACE_SUB_SET)" supertypes="topological_representation_item">
			<explicit name="cfs_faces">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="face"/>
			</explicit>
		</entity>
		<entity name="connected_face_sub_set" supertypes="connected_face_set">
			<explicit name="parent_face_set">
				<typename name="connected_face_set"/>
			</explicit>
		</entity>
		<entity name="constructive_geometry_representation" supertypes="representation">
			<where label="WR1" expression="('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 &lt;= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension &lt;= 3})">
            </where>
			<where label="WR2" expression="SIZEOF(QUERY(cgr_i &lt;* SELF.items | SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.PLACEMENT', 'CONSTRUCTION_GEOMETRY_MIM.CURVE', 'CONSTRUCTION_GEOMETRY_MIM.EDGE', 'CONSTRUCTION_GEOMETRY_MIM.FACE', 'CONSTRUCTION_GEOMETRY_MIM.POINT', 'CONSTRUCTION_GEOMETRY_MIM.SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.FACE_SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.VERTEX_POINT'] * TYPEOF(cgr_i)) &lt;&gt; 1)) = 0">
            </where>
			<where label="WR3" expression="SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2')) &gt; 0">
            </where>
			<where label="WR4" expression="SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) = 0">
            </where>
		</entity>
		<entity name="constructive_geometry_representation_relationship" supertypes="representation_relationship">
			<where label="WR1" expression="(SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items))">
            </where>
			<where label="WR2" expression="'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2)">
            </where>
			<where label="WR3" expression="SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.SHAPE_REPRESENTATION', 'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1">
            </where>
			<where label="WR4" expression="NOT('CONSTRUCTION_GEOMETRY_MIM.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF))">
            </where>
		</entity>
		<entity name="contact_ratio_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="(SIZEOF (SELF.items) =1) AND (SIZEOF (QUERY (i &lt;* SELF.items | (SIZEOF (['SURFACE_CONDITIONS_MIM.'+'MEASURE_REPRESENTATION_ITEM' , 'SURFACE_CONDITIONS_MIM.'+'VALUE_RANGE']* TYPEOF (i)) =1) AND (i.name ='ratio value'))) =1)">
            </where>
			<where label="WR2" expression="(SIZEOF (QUERY (pdr &lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | pdr. name ='contact ratio reference')) =1) AND (SIZEOF (QUERY (pdr &lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | (pdr. name ='contact ratio reference') AND ('SURFACE_CONDITIONS_MIM.'+'PHYSICALLY_MODELLED_PRODUCT_DEFINITION' IN TYPEOF (pdr. definition.definition)))) =1)">
            </where>
			<where label="WR3" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION')) =1) AND (SIZEOF (QUERY (pdr&lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | SIZEOF (QUERY (gpa &lt;* USEDIN (pdr. definition ,'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+'DERIVED_DEFINITION') | ('SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY' IN TYPEOF (gpa. base_definition)) AND(gpa. base_definition.name ='surface_condition'))) =1)) =1)">
            </where>
		</entity>
		<entity name="context_dependent_shape_representation">
			<explicit name="representation_relation">
				<typename name="shape_representation_relationship"/>
			</explicit>
			<explicit name="represented_product_relation">
				<typename name="product_definition_shape"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<where label="WR1" expression="'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition)">
            </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
            </where>
			<where label="WR3" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
            </where>
		</entity>
		<entity name="context_dependent_unit" supertypes="named_unit">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
		</entity>
		<entity name="contract">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="purpose">
				<typename name="text"/>
			</explicit>
			<explicit name="kind">
				<typename name="contract_type"/>
			</explicit>
		</entity>
		<entity name="contract_assignment" abstract.supertype="YES">
			<explicit name="assigned_contract">
				<typename name="CONTRACT"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
            </where>
		</entity>
		<entity name="contract_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_contract">
				<typename name="contract"/>
			</explicit>
			<explicit name="related_contract">
				<typename name="contract"/>
			</explicit>
		</entity>
		<entity name="contract_type">
			<explicit name="description">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="conversion_based_unit" supertypes="named_unit">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="conversion_factor">
				<typename name="measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="convex_hexahedron" supertypes="faceted_primitive">
			<where label="WR1" expression="SIZEOF(points) = 8">
            </where>
			<where label="WR2" expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0">
            </where>
			<where label="WR3" expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0">
            </where>
			<where label="WR4" expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0">
            </where>
			<where label="WR5" expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0">
            </where>
			<where label="WR6" expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0">
            </where>
			<where label="WR7" expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0">
            </where>
			<where label="WR8" expression="same_side([points[1], points[2], points[3]],[points[5], points[6], points[7], points[8]])">
            </where>
			<where label="WR9" expression="same_side([points[1], points[4], points[8]],[points[3], points[7], points[6], points[2]])">
            </where>
			<where label="WR10" expression="same_side([points[1], points[2], points[5]],[points[3], points[7], points[8], points[4]])">
            </where>
			<where label="WR11" expression="same_side([points[5], points[6], points[7]],[points[1], points[2], points[3], points[4]])">
            </where>
			<where label="WR12" expression="same_side([points[3], points[7], points[6]],[points[1], points[4], points[8], points[5]])">
            </where>
			<where label="WR13" expression="same_side([points[3], points[7], points[8]],[points[1], points[5], points[6], points[2]])">
            </where>
		</entity>
		<entity name="coordinated_universal_time_offset">
			<explicit name="hour_offset">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="minute_offset" optional="YES">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="sense">
				<typename name="ahead_or_behind"/>
			</explicit>
			<derived name="actual_minute_offset" expression="NVL(minute_offset,0)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="{ 0 &lt;= hour_offset &lt; 24 }">
            </where>
			<where label="WR2" expression="{ 0 &lt;= actual_minute_offset &lt;= 59 }">
            </where>
			<where label="WR3" expression="NOT (((hour_offset &lt;&gt; 0) OR (actual_minute_offset &lt;&gt;0)) AND (sense = exact))">
            </where>
		</entity>
		<entity name="csg_solid" supertypes="solid_model">
			<explicit name="tree_root_expression">
				<typename name="csg_select"/>
			</explicit>
		</entity>
		<entity name="curve" super.expression="(ONEOF ( LINE, CONIC, CLOTHOID, CIRCULAR_INVOLUTE, PCURVE, SURFACE_CURVE, OFFSET_CURVE_2D, OFFSET_CURVE_3D, CURVE_REPLICA) ANDOR BOUNDED_CURVE)" supertypes="geometric_representation_item">
          </entity>
		<entity name="curve_bounded_surface" supertypes="bounded_surface">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="boundaries">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="boundary_curve"/>
			</explicit>
			<explicit name="implicit_outer">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<where label="WR1" expression="(NOT implicit_outer) OR(SIZEOF (QUERY (temp &lt;* boundaries |'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)">
            </where>
			<where label="WR2" expression="(NOT(implicit_outer)) OR('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface))">
            </where>
			<where label="WR3" expression="SIZEOF(QUERY(temp &lt;* boundaries |'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) &lt;= 1">
            </where>
			<where label="WR4" expression="SIZEOF(QUERY(temp &lt;* boundaries |(temp\composite_curve_on_surface.basis_surface [1] &lt;&gt; SELF.basis_surface))) = 0">
            </where>
		</entity>
		<entity name="curve_replica" supertypes="curve">
			<explicit name="parent_curve">
				<typename name="curve"/>
			</explicit>
			<explicit name="transformation">
				<typename name="cartesian_transformation_operator"/>
			</explicit>
			<where label="WR1" expression="transformation.dim = parent_curve.dim">
            </where>
			<where label="WR2" expression="acyclic_curve_replica (SELF, parent_curve)">
            </where>
		</entity>
		<entity name="cyclide_segment_solid" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="radius1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="radius2">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="cone_angle1">
				<typename name="plane_angle_measure"/>
			</explicit>
			<explicit name="cone_angle2">
				<typename name="plane_angle_measure"/>
			</explicit>
			<explicit name="turn_angle">
				<typename name="plane_angle_measure"/>
			</explicit>
		</entity>
		<entity name="cylindrical_point" supertypes="cartesian_point">
			<explicit name="r">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="theta">
				<typename name="plane_angle_measure"/>
			</explicit>
			<explicit name="z">
				<typename name="length_measure"/>
			</explicit>
			<derived name="coordinates" expression="[r*cos(theta), r*sin(theta), z]">
				<aggregate type="LIST" lower="1" upper="3"/>
				<typename name="length_measure"/>
				<redeclaration entity-ref="cartesian_point"/>
			</derived>
			<where label="WR1" expression="r &gt;= 0.0">
              </where>
		</entity>
		<entity name="cylindrical_surface" supertypes="elementary_surface">
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="cylindrical_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="data_environment">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="elements">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="property_definition_representation"/>
			</explicit>
		</entity>
		<entity name="data_environment_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_data_environment">
				<typename name="data_environment"/>
			</explicit>
			<explicit name="related_data_environment">
				<typename name="data_environment"/>
			</explicit>
		</entity>
		<entity name="date" super.expression="(ONEOF ( CALENDAR_DATE, ORDINAL_DATE, WEEK_OF_YEAR_AND_DAY_DATE))">
			<explicit name="year_component">
				<typename name="year_number"/>
			</explicit>
		</entity>
		<entity name="date_and_time">
			<explicit name="date_component">
				<typename name="date"/>
			</explicit>
			<explicit name="time_component">
				<typename name="local_time"/>
			</explicit>
		</entity>
		<entity name="date_and_time_assignment" abstract.supertype="YES">
			<explicit name="assigned_date_and_time">
				<typename name="DATE_AND_TIME"/>
			</explicit>
			<explicit name="role">
				<typename name="DATE_TIME_ROLE"/>
			</explicit>
		</entity>
		<entity name="date_assignment" abstract.supertype="YES">
			<explicit name="assigned_date">
				<typename name="DATE"/>
			</explicit>
			<explicit name="role">
				<typename name="DATE_ROLE"/>
			</explicit>
		</entity>
		<entity name="date_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
              </where>
		</entity>
		<entity name="date_time_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
              </where>
		</entity>
		<entity name="dated_effectivity" supertypes="effectivity">
			<explicit name="effectivity_end_date" optional="YES">
				<typename name="date_time_or_event_occurrence"/>
			</explicit>
			<explicit name="effectivity_start_date">
				<typename name="date_time_or_event_occurrence"/>
			</explicit>
		</entity>
		<entity name="datum" supertypes="shape_aspect">
			<explicit name="identification">
				<typename name="identifier"/>
			</explicit>
			<inverse name="established_by_relationships" entity="shape_aspect_relationship" attribute="related_shape_aspect">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="SIZEOF (QUERY (x&lt;*SELF\datum.established_by_relationships | SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)*['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE','SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET']) &lt;&gt; 1))=0">
              </where>
		</entity>
		<entity name="datum_feature" supertypes="shape_aspect">
			<inverse name="feature_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
              </inverse>
			<where label="WR1" expression="SIZEOF (QUERY (sar&lt;* bag_to_set (USEDIN (SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'+'RELATING_SHAPE_ASPECT'))| NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))))=0">
              </where>
			<where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE">
              </where>
		</entity>
		<entity name="datum_reference">
			<explicit name="precedence">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="referenced_datum">
				<typename name="datum"/>
			</explicit>
			<where label="WR1" expression="precedence &gt; 0">
              </where>
		</entity>
		<entity name="datum_target" supertypes="shape_aspect">
			<explicit name="target_id">
				<typename name="identifier"/>
			</explicit>
			<inverse name="target_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
              </inverse>
			<where label="WR1" expression="SIZEOF (QUERY (sar&lt;* bag_to_set (USEDIN (SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +'RELATING_SHAPE_ASPECT'))| NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))))=0">
              </where>
			<where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE">
              </where>
		</entity>
		<entity name="definitional_representation" supertypes="representation">
			<where label="WR1" expression="'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (SELF\representation.context_of_items)">
              </where>
		</entity>
		<entity name="degenerate_pcurve" supertypes="point">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="reference_to_curve">
				<typename name="definitional_representation"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(reference_to_curve\representation.items) = 1">
              </where>
			<where label="WR2" expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1])">
              </where>
			<where label="WR3" expression="reference_to_curve\representation. items[1]\geometric_representation_item.dim =2">
              </where>
		</entity>
		<entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
			<explicit name="select_outer">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<where label="WR1" expression="major_radius &lt; minor_radius">
              </where>
		</entity>
		<entity name="derived_shape_aspect" super.expression="(ONEOF ( APEX, CENTRE_OF_SYMMETRY, GEOMETRIC_ALIGNMENT, GEOMETRIC_INTERSECTION, PARALLEL_OFFSET, PERPENDICULAR_TO, EXTENSION, TANGENT))" supertypes="shape_aspect">
			<inverse name="deriving_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="SIZEOF (QUERY (dr &lt;* SELF\derived_shape_aspect.deriving_relationships | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.' +'SHAPE_ASPECT_DERIVING_RELATIONSHIP' IN TYPEOF (dr)))) = 0">
              </where>
		</entity>
		<entity name="derived_unit">
			<explicit name="elements">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="derived_unit_element"/>
			</explicit>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="LABEL"/>
			</derived>
			<where label="WR1" expression="(SIZEOF (elements) &gt; 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent &lt;&gt; 1.0))">
              </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
              </where>
		</entity>
		<entity name="derived_unit_element">
			<explicit name="unit">
				<typename name="named_unit"/>
			</explicit>
			<explicit name="exponent">
				<builtintype type="REAL"/>
			</explicit>
		</entity>
		<entity name="description_attribute">
			<explicit name="attribute_value">
				<typename name="text"/>
			</explicit>
			<explicit name="described_item">
				<typename name="description_attribute_select"/>
			</explicit>
		</entity>
		<entity name="descriptive_representation_item" supertypes="representation_item">
			<explicit name="description">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="dimension_related_tolerance_zone_element">
			<explicit name="related_dimension">
				<typename name="dimensional_location"/>
			</explicit>
			<explicit name="related_element">
				<typename name="tolerance_zone_definition"/>
			</explicit>
		</entity>
		<entity name="dimensional_characteristic_representation">
			<explicit name="dimension">
				<typename name="dimensional_characteristic"/>
			</explicit>
			<explicit name="representation">
				<typename name="shape_dimension_representation"/>
			</explicit>
		</entity>
		<entity name="dimensional_exponents">
			<explicit name="length_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="mass_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="time_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="electric_current_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="thermodynamic_temperature_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="amount_of_substance_exponent">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="luminous_intensity_exponent">
				<builtintype type="REAL"/>
			</explicit>
		</entity>
		<entity name="dimensional_location" super.expression="(ONEOF ( ANGULAR_LOCATION, DIMENSIONAL_LOCATION_WITH_PATH))" supertypes="shape_aspect_relationship">
            </entity>
		<entity name="dimensional_location_with_path" supertypes="dimensional_location">
			<explicit name="path">
				<typename name="shape_aspect"/>
			</explicit>
		</entity>
		<entity name="dimensional_size" super.expression="(ONEOF ( ANGULAR_SIZE, DIMENSIONAL_SIZE_WITH_PATH))">
			<explicit name="applies_to">
				<typename name="shape_aspect"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<where label="WR1" expression="applies_to.product_definitional = TRUE">
              </where>
		</entity>
		<entity name="dimensional_size_with_path" supertypes="dimensional_size">
			<explicit name="path">
				<typename name="shape_aspect"/>
			</explicit>
		</entity>
		<entity name="directed_action" supertypes="executed_action">
			<explicit name="directive">
				<typename name="action_directive"/>
			</explicit>
		</entity>
		<entity name="directed_dimensional_location" supertypes="DIMENSIONAL_LOCATION">
            </entity>
		<entity name="direction" supertypes="geometric_representation_item">
			<explicit name="direction_ratios">
				<aggregate type="LIST" lower="2" upper="3"/>
				<builtintype type="REAL"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0">
              </where>
		</entity>
		<entity name="document">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="kind">
				<typename name="document_type"/>
			</explicit>
			<inverse name="representation_types" entity="document_representation_type" attribute="represented_document">
				<inverse.aggregate type="SET" lower="0" upper="?"/>
			</inverse>
		</entity>
		<entity name="document_file" supertypes="document characterized_object">
			<where label="WR1" expression="SELF\characterized_object.name = ''">
              </where>
			<where label="WR2" expression="NOT EXISTS(SELF\characterized_object.description)">
              </where>
			<where label="WR3" expression="SIZEOF(QUERY(drt &lt;* SELF\document.representation_types | drt.name IN ['digital','physical'])) = 1">
              </where>
		</entity>
		<entity name="document_product_association">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_document">
				<typename name="document"/>
			</explicit>
			<explicit name="related_product">
				<typename name="product_or_formation_or_definition"/>
			</explicit>
		</entity>
		<entity name="document_product_equivalence" supertypes="document_product_association">
			<where label="WR1" expression="SELF\document_product_association.name = 'equivalence'">
              </where>
			<where label="WR2" expression="NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF(QUERY(prpc &lt;* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1))">
              </where>
			<where label="WR3" expression="NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF(QUERY(prpc &lt;* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1))">
              </where>
			<where label="WR4" expression="NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF(QUERY(prpc &lt;* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1))">
              </where>
		</entity>
		<entity name="document_reference" abstract.supertype="YES">
			<explicit name="assigned_document">
				<typename name="DOCUMENT"/>
			</explicit>
			<explicit name="source">
				<typename name="LABEL"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
              </where>
		</entity>
		<entity name="document_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_document">
				<typename name="document"/>
			</explicit>
			<explicit name="related_document">
				<typename name="document"/>
			</explicit>
		</entity>
		<entity name="document_representation_type">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="represented_document">
				<typename name="document"/>
			</explicit>
		</entity>
		<entity name="document_type">
			<explicit name="product_data_type">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="document_usage_constraint">
			<explicit name="source">
				<typename name="document"/>
			</explicit>
			<explicit name="subject_element">
				<typename name="label"/>
			</explicit>
			<explicit name="subject_element_value">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="document_usage_constraint_assignment" abstract.supertype="YES">
			<explicit name="assigned_document_usage">
				<typename name="DOCUMENT_USAGE_CONSTRAINT"/>
			</explicit>
			<explicit name="role">
				<typename name="document_usage_role"/>
			</explicit>
		</entity>
		<entity name="document_usage_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="document_with_class" supertypes="document">
			<explicit name="class">
				<typename name="identifier"/>
			</explicit>
		</entity>
		<entity name="dupin_cyclide_surface" supertypes="elementary_surface">
			<explicit name="generalised_major_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="generalised_minor_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="skewness">
				<typename name="length_measure"/>
			</explicit>
			<where label="WR1" expression="skewness &gt;= 0.0">
              </where>
		</entity>
		<entity name="eccentric_cone" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="x_offset">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="y_offset">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="ratio">
				<builtintype type="REAL"/>
			</explicit>
			<where label="WR1" expression="ratio &gt;= 0.0">
              </where>
		</entity>
		<entity name="eccentric_conical_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="x_offset">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="y_offset">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="ratio">
				<builtintype type="REAL"/>
			</explicit>
			<where label="WR1" expression="ratio &gt;= 0.0">
              </where>
		</entity>
		<entity name="edge" super.expression="(ONEOF ( EDGE_CURVE, ORIENTED_EDGE, SUBEDGE))" supertypes="topological_representation_item">
			<explicit name="edge_start">
				<typename name="vertex"/>
			</explicit>
			<explicit name="edge_end">
				<typename name="vertex"/>
			</explicit>
		</entity>
		<entity name="edge_based_wireframe_model" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="ebwm_boundary">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="CONNECTED_EDGE_SET"/>
			</explicit>
		</entity>
		<entity name="edge_curve" supertypes="edge GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="edge_geometry">
				<typename name="CURVE"/>
			</explicit>
			<explicit name="same_sense">
				<builtintype type="BOOLEAN"/>
			</explicit>
		</entity>
		<entity name="edge_loop" supertypes="loop path">
			<derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="(SELF\path.edge_list[1].edge_start) :=:(SELF\path.edge_list[ne].edge_end)">
              </where>
		</entity>
		<entity name="effectivity" super.expression="(ONEOF ( SERIAL_NUMBERED_EFFECTIVITY, DATED_EFFECTIVITY, LOT_EFFECTIVITY, TIME_INTERVAL_BASED_EFFECTIVITY))">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<derived name="name" expression="get_name_value(SELF)">
				<typename name="label"/>
			</derived>
			<derived name="description" expression="get_description_value(SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
              </where>
			<where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
              </where>
		</entity>
		<entity name="effectivity_assignment" abstract.supertype="YES">
			<explicit name="assigned_effectivity">
				<typename name="EFFECTIVITY"/>
			</explicit>
			<derived name="role" expression="get_role(SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
              </where>
		</entity>
		<entity name="effectivity_context_assignment" abstract.supertype="YES">
			<explicit name="assigned_effectivity_assignment">
				<typename name="effectivity_assignment"/>
			</explicit>
			<explicit name="role">
				<typename name="effectivity_context_role"/>
			</explicit>
		</entity>
		<entity name="effectivity_context_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="effectivity_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="related_effectivity">
				<typename name="effectivity"/>
			</explicit>
			<explicit name="relating_effectivity">
				<typename name="effectivity"/>
			</explicit>
		</entity>
		<entity name="electric_current_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
              </where>
		</entity>
		<entity name="electric_current_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
              </where>
		</entity>
		<entity name="elementary_surface" super.expression="(ONEOF ( PLANE, CYLINDRICAL_SURFACE, CONICAL_SURFACE, SPHERICAL_SURFACE, TOROIDAL_SURFACE) ANDOR DUPIN_CYCLIDE_SURFACE)" supertypes="surface">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
		</entity>
		<entity name="ellipse" supertypes="conic">
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="ellipsoid" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_3">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="ellipsoid_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_3">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="elliptic_area" supertypes="primitive_2d">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_2D"/>
			</explicit>
			<explicit name="semi_axis_1">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_axis_2">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
			<explicit name="equivalent_point">
				<typename name="cartesian_point"/>
			</explicit>
		</entity>
		<entity name="event_occurrence">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="event_occurrence_assignment" abstract.supertype="YES">
			<explicit name="assigned_event_occurrence">
				<typename name="EVENT_OCCURRENCE"/>
			</explicit>
			<explicit name="role">
				<typename name="EVENT_OCCURRENCE_ROLE"/>
			</explicit>
		</entity>
		<entity name="event_occurrence_context_assignment" abstract.supertype="YES">
			<explicit name="assigned_event_occurrence_assignment">
				<typename name="event_occurrence_assignment"/>
			</explicit>
			<explicit name="role">
				<typename name="EVENT_OCCURRENCE_CONTEXT_ROLE"/>
			</explicit>
		</entity>
		<entity name="event_occurrence_context_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="event_occurrence_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_event">
				<typename name="event_occurrence"/>
			</explicit>
			<explicit name="related_event">
				<typename name="event_occurrence"/>
			</explicit>
		</entity>
		<entity name="event_occurrence_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="exclusive_product_concept_feature_category" supertypes="product_concept_feature_category">
            </entity>
		<entity name="executed_action" supertypes="action">
            </entity>
		<entity name="expanded_uncertainty" supertypes="standard_uncertainty">
			<explicit name="coverage_factor">
				<builtintype type="REAL"/>
			</explicit>
		</entity>
		<entity name="experience">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="experience_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_experience">
				<typename name="EXPERIENCE"/>
			</explicit>
			<explicit name="role">
				<typename name="experience_role"/>
			</explicit>
		</entity>
		<entity name="experience_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_experience">
				<typename name="experience"/>
			</explicit>
			<explicit name="related_experience">
				<typename name="experience"/>
			</explicit>
		</entity>
		<entity name="experience_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="experience_type">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="experience_type_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_experience_type">
				<typename name="EXPERIENCE_TYPE"/>
			</explicit>
			<explicit name="role">
				<typename name="experience_type_role"/>
			</explicit>
		</entity>
		<entity name="experience_type_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_experience_type">
				<typename name="experience_type"/>
			</explicit>
			<explicit name="related_experience_type">
				<typename name="experience_type"/>
			</explicit>
		</entity>
		<entity name="experience_type_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="extension" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1">
              </where>
		</entity>
		<entity name="external_class_library" supertypes="external_source">
            </entity>
		<entity name="external_identification_assignment" abstract.supertype="YES" supertypes="identification_assignment">
			<explicit name="source">
				<typename name="external_source"/>
			</explicit>
		</entity>
		<entity name="external_referent_assignment" abstract.supertype="YES">
			<explicit name="assigned_name">
				<typename name="LABEL"/>
			</explicit>
			<derived name="role" expression="get_role(SELF)">
				<typename name="object_role"/>
			</derived>
			<unique label="UR1">
				<unique.attribute attribute="assigned_name"/>
			</unique>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
              </where>
		</entity>
		<entity name="external_source">
			<explicit name="source_id">
				<typename name="source_item"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
              </where>
		</entity>
		<entity name="external_source_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_source">
				<typename name="external_source"/>
			</explicit>
			<explicit name="related_source">
				<typename name="external_source"/>
			</explicit>
		</entity>
		<entity name="externally_defined_class" supertypes="class externally_defined_item">
            </entity>
		<entity name="externally_defined_dimension_definition" supertypes="DIMENSIONAL_SIZE externally_defined_item">
			<where label="WR1" expression="(SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification')">
              </where>
			<where label="WR2" expression="1 &gt;= SIZEOF(QUERY (adr &lt;* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification')))">
              </where>
		</entity>
		<entity name="externally_defined_general_property" supertypes="GENERAL_PROPERTY externally_defined_item">
            </entity>
		<entity name="externally_defined_item">
			<explicit name="item_id">
				<typename name="source_item"/>
			</explicit>
			<explicit name="source">
				<typename name="external_source"/>
			</explicit>
		</entity>
		<entity name="externally_defined_item_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_item">
				<typename name="externally_defined_item"/>
			</explicit>
			<explicit name="related_item">
				<typename name="externally_defined_item"/>
			</explicit>
		</entity>
		<entity name="extruded_area_solid" supertypes="swept_area_solid">
			<explicit name="extruded_direction">
				<typename name="DIRECTION"/>
			</explicit>
			<explicit name="depth">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="dot_product((SELF\swept_area_solid.swept_area.basis_surface\ elementary_surface.position.p[3]), extruded_direction) &lt;&gt; 0.0">
              </where>
		</entity>
		<entity name="extruded_face_solid" supertypes="swept_face_solid">
			<explicit name="extruded_direction">
				<typename name="DIRECTION"/>
			</explicit>
			<explicit name="depth">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="dot_product((SELF\swept_face_solid.swept_face.face_geometry\ elementary_surface.position.p[3]), extruded_direction) &lt;&gt; 0.0">
              </where>
		</entity>
		<entity name="face" super.expression="(ONEOF ( FACE_SURFACE, SUBFACE, ORIENTED_FACE))" supertypes="topological_representation_item">
			<explicit name="bounds">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="face_bound"/>
			</explicit>
			<where label="WR1" expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))))">
              </where>
			<where label="WR2" expression="SIZEOF(QUERY(temp &lt;* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp))) &lt;= 1">
              </where>
		</entity>
		<entity name="face_based_surface_model" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="fbsm_faces">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="CONNECTED_FACE_SET"/>
			</explicit>
		</entity>
		<entity name="face_bound" supertypes="topological_representation_item">
			<explicit name="bound">
				<typename name="loop"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
		</entity>
		<entity name="face_outer_bound" supertypes="face_bound">
            </entity>
		<entity name="face_surface" supertypes="face GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="face_geometry">
				<typename name="SURFACE"/>
			</explicit>
			<explicit name="same_sense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<where label="WR1" expression="NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry))">
              </where>
		</entity>
		<entity name="faceted_brep" supertypes="manifold_solid_brep">
            </entity>
		<entity name="faceted_primitive" super.expression="(ONEOF ( TETRAHEDRON, CONVEX_HEXAHEDRON))" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="points">
				<aggregate type="LIST" lower="4" upper="?"/>
				<typename name="CARTESIAN_POINT"/>
			</explicit>
			<where label="WR1" expression="points[1].dim = 3">
              </where>
		</entity>
		<entity name="fixed_reference_swept_surface" supertypes="swept_surface">
			<explicit name="directrix">
				<typename name="curve"/>
			</explicit>
			<explicit name="fixed_reference">
				<typename name="direction"/>
			</explicit>
		</entity>
		<entity name="founded_item">
            </entity>
		<entity name="functional_breakdown_context" supertypes="BREAKDOWN_CONTEXT">
            </entity>
		<entity name="functional_element_usage" supertypes="BREAKDOWN_ELEMENT_USAGE">
            </entity>
		<entity name="functionally_defined_transformation">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="general_material_property" supertypes="GENERAL_PROPERTY">
			<where label="WR1" expression="SIZEOF(QUERY(gpa &lt;* USEDIN(SELF,'MATERIAL_ASPECTS_MIM.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | NOT ('MATERIAL_ASPECTS_MIM.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)))) = 0">
              </where>
		</entity>
		<entity name="general_property">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="general_property_association">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="base_definition">
				<typename name="general_property"/>
			</explicit>
			<explicit name="derived_definition">
				<typename name="derived_property_select"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(USEDIN(derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1">
              </where>
			<where label="WR2" expression="derived_definition.name = base_definition.name">
              </where>
		</entity>
		<entity name="general_property_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_property">
				<typename name="general_property"/>
			</explicit>
			<explicit name="related_property">
				<typename name="general_property"/>
			</explicit>
		</entity>
		<entity name="geometric_alignment" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1">
              </where>
		</entity>
		<entity name="geometric_curve_set" supertypes="geometric_set">
			<where label="WR1" expression="SIZEOF(QUERY(temp &lt;* SELF\geometric_set.elements |'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0">
              </where>
		</entity>
		<entity name="geometric_intersection" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1">
              </where>
		</entity>
		<entity name="geometric_representation_context" supertypes="representation_context">
			<explicit name="coordinate_space_dimension">
				<typename name="dimension_count"/>
			</explicit>
		</entity>
		<entity name="geometric_representation_item" super.expression="(ONEOF ( POINT, DIRECTION, VECTOR, PLACEMENT, CARTESIAN_TRANSFORMATION_OPERATOR, CURVE, SURFACE, EDGE_CURVE, FACE_SURFACE, POLY_LOOP, VERTEX_POINT, SOLID_MODEL, BOOLEAN_RESULT, SPHERE, RIGHT_CIRCULAR_CONE, RIGHT_CIRCULAR_CYLINDER, TORUS, BLOCK, PRIMITIVE_2D, RIGHT_ANGULAR_WEDGE, ELLIPSOID, FACETED_PRIMITIVE, RECTANGULAR_PYRAMID, CYCLIDE_SEGMENT_SOLID, VOLUME, HALF_SPACE_SOLID, HALF_SPACE_2D, SHELL_BASED_SURFACE_MODEL, FACE_BASED_SURFACE_MODEL, SHELL_BASED_WIREFRAME_MODEL, EDGE_BASED_WIREFRAME_MODEL, GEOMETRIC_SET))" supertypes="representation_item">
			<derived name="dim" expression="dimension_of(SELF)">
				<typename name="dimension_count"/>
			</derived>
			<where label="WR1" expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0">
              </where>
		</entity>
		<entity name="geometric_set" super.expression="(ONEOF ( GEOMETRIC_CURVE_SET, GEOMETRIC_SET_REPLICA))" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="elements">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="geometric_set_select"/>
			</explicit>
		</entity>
		<entity name="geometric_set_replica" supertypes="geometric_set">
			<explicit name="parent_set">
				<typename name="geometric_set"/>
			</explicit>
			<explicit name="transformation">
				<typename name="CARTESIAN_TRANSFORMATION_OPERATOR"/>
			</explicit>
			<derived name="elements" expression="build_transformed_set(transformation, parent_set)">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="geometric_set_select"/>
				<redeclaration entity-ref="geometric_set"/>
			</derived>
			<where label="WR1" expression="acyclic_set_replica(SELF, parent_set)">
                </where>
		</entity>
		<entity name="geometric_tolerance">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="magnitude">
				<typename name="measure_with_unit"/>
			</explicit>
			<explicit name="toleranced_shape_aspect">
				<typename name="shape_aspect"/>
			</explicit>
			<where label="WR1" expression="('NUMBER' IN TYPEOF(magnitude\measure_with_unit.value_component)) AND(magnitude\measure_with_unit.value_component &gt;= 0.0)">
                </where>
		</entity>
		<entity name="geometric_tolerance_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_geometric_tolerance">
				<typename name="geometric_tolerance"/>
			</explicit>
			<explicit name="related_geometric_tolerance">
				<typename name="geometric_tolerance"/>
			</explicit>
		</entity>
		<entity name="geometric_tolerance_with_datum_reference" supertypes="geometric_tolerance">
			<explicit name="datum_system">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="datum_reference"/>
			</explicit>
		</entity>
		<entity name="geometric_tolerance_with_defined_unit" supertypes="geometric_tolerance">
			<explicit name="unit_size">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="('NUMBER' IN TYPEOF(unit_size\measure_with_unit.value_component)) AND(unit_size\measure_with_unit.value_component &gt; 0.0)">
                </where>
		</entity>
		<entity name="geometrically_bounded_2d_wireframe_representation" supertypes="shape_representation">
			<where label="WR1" expression="SELF.context_of_items\geometric_representation_context. coordinate_space_dimension = 2">
                </where>
			<where label="WR2" expression="SIZEOF (QUERY (item &lt;* SELF.items | NOT (SIZEOF (TYPEOF (item) *['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1))) = 0">
                </where>
			<where label="WR3" expression="SIZEOF (QUERY (item &lt;* SELF.items | SIZEOF (TYPEOF (item) *['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)) &gt;= 1">
                </where>
			<where label="WR4" expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF.items |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM' IN TYPEOF (item))) | NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0">
                </where>
			<where label="WR5" expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (item))) | NOT (SIZEOF (QUERY (elem &lt;* gcs\geometric_set.elements | NOT (SIZEOF (TYPEOF (elem) *['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) =1))) = 0))) = 0">
                </where>
			<where label="WR6" expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (item))) | NOT (SIZEOF (QUERY (crv &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE' IN TYPEOF (elem))) | NOT (valid_basis_curve_in_2d_wireframe(crv)))) = 0))) = 0">
                </where>
			<where label="WR7" expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items | ('AIC_- GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (item))) | NOT (SIZEOF (QUERY (pnt &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT' IN TYPEOF(elem))) | NOT (SIZEOF (TYPEOF (pnt) *['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT','AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE'])= 1))) = 0))) = 0">
                </where>
			<where label="WR8" expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (item))) | NOT (SIZEOF (QUERY (pl &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE' IN TYPEOF (elem))) | NOT (SIZEOF (pl\polyline.points) &gt; 2))) = 0))) = 0">
                </where>
		</entity>
		<entity name="global_uncertainty_assigned_context" supertypes="representation_context">
			<explicit name="uncertainty">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="uncertainty_measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="global_unit_assigned_context" supertypes="representation_context">
			<explicit name="units">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="unit"/>
			</explicit>
		</entity>
		<entity name="group">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                </where>
		</entity>
		<entity name="group_assignment" abstract.supertype="YES">
			<explicit name="assigned_group">
				<typename name="GROUP"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
                </where>
		</entity>
		<entity name="group_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_group">
				<typename name="group"/>
			</explicit>
			<explicit name="related_group">
				<typename name="group"/>
			</explicit>
		</entity>
		<entity name="half_space_2d" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="base_curve">
				<typename name="CURVE"/>
			</explicit>
			<explicit name="agreement_flag">
				<builtintype type="BOOLEAN"/>
			</explicit>
		</entity>
		<entity name="half_space_solid" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="base_surface">
				<typename name="SURFACE"/>
			</explicit>
			<explicit name="agreement_flag">
				<builtintype type="BOOLEAN"/>
			</explicit>
		</entity>
		<entity name="hardness_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="({2&lt;= SIZEOF (SELF.items) &lt;=4}) AND (SIZEOF (QUERY (i &lt;* items | ('SURFACE_CONDITIONS_MIM.'+'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (i)) AND (i.name IN [ 'measuring method' , 'measuring position' ]))) + SIZEOF (QUERY (i &lt;* items | (SIZEOF (['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF (i)) =1) AND (i.name IN ['depth' , 'hardness']))) = SIZEOF (SELF.items))">
                </where>
			<where label="WR2" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='measuring method')) =1">
                </where>
			<where label="WR3" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='hardness'))=1">
                </where>
			<where label="WR4" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='measuring position')) &lt;=1">
                </where>
			<where label="WR5" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='depth'))&lt;=1">
                </where>
			<where label="WR6" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION')) =1) AND (SIZEOF (QUERY (pdr&lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | SIZEOF (QUERY (gpa &lt;* USEDIN (pdr. definition ,'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+'DERIVED_DEFINITION') | ('SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY' IN TYPEOF (gpa. base_definition)) AND(gpa. base_definition.name ='surface_condition'))) =1)) =1)">
                </where>
		</entity>
		<entity name="hexahedron_volume" supertypes="volume">
			<explicit name="points">
				<aggregate type="LIST" lower="8" upper="8"/>
				<typename name="cartesian_point"/>
			</explicit>
			<where label="WR1" expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0">
                </where>
			<where label="WR2" expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0">
                </where>
			<where label="WR3" expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0">
                </where>
			<where label="WR4" expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0">
                </where>
			<where label="WR5" expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0">
                </where>
			<where label="WR6" expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0">
                </where>
			<where label="WR7" expression="same_side([points[1], points[2], points[3]],[points[5], points[6], points[7], points[8]])">
                </where>
			<where label="WR8" expression="same_side([points[1], points[4], points[8]],[points[3], points[7], points[6], points[2]])">
                </where>
			<where label="WR9" expression="same_side([points[1], points[2], points[5]],[points[3], points[7], points[8], points[4]])">
                </where>
			<where label="WR10" expression="same_side([points[5], points[6], points[7]],[points[1], points[2], points[3], points[4]])">
                </where>
			<where label="WR11" expression="same_side([points[3], points[7], points[6]],[points[1], points[4], points[8], points[5]])">
                </where>
			<where label="WR12" expression="same_side([points[3], points[7], points[8]],[points[1], points[5], points[6], points[2]])">
                </where>
			<where label="WR13" expression="points[1].dim = 3">
                </where>
		</entity>
		<entity name="hyperbola" supertypes="conic">
			<explicit name="semi_axis">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="semi_imag_axis">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="id_attribute">
			<explicit name="attribute_value">
				<typename name="identifier"/>
			</explicit>
			<explicit name="identified_item">
				<typename name="id_attribute_select"/>
			</explicit>
		</entity>
		<entity name="identification_assignment" abstract.supertype="YES">
			<explicit name="assigned_id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="role">
				<typename name="identification_role"/>
			</explicit>
		</entity>
		<entity name="identification_assignment_relationship">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="relating_identification_assignment">
				<typename name="identification_assignment"/>
			</explicit>
			<explicit name="related_identification_assignment">
				<typename name="identification_assignment"/>
			</explicit>
		</entity>
		<entity name="identification_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="inclusion_product_concept_feature" supertypes="conditional_concept_feature">
			<where label="WR1" expression="NOT ('PRODUCT_CLASS_MIM.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF (SELF))">
                </where>
			<where label="WR2" expression="SIZEOF (QUERY(cfr &lt;* USEDIN (SELF ,'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE') |'PRODUCT_CLASS_MIM.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr))) + SIZEOF(QUERY(cfr &lt;* USEDIN (SELF , 'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE') |'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)))= 0">
                </where>
			<where label="WR3" expression="SELF.condition.conditional_operator.name = 'implication'">
                </where>
		</entity>
		<entity name="instance_usage_context_assignment" supertypes="PRODUCT_DEFINITION_CONTEXT">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="instance_usage_context_select"/>
			</explicit>
		</entity>
		<entity name="intersection_curve" supertypes="surface_curve">
			<where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
                </where>
			<where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1]) &lt;&gt; associated_surface(SELF\surface_curve.associated_geometry[2])">
                </where>
		</entity>
		<entity name="item_defined_transformation">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="transform_item_1">
				<typename name="representation_item"/>
			</explicit>
			<explicit name="transform_item_2">
				<typename name="representation_item"/>
			</explicit>
		</entity>
		<entity name="item_identified_representation_usage">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="definition">
				<typename name="represented_definition"/>
			</explicit>
			<explicit name="used_representation">
				<typename name="representation"/>
			</explicit>
			<explicit name="identified_item">
				<typename name="representation_item"/>
			</explicit>
			<where label="WR1" expression="SELF.used_representation IN using_representations(SELF.identified_item)">
                </where>
		</entity>
		<entity name="known_source" supertypes="external_source pre_defined_item">
              </entity>
		<entity name="language" supertypes="group">
			<where label="WR1" expression="SELF\group.name &lt;&gt; ''">
                </where>
		</entity>
		<entity name="length_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                </where>
		</entity>
		<entity name="length_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                </where>
		</entity>
		<entity name="library_assignment" abstract.supertype="YES" supertypes="external_referent_assignment">
			<explicit name="frame_of_reference">
				<typename name="library_context"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="frame_of_reference"/>
			</unique>
		</entity>
		<entity name="library_context" supertypes="application_context_element">
			<explicit name="library_reference">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="limits_and_fits">
			<explicit name="form_variance">
				<typename name="label"/>
			</explicit>
			<explicit name="zone_variance">
				<typename name="label"/>
			</explicit>
			<explicit name="grade">
				<typename name="label"/>
			</explicit>
			<explicit name="source">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="line" supertypes="curve">
			<explicit name="pnt">
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="dir">
				<typename name="vector"/>
			</explicit>
			<where label="WR1" expression="dir.dim = pnt.dim">
                </where>
		</entity>
		<entity name="local_time">
			<explicit name="hour_component">
				<typename name="hour_in_day"/>
			</explicit>
			<explicit name="minute_component" optional="YES">
				<typename name="minute_in_hour"/>
			</explicit>
			<explicit name="second_component" optional="YES">
				<typename name="second_in_minute"/>
			</explicit>
			<explicit name="zone">
				<typename name="coordinated_universal_time_offset"/>
			</explicit>
			<where label="WR1" expression="valid_time (SELF)">
                </where>
		</entity>
		<entity name="location">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="location_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_location">
				<typename name="LOCATION"/>
			</explicit>
			<explicit name="role">
				<typename name="location_role"/>
			</explicit>
		</entity>
		<entity name="location_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_location">
				<typename name="location"/>
			</explicit>
			<explicit name="related_location">
				<typename name="location"/>
			</explicit>
		</entity>
		<entity name="location_representation_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="represented_location">
				<typename name="LOCATION"/>
			</explicit>
			<explicit name="role">
				<typename name="location_representation_role"/>
			</explicit>
		</entity>
		<entity name="location_representation_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="location_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="loop" super.expression="(ONEOF ( VERTEX_LOOP, EDGE_LOOP, POLY_LOOP))" supertypes="topological_representation_item">
              </entity>
		<entity name="lot_effectivity" supertypes="effectivity">
			<explicit name="effectivity_lot_id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="effectivity_lot_size">
				<typename name="measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="luminous_intensity_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)">
                </where>
		</entity>
		<entity name="luminous_intensity_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0)">
                </where>
		</entity>
		<entity name="make_from_usage_option" supertypes="product_definition_usage">
			<explicit name="ranking">
				<builtintype type="INTEGER"/>
			</explicit>
			<explicit name="ranking_rationale">
				<typename name="text"/>
			</explicit>
			<explicit name="quantity">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component &gt; 0)">
                </where>
		</entity>
		<entity name="make_from_usage_option_group">
			<explicit name="members">
				<aggregate type="SET" lower="2" upper="?"/>
				<typename name="make_from_usage_option"/>
			</explicit>
			<where label="WR1" expression="SIZEOF (QUERY (example &lt;* members | example.related_product_definition:=: members[1].related_product_definition)) =SIZEOF(members)">
                </where>
		</entity>
		<entity name="manifold_solid_brep" supertypes="solid_model">
			<explicit name="outer">
				<typename name="CLOSED_SHELL"/>
			</explicit>
		</entity>
		<entity name="mapped_item" supertypes="representation_item">
			<explicit name="mapping_source">
				<typename name="representation_map"/>
			</explicit>
			<explicit name="mapping_target">
				<typename name="representation_item"/>
			</explicit>
			<where label="WR1" expression="acyclic_mapped_representation(using_representations(SELF), [SELF])">
                </where>
		</entity>
		<entity name="mass_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                </where>
		</entity>
		<entity name="mass_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                </where>
		</entity>
		<entity name="material_designation">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="definitions">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="characterized_definition"/>
			</explicit>
		</entity>
		<entity name="material_designation_characterization">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="designation">
				<typename name="material_designation"/>
			</explicit>
			<explicit name="property">
				<typename name="characterized_material_property"/>
			</explicit>
		</entity>
		<entity name="material_property" supertypes="property_definition">
			<where label="WR1" expression="('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR(SIZEOF(bag_to_set(USEDIN(SELF ,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - QUERY(temp &lt;* bag_to_set(USEDIN(SELF ,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp)))) = 0)">
                </where>
		</entity>
		<entity name="material_property_representation" supertypes="property_definition_representation">
			<explicit name="dependent_environment">
				<typename name="data_environment"/>
			</explicit>
		</entity>
		<entity name="measure_qualification">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="qualified_measure">
				<typename name="measure_with_unit"/>
			</explicit>
			<explicit name="qualifiers">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="value_qualifier"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp))) &lt; 2">
                </where>
		</entity>
		<entity name="measure_representation_item" supertypes="representation_item measure_with_unit">
              </entity>
		<entity name="measure_with_unit" super.expression="(ONEOF ( LENGTH_MEASURE_WITH_UNIT, MASS_MEASURE_WITH_UNIT, TIME_MEASURE_WITH_UNIT, ELECTRIC_CURRENT_MEASURE_WITH_UNIT, THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT, CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT, AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT, LUMINOUS_INTENSITY_MEASURE_WITH_UNIT, PLANE_ANGLE_MEASURE_WITH_UNIT, SOLID_ANGLE_MEASURE_WITH_UNIT, AREA_MEASURE_WITH_UNIT, VOLUME_MEASURE_WITH_UNIT, RATIO_MEASURE_WITH_UNIT))">
			<explicit name="value_component">
				<typename name="measure_value"/>
			</explicit>
			<explicit name="unit_component">
				<typename name="unit"/>
			</explicit>
			<where label="WR1" expression="valid_units (SELF)">
                </where>
		</entity>
		<entity name="modified_geometric_tolerance" supertypes="geometric_tolerance">
			<explicit name="modifier">
				<typename name="limit_condition"/>
			</explicit>
		</entity>
		<entity name="moments_of_inertia_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="(SIZEOF(SELF.items) = 1) AND(SIZEOF(QUERY(i &lt;* SELF.items | ('INERTIA_CHARACTERISTICS_MIM' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND(i.name = 'moments of inertia matrix'))) = 1)">
                </where>
			<where label="WR2" expression="SIZEOF(QUERY(i &lt;* SELF.items | ('INERTIA_CHARACTERISTICS_MIM' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND('INERTIA_CHARACTERISTICS_MIM' + '.LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND value_range_aggregate_rep_item (i\compound_representation_item.item_element))) = 1">
                </where>
		</entity>
		<entity name="multi_language_attribute_assignment" supertypes="attribute_value_assignment">
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="multi_language_attribute_item"/>
			</explicit>
			<derived name="translation_language" expression="language_indication[1]\attribute_classification_assignment.assigned_class">
				<typename name="language"/>
			</derived>
			<inverse name="language_indication" entity="attribute_language_assignment" attribute="items">
				<inverse.aggregate type="SET" lower="1" upper="1"/>
			</inverse>
			<where label="WR1" expression="(SELF\attribute_value_assignment.role.name = 'alternate language')">
                </where>
			<where label="WR2" expression="SIZEOF(QUERY(ala &lt;* language_indication |(ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND(ala\attribute_classification_assignment.role.name='translated'))) = 1">
                </where>
			<where label="WR3" expression="SELF\attribute_value_assignment.attribute_name &lt;&gt; ''">
                </where>
			<where label="WR4" expression="SIZEOF(QUERY(ci &lt;* items | SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'MULTI_LINGUISM_MIM.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND(ata.translation_language :=: translation_language)))&gt;1)) =0">
                </where>
			<where label="WR5" expression="SIZEOF(QUERY(ci &lt;* items | SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |(ata\attribute_classification_assignment.role.name='primary') AND(ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND(ata\attribute_classification_assignment.assigned_class :=: translation_language)))&gt;0)) =0">
                </where>
		</entity>
		<entity name="name_assignment" abstract.supertype="YES">
			<explicit name="assigned_name">
				<typename name="LABEL"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
                </where>
		</entity>
		<entity name="name_attribute">
			<explicit name="attribute_value">
				<typename name="label"/>
			</explicit>
			<explicit name="named_item">
				<typename name="name_attribute_select"/>
			</explicit>
		</entity>
		<entity name="named_unit" super.expression="(ONEOF ( SI_UNIT, CONVERSION_BASED_UNIT, CONTEXT_DEPENDENT_UNIT) ANDOR ONEOF ( LENGTH_UNIT, MASS_UNIT, TIME_UNIT, ELECTRIC_CURRENT_UNIT, THERMODYNAMIC_TEMPERATURE_UNIT, AMOUNT_OF_SUBSTANCE_UNIT, LUMINOUS_INTENSITY_UNIT, PLANE_ANGLE_UNIT, SOLID_ANGLE_UNIT, AREA_UNIT, VOLUME_UNIT, RATIO_UNIT))">
			<explicit name="dimensions">
				<typename name="dimensional_exponents"/>
			</explicit>
		</entity>
		<entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage">
              </entity>
		<entity name="object_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="offset_curve_2d" supertypes="curve">
			<explicit name="basis_curve">
				<typename name="curve"/>
			</explicit>
			<explicit name="distance">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
			<where label="WR1" expression="basis_curve.dim = 2">
                </where>
		</entity>
		<entity name="offset_curve_3d" supertypes="curve">
			<explicit name="basis_curve">
				<typename name="curve"/>
			</explicit>
			<explicit name="distance">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
			<explicit name="ref_direction">
				<typename name="direction"/>
			</explicit>
			<where label="WR1" expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)">
                </where>
		</entity>
		<entity name="offset_surface" supertypes="surface">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="distance">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="self_intersect">
				<builtintype type="LOGICAL"/>
			</explicit>
		</entity>
		<entity name="open_path" supertypes="path">
			<derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="(SELF\path.edge_list[1].edge_element.edge_start) :&lt;&gt;:(SELF\path.edge_list[ne].edge_element.edge_end)">
                </where>
		</entity>
		<entity name="open_shell" supertypes="connected_face_set">
              </entity>
		<entity name="ordinal_date" supertypes="date">
			<explicit name="day_component">
				<typename name="day_in_year_number"/>
			</explicit>
			<where label="WR1" expression="(NOT leap_year(SELF.year_component) AND { 1 &lt;= day_component &lt;= 365 }) OR (leap_year(SELF.year_component) AND { 1 &lt;= day_component &lt;= 366 })">
                </where>
		</entity>
		<entity name="organization">
			<explicit name="id" optional="YES">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="organization_assignment" abstract.supertype="YES">
			<explicit name="assigned_organization">
				<typename name="ORGANIZATION"/>
			</explicit>
			<explicit name="role">
				<typename name="ORGANIZATION_ROLE"/>
			</explicit>
		</entity>
		<entity name="organization_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_organization">
				<typename name="organization"/>
			</explicit>
			<explicit name="related_organization">
				<typename name="organization"/>
			</explicit>
		</entity>
		<entity name="organization_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value(SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                </where>
		</entity>
		<entity name="organization_type">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="organization_type_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_organization_type">
				<typename name="ORGANIZATION_TYPE"/>
			</explicit>
			<explicit name="role">
				<typename name="organization_type_role"/>
			</explicit>
		</entity>
		<entity name="organization_type_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_organization_type">
				<typename name="organization_type"/>
			</explicit>
			<explicit name="related_organization_type">
				<typename name="organization_type"/>
			</explicit>
		</entity>
		<entity name="organization_type_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="organizational_address" supertypes="address">
			<explicit name="organizations">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="organization"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="organizational_project">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="responsible_organizations">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="organization"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                </where>
		</entity>
		<entity name="organizational_project_assignment" abstract.supertype="YES">
			<explicit name="assigned_organizational_project">
				<typename name="ORGANIZATIONAL_PROJECT"/>
			</explicit>
			<explicit name="role">
				<typename name="organizational_project_role"/>
			</explicit>
		</entity>
		<entity name="organizational_project_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_organizational_project">
				<typename name="organizational_project"/>
			</explicit>
			<explicit name="related_organizational_project">
				<typename name="organizational_project"/>
			</explicit>
		</entity>
		<entity name="organizational_project_role">
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="oriented_closed_shell" supertypes="closed_shell">
			<explicit name="closed_shell_element">
				<typename name="closed_shell"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<derived name="cfs_faces" expression="conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces)">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="face"/>
				<redeclaration entity-ref="connected_face_set"/>
			</derived>
			<where label="WR1" expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (SELF.closed_shell_element))">
                  </where>
		</entity>
		<entity name="oriented_edge" supertypes="edge">
			<explicit name="edge_element">
				<typename name="edge"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<derived name="edge_start" expression="boolean_choose (SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end)">
				<typename name="vertex"/>
				<redeclaration entity-ref="edge"/>
			</derived>
			<derived name="edge_end" expression="boolean_choose (SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start)">
				<typename name="vertex"/>
				<redeclaration entity-ref="edge"/>
			</derived>
			<where label="WR1" expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element))">
                      </where>
		</entity>
		<entity name="oriented_face" supertypes="face">
			<explicit name="face_element">
				<typename name="face"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<derived name="bounds" expression="conditional_reverse(SELF.orientation,SELF.face_element.bounds)">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="face_bound"/>
				<redeclaration entity-ref="face"/>
			</derived>
			<where label="WR1" expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element))">
                        </where>
		</entity>
		<entity name="oriented_open_shell" supertypes="open_shell">
			<explicit name="open_shell_element">
				<typename name="open_shell"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<derived name="cfs_faces" expression="conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces)">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="face"/>
				<redeclaration entity-ref="connected_face_set"/>
			</derived>
			<where label="WR1" expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (SELF.open_shell_element))">
                          </where>
		</entity>
		<entity name="oriented_path" supertypes="path">
			<explicit name="path_element">
				<typename name="path"/>
			</explicit>
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<derived name="edge_list" expression="conditional_reverse(SELF.orientation, SELF.path_element.edge_list)">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="oriented_edge"/>
				<redeclaration entity-ref="path"/>
			</derived>
			<where label="WR1" expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element))">
                            </where>
		</entity>
		<entity name="oriented_surface" supertypes="surface">
			<explicit name="orientation">
				<builtintype type="BOOLEAN"/>
			</explicit>
		</entity>
		<entity name="outer_boundary_curve" supertypes="boundary_curve">
                          </entity>
		<entity name="package_product_concept_feature" supertypes="product_concept_feature">
			<where label="WR1" expression="NOT ('PRODUCT_CLASS_MIM.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (SELF))">
                            </where>
			<where label="WR2" expression="SIZEOF (QUERY (cfr &lt;* USEDIN (SELF ,'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE') |('AUTOMOTIVE_DESIGN.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr)) AND(SIZEOF (QUERY (ipcf &lt;* USEDIN (cfr , 'PRODUCT_CLASS_MIM.' + 'CONDITIONAL_CONCEPT_FEATURE.' +'CONDITION') |'PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF (ipcf)))= 1)))&gt;0">
                            </where>
		</entity>
		<entity name="parabola" supertypes="conic">
			<explicit name="focal_dist">
				<typename name="length_measure"/>
			</explicit>
			<where label="WR1" expression="focal_dist &lt;&gt; 0.0">
                            </where>
		</entity>
		<entity name="parallel_offset" supertypes="derived_shape_aspect">
			<explicit name="offset">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1">
                            </where>
		</entity>
		<entity name="parametric_representation_context" supertypes="representation_context">
                          </entity>
		<entity name="path" super.expression="(ONEOF ( OPEN_PATH, EDGE_LOOP, ORIENTED_PATH))" supertypes="topological_representation_item">
			<explicit name="edge_list">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="oriented_edge"/>
			</explicit>
			<where label="WR1" expression="path_head_to_tail(SELF)">
                            </where>
		</entity>
		<entity name="pcurve" supertypes="curve">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="reference_to_curve">
				<typename name="definitional_representation"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(reference_to_curve\representation.items) = 1">
                            </where>
			<where label="WR2" expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1])">
                            </where>
			<where label="WR3" expression="reference_to_curve\representation.items[1]\ geometric_representation_item.dim =2">
                            </where>
		</entity>
		<entity name="perpendicular_to" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1">
                            </where>
		</entity>
		<entity name="person">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="last_name" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="first_name" optional="YES">
				<typename name="label"/>
			</explicit>
			<explicit name="middle_names" optional="YES">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="label"/>
			</explicit>
			<explicit name="prefix_titles" optional="YES">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="label"/>
			</explicit>
			<explicit name="suffix_titles" optional="YES">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="label"/>
			</explicit>
			<where label="WR1" expression="EXISTS(last_name) OR EXISTS(first_name)">
                            </where>
		</entity>
		<entity name="person_and_organization">
			<explicit name="the_person">
				<typename name="person"/>
			</explicit>
			<explicit name="the_organization">
				<typename name="organization"/>
			</explicit>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<derived name="description" expression="get_description_value(SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
                            </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                            </where>
		</entity>
		<entity name="person_and_organization_address" supertypes="organizational_address personal_address">
			<explicit name="organizations">
				<aggregate type="SET" lower="1" upper="1"/>
				<typename name="organization"/>
				<redeclaration entity-ref="organizational_address"/>
			</explicit>
			<explicit name="people">
				<aggregate type="SET" lower="1" upper="1"/>
				<typename name="person"/>
				<redeclaration entity-ref="personal_address"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(pao &lt;* USEDIN (SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1">
                                </where>
		</entity>
		<entity name="person_and_organization_assignment" abstract.supertype="YES">
			<explicit name="assigned_person_and_organization">
				<typename name="PERSON_AND_ORGANIZATION"/>
			</explicit>
			<explicit name="role">
				<typename name="PERSON_AND_ORGANIZATION_ROLE"/>
			</explicit>
		</entity>
		<entity name="person_and_organization_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                                </where>
		</entity>
		<entity name="person_assignment" abstract.supertype="YES">
			<explicit name="assigned_person">
				<typename name="PERSON"/>
			</explicit>
			<explicit name="role">
				<typename name="PERSON_ROLE"/>
			</explicit>
		</entity>
		<entity name="person_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                                </where>
		</entity>
		<entity name="person_type">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="person_type_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_person_type">
				<typename name="PERSON_TYPE"/>
			</explicit>
			<explicit name="role">
				<typename name="person_type_role"/>
			</explicit>
		</entity>
		<entity name="person_type_definition">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="formation">
				<typename name="person_type_definition_formation"/>
			</explicit>
		</entity>
		<entity name="person_type_definition_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_person_type_definition">
				<typename name="PERSON_TYPE_DEFINITION"/>
			</explicit>
			<explicit name="role">
				<typename name="person_type_definition_role"/>
			</explicit>
		</entity>
		<entity name="person_type_definition_formation">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="of_person_type">
				<typename name="person_type"/>
			</explicit>
		</entity>
		<entity name="person_type_definition_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_person_type_definition">
				<typename name="person_type_definition"/>
			</explicit>
			<explicit name="related_person_type_definition">
				<typename name="person_type_definition"/>
			</explicit>
		</entity>
		<entity name="person_type_definition_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="person_type_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="personal_address" supertypes="address">
			<explicit name="people">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="person"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="physical_breakdown_context" supertypes="BREAKDOWN_CONTEXT">
                              </entity>
		<entity name="physical_element_usage" supertypes="BREAKDOWN_ELEMENT_USAGE">
                              </entity>
		<entity name="physically_modelled_product_definition" supertypes="PRODUCT_DEFINITION">
			<where label="WR1" expression="SELF.frame_of_reference\application_context_element.name = 'physical model occurrence'">
                                </where>
			<where label="WR2" expression="'document' IN categories_of_product(SELF\product_definition.formation.of_product)">
                                </where>
		</entity>
		<entity name="placement" super.expression="(ONEOF ( AXIS1_PLACEMENT, AXIS2_PLACEMENT_2D, AXIS2_PLACEMENT_3D))" supertypes="geometric_representation_item">
			<explicit name="location">
				<typename name="cartesian_point"/>
			</explicit>
		</entity>
		<entity name="plane" supertypes="elementary_surface">
                              </entity>
		<entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                </where>
		</entity>
		<entity name="plane_angle_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                                </where>
		</entity>
		<entity name="plus_minus_tolerance">
			<explicit name="range">
				<typename name="tolerance_method_definition"/>
			</explicit>
			<explicit name="toleranced_dimension">
				<typename name="dimensional_characteristic"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="toleranced_dimension"/>
			</unique>
		</entity>
		<entity name="point" super.expression="(ONEOF ( CARTESIAN_POINT, POINT_ON_CURVE, POINT_ON_SURFACE, POINT_IN_VOLUME, POINT_REPLICA, DEGENERATE_PCURVE))" supertypes="geometric_representation_item">
                              </entity>
		<entity name="point_in_volume" supertypes="point">
			<explicit name="basis_volume">
				<typename name="volume"/>
			</explicit>
			<explicit name="point_parameter_u">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="point_parameter_v">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="point_parameter_w">
				<typename name="parameter_value"/>
			</explicit>
		</entity>
		<entity name="point_on_curve" supertypes="point">
			<explicit name="basis_curve">
				<typename name="curve"/>
			</explicit>
			<explicit name="point_parameter">
				<typename name="parameter_value"/>
			</explicit>
		</entity>
		<entity name="point_on_surface" supertypes="point">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="point_parameter_u">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="point_parameter_v">
				<typename name="parameter_value"/>
			</explicit>
		</entity>
		<entity name="point_replica" supertypes="point">
			<explicit name="parent_pt">
				<typename name="point"/>
			</explicit>
			<explicit name="transformation">
				<typename name="cartesian_transformation_operator"/>
			</explicit>
			<where label="WR1" expression="transformation.dim = parent_pt.dim">
                                </where>
			<where label="WR2" expression="acyclic_point_replica (SELF,parent_pt)">
                                </where>
		</entity>
		<entity name="polar_point" supertypes="cartesian_point">
			<explicit name="r">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="theta">
				<typename name="plane_angle_measure"/>
			</explicit>
			<derived name="coordinates" expression="[r*cos(theta), r*sin(theta)]">
				<aggregate type="LIST" lower="1" upper="3"/>
				<typename name="length_measure"/>
				<redeclaration entity-ref="cartesian_point"/>
			</derived>
			<where label="WR1" expression="r &gt;= 0.0">
                                  </where>
		</entity>
		<entity name="poly_loop" supertypes="loop GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="polygon">
				<aggregate type="LIST" lower="3" upper="?"/>
				<typename name="CARTESIAN_POINT"/>
			</explicit>
		</entity>
		<entity name="polygonal_area" supertypes="primitive_2d">
			<explicit name="bounds">
				<aggregate type="LIST" lower="3" upper="?"/>
				<typename name="CARTESIAN_POINT"/>
			</explicit>
		</entity>
		<entity name="polyline" supertypes="bounded_curve">
			<explicit name="points">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="cartesian_point"/>
			</explicit>
		</entity>
		<entity name="position_in_organization">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_position_in_organization">
				<typename name="POSITION_IN_ORGANIZATION"/>
			</explicit>
			<explicit name="role">
				<typename name="position_in_organization_role"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_position_in_organization">
				<typename name="position_in_organization"/>
			</explicit>
			<explicit name="related_position_in_organization">
				<typename name="position_in_organization"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_type">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_type_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_position_in_organization_type">
				<typename name="POSITION_IN_ORGANIZATION_TYPE"/>
			</explicit>
			<explicit name="role">
				<typename name="position_in_organization_type_role"/>
			</explicit>
		</entity>
		<entity name="position_in_organization_type_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="pre_defined_item">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="precision_qualifier">
			<explicit name="precision_value">
				<builtintype type="INTEGER"/>
			</explicit>
		</entity>
		<entity name="primitive_2d" super.expression="(ONEOF ( CIRCULAR_AREA, ELLIPTIC_AREA, RECTANGULAR_AREA, POLYGONAL_AREA))" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 2">
                                  </where>
		</entity>
		<entity name="process_product_association">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="defined_product">
				<typename name="characterized_product_definition"/>
			</explicit>
			<explicit name="process">
				<typename name="product_definition_process"/>
			</explicit>
		</entity>
		<entity name="process_property_association">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="process">
				<typename name="property_process"/>
			</explicit>
			<explicit name="property_or_shape">
				<typename name="property_or_shape_select"/>
			</explicit>
		</entity>
		<entity name="product">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="frame_of_reference">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product_context"/>
			</explicit>
		</entity>
		<entity name="product_as_individual" supertypes="product">
                                </entity>
		<entity name="product_as_individual_version" abstract.supertype="YES" super.expression="(ONEOF ( PRODUCT_AS_PLANNED, PRODUCT_AS_REALIZED))" supertypes="product_definition_formation">
			<explicit name="of_product">
				<typename name="product_as_individual"/>
				<redeclaration entity-ref="product_definition_formation"/>
			</explicit>
		</entity>
		<entity name="product_as_individual_view" supertypes="product_definition">
			<explicit name="defined_version">
				<typename name="product_as_individual_version"/>
				<redeclaration entity-ref="product_definition"/>
			</explicit>
		</entity>
		<entity name="product_as_planned" supertypes="product_as_individual_version">
                                    </entity>
		<entity name="product_as_realized" supertypes="product_as_individual_version">
                                    </entity>
		<entity name="product_category">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                                      </where>
		</entity>
		<entity name="product_category_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="category">
				<typename name="product_category"/>
			</explicit>
			<explicit name="sub_category">
				<typename name="product_category"/>
			</explicit>
			<where label="WR1" expression="acyclic_product_category_relationship (SELF, [SELF.sub_category])">
                                      </where>
		</entity>
		<entity name="product_class" supertypes="PRODUCT_CONCEPT characterized_object">
                                    </entity>
		<entity name="product_concept">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="market_context">
				<typename name="product_concept_context"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="id"/>
			</unique>
		</entity>
		<entity name="product_concept_context" supertypes="application_context_element">
			<explicit name="market_segment_type">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="product_concept_feature">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="product_concept_feature_association">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="concept">
				<typename name="product_concept"/>
			</explicit>
			<explicit name="feature">
				<typename name="product_concept_feature"/>
			</explicit>
		</entity>
		<entity name="product_concept_feature_category" supertypes="GROUP">
			<where label="WR1" expression="SIZEOF(QUERY(aga &lt;* USEDIN(SELF, 'PRODUCT_CLASS_MIM.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |('PRODUCT_CLASS_MIM.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) AND((aga.role.name &lt;&gt; 'specification category member') OR(SIZEOF(QUERY (i &lt;* aga.items | ('PRODUCT_CLASS_MIM.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF (i)) AND NOT ('PRODUCT_CLASS_MIM.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i)))) &lt;&gt; SIZEOF (aga.items))))) =0">
                                      </where>
		</entity>
		<entity name="product_concept_feature_category_usage" supertypes="GROUP_ASSIGNMENT">
			<explicit name="assigned_group">
				<typename name="product_concept_feature_category"/>
				<redeclaration entity-ref="group_assignment"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="category_usage_item"/>
			</explicit>
			<where label="WR1" expression="SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ]">
                                        </where>
		</entity>
		<entity name="product_concept_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_product_concept">
				<typename name="product_concept"/>
			</explicit>
			<explicit name="related_product_concept">
				<typename name="product_concept"/>
			</explicit>
		</entity>
		<entity name="product_context" supertypes="application_context_element">
			<explicit name="discipline_type">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="product_definition">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="formation">
				<typename name="product_definition_formation"/>
			</explicit>
			<explicit name="frame_of_reference">
				<typename name="product_definition_context"/>
			</explicit>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
                                        </where>
		</entity>
		<entity name="product_definition_context" supertypes="application_context_element">
			<explicit name="life_cycle_stage">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="product_definition_context_association">
			<explicit name="definition">
				<typename name="product_definition"/>
			</explicit>
			<explicit name="frame_of_reference">
				<typename name="product_definition_context"/>
			</explicit>
			<explicit name="role">
				<typename name="product_definition_context_role"/>
			</explicit>
		</entity>
		<entity name="product_definition_context_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="product_definition_effectivity" supertypes="effectivity">
			<explicit name="usage">
				<typename name="product_definition_relationship"/>
			</explicit>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0">
                                        </where>
		</entity>
		<entity name="product_definition_element_relationship" supertypes="GROUP">
                                      </entity>
		<entity name="product_definition_formation">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="of_product">
				<typename name="product"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="id"/>
				<unique.attribute attribute="of_product"/>
			</unique>
		</entity>
		<entity name="product_definition_formation_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_product_definition_formation">
				<typename name="product_definition_formation"/>
			</explicit>
			<explicit name="related_product_definition_formation">
				<typename name="product_definition_formation"/>
			</explicit>
		</entity>
		<entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
			<explicit name="make_or_buy">
				<typename name="source"/>
			</explicit>
		</entity>
		<entity name="product_definition_group_assignment" supertypes="group_assignment">
			<explicit name="assigned_group">
				<typename name="product_definition_element_relationship"/>
				<redeclaration entity-ref="group_assignment"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="1"/>
				<typename name="product_definition_or_product_definition_relationship"/>
			</explicit>
		</entity>
		<entity name="product_definition_occurrence_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="occurrence">
				<typename name="product_definition"/>
			</explicit>
			<explicit name="occurrence_usage">
				<typename name="assembly_component_usage"/>
			</explicit>
			<where label="WR1" expression="occurrence_usage.relating_product_definition :&lt;&gt;: occurrence">
                                          </where>
			<where label="WR2" expression="occurrence_usage.related_product_definition :&lt;&gt;: occurrence">
                                          </where>
			<where label="WR3" expression="occurrence.formation :=: occurrence_usage.related_product_definition.formation">
                                          </where>
		</entity>
		<entity name="product_definition_process" supertypes="action">
			<explicit name="identification">
				<typename name="identifier"/>
			</explicit>
			<inverse name="product_definitions" entity="process_product_association" attribute="process">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
		</entity>
		<entity name="product_definition_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_product_definition">
				<typename name="product_definition"/>
			</explicit>
			<explicit name="related_product_definition">
				<typename name="product_definition"/>
			</explicit>
		</entity>
		<entity name="product_definition_shape" supertypes="property_definition">
			<unique label="UR1">
				<unique.attribute attribute="definition"/>
			</unique>
			<where label="WR1" expression="SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) &gt; 0">
                                          </where>
		</entity>
		<entity name="product_definition_substitute">
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="context_relationship">
				<typename name="product_definition_relationship"/>
			</explicit>
			<explicit name="substitute_definition">
				<typename name="product_definition"/>
			</explicit>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<where label="WR1" expression="context_relationship.related_product_definition :&lt;&gt;: substitute_definition">
                                          </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
                                          </where>
		</entity>
		<entity name="product_definition_usage" super.expression="(ONEOF ( MAKE_FROM_USAGE_OPTION, ASSEMBLY_COMPONENT_USAGE))" supertypes="product_definition_relationship">
			<where label="WR1" expression="acyclic_product_definition_relationship(SELF,[SELF\product_definition_relationship.related_product_definition],'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE')">
                                          </where>
		</entity>
		<entity name="product_definition_with_associated_documents" supertypes="product_definition">
			<explicit name="documentation_ids">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="document"/>
			</explicit>
		</entity>
		<entity name="product_design_to_individual" supertypes="product_relationship">
			<explicit name="individual_product">
				<typename name="product_as_individual"/>
				<redeclaration entity-ref="product_relationship"/>
			</explicit>
			<explicit name="product_design">
				<typename name="product"/>
				<redeclaration entity-ref="product_relationship"/>
			</explicit>
		</entity>
		<entity name="product_design_version_to_individual" supertypes="product_definition_formation_relationship">
			<explicit name="individual_product">
				<typename name="product_as_individual_version"/>
				<redeclaration entity-ref="product_definition_formation_relationship"/>
			</explicit>
			<explicit name="product_design_version">
				<typename name="product_definition_formation"/>
				<redeclaration entity-ref="product_definition_formation_relationship"/>
			</explicit>
		</entity>
		<entity name="product_identification" supertypes="CONFIGURATION_ITEM characterized_object">
			<explicit name="item_concept">
				<typename name="PRODUCT_CLASS"/>
				<redeclaration entity-ref="configuration_item"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY (cd &lt;* USEDIN (SELF ,'SPECIFIED_PRODUCT_MIM.CONFIGURATION_DESIGN.CONFIGURATION') |('SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF (cd. design)) AND(SIZEOF (QUERY (prpc &lt;* USEDIN (cd. design\product_definition_formation.of_product ,'SPECIFIED_PRODUCT_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc. name IN ['part' , 'raw material' , 'tool'])) &gt;0))) &lt;=1">
                                                    </where>
			<where label="WR2" expression="NOT ('SPECIFIED_PRODUCT_MIM.'+ 'CONFIGURABLE_ITEM' IN TYPEOF(SELF)) XOR('SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF (SELF))">
                                                    </where>
		</entity>
		<entity name="product_material_composition_relationship" supertypes="product_definition_relationship">
			<explicit name="class">
				<typename name="label"/>
			</explicit>
			<explicit name="constituent_amount">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="measure_with_unit"/>
			</explicit>
			<explicit name="composition_basis">
				<typename name="label"/>
			</explicit>
			<explicit name="determination_method">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="product_planned_to_realized" supertypes="product_definition_formation_relationship">
			<explicit name="planned_product">
				<typename name="product_as_planned"/>
				<redeclaration entity-ref="product_definition_formation_relationship"/>
			</explicit>
			<explicit name="realized_product">
				<typename name="product_as_realized"/>
				<redeclaration entity-ref="product_definition_formation_relationship"/>
			</explicit>
		</entity>
		<entity name="product_related_product_category" supertypes="product_category">
			<explicit name="products">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product"/>
			</explicit>
		</entity>
		<entity name="product_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_product">
				<typename name="product"/>
			</explicit>
			<explicit name="related_product">
				<typename name="product"/>
			</explicit>
		</entity>
		<entity name="product_specification" supertypes="product_identification configurable_item">
                                                      </entity>
		<entity name="projected_zone_definition" supertypes="tolerance_zone_definition">
			<explicit name="projection_end">
				<typename name="shape_aspect"/>
			</explicit>
			<explicit name="projected_length">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="('NUMBER' IN TYPEOF(projected_length\measure_with_unit.value_component)) AND(projected_length\measure_with_unit.value_component &gt; 0.0)">
                                                        </where>
			<where label="WR2" expression="(derive_dimensional_exponents(projected_length\measure_with_unit.unit_component)= dimensional_exponents(1,0,0,0,0,0,0))">
                                                        </where>
		</entity>
		<entity name="promissory_usage_occurrence" supertypes="assembly_component_usage">
                                                      </entity>
		<entity name="property_definition">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="definition">
				<typename name="characterized_definition"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                                                        </where>
		</entity>
		<entity name="property_definition_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_property_definition">
				<typename name="property_definition"/>
			</explicit>
			<explicit name="related_property_definition">
				<typename name="property_definition"/>
			</explicit>
		</entity>
		<entity name="property_definition_representation">
			<explicit name="definition">
				<typename name="represented_definition"/>
			</explicit>
			<explicit name="used_representation">
				<typename name="representation"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<derived name="name" expression="get_name_value (SELF)">
				<typename name="label"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                                                        </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1">
                                                        </where>
		</entity>
		<entity name="property_process" supertypes="action">
			<explicit name="identification">
				<typename name="identifier"/>
			</explicit>
			<inverse name="properties" entity="process_property_association" attribute="process">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
		</entity>
		<entity name="pyramid_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="xlength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ylength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="qualification">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="qualification_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_qualification">
				<typename name="QUALIFICATION"/>
			</explicit>
			<explicit name="role">
				<typename name="qualification_role"/>
			</explicit>
		</entity>
		<entity name="qualification_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_qualification">
				<typename name="qualification"/>
			</explicit>
			<explicit name="related_qualification">
				<typename name="qualification"/>
			</explicit>
		</entity>
		<entity name="qualification_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="qualification_type">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="qualification_type_assignment" abstract.supertype="YES">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
			<explicit name="assigned_qualification_type">
				<typename name="QUALIFICATION_TYPE"/>
			</explicit>
			<explicit name="role">
				<typename name="qualification_type_role"/>
			</explicit>
		</entity>
		<entity name="qualification_type_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_qualification_type">
				<typename name="qualification_type"/>
			</explicit>
			<explicit name="related_qualification_type">
				<typename name="qualification_type"/>
			</explicit>
		</entity>
		<entity name="qualification_type_role">
			<explicit name="id">
				<typename name="IDENTIFIER"/>
			</explicit>
			<explicit name="name">
				<typename name="LABEL"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="TEXT"/>
			</explicit>
		</entity>
		<entity name="qualified_representation_item" supertypes="representation_item">
			<explicit name="qualifiers">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="value_qualifier"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp))) &lt; 2">
                                                        </where>
		</entity>
		<entity name="qualitative_uncertainty" supertypes="uncertainty_qualifier">
			<explicit name="uncertainty_value">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
			<explicit name="quantity">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component &gt; 0)">
                                                        </where>
		</entity>
		<entity name="quasi_uniform_curve" supertypes="b_spline_curve">
                                                      </entity>
		<entity name="quasi_uniform_surface" supertypes="b_spline_surface">
                                                      </entity>
		<entity name="quasi_uniform_volume" supertypes="b_spline_volume">
                                                      </entity>
		<entity name="ratio_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                                        </where>
		</entity>
		<entity name="ratio_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                                                        </where>
		</entity>
		<entity name="rational_b_spline_curve" supertypes="b_spline_curve">
			<explicit name="weights_data">
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="REAL"/>
			</explicit>
			<derived name="weights" expression="list_to_array(weights_data,0, upper_index_on_control_points)">
				<aggregate type="ARRAY" lower="0" upper="100"/>
				<builtintype type="REAL"/>
			</derived>
			<where label="WR1" expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. control_points_list)">
                                                        </where>
			<where label="WR2" expression="curve_weights_positive(SELF)">
                                                        </where>
		</entity>
		<entity name="rational_b_spline_surface" supertypes="b_spline_surface">
			<explicit name="weights_data">
				<aggregate type="LIST" lower="2" upper="?"/>
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="REAL"/>
			</explicit>
			<derived name="weights" expression="make_array_of_array(weights_data, 0, u_upper, 0, v_upper)">
				<aggregate type="ARRAY" lower="0" upper="u_upper"/>
				<aggregate type="ARRAY" lower="0" upper="v_upper"/>
				<builtintype type="REAL"/>
			</derived>
			<where label="WR1" expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]))">
                                                        </where>
			<where label="WR2" expression="surface_weights_positive(SELF)">
                                                        </where>
		</entity>
		<entity name="rational_b_spline_volume" supertypes="b_spline_volume">
			<explicit name="weights_data">
				<aggregate type="LIST" lower="2" upper="?"/>
				<aggregate type="LIST" lower="2" upper="?"/>
				<aggregate type="LIST" lower="2" upper="?"/>
				<builtintype type="REAL"/>
			</explicit>
			<derived name="weights" expression="make_array_of_array_of_array(weights_data, 0, u_upper, 0, v_upper, 0, w_upper)">
				<aggregate type="ARRAY" lower="0" upper="u_upper"/>
				<aggregate type="ARRAY" lower="0" upper="v_upper"/>
				<aggregate type="ARRAY" lower="0" upper="w_upper"/>
				<builtintype type="REAL"/>
			</derived>
			<where label="WR1" expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))">
                                                        </where>
			<where label="WR2" expression="volume_weights_positive(SELF)">
                                                        </where>
		</entity>
		<entity name="rectangle_domain" supertypes="founded_item">
			<explicit name="corner">
				<typename name="CARTESIAN_POINT"/>
			</explicit>
			<explicit name="xlength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ylength">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(QUERY(item &lt;* USEDIN(SELF, '')| NOT('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0">
                                                        </where>
		</entity>
		<entity name="rectangled_half_space" supertypes="half_space_2d">
			<explicit name="enclosure">
				<typename name="rectangle_domain"/>
			</explicit>
		</entity>
		<entity name="rectangular_area" supertypes="primitive_2d">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_2D"/>
			</explicit>
			<explicit name="x">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="y">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="rectangular_composite_surface" supertypes="bounded_surface">
			<explicit name="segments">
				<aggregate type="LIST" lower="1" upper="?"/>
				<typename name="LIST"/>
			</explicit>
			<derived name="n_u" expression="SIZEOF(segments)">
				<builtintype type="INTEGER"/>
			</derived>
			<derived name="n_v" expression="SIZEOF(segments[1])">
				<builtintype type="INTEGER"/>
			</derived>
			<where label="WR1" expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0">
                                                        </where>
			<where label="WR2" expression="constraints_rectangular_composite_surface(SELF)">
                                                        </where>
		</entity>
		<entity name="rectangular_pyramid" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="xlength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ylength">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
			<explicit name="basis_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="u1">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="u2">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v1">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v2">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="usense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<explicit name="vsense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<where label="WR1" expression="u1 &lt;&gt; u2">
                                                        </where>
			<where label="WR2" expression="v1 &lt;&gt; v2">
                                                        </where>
			<where label="WR3" expression="(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 &gt; u1))">
                                                        </where>
			<where label="WR4" expression="(('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 &gt; v1))">
                                                        </where>
		</entity>
		<entity name="referenced_modified_datum" supertypes="datum_reference">
			<explicit name="modifier">
				<typename name="limit_condition"/>
			</explicit>
		</entity>
		<entity name="relative_event_occurrence" supertypes="event_occurrence">
			<explicit name="base_event">
				<typename name="event_occurrence"/>
			</explicit>
			<explicit name="offset">
				<typename name="time_measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
			<explicit name="param_length">
				<typename name="parameter_value"/>
			</explicit>
			<where label="WR1" expression="param_length &gt; 0.0">
                                                        </where>
		</entity>
		<entity name="replacement_relationship" supertypes="action_relationship">
			<where label="WR1" expression="acyclic_action_relationship (SELF,[SELF\action_relationship.related_action],'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP')">
                                                        </where>
		</entity>
		<entity name="representation">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="items">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="representation_item"/>
			</explicit>
			<explicit name="context_of_items">
				<typename name="representation_context"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1">
                                                        </where>
			<where label="WR2" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1">
                                                        </where>
		</entity>
		<entity name="representation_context">
			<explicit name="context_identifier">
				<typename name="identifier"/>
			</explicit>
			<explicit name="context_type">
				<typename name="text"/>
			</explicit>
			<inverse name="representations_in_context" entity="representation" attribute="context_of_items">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
		</entity>
		<entity name="representation_item">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(using_representations(SELF)) &gt; 0">
                                                        </where>
		</entity>
		<entity name="representation_item_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_representation_item">
				<typename name="representation_item"/>
			</explicit>
			<explicit name="related_representation_item">
				<typename name="representation_item"/>
			</explicit>
		</entity>
		<entity name="representation_map">
			<explicit name="mapping_origin">
				<typename name="representation_item"/>
			</explicit>
			<explicit name="mapped_representation">
				<typename name="representation"/>
			</explicit>
			<inverse name="map_usage" entity="mapped_item" attribute="mapping_source">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items)">
                                                        </where>
		</entity>
		<entity name="representation_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="rep_1">
				<typename name="representation"/>
			</explicit>
			<explicit name="rep_2">
				<typename name="representation"/>
			</explicit>
		</entity>
		<entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
			<explicit name="transformation_operator">
				<typename name="transformation"/>
			</explicit>
			<where label="WR1" expression="SELF\representation_relationship.rep_1.context_of_items:&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items">
                                                        </where>
		</entity>
		<entity name="requirement_for_action_resource" supertypes="action_resource_requirement">
			<explicit name="resources">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="action_resource"/>
			</explicit>
		</entity>
		<entity name="resource_property">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="resource">
				<typename name="characterized_resource_definition"/>
			</explicit>
		</entity>
		<entity name="resource_property_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_resource_property">
				<typename name="resource_property"/>
			</explicit>
			<explicit name="related_resource_property">
				<typename name="resource_property"/>
			</explicit>
			<where label="WR1" expression="relating_resource_property :&lt;&gt;: related_resource_property">
                                                        </where>
		</entity>
		<entity name="resource_requirement_type">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="resource_requirement_type_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_requirement_type">
				<typename name="resource_requirement_type"/>
			</explicit>
			<explicit name="related_requirement_type">
				<typename name="resource_requirement_type"/>
			</explicit>
			<where label="WR1" expression="relating_requirement_type :&lt;&gt;: related_requirement_type">
                                                        </where>
		</entity>
		<entity name="revolved_area_solid" supertypes="swept_area_solid">
			<explicit name="axis">
				<typename name="AXIS1_PLACEMENT"/>
			</explicit>
			<explicit name="angle">
				<typename name="plane_angle_measure"/>
			</explicit>
			<derived name="axis_line" expression="representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0))">
				<typename name="LINE"/>
			</derived>
		</entity>
		<entity name="revolved_face_solid" supertypes="swept_face_solid">
			<explicit name="axis">
				<typename name="AXIS1_PLACEMENT"/>
			</explicit>
			<explicit name="angle">
				<typename name="plane_angle_measure"/>
			</explicit>
			<derived name="axis_line" expression="representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0))">
				<typename name="LINE"/>
			</derived>
		</entity>
		<entity name="right_angular_wedge" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS2_PLACEMENT_3D"/>
			</explicit>
			<explicit name="x">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="y">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="z">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ltx">
				<typename name="length_measure"/>
			</explicit>
			<where label="WR1" expression="((0.0 &lt;= ltx) AND (ltx &lt; x))">
                                                        </where>
		</entity>
		<entity name="right_circular_cone" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS1_PLACEMENT"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="radius">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="semi_angle">
				<typename name="plane_angle_measure"/>
			</explicit>
			<where label="WR1" expression="radius &gt;= 0.0">
                                                        </where>
		</entity>
		<entity name="right_circular_cylinder" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS1_PLACEMENT"/>
			</explicit>
			<explicit name="height">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="role_association">
			<explicit name="role">
				<typename name="object_role"/>
			</explicit>
			<explicit name="item_with_role">
				<typename name="role_select"/>
			</explicit>
		</entity>
		<entity name="runout_zone_definition" supertypes="tolerance_zone_definition">
			<explicit name="orientation">
				<typename name="runout_zone_orientation"/>
			</explicit>
		</entity>
		<entity name="runout_zone_orientation">
			<explicit name="angle">
				<typename name="measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="runout_zone_orientation_reference_direction" supertypes="runout_zone_orientation">
			<explicit name="orientation_defining_relationship">
				<typename name="shape_aspect_relationship"/>
			</explicit>
		</entity>
		<entity name="seam_curve" supertypes="surface_curve">
			<where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
                                                        </where>
			<where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2])">
                                                        </where>
			<where label="WR3" expression="'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1])">
                                                        </where>
			<where label="WR4" expression="'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2])">
                                                        </where>
		</entity>
		<entity name="seam_edge" supertypes="oriented_edge">
			<explicit name="pcurve_reference">
				<typename name="PCURVE"/>
			</explicit>
			<where label="WR1" expression="('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element)) AND('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF(edge_element\edge_curve.edge_geometry))">
                                                        </where>
			<where label="WR2" expression="pcurve_reference IN edge_element\edge_curve.edge_geometry\ surface_curve.associated_geometry">
                                                        </where>
		</entity>
		<entity name="sectioned_spine" supertypes="geometric_curve_set">
			<explicit name="cross_sections">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="CURVE"/>
			</explicit>
			<explicit name="spine_points">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="POINT"/>
			</explicit>
			<where label="WR1" expression="SIZEOF(SELF\geometric_set.elements) = 1">
                                                        </where>
			<where label="WR2" expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1])">
                                                        </where>
			<where label="WR3" expression="SIZEOF(cross_sections) = SIZEOF(spine_points)">
                                                        </where>
			<where label="WR4" expression="SELF\geometric_representation_item.dim = 3">
                                                        </where>
		</entity>
		<entity name="security_classification">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="purpose">
				<typename name="text"/>
			</explicit>
			<explicit name="security_level">
				<typename name="security_classification_level"/>
			</explicit>
		</entity>
		<entity name="security_classification_assignment" abstract.supertype="YES">
			<explicit name="assigned_security_classification">
				<typename name="SECURITY_CLASSIFICATION"/>
			</explicit>
			<derived name="role" expression="get_role (SELF)">
				<typename name="object_role"/>
			</derived>
			<where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1">
                                                        </where>
		</entity>
		<entity name="security_classification_level">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="serial_numbered_effectivity" supertypes="effectivity">
			<explicit name="effectivity_start_id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="effectivity_end_id" optional="YES">
				<typename name="identifier"/>
			</explicit>
		</entity>
		<entity name="shape_aspect">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="of_shape">
				<typename name="product_definition_shape"/>
			</explicit>
			<explicit name="product_definitional">
				<builtintype type="LOGICAL"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                                                        </where>
		</entity>
		<entity name="shape_aspect_deriving_relationship" supertypes="shape_aspect_relationship">
			<where label="WR1" expression="'SHAPE_ASPECT_DEFINITION_SCHEMA.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT)">
                                                        </where>
		</entity>
		<entity name="shape_aspect_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_shape_aspect">
				<typename name="shape_aspect"/>
			</explicit>
			<explicit name="related_shape_aspect">
				<typename name="shape_aspect"/>
			</explicit>
			<derived name="id" expression="get_id_value (SELF)">
				<typename name="identifier"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1">
                                                        </where>
		</entity>
		<entity name="shape_definition_representation" supertypes="property_definition_representation">
			<where label="WR1" expression="('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition))">
                                                        </where>
			<where label="WR2" expression="'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation)">
                                                        </where>
		</entity>
		<entity name="shape_dimension_representation" supertypes="shape_representation">
			<where label="WR1" expression="SIZEOF (QUERY (temp &lt;* SELF\representation.items | NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (temp)))) = 0">
                                                        </where>
			<where label="WR2" expression="SIZEOF (SELF\representation.items) &lt;= 3">
                                                        </where>
			<where label="WR3" expression="SIZEOF (QUERY (pos_mri &lt;* QUERY (real_mri &lt;* SELF\representation.items | 'REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)) | NOT (pos_mri\measure_with_unit.value_component &gt; 0.0))) = 0">
                                                        </where>
		</entity>
		<entity name="shape_representation" supertypes="representation">
                                                      </entity>
		<entity name="shape_representation_relationship" supertypes="representation_relationship">
			<where label="WR1" expression="'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))">
                                                        </where>
		</entity>
		<entity name="shell_based_surface_model" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="sbsm_boundary">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="SHELL"/>
			</explicit>
			<where label="WR1" expression="constraints_geometry_shell_based_surface_model(SELF)">
                                                        </where>
		</entity>
		<entity name="shell_based_wireframe_model" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="sbwm_boundary">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="SHELL"/>
			</explicit>
			<where label="WR1" expression="constraints_geometry_shell_based_wireframe_model(SELF)">
                                                        </where>
		</entity>
		<entity name="si_unit" supertypes="named_unit">
			<explicit name="prefix" optional="YES">
				<typename name="si_prefix"/>
			</explicit>
			<explicit name="name">
				<typename name="si_unit_name"/>
			</explicit>
			<derived name="dimensions" expression="dimensions_for_si_unit (name)">
				<typename name="dimensional_exponents"/>
				<redeclaration entity-ref="named_unit"/>
			</derived>
		</entity>
		<entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                                          </where>
		</entity>
		<entity name="solid_angle_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                                                          </where>
		</entity>
		<entity name="solid_model" super.expression="(ONEOF ( CSG_SOLID, MANIFOLD_SOLID_BREP, SWEPT_FACE_SOLID, SWEPT_AREA_SOLID, SWEPT_DISK_SOLID, SOLID_REPLICA, BREP_2D, TRIMMED_VOLUME))" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
                                                        </entity>
		<entity name="solid_replica" supertypes="solid_model">
			<explicit name="parent_solid">
				<typename name="solid_model"/>
			</explicit>
			<explicit name="transformation">
				<typename name="CARTESIAN_TRANSFORMATION_OPERATOR_3D"/>
			</explicit>
			<where label="WR1" expression="acyclic_solid_replica(SELF, parent_solid)">
                                                          </where>
			<where label="WR2" expression="parent_solid\geometric_representation_item.dim = 3">
                                                          </where>
		</entity>
		<entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
			<explicit name="upper_usage">
				<typename name="assembly_component_usage"/>
			</explicit>
			<explicit name="next_usage">
				<typename name="next_assembly_usage_occurrence"/>
			</explicit>
			<unique label="UR1">
				<unique.attribute attribute="upper_usage"/>
				<unique.attribute attribute="next_usage"/>
			</unique>
			<where label="WR1" expression="SELF :&lt;&gt;: upper_usage">
                                                          </where>
			<where label="WR2" expression="SELF\product_definition_relationship.relating_product_definition:=: upper_usage.relating_product_definition">
                                                          </where>
			<where label="WR3" expression="SELF\product_definition_relationship.related_product_definition:=: next_usage.related_product_definition">
                                                          </where>
			<where label="WR4" expression="(upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR(SIZEOF (QUERY (pdr &lt;* USEDIN (upper_usage.related_product_definition,'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +'RELATED_PRODUCT_DEFINITION') | pdr.relating_product_definition :=: next_usage.relating_product_definition)) = 1)">
                                                          </where>
			<where label="WR5" expression="SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE','PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']* TYPEOF(upper_usage)) = 1">
                                                          </where>
		</entity>
		<entity name="sphere" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="centre">
				<typename name="POINT"/>
			</explicit>
		</entity>
		<entity name="spherical_point" supertypes="cartesian_point">
			<explicit name="r">
				<typename name="length_measure"/>
			</explicit>
			<explicit name="theta">
				<typename name="plane_angle_measure"/>
			</explicit>
			<explicit name="phi">
				<typename name="plane_angle_measure"/>
			</explicit>
			<derived name="coordinates" expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]">
				<aggregate type="LIST" lower="1" upper="3"/>
				<typename name="length_measure"/>
				<redeclaration entity-ref="cartesian_point"/>
			</derived>
			<where label="WR1" expression="r &gt;= 0.0">
                                                            </where>
		</entity>
		<entity name="spherical_surface" supertypes="elementary_surface">
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="spherical_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="standard_uncertainty" supertypes="uncertainty_qualifier">
			<explicit name="uncertainty_value">
				<builtintype type="REAL"/>
			</explicit>
		</entity>
		<entity name="statistical_distribution_for_tolerance" supertypes="representation">
			<where label="WR1" expression="SIZEOF (QUERY (item &lt;* SELF\representation.items | NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (item)))) = 0">
                                                            </where>
		</entity>
		<entity name="subedge" supertypes="edge">
			<explicit name="parent_edge">
				<typename name="edge"/>
			</explicit>
		</entity>
		<entity name="subface" supertypes="face">
			<explicit name="parent_face">
				<typename name="face"/>
			</explicit>
			<where label="WR1" expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))))">
                                                            </where>
		</entity>
		<entity name="surface" super.expression="(ONEOF ( ELEMENTARY_SURFACE, SWEPT_SURFACE, BOUNDED_SURFACE, OFFSET_SURFACE, SURFACE_REPLICA) ANDOR ORIENTED_SURFACE)" supertypes="geometric_representation_item">
                                                          </entity>
		<entity name="surface_curve" super.expression="(ONEOF ( INTERSECTION_CURVE, SEAM_CURVE) ANDOR BOUNDED_SURFACE_CURVE)" supertypes="curve">
			<explicit name="curve_3d">
				<typename name="curve"/>
			</explicit>
			<explicit name="associated_geometry">
				<aggregate type="LIST" lower="1" upper="2"/>
				<typename name="pcurve_or_surface"/>
			</explicit>
			<explicit name="master_representation">
				<typename name="preferred_surface_curve_representation"/>
			</explicit>
			<derived name="basis_surface" expression="get_basis_surface(SELF)">
				<aggregate type="SET" lower="1" upper="2"/>
				<typename name="surface"/>
			</derived>
			<where label="WR1" expression="curve_3d.dim = 3">
                                                            </where>
			<where label="WR2" expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR(master_representation &lt;&gt; pcurve_s1)">
                                                            </where>
			<where label="WR3" expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR(master_representation &lt;&gt; pcurve_s2)">
                                                            </where>
			<where label="WR4" expression="NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d))">
                                                            </where>
		</entity>
		<entity name="surface_curve_swept_area_solid" supertypes="swept_area_solid">
			<explicit name="directrix">
				<typename name="CURVE"/>
			</explicit>
			<explicit name="start_param">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="end_param">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="reference_surface">
				<typename name="SURFACE"/>
			</explicit>
			<where label="WR1" expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR(reference_surface IN (directrix\surface_curve.basis_surface))">
                                                            </where>
		</entity>
		<entity name="surface_curve_swept_face_solid" supertypes="swept_face_solid">
			<explicit name="directrix">
				<typename name="CURVE"/>
			</explicit>
			<explicit name="start_param">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="end_param">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="reference_surface">
				<typename name="SURFACE"/>
			</explicit>
			<where label="WR1" expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR(reference_surface IN (directrix\surface_curve.basis_surface))">
                                                            </where>
		</entity>
		<entity name="surface_curve_swept_surface" supertypes="swept_surface">
			<explicit name="directrix">
				<typename name="curve"/>
			</explicit>
			<explicit name="reference_surface">
				<typename name="surface"/>
			</explicit>
			<where label="WR1" expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR(reference_surface IN (directrix\surface_curve.basis_surface))">
                                                            </where>
		</entity>
		<entity name="surface_of_linear_extrusion" supertypes="swept_surface">
			<explicit name="extrusion_axis">
				<typename name="vector"/>
			</explicit>
		</entity>
		<entity name="surface_of_revolution" supertypes="swept_surface">
			<explicit name="axis_position">
				<typename name="axis1_placement"/>
			</explicit>
			<derived name="axis_line" expression="representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0))">
				<typename name="line"/>
			</derived>
		</entity>
		<entity name="surface_patch" supertypes="founded_item">
			<explicit name="parent_surface">
				<typename name="bounded_surface"/>
			</explicit>
			<explicit name="u_transition">
				<typename name="transition_code"/>
			</explicit>
			<explicit name="v_transition">
				<typename name="transition_code"/>
			</explicit>
			<explicit name="u_sense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<explicit name="v_sense">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<inverse name="using_surfaces" entity="rectangular_composite_surface" attribute="segments">
				<inverse.aggregate type="BAG" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="(NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)))">
                                                            </where>
		</entity>
		<entity name="surface_replica" supertypes="surface">
			<explicit name="parent_surface">
				<typename name="surface"/>
			</explicit>
			<explicit name="transformation">
				<typename name="cartesian_transformation_operator_3d"/>
			</explicit>
			<where label="WR1" expression="acyclic_surface_replica(SELF, parent_surface)">
                                                            </where>
		</entity>
		<entity name="surface_texture_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="SIZEOF (QUERY (i &lt;* SELF.items | SIZEOF (['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE' , 'SURFACE_CONDITIONS_MIM.'+'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF (i)) &lt;&gt;1))=0">
                                                            </where>
			<where label="WR2" expression="(SIZEOF (QUERY (i &lt;* SELF.items | 'SURFACE_CONDITIONS_MIM.'+'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (i))) =1) AND (SIZEOF (QUERY (i &lt;* SELF.items | ('SURFACE_CONDITIONS_MIM.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (i)) AND (i.name = 'measuring method'))) =1)">
                                                            </where>
			<where label="WR3" expression="SIZEOF (QUERY (i &lt;* SELF.items | SIZEOF (['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF (i)) =1))&gt;0">
                                                            </where>
			<where label="WR4" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+'REP_1')) &lt;=1) AND (SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+'REP_2')) =0) AND (SIZEOF (QUERY (rr &lt;* USEDIN (SELF, 'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+'REP_1') | rr. rep_2.name = 'measuring direction')) = SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+'REP_1')))">
                                                            </where>
			<where label="WR5" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION')) =1) AND (SIZEOF (QUERY (pdr&lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | SIZEOF (QUERY (gpa &lt;* USEDIN (pdr. definition ,'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+'DERIVED_DEFINITION') | ('SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY' IN TYPEOF (gpa. base_definition)) AND(gpa. base_definition.name ='surface_condition'))) =1)) =1)">
                                                            </where>
		</entity>
		<entity name="swept_area_solid" super.expression="(ONEOF ( REVOLVED_AREA_SOLID, EXTRUDED_AREA_SOLID, SURFACE_CURVE_SWEPT_AREA_SOLID))" supertypes="solid_model">
			<explicit name="swept_area">
				<typename name="CURVE_BOUNDED_SURFACE"/>
			</explicit>
			<where label="WR1" expression="'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface)">
                                                            </where>
		</entity>
		<entity name="swept_disk_solid" supertypes="solid_model">
			<explicit name="directrix">
				<typename name="CURVE"/>
			</explicit>
			<explicit name="radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="inner_radius" optional="YES">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="start_param">
				<builtintype type="REAL"/>
			</explicit>
			<explicit name="end_param">
				<builtintype type="REAL"/>
			</explicit>
			<where label="WR1" expression="directrix.dim = 3">
                                                            </where>
			<where label="WR2" expression="(NOT EXISTS(inner_radius)) OR (radius &gt; inner_radius)">
                                                            </where>
		</entity>
		<entity name="swept_face_solid" super.expression="(ONEOF ( EXTRUDED_FACE_SOLID, REVOLVED_FACE_SOLID, SURFACE_CURVE_SWEPT_FACE_SOLID))" supertypes="solid_model">
			<explicit name="swept_face">
				<typename name="FACE_SURFACE"/>
			</explicit>
			<where label="WR1" expression="'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry)">
                                                            </where>
		</entity>
		<entity name="swept_surface" super.expression="(ONEOF ( SURFACE_OF_LINEAR_EXTRUSION, SURFACE_OF_REVOLUTION, SURFACE_CURVE_SWEPT_SURFACE, FIXED_REFERENCE_SWEPT_SURFACE))" supertypes="surface">
			<explicit name="swept_curve">
				<typename name="curve"/>
			</explicit>
		</entity>
		<entity name="symmetric_shape_aspect" supertypes="shape_aspect">
			<inverse name="basis_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
				<inverse.aggregate type="SET" lower="1" upper="?"/>
			</inverse>
			<where label="WR1" expression="SIZEOF (QUERY (x&lt;*SELF\symmetric_shape_aspect.basis_relationships |'SHAPE_ASPECT_DEFINITION_SCHEMA.CENTRE_OF_SYMMETRY' IN TYPEOF(x\shape_aspect_relationship.related_shape_aspect)))&gt;=1">
                                                            </where>
		</entity>
		<entity name="tactile_appearance_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="SIZEOF (QUERY (i &lt;* SELF.items | SIZEOF (['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF (i)) &lt;&gt;1)) =0">
                                                            </where>
			<where label="WR2" expression="SIZEOF (QUERY (i &lt;* SELF.items | name ='depth')) &lt;=1">
                                                            </where>
			<where label="WR3" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION')) =1) AND (SIZEOF (QUERY (pdr&lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | SIZEOF (QUERY (gpa &lt;* USEDIN (pdr. definition ,'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+'DERIVED_DEFINITION') | ('SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY' IN TYPEOF (gpa. base_definition)) AND(gpa. base_definition.name ='surface_condition'))) =1)) =1)">
                                                            </where>
		</entity>
		<entity name="tangent" supertypes="derived_shape_aspect">
			<where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1">
                                                            </where>
		</entity>
		<entity name="tetrahedron" supertypes="faceted_primitive">
			<where label="WR1" expression="SIZEOF(points) = 4">
                                                            </where>
			<where label="WR2" expression="above_plane(points[1], points[2], points[3], points[4]) &lt;&gt; 0.0">
                                                            </where>
		</entity>
		<entity name="tetrahedron_volume" supertypes="volume">
			<explicit name="point_1">
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="point_2">
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="point_3">
				<typename name="cartesian_point"/>
			</explicit>
			<explicit name="point_4">
				<typename name="cartesian_point"/>
			</explicit>
			<where label="WR1" expression="point_1.dim = 3">
                                                            </where>
			<where label="WR2" expression="above_plane(point_1, point_2, point_3, point_4) &lt;&gt; 0.0">
                                                            </where>
		</entity>
		<entity name="thermodynamic_temperature_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                                            </where>
		</entity>
		<entity name="thermodynamic_temperature_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                                                            </where>
		</entity>
		<entity name="time_assignment" abstract.supertype="YES">
			<explicit name="assigned_time">
				<typename name="LOCAL_TIME"/>
			</explicit>
			<explicit name="role">
				<typename name="TIME_ROLE"/>
			</explicit>
		</entity>
		<entity name="time_interval">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="time_interval_assignment" abstract.supertype="YES">
			<explicit name="assigned_time_interval">
				<typename name="TIME_INTERVAL"/>
			</explicit>
			<explicit name="role">
				<typename name="TIME_INTERVAL_ROLE"/>
			</explicit>
		</entity>
		<entity name="time_interval_based_effectivity" supertypes="effectivity">
			<explicit name="effectivity_period">
				<typename name="time_interval"/>
			</explicit>
		</entity>
		<entity name="time_interval_relationship">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_time_interval">
				<typename name="time_interval"/>
			</explicit>
			<explicit name="related_time_interval">
				<typename name="time_interval"/>
			</explicit>
		</entity>
		<entity name="time_interval_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="time_interval_with_bounds" supertypes="time_interval">
			<explicit name="primary_bound" optional="YES">
				<typename name="date_time_or_event_occurrence"/>
			</explicit>
			<explicit name="secondary_bound" optional="YES">
				<typename name="date_time_or_event_occurrence"/>
			</explicit>
			<explicit name="duration" optional="YES">
				<typename name="time_measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="NOT (EXISTS(secondary_bound) AND EXISTS(duration))">
                                                            </where>
			<where label="WR2" expression="EXISTS(primary_bound) OR EXISTS(secondary_bound)">
                                                            </where>
		</entity>
		<entity name="time_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                                            </where>
		</entity>
		<entity name="time_role">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<derived name="description" expression="get_description_value (SELF)">
				<typename name="text"/>
			</derived>
			<where label="WR1" expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                                                            </where>
		</entity>
		<entity name="time_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)">
                                                            </where>
		</entity>
		<entity name="tolerance_value">
			<explicit name="lower_bound">
				<typename name="measure_with_unit"/>
			</explicit>
			<explicit name="upper_bound">
				<typename name="measure_with_unit"/>
			</explicit>
			<where label="WR1" expression="upper_bound\measure_with_unit.value_component &gt; lower_bound\measure_with_unit.value_component">
                                                            </where>
			<where label="WR2" expression="upper_bound\measure_with_unit.unit_component = lower_bound\measure_with_unit.unit_component">
                                                            </where>
		</entity>
		<entity name="tolerance_with_statistical_distribution">
			<explicit name="associated_tolerance">
				<typename name="shape_tolerance_select"/>
			</explicit>
			<explicit name="tolerance_allocation">
				<typename name="statistical_distribution_for_tolerance"/>
			</explicit>
		</entity>
		<entity name="tolerance_zone" supertypes="shape_aspect">
			<explicit name="defining_tolerance">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="geometric_tolerance"/>
			</explicit>
			<explicit name="form">
				<typename name="tolerance_zone_form"/>
			</explicit>
		</entity>
		<entity name="tolerance_zone_definition" super.expression="(ONEOF ( PROJECTED_ZONE_DEFINITION, RUNOUT_ZONE_DEFINITION))">
			<explicit name="zone">
				<typename name="tolerance_zone"/>
			</explicit>
			<explicit name="boundaries">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="shape_aspect"/>
			</explicit>
		</entity>
		<entity name="tolerance_zone_form">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="topological_representation_item" super.expression="(ONEOF ( VERTEX, EDGE, FACE_BOUND, FACE, VERTEX_SHELL, WIRE_SHELL, CONNECTED_EDGE_SET, CONNECTED_FACE_SET, LOOP ANDOR PATH))" supertypes="representation_item">
                                                          </entity>
		<entity name="toroidal_surface" supertypes="elementary_surface">
			<explicit name="major_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="minor_radius">
				<typename name="positive_length_measure"/>
			</explicit>
		</entity>
		<entity name="toroidal_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="major_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="minor_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="minor_radius &lt; major_radius">
                                                            </where>
		</entity>
		<entity name="torus" supertypes="GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="position">
				<typename name="AXIS1_PLACEMENT"/>
			</explicit>
			<explicit name="major_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="minor_radius">
				<typename name="positive_length_measure"/>
			</explicit>
			<where label="WR1" expression="major_radius &gt; minor_radius">
                                                            </where>
		</entity>
		<entity name="trimmed_curve" supertypes="bounded_curve">
			<explicit name="basis_curve">
				<typename name="curve"/>
			</explicit>
			<explicit name="trim_1">
				<aggregate type="SET" lower="1" upper="2"/>
				<typename name="trimming_select"/>
			</explicit>
			<explicit name="trim_2">
				<aggregate type="SET" lower="1" upper="2"/>
				<typename name="trimming_select"/>
			</explicit>
			<explicit name="sense_agreement">
				<builtintype type="BOOLEAN"/>
			</explicit>
			<explicit name="master_representation">
				<typename name="trimming_preference"/>
			</explicit>
			<where label="WR1" expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))">
                                                            </where>
			<where label="WR2" expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))">
                                                            </where>
		</entity>
		<entity name="trimmed_volume" supertypes="solid_model">
			<explicit name="basis_volume">
				<typename name="VOLUME"/>
			</explicit>
			<explicit name="u1">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="u2">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v1">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="v2">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="w1">
				<typename name="parameter_value"/>
			</explicit>
			<explicit name="w2">
				<typename name="parameter_value"/>
			</explicit>
			<where label="WR1" expression="u1 &lt;&gt; u2">
                                                            </where>
			<where label="WR2" expression="v1 &lt;&gt; v2">
                                                            </where>
			<where label="WR3" expression="w1 &lt;&gt; w2">
                                                            </where>
		</entity>
		<entity name="type_qualifier">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
		</entity>
		<entity name="uncertainty_assigned_representation" supertypes="representation">
			<explicit name="uncertainty">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="uncertainty_measure_with_unit"/>
			</explicit>
		</entity>
		<entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<where label="WR1" expression="valid_measure_value (SELF\measure_with_unit.value_component)">
                                                            </where>
		</entity>
		<entity name="uncertainty_qualifier" super.expression="(ONEOF ( STANDARD_UNCERTAINTY, QUALITATIVE_UNCERTAINTY))">
			<explicit name="measure_name">
				<typename name="label"/>
			</explicit>
			<explicit name="description">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="uniform_curve" supertypes="b_spline_curve">
                                                          </entity>
		<entity name="uniform_surface" supertypes="b_spline_surface">
                                                          </entity>
		<entity name="uniform_volume" supertypes="b_spline_volume">
                                                          </entity>
		<entity name="value_range" supertypes="compound_representation_item">
			<where label="WR1" expression="('value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF (item_element)) AND value_range_wr1 (item_element)">
                                                            </where>
			<where label="WR2" expression="value_range_wr2 (item_element)">
                                                            </where>
			<where label="WR3" expression="value_range_wr3 (item_element)">
                                                            </where>
		</entity>
		<entity name="value_representation_item" supertypes="representation_item">
			<explicit name="value_component">
				<typename name="measure_value"/>
			</explicit>
			<where label="WR1" expression="SIZEOF (QUERY (rep &lt;* using_representations (SELF) | NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF (rep.context_of_items)))) = 0">
                                                            </where>
		</entity>
		<entity name="vector" supertypes="geometric_representation_item">
			<explicit name="orientation">
				<typename name="direction"/>
			</explicit>
			<explicit name="magnitude">
				<typename name="length_measure"/>
			</explicit>
			<where label="WR1" expression="magnitude &gt;= 0.0">
                                                            </where>
		</entity>
		<entity name="versioned_action_request">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="version">
				<typename name="label"/>
			</explicit>
			<explicit name="purpose">
				<typename name="text"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
		</entity>
		<entity name="versioned_action_request_relationship">
			<explicit name="id">
				<typename name="identifier"/>
			</explicit>
			<explicit name="name">
				<typename name="label"/>
			</explicit>
			<explicit name="description" optional="YES">
				<typename name="text"/>
			</explicit>
			<explicit name="relating_versioned_action_request">
				<typename name="versioned_action_request"/>
			</explicit>
			<explicit name="related_versioned_action_request">
				<typename name="versioned_action_request"/>
			</explicit>
		</entity>
		<entity name="vertex" supertypes="topological_representation_item">
                                                          </entity>
		<entity name="vertex_loop" supertypes="loop">
			<explicit name="loop_vertex">
				<typename name="vertex"/>
			</explicit>
		</entity>
		<entity name="vertex_point" supertypes="vertex GEOMETRIC_REPRESENTATION_ITEM">
			<explicit name="vertex_geometry">
				<typename name="POINT"/>
			</explicit>
		</entity>
		<entity name="vertex_shell" supertypes="topological_representation_item">
			<explicit name="vertex_shell_extent">
				<typename name="vertex_loop"/>
			</explicit>
		</entity>
		<entity name="visual_appearance_representation" supertypes="REPRESENTATION">
			<where label="WR1" expression="({2&lt;= SIZEOF (SELF.items) &lt;=5}) AND (SIZEOF (QUERY (i &lt;* items | ('SURFACE_CONDITIONS_MIM.'+'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (i)) AND (i.name IN [ 'colour id' , 'colour name' , 'lustre' ,'pattern' , 'transparency']))) = SIZEOF (SELF.items))">
                                                            </where>
			<where label="WR2" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name = 'colour id')) =1">
                                                            </where>
			<where label="WR3" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='lustre'))=1">
                                                            </where>
			<where label="WR4" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name = 'colour name')) &lt;=1">
                                                            </where>
			<where label="WR5" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='pattern'))&lt;=1">
                                                            </where>
			<where label="WR6" expression="SIZEOF (QUERY (i &lt;* SELF.items | i.name ='transparency')) &lt;=1">
                                                            </where>
			<where label="WR7" expression="(SIZEOF (USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION')) =1) AND (SIZEOF (QUERY (pdr&lt;* USEDIN (SELF ,'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+'USED_REPRESENTATION') | SIZEOF (QUERY (gpa &lt;* USEDIN (pdr. definition ,'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+'DERIVED_DEFINITION') | ('SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY' IN TYPEOF (gpa. base_definition)) AND(gpa. base_definition.name ='surface_condition'))) =1)) =1)">
                                                            </where>
		</entity>
		<entity name="volume" super.expression="(ONEOF ( BLOCK_VOLUME, WEDGE_VOLUME, SPHERICAL_VOLUME, CYLINDRICAL_VOLUME, ECCENTRIC_CONICAL_VOLUME, TOROIDAL_VOLUME, PYRAMID_VOLUME, B_SPLINE_VOLUME, ELLIPSOID_VOLUME, TETRAHEDRON_VOLUME, HEXAHEDRON_VOLUME))" supertypes="geometric_representation_item">
			<where label="WR1" expression="SELF\geometric_representation_item.dim = 3">
                                                            </where>
		</entity>
		<entity name="volume_measure_with_unit" supertypes="measure_with_unit">
			<where label="WR1" expression="'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
                                                            </where>
		</entity>
		<entity name="volume_unit" supertypes="named_unit">
			<where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)">
                                                            </where>
		</entity>
		<entity name="wedge_volume" supertypes="volume">
			<explicit name="position">
				<typename name="axis2_placement_3d"/>
			</explicit>
			<explicit name="x">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="y">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="z">
				<typename name="positive_length_measure"/>
			</explicit>
			<explicit name="ltx">
				<typename name="length_measure"/>
			</explicit>
			<where label="WR1" expression="((0.0 &lt;= ltx) AND (ltx &lt; x))">
                                                            </where>
		</entity>
		<entity name="week_of_year_and_day_date" supertypes="date">
			<explicit name="week_component">
				<typename name="week_in_year_number"/>
			</explicit>
			<explicit name="day_component" optional="YES">
				<typename name="day_in_week_number"/>
			</explicit>
		</entity>
		<entity name="wire_shell" supertypes="topological_representation_item">
			<explicit name="wire_shell_extent">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="loop"/>
			</explicit>
			<where label="WR1" expression="NOT mixed_loop_type_set(wire_shell_extent)">
                                                            </where>
		</entity>
		<function name="above_plane">
			<parameter name="p1">
				<typename name="cartesian_point"/>
			</parameter>
			<parameter name="p2">
				<typename name="cartesian_point"/>
			</parameter>
			<parameter name="p3">
				<typename name="cartesian_point"/>
			</parameter>
			<parameter name="p4">
				<typename name="cartesian_point"/>
			</parameter>
			<builtintype type="REAL"/>
			<algorithm>
LOCAL
dir2, dir3, dir4 : direction :=
dummy_gri || direction([1.0, 0.0, 0.0]);
val, mag : REAL;
END_LOCAL;
IF (p1.dim &lt;&gt; 3) THEN
RETURN(?);
END_IF;
REPEAT i := 1 TO 3;
dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
END_REPEAT;
mag := sqrt(mag);
val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
RETURN(val);
                                                            </algorithm>
		</function>
		<function name="acyclic_action_method_relationship">
			<parameter name="relation">
				<typename name="action_method_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="action_method"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF action_method_relationship;
END_LOCAL;
IF relation.relating_method IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(am &lt;* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_action_relationship">
			<parameter name="relation">
				<typename name="action_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="action"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF action_relationship;
END_LOCAL;
IF relation.relating_action IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(actn &lt;* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_action_resource_relationship">
			<parameter name="relation">
				<typename name="action_resource_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="action_resource"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF action_resource_relationship;
END_LOCAL;
IF relation.relating_resource IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(ar &lt;* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_approval_relationship">
			<parameter name="relation">
				<typename name="approval_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="approval"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF approval_relationship;
END_LOCAL;
IF relation.relating_approval IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(app &lt;* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_characterized_object_relationship">
			<parameter name="relation">
				<typename name="characterized_object_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="characterized_object"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF characterized_object_relationship;
END_LOCAL;
IF relation.relating_object IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(ca &lt;* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_contract_relationship">
			<parameter name="relation">
				<typename name="contract_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="contract"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF contract_relationship;
END_LOCAL;
IF relation.relating_contract IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(cont &lt;* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_curve_replica">
			<parameter name="rep">
				<typename name="curve_replica"/>
			</parameter>
			<parameter name="parent">
				<typename name="curve"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF (parent :=: rep) THEN
RETURN (FALSE);
ELSE
RETURN(acyclic_curve_replica(rep,
parent\curve_replica.parent_curve));
END_IF;
                                                            </algorithm>
		</function>
		<function name="acyclic_document_relationship">
			<parameter name="relation">
				<typename name="document_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="document"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF document_relationship;
END_LOCAL;
IF relation.relating_document IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(doc &lt;* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_effectivity_relationship">
			<parameter name="relation">
				<typename name="effectivity_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="effectivity"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF effectivity_relationship;
END_LOCAL;
IF relation.relating_effectivity IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(eff &lt;* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_event_occurrence_relationship">
			<parameter name="relation">
				<typename name="event_occurrence_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="event_occurrence"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF event_occurrence_relationship;
END_LOCAL;
IF relation.relating_event IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(evnt &lt;* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_experience_relationship">
			<parameter name="relation">
				<typename name="experience_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="experience"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF experience_relationship;
END_LOCAL;
IF relation.relating_experience IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(expr &lt;* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_experience_type_relationship">
			<parameter name="relation">
				<typename name="experience_type_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="experience_type"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF experience_type_relationship;
END_LOCAL;
IF relation.relating_experience_type IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(exptyp &lt;* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_external_source_relationship">
			<parameter name="relation">
				<typename name="external_source_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="external_source"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF external_source_relationship;
END_LOCAL;
IF relation.relating_source IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(es &lt;* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_externally_defined_item_relationship">
			<parameter name="relation">
				<typename name="externally_defined_item_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="externally_defined_item"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF externally_defined_item_relationship;
END_LOCAL;
IF relation.relating_item IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(edi &lt;* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_general_property_relationship">
			<parameter name="relation">
				<typename name="general_property_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="general_property"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF general_property_relationship;
END_LOCAL;
IF relation.relating_property IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(genp &lt;* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_group_relationship">
			<parameter name="relation">
				<typename name="group_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="group"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF group_relationship;
END_LOCAL;
IF relation.relating_group IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(grp &lt;* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_identification_assignment_relationship">
			<parameter name="relation">
				<typename name="identification_assignment_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="identification_assignment"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF identification_assignment_relationship;
END_LOCAL;
IF relation.relating_identification_assignment IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(ia &lt;* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_location_relationship">
			<parameter name="relation">
				<typename name="location_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="location"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF location_relationship;
END_LOCAL;
IF relation.relating_location IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(lctn &lt;* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_mapped_representation">
			<parameter name="parent_set">
				<aggregate type="SET"/>
				<typename name="representation"/>
			</parameter>
			<parameter name="children_set">
				<aggregate type="SET"/>
				<typename name="representation_item"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x,y : SET OF representation_item;
END_LOCAL;
x := QUERY(z &lt;* children_set | 'REPRESENTATION_SCHEMA.MAPPED_ITEM'
IN TYPEOF(z));
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x);
IF x[i]\mapped_item.mapping_source.mapped_representation
IN parent_set THEN
RETURN (FALSE);
END_IF;
IF NOT acyclic_mapped_representation
(parent_set +
x[i]\mapped_item.mapping_source.mapped_representation,
x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
END_IF;
x := children_set - x;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x);
y := QUERY(z &lt;* bag_to_set(USEDIN(x[i], '')) |
'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
IF NOT acyclic_mapped_representation(parent_set, y) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_organization_relationship">
			<parameter name="relation">
				<typename name="organization_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="organization"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF organization_relationship;
END_LOCAL;
IF relation.relating_organization IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(org &lt;* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_organization_type_relationship">
			<parameter name="relation">
				<typename name="organization_type_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="organization_type"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF organization_type_relationship;
END_LOCAL;
IF relation.relating_organization_type IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(orgtyp &lt;* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_organizational_project_relationship">
			<parameter name="relation">
				<typename name="organizational_project_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="organizational_project"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF organizational_project_relationship;
END_LOCAL;
IF relation.relating_organizational_project IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(op &lt;* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_person_type_definition_relationship">
			<parameter name="relation">
				<typename name="person_type_definition_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="person_type_definition"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF person_type_definition_relationship;
END_LOCAL;
IF relation.relating_person_type_definition IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(ptdef &lt;* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_point_replica">
			<parameter name="rep">
				<typename name="point_replica"/>
			</parameter>
			<parameter name="parent">
				<typename name="point"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF (parent :=: rep) THEN
RETURN (FALSE);
ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
END_IF;
                                                            </algorithm>
		</function>
		<function name="acyclic_position_in_organization_relationship">
			<parameter name="relation">
				<typename name="position_in_organization_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="position_in_organization"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF position_in_organization_relationship;
END_LOCAL;
IF relation.relating_position_in_organization IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(piorg &lt;* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_product_category_relationship">
			<parameter name="relation">
				<typename name="product_category_relationship"/>
			</parameter>
			<parameter name="children">
				<aggregate type="SET"/>
				<typename name="product_category"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF product_category_relationship;
local_children : SET OF product_category;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(children);
IF relation.category :=: children[i] THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
local_children := children + relation.category;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_product_definition_formation_relationship">
			<parameter name="relation">
				<typename name="product_definition_formation_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product_definition_formation"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF product_definition_formation_relationship;
END_LOCAL;
IF relation.relating_product_definition_formation IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(pdf &lt;* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_product_definition_relationship">
			<parameter name="relation">
				<typename name="product_definition_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product_definition"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF product_definition_relationship;
END_LOCAL;
IF relation.relating_product_definition IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_product_relationship">
			<parameter name="relation">
				<typename name="product_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="product"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF product_relationship;
END_LOCAL;
IF relation.relating_product IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(prod &lt;* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_property_definition_relationship">
			<parameter name="relation">
				<typename name="property_definition_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="property_definition"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
LOCAL
x : SET OF property_definition_relationship;
END_LOCAL;
IF relation.relating_property_definition IN
relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY (pd &lt;* bag_to_set (USEDIN
(relation.relating_property_definition,
'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
'PROPERTY_DEFINITION_RELATIONSHIP.' +
'RELATED_PROPERTY_DEFINITION')) |
specific_relation IN TYPEOF (pd));
REPEAT I := 1 TO HIINDEX(x);
IF NOT acyclic_property_definition_relationship
(x[i],
relatives + relation.relating_property_definition,
specific_relation) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_qualification_relationship">
			<parameter name="relation">
				<typename name="qualification_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="qualification"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF qualification_relationship;
END_LOCAL;
IF relation.relating_qualification IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(qual &lt;* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_qualification_type_relationship">
			<parameter name="relation">
				<typename name="qualification_type_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="qualification_type"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF qualification_type_relationship;
END_LOCAL;
IF relation.relating_qualification_type IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(qultyp &lt;* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_set_replica">
			<parameter name="rep">
				<typename name="geometric_set_replica"/>
			</parameter>
			<parameter name="parent">
				<typename name="geometric_set"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
THEN RETURN (TRUE);
END_IF;
IF (parent :=: rep) THEN
RETURN (FALSE);
ELSE RETURN(acyclic_set_replica(rep,
parent\geometric_set_replica.parent_set));
END_IF;
                                                            </algorithm>
		</function>
		<function name="acyclic_shape_aspect_relationship">
			<parameter name="relation">
				<typename name="shape_aspect_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="shape_aspect"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF shape_aspect_relationship;
END_LOCAL;
IF relation.relating_shape_aspect IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(sa &lt;* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_solid_replica">
			<parameter name="rep">
				<typename name="solid_replica"/>
			</parameter>
			<parameter name="parent">
				<typename name="solid_model"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF (parent :=: rep) THEN
RETURN (FALSE);
ELSE RETURN(acyclic_solid_replica(rep,
parent\solid_replica.parent_solid));
END_IF;
                                                            </algorithm>
		</function>
		<function name="acyclic_surface_replica">
			<parameter name="rep">
				<typename name="surface_replica"/>
			</parameter>
			<parameter name="parent">
				<typename name="surface"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF (parent :=: rep) THEN
RETURN (FALSE);
ELSE RETURN(acyclic_surface_replica(rep,
parent\surface_replica.parent_surface));
END_IF;
                                                            </algorithm>
		</function>
		<function name="acyclic_time_interval_relationship">
			<parameter name="relation">
				<typename name="time_interval_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET" lower="1" upper="?"/>
				<typename name="time_interval"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF time_interval_relationship;
END_LOCAL;
IF relation.relating_time_interval IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(ti &lt;* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="acyclic_versioned_action_request_relationship">
			<parameter name="relation">
				<typename name="versioned_action_request_relationship"/>
			</parameter>
			<parameter name="relatives">
				<aggregate type="SET"/>
				<typename name="versioned_action_request"/>
			</parameter>
			<parameter name="specific_relation">
				<builtintype type="STRING"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
x : SET OF versioned_action_request_relationship;
END_LOCAL;
IF relation.relating_versioned_action_request IN relatives THEN
RETURN (FALSE);
END_IF;
x := QUERY(varr &lt;* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
REPEAT i := 1 TO HIINDEX(x);
IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="associated_surface">
			<parameter name="arg">
				<typename name="pcurve_or_surface"/>
			</parameter>
			<typename name="surface"/>
			<algorithm>
LOCAL
surf : surface;
END_LOCAL;
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
surf := arg.basis_surface;
ELSE
surf := arg;
END_IF;
RETURN(surf);
                                                            </algorithm>
		</function>
		<function name="bag_to_set">
			<parameter name="the_bag">
				<aggregate type="BAG"/>
				<builtintype type="GENERIC" typelabel="intype"/>
			</parameter>
			<aggregate type="SET"/>
			<builtintype type="GENERIC" typelabel="intype"/>
			<algorithm>
LOCAL
the_set : SET OF GENERIC:intype := [];
END_LOCAL;
IF SIZEOF(the_bag) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(the_bag);
the_set := the_set + the_bag[i];
END_REPEAT;
END_IF;
RETURN (the_set);
                                                            </algorithm>
		</function>
		<function name="base_axis">
			<parameter name="dim">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="axis1">
				<typename name="direction"/>
			</parameter>
			<parameter name="axis2">
				<typename name="direction"/>
			</parameter>
			<parameter name="axis3">
				<typename name="direction"/>
			</parameter>
			<aggregate type="LIST" lower="2" upper="3"/>
			<typename name="direction"/>
			<algorithm>
LOCAL
u : LIST [2:3] OF direction;
factor : REAL;
d1, d2 : direction;
END_LOCAL;
IF (dim = 3) THEN
d1 := NVL(normalise(axis3), dummy_gri || direction([0.0,0.0,1.0]));
d2 := first_proj_axis(d1,axis1);
u := [d2, second_proj_axis(d1,d2,axis2), d1];
ELSE
IF EXISTS(axis1) THEN
d1 := normalise(axis1);
u := [d1, orthogonal_complement(d1)];
IF EXISTS(axis2) THEN
factor := dot_product(axis2,u[2]);
IF (factor &lt; 0.0) THEN
u[2].direction_ratios[1] := -u[2].direction_ratios[1];
u[2].direction_ratios[2] := -u[2].direction_ratios[2];
END_IF;
END_IF;
ELSE
IF EXISTS(axis2) THEN
d1 := normalise(axis2);
u := [orthogonal_complement(d1), d1];
u[1].direction_ratios[1] := -u[1].direction_ratios[1];
u[1].direction_ratios[2] := -u[1].direction_ratios[2];
ELSE
u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
direction([0.0, 1.0])];
END_IF;
END_IF;
END_IF;
RETURN(u);
                                                            </algorithm>
		</function>
		<function name="boolean_choose">
			<parameter name="b">
				<builtintype type="BOOLEAN"/>
			</parameter>
			<parameter name="choice1">
				<builtintype type="GENERIC"/>
			</parameter>
			<parameter name="choice2">
				<builtintype type="GENERIC"/>
			</parameter>
			<builtintype type="GENERIC"/>
			<algorithm>
IF b THEN
RETURN (choice1);
ELSE
RETURN (choice2);
END_IF;
                                                            </algorithm>
		</function>
		<function name="build_2axes">
			<parameter name="ref_direction">
				<typename name="direction"/>
			</parameter>
			<aggregate type="LIST" lower="2" upper="2"/>
			<typename name="direction"/>
			<algorithm>
LOCAL
d : direction := NVL(normalise(ref_direction),
dummy_gri || direction([1.0,0.0]));
END_LOCAL;
RETURN([d, orthogonal_complement(d)]);
                                                            </algorithm>
		</function>
		<function name="build_axes">
			<parameter name="axis">
				<typename name="direction"/>
			</parameter>
			<parameter name="ref_direction">
				<typename name="direction"/>
			</parameter>
			<aggregate type="LIST" lower="3" upper="3"/>
			<typename name="direction"/>
			<algorithm>
LOCAL
d1, d2 : direction;
END_LOCAL;
d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
d2 := first_proj_axis(d1, ref_direction);
RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
                                                            </algorithm>
		</function>
		<function name="build_transformed_set">
			<parameter name="tr">
				<typename name="cartesian_transformation_operator"/>
			</parameter>
			<parameter name="gset">
				<typename name="geometric_set"/>
			</parameter>
			<aggregate type="SET" lower="0" upper="?"/>
			<typename name="geometric_set_select"/>
			<algorithm>
LOCAL
s : SET [1:?] OF geometric_set_select := gset.elements;
trset : SET [0:?] OF geometric_set_select := [];
END_LOCAL;
REPEAT j := 1 TO SIZEOF(s);
IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
trset := trset + dummy_gri || point() || point_replica(s[j],tr);
ELSE
IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
trset := trset + dummy_gri || surface() || surface_replica(s[j],
tr || cartesian_transformation_operator_3d (?));
END_IF;
END_IF;
END_IF;
END_REPEAT;
RETURN(trset);
                                                            </algorithm>
		</function>
		<function name="categories_of_product">
			<parameter name="obj">
				<typename name="product"/>
			</parameter>
			<aggregate type="SET"/>
			<builtintype type="STRING"/>
			<algorithm>
LOCAL
category_assignments: BAG OF product_category;
categories: SET OF STRING:=[];
i: INTEGER;
END_LOCAL;
category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);
                                                            </algorithm>
		</function>
		<function name="class_assignment_is_valid">
			<parameter name="aia">
				<typename name="applied_classification_assignment"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
item: classification_item;
role: classification_role;
END_LOCAL;
role:= aia.role;
IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
IF(role.name &lt;&gt; 'class system membership') THEN
RETURN(FALSE);
END_IF;
REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
item:= aia.items[i];
IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
RETURN(FALSE);
END_IF;
REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
item:= aia.items[i];
IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="closed_shell_reversed">
			<parameter name="a_shell">
				<typename name="closed_shell"/>
			</parameter>
			<typename name="oriented_closed_shell"/>
			<algorithm>
LOCAL
the_reverse : oriented_closed_shell;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell)) THEN
the_reverse := dummy_tri ||
connected_face_set (
a_shell\connected_face_set.cfs_faces) ||
closed_shell () || oriented_closed_shell(
a_shell\oriented_closed_shell.closed_shell_element,
NOT(a_shell\oriented_closed_shell.orientation));
ELSE
the_reverse := dummy_tri ||
connected_face_set (
a_shell\connected_face_set.cfs_faces) ||
closed_shell () || oriented_closed_shell (a_shell, FALSE);
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="conditional_reverse">
			<parameter name="p">
				<builtintype type="BOOLEAN"/>
			</parameter>
			<parameter name="an_item">
				<typename name="reversible_topology"/>
			</parameter>
			<typename name="reversible_topology"/>
			<algorithm>
IF p THEN
RETURN (an_item);
ELSE
RETURN (topology_reversed (an_item));
END_IF;
                                                            </algorithm>
		</function>
		<function name="constraints_composite_curve_on_surface">
			<parameter name="c">
				<typename name="composite_curve_on_surface"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
REPEAT k := 1 TO n_segments;
IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
(NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
(NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="constraints_geometry_shell_based_surface_model">
			<parameter name="m">
				<typename name="shell_based_surface_model"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
TYPEOF(m.sbsm_boundary[j])) AND
(NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
TYPEOF(m.sbsm_boundary[j]))))
THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<function name="constraints_geometry_shell_based_wireframe_model">
			<parameter name="m">
				<typename name="shell_based_wireframe_model"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
TYPEOF(m.sbwm_boundary[j])) AND
(NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
TYPEOF(m.sbwm_boundary[j]))))
THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<function name="constraints_param_b_spline">
			<parameter name="degree">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="up_knots">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="up_cp">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="knot_mult">
				<aggregate type="LIST"/>
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="knots">
				<aggregate type="LIST"/>
				<typename name="parameter_value"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
k, sum : INTEGER;
END_LOCAL;
sum := knot_mult[1];
REPEAT i := 2 TO up_knots;
sum := sum + knot_mult[i];
END_REPEAT;
IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
(sum &lt;&gt; (degree + up_cp + 2)) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[1];
IF (k &lt; 1) OR (k &gt; degree + 1) THEN
result := FALSE;
RETURN(result);
END_IF;
REPEAT i := 2 TO up_knots;
IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[i];
IF (i &lt; up_knots) AND (k &gt; degree) THEN
result := FALSE;
RETURN(result);
END_IF;
IF (i = up_knots) AND (k &gt; degree + 1) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<function name="constraints_rectangular_composite_surface">
			<parameter name="s">
				<typename name="rectangular_composite_surface"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
REPEAT i := 1 TO s.n_u;
REPEAT j := 1 TO s.n_v;
IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
(s.segments[i][j].parent_surface)) OR
('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
(s.segments[i][j].parent_surface))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u-1;
REPEAT j := 1 TO s.n_v;
IF s.segments[i][j].u_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u;
REPEAT j := 1 TO s.n_v-1;
IF s.segments[i][j].v_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="cross_product">
			<parameter name="arg1">
				<typename name="direction"/>
			</parameter>
			<parameter name="arg2">
				<typename name="direction"/>
			</parameter>
			<typename name="vector"/>
			<algorithm>
LOCAL
mag : REAL;
res : direction;
v1,v2 : LIST[3:3] OF REAL;
result : vector;
END_LOCAL;
IF (NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
(NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
RETURN(?);
ELSE
BEGIN
v1 := normalise(arg1).direction_ratios;
v2 := normalise(arg2).direction_ratios;
res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
(v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
mag := 0.0;
REPEAT i := 1 TO 3;
mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(arg1, 0.0);
END_IF;
RETURN(result);
END;
END_IF;
                                                            </algorithm>
		</function>
		<function name="curve_weights_positive">
			<parameter name="b">
				<typename name="rational_b_spline_curve"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.upper_index_on_control_points;
IF b.weights[i] &lt;= 0.0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<function name="default_b_spline_curve_weights">
			<parameter name="up_cp">
				<builtintype type="INTEGER"/>
			</parameter>
			<aggregate type="ARRAY" lower="0" upper="up_cp"/>
			<builtintype type="REAL"/>
			<algorithm>
RETURN([1:up_cp + 1]);
                                                            </algorithm>
		</function>
		<function name="default_b_spline_knot_mult">
			<parameter name="degree">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="up_knots">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="uniform">
				<typename name="knot_type"/>
			</parameter>
			<aggregate type="LIST" lower="2" upper="?"/>
			<builtintype type="INTEGER"/>
			<algorithm>
LOCAL
knot_mult : LIST [1:up_knots] OF INTEGER;
END_LOCAL;
IF uniform = uniform_knots THEN
knot_mult := [1:up_knots];
ELSE
IF uniform = quasi_uniform_knots THEN
knot_mult := [1:up_knots];
knot_mult[1] := degree + 1;
knot_mult[up_knots] := degree + 1;
ELSE
IF uniform = piecewise_bezier_knots THEN
knot_mult := [degree:up_knots];
knot_mult[1] := degree + 1;
knot_mult[up_knots] := degree + 1;
ELSE
knot_mult := [0:up_knots];
END_IF;
END_IF;
END_IF;
RETURN(knot_mult);
                                                            </algorithm>
		</function>
		<function name="default_b_spline_knots">
			<parameter name="degree">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="up_knots">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="uniform">
				<typename name="knot_type"/>
			</parameter>
			<aggregate type="LIST" lower="2" upper="?"/>
			<typename name="parameter_value"/>
			<algorithm>
LOCAL
knots : LIST [1:up_knots] OF parameter_value := [0:up_knots];
ishift : INTEGER := 1;
END_LOCAL;
IF (uniform = uniform_knots) THEN
ishift := degree + 1;
END_if;
IF (uniform = uniform_knots) OR
(uniform = quasi_uniform_knots) OR
(uniform = piecewise_bezier_knots) THEN
REPEAT i := 1 TO up_knots;
knots[i] := i - ishift;
END_REPEAT;
END_IF;
RETURN(knots);
                                                            </algorithm>
		</function>
		<function name="default_b_spline_surface_weights">
			<parameter name="u_upper">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="v_upper">
				<builtintype type="INTEGER"/>
			</parameter>
			<aggregate type="ARRAY" lower="0" upper="u_upper"/>
			<aggregate type="ARRAY" lower="0" upper="v_upper"/>
			<builtintype type="REAL"/>
			<algorithm>
  RETURN;
      </algorithm>
		</function>
		<function name="derive_dimensional_exponents">
			<parameter name="x">
				<typename name="unit"/>
			</parameter>
			<typename name="dimensional_exponents"/>
			<algorithm>
LOCAL
result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_LOCAL;
IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
END_REPEAT;
ELSE
result := x.dimensions;
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="dimension_of">
			<parameter name="item">
				<typename name="geometric_representation_item"/>
			</parameter>
			<typename name="dimension_count"/>
			<algorithm>
LOCAL
x : SET OF representation;
y : representation_context;
dim : dimension_count;
END_LOCAL;
IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
dim := SIZEOF(item\cartesian_point.coordinates);
RETURN(dim);
END_IF;
IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
dim := SIZEOF(item\direction.direction_ratios);
RETURN(dim);
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
RETURN(dim);
END_IF;
x := using_representations(item);
y := x[1].context_of_items;
dim := y\geometric_representation_context.coordinate_space_dimension;
RETURN (dim);
                                                            </algorithm>
		</function>
		<function name="dimensions_for_si_unit">
			<parameter name="n">
				<typename name="si_unit_name"/>
			</parameter>
			<typename name="dimensional_exponents"/>
			<algorithm>
CASE n OF
metre : RETURN (dimensional_exponents
(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
gram : RETURN (dimensional_exponents
(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
second : RETURN (dimensional_exponents
(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
ampere : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
kelvin : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
mole : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
candela : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
radian : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
steradian : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
hertz : RETURN (dimensional_exponents
(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
newton : RETURN (dimensional_exponents
(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
pascal : RETURN (dimensional_exponents
(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
joule : RETURN (dimensional_exponents
(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
watt : RETURN (dimensional_exponents
(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
coulomb : RETURN (dimensional_exponents
(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
volt : RETURN (dimensional_exponents
(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
farad : RETURN (dimensional_exponents
(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
ohm : RETURN (dimensional_exponents
(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
siemens : RETURN (dimensional_exponents
(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
weber : RETURN (dimensional_exponents
(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
tesla : RETURN (dimensional_exponents
(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
henry : RETURN (dimensional_exponents
(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
degree_Celsius : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
lumen : RETURN (dimensional_exponents
(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
lux : RETURN (dimensional_exponents
(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
becquerel : RETURN (dimensional_exponents
(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
gray : RETURN (dimensional_exponents
(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
sievert : RETURN (dimensional_exponents
(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
OTHERWISE : RETURN (?);
END_CASE;
                                                            </algorithm>
		</function>
		<function name="dot_product">
			<parameter name="arg1">
				<typename name="direction"/>
			</parameter>
			<parameter name="arg2">
				<typename name="direction"/>
			</parameter>
			<builtintype type="REAL"/>
			<algorithm>
LOCAL
scalar : REAL;
vec1, vec2: direction;
ndim : INTEGER;
END_LOCAL;
IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
scalar := ?;
ELSE
IF (arg1.dim &lt;&gt; arg2.dim) THEN
scalar := ?;
ELSE
BEGIN
vec1 := normalise(arg1);
vec2 := normalise(arg2);
ndim := arg1.dim;
scalar := 0.0;
REPEAT i := 1 TO ndim;
scalar := scalar +
vec1.direction_ratios[i]*vec2.direction_ratios[i];
END_REPEAT;
END;
END_IF;
END_IF;
RETURN (scalar);
                                                            </algorithm>
		</function>
		<function name="edge_curve_pcurves">
			<parameter name="an_edge">
				<typename name="edge_curve"/>
			</parameter>
			<parameter name="the_surface_curves">
				<aggregate type="SET"/>
				<typename name="surface_curve"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="pcurve"/>
			<algorithm>
LOCAL
a_curve : curve;
result : SET OF pcurve;
the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
a_curve := an_edge.edge_geometry;
result := [];
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
result := result + a_curve;
ELSE
IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
the_geometry := a_curve\surface_curve.associated_geometry;
REPEAT k := 1 TO SIZEOF(the_geometry);
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
THEN
result := result + the_geometry[k];
END_IF;
END_REPEAT;
ELSE
REPEAT j := 1 TO SIZEOF(the_surface_curves);
the_geometry := the_surface_curves[j].associated_geometry;
IF the_surface_curves[j].curve_3d :=: a_curve
THEN
REPEAT k := 1 TO SIZEOF(the_geometry);
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
THEN
result := result + the_geometry[k];
END_IF;
END_REPEAT;
END_IF;
END_REPEAT;
END_IF;
END_IF;
RETURN (RESULT);
                                                            </algorithm>
		</function>
		<function name="edge_reversed">
			<parameter name="an_edge">
				<typename name="edge"/>
			</parameter>
			<typename name="oriented_edge"/>
			<algorithm>
LOCAL
the_reverse : oriented_edge;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge)) THEN
the_reverse := dummy_tri ||
edge(an_edge.edge_end, an_edge.edge_start) ||
oriented_edge(an_edge\oriented_edge.edge_element,
NOT (an_edge\oriented_edge.orientation)) ;
ELSE
the_reverse := dummy_tri ||
edge(an_edge.edge_end, an_edge.edge_start) ||
oriented_edge(an_edge, FALSE);
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="external_version_assignment_is_valid">
			<parameter name="aia">
				<typename name="applied_external_identification_assignment"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
item: identification_item;
role: identification_role;
END_LOCAL;
role:= aia.role;
IF role.name='version' THEN
REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
item:= aia.items[i];
IF (SIZEOF(['EXTERNAL_PROPERTIES_MIM.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
ELSE
RETURN(TRUE);
END_IF;
                                                            </algorithm>
		</function>
		<function name="face_bound_reversed">
			<parameter name="a_face_bound">
				<typename name="face_bound"/>
			</parameter>
			<typename name="face_bound"/>
			<algorithm>
LOCAL
the_reverse : face_bound ;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound)) THEN
the_reverse := dummy_tri ||
face_bound(a_face_bound\face_bound.bound,
NOT (a_face_bound\face_bound.orientation))
|| face_outer_bound() ;
ELSE
the_reverse := dummy_tri ||
face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="face_reversed">
			<parameter name="a_face">
				<typename name="face"/>
			</parameter>
			<typename name="oriented_face"/>
			<algorithm>
LOCAL
the_reverse : oriented_face ;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face)) THEN
the_reverse := dummy_tri ||
face(set_of_topology_reversed(a_face.bounds)) ||
oriented_face(a_face\oriented_face.face_element,
NOT (a_face\oriented_face.orientation)) ;
ELSE
the_reverse := dummy_tri ||
face(set_of_topology_reversed(a_face.bounds)) ||
oriented_face(a_face, FALSE) ;
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="first_proj_axis">
			<parameter name="z_axis">
				<typename name="direction"/>
			</parameter>
			<parameter name="arg">
				<typename name="direction"/>
			</parameter>
			<typename name="direction"/>
			<algorithm>
LOCAL
x_axis : direction;
v : direction;
z : direction;
x_vec : vector;
END_LOCAL;
IF (NOT EXISTS(z_axis)) THEN
RETURN (?) ;
ELSE
z := normalise(z_axis);
IF NOT EXISTS(arg) THEN
IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
(z.direction_ratios &lt;&gt; [-1.0,0.0,0.0])) THEN
v := dummy_gri || direction([1.0,0.0,0.0]);
ELSE
v := dummy_gri || direction([0.0,1.0,0.0]);
END_IF;
ELSE
IF (arg.dim &lt;&gt; 3) THEN
RETURN (?) ;
END_IF;
IF ((cross_product(arg,z).magnitude) = 0.0) THEN
RETURN (?);
ELSE
v := normalise(arg);
END_IF;
END_IF;
x_vec := scalar_times_vector(dot_product(v, z), z);
x_axis := vector_difference(v, x_vec).orientation;
x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);
                                                            </algorithm>
		</function>
		<function name="get_basis_surface">
			<parameter name="c">
				<typename name="curve_on_surface"/>
			</parameter>
			<aggregate type="SET" lower="0" upper="2"/>
			<typename name="surface"/>
			<algorithm>
LOCAL
surfs : SET[0:2] OF surface;
n : INTEGER;
END_LOCAL;
surfs := [];
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
surfs := [c\pcurve.basis_surface];
ELSE
IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
n := SIZEOF(c\surface_curve.associated_geometry);
REPEAT i := 1 TO n;
surfs := surfs +
associated_surface(c\surface_curve.associated_geometry[i]);
END_REPEAT;
END_IF;
END_IF;
IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
n := SIZEOF(c\composite_curve.segments);
surfs := get_basis_surface(
c\composite_curve.segments[1].parent_curve);
IF n &gt; 1 THEN
REPEAT i := 2 TO n;
surfs := surfs * get_basis_surface(
c\composite_curve.segments[i].parent_curve);
END_REPEAT;
END_IF;
END_IF;
RETURN(surfs);
                                                            </algorithm>
		</function>
		<function name="get_description_value">
			<parameter name="obj">
				<typename name="description_attribute_select"/>
			</parameter>
			<typename name="text"/>
			<algorithm>
LOCAL
description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
END_LOCAL;
IF SIZEOF(description_bag) = 1 THEN
RETURN (description_bag[1].attribute_value);
ELSE
RETURN (?);
END_IF;
                                                            </algorithm>
		</function>
		<function name="get_id_value">
			<parameter name="obj">
				<typename name="id_attribute_select"/>
			</parameter>
			<typename name="identifier"/>
			<algorithm>
LOCAL
id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
RETURN (id_bag[1].attribute_value);
ELSE
RETURN (?);
END_IF;
                                                            </algorithm>
		</function>
		<function name="get_name_value">
			<parameter name="obj">
				<typename name="name_attribute_select"/>
			</parameter>
			<typename name="label"/>
			<algorithm>
LOCAL
name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
END_LOCAL;
IF SIZEOF(name_bag) = 1 THEN
RETURN (name_bag[1].attribute_value);
ELSE
RETURN (?);
END_IF;
                                                            </algorithm>
		</function>
		<function name="get_product_definitions">
			<parameter name="c_def_instance">
				<typename name="product"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="product_definition"/>
			<algorithm>
LOCAL
pd_set : SET OF product_definition_formation := [];
pdr_set : SET OF product_definition := [];
END_LOCAL;
pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
IF (SIZEOF(pd_set) &lt; 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
END_REPEAT;
RETURN (pdr_set);
                                                            </algorithm>
		</function>
		<function name="get_property_definition_representations">
			<parameter name="c_def_instance">
				<typename name="characterized_definition"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="property_definition_representation"/>
			<algorithm>
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [];
END_LOCAL;
pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) &lt; 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
END_REPEAT;
RETURN (pdr_set);
                                                            </algorithm>
		</function>
		<function name="get_role">
			<parameter name="obj">
				<typename name="role_select"/>
			</parameter>
			<typename name="object_role"/>
			<algorithm>
LOCAL
role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
END_LOCAL;
IF SIZEOF(role_bag) = 1 THEN
RETURN (role_bag[1].role);
ELSE
RETURN (?);
END_IF;
                                                            </algorithm>
		</function>
		<function name="get_shape_aspects">
			<parameter name="c_def_instance">
				<typename name="characterized_definition"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="shape_aspect"/>
			<algorithm>
LOCAL
pd_set : SET OF product_definition_shape := [];
pdr_set : SET OF shape_aspect := [];
END_LOCAL;
pd_set := bag_to_set(QUERY(pd &lt;* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
IF (SIZEOF(pd_set) &lt; 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
END_REPEAT;
RETURN (pdr_set);
                                                            </algorithm>
		</function>
		<function name="item_in_context">
			<parameter name="item">
				<typename name="representation_item"/>
			</parameter>
			<parameter name="cntxt">
				<typename name="representation_context"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
y : BAG OF representation_item;
END_LOCAL;
IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
* cntxt.representations_in_context) &gt; 0 THEN
RETURN (TRUE);
ELSE y := QUERY(z &lt;* USEDIN (item , '') |
'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
IF SIZEOF(y) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(y);
IF item_in_context(y[i], cntxt) THEN
RETURN (TRUE);
END_IF;
END_REPEAT;
END_IF;
END_IF;
RETURN (FALSE);
                                                            </algorithm>
		</function>
		<function name="leap_year">
			<parameter name="year">
				<typename name="year_number"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF ((((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) = 0)) THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
                                                            </algorithm>
		</function>
		<function name="list_face_loops">
			<parameter name="f">
				<typename name="face"/>
			</parameter>
			<aggregate type="LIST" lower="0" upper="?"/>
			<typename name="loop"/>
			<algorithm>
LOCAL
loops : LIST[0:?] OF loop := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(f.bounds);
loops := loops +(f.bounds[i].bound);
END_REPEAT;
RETURN(loops);
                                                            </algorithm>
		</function>
		<function name="list_loop_edges">
			<parameter name="l">
				<typename name="loop"/>
			</parameter>
			<aggregate type="LIST" lower="0" upper="?"/>
			<typename name="edge"/>
			<algorithm>
LOCAL
edges : LIST[0:?] OF edge := [];
END_LOCAL;
IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
REPEAT i := 1 TO SIZEOF(l\path.edge_list);
edges := edges + (l\path.edge_list[i].edge_element);
END_REPEAT;
END_IF;
RETURN(edges);
                                                            </algorithm>
		</function>
		<function name="list_of_topology_reversed">
			<parameter name="a_list">
				<typename name="list_of_reversible_topology_item"/>
			</parameter>
			<typename name="list_of_reversible_topology_item"/>
			<algorithm>
LOCAL
the_reverse : list_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF (a_list);
the_reverse := topology_reversed (a_list [i]) + the_reverse;
END_REPEAT;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="list_shell_edges">
			<parameter name="s">
				<typename name="shell"/>
			</parameter>
			<aggregate type="LIST" lower="0" upper="?"/>
			<typename name="edge"/>
			<algorithm>
LOCAL
edges : LIST[0:?] OF edge := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
edges := edges + list_loop_edges(list_shell_loops(s)[i]);
END_REPEAT;
RETURN(edges);
                                                            </algorithm>
		</function>
		<function name="list_shell_faces">
			<parameter name="s">
				<typename name="shell"/>
			</parameter>
			<aggregate type="LIST" lower="0" upper="?"/>
			<typename name="face"/>
			<algorithm>
LOCAL
faces : LIST[0:?] OF face := [];
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR
('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
faces := faces + s\connected_face_set.cfs_faces[i];
END_REPEAT;
END_IF;
RETURN(faces);
                                                            </algorithm>
		</function>
		<function name="list_shell_loops">
			<parameter name="s">
				<typename name="shell"/>
			</parameter>
			<aggregate type="LIST" lower="0" upper="?"/>
			<typename name="loop"/>
			<algorithm>
LOCAL
loops : LIST[0:?] OF loop := [];
END_LOCAL;
IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
loops := loops + s.vertex_shell_extent;
END_IF;
IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
loops := loops + s.wire_shell_extent[i];
END_REPEAT;
END_IF;
IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR
('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
REPEAT i := 1 TO SIZEOF(s.cfs_faces);
loops := loops + list_face_loops(s.cfs_faces[i]);
END_REPEAT;
END_IF;
RETURN(loops);
                                                            </algorithm>
		</function>
		<function name="list_to_array">
			<parameter name="lis">
				<aggregate type="LIST" lower="0" upper="?"/>
				<builtintype type="GENERIC" typelabel="T"/>
			</parameter>
			<parameter name="low">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u">
				<builtintype type="INTEGER"/>
			</parameter>
			<aggregate type="ARRAY" lower="low" upper="u"/>
			<builtintype type="GENERIC" typelabel="T"/>
			<algorithm>
LOCAL
n : INTEGER;
res : ARRAY [low:u] OF GENERIC : T;
END_LOCAL;
n := SIZEOF(lis);
IF (n &lt;&gt; (u-low +1)) THEN
RETURN(?);
ELSE
res := [lis[1] : n];
REPEAT i := 2 TO n;
res[low+i-1] := lis[i];
END_REPEAT;
RETURN(res);
END_IF;
                                                            </algorithm>
		</function>
		<function name="list_to_set">
			<parameter name="l">
				<aggregate type="LIST" lower="0" upper="?"/>
				<builtintype type="GENERIC" typelabel="T"/>
			</parameter>
			<aggregate type="SET"/>
			<builtintype type="GENERIC" typelabel="T"/>
			<algorithm>
LOCAL
s : SET OF GENERIC:T := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(l);
s := s + l[i];
END_REPEAT;
RETURN(s);
                                                            </algorithm>
		</function>
		<function name="make_array_of_array">
			<parameter name="lis">
				<aggregate type="LIST" lower="1" upper="?"/>
				<aggregate type="LIST" lower="1" upper="?"/>
				<builtintype type="GENERIC" typelabel="t"/>
			</parameter>
			<parameter name="low1">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u1">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="low2">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u2">
				<builtintype type="INTEGER"/>
			</parameter>
			<aggregate type="ARRAY" lower="low1" upper="u1"/>
			<aggregate type="ARRAY" lower="low2" upper="u2"/>
			<builtintype type="GENERIC" typelabel="t"/>
			<algorithm>
  LOCAL
    res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
  END_LOCAL;

  IF ((u1 - low1) + 1) &lt;&gt; SIZEOF(lis) THEN
    RETURN (?);
  END_IF;
  IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[1]) THEN
    RETURN (?);
  END_IF;
  res := ;
  REPEAT i := 2 TO HIINDEX(lis) BY 1;
    IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[i]) THEN
      RETURN (?);
    END_IF;
    res[(low1 + i) - 1] := list_to_array(lis[i], low2, u2);
  END_REPEAT;
  RETURN (res);
      </algorithm>
		</function>
		<function name="make_array_of_array_of_array">
			<parameter name="lis">
				<aggregate type="LIST" lower="1" upper="?"/>
				<aggregate type="LIST" lower="1" upper="?"/>
				<aggregate type="LIST" lower="1" upper="?"/>
				<builtintype type="GENERIC" typelabel="t"/>
			</parameter>
			<parameter name="low1">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u1">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="low2">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u2">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="low3">
				<builtintype type="INTEGER"/>
			</parameter>
			<parameter name="u3">
				<builtintype type="INTEGER"/>
			</parameter>
			<aggregate type="ARRAY" lower="low1" upper="u1"/>
			<aggregate type="ARRAY" lower="low2" upper="u2"/>
			<aggregate type="ARRAY" lower="low3" upper="u3"/>
			<builtintype type="GENERIC" typelabel="t"/>
			<algorithm>
  LOCAL
    res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF GENERIC:t;
  END_LOCAL;

  IF ((u1 - low1) + 1) &lt;&gt; SIZEOF(lis) THEN
    RETURN (?);
  END_IF;
  IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[1]) THEN
    RETURN (?);
  END_IF;
  res := [make_array_of_array(lis[1], low2, u2, low3, u3):(u1 - low1) + 1];
  REPEAT i := 2 TO HIINDEX(lis) BY 1;
    IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[i]) THEN
      RETURN (?);
    END_IF;
    res[(low1 + i) - 1] := make_array_of_array(lis[i], low2, u2, low3, u3);
  END_REPEAT;
  RETURN (res);
      </algorithm>
		</function>
		<function name="mixed_loop_type_set">
			<parameter name="l">
				<aggregate type="SET"/>
				<typename name="loop"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
  LOCAL
    poly_loop_type : LOGICAL;
  END_LOCAL;

  IF SIZEOF(l) &lt;= 1 THEN
    RETURN (FALSE);
  END_IF;
  poly_loop_type := &apos;AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POLY_LOOP&apos; IN TYPEOF(l[1]);
  REPEAT i := 2 TO SIZEOF(l) BY 1;
    IF (&apos;AP239_PRODUCT_DEFINITION_INFORMATION_MIM_LF.POLY_LOOP&apos; IN TYPEOF(l[i])) &lt;&gt; poly_loop_type THEN
      RETURN (TRUE);
    END_IF;
  END_REPEAT;
  RETURN (FALSE);
      </algorithm>
		</function>
		<function name="msb_shells">
			<parameter name="brep">
				<typename name="manifold_solid_brep"/>
			</parameter>
			<aggregate type="SET" lower="1" upper="?"/>
			<typename name="closed_shell"/>
			<algorithm>
IF SIZEOF (QUERY (msbtype &lt;* TYPEOF (brep) |
msbtype LIKE '*BREP_WITH_VOIDS')) &gt;= 1 THEN
RETURN (brep\brep_with_voids.voids + brep.outer);
ELSE
RETURN([brep.outer]);
END_IF;
                                                            </algorithm>
		</function>
		<function name="normalise">
			<parameter name="arg">
				<typename name="vector_or_direction"/>
			</parameter>
			<typename name="vector_or_direction"/>
			<algorithm>
LOCAL
ndim : INTEGER;
v : direction;
result : vector_or_direction;
vec : vector;
mag : REAL;
END_LOCAL;
IF NOT EXISTS (arg) THEN
result := ?;
ELSE
ndim := arg.dim;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
BEGIN
v := dummy_gri || direction(arg.orientation.direction_ratios);
IF arg.magnitude = 0.0 THEN
RETURN(?);
ELSE
vec := dummy_gri || vector (v, 1.0);
END_IF;
END;
ELSE
v := dummy_gri || direction (arg.direction_ratios);
END_IF;
mag := 0.0;
REPEAT i := 1 TO ndim;
mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
END_REPEAT;
IF mag &gt; 0.0 THEN
mag := SQRT(mag);
REPEAT i := 1 TO ndim;
v.direction_ratios[i] := v.direction_ratios[i]/mag;
END_REPEAT;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
vec.orientation := v;
result := vec;
ELSE
result := v;
END_IF;
ELSE
RETURN(?);
END_IF;
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="mixed_loop_type_set">
			<parameter name="l">
				<aggregate type="SET" lower="0" upper="?"/>
				<typename name="loop"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
LOCAL
poly_loop_type: LOGICAL;
END_LOCAL;
IF(SIZEOF(l) &lt;= 1) THEN
RETURN(FALSE);
END_IF;
poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
REPEAT i := 2 TO SIZEOF(l);
IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt; poly_loop_type)
THEN
RETURN(TRUE);
END_IF;
END_REPEAT;
RETURN(FALSE);
                                                            </algorithm>
		</function>
		<function name="msb_shells">
			<parameter name="brep">
				<typename name="manifold_solid_brep"/>
			</parameter>
			<aggregate type="SET" lower="1" upper="?"/>
			<typename name="closed_shell"/>
			<algorithm>
IF SIZEOF (QUERY (msbtype &lt;* TYPEOF (brep) |
msbtype LIKE '*BREP_WITH_VOIDS')) &gt;= 1 THEN
RETURN (brep\brep_with_voids.voids + brep.outer);
ELSE
RETURN([brep.outer]);
END_IF;
                                                            </algorithm>
		</function>
		<function name="normalise">
			<parameter name="arg">
				<typename name="vector_or_direction"/>
			</parameter>
			<typename name="vector_or_direction"/>
			<algorithm>
LOCAL
ndim : INTEGER;
v : direction;
result : vector_or_direction;
vec : vector;
mag : REAL;
END_LOCAL;
IF NOT EXISTS (arg) THEN
result := ?;
ELSE
ndim := arg.dim;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
BEGIN
v := dummy_gri || direction(arg.orientation.direction_ratios);
IF arg.magnitude = 0.0 THEN
RETURN(?);
ELSE
vec := dummy_gri || vector (v, 1.0);
END_IF;
END;
ELSE
v := dummy_gri || direction (arg.direction_ratios);
END_IF;
mag := 0.0;
REPEAT i := 1 TO ndim;
mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
END_REPEAT;
IF mag &gt; 0.0 THEN
mag := SQRT(mag);
REPEAT i := 1 TO ndim;
v.direction_ratios[i] := v.direction_ratios[i]/mag;
END_REPEAT;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
vec.orientation := v;
result := vec;
ELSE
result := v;
END_IF;
ELSE
RETURN(?);
END_IF;
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="open_shell_reversed">
			<parameter name="a_shell">
				<typename name="open_shell"/>
			</parameter>
			<typename name="oriented_open_shell"/>
			<algorithm>
LOCAL
the_reverse : oriented_open_shell;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell)) THEN
the_reverse := dummy_tri ||
connected_face_set (
a_shell\connected_face_set.cfs_faces) ||
open_shell () || oriented_open_shell(
a_shell\oriented_open_shell.open_shell_element,
(NOT (a_shell\oriented_open_shell.orientation)));
ELSE
the_reverse := dummy_tri ||
connected_face_set (
a_shell\connected_face_set.cfs_faces) ||
open_shell () || oriented_open_shell (a_shell, FALSE);
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="orthogonal_complement">
			<parameter name="vec">
				<typename name="direction"/>
			</parameter>
			<typename name="direction"/>
			<algorithm>
LOCAL
result : direction ;
END_LOCAL;
IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
RETURN(?);
ELSE
result := dummy_gri || direction([-vec.direction_ratios[2],
vec.direction_ratios[1]]);
RETURN(result);
END_IF;
                                                            </algorithm>
		</function>
		<function name="path_head_to_tail">
			<parameter name="a_path">
				<typename name="path"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
LOCAL
n : INTEGER;
p : LOGICAL := TRUE;
END_LOCAL;
n := SIZEOF (a_path.edge_list);
REPEAT i := 2 TO n;
p := p AND (a_path.edge_list[i-1].edge_end :=:
a_path.edge_list[i].edge_start);
END_REPEAT;
RETURN (p);
                                                            </algorithm>
		</function>
		<function name="path_reversed">
			<parameter name="a_path">
				<typename name="path"/>
			</parameter>
			<typename name="oriented_path"/>
			<algorithm>
LOCAL
the_reverse : oriented_path ;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path)) THEN
the_reverse := dummy_tri ||
path(list_of_topology_reversed (a_path.edge_list)) ||
oriented_path(a_path\oriented_path.path_element,
NOT(a_path\oriented_path.orientation)) ;
ELSE
the_reverse := dummy_tri ||
path(list_of_topology_reversed (a_path.edge_list)) ||
oriented_path(a_path, FALSE);
END_IF;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="relatives_of_product_definitions">
			<parameter name="definition_set">
				<aggregate type="SET"/>
				<typename name="product_definition"/>
			</parameter>
			<parameter name="relation_subtype">
				<builtintype type="STRING"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="product_definition"/>
			<algorithm>
FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
LOCAL
local_def : SET OF product_definition := [];
local_pdr : SET OF product_definition_relationship := [];
local_total : SET OF product_definition := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(definition_set);
local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_pdr);
local_def := local_def + local_pdr[i].related_product_definition;
END_REPEAT;
IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
RETURN (local_def);
ELSE
local_total := total_definitions + local_def;
RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
END_IF;
                                                            </algorithm>
		</function>
		<function name="relatives_of_shape_representations">
			<parameter name="shape_representation_set">
				<aggregate type="SET"/>
				<typename name="shape_representation"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="shape_representation"/>
			<algorithm>
FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
LOCAL
local_shape_rep : SET OF shape_representation := [];
local_srr : SET OF shape_representation_relationship := [];
local_total : SET OF shape_representation := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(shape_representation_set);
local_srr := local_srr + QUERY(rr &lt;* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_srr);
IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
local_shape_rep := local_shape_rep + local_srr[i].rep_2;
END_IF;
END_REPEAT;
IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
RETURN (shape_representation_set);
ELSE
local_total := total_reps + local_shape_rep;
RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
END_IF;
                                                            </algorithm>
		</function>
		<function name="same_side">
			<parameter name="plane_pts">
				<aggregate type="LIST" lower="3" upper="3"/>
				<typename name="cartesian_point"/>
			</parameter>
			<parameter name="test_points">
				<aggregate type="LIST" lower="2" upper="?"/>
				<typename name="cartesian_point"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
val1, val2 : REAL;
n : INTEGER;
END_LOCAL;
IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
RETURN(?);
END_IF;
n := SIZEOF(test_points);
val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
test_points[1]);
REPEAT i := 2 TO n;
val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
test_points[i]);
IF (val1*val2 &lt;= 0.0) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="scalar_times_vector">
			<parameter name="scalar">
				<builtintype type="REAL"/>
			</parameter>
			<parameter name="vec">
				<typename name="vector_or_direction"/>
			</parameter>
			<typename name="vector"/>
			<algorithm>
LOCAL
v : direction;
mag : REAL;
result : vector;
END_LOCAL;
IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
RETURN (?) ;
ELSE
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
v := dummy_gri || direction(vec.orientation.direction_ratios);
mag := scalar * vec.magnitude;
ELSE
v := dummy_gri || direction(vec.direction_ratios);
mag := scalar;
END_IF;
IF (mag &lt; 0.0) THEN
REPEAT i := 1 TO SIZEOF(v.direction_ratios);
v.direction_ratios[i] := -v.direction_ratios[i];
END_REPEAT;
mag := -mag;
END_IF;
result := dummy_gri || vector(normalise(v), mag);
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="second_proj_axis">
			<parameter name="z_axis">
				<typename name="direction"/>
			</parameter>
			<parameter name="x_axis">
				<typename name="direction"/>
			</parameter>
			<parameter name="arg">
				<typename name="direction"/>
			</parameter>
			<typename name="direction"/>
			<algorithm>
LOCAL
y_axis : vector;
v : direction;
temp : vector;
END_LOCAL;
IF NOT EXISTS(arg) THEN
v := dummy_gri || direction([0.0,1.0,0.0]);
ELSE
v := arg;
END_IF;
temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
y_axis := vector_difference(v, temp);
temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
y_axis := vector_difference(y_axis, temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);
                                                            </algorithm>
		</function>
		<function name="set_of_topology_reversed">
			<parameter name="a_set">
				<typename name="set_of_reversible_topology_item"/>
			</parameter>
			<typename name="set_of_reversible_topology_item"/>
			<algorithm>
LOCAL
the_reverse : set_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF (a_set);
the_reverse := the_reverse + topology_reversed (a_set [i]);
END_REPEAT;
RETURN (the_reverse);
                                                            </algorithm>
		</function>
		<function name="shell_reversed">
			<parameter name="a_shell">
				<typename name="shell"/>
			</parameter>
			<typename name="shell"/>
			<algorithm>
IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell)) THEN
RETURN (open_shell_reversed (a_shell));
ELSE
IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell)) THEN
RETURN (closed_shell_reversed (a_shell));
ELSE
RETURN (?);
END_IF;
END_IF;
                                                            </algorithm>
		</function>
		<function name="surface_condition_correlation">
			<parameter name="pd">
				<typename name="property_definition"/>
			</parameter>
			<parameter name="rep">
				<typename name="representation"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
CASE pd.name OF
'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' :
RETURN(pd.name = rep.name);
OTHERWISE : RETURN(UNKNOWN);
END_CASE;
                                                            </algorithm>
		</function>
		<function name="surface_weights_positive">
			<parameter name="b">
				<typename name="rational_b_spline_surface"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper;
REPEAT j := 0 TO b.v_upper;
IF (b.weights[i][j] &lt;= 0.0) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<function name="topology_reversed">
			<parameter name="an_item">
				<typename name="reversible_topology"/>
			</parameter>
			<typename name="reversible_topology"/>
			<algorithm>
IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
RETURN (edge_reversed (an_item));
END_IF;
IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
RETURN (path_reversed (an_item));
END_IF;
IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
RETURN (face_bound_reversed (an_item));
END_IF;
IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
RETURN (face_reversed (an_item));
END_IF;
IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
RETURN (shell_reversed (an_item));
END_IF;
IF ('SET' IN TYPEOF (an_item)) THEN
RETURN (set_of_topology_reversed (an_item));
END_IF;
IF ('LIST' IN TYPEOF (an_item)) THEN
RETURN (list_of_topology_reversed (an_item));
END_IF;
RETURN (?);
                                                            </algorithm>
		</function>
		<function name="type_check_function">
			<parameter name="the_type">
				<builtintype type="GENERIC"/>
			</parameter>
			<parameter name="sub_names">
				<aggregate type="SET"/>
				<builtintype type="STRING"/>
			</parameter>
			<parameter name="criterion">
				<builtintype type="INTEGER"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
IF ((NOT EXISTS (the_type)) OR (NOT ({0&lt;= criterion &lt;=3})) OR
(SIZEOF (sub_names) = 0)) THEN RETURN (UNKNOWN);
ELSE
CASE criterion OF
0: RETURN (SIZEOF (sub_names * TYPEOF (the_type)) &gt; 0);
1: RETURN (SIZEOF (sub_names * TYPEOF (the_type)) = 0);
2: RETURN (SIZEOF (sub_names * TYPEOF (the_type)) = 1);
3: RETURN (SIZEOF (sub_names * TYPEOF (the_type)) &lt;= 1);
END_CASE;
END_IF;
                                                            </algorithm>
		</function>
		<function name="using_items">
			<parameter name="item">
				<typename name="founded_item_select"/>
			</parameter>
			<parameter name="checked_items">
				<aggregate type="SET"/>
				<typename name="founded_item_select"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="founded_item_select"/>
			<algorithm>
LOCAL
new_check_items : SET OF founded_item_select;
result_items : SET OF founded_item_select;
next_items : SET OF founded_item_select;
END_LOCAL;
result_items := [];
new_check_items := checked_items + item;
next_items := QUERY(z &lt;* bag_to_set(USEDIN(item , '')) |
('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
('REPRESENTATION_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z)));
IF SIZEOF(next_items) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(next_items);
IF NOT(next_items[i] IN new_check_items) THEN
result_items := result_items + next_items[i] +
using_items(next_items[i],new_check_items);
END_IF;
END_REPEAT;
END_IF;
RETURN (result_items);
                                                            </algorithm>
		</function>
		<function name="using_representations">
			<parameter name="item">
				<typename name="founded_item_select"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="representation"/>
			<algorithm>
LOCAL
results : SET OF representation;
result_bag : BAG OF representation;
intermediate_items : SET OF founded_item_select;
END_LOCAL;
results := [];
result_bag :=
USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
IF SIZEOF(result_bag) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(result_bag);
results := results + result_bag[i];
END_REPEAT;
END_IF;
intermediate_items := using_items(item,[]);
IF SIZEOF(intermediate_items) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(intermediate_items);
result_bag := USEDIN(intermediate_items[i],
'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
IF SIZEOF(result_bag) &gt; 0 THEN
REPEAT j := 1 TO HIINDEX(result_bag);
results := results + result_bag[j];
END_REPEAT;
END_IF;
END_REPEAT;
END_IF;
RETURN (results);
                                                            </algorithm>
		</function>
		<function name="valid_basis_curve_in_2d_wireframe">
			<parameter name="crv">
				<typename name="curve"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE'] *
TYPEOF (crv)) = 1
THEN RETURN (TRUE);
ELSE
IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE')
IN TYPEOF (crv)) THEN
IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.LINE',
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.PARABOLA',
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.HYPERBOLA'] *
TYPEOF(crv\trimmed_curve.basis_curve)) = 1
THEN RETURN (TRUE);
ELSE RETURN (valid_basis_curve_in_2d_wireframe
(crv\trimmed_curve.basis_curve));
END_IF;
ELSE
IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D')
IN TYPEOF (crv))
THEN RETURN (valid_basis_curve_in_2d_wireframe
(crv\offset_curve_2d.basis_curve));
ELSE
IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE_REPLICA')
IN TYPEOF (crv))
THEN RETURN (valid_basis_curve_in_2d_wireframe
(crv\curve_replica.parent_curve));
ELSE
IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE')
IN TYPEOF (crv)) THEN
RETURN (SIZEOF (QUERY (ccs &lt;* crv\composite_curve.segments |
NOT (valid_basis_curve_in_2d_wireframe
(ccs.parent_curve)))) = 0);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                                                            </algorithm>
		</function>
		<function name="valid_calendar_date">
			<parameter name="date">
				<typename name="calendar_date"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
CASE date.month_component OF
1 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
2 : BEGIN
IF (leap_year(date.year_component)) THEN
RETURN({ 1 &lt;= date.day_component &lt;= 29 });
ELSE
RETURN({ 1 &lt;= date.day_component &lt;= 28 });
END_IF;
END;
3 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
4 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
5 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
6 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
7 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
8 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
9 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
10 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
11 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
12 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
END_CASE;
RETURN (FALSE);
                                                            </algorithm>
		</function>
		<function name="valid_measure_value">
			<parameter name="m">
				<typename name="measure_value"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF ('REAL' IN TYPEOF (m)) THEN
RETURN (m &gt; 0.0);
ELSE
IF ('INTEGER' IN TYPEOF (m)) THEN
RETURN (m &gt; 0);
ELSE
RETURN (TRUE);
END_IF;
END_IF;
                                                            </algorithm>
		</function>
		<function name="valid_selected_instance_representation">
			<parameter name="pd">
				<typename name="product_definition_or_assembly_relationship"/>
			</parameter>
			<builtintype type="LOGICAL"/>
			<algorithm>
LOCAL
properties: SET OF property_definition :=[];
property_definition_representations: SET OF property_definition_representation :=[];
selected_representation: representation;
END_LOCAL;
properties :=QUERY(prd&lt;* USEDIN (pd ,'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION') |
(prd.name = 'occurrence selection'));
IF (SIZEOF(properties)&lt;&gt;1) THEN
RETURN(FALSE);
END_IF;
property_definition_representations := QUERY (pdr &lt;* USEDIN (properties[1] , 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
(pdr.used_representation.name = 'selection criteria'));
IF (SIZEOF(property_definition_representations)&lt;&gt;1) THEN
RETURN(FALSE);
END_IF;
selected_representation := property_definition_representations[1].used_representation;
IF (SIZEOF(selected_representation.items) &lt;1) OR (SIZEOF(selected_representation.items) &gt;2) THEN
RETURN(FALSE);
END_IF;
IF (SIZEOF (QUERY (i &lt;* selected_representation.used_representation.items |
(SIZEOF (['PRODUCT_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM' ,
'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF (i)) = 1) AND
(i.name = 'selection quantity'))) &lt;&gt; 1) THEN
RETURN(FALSE);
END_IF;
IF (SIZEOF (QUERY (i &lt;* selected_representation.used_representation.items |
('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (i)) AND
(i.name = 'selection control')))&gt; 1) THEN
RETURN(FALSE);
END_IF;
IF (SIZEOF (QUERY (i &lt;* selected_representation.used_representation.items |
('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND
(i.name = 'selection control')))= 0) AND
(SIZEOF (QUERY (i &lt;* selected_representation.used_representation.items |
(i.name = 'selection quantity') AND
(SIZEOF(['PRODUCT_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM' ,
'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF (i)) =0))) &gt; 0) THEN
RETURN(FALSE);
END_IF;
RETURN(TRUE);
                                                            </algorithm>
		</function>
		<function name="valid_time">
			<parameter name="time">
				<typename name="local_time"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF EXISTS(time.second_component) THEN
RETURN (EXISTS(time.minute_component));
ELSE
RETURN (TRUE);
END_IF;
                                                            </algorithm>
		</function>
		<function name="valid_units">
			<parameter name="m">
				<typename name="measure_with_unit"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE'
IN TYPEOF (m.value_component) THEN
IF derive_dimensional_exponents (m.unit_component) &lt;&gt;
dimensional_exponents (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
RETURN (FALSE);
END_IF;
END_IF;
RETURN (TRUE);
                                                            </algorithm>
		</function>
		<function name="value_range_aggregate_rep_item">
			<parameter name="agg">
				<aggregate type="AGGREGATE"/>
				<typename name="representation_item"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
BEGIN
IF (SIZEOF(QUERY(i1 &lt;* agg | ('INERTIA_CHARACTERISTICS_MIM' + '.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)))) = 6) THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;
                                                            </algorithm>
		</function>
		<function name="value_range_wr1">
			<parameter name="agg">
				<typename name="compound_item_definition"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 &lt;* agg | (
'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 &lt;* agg | (
'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
                                                            </algorithm>
		</function>
		<function name="value_range_wr2">
			<parameter name="agg">
				<typename name="compound_item_definition"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
BEGIN
IF (SIZEOF(QUERY (i &lt;* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i &lt;* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
                                                            </algorithm>
		</function>
		<function name="value_range_wr3">
			<parameter name="agg">
				<typename name="compound_item_definition"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
BEGIN
IF (SIZEOF(QUERY(i1 &lt;* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 &lt;* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
(i1 :&lt;&gt;: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;
                                                            </algorithm>
		</function>
		<function name="vector_difference">
			<parameter name="arg1">
				<typename name="vector_or_direction"/>
			</parameter>
			<parameter name="arg2">
				<typename name="vector_or_direction"/>
			</parameter>
			<typename name="vector"/>
			<algorithm>
LOCAL
result : vector;
res, vec1, vec2 : direction;
mag, mag1, mag2 : REAL;
ndim : INTEGER;
END_LOCAL;
IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
RETURN (?) ;
ELSE
BEGIN
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1.0;
vec1 := arg1;
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1.0;
vec2 := arg2;
END_IF;
vec1 := normalise (vec1);
vec2 := normalise (vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0.0;
res := dummy_gri || direction(vec1.direction_ratios);
REPEAT i := 1 TO ndim;
res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
mag2*vec2.direction_ratios[i];
mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(vec1, 0.0);
END_IF;
END;
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="vector_sum">
			<parameter name="arg1">
				<typename name="vector_or_direction"/>
			</parameter>
			<parameter name="arg2">
				<typename name="vector_or_direction"/>
			</parameter>
			<typename name="vector"/>
			<algorithm>
LOCAL
result : vector;
res, vec1, vec2 : direction;
mag, mag1, mag2 : REAL;
ndim : INTEGER;
END_LOCAL;
IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
RETURN (?) ;
ELSE
BEGIN
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1.0;
vec1 := arg1;
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1.0;
vec2 := arg2;
END_IF;
vec1 := normalise (vec1);
vec2 := normalise (vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0.0;
res := dummy_gri || direction(vec1.direction_ratios);
REPEAT i := 1 TO ndim;
res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
mag2*vec2.direction_ratios[i];
mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(vec1, 0.0);
END_IF;
END;
END_IF;
RETURN (result);
                                                            </algorithm>
		</function>
		<function name="vertex_point_pcurves">
			<parameter name="a_vertex">
				<typename name="vertex_point"/>
			</parameter>
			<parameter name="the_degenerates">
				<aggregate type="SET"/>
				<typename name="evaluated_degenerate_pcurve"/>
			</parameter>
			<aggregate type="SET"/>
			<typename name="degenerate_pcurve"/>
			<algorithm>
LOCAL
a_point : point;
result : SET OF degenerate_pcurve;
END_LOCAL;
a_point := a_vertex.vertex_geometry;
result := [];
IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
result := result + a_point;
ELSE
REPEAT j := 1 TO SIZEOF(the_degenerates);
IF (the_degenerates[j].equivalent_point :=: a_point) THEN
result := result + the_degenerates[j];
END_IF;
END_REPEAT;
END_IF;
RETURN (RESULT);
                                                            </algorithm>
		</function>
		<function name="volume_weights_positive">
			<parameter name="b">
				<typename name="rational_b_spline_volume"/>
			</parameter>
			<builtintype type="BOOLEAN"/>
			<algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper;
REPEAT j := 0 TO b.v_upper;
REPEAT k := 0 TO b.w_upper;
IF (b.weights[i][j][k] &lt;= 0.0) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
END_REPEAT;
RETURN(result);
                                                            </algorithm>
		</function>
		<rule name="compatible_dimension" appliesto="cartesian_point direction geometric_representation_context">
			<where label="WR1" expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY(y &lt;* geometric_representation_context | item_in_context(x,y) AND(HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) =0">
                                                            </where>
			<where label="WR2" expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF(QUERY(y &lt;* geometric_representation_context | item_in_context(x,y) AND(HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)))&gt; 0)) = 0">
                                                            </where>
		</rule>
		<rule name="plib_property_reference_requires_name_scope" appliesto="externally_defined_general_property">
			<algorithm>
LOCAL
known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
known_sourced_properties := QUERY(edc &lt;* externally_defined_general_property |
'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF(edc.source));
                                                            </algorithm>
			<where label="WR1" expression="SIZEOF (QUERY (edgp &lt;* known_sourced_properties |(SIZEOF (QUERY (edir &lt;* USEDIN (edgp, 'EXTERNAL_PROPERTIES_MIM' + '.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM')|(edir.name = 'name scope') AND('EXTERNAL_PROPERTIES_MIM' + '.EXTERNALLY_DEFINED_CLASS' IN TYPEOF (edir.related_item)) AND('EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF (edir.related_item.source)))) &lt;&gt;1))) = 0">
                                                            </where>
		</rule>
		<rule name="plib_property_reference_requires_version" appliesto="externally_defined_general_property">
			<algorithm>
LOCAL
plib_properties : SET OF externally_defined_general_property := [];
END_LOCAL;
plib_properties := QUERY (edgp &lt;* externally_defined_general_property |
('EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF (edgp.source)) AND
(known_source\pre_defined_item.name = 'ISO 13584 library'));
                                                            </algorithm>
			<where label="WR1" expression="SIZEOF(QUERY(edgp &lt;* plib_properties |(SIZEOF(QUERY(edir &lt;* USEDIN(edgp, 'EXTERNAL_PROPERTIES_MIM' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') |(edir.role.name = 'version'))) &lt;&gt; 1))) = 0">
                                                            </where>
		</rule>
		<rule name="restrict_language_assignment_per_attribute" appliesto="attribute_language_assignment">
			<where label="WR1" expression="SIZEOF (QUERY (ala1 &lt;* attribute_language_assignment | SIZEOF(QUERY(it &lt;* ala1.items | SIZEOF (QUERY (ala2 &lt;* USEDIN (it ,'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |(ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name) AND(ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class))) &gt;1)) &gt;0)) =0">
                                                            </where>
		</rule>
		<subtype.constraint name="classification_or_complete_membership" entity="classification_assignment" super.expression="ONEOF(classification, complete_membership)">
                                                          </subtype.constraint>
	</schema>
</express>
