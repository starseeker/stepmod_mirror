<?xml version="1.0"?>
<!-- $Id: express2xml.js,v 1.8 2002/02/15 12:21:31 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.8"
    source="../data/modules/geometric_validation_property_representation/mim_lf.exp"/>

  <schema name="geometric_validation_property_representation_mim">
    <type name="area_measure">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="attribute_type">
      <select
        selectitems="label text">
      </select>

    </type>
    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>

    </type>
    <type name="characterized_definition">
      <select
        selectitems="characterized_product_definition shape_definition">
      </select>

    </type>
    <type name="characterized_product_definition">
      <select
        selectitems="product_definition">
      </select>

    </type>
    <type name="derived_property_select">
      <select
        selectitems="property_definition">
      </select>

    </type>
    <type name="description_attribute_select">
      <select
        selectitems="application_context organization_role person_and_organization_role person_and_organization property_definition_representation representation">
      </select>

    </type>
    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>


      <where
        label="WHERE"
        expression="(SELF &gt; 0)">
      </where>
    </type>
    <type name="founded_item_select">
      <select
        selectitems="representation_item">
      </select>

    </type>
    <type name="id_attribute_select">
      <select
        selectitems="application_context representation">
      </select>

    </type>
    <type name="identification_item">
      <select
        selectitems="applied_identification_assignment">
      </select>

    </type>
    <type name="identification_organization_item">
      <select
        selectitems="organization_item">
      </select>

    </type>
    <type name="identification_person_and_organization_item">
      <select
        selectitems="person_and_organization_item">
      </select>

    </type>
    <type name="identifier">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="label">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="length_measure">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="measure_value">
      <select
        selectitems="length_measure area_measure volume_measure">
      </select>

    </type>
    <type name="name_attribute_select">
      <select
        selectitems="person_and_organization product_definition property_definition_representation">
      </select>

    </type>
    <type name="organization_item">
      <select
        selectitems="applied_organization_assignment">
      </select>

    </type>
    <type name="person_and_organization_item">
      <select
        selectitems="applied_person_and_organization_assignment">
      </select>

    </type>
    <type name="person_organization_select">
      <select
        selectitems="person organization person_and_organization">
      </select>

    </type>
    <type name="representation_identification_item">
      <select
        selectitems="representation">
      </select>

    </type>
    <type name="represented_definition">
      <select
        selectitems="property_definition shape_aspect shape_aspect_relationship">
      </select>

    </type>
    <type name="shape_definition">
      <select
        selectitems="product_definition_shape shape_aspect shape_aspect_relationship">
      </select>

    </type>
    <type name="text">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="transformation">
      <select
        selectitems="item_defined_transformation functionally_defined_transformation">
      </select>

    </type>
    <type name="trimming_select">
      <select
        selectitems="cartesian_point">
      </select>

    </type>
    <type name="unit">
      <select
        selectitems="named_unit">
      </select>

    </type>
    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>

    </type>
    <type name="volume_measure">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <entity
      name="address">
      <explicit
        name="internal_location"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_box"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="town"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="region"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_code"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="country"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="facsimile_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telephone_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="electronic_mail_address"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telex_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(               electronic_mail_address) OR EXISTS(telex_number))">
      </where>
    </entity>

    <entity
      name="application_context">
      <explicit
        name="application">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <inverse
        name="context_elements"
        entity="application_context_element"
        attribute="frame_of_reference">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="application_context_element"
      super.expression="(ONEOF (product_context,product_definition_context))">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="applied_identification_assignment"
      supertypes="identification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="identification_item"/>
      </explicit>
    </entity>

    <entity
      name="applied_organization_assignment"
      supertypes="organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization_item"/>
      </explicit>
    </entity>

    <entity
      name="applied_person_and_organization_assignment"
      supertypes="person_and_organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person_and_organization_item"/>
      </explicit>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis),representation_item('') ||              geometric_representation_item() || direction([0,0,1]))">
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\placement.location.dim = 3)">
      </where>
      <where
        label="wr2"
        expression="((NOT EXISTS(axis)) OR (axis.dim = 3))">
      </where>
      <where
        label="wr3"
        expression="((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3))">
      </where>
      <where
        label="wr4"
        expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (               cross_product(axis,ref_direction).magnitude &gt; 0))">
      </where>
    </entity>

    <entity
      name="cartesian_point"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(ONEOF (cartesian_transformation_operator_2d,        cartesian_transformation_operator_3d))"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale,1)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="wr1"
        expression="(scl &gt; 0)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_2d"
      supertypes="cartesian_transformation_operator">
      <derived
        name="u"
        expression="base_axis(2,SELF\             cartesian_transformation_operator.axis1,SELF\             cartesian_transformation_operator.axis2,?)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3,SELF\             cartesian_transformation_operator.axis1,SELF\             cartesian_transformation_operator.axis2,axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="description_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="described_item">
        <typename
          name="description_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="dimensional_exponents">
      <explicit
        name="length_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="mass_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="time_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="electric_current_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="thermodynamic_temperature_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="amount_of_substance_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="luminous_intensity_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <typename
          name="REAL"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( tmp &lt;* direction_ratios | (tmp &lt;&gt; 0) )) &gt; 0)">
      </where>
    </entity>

    <entity
      name="functionally_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF (point,direction,vector,placement,        cartesian_transformation_operator))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY ( using_rep &lt;* using_representations(SELF) | (               NOT ('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.GEOMETRIC_REPRESENTATION_CONTEXT'                IN TYPEOF(using_rep.context_of_items))) )) = 0)">
      </where>
    </entity>

    <entity
      name="global_uncertainty_assigned_context"
      supertypes="representation_context">
      <explicit
        name="uncertainty">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="uncertainty_measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="global_unit_assigned_context"
      supertypes="representation_context">
      <explicit
        name="units">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="unit"/>
      </explicit>
    </entity>

    <entity
      name="id_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="identified_item">
        <typename
          name="id_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="identification_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="identification_role"/>
      </explicit>
    </entity>

    <entity
      name="identification_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="item_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="transform_item_1">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="transform_item_2">
        <typename
          name="representation_item"/>
      </explicit>
    </entity>

    <entity
      name="length_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="wr1"
        expression="('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.LENGTH_UNIT'                IN TYPEOF(SELF\measure_with_unit.unit_component))">
      </where>
    </entity>

    <entity
      name="mapped_item"
      supertypes="representation_item">
      <explicit
        name="mapping_source">
        <typename
          name="representation_map"/>
      </explicit>
      <explicit
        name="mapping_target">
        <typename
          name="representation_item"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_mapped_representation(using_representations(SELF),[SELF])">
      </where>
    </entity>

    <entity
      name="measure_representation_item"
      supertypes="representation_item measure_with_unit">
    </entity>

    <entity
      name="measure_with_unit"
      super.expression="(length_measure_with_unit)">
      <explicit
        name="value_component">
        <typename
          name="measure_value"/>
      </explicit>
      <explicit
        name="unit_component">
        <typename
          name="unit"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_units(SELF)">
      </where>
    </entity>

    <entity
      name="name_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="named_item">
        <typename
          name="name_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="named_unit">
      <explicit
        name="dimensions">
        <typename
          name="dimensional_exponents"/>
      </explicit>
    </entity>

    <entity
      name="organization">
      <explicit
        name="id"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organization_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_organization">
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="organization_role"/>
      </explicit>
    </entity>

    <entity
      name="organization_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="organizational_address"
      supertypes="address">
      <explicit
        name="organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="person">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="last_name"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="first_name"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="middle_names"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="prefix_titles"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="suffix_titles"
        optional="YES">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(EXISTS(last_name) OR EXISTS(first_name))">
      </where>
    </entity>

    <entity
      name="person_and_organization">
      <explicit
        name="the_person">
        <typename
          name="person"/>
      </explicit>
      <explicit
        name="the_organization">
        <typename
          name="organization"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="person_and_organization_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_person_and_organization">
        <typename
          name="person_and_organization"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="person_and_organization_role"/>
      </explicit>
    </entity>

    <entity
      name="person_and_organization_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="personal_address"
      supertypes="address">
      <explicit
        name="people">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="placement"
      super.expression="(ONEOF (axis1_placement,axis2_placement_2d,        axis2_placement_3d))"
      supertypes="geometric_representation_item">
      <explicit
        name="location">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="point"
      super.expression="(cartesian_point)"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="product">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="product_context"/>
      </explicit>
    </entity>

    <entity
      name="product_context"
      supertypes="application_context_element">
      <explicit
        name="discipline_type">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="product_definition">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="formation">
        <typename
          name="product_definition_formation"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="product_definition_context"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="product_definition_context"
      supertypes="application_context_element">
      <explicit
        name="life_cycle_stage">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="product_definition_formation">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="of_product">
        <typename
          name="product"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="id"/>
        <unique.attribute
          attribute="of_product"/>
      </unique>
    </entity>

    <entity
      name="product_definition_shape"
      supertypes="property_definition">
      <unique
        label="ur1">
        <unique.attribute
          attribute="definition"/>
      </unique>
      <where
        label="wr1"
        expression="(SIZEOF(['GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.CHARACTERIZED_PRODUCT_DEFINITION','GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.CHARACTERIZED_OBJECT']                * TYPEOF(SELF\property_definition.definition)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="property_definition">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="definition">
        <typename
          name="characterized_definition"/>
      </explicit>
    </entity>

    <entity
      name="property_definition_representation">
      <explicit
        name="definition">
        <typename
          name="represented_definition"/>
      </explicit>
      <explicit
        name="used_representation">
        <typename
          name="representation"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="representation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="context_of_items">
        <typename
          name="representation_context"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,               'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' +                'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="representation_context">
      <explicit
        name="context_identifier">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="context_type">
        <typename
          name="text"/>
      </explicit>
      <inverse
        name="representations_in_context"
        entity="representation"
        attribute="context_of_items">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
    </entity>

    <entity
      name="representation_item">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(using_representations(SELF)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="representation_map">
      <explicit
        name="mapping_origin">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="mapped_representation">
        <typename
          name="representation"/>
      </explicit>
      <inverse
        name="map_usage"
        entity="mapped_item"
        attribute="mapping_source">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="item_in_context(SELF.mapping_origin,SELF.mapped_representation.               context_of_items)">
      </where>
    </entity>

    <entity
      name="representation_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="rep_1">
        <typename
          name="representation"/>
      </explicit>
      <explicit
        name="rep_2">
        <typename
          name="representation"/>
      </explicit>
    </entity>

    <entity
      name="representation_relationship_with_transformation"
      supertypes="representation_relationship">
      <explicit
        name="transformation_operator">
        <typename
          name="transformation"/>
      </explicit>
      <where
        label="wr1"
        expression="(SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;:                SELF\representation_relationship.rep_2.context_of_items)">
      </where>
    </entity>

    <entity
      name="shape_aspect">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="of_shape">
        <typename
          name="product_definition_shape"/>
      </explicit>
      <explicit
        name="product_definitional">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="shape_aspect_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_shape_aspect">
        <typename
          name="shape_aspect"/>
      </explicit>
      <explicit
        name="related_shape_aspect">
        <typename
          name="shape_aspect"/>
      </explicit>
    </entity>

    <entity
      name="shape_definition_representation"
      supertypes="property_definition_representation">
      <where
        label="wr1"
        expression="(('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.PRODUCT_DEFINITION_SHAPE'                IN TYPEOF(SELF.definition)) OR ('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.SHAPE_DEFINITION'                IN TYPEOF(SELF.definition.definition)))">
      </where>
      <where
        label="wr2"
        expression="('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.SHAPE_REPRESENTATION'                IN TYPEOF(SELF.used_representation))">
      </where>
    </entity>

    <entity
      name="shape_representation"
      supertypes="representation">
    </entity>

    <entity
      name="shape_representation_relationship"
      supertypes="representation_relationship">
      <where
        label="wr1"
        expression="('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.SHAPE_REPRESENTATION'                IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(               SELF\representation_relationship.rep_2)))">
      </where>
    </entity>

    <entity
      name="uncertainty_measure_with_unit"
      supertypes="measure_with_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_measure_value(SELF\measure_with_unit.value_component)">
      </where>
    </entity>

    <entity
      name="vector"
      supertypes="geometric_representation_item">
      <explicit
        name="orientation">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="magnitude">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(magnitude &gt;= 0)">
      </where>
    </entity>

    <rule
      name="compatible_dimension"
      appliesto="cartesian_point direction representation_context geometric_representation_context">
      <algorithm>

  WHERE
    wr1: (SIZEOF(QUERY ( x &lt;* cartesian_point | (SIZEOF(QUERY ( y &lt;* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension)) )) &gt; 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x &lt;* direction | (SIZEOF(QUERY ( y &lt;* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)) )) 
             &gt; 0) )) = 0);

      </algorithm>

    </rule>

    <function
      name="acyclic_mapped_representation">
      <parameter
        name="parent_set">
        <aggregate
          type="SET"/>
        <typename
          name="representation"/>
      </parameter>
      <parameter
        name="children_set">
        <aggregate
          type="SET"/>
        <typename
          name="representation_item"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z &lt;* children_set | (
        'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.MAPPED_ITEM' IN 
        TYPEOF(z)) );
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z &lt;* bag_to_set(USEDIN(x[i],'')) | ('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION_ITEM' 
            IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="bag_to_set">
      <parameter
        name="the_bag">
        <aggregate
          type="BAG"/>
        <typename
          name="GENERICintype"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="GENERICintype"/>
      <algorithm>

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

      </algorithm>

    </function>

    <function
      name="base_axis">
      <parameter
        name="dim">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="axis1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis2">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis3">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      u      : LIST [2:3] OF direction;
      vec    : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      u[3] := NVL(normalise(axis3),representation_item('') || 
          geometric_representation_item() || direction([0,0,1]));
      u[1] := first_proj_axis(u[3],axis1);
      u[2] := second_proj_axis(u[3],u[1],axis2);
    ELSE
      u[3] := ?;
      IF EXISTS(axis1) THEN
        u[1] := normalise(axis1);
        u[2] := orthogonal_complement(u[1]);
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor &lt; 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          u[2] := normalise(axis2);
          u[1] := orthogonal_complement(u[2]);
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u[1].name := '';
          u[2].name := '';
          u[1].direction_ratios[1] := 1;
          u[1].direction_ratios[2] := 0;
          u[2].direction_ratios[1] := 0;
          u[2].direction_ratios[2] := 1;
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

      </algorithm>

    </function>

    <function
      name="build_2axes">
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="2"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      u : LIST [2:2] OF direction;
    END_LOCAL;
    u[1] := NVL(normalise(ref_direction),representation_item('') || 
        geometric_representation_item() || direction([1,0]));
    u[2] := orthogonal_complement(u[1]);
    RETURN(u);

      </algorithm>

    </function>

    <function
      name="build_axes">
      <parameter
        name="axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="3"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      u : LIST [3:3] OF direction;
    END_LOCAL;
    u[3] := NVL(normalise(axis),representation_item('') || 
        geometric_representation_item() || direction([0,0,1]));
    u[1] := first_proj_axis(u[3],ref_direction);
    u[2] := normalise(cross_product(u[3],u[1])).orientation;
    RETURN(u);

      </algorithm>

    </function>

    <function
      name="cross_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res.name := '';
        res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
        res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
        res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result.orientation := res;
          result.magnitude := SQRT(mag);
        ELSE
          result.orientation := arg1;
          result.magnitude := 0;
        END_IF;
        result.name := '';
        RETURN(result);
      END;
    END_IF;

      </algorithm>

    </function>

    <function
      name="derive_dimensional_exponents">
      <parameter
        name="x">
        <typename
          name="unit"/>
      </parameter>
      <typename
        name="dimensional_exponents"/>
      <algorithm>

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.DERIVED_UNIT' IN 
        TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="dimension_of">
      <parameter
        name="item">
        <typename
          name="geometric_representation_item"/>
      </parameter>
      <typename
        name="dimension_count"/>
      <algorithm>

    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

      </algorithm>

    </function>

    <function
      name="dot_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <builtintype
        type="REAL"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim &lt;&gt; arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

      </algorithm>

    </function>

    <function
      name="first_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios &lt;&gt; [1,0,0] THEN
          v := representation_item('') || geometric_representation_item() 
              || direction([1,0,0]);
        ELSE
          v := representation_item('') || geometric_representation_item() 
              || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim &lt;&gt; 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

      </algorithm>

    </function>

    <function
      name="get_description_value">
      <parameter
        name="obj">
        <typename
          name="description_attribute_select"/>
      </parameter>
      <typename
        name="text"/>
      <algorithm>

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' 
                         + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="get_id_value">
      <parameter
        name="obj">
        <typename
          name="id_attribute_select"/>
      </parameter>
      <typename
        name="identifier"/>
      <algorithm>

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,
                'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' + 
                'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="get_name_value">
      <parameter
        name="obj">
        <typename
          name="name_attribute_select"/>
      </parameter>
      <typename
        name="label"/>
      <algorithm>

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.' + 
                  'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

      </algorithm>

    </function>

    <function
      name="item_in_context">
      <parameter
        name="item">
        <typename
          name="representation_item"/>
      </parameter>
      <parameter
        name="cntxt">
        <typename
          name="representation_context"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION.ITEMS') 
        * cntxt.representations_in_context) &gt; 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z &lt;* USEDIN(item,'') | ('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION_ITEM' 
          IN TYPEOF(z)) );
      IF SIZEOF(y) &gt; 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

      </algorithm>

    </function>

    <function
      name="normalise">
      <parameter
        name="arg">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector_or_direction"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      RETURN(?);
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          vec := arg;
          v := arg.orientation;
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec.magnitude := 1;
          END_IF;
        END;
      ELSE
        v := arg;
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag &gt; 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="orthogonal_complement">
      <parameter
        name="vec">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result.name := '';
      result.direction_ratios[1] := -vec.direction_ratios[2];
      result.direction_ratios[2] := vec.direction_ratios[1];
      RETURN(result);
    END_IF;

      </algorithm>

    </function>

    <function
      name="scalar_times_vector">
      <parameter
        name="scalar">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="vec">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VECTOR' IN TYPEOF(vec) THEN
        v := vec.orientation;
        mag := scalar * vec.magnitude;
      ELSE
        v := vec;
        mag := scalar;
      END_IF;
      IF mag &lt; 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result.name := '';
      result.orientation := normalise(v);
      result.magnitude := mag;
    END_IF;
    RETURN(result);

      </algorithm>

    </function>

    <function
      name="second_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="x_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := representation_item('') || geometric_representation_item() || 
          direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

      </algorithm>

    </function>

    <function
      name="using_items">
      <parameter
        name="item">
        <typename
          name="founded_item_select"/>
      </parameter>
      <parameter
        name="checked_items">
        <aggregate
          type="SET"/>
        <typename
          name="founded_item_select"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="founded_item_select"/>
      <algorithm>

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z &lt;* bag_to_set(USEDIN(item,'')) | (('GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION_ITEM' 
        IN TYPEOF(z)) OR (
        'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.FOUNDED_ITEM' IN 
        TYPEOF(z))) );
    IF SIZEOF(next_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

      </algorithm>

    </function>

    <function
      name="using_representations">
      <parameter
        name="item">
        <typename
          name="founded_item_select"/>
      </parameter>
      <aggregate
        type="SET"/>
      <typename
        name="representation"/>
      <algorithm>

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

      </algorithm>

    </function>

    <function
      name="valid_measure_value">
      <parameter
        name="m">
        <typename
          name="measure_value"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m &gt; 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m &gt; 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

      </algorithm>

    </function>

    <function
      name="valid_units">
      <parameter
        name="m">
        <typename
          name="measure_with_unit"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.LENGTH_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.MASS_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.TIME_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.ELECTRIC_CURRENT_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.THERMODYNAMIC_TEMPERATURE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.AMOUNT_OF_SUBSTANCE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.LUMINOUS_INTENSITY_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.SOLID_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.AREA_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VOLUME_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.RATIO_MEASURE' IN
         TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.POSITIVE_LENGTH_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.POSITIVE_PLANE_ANGLE_MEASURE' 
        IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

      </algorithm>

    </function>

    <function
      name="vector_difference">
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim &lt;&gt; arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VECTOR' IN TYPEOF(arg1)
             THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRIC_VALIDATION_PROPERTY_REPRESENTATION_MIM.VECTOR' IN TYPEOF(arg2)
             THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result.magnitude := SQRT(mag);
          result.orientation := res;
        ELSE
          result.magnitude := 0;
          result.orientation := vec1;
        END_IF;
      END;
    END_IF;
    result.name := '';
    RETURN(result);

      </algorithm>

    </function>

  </schema>

</express>
