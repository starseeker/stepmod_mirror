(*
   $Id: MimGenerator.java,v 1.6 2004/11/22 16:26:37 raimundas Exp $
   ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-xxxx Interconnect module connection routing - EXPRESS MIM
*)


SCHEMA Interconnect_module_connection_routing_mim;
	USE FROM Fabrication_joint_mim;
	USE FROM Functional_design_elaboration_mim;
	USE FROM Layered_interconnect_module_with_design_intend_modifications_mim;
	
ENTITY direct_stratum_component_join_implementation
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
SELF\direct_stratum_component_join_implementation)) = 0;
END_ENTITY; -- direct_stratum_component_join_implementation

ENTITY indirect_stratum_component_join_implementation
  SUBTYPE OF (plated_inter_stratum_feature);
END_ENTITY; -- indirect_stratum_component_join_implementation

RULE junction_vertex_allocation_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation')
       AND NOT ((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'LAYER_CONNECTION_POINT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.description = 'explicitly located')) OR
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join'))
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND
       NOT (sar.relating_shape_aspect\shape_aspect.description = 
                        'topological junction'))) = 0;
END_RULE; -- junction_vertex_allocation_constraint

RULE junction_vertex_allocation_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  jva : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'junction vertex allocation') );
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(jva) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF EXISTS( jva[i].relating_shape_aspect ) THEN
    IF ( jva[i].relating_shape_aspect\shape_aspect.description = 
                       'topological junction' ) THEN
      IF ( jva[i].relating_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + jva[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- junction_vertex_allocation_unique_constraint
	
RULE physical_connectivity_abstraction_map_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  pcam : BAG OF shape_aspect_relationship := 
        QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'physical to topological abstraction map') );
  pce_bag : BAG OF physical_connectivity_element := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pcam) by 1;
  IF EXISTS( pcam[i].related_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_CONNECTIVITY_ELEMENT' IN 
TYPEOF(pcam[i].related_shape_aspect) ) THEN
      IF ( NOT ( pcam[i].related_shape_aspect IN pce_bag )) THEN
        pce_bag := pce_bag + pcam[i].related_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pce_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  csa_bag := [];
  sar_bag := QUERY( sar <* pcam | (sar.related_shape_aspect :=: 
                 pce_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_SHAPE_ASPECT' IN 
TYPEOF(sar_bag[j].relating_shape_aspect))
AND (sar_bag[j].relating_shape_aspect\shape_aspect.description IN [
'conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition']) )
                                                      THEN
      IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
        IF ( sar_bag[j].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- physical_connectivity_abstraction_map_unique_constraint

RULE topological_junction_unique_constraint FOR
 ( shape_aspect );
LOCAL
  tj : BAG OF shape_aspect := 
   QUERY( r <* shape_aspect | (r\shape_aspect.description = 'topological junction'));
  sar_bag : BAG OF shape_aspect_relationship;
  s_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tj) by 1;
  sar_bag := QUERY( sar <* USEDIN( tj[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
((sar\shape_aspect_relationship.name = 'topological junction scope') AND
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_CONNECTIVITY_DEFINITION') IN
TYPEOF(sar.relating_shape_aspect)) ) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].relating_shape_aspect IN s_bag ) ) THEN
        s_bag := s_bag + sar_bag[j].relating_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( s_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | 
(sar\shape_aspect_relationship.name = 'topological junction scope') );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- topological_junction_unique_constraint
	
END_SCHEMA;

