<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2004-12-14T12:55:45" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="interconnect_module_connection_routing_mim schema_instance"/>
   <schema name="Interconnect_module_connection_routing_mim">
      <interface kind="use" schema="FABRICATION_JOINT_MIM"/>
      <interface kind="use" schema="FUNCTIONAL_DESIGN_ELABORATION_MIM"/>
      <interface kind="use" schema="LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTEND_MODIFICATIONS_MIM"/>
      <entity name="direct_stratum_component_join_implementation" supertypes="shape_aspect_relationship">
         <where label="wr1" expression=" sizeof ( typeof ( self ) - typeof ( self \ shape_aspect_relationship || self \ direct_stratum_component_join_implementation ) ) = 0 "/>
      </entity>
      <entity name="indirect_stratum_component_join_implementation" supertypes="plated_inter_stratum_feature"/>
      <rule name="junction_vertex_allocation_constraint" appliesto="shape_aspect_relationship">
         <where label="wr1" expression=" sizeof ( query ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) and not ( ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'layer_connection_point' in typeof ( sar . related_shape_aspect ) ) and ( sar . related_shape_aspect \ shape_aspect . description = 'explicitly located' ) ) or ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'join_shape_aspect' in typeof ( sar . related_shape_aspect ) ) and ( sar . related_shape_aspect \ shape_aspect . name = 'inter stratum join' ) ) ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) and not ( sar . relating_shape_aspect \ shape_aspect . description = 'topological junction' ) ) ) = 0 "/>
      </rule>
      <rule name="junction_vertex_allocation_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm> local jva : bag of shape_aspect_relationship := query ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) ) ; pass : boolean := true ; sa_bag : bag of shape_aspect := [ ] ; end_local ; repeat i := 1 to sizeof ( jva ) by 1 ; if ( not pass ) then escape ; end_if ; if exists ( jva [ i ] . relating_shape_aspect ) then if ( jva [ i ] . relating_shape_aspect \ shape_aspect . description = 'topological junction' ) then if ( jva [ i ] . relating_shape_aspect in sa_bag ) then pass := false ; escape ; else sa_bag := sa_bag + jva [ i ] . relating_shape_aspect ; end_if ; end_if ; end_if ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="physical_connectivity_abstraction_map_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm> local pcam : bag of shape_aspect_relationship := query ( r &lt;* shape_aspect_relationship | ( r \ shape_aspect_relationship . name = 'physical to topological abstraction map' ) ) ; pce_bag : bag of physical_connectivity_element := [ ] ; sar_bag : bag of shape_aspect_relationship ; pass : boolean := true ; csa_bag : bag of component_shape_aspect ; end_local ; repeat i := 1 to sizeof ( pcam ) by 1 ; if exists ( pcam [ i ] . related_shape_aspect ) then if ( 'electronic_assembly_interconnect_and_packaging_design.' + 'physical_connectivity_element' in typeof ( pcam [ i ] . related_shape_aspect ) ) then if ( not ( pcam [ i ] . related_shape_aspect in pce_bag ) ) then pce_bag := pce_bag + pcam [ i ] . related_shape_aspect ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( pce_bag ) by 1 ; if ( not pass ) then escape ; end_if ; csa_bag := [ ] ; sar_bag := query ( sar &lt;* pcam | ( sar . related_shape_aspect :=: pce_bag [ i ] ) ) ; repeat j := 1 to sizeof ( sar_bag ) by 1 ; if ( not pass ) then escape ; end_if ; if ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'component_shape_aspect' in typeof ( sar_bag [ j ] . relating_shape_aspect ) ) and ( sar_bag [ j ] . relating_shape_aspect \ shape_aspect . description in [ 'conductive interconnect element with pre defined transitions' , 'conductive interconnect element with user defined single transition' ] ) ) then if exists ( sar_bag [ j ] . relating_shape_aspect ) then if ( sar_bag [ j ] . relating_shape_aspect in csa_bag ) then pass := false ; escape ; else csa_bag := csa_bag + sar_bag [ j ] . relating_shape_aspect ; end_if ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="topological_junction_unique_constraint" appliesto="shape_aspect">
         <algorithm> local tj : bag of shape_aspect := query ( r &lt;* shape_aspect | ( r \ shape_aspect . description = 'topological junction' ) ) ; sar_bag : bag of shape_aspect_relationship ; s_bag : bag of shape_aspect := [ ] ; pass : boolean := true ; name_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( tj ) by 1 ; sar_bag := query ( sar &lt;* usedin ( tj [ i ] , 'electronic_assembly_interconnect_and_packaging_design.' + 'shape_aspect_relationship.related_shape_aspect' ) | ( ( sar \ shape_aspect_relationship . name = 'topological junction scope' ) and ( ( 'electronic_assembly_interconnect_and_packaging_design.' + 'physical_connectivity_definition' ) in typeof ( sar . relating_shape_aspect ) ) ) ) ; repeat j := 1 to sizeof ( sar_bag ) by 1 ; if exists ( sar_bag [ j ] . relating_shape_aspect ) then if ( not ( sar_bag [ j ] . relating_shape_aspect in s_bag ) ) then s_bag := s_bag + sar_bag [ j ] . relating_shape_aspect ; end_if ; end_if ; end_repeat ; end_repeat ; repeat i := 1 to sizeof ( s_bag ) by 1 ; if ( not pass ) then escape ; end_if ; sar_bag := query ( sar &lt;* usedin ( s_bag [ i ] , 'electronic_assembly_interconnect_and_packaging_design.' + 'shape_aspect_relationship.relating_shape_aspect' ) | ( sar \ shape_aspect_relationship . name = 'topological junction scope' ) ) ; name_bag := [ ] ; repeat j := 1 to sizeof ( sar_bag ) by 1 ; if exists ( sar_bag [ j ] . related_shape_aspect \ shape_aspect . name ) then if ( sar_bag [ j ] . related_shape_aspect \ shape_aspect . name in name_bag ) then pass := false ; escape ; else name_bag := name_bag + sar_bag [ j ] . related_shape_aspect \ shape_aspect . name ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
   </schema>
</express>
