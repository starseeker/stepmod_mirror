<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-04-04T14:14:53" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="interconnect_module_connection_routing_mim schema_instance"/>
   <schema name="Interconnect_module_connection_routing_mim">
      <interface kind="use" schema="Fabrication_joint_mim"/>
      <interface kind="use" schema="Interconnect_module_with_macros_mim"/>
      <interface kind="use" schema="Layered_interconnect_module_with_design_intent_modifications_mim"/>
      <entity name="direct_stratum_component_join_implementation" supertypes="shape_aspect_relationship">
         <where label="WR1" expression=" SIZEOF ( TYPEOF ( SELF ) - TYPEOF ( SELF \ shape_aspect_relationship || SELF \ direct_stratum_component_join_implementation ) ) = 0 "/>
      </entity>
      <entity name="indirect_stratum_component_join_implementation" supertypes="plated_inter_stratum_feature"/>
      <rule name="explicitly_located_layer_connection_point_unique_constraint" appliesto="layer_connection_point">
         <algorithm> LOCAL ellcp : BAG OF layer_connection_point := QUERY ( lcp &lt;* layer_connection_point | ( lcp \ shape_aspect . description = 'explicitly located' ) ) ; s_bag : BAG OF stratum := [ ] ; lcp_bag : BAG OF layer_connection_point ; pd_bag : BAG OF property_definition ; pdr_bag : BAG OF property_definition_representation ; pass : BOOLEAN := TRUE ; cp_bag : BAG OF cartesian_point ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( ellcp ) by 1 ; IF EXISTS ( ellcp [ i ] . of_shape . definition ) THEN IF ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'STRATUM' IN TYPEOF ( ellcp [ i ] . of_shape . definition ) ) THEN IF ( NOT ( ellcp [ i ] . of_shape . definition IN s_bag ) ) THEN s_bag := s_bag + ellcp [ i ] . of_shape . definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( s_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; cp_bag := [ ] ; lcp_bag := QUERY ( lcp &lt;* ellcp | ( lcp . of_shape . definition :=: s_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( lcp_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pd_bag := USEDIN ( lcp_bag [ j ] , 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PROPERTY_DEFINITION.DEFINITION' ) ; REPEAT k := 1 to SIZEOF ( pd_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdr_bag := QUERY ( pdr &lt;* USEDIN ( pd_bag [ k ] , 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | ( ( pdr . used_representation \ representation . name = 'connection point location' ) AND ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'CARTESIAN_POINT' IN TYPEOF ( pdr . used_representation . items [ 1 ] ) ) ) ) ; REPEAT l := 1 to SIZEOF ( pdr_bag ) by 1 ; IF EXISTS ( pdr_bag [ l ] . used_representation . items [ 1 ] ) THEN IF ( pdr_bag [ l ] . used_representation . items [ 1 ] IN cp_bag ) THEN pass := FALSE ; ESCAPE ; ELSE cp_bag := cp_bag + pdr_bag [ l ] . used_representation . items [ 1 ] ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="junction_vertex_allocation_constraint" appliesto="shape_aspect_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) AND NOT ( ( ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'LAYER_CONNECTION_POINT' IN TYPEOF ( sar . related_shape_aspect ) ) AND ( sar . related_shape_aspect \ shape_aspect . description = 'explicitly located' ) ) OR ( ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF ( sar . related_shape_aspect ) ) AND ( sar . related_shape_aspect \ shape_aspect . name = 'inter stratum join' ) ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) AND NOT ( sar . relating_shape_aspect \ shape_aspect . description = 'topological junction' ) ) ) = 0 "/>
      </rule>
      <rule name="junction_vertex_allocation_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm> LOCAL jva : BAG OF shape_aspect_relationship := QUERY ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'junction vertex allocation' ) ) ; pass : BOOLEAN := TRUE ; sa_bag : BAG OF shape_aspect := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( jva ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; IF EXISTS ( jva [ i ] . relating_shape_aspect ) THEN IF ( jva [ i ] . relating_shape_aspect \ shape_aspect . description = 'topological junction' ) THEN IF ( jva [ i ] . relating_shape_aspect IN sa_bag ) THEN pass := FALSE ; ESCAPE ; ELSE sa_bag := sa_bag + jva [ i ] . relating_shape_aspect ; END_IF ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="topological_junction_unique_constraint" appliesto="shape_aspect">
         <algorithm> LOCAL tj : BAG OF shape_aspect := QUERY ( r &lt;* shape_aspect | ( r \ shape_aspect . description = 'topological junction' ) ) ; sar_bag : BAG OF shape_aspect_relationship ; s_bag : BAG OF shape_aspect := [ ] ; pass : BOOLEAN := TRUE ; name_bag : BAG OF STRING ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( tj ) by 1 ; sar_bag := QUERY ( sar &lt;* USEDIN ( tj [ i ] , 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | ( ( sar \ shape_aspect_relationship . name = 'topological junction scope' ) AND ( ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' ) IN TYPEOF ( sar . relating_shape_aspect ) ) ) ) ; REPEAT j := 1 to SIZEOF ( sar_bag ) by 1 ; IF EXISTS ( sar_bag [ j ] . relating_shape_aspect ) THEN IF ( NOT ( sar_bag [ j ] . relating_shape_aspect IN s_bag ) ) THEN s_bag := s_bag + sar_bag [ j ] . relating_shape_aspect ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( s_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; sar_bag := QUERY ( sar &lt;* USEDIN ( s_bag [ i ] , 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | ( sar \ shape_aspect_relationship . name = 'topological junction scope' ) ) ; name_bag := [ ] ; REPEAT j := 1 to SIZEOF ( sar_bag ) by 1 ; IF EXISTS ( sar_bag [ j ] . related_shape_aspect \ shape_aspect . name ) THEN IF ( sar_bag [ j ] . related_shape_aspect \ shape_aspect . name IN name_bag ) THEN pass := FALSE ; ESCAPE ; ELSE name_bag := name_bag + sar_bag [ j ] . related_shape_aspect \ shape_aspect . name ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
   </schema>
</express>
