(*
   $Id: arm.exp,v 1.29 2005/12/23 11:29:55 kovaliovas Exp $
   ISO TC184/SC4/WG12 N3456 - ISO/CD-TS 10303-1689 Interconnect physical requirement allocation - EXPRESS ARM
*)

 SCHEMA Interconnect_physical_requirement_allocation_arm;

	USE FROM Fabrication_technology_arm;	-- ISO/TS 10303-1670
	
	USE FROM Requirement_view_definition_relationship_arm; -- ISO/TS 10303-1142
	
	USE FROM Integral_shield_arm; -- ISO/TS 10303-xxxx

REFERENCE FROM Requirement_decomposition_arm (
  get_predefined_requirement_view_definition,
  get_rvd);	-- ISO/TS 10303-1740

  TYPE electrical_isolation_removal_structure_or_template = EXTENSIBLE GENERIC_ENTITY SELECT
    (Electrical_isolation_removal_template);
  END_TYPE;

	SUBTYPE_CONSTRAINT material_removal_feature_template_subtypes FOR Material_removal_feature_template; 
	    (ONEOF (Electrical_isolation_removal_template,
	 	Thermal_isolation_removal_template));
	END_SUBTYPE_CONSTRAINT;

 	TYPE thermal_isolation_removal_structure_or_template = EXTENSIBLE GENERIC_ENTITY SELECT
 		(Thermal_isolation_removal_template);
	END_TYPE;

  ENTITY Dependant_electrical_isolation_removal_template
    SUBTYPE OF (Dependant_template, Electrical_isolation_removal_template);
      SELF\Dependant_template.associated_item : Land_physical_template;
  END_ENTITY;

  ENTITY Dependant_thermal_isolation_removal_template
    SUBTYPE OF (Dependant_template, Thermal_isolation_removal_template);
      SELF\Dependant_template.associated_item : Land_physical_template;
  END_ENTITY;

  ENTITY Electrical_isolation_removal_template
    SUBTYPE OF (Material_removal_feature_template);
    DERIVE
      electrical_isolation_spacing_requirement : SET[1:1] OF Requirement_view_definition := 
        get_rvd(SELF, 'electrical requirement');
    WHERE
      WR1: SIZEOF(QUERY(eisr <* electrical_isolation_spacing_requirement |
         NOT('INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_ARM.ELECTRICAL_ISOLATION_REQUIREMENT'
        IN TYPEOF(eisr)) )) =0;
  END_ENTITY;

  ENTITY Electrical_isolation_requirement
    SUBTYPE OF (Requirement_view_definition);
    DERIVE
      effective_voltage_withstand_capacity_requirement : SET[1:1] OF Predefined_requirement_view_definition := 
        get_specific_requirement_view_definition_for_collector(SELF, 'effective voltage withstand capacity requirement');
      electrical_isolation_spacing_requirement : SET[1:1] OF Predefined_requirement_view_definition :=
        get_specific_requirement_type_for_primary_rvd_relationship(SELF, 'electrical isolation spacing requirement', 'LAYOUT_SPACING_REQUIREMENT_OCCURRENCE');
    WHERE
      WR1: 'FABRICATION_TECHNOLOGY_ARM.LAYOUT_SPACING_REQUIREMENT_OCCURRENCE' IN TYPEOF(electrical_isolation_spacing_requirement[1]);
      WR2: NOT EXISTS(SELF\Product_view_definition.additional_characterization);
  END_ENTITY;

  ENTITY Interconnect_shield_allocation
    SUBTYPE OF (Requirement_assignment);
      SELF\Requirement_assignment.assigned_to : integral_or_routed_shield;
    DERIVE
    	assigned_requirement_property :  Predefined_requirement_view_definition := get_predefined_requirement_view_definition(SELF,
      'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_ARM.'+'ELECTROMAGNETIC_REQUIREMENT_OCCURRENCE');
  END_ENTITY;
		
  ENTITY Thermal_isolation_removal_template
    SUBTYPE OF (Material_removal_structured_template);
	DERIVE
  		thermal_isolation_spacing_requirement: SET[1:1] OF Requirement_view_definition :=
		  get_rvd(SELF, 'thermal requirement');
	WHERE
	  WR1: SIZEOF(QUERY(tisr <* THERMAL_ISOLATION_SPACING_REQUIREMENT |
       NOT('INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_ARM.THERMAL_ISOLATION_REQUIREMENT' IN TYPEOF(tisr))
       )) =0;
  END_ENTITY;

  ENTITY Thermal_isolation_requirement
  	SUBTYPE OF (Requirement_view_definition);
  	DERIVE
      effective_current_capacity_requirement : SET [1:1] OF Predefined_requirement_view_definition :=
        get_specific_requirement_view_definition_for_collector(SELF, 'effective current capacity requirement');

      angular_orientation_requirement : SET [1:1] OF Predefined_requirement_view_definition := 
        get_specific_requirement_view_definition_for_collector(SELF, 'angular orientation requirement');
 
      thermal_isolation_spacing_requirement : SET [1:1] OF Predefined_requirement_view_definition :=
        get_specific_requirement_type_for_primary_rvd_relationship(SELF, 'thermal isolation spacing requirement', 'LAYOUT_SPACING_REQUIREMENT_OCCURRENCE');
   WHERE
     WR1 : 'FABRICATION_TECHNOLOGY_ARM.LAYOUT_SPACING_REQUIREMENT_OCCURRENCE' IN TYPEOF(thermal_isolation_spacing_requirement[1]);
     WR2 : NOT EXISTS(SELF\Product_view_definition.additional_characterization);
  END_ENTITY;

FUNCTION get_specific_requirement_view_definition_for_collector(
	input : Requirement_view_definition;
	id : STRING
) : SET OF Predefined_requirement_view_definition; 
LOCAL
    rcr : SET[0:?] OF Requirement_collection_relationship := [];--this gives us access to the information base
    rdp : SET[0:?] OF Predefined_requirement_view_definition :=[];
END_LOCAL;
    rcr := bag_to_set(QUERY(rai <* USEDIN (input, 'REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP_ARM.'+
	'REQUIREMENT_COLLECTION_RELATIONSHIP.COLLECTION') | 
          (rai\View_definition_relationship.relation_type = id)));

	-- iterate over rcr 
    REPEAT i := 1 to SIZEOF(rcr) by 1;
        -- get rdp 
      rdp := rdp + USEDIN (rcr[i].member, 'REQUIREMENT_DECOMPOSITION_ARM.'+
        'PREDEFINED_REQUIREMENT_VIEW_DEFINITION.ASSOCIATED_DEFINITION');
    END_REPEAT;

	RETURN(rdp);
END_FUNCTION;

FUNCTION get_specific_requirement_type_for_primary_rvd_relationship(
	input : Requirement_view_definition;
	id : STRING;
    reqType : STRING
) : SET OF Predefined_requirement_view_definition; 

LOCAL
    rvdr : SET[0:?] OF Requirement_view_definition_relationship := [];
    rdp : SET[0:?] OF Predefined_requirement_view_definition := [];  --this gives us access to the information base
END_LOCAL;
	rvdr := bag_to_set(QUERY(rvdre <* USEDIN (input, 'REQUIREMENT_DECOMPOSITION_ARM.'+ 'REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP.SECONDARY')|
	                           (rvdre.relation_type = id)
                       ));
	-- iterate over rvdr
	REPEAT i := 1 to SIZEOF(rvdr) by 1;
      rdp := rdp + bag_to_set(QUERY(rdp <* USEDIN (rvdr[i].primary, 'REQUIREMENT_DECOMPOSITION_ARM.'+ 'PREDEFINED_REQUIREMENT_VIEW_DEFINITION.ASSOCIATED_DEFINITION') |
        (reqType IN TYPEOF(rdp))
                             ));
	END_REPEAT;

	RETURN(rdp);
END_FUNCTION;
  
FUNCTION bag_to_set(
    the_bag : BAG OF GENERIC : intype
  ) : SET OF GENERIC : intype;

    LOCAL
      the_set : SET OF GENERIC : intype := [];
      i       : INTEGER;
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);
END_FUNCTION;
  
 END_SCHEMA;
