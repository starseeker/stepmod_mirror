<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-11-18T17:07:44" rcs.revision="1.0" description.file="arm_descriptions.xml">
<application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="interconnect_physical_requirement_allocation_arm schema_instance"/>
<schema name="Interconnect_physical_requirement_allocation_arm">
<interface kind="use" schema="Fabrication_technology_arm"/>
<interface kind="use" schema="Requirement_view_definition_relationship_arm"/>
<interface kind="use" schema="Integral_shield_arm"/>
<type name="thermal_isolation_removal_structure_or_template">
<select extensible="YES" genericentity="YES" selectitems="Thermal_isolation_removal_template"/>
</type>
<entity name="Interconnect_shield_allocation" supertypes="Requirement_assignment">
<explicit name="assigned_to">
<typename name="integral_or_routed_shield"/>
<redeclaration entity-ref="Requirement_assignment"/>
</explicit>
<derived name="assigned_requirement_property" expression="get_requirement_definition_property(SELF,&#10;'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_ARM.'+'ELECTROMAGNETIC_REQUIREMENT_OCCURRENCE')">
<typename name="Requirement_definition_property"/>
</derived>
</entity>
<entity name="Thermal_isolation_removal_template" supertypes="Material_removal_feature_template">
<derived name="thermal_isolation_spacing_requirement" expression="get_rvd(SELF, 'thermal requirement')">
<aggregate type="SET" lower="1" upper="1"/>
<typename name="Requirement_view_definition"/>
</derived>
<where label="WR1" expression="SIZEOF(QUERY(tisr &lt;* THERMAL_ISOLATION_SPACING_REQUIREMENT |&#10;       NOT('INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_ARM.THERMAL_ISOLATION_REQUIREMENT' IN TYPEOF(tisr))&#10;       )) =0"/>
</entity>
<entity name="Thermal_isolation_requirement" supertypes="Requirement_view_definition">
<derived name="effective_current_capacity_requirement" expression="get_specific_requirement_property_for_collector(SELF, 'effective current capacity requirement')">
<aggregate type="SET" lower="1" upper="1"/>
<typename name="Requirement_definition_property"/>
</derived>
<derived name="angular_orientation_requirement" expression="get_specific_requirement_property_for_collector(SELF, 'angular orientation requirement')">
<aggregate type="SET" lower="1" upper="1"/>
<typename name="Requirement_definition_property"/>
</derived>
<derived name="thermal_isolation_spacing_requirement" expression="get_specific_requirement_type_for_primary_rvd_relationship(SELF, 'thermal isolation spacing requirement', 'LAYOUT_SPACING_REQUIREMENT_OCCURRENCE')">
<aggregate type="SET" lower="1" upper="1"/>
<typename name="Requirement_definition_property"/>
</derived>
<where label="WR1" expression="'FABRICATION_TECHNOLOGY_ARM.LAYOUT_SPACING_REQUIREMENT_OCCURRENCE' IN TYPEOF(thermal_isolation_spacing_requirement[1])"/>
<where label="WR2" expression="NOT EXISTS(SELF\Product_view_definition.additional_characterization)"/>
</entity>
<subtype.constraint name="material_removal_feature_template_subtypes" entity="Material_removal_feature_template" super.expression="ONEOF (Electrical_isolation_removal_template, Thermal_isolation_removal_template)"/>
<function name="bag_to_set">
<parameter name="the_bag">
<aggregate type="BAG" lower="0" upper="?"/>
<builtintype type="GENERIC"/>
</parameter>
<aggregate type="SET" lower="0" upper="?"/>
<builtintype type="GENERIC"/>
<algorithm>LOCAL
      the_set : SET OF GENERIC : intype := [];
      i       : INTEGER;
    END_LOCAL;

    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);</algorithm>
</function>
<function name="get_specific_requirement_property_for_collector">
<parameter name="input">
<typename name="Requirement_view_definition"/>
</parameter>
<parameter name="id">
<builtintype type="STRING"/>
</parameter>
<aggregate type="SET" lower="0" upper="?"/>
<typename name="Requirement_definition_property"/>
<algorithm>LOCAL
    rcr : SET[0:?] OF Requirement_collection_relationship := [];--this gives us access to the information base
    rdp : SET[0:?] OF Requirement_definition_property :=[];
END_LOCAL;
    rcr := bag_to_set(QUERY(rai &lt;* USEDIN (input, 'REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP_ARM.'+
	'REQUIREMENT_COLLECTION_RELATIONSHIP.COLLECTION') | 
          (rai\View_definition_relationship.relation_type = id)));

	-- iterate over rcr 
    REPEAT i := 1 to SIZEOF(rcr) by 1;
        -- get rdp 
      rdp := rdp + USEDIN (rcr[i].member, 'REQUIREMENT_DECOMPOSITION_ARM.'+
        'REQUIREMENT_DEFINITION_PROPERTY.ASSOCIATED_DEFINITION');
    END_REPEAT;

	RETURN(rdp);</algorithm>
</function>
<function name="get_specific_requirement_type_for_primary_rvd_relationship">
<parameter name="input">
<typename name="Requirement_view_definition"/>
</parameter>
<parameter name="id">
<builtintype type="STRING"/>
</parameter>
<parameter name="reqType">
<builtintype type="STRING"/>
</parameter>
<aggregate type="SET" lower="0" upper="?"/>
<typename name="Requirement_definition_property"/>
<algorithm>LOCAL
    rvdr : SET[0:?] OF Requirement_view_definition_relationship := [];
    rdp : SET[0:?] OF Requirement_definition_property := [];  --this gives us access to the information base
END_LOCAL;
	rvdr := bag_to_set(QUERY(rvdre &lt;* USEDIN (input, 'REQUIREMENT_DECOMPOSITION_ARM.'+ 'REQUIREMENT_VIEW_DEFINITION_RELATIONSHIP.SECONDARY')|
	                           (rvdre.relation_type = id)
                       ));
	-- iterate over rvdr
	REPEAT i := 1 to SIZEOF(rvdr) by 1;
      rdp := rdp + bag_to_set(QUERY(rdp &lt;* USEDIN (rvdr[i].primary, 'REQUIREMENT_DECOMPOSITION_ARM.'+ 'REQUIREMENT_DEFINITION_PROPERTY.ASSOCIATED_DEFINITION') |
        (reqType IN TYPEOF(rdp))
                             ));
	END_REPEAT;

	RETURN(rdp);</algorithm>
</function>
</schema>
</express>
