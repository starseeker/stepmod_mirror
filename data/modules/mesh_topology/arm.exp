(*
   $Id: arm.exp,v 1.7 2008/10/08 21:45:59 darla Exp $
   ISO TC184/SC4/WG12 N6746 - ISO/CD-TS 10303-1386 Mesh topology - EXPRESS ARM
*)

SCHEMA Mesh_topology_arm;

USE FROM Basic_geometric_topology_arm;

USE FROM Elemental_topology_arm;

USE FROM Finite_elements_arm;

USE FROM Maths_space_arm;

TYPE cell_shape = EXTENSIBLE SELECT 
  (cell_shape_0d,
   cell_shape_1d,
   cell_shape_2d,
   cell_shape_3d);
END_TYPE;

TYPE cell_shape_0d = EXTENSIBLE ENUMERATION OF 
  (single);
END_TYPE;

TYPE cell_shape_1d = EXTENSIBLE ENUMERATION OF 
  (line);
END_TYPE;

TYPE cell_shape_2d = EXTENSIBLE ENUMERATION OF 
  (quadrilateral,
   triangle,
   polygon);
END_TYPE;

TYPE cell_shape_3d = EXTENSIBLE ENUMERATION OF 
  (hexahedron,
   wedge,
   tetrahedron,
   pyramid);
END_TYPE;

TYPE element_order = ENUMERATION OF 
  (linear,
   quadratic,
   cubic);
END_TYPE;

TYPE indices_group = SELECT 
  (Indices_list,
   Indices_range);
END_TYPE;

TYPE mesh_location = EXTENSIBLE ENUMERATION OF 
  (unspecified,
   application_defined,
   vertices,
   cell_center,
   face_center,
   iface_center,
   jface_center,
   kface_center,
   edge_center);
END_TYPE;

TYPE mesh_maths_space_type = EXTENSIBLE ENUMERATION OF 
  (cells,
   vertices);
END_TYPE;

TYPE structured_mesh_type = EXTENSIBLE ENUMERATION OF 
  (rectangular,
   pentahedral,
   pyramidal,
   tetrahedral);
END_TYPE;

ENTITY Array_based_unstructured_mesh
SUBTYPE OF (Unstructured_mesh);
  cells : ARRAY [1 : cell_count] OF Vertex_defined_cell;
WHERE
    wr1: SELF\mesh.index_count = 1;
END_ENTITY;

ENTITY Array_based_unstructured_mesh_and_vertices
SUBTYPE OF (Array_based_unstructured_mesh);
  vertex_count : INTEGER;
  vertices : ARRAY [1 : vertex_count] OF UNIQUE Vertex;
WHERE
    wr1: all_mesh_vertices(SELF);
END_ENTITY;

ENTITY Cell_of_structured_mesh
SUBTYPE OF (Topological_region);
  the_mesh : Structured_mesh;
  cell_identifier : ARRAY [1 : index_count] OF INTEGER;
DERIVE
  index_count : INTEGER := the_mesh\mesh.index_count;
END_ENTITY;

ENTITY Composition_of_structured_mesh;
  part : Structured_mesh;
  whole : Structured_mesh;
  lower_vertex : ARRAY [1 : whole_indices] OF INTEGER;
  lower_face : ARRAY [1 : whole_indices] OF OPTIONAL BOOLEAN;
  used_indices : ARRAY [1 : part_indices] OF INTEGER;
  used_senses : ARRAY [1 : part_indices] OF BOOLEAN;
DERIVE
  part_indices : INTEGER := part\mesh.index_count;
  whole_indices : INTEGER := whole\mesh.index_count;
END_ENTITY;

ENTITY Explicit_unstructured_mesh
SUBTYPE OF (Unstructured_mesh);
  explicit_model : Fea_model;
  cells : ARRAY [1 : cell_count] OF UNIQUE element;
END_ENTITY;

ENTITY Explicitly_defined_cell_patch
SUBTYPE OF (Patch);
  cells : LIST [1 : ?] OF Vertex_defined_cell;
END_ENTITY;

ENTITY Explicitly_defined_vertex_patch
SUBTYPE OF (Patch);
  vertices : LIST [1 : ?] OF Vertex;
END_ENTITY;

ENTITY Indices_list;
  nindices : INTEGER;
  indices : LIST [1 : ?] OF ARRAY [1 : nindices] OF INTEGER;
END_ENTITY;

ENTITY Indices_range;
  nindices : INTEGER;
  start : ARRAY [1 : nindices] OF INTEGER;
  finish : ARRAY [1 : nindices] OF INTEGER;
END_ENTITY;

ENTITY Mesh
SUBTYPE OF (Topological_representation_item);
  description : STRING;
  index_count : INTEGER;
END_ENTITY;

ENTITY Mesh_derived_maths_space
SUBTYPE OF (Maths_space);
  id : STRING;
  name : STRING;
  description : STRING;
  the_mesh : Mesh;
  kind : mesh_maths_space_type;
END_ENTITY;

ENTITY Patch
SUBTYPE OF (Mesh);
END_ENTITY;

ENTITY Product_of_mesh;
  operands : LIST [2 : 2] OF Mesh;
  product : Mesh;
WHERE
    wr1: (this_schema + '.STRUCTURED_MESH' IN TYPEOF(operands[1])) AND (this_schema + '.STRUCTURED_MESH' IN TYPEOF(operands[2])) AND (this_schema + '.STRUCTURED_MESH' IN TYPEOF(product));
    wr2: operands[1].index_count = 1;
    wr3: operands[1].index_count + operands[2].index_count = product.index_count;
END_ENTITY;

ENTITY Property_distribution_description;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;

ENTITY Rind;
  index_count : INTEGER;
  planes : ARRAY [1 : 2 * index_count] OF INTEGER;
END_ENTITY;

ENTITY Structured_mesh
SUBTYPE OF (Mesh);
  vertex_counts : ARRAY [1 : SELF\mesh.index_count] OF INTEGER;
  kind : structured_mesh_type;
END_ENTITY;

ENTITY Structured_mesh_with_rind
SUBTYPE OF (Structured_mesh);
  rind_planes : Rind;
END_ENTITY;

ENTITY Topological_region
SUBTYPE OF (Topological_representation_item);
  description : STRING;
  dimension : INTEGER;
END_ENTITY;

ENTITY Topological_region_with_boundary
SUBTYPE OF (Topological_region);
  boundary : SET [1 : ?] OF Topological_representation_item;
END_ENTITY;

ENTITY Topological_representation_item
SUBTYPE OF (Detailed_topological_model_element);
END_ENTITY;

ENTITY Unstructured_mesh
SUBTYPE OF (Mesh);
  cell_count : INTEGER;
END_ENTITY;

(*
ENTITY Vertex
SUBTYPE OF (Detailed_topological_model_element);
END_ENTITY;
*)
ENTITY Vertex_defined_cell
SUBTYPE OF (Topological_region);
  shape : cell_shape;
  order : element_order;
  vertices : ARRAY [1 : vn_count] OF OPTIONAL Vertex;
DERIVE
  bound_count : INTEGER := cell_counts(SELF)[1];
  edge_node_count : INTEGER := cell_counts(SELF)[2];
  opt_node_count : INTEGER := cell_counts(SELF)[3];
  required_count : INTEGER := bound_count + edge_node_count;
  vn_count : INTEGER := required_count + opt_node_count;
END_ENTITY;


ENTITY Vertex_range_defined_patch
SUBTYPE OF (Patch);
  base_mesh : Structured_mesh;
  range : Indices_range;
END_ENTITY;

SUBTYPE_CONSTRAINT sc1_mesh FOR Mesh;
  ABSTRACT SUPERTYPE;
  ONEOF(patch, structured_mesh, unstructured_mesh);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT sc1_patch FOR Patch;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT sc1_topological_region FOR Topological_region;
  ONEOF(cell_of_structured_mesh, vertex_defined_cell);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT sc1_unstructured_mesh FOR Unstructured_mesh;
  ABSTRACT SUPERTYPE;
  ONEOF(array_based_unstructured_mesh, explicit_unstructured_mesh);
END_SUBTYPE_CONSTRAINT;

  FUNCTION all_mesh_vertices (arg : array_based_unstructured_mesh_and_vertices): BOOLEAN;
    LOCAL
      vertex_set : SET OF Vertex := [];
      cell : vertex_defined_cell;
    END_LOCAL;

    REPEAT i := 1 TO arg.cell_count;
      cell := arg.cells[i];
      REPEAT j := 1 TO cell.vn_count;
        vertex_set := vertex_set + cell.vertices[j];
      END_REPEAT;
    END_REPEAT;
    IF (SIZEOF(vertex_set) <> arg.index_count) THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO arg.index_count;
      IF ( NOT (arg.vertices[i] IN vertex_set)) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION cell_counts (arg : vertex_defined_cell): ARRAY[1:3] OF INTEGER;
    LOCAL
      om1 : INTEGER := 0;
      om1sq : INTEGER := om1 * om1; -- KAH Fix power of two 
      vts : INTEGER; -- (order - 1) squared
      eds : INTEGER; -- number of bounding vertices
      qf : INTEGER := 0; -- number of edges
      tf : INTEGER := 0; -- number of quadrilateral faces
      result : ARRAY[1:3] OF INTEGER := [0, 0, 0]; -- number of triangular faces
    END_LOCAL;

    CASE arg.order OF
      linear:
        om1 := 0;
      quadratic:
        om1 := 1;
      cubic:
        om1 := 2;
      OTHERWISE:
        RETURN (result);
    END_CASE;
    om1sq := om1 * om1;
    CASE arg.shape OF
      single:
        BEGIN
          vts := 1;
          eds := 0;
          qf := 0;
          tf := 0;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := 0;
        END;
      line:
        BEGIN
          vts := 2;
          eds := 1;
          qf := 0;
          tf := 0;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := 0;
        END;
      quadrilateral:
        BEGIN
          vts := 4;
          eds := 4;
          qf := 1;
          tf := 0;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := om1sq * qf;
        END;
      triangle:
        BEGIN
          vts := 3;
          eds := 3;
          qf := 0;
          tf := 1;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := (om1 - 1) * tf;
          CASE arg.order OF
            linear:
              result[3] := 0;
          END_CASE;
        END;
      polygon:
        BEGIN
          result[2] := 0;
          result[3] := 0;
        END;
      hexahedron:
        BEGIN
          vts := 8;
          eds := 12;
          qf := 6;
          tf := 0;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := om1sq * (qf + om1);
        END;
      wedge:
        BEGIN
          vts := 6;
          eds := 9;
          qf := 3;
          tf := 2;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := om1sq * qf + om1 * tf;
        END;
      tetrahedron:
        BEGIN
          vts := 4;
          eds := 6;
          qf := 0;
          tf := 4;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := (om1 - 1) * tf;
          CASE arg.order OF
            linear:
              result[3] := 0;
          END_CASE;
        END;
      pyramid:
        BEGIN
          vts := 5;
          eds := 8;
          qf := 1;
          tf := 4;
          result[1] := vts;
          result[2] := om1 * eds;
          result[3] := om1sq * qf + (om1 - 1) * tf;
          CASE arg.order OF
            linear:
              result[3] := 0;
          END_CASE;
        END;
    END_CASE;
    RETURN (result);
  END_FUNCTION;

  (* 0*)
  FUNCTION this_schema: STRING;
    RETURN ('MESH_TOPOLOGY_SCHEMA');
  END_FUNCTION;



END_SCHEMA;

