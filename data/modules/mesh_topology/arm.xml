<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="arm_descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO/TS 10303-1386">
   <application name="JSDAI" owner="LKSoft" source="mesh_topology_arm schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="Mesh_topology_arm">
      <interface kind="use" schema="Basic_geometric_topology_arm"/>
      <interface kind="use" schema="Elemental_topology_arm"/>
      <interface kind="use" schema="Finite_elements_arm"/>
      <interface kind="use" schema="Maths_space_arm"/>
      <interface kind="use" schema="Support_resource_arm"/>
      <type name="cell_shape">
         <select extensible="YES" selectitems="cell_shape_0d cell_shape_1d cell_shape_2d cell_shape_3d"/>
      </type>
      <type name="cell_shape_0d">
         <enumeration extensible="YES" items="single"/>
      </type>
      <type name="cell_shape_1d">
         <enumeration extensible="YES" items="line"/>
      </type>
      <type name="cell_shape_2d">
         <enumeration extensible="YES" items="quadrilateral triangle"/>
      </type>
      <type name="cell_shape_3d">
         <enumeration extensible="YES" items="hexahedron wedge tetrahedron pyramid"/>
      </type>
      <type name="element_order">
         <enumeration items="linear quadratic cubic"/>
      </type>
      <type name="indices_group">
         <select selectitems="Indices_list Indices_range"/>
      </type>
      <type name="mesh_location">
         <enumeration extensible="YES" items="unspecified application_defined vertices cell_centre face_centre iface_centre jface_centre kface_centre edge_centre"/>
      </type>
      <type name="mesh_maths_space_type">
         <enumeration extensible="YES" items="cells vertices"/>
      </type>
      <type name="structured_mesh_type">
         <enumeration extensible="YES" items="rectangular pentahedral pyramidal tetrahedral"/>
      </type>
      <entity name="Array_based_unstructured_mesh" supertypes="Unstructured_mesh">
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" upper="cell_count"/>
            <typename name="Vertex_defined_cell"/>
         </explicit>
         <where expression="SELF\Mesh.index_count = 1" label="wr1"/>
      </entity>
      <entity name="Array_based_unstructured_mesh_and_vertices" supertypes="Array_based_unstructured_mesh">
         <explicit name="vertex_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" type="ARRAY" unique="YES" upper="vertex_count"/>
            <typename name="Vertex"/>
         </explicit>
         <where expression="all_mesh_vertices(SELF)" label="wr1"/>
      </entity>
      <entity name="Cell" super.expression="ONEOF (Cell_of_structured_mesh, Vertex_defined_cell)" supertypes="Detailed_topological_model_element">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="dimension">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="Cell_of_structured_mesh" supertypes="Cell">
         <explicit name="the_mesh">
            <typename name="Structured_mesh"/>
         </explicit>
         <explicit name="cell_identifier">
            <aggregate lower="1" type="ARRAY" upper="index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="the_mesh\Mesh.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity name="Cell_with_explicit_boundary" supertypes="Cell">
         <explicit name="boundary">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="Detailed_topological_model_element"/>
         </explicit>
      </entity>
      <entity name="Explicit_unstructured_mesh" supertypes="Unstructured_mesh">
         <explicit name="explicit_model">
            <typename name="Fea_model"/>
         </explicit>
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" unique="YES" upper="cell_count"/>
            <typename name="Element"/>
         </explicit>
      </entity>
      <entity name="Extraction_of_structured_submesh" supertypes="Extraction_of_submesh">
         <explicit name="lower_vertex">
            <aggregate lower="1" type="ARRAY" upper="whole_indices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="used_indices">
            <aggregate lower="1" type="ARRAY" upper="part_indices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="used_senses">
            <aggregate lower="1" type="ARRAY" upper="part_indices"/>
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="whole\Mesh.index_count" name="whole_indices">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="part\Mesh.index_count" name="part_indices">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="('MESH_TOPOLOGY_ARM.STRUCTURED_MESH' IN  TYPEOF(&#10;             SELF\Extraction_of_submesh.whole))" label="WR1"/>
         <where expression="('MESH_TOPOLOGY_ARM.STRUCTURED_MESH' IN  TYPEOF(&#10;             SELF\Extraction_of_submesh.part))" label="WR2"/>
      </entity>
      <entity name="Extraction_of_submesh">
         <explicit name="whole">
            <typename name="Mesh"/>
         </explicit>
         <explicit name="part">
            <typename name="Submesh"/>
         </explicit>
      </entity>
      <entity name="Extraction_of_submesh_by_cells" supertypes="Extraction_of_submesh">
         <explicit name="cell_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" upper="cell_count"/>
            <typename name="Cell"/>
         </explicit>
      </entity>
      <entity name="Extraction_of_submesh_by_vertices" supertypes="Extraction_of_submesh">
         <explicit name="vertex_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" type="ARRAY" upper="vertex_count"/>
            <typename name="Vertex"/>
         </explicit>
      </entity>
      <entity name="Indices_list">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="indices">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="Indices_range">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="start">
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="finish">
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="Mesh" super.expression="ONEOF (Structured_mesh, Unstructured_mesh) ANDOR Submesh" supertypes="Detailed_topological_model_element">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="Mesh_derived_maths_space" supertypes="Maths_space">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="the_mesh">
            <typename name="Mesh"/>
         </explicit>
         <explicit name="kind">
            <typename name="mesh_maths_space_type"/>
         </explicit>
      </entity>
      <entity name="Product_of_mesh">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="Mesh"/>
         </explicit>
         <explicit name="product">
            <typename name="Mesh"/>
         </explicit>
         <where expression="('MESH_TOPOLOGY_ARM.STRUCTURED_MESH' IN TYPEOF(operands[1])) AND&#10;        ('MESH_TOPOLOGY_ARM.STRUCTURED_MESH' IN TYPEOF(operands[2])) AND&#10;        ('MESH_TOPOLOGY_ARM.STRUCTURED_MESH' IN TYPEOF(product))" label="wr1"/>
         <where expression="operands[1].index_count = 1" label="wr2"/>
         <where expression="operands[1].index_count + operands[2].index_count&#10;        = product.index_count" label="wr3"/>
      </entity>
      <entity name="Rind">
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="planes">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="Structured_mesh" supertypes="Mesh">
         <explicit name="vertex_counts">
            <aggregate lower="1" type="ARRAY" upper="SELF\mesh.index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="cell_counts">
            <aggregate lower="1" type="ARRAY" upper="SELF\mesh.index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="kind">
            <typename name="structured_mesh_type"/>
         </explicit>
      </entity>
      <entity name="Structured_mesh_with_rind" supertypes="Structured_mesh">
         <explicit name="rind_planes">
            <typename name="Rind"/>
         </explicit>
      </entity>
      <entity name="Submesh" supertypes="Mesh"/>
      <entity abstract.supertype="YES" name="Unstructured_mesh" super.expression="ONEOF (Array_based_unstructured_mesh, Explicit_unstructured_mesh)" supertypes="Mesh">
         <explicit name="cell_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="Vertex_defined_cell" supertypes="Cell">
         <explicit name="shape">
            <typename name="cell_shape"/>
         </explicit>
         <explicit name="order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" optional="YES" type="ARRAY" upper="vn_count"/>
            <typename name="Vertex"/>
         </explicit>
         <derived expression="cell_counts(SELF)[1]" name="bound_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[2]" name="edge_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[3]" name="opt_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="bound_count + edge_node_count" name="required_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="required_count + opt_node_count" name="vn_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="shorten_array(vertices, vn_count, required_count)" name="required_vertices">
            <aggregate lower="1" type="ARRAY" upper="required_count"/>
            <typename name="Vertex"/>
         </derived>
      </entity>
      <function name="all_mesh_vertices">
         <parameter name="arg">
            <typename name="Array_based_unstructured_mesh_and_vertices"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  vertex_set : SET OF Vertex := [];
  cell : Vertex_defined_cell;
END_LOCAL;
  REPEAT i := 1 TO arg.cell_count;
    cell := arg.cells[i];
    REPEAT j := 1 TO cell.vn_count;
      vertex_set := vertex_set + cell.vertices[j];
    END_REPEAT;
  END_REPEAT;
  IF (SIZEOF(vertex_set) &lt;&gt; arg.index_count) THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO arg.index_count;
    IF (NOT (arg.vertices[i] IN vertex_set) ) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);</algorithm>
      </function>
      <function name="cell_counts">
         <parameter name="arg">
            <typename name="Vertex_defined_cell"/>
         </parameter>
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
  om1    : INTEGER := 0;      -- (order - 1)
  om1sq  : INTEGER := om1**2; -- (order - 1) squared
  vts    : INTEGER;           -- number of bounding vertices
  eds    : INTEGER;           -- number of edges
  qf     : INTEGER := 0;      -- number of quadrilateral faces
  tf     : INTEGER := 0;      -- number of triangular faces
  result : ARRAY [1:3] OF INTEGER := [0,0,0];
END_LOCAL;
  CASE arg.order OF
    element_order.linear    : om1 := 0;
    element_order.quadratic : om1 := 1;
    element_order.cubic     : om1 := 2;
    OTHERWISE : RETURN(result);
  END_CASE;
  om1sq := om1**2;
  CASE arg.shape OF
    cell_shape_0d.single : 
        BEGIN
          vts := 1; eds := 0; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 0, 0
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_1d.line :
        BEGIN
          vts := 2; eds := 1; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 1, 2
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_2d.quadrilateral : 
        BEGIN
          vts := 4; eds := 4; qf := 1; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 4, 8
          result[3] := om1sq*qf;                  -- 0, 1, 4
        END;
    cell_shape_2d.triangle : 
        BEGIN
          vts := 3; eds := 3; qf := 0; tf := 1;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 3, 6
          result[3] := (om1-1)*tf;                --    0, 1
          CASE arg.order OF
            element_order.linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3d.hexahedron :
        BEGIN
          vts := 8; eds := 12; qf := 6; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 12, 24
          result[3] := om1sq*(qf+om1);            -- 0, 7, 32
        END;
    cell_shape_3d.wedge :
        BEGIN
          vts := 6; eds := 9; qf := 3; tf := 2;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 9,  18
          result[3] := om1sq*qf + om1*tf;         -- 0, 3, 16
        END;
    cell_shape_3d.tetrahedron : 
        BEGIN
          vts := 4; eds := 6; qf := 0; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 6, 12
          result[3] := (om1-1)*tf;                --    0, 4
          CASE arg.order OF
            element_order.linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3d.pyramid : 
        BEGIN
          vts := 5; eds := 8; qf := 1; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 8, 16
          result[3] := om1sq*qf + (om1-1)*tf;     --    1, 9
          CASE arg.order OF
            element_order.linear : result[3] := 0;              -- 0
          END_CASE;
        END;
  END_CASE;
RETURN(result);</algorithm>
      </function>
      <function name="shorten_array">
         <parameter name="longa">
            <aggregate lower="0" type="ARRAY"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="oldl">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="newl">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     shorta : ARRAY [1:newl] OF GENERIC : T;
   END_LOCAL;

   IF (newl &gt; oldl) THEN
     RETURN(?);
   ELSE
     REPEAT i := 1 TO newl;
       shorta[i] := longa[i];
     END_REPEAT;
     RETURN(shorta);
   END_IF;</algorithm>
      </function>
   </schema>
</express>
