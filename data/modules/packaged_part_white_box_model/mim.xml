<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:55:30" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="packaged_part_white_box_model_mim schema_instance"/>
   <schema name="PACKAGED_PART_WHITE_BOX_MODEL_MIM">
      <interface kind="use" schema="BARE_DIE_MIM"/>
      <interface kind="use" schema="FEATURE_AND_CONNECTION_ZONE_MIM"/>
      <interface kind="use" schema="PACKAGED_PART_BLACK_BOX_MODEL_MIM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_2D_SHAPE_MIM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_3D_SHAPE_MIM"/>
      <entity name="device_terminal_map" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="ur1">
            <unique.attribute entity-ref="device_terminal_map" attribute="related_shape_aspect"/>
            <unique.attribute entity-ref="device_terminal_map" attribute="relating_shape_aspect"/>
         </unique>
         <where label="wr1" expression=" 'packaged_part_white_box_model_mim.' + 'packaged_part_terminal' in typeof ( self . relating_shape_aspect ) "/>
      </entity>
      <rule name="analytical_model_port_assignment_unique_constraint" appliesto="property_definition_representation">
         <where label="WR1" expression=" true "/>
      </rule>
      <rule name="device_terminal_map_relationship_constraint" appliesto="shape_aspect_relationship">
         <where label="wr1" expression=" sizeof ( query ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'device terminal map relationship' ) and ( not ( 'packaged_part_white_box_model_mim.' + 'device_terminal_map' in typeof ( sar . relating_shape_aspect ) ) ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( sar &lt;* shape_aspect_relationship | ( sar \ shape_aspect_relationship . name = 'device terminal map relationship' ) and ( not ( 'packaged_part_white_box_model_mim.' + 'device_terminal_map' in typeof ( sar . related_shape_aspect ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="part_device_terminal_unique_constraint" appliesto="shape_aspect">
         <algorithm> local pdr_bag : bag of product_definition_relationship := [ ] ; sa_bag : bag of shape_aspect ; pd_bag : bag of property_definition ; sa : bag of bare_die_terminal ; pass : boolean := true ; bdt_bag : bag of bare_die_terminal ; end_local ; repeat i := 1 to sizeof ( shape_aspect ) by 1 ; if exists ( shape_aspect [ i ] . of_shape . definition ) then if ( ( 'packaged_part_white_box_model_mim.' + 'product_definition_relationship' in typeof ( shape_aspect [ i ] . of_shape . definition ) ) and ( shape_aspect [ i ] . of_shape . definition . description = 'part device' ) ) then if ( not ( shape_aspect [ i ] . of_shape . definition in pdr_bag ) ) then pdr_bag := pdr_bag + shape_aspect [ i ] . of_shape . definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( pdr_bag ) by 1 ; if ( not pass ) then escape ; end_if ; bdt_bag := [ ] ; sa_bag := query ( sa &lt;* shape_aspect | ( sa . of_shape . definition :=: pdr_bag [ i ] ) ) ; repeat j := 1 to sizeof ( sa_bag ) by 1 ; if ( not pass ) then escape ; end_if ; pd_bag := query ( pd &lt;* usedin ( sa_bag [ j ] . of_shape . definition . related_product_definition , 'packaged_part_white_box_model_mim.' + 'property_definition.definition' ) | ( sizeof ( [ 'packaged_part_white_box_model_mim.' + 'bare_die' ] * typeof ( pd . definition ) ) &gt; 0 ) ) ; repeat k := 1 to sizeof ( pd_bag ) by 1 ; if ( not pass ) then escape ; end_if ; sa := query ( bdt &lt;* usedin ( pd_bag [ k ] , 'packaged_part_white_box_model_mim.' + 'shape_aspect.of_shape' ) | ( 'packaged_part_white_box_model_mim.' + 'bare_die_terminal' in typeof ( bdt ) ) ) ; repeat l := 1 to sizeof ( sa ) by 1 ; if exists ( sa [ l ] ) then if ( sa [ l ] in bdt_bag ) then pass := false ; escape ; else bdt_bag := bdt_bag + sa [ l ] ; end_if ; end_if ; end_repeat ; end_repeat ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="part_device_unique_constraint" appliesto="product_definition_relationship">
         <algorithm> local pd : bag of product_definition_relationship := query ( pdr &lt;* product_definition_relationship | ( pdr \ product_definition_relationship . description = 'part device' ) ) ; pu_bag : bag of physical_unit := [ ] ; pdr_bag : bag of product_definition_relationship ; pass : boolean := true ; name_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( pd ) by 1 ; if exists ( pd [ i ] . relating_product_definition ) then if ( ( pd [ i ] . relating_product_definition . frame_of_reference . name = 'physical design usage' ) and ( sizeof ( [ 'packaged_part_white_box_model_mim.' + 'packaged_part' ] * typeof ( pd [ i ] . relating_product_definition ) ) &gt; 0 ) ) then if ( not ( pd [ i ] . relating_product_definition in pu_bag ) ) then pu_bag := pu_bag + pd [ i ] . relating_product_definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( pu_bag ) by 1 ; if ( not pass ) then escape ; end_if ; name_bag := [ ] ; pdr_bag := query ( pdr &lt;* pd | ( pdr . relating_product_definition :=: pu_bag [ i ] ) ) ; repeat j := 1 to sizeof ( pdr_bag ) by 1 ; if exists ( pdr_bag [ j ] \ product_definition_relationship . name ) then if ( pdr_bag [ j ] \ product_definition_relationship . name in name_bag ) then pass := false ; escape ; else name_bag := name_bag + pdr_bag [ j ] \ product_definition_relationship . name ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
   </schema>
</express>
