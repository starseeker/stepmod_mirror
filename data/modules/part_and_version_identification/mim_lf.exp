(* This file was generated by exppp (an EXPRESS Pretty Printer)
written at the National Institute of Standards and Technology
by Don Libes, February 19, 1993.

WARNING: If you modify this file and want to save the changes,
delete this comment block or else the file will be rewritten
the next time exppp processes this schema. *)

SCHEMA part_and_version_identification_mim;

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE approval_item = SELECT
    (approval);
  END_TYPE; -- approval_item

  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE; -- attribute_type

  TYPE date_and_time_item = SELECT
    (date_assignment);
  END_TYPE; -- date_and_time_item

  TYPE date_item = SELECT
    (date_assignment);
  END_TYPE; -- date_item

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select);
  END_TYPE; -- date_time_or_event_occurrence

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE; -- day_in_month_number

  TYPE description_attribute_select = SELECT
    (application_context,
     approval_role,
     date_role,
     date_time_role,
     organization_role,
     person_and_organization_role,
     person_and_organization);
  END_TYPE; -- description_attribute_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE id_attribute_select = SELECT
    (application_context);
  END_TYPE; -- id_attribute_select

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE name_attribute_select = SELECT
    (person_and_organization);
  END_TYPE; -- name_attribute_select

  TYPE organization_item = SELECT
    (applied_organization_assignment);
  END_TYPE; -- organization_item

  TYPE part_and_version_identification_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- part_and_version_identification_organization_item

  TYPE part_and_version_identification_person_and_organization_item =
              SELECT
    (product_definition_formation);
  END_TYPE; -- part_and_version_identification_person_and_organization_item

  TYPE person_and_organization_item = SELECT
    (applied_person_and_organization_assignment);
  END_TYPE; -- person_and_organization_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE product_categorisation_organization_item = SELECT
    (organization_item);
  END_TYPE; -- product_categorisation_organization_item

  TYPE product_categorisation_person_and_organization_item = SELECT
    (person_and_organization_item);
  END_TYPE; -- product_categorisation_person_and_organization_item

  TYPE product_organization_item = SELECT
    (organization_item);
  END_TYPE; -- product_organization_item

  TYPE product_person_and_organization_item = SELECT
    (person_and_organization_item);
  END_TYPE; -- product_person_and_organization_item

  TYPE product_version_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_organization_item

  TYPE product_version_person_and_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_person_and_organization_item

  TYPE product_version_security_classification_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_security_classification_item

  TYPE role_select = SELECT
    (approval_assignment,
     approval_date_time,
     security_classification_assignment);
  END_TYPE; -- role_select

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE; -- second_in_minute

  TYPE security_classification_approval_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_approval_item

  TYPE security_classification_date_and_time_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_date_and_time_item

  TYPE security_classification_date_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_date_item

  TYPE security_classification_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_item

  TYPE security_classification_organization_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_organization_item

  TYPE security_classification_person_and_organization_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_person_and_organization_item

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (product_context);
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_item;
  END_ENTITY; -- applied_date_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_item;
  END_ENTITY; -- applied_security_classification_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset <= 12));
      wr2: ((0 <= minute_offset) AND (minute_offset <= 59));
      wr3: (NOT ((hour_offset <> 0) AND (sense = exact)));
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY date
    SUPERTYPE OF (calendar_date);
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_role

  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_time_role

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY; -- description_attribute

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY; -- id_attribute

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY; -- name_attribute

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- object_role

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY; -- organizational_address

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY; -- personal_address

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY; -- role_association

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  RULE product_requires_product_category FOR (product, 
                product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* 
             product_related_product_category | ((prod IN prpc.products) 
             AND (prpc.name IN ['part','document'])) )) = 1)) )) = 0);

  END_RULE; -- product_requires_product_category

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): BOOLEAN;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,
        'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
                         'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_description_value

  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,
                'PART_AND_VERSION_IDENTIFICATION_MIM.' + 'ID_ATTRIBUTE.' + 
                'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_id_value

  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
                  'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_name_value

  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
                  'PART_AND_VERSION_IDENTIFICATION_MIM.' + 
                  'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_role

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;
    RETURN(FALSE);

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

END_SCHEMA; -- part_and_version_identification_mim
