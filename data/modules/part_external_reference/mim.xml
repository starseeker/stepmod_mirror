<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-04-18T16:34:29" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="part_external_reference_mim schema_instance"/>
   <schema name="Part_external_reference_mim">
      <interface kind="use" schema="Physical_layout_template_mim"/>
      <rule name="package_external_reference_constraint" appliesto="representation">
         <where label="WR1" expression=" SIZEOF ( QUERY ( rep &lt;* representation | ( rep \ representation . name = 'package external reference' ) AND ( SIZEOF ( QUERY ( dri &lt;* rep . items | NOT ( ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( dri ) ) AND ( dri \ representation_item . name = 'design owner' ) ) ) ) = 1 ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( rep &lt;* representation | ( rep \ representation . name = 'package external reference' ) AND ( SIZEOF ( QUERY ( dri &lt;* rep . items | NOT ( ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( dri ) ) AND ( dri \ representation_item . name = 'part number' ) ) ) ) = 1 ) ) ) = 0 "/>
         <where label="WR3" expression=" SIZEOF ( QUERY ( rep &lt;* representation | ( rep \ representation . name = 'package external reference' ) AND ( SIZEOF ( QUERY ( dri &lt;* rep . items | NOT ( ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( dri ) ) AND ( dri \ representation_item . name = 'revision code' ) ) ) ) = 1 ) ) ) = 0 "/>
         <where label="WR4" expression=" SIZEOF ( QUERY ( rep &lt;* representation | ( rep \ representation . name = 'package external reference' ) AND ( SIZEOF ( QUERY ( dri &lt;* rep . items | NOT ( ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( dri ) ) AND ( dri \ representation_item . name = 'product definition id' ) ) ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="package_terminal_external_reference_constraint" appliesto="descriptive_representation_item">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dri &lt;* descriptive_representation_item | ( dri \ representation_item . name = 'package terminal external reference' ) AND ( SIZEOF ( QUERY ( rep &lt;* USEDIN ( dri , 'PART_EXTERNAL_REFERENCE_MIM.' + 'REPRESENTATION.ITEMS' ) | ( rep \ representation . name = 'package external reference' ) ) ) = 0 ) ) ) = 0 "/>
      </rule>
      <rule name="package_terminal_external_reference_unique_constraint" appliesto="descriptive_representation_item">
         <algorithm> LOCAL pter : BAG OF descriptive_representation_item := QUERY ( dri &lt;* descriptive_representation_item | ( dri \ representation_item . name = 'package terminal external reference' ) ) ; desc_bag : BAG OF STRING := [ ] ; dri_bag : BAG OF descriptive_representation_item ; rep_bag : BAG OF representation ; pass : BOOLEAN := TRUE ; r_bag : BAG OF representation ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( pter ) by 1 ; IF EXISTS ( pter [ i ] \ descriptive_representation_item . description ) THEN IF ( NOT ( pter [ i ] \ descriptive_representation_item . description IN desc_bag ) ) THEN desc_bag := desc_bag + pter [ i ] \ descriptive_representation_item . description ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( desc_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; r_bag := [ ] ; dri_bag := QUERY ( dri &lt;* pter | ( dri \ descriptive_representation_item . description = desc_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( dri_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; rep_bag := QUERY ( r &lt;* USEDIN ( dri_bag [ j ] , 'PART_EXTERNAL_REFERENCE_MIM.' + 'REPRESENTATION.ITEMS' ) | ( r \ representation . name = 'package external reference' ) ) ; REPEAT k := 1 to SIZEOF ( rep_bag ) by 1 ; IF EXISTS ( rep_bag [ k ] ) THEN IF ( rep_bag [ k ] IN r_bag ) THEN pass := FALSE ; ESCAPE ; ELSE r_bag := r_bag + rep_bag [ k ] ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="part_terminal_external_reference_unique_constraint" appliesto="representation">
         <algorithm> LOCAL pter : BAG OF representation := QUERY ( r &lt;* representation | ( r \ representation . name = 'part terminal external reference' ) ) ; fn_bag : BAG OF STRING := [ ] ; ft_bag : BAG OF STRING := [ ] ; r_bag : BAG OF representation ; pdr_bag : BAG OF property_definition_representation ; pass : BOOLEAN := TRUE ; ptd_bag : BAG OF part_template_definition ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( pter ) by 1 ; REPEAT j := 1 to SIZEOF ( pter [ i ] . items ) by 1 ; IF ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( pter [ i ] . items [ j ] ) ) THEN IF ( ( pter [ i ] . items [ j ] \ representation_item . name = 'feature name' ) AND ( NOT ( pter [ i ] . items [ j ] \ descriptive_representation_item . description IN fn_bag ) ) ) THEN fn_bag := fn_bag + pter [ i ] . items [ j ] \ descriptive_representation_item . description ; END_IF ; IF ( ( pter [ i ] . items [ j ] \ representation_item . name = 'feature type' ) AND ( NOT ( pter [ i ] . items [ j ] \ descriptive_representation_item . description IN ft_bag ) ) ) THEN ft_bag := ft_bag + pter [ i ] . items [ j ] \ descriptive_representation_item . description ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( fn_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; REPEAT j := 1 to SIZEOF ( ft_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; r_bag := QUERY ( r &lt;* pter | ( ( SIZEOF ( QUERY ( ri &lt;* r . items | ( ( ri \ descriptive_representation_item . description = ft_bag [ j ] ) AND ( ri \ representation_item . name = 'feature type' ) ) ) ) &gt; 0 ) AND ( SIZEOF ( QUERY ( ri &lt;* r . items | ( ( ri \ descriptive_representation_item . description = fn_bag [ i ] ) AND ( ri \ representation_item . name = 'feature name' ) ) ) ) &gt; 0 ) ) ) ; ptd_bag := [ ] ; REPEAT k := 1 to SIZEOF ( r_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdr_bag := USEDIN ( r_bag [ k ] , 'PART_EXTERNAL_REFERENCE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION' ) ; REPEAT l := 1 to SIZEOF ( pdr_bag ) by 1 ; IF EXISTS ( pdr_bag [ l ] . definition . definition ) THEN IF ( 'PART_EXTERNAL_REFERENCE_MIM.' + 'PHYSICAL_UNIT' IN TYPEOF ( pdr_bag [ l ] . definition . definition ) ) THEN IF ( pdr_bag [ l ] . definition . definition IN ptd_bag ) THEN pass := FALSE ; ESCAPE ; ELSE ptd_bag := ptd_bag + pdr_bag [ l ] . definition . definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
   </schema>
</express>
