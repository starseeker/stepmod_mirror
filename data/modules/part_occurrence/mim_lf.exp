(* This file was generated by exppp (an EXPRESS Pretty Printer)
written at the National Institute of Standards and Technology
by Don Libes, February 19, 1993.

WARNING: If you modify this file and want to save the changes,
delete this comment block or else the file will be rewritten
the next time exppp processes this schema. *)

SCHEMA part_occurrence_mim;

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE alias_identification_item = SELECT
    (applied_identification_assignment);
  END_TYPE; -- alias_identification_item

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE approval_item = SELECT
    (approval);
  END_TYPE; -- approval_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE; -- attribute_type

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE characterized_definition = SELECT
    (characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE date_and_time_item = SELECT
    (date_assignment);
  END_TYPE; -- date_and_time_item

  TYPE date_item = SELECT
    (date_assignment);
  END_TYPE; -- date_item

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select);
  END_TYPE; -- date_time_or_event_occurrence

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE; -- day_in_month_number

  TYPE derived_property_select = SELECT
    (property_definition);
  END_TYPE; -- derived_property_select

  TYPE description_attribute_select = SELECT
    (application_context,
     approval_role,
     date_role,
     date_time_role,
     context_dependent_shape_representation,
     organization_role,
     person_and_organization_role,
     person_and_organization,
     property_definition_representation,
     representation);
  END_TYPE; -- description_attribute_select

  TYPE descriptive_measure = STRING;
  END_TYPE; -- descriptive_measure

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE founded_item_select = SELECT
    (representation_item);
  END_TYPE; -- founded_item_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE id_attribute_select = SELECT
    (application_context,
     representation);
  END_TYPE; -- id_attribute_select

  TYPE identification_item = SELECT
    (applied_identification_assignment);
  END_TYPE; -- identification_item

  TYPE identification_organization_item = SELECT
    (organization_item);
  END_TYPE; -- identification_organization_item

  TYPE identification_person_and_organization_item = SELECT
    (person_and_organization_item);
  END_TYPE; -- identification_person_and_organization_item

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     amount_of_substance_measure,
     area_measure,
     volume_measure,
     numeric_measure,
     context_dependent_measure,
     descriptive_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE name_attribute_select = SELECT
    (context_dependent_shape_representation,
     person_and_organization,
     product_definition,
     property_definition_representation);
  END_TYPE; -- name_attribute_select

  TYPE numeric_measure = NUMBER;
  END_TYPE; -- numeric_measure

  TYPE organization_item = SELECT
    (applied_organization_assignment);
  END_TYPE; -- organization_item

  TYPE part_and_version_identification_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- part_and_version_identification_organization_item

  TYPE part_and_version_identification_person_and_organization_item =
              SELECT
    (product_definition_formation);
  END_TYPE; -- part_and_version_identification_person_and_organization_item

  TYPE person_and_organization_item = SELECT
    (applied_person_and_organization_assignment);
  END_TYPE; -- person_and_organization_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE product_categorisation_organization_item = SELECT
    (organization_item);
  END_TYPE; -- product_categorisation_organization_item

  TYPE product_categorisation_person_and_organization_item = SELECT
    (person_and_organization_item);
  END_TYPE; -- product_categorisation_person_and_organization_item

  TYPE product_definition_approval_item = SELECT
    (product_definition);
  END_TYPE; -- product_definition_approval_item

  TYPE product_definition_date_and_time_item = SELECT
    (product_definition);
  END_TYPE; -- product_definition_date_and_time_item

  TYPE product_definition_date_item = SELECT
    (product_definition);
  END_TYPE; -- product_definition_date_item

  TYPE product_definition_organization_item = SELECT
    (product_definition);
  END_TYPE; -- product_definition_organization_item

  TYPE product_definition_person_and_organization_item = SELECT
    (product_definition);
  END_TYPE; -- product_definition_person_and_organization_item

  TYPE product_definition_usage_security_classification_item = SELECT
    (product_definition_usage);
  END_TYPE; -- product_definition_usage_security_classification_item

  TYPE product_organization_item = SELECT
    (organization_item);
  END_TYPE; -- product_organization_item

  TYPE product_person_and_organization_item = SELECT
    (person_and_organization_item);
  END_TYPE; -- product_person_and_organization_item

  TYPE product_version_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_organization_item

  TYPE product_version_person_and_organization_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_person_and_organization_item

  TYPE product_version_security_classification_item = SELECT
    (product_definition_formation);
  END_TYPE; -- product_version_security_classification_item

  TYPE representation_identification_item = SELECT
    (representation);
  END_TYPE; -- representation_identification_item

  TYPE represented_definition = SELECT
    (property_definition,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- represented_definition

  TYPE role_select = SELECT
    (approval_assignment,
     approval_date_time,
     security_classification_assignment);
  END_TYPE; -- role_select

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE; -- second_in_minute

  TYPE security_classification_approval_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_approval_item

  TYPE security_classification_date_and_time_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_date_and_time_item

  TYPE security_classification_date_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_date_item

  TYPE security_classification_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_item

  TYPE security_classification_organization_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_organization_item

  TYPE security_classification_person_and_organization_item = SELECT
    (security_classification);
  END_TYPE; -- security_classification_person_and_organization_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_NAME=ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE trimming_select = SELECT
    (cartesian_point);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- amount_of_substance_measure_with_unit

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 1) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- amount_of_substance_unit

  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF date_item;
  END_ENTITY; -- applied_date_assignment

  ENTITY applied_identification_assignment
    SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY; -- applied_identification_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_security_classification_assignment
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF security_classification_item;
  END_ENTITY; -- applied_security_classification_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.AREA_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- area_measure_with_unit

  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- area_unit

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
        specified_higher_usage_occurrence,promissory_usage_occurrence))
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : OPTIONAL text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY; -- assembly_component_usage_substitute

  ENTITY assembly_component_usage_substitute_with_ranking
    SUBTYPE OF (assembly_component_usage_substitute);
      ranking           : INTEGER;
      ranking_rationale : text;
  END_ENTITY; -- assembly_component_usage_substitute_with_ranking

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),representation_item('') || 
             geometric_representation_item() || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
        cartesian_transformation_operator_3d))
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: (SELF\cartesian_transformation_operator.dim = 2);
  END_ENTITY; -- cartesian_transformation_operator_2d

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\cartesian_transformation_operator.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.PRODUCT_DEFINITION_RELATIONSHIP' IN 
               TYPEOF(SELF.represented_product_relation.definition));
      wr2: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr3: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- context_dependent_shape_representation

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset <= 12));
      wr2: ((0 <= minute_offset) AND (minute_offset <= 59));
      wr3: (NOT ((hour_offset <> 0) AND (sense = exact)));
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY date
    SUPERTYPE OF (calendar_date);
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_role

  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_time_role

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY; -- description_attribute

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT ('PART_OCCURRENCE_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY; -- id_attribute

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role        : identification_role;
  END_ENTITY; -- identification_assignment

  ENTITY identification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- identification_role

  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY make_from_usage_option
    SUBTYPE OF (product_definition_usage);
      ranking           : INTEGER;
      ranking_rationale : text;
      quantity          : measure_with_unit;
    WHERE
      wr1: ((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (
               quantity.value_component > 0));
  END_ENTITY; -- make_from_usage_option

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.MASS_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        amount_of_substance_measure_with_unit,area_measure_with_unit,
        volume_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY; -- name_attribute

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        amount_of_substance_unit,area_unit,volume_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- next_assembly_usage_occurrence

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- object_role

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY; -- organizational_address

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY point
    SUPERTYPE OF (cartesian_point)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_context_association;
      definition         : product_definition;
      frame_of_reference : product_definition_context;
      role               : product_definition_context_role;
  END_ENTITY; -- product_definition_context_association

  ENTITY product_definition_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_definition_context_role

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_relationship;
      id                                    : identifier;
      name                                  : label;
      description                           : OPTIONAL text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation  : product_definition_formation;
  END_ENTITY; -- product_definition_formation_relationship

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (SIZEOF(['PART_OCCURRENCE_MIM.CHARACTERIZED_PRODUCT_DEFINITION',
               'PART_OCCURRENCE_MIM.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\
               property_definition.definition)) > 0);
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_usage
    SUPERTYPE OF (ONEOF (make_from_usage_option,assembly_component_usage))
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],
               'PART_OCCURRENCE_MIM.PRODUCT_DEFINITION_USAGE');
  END_ENTITY; -- product_definition_usage

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY product_relationship;
      id               : identifier;
      name             : label;
      description      : OPTIONAL text;
      relating_product : product;
      related_product  : product;
  END_ENTITY; -- product_relationship

  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- promissory_usage_occurrence

  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- property_definition_representation

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
    WHERE
      wr1: ((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (
               quantity.value_component > 0));
  END_ENTITY; -- quantified_assembly_component_usage

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id          : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY; -- role_association

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'PART_OCCURRENCE_MIM.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('PART_OCCURRENCE_MIM.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF
               .definition)) OR ('PART_OCCURRENCE_MIM.SHAPE_DEFINITION' IN 
               TYPEOF(SELF.definition.definition)));
      wr2: ('PART_OCCURRENCE_MIM.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
               used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\
               representation_relationship.rep_1) + TYPEOF(SELF\
               representation_relationship.rep_2)));
  END_ENTITY; -- shape_representation_relationship

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(name);
  END_ENTITY; -- si_unit

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: ((upper_usage.related_product_definition :=: next_usage.
               relating_product_definition) OR (SIZEOF(QUERY ( pdr <* 
               USEDIN(upper_usage.related_product_definition,
               'PART_OCCURRENCE_MIM.PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr.
               relating_product_definition :=: next_usage.
               relating_product_definition) )) = 1));
      wr5: (SIZEOF(['PART_OCCURRENCE_MIM.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
               'PART_OCCURRENCE_MIM.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] * 
               TYPEOF(upper_usage)) = 1);
  END_ENTITY; -- specified_higher_usage_occurrence

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('PART_OCCURRENCE_MIM.VOLUME_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- volume_measure_with_unit

  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- volume_unit

  RULE compatible_dimension FOR (cartesian_point, direction, 
               representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE; -- compatible_dimension

  RULE product_requires_product_category FOR (product, 
             product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* 
             product_related_product_category | ((prod IN prpc.products) 
             AND (prpc.name IN ['part','document'])) )) = 1)) )) = 0);

  END_RULE; -- product_requires_product_category

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('PART_OCCURRENCE_MIM.MAPPED_ITEM' IN
         TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'PART_OCCURRENCE_MIM.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): BOOLEAN;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'PART_OCCURRENCE_MIM.' + 
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING
      ): BOOLEAN;

    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,'PART_OCCURRENCE_MIM.' + 
        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives + 
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      vec    : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      u[3] := NVL(normalise(axis3),representation_item('') || 
          geometric_representation_item() || direction([0,0,1]));
      u[1] := first_proj_axis(u[3],axis1);
      u[2] := second_proj_axis(u[3],u[1],axis2);
    ELSE
      u[3] := ?;
      IF EXISTS(axis1) THEN
        u[1] := normalise(axis1);
        u[2] := orthogonal_complement(u[1]);
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          u[2] := normalise(axis2);
          u[1] := orthogonal_complement(u[2]);
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u[1].name := '';
          u[2].name := '';
          u[1].direction_ratios[1] := 1;
          u[1].direction_ratios[2] := 0;
          u[2].direction_ratios[1] := 0;
          u[2].direction_ratios[2] := 1;
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      u : LIST [2:2] OF direction;
    END_LOCAL;
    u[1] := NVL(normalise(ref_direction),representation_item('') || 
        geometric_representation_item() || direction([1,0]));
    u[2] := orthogonal_complement(u[1]);
    RETURN(u);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      u : LIST [3:3] OF direction;
    END_LOCAL;
    u[3] := NVL(normalise(axis),representation_item('') || 
        geometric_representation_item() || direction([0,0,1]));
    u[1] := first_proj_axis(u[3],ref_direction);
    u[2] := normalise(cross_product(u[3],u[1])).orientation;
    RETURN(u);

  END_FUNCTION; -- build_axes

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res.name := '';
        res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
        res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
        res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.orientation := res;
          result.magnitude := SQRT(mag);
        ELSE
          result.orientation := arg1;
          result.magnitude := 0;
        END_IF;
        result.name := '';
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'PART_OCCURRENCE_MIM.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      OTHERWISE     :         RETURN(?);
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := representation_item('') || geometric_representation_item() 
              || direction([1,0,0]);
        ELSE
          v := representation_item('') || geometric_representation_item() 
              || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'PART_OCCURRENCE_MIM.' + 'DESCRIPTION_ATTRIBUTE.' 
                         + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_description_value

  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,'PART_OCCURRENCE_MIM.' + 
                'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_id_value

  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'PART_OCCURRENCE_MIM.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_name_value

  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
                  'PART_OCCURRENCE_MIM.' + 'ROLE_ASSOCIATION.' + 
                  'ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_role

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'PART_OCCURRENCE_MIM.REPRESENTATION.ITEMS') * 
        cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'PART_OCCURRENCE_MIM.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      RETURN(?);
    ELSE
      ndim := arg.dim;
      IF 'PART_OCCURRENCE_MIM.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          vec := arg;
          v := arg.orientation;
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec.magnitude := 1;
          END_IF;
        END;
      ELSE
        v := arg;
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'PART_OCCURRENCE_MIM.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result.name := '';
      result.direction_ratios[1] := -vec.direction_ratios[2];
      result.direction_ratios[2] := vec.direction_ratios[1];
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'PART_OCCURRENCE_MIM.VECTOR' IN TYPEOF(vec) THEN
        v := vec.orientation;
        mag := scalar * vec.magnitude;
      ELSE
        v := vec;
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result.name := '';
      result.orientation := normalise(v);
      result.magnitude := mag;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := representation_item('') || geometric_representation_item() || 
          direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'PART_OCCURRENCE_MIM.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'PART_OCCURRENCE_MIM.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,'PART_OCCURRENCE_MIM.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'PART_OCCURRENCE_MIM.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;
    RETURN(FALSE);

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'PART_OCCURRENCE_MIM.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m
        .value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'PART_OCCURRENCE_MIM.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'PART_OCCURRENCE_MIM.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'PART_OCCURRENCE_MIM.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.magnitude := SQRT(mag);
          result.orientation := res;
        ELSE
          result.magnitude := 0;
          result.orientation := vec1;
        END_IF;
      END;
    END_IF;
    result.name := '';
    RETURN(result);

  END_FUNCTION; -- vector_difference

END_SCHEMA; -- part_occurrence_mim
