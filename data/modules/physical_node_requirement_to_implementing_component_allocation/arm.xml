<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:27:10" rcs.revision="1.0" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="physical_node_requirement_to_implementing_component_allocation_arm schema_instance"/>
   <schema name="PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION_ARM">
      <interface kind="use" schema="ASSEMBLY_MODULE_WITH_PACKAGED_CONNECTOR_COMPONENT_ARM"/>
      <interface kind="use" schema="ASSEMBLY_TECHNOLOGY_ARM"/>
      <interface kind="use" schema="COMPONENT_FEATURE_ARM"/>
      <interface kind="use" schema="FUNCTIONAL_ASSIGNMENT_TO_PART_ARM"/>
      <interface kind="use" schema="INTERFACE_COMPONENT_ARM"/>
      <interface kind="use" schema="PACKAGED_CONNECTOR_MODEL_ARM"/>
      <interface kind="use" schema="PHYSICAL_CONNECTIVITY_DEFINITION_ARM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_DESIGN_VIEW_ARM"/>
      <entity name="physical_node_requirement_to_implementing_component_allocation">
         <explicit name="physical_node_requirement">
            <typename name="physical_connectivity_definition"/>
         </explicit>
         <explicit name="implementation_component">
            <typename name="assembly_component"/>
         </explicit>
         <explicit name="implementation_interface_joint_set" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="interface_mounted_join"/>
         </explicit>
         <explicit name="implementation_joint_set" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="assembly_joint"/>
         </explicit>
         <derived name="implementation_connection_definition_1" expression=" get_pctd ( implementation_component , implementation_joint_set ) ">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="part_connected_terminals_definition"/>
         </derived>
         <derived name="implementation_connection_definition_2" expression=" get_pctr ( implementation_component , implementation_interface_joint_set ) ">
            <aggregate type="SET" lower="0" upper="1"/>
            <typename name="packaged_connector_terminal_relationship"/>
         </derived>
         <where label="wr1" expression=" exists ( implementation_interface_joint_set ) xor exists ( implementation_joint_set ) "/>
         <where label="wr2" expression=" ( sizeof ( implementation_connection_definition_1 ) + sizeof ( implementation_connection_definition_2 ) = 1 ) or ( ( 'physical_node_requirement_to_implementing_component_allocation_arm.interface_component' in typeof ( implementation_component ) ) and ( 'physical_node_requirement_to_implementing_component_allocation_arm.physical_component_interface_terminal' in typeof ( get_cit ( implementation_component , implementation_joint_set ) ) ) ) or ( 'physical_node_requirement_to_implementing_component_allocation_arm.routed_interconnect_component' in typeof ( implementation_component ) ) "/>
         <where label="wr3" expression=" sizeof ( query ( pct &lt;* physical_node_requirement . associated_terminals | pct \ component_feature . associated_component = implementation_component ) ) = 0 "/>
      </entity>
      <function name="get_cit">
         <parameter name="ac">
            <typename name="assembly_component"/>
         </parameter>
         <parameter name="ajb">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="assembly_joint"/>
         </parameter>
         <typename name="physical_component_interface_terminal"/>
         <algorithm> local cf : list [ 1 : ? ] of component_feature := [ ] ; cit : physical_component_interface_terminal ; end_local ; repeat i := 1 to 2 by 1 ; cf [ 1 ] := ajb [ 1 ] . assembly_features_1 ; cf [ 2 ] := ajb [ 1 ] . assembly_features_2 ; if ac :=: cf [ i ] . associated_component then if ( 'physical_node_requirement_to_implementing_component_allocation_arm.interface_component' in typeof ( cf [ i ] . associated_component ) ) then return ( cf [ i ] ) ; else return ( ? ) ; end_if ; else return ( ? ) ; end_if ; end_repeat ; return ( ? ) ; </algorithm>
      </function>
      <function name="get_pctd">
         <parameter name="ac">
            <typename name="assembly_component"/>
         </parameter>
         <parameter name="ajb">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="assembly_joint"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="part_connected_terminals_definition"/>
         <algorithm> local cf : list [ 1 : ? ] of component_feature ; pctd : set of part_connected_terminals_definition := [ ] ; end_local ; repeat i := 1 to 2 by 1 ; cf [ 1 ] := ajb [ 1 ] . assembly_features_1 ; cf [ 2 ] := ajb [ 1 ] . assembly_features_2 ; if ac :=: cf [ i ] . associated_component then if ( 'physical_node_requirement_to_implementing_component_allocation_arm.part_terminal' in typeof ( cf [ i ] . definition ) ) then pctd := cf [ i ] . definition . connection_requirement ; return ( pctd ) ; else return ( pctd ) ; end_if ; else return ( pctd ) ; end_if ; end_repeat ; return ( ? ) ; </algorithm>
      </function>
      <function name="get_pctr">
         <parameter name="ac">
            <typename name="assembly_component"/>
         </parameter>
         <parameter name="imjb">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="interface_mounted_join"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="packaged_connector_terminal_relationship"/>
         <algorithm> local cf : component_feature ; pctr : set of packaged_connector_terminal_relationship := [ ] ; end_local ; cf := imjb [ 1 ] . connection_to_interconnect_module_component ; if ac :=: cf . associated_component then if ( 'physical_node_requirement_to_implementing_component_allocation_arm.packaged_part_interface_terminal' in typeof ( cf . definition ) ) then pctr := cf . definition . external_connector_function ; return ( pctr ) ; else return ( pctr ) ; end_if ; else return ( pctr ) ; end_if ; return ( ? ) ; </algorithm>
      </function>
   </schema>
</express>
