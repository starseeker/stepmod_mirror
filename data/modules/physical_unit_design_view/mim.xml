<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:55:31" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="physical_unit_design_view_mim schema_instance"/>
   <schema name="PHYSICAL_UNIT_DESIGN_VIEW_MIM">
      <interface kind="use" schema="FEATURE_AND_CONNECTION_ZONE_MIM"/>
      <interface kind="use" schema="ITEM_DEFINITION_STRUCTURE_MIM"/>
      <interface kind="use" schema="PART_OCCURRENCE_MIM"/>
      <interface kind="use" schema="PART_VIEW_DEFINITION_MIM"/>
      <interface kind="use" schema="PHYSICAL_UNIT_USAGE_VIEW_MIM"/>
      <interface kind="use" schema="APPLICATION_CONTEXT_SCHEMA">
         <interfaced.item name="application_context_element"/>
      </interface>
      <type name="pudv_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="assembly_component_usage descriptive_representation_item"/>
      </type>
      <entity name="assembly_component" supertypes="component_definition product_definition_shape"/>
      <entity name="component_definition" supertypes="product_definition">
         <where label="wr1" expression=" sizeof ( query ( pd &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'property_definition.definition' ) | not ( sizeof ( query ( sr_pdr &lt;* query ( pdr &lt;* usedin ( pd , 'physical_unit_design_view_mim.' + 'property_definition_representation.definition' ) | 'physical_unit_design_view_mim.' + 'shape_representation' in typeof ( pdr . used_representation ) ) | sr_pdr . used_representation \ representation . name = 'planar projected shape' ) ) &lt;= 1 ) ) ) = 0 "/>
         <where label="wr2" expression=" sizeof ( query ( pd &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'property_definition.definition' ) | not ( sizeof ( query ( sr_pdr &lt;* query ( pdr &lt;* usedin ( pd , 'physical_unit_design_view_mim.' + 'property_definition_representation.definition' ) | 'physical_unit_design_view_mim.' + 'shape_representation' in typeof ( pdr . used_representation ) ) | sr_pdr . used_representation \ representation . name = '3d bound volume shape' ) ) &lt;= 1 ) ) ) = 0 "/>
         <where label="wr3" expression=" ( not ( self \ product_definition . description = 'bare die component' ) ) or ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'instantiated part' ) | ( sizeof ( [ 'physical_unit_design_view_mim.' + 'bare_die' , 'physical_unit_design_view_mim.' + 'externally_defined_bare_die' , 'physical_unit_design_view_mim.' + 'library_defined_bare_die' ] * typeof ( ip . relating_product_definition ) ) = 1 ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design usage' ) ) ) = 1 ) "/>
         <where label="wr4" expression=" not ( is_assembly_module_occurrence ( self ) ) or ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'instantiated part' ) | ( 'physical_unit_design_view_mim.' + 'physical_unit' in typeof ( ip . relating_product_definition ) ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design usage' ) and ( ip . relating_product_definition \ product_definition . name = 'assembly module' ) ) ) = 1 ) "/>
         <where label="wr5" expression=" not ( is_assembly_module_occurrence ( self ) ) or ( sizeof ( query ( pd &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'property_definition.definition' ) | sizeof ( query ( sa &lt;* usedin ( pd , 'physical_unit_design_view_mim.' + 'shape_aspect.of_shape' ) | ( 'physical_unit_design_view_mim.' + 'component_terminal' in typeof ( sa ) ) and ( sa \ shape_aspect . description = 'assembly module component terminal' ) ) ) &gt;= 2 ) ) &gt;= 1 ) "/>
         <where label="wr6" expression=" not ( is_interconnect_module_occurrence ( self ) ) or ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'instantiated part' ) | ( 'physical_unit_design_view_mim.' + 'physical_unit' in typeof ( ip . relating_product_definition ) ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design usage' ) and ( self \ product_definition . name = 'interconnect module' ) ) ) = 1 ) "/>
         <where label="wr8" expression=" ( not ( self \ product_definition . description = 'mating connector' ) ) or ( sizeof ( query ( pd &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'property_definition.definition' ) | sizeof ( query ( pdr &lt;* usedin ( pd , 'physical_unit_design_view_mim.' + 'property_definition_representation.definition' ) | pdr . used_representation \ representation . name = 'mating connector placement' ) ) = 1 ) ) = 1 ) "/>
         <where label="wr9" expression=" ( not ( self \ product_definition . description = 'mating connector' ) ) or ( ( sizeof ( query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.relating_product_definition' ) | 'physical_unit_design_view_mim.' + 'next_assembly_usage_occurrence' in typeof ( pdr ) ) ) = 0 ) and ( sizeof ( query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | 'physical_unit_design_view_mim.' + 'next_assembly_usage_occurrence' in typeof ( pdr ) ) ) = 0 ) ) "/>
         <where label="wr10" expression=" sizeof ( query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | not ( not ( pdr \ product_definition_relationship . name = 'instantiated part' ) or ( self . formation :=: pdr . relating_product_definition . formation ) ) ) ) = 0 "/>
         <where label="wr11" expression=" sizeof ( query ( pd &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'property_definition.definition' ) | not ( sizeof ( query ( sr_pdr &lt;* query ( pdr &lt;* usedin ( pd , 'physical_unit_design_view_mim.' + 'property_definition_representation.definition' ) | 'physical_unit_design_view_mim.' + 'shape_representation' in typeof ( pdr . used_representation ) ) | ( sr_pdr . used_representation \ representation . name = 'part template non planar 2d shape' ) or ( sr_pdr . used_representation \ representation . name = 'non planar 2d shape' ) or ( sr_pdr . used_representation \ representation . name = 'open shell based surface' ) ) ) &lt;= 1 ) ) ) = 0 "/>
         <where label="wr13" expression=" not ( is_assembly_module_macro_occurrence ( self ) ) or ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'design definition' ) | ( 'physical_unit_design_view_mim.' + 'physical_unit' in typeof ( ip . relating_product_definition ) ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design' ) and ( ip . relating_product_definition \ product_definition . name = 'assembly module' ) ) ) = 1 ) "/>
         <where label="wr14" expression=" not ( is_interconnect_module_macro_occurrence ( self ) ) or ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'design definition' ) | ( 'physical_unit_design_view_mim.' + 'physical_unit' in typeof ( ip . relating_product_definition ) ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design' ) and ( ip . relating_product_definition \ product_definition . name = 'interconnect module' ) ) ) = 1 ) "/>
         <where label="wr15" expression=" sizeof ( query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | ( ( pdr \ product_definition_relationship . name = 'instantiated definition' ) and ( not ( self . formation :=: pdr . relating_product_definition . formation ) ) ) ) ) = 0 "/>
         <where label="wr16" expression=" ( not ( self \ product_definition . description = 'routed interconnect component' ) ) or ( ( sizeof ( query ( ip &lt;* query ( pdr &lt;* usedin ( self , 'physical_unit_design_view_mim.' + 'product_definition_relationship.related_product_definition' ) | pdr \ product_definition_relationship . name = 'instantiated part' ) | ( sizeof ( [ 'physical_unit_design_view_mim.' + 'physical_unit' ] * typeof ( ip . relating_product_definition ) ) = 1 ) and ( ip . relating_product_definition . frame_of_reference . name = 'physical design usage' ) ) ) = 1 ) and ( self . frame_of_reference . name = 'physical occurrence' ) ) "/>
      </entity>
      <entity name="thermal_component" supertypes="assembly_component"/>
      <rule name="assembly_composition_relationship_unique_constraint" appliesto="assembly_component_usage">
         <algorithm> local acr : bag of assembly_component_usage := query ( acu &lt;* assembly_component_usage | ( acu \ product_definition_relationship . name = 'assembly composition' ) ) ; pu_bag : bag of physical_unit := [ ] ; acu_bag : bag of assembly_component_usage ; pass : boolean := true ; cd_bag : bag of component_definition ; end_local ; repeat i := 1 to sizeof ( acr ) by 1 ; if exists ( acr [ i ] . relating_product_definition ) then if ( ( acr [ i ] . relating_product_definition . frame_of_reference . name = 'physical design' ) and ( 'physical_unit_usage_view_mim.' + 'physical_unit' in typeof ( acr [ i ] . relating_product_definition ) ) ) then if ( not ( acr [ i ] . relating_product_definition in pu_bag ) ) then pu_bag := pu_bag + acr [ i ] . relating_product_definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( pu_bag ) by 1 ; if ( not pass ) then escape ; end_if ; cd_bag := [ ] ; acu_bag := query ( acu &lt;* acr | ( acu . relating_product_definition :=: pu_bag [ i ] ) ) ; repeat j := 1 to sizeof ( acu_bag ) by 1 ; if exists ( acu_bag [ j ] . related_product_definition ) then if ( 'physical_unit_design_view_mim.' + 'component_definition' in typeof ( acu_bag [ j ] . related_product_definition ) ) then if ( acu_bag [ j ] . related_product_definition in cd_bag ) then pass := false ; escape ; else cd_bag := cd_bag + acu_bag [ j ] . related_product_definition ; end_if ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <rule name="next_higher_assembly_relationship_unique_constraint" appliesto="next_assembly_usage_occurrence">
         <algorithm> local pu_bag : bag of physical_unit := [ ] ; nauo_bag : bag of next_assembly_usage_occurrence ; pass : boolean := true ; refdes_bag : bag of string ; end_local ; repeat i := 1 to sizeof ( next_assembly_usage_occurrence ) by 1 ; if exists ( next_assembly_usage_occurrence [ i ] . relating_product_definition ) then if ( ( next_assembly_usage_occurrence [ i ] . relating_product_definition . frame_of_reference . name = 'physical design' ) and ( 'physical_unit_design_view_mim.' + 'physical_unit' in typeof ( next_assembly_usage_occurrence [ i ] . relating_product_definition ) ) ) then if ( not ( next_assembly_usage_occurrence [ i ] . relating_product_definition in pu_bag ) ) then pu_bag := pu_bag + next_assembly_usage_occurrence [ i ] . relating_product_definition ; end_if ; end_if ; end_if ; end_repeat ; repeat i := 1 to sizeof ( pu_bag ) by 1 ; if ( not pass ) then escape ; end_if ; refdes_bag := [ ] ; nauo_bag := query ( nauo &lt;* next_assembly_usage_occurrence | ( nauo . relating_product_definition :=: pu_bag [ i ] ) ) ; repeat j := 1 to sizeof ( nauo_bag ) by 1 ; if exists ( nauo_bag [ j ] . reference_designator ) then if ( nauo_bag [ j ] . reference_designator in refdes_bag ) then pass := false ; escape ; else refdes_bag := refdes_bag + nauo_bag [ j ] . reference_designator ; end_if ; end_if ; end_repeat ; end_repeat ; </algorithm>
         <where label="wr1" expression=" pass "/>
      </rule>
      <function name="is_assembly_module_macro_occurrence">
         <parameter name="pd">
            <typename name="product_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm> local pass : boolean := false ; end_local ; if not ( exists ( pd \ product_definition . name ) ) then return ( false ) ; end_if ; if ( ( pd \ product_definition . name = 'assembly module' ) and ( pd . frame_of_reference \ application_context_element . name = 'macro occurrence' ) ) then return ( true ) ; end_if ; return ( pass ) ; </algorithm>
      </function>
      <function name="is_assembly_module_occurrence">
         <parameter name="pd">
            <typename name="product_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm> local pass : boolean := false ; end_local ; if not ( exists ( pd \ product_definition . name ) ) then return ( false ) ; end_if ; if ( ( pd \ product_definition . name = 'assembly module' ) and ( pd . frame_of_reference \ application_context_element . name = 'physical occurrence' ) ) then return ( true ) ; end_if ; return ( pass ) ; </algorithm>
      </function>
      <function name="is_interconnect_module_macro_occurrence">
         <parameter name="pd">
            <typename name="product_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm> local pass : boolean := false ; end_local ; if not ( exists ( pd \ product_definition . name ) ) then return ( false ) ; end_if ; if ( ( pd \ product_definition . name = 'interconnect module' ) and ( pd . frame_of_reference \ application_context_element . name = 'macro occurrence' ) ) then return ( true ) ; end_if ; return ( pass ) ; </algorithm>
      </function>
      <function name="is_interconnect_module_occurrence">
         <parameter name="pd">
            <typename name="product_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm> local pass : boolean := false ; end_local ; if not ( exists ( pd \ product_definition . name ) ) then return ( false ) ; end_if ; if ( ( pd \ product_definition . name = 'interconnect module' ) and ( pd . frame_of_reference \ application_context_element . name = 'physical occurrence' ) ) then return ( true ) ; end_if ; return ( pass ) ; </algorithm>
      </function>
   </schema>
</express>
