(*
$Id: arm.exp,v 1.11 2005/04/13 17:18:41 thendrix Exp $
ISO TC184/SC4/WG3 N1881 - ISO/TS 10303-1231 Product data management - EXPRESS MIM Long form
Supersedes ISO TC184/SC4/WG3 N1488
*) 

SCHEMA Product_data_management_mim_lf;


CONSTANT

  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();

END_CONSTANT;

TYPE action_items = SELECT (
   configuration_effectivity,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;


TYPE action_request_item = SELECT (
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   property_definition);
END_TYPE;


TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE;

(* Pruned unused type: aliasable_item  *)


TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE approval_item = SELECT (
   action,
   applied_action_assignment,
   certification,
   configuration_effectivity,
   contract,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   versioned_action_request);
END_TYPE;


TYPE area_measure = REAL;
END_TYPE;

TYPE attribute_language_item = SELECT (
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   attribute_value_assignment,
   certification,
   certification_type,
   contract,
   date_role,
   date_time_role,
   document_relationship,
   document_usage_role,
   external_source,
   identification_role,
   multi_language_attribute_assignment,
   object_role,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;


TYPE attribute_type = SELECT
   (label, 
    text);
END_TYPE;

(* Pruned unused type: axis2_placement  *)


TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE certification_item = SELECT (
   product_definition_formation_relationship);
END_TYPE;


TYPE characterized_action_definition = SELECT (
   action,
   action_method,
   action_relationship);
END_TYPE;


TYPE characterized_definition = SELECT
   (characterized_object, 
    characterized_product_definition, 
    shape_definition);
END_TYPE;

TYPE characterized_product_definition = SELECT
   (product_definition, 
    product_definition_relationship);
END_TYPE;

TYPE classification_item = SELECT (
   action,
   action_directive,
   action_method,
   action_property,
   action_relationship,
   action_request_solution,
   action_request_status,
   address,
   alternate_product_relationship,
   applied_action_assignment,
   applied_action_request_assignment,
   applied_approval_assignment,
   applied_certification_assignment,
   applied_contract_assignment,
   applied_date_and_time_assignment,
   applied_date_assignment,
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_effectivity_assignment,
   applied_event_occurrence_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   applied_organization_assignment,
   applied_organizational_project_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval,
   approval_person_organization,
   approval_relationship,
   approval_status,
   assembly_component_usage_substitute,
   calendar_date,
   certification,
   class,
   configuration_item,
   context_dependent_unit,
   contract,
   conversion_based_unit,
   date_and_time,
   date_and_time_assignment,
   date_assignment,
   derived_unit,
   descriptive_representation_item,
   directed_action,
   document_file,
   document_relationship,
   effectivity,
   event_occurrence,
   executed_action,
   general_property,
   general_property_relationship,
   group,
   identification_assignment,
   language,
   measure_representation_item,
   measure_with_unit,
   multi_language_attribute_assignment,
   named_unit,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization_address,
   product,
   product_category,
   product_concept,
   product_definition,
   product_definition_context,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_context,
   representation_item,
   security_classification,
   uncertainty_measure_with_unit,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: complete_membership_select  *)


TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE contract_item = SELECT (
   product_definition_formation);
END_TYPE;


TYPE count_measure = NUMBER;
END_TYPE;

TYPE date_and_time_item = SELECT (
   action,
   applied_action_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval_person_organization,
   certification,
   contract,
   document_file,
   event_occurrence,
   executed_action,
   organizational_project,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   security_classification,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: date_and_time_item_approval  *)


TYPE date_item = SELECT (
   action,
   applied_action_assignment,
   applied_organization_assignment,
   applied_person_and_organization_assignment,
   applied_security_classification_assignment,
   approval_person_organization,
   certification,
   contract,
   document_file,
   event_occurrence,
   organizational_project,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   security_classification,
   versioned_action_request);
END_TYPE;


(* Pruned unused type: date_item_approval  *)


TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE derived_property_select = SELECT (
   action_property,
   property_definition);
END_TYPE;


TYPE description_attribute_select = SELECT (
   action_request_solution,
   application_context,
   approval_role,
   configuration_design,
   context_dependent_shape_representation,
   date_role,
   date_time_role,
   effectivity,
   external_source,
   organization_role,
   person_and_organization,
   person_and_organization_role,
   property_definition_representation,
   representation);
END_TYPE;


TYPE descriptive_measure = STRING;
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

(* Pruned unused type: dm_aliasable_item  *)


(* Pruned unused type: dm_approval_item  *)


(* Pruned unused type: dm_attribute_language_item  *)


(* Pruned unused type: dm_contract_item  *)


(* Pruned unused type: dm_date_and_time_item  *)


(* Pruned unused type: dm_date_item  *)


(* Pruned unused type: dm_identification_item  *)


(* Pruned unused type: dm_multi_language_attribute_item  *)


(* Pruned unused type: dm_organization_item  *)


(* Pruned unused type: dm_person_and_organization_item  *)


(* Pruned unused type: dm_security_classification_item  *)


(* Pruned unused type: document_location_select  *)


TYPE document_reference_item = SELECT (
   action_method,
   executed_action,
   product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   shape_aspect,
   shape_aspect_relationship,
   versioned_action_request);
END_TYPE;


TYPE effectivity_item = SELECT (
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;


TYPE electric_current_measure = REAL;
END_TYPE;

(* Pruned unused type: event_occurrence_date_and_time_item  *)


(* Pruned unused type: event_occurrence_date_item  *)


TYPE event_occurrence_item = SELECT (
   organizational_project);
END_TYPE;


(* Pruned unused type: external_class_name_item  *)


TYPE external_identification_item = SELECT (
   document_file,
   product_definition);
END_TYPE;


(* Pruned unused type: file_identification_item  *)


(* Pruned unused type: file_location_select  *)


(* Pruned unused type: file_version_item  *)


TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

(* Pruned unused type: geometric_set_select  *)


TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE;

TYPE id_attribute_select = SELECT
   (action, 
    address, 
    application_context, 
    group, 
    organizational_project, 
    product_category, 
    property_definition, 
    representation, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE;

TYPE identification_item = SELECT (
   approval_status,
   contract,
   document_file,
   organization,
   product,
   product_definition,
   product_definition_formation,
   security_classification_level,
   shape_aspect_relationship,
   shape_representation);
END_TYPE;


TYPE identifier = STRING;
END_TYPE;

(* Pruned unused type: idrm_marked_item  *)


TYPE label = STRING;
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE;

(* Pruned unused type: mri_aliasable_item  *)


(* Pruned unused type: mri_approval_item  *)


(* Pruned unused type: mri_attribute_language_item  *)


(* Pruned unused type: mri_date_and_time_item  *)


(* Pruned unused type: mri_date_item  *)


(* Pruned unused type: mri_identification_item  *)


(* Pruned unused type: mri_multi_language_attribute_item  *)


(* Pruned unused type: mri_organization_item  *)


(* Pruned unused type: mri_person_and_organization_item  *)


TYPE multi_language_attribute_item = SELECT (
   applied_document_reference,
   applied_document_usage_constraint_assignment,
   applied_external_identification_assignment,
   applied_organizational_project_assignment,
   approval,
   approval_relationship,
   approval_status,
   certification,
   certification_type,
   contract,
   date_role,
   date_time_role,
   document_relationship,
   document_usage_role,
   external_source,
   identification_role,
   object_role,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   organizational_project_role,
   person_and_organization,
   product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship);
END_TYPE;


TYPE name_attribute_select = SELECT (
   action_request_solution,
   address,
   configuration_design,
   context_dependent_shape_representation,
   derived_unit,
   effectivity,
   person_and_organization,
   product_definition,
   property_definition_representation);
END_TYPE;


TYPE name_item = SELECT (
   assembly_component_usage,
   external_class_library);
END_TYPE;


TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE organization_item = SELECT (
   action,
   applied_action_assignment,
   applied_identification_assignment,
   applied_security_classification_assignment,
   approval,
   configuration_item,
   contract,
   document_file,
   executed_action,
   product,
   product_definition,
   product_definition_formation,
   security_classification,
   versioned_action_request);
END_TYPE;


TYPE parameter_value = REAL;
END_TYPE;

(* Pruned unused type: pdm_action_items  *)


(* Pruned unused type: pdm_action_request_item  *)


(* Pruned unused type: pdm_approval_item  *)


(* Pruned unused type: pdm_attribute_language_item  *)


(* Pruned unused type: pdm_certification_item  *)


(* Pruned unused type: pdm_classification_item  *)


(* Pruned unused type: pdm_date_and_time_item  *)


(* Pruned unused type: pdm_date_item  *)


(* Pruned unused type: pdm_document_reference_item  *)


(* Pruned unused type: pdm_effectivity_item  *)


(* Pruned unused type: pdm_event_occurrence_item  *)


(* Pruned unused type: pdm_external_class_name_item  *)


(* Pruned unused type: pdm_identification_item  *)


(* Pruned unused type: pdm_multi_language_attribute_item  *)


(* Pruned unused type: pdm_organization_item  *)


(* Pruned unused type: pdm_person_and_organization_item  *)


(* Pruned unused type: pdm_project_item  *)


(* Pruned unused type: pdm_security_classification_item  *)


(* Pruned unused type: pdm_time_interval_item  *)


TYPE person_and_organization_item = SELECT (
   action,
   applied_action_assignment,
   applied_identification_assignment,
   applied_security_classification_assignment,
   approval,
   configuration_item,
   contract,
   document_file,
   executed_action,
   product,
   product_definition,
   product_definition_formation,
   security_classification,
   versioned_action_request);
END_TYPE;


TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE;

TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE product_or_formation_or_definition = SELECT
   (product, 
    product_definition_formation, 
    product_definition);
END_TYPE;

(* Pruned unused type: project_as_date_and_time_item  *)


(* Pruned unused type: project_as_date_item  *)


TYPE project_item = SELECT (
   executed_action,
   product_concept);
END_TYPE;


TYPE ratio_measure = REAL;
END_TYPE;

(* Pruned unused type: representation_identification_item  *)


(* Pruned unused type: representation_version_item  *)


TYPE represented_definition = SELECT (
   general_property,
   property_definition,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;


TYPE role_select = SELECT (
   action_assignment,
   action_request_assignment,
   approval_assignment,
   approval_date_time,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE;


TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE;

TYPE security_classification_item = SELECT (
   assembly_component_usage,
   document_file,
   product,
   product_definition,
   product_definition_formation);
END_TYPE;


TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE shape_definition = SELECT
   (product_definition_shape, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE;

TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE;

TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE source = ENUMERATION OF 
   (made,
    bought,
    not_known);
END_TYPE;

TYPE source_item = SELECT (
   identifier);
END_TYPE;


(* Pruned unused type: spr_document_reference_item  *)


(* Pruned unused type: spr_organization_item  *)


(* Pruned unused type: spr_person_and_organization_item  *)


(* Pruned unused type: supported_item  *)


TYPE text = STRING;
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_interval_item = SELECT (
   action);
END_TYPE;


TYPE time_measure = REAL;
END_TYPE;

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

(* Pruned unused type: trimming_select  *)


TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE;

TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

(* Pruned unused type: versionable_item  *)


TYPE volume_measure = REAL;
END_TYPE;

TYPE year_number = INTEGER;
END_TYPE;

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY action_assignment
   ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET[1:?] OF versioned_action_request;
END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_request_assignment
   ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (
              PRODUCT_CONCEPT_CONTEXT,
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;

ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;

ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET[1:?] OF approval_item;
END_ENTITY;

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;

ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;

ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;

ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;

ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET[0:?] OF time_interval_item;
END_ENTITY;

ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;

ENTITY approval_assignment
   ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (
              NEXT_ASSEMBLY_USAGE_OCCURRENCE,
              SPECIFIED_HIGHER_USAGE_OCCURRENCE,
              PROMISSORY_USAGE_OCCURRENCE))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY attribute_classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;

ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY;

ENTITY attribute_value_assignment
   ABSTRACT SUPERTYPE;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

 ENTITY cartesian_point
   
  SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

 ENTITY cartesian_transformation_operator
   SUPERTYPE OF (ONEOF (
              CARTESIAN_TRANSFORMATION_OPERATOR_2D,
              CARTESIAN_TRANSFORMATION_OPERATOR_3D))
  SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
 DERIVE
   u : LIST[2:2] OF direction := 
       base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;

ENTITY certification_assignment
   ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;

ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_class : group;
  role : classification_role;
END_ENTITY;

ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' +

                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_USAGE' IN

        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;

ENTITY contract_assignment
   ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  ;
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_and_time_assignment
   ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;

ENTITY date_assignment
   ABSTRACT SUPERTYPE;
  assigned_date : date;
  role : date_role;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;

ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  WR3: NOT('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));

END_ENTITY;

ENTITY document_reference
   ABSTRACT SUPERTYPE;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;

ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_usage_constraint_assignment
   ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF (
              SERIAL_NUMBERED_EFFECTIVITY,
              DATED_EFFECTIVITY,
              LOT_EFFECTIVITY,
              TIME_INTERVAL_BASED_EFFECTIVITY));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY effectivity_assignment
   ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
   ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

ENTITY external_identification_assignment
   ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;

  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('PRODUCT_DATA_MANAGEMENT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN

      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY identification_assignment
   ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY language 
SUBTYPE OF (group); 
WHERE
WR1: SELF\group.name <> '';
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |

 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY;

ENTITY name_assignment
   ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;

END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY organizational_project_assignment
   ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;

ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value (SELF);
  description : text := get_description_value(SELF);
  
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;

END_ENTITY;

ENTITY person_and_organization_assignment
   ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

 ENTITY placement
   SUPERTYPE OF (ONEOF (
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY point
   
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;

END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;

ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;

ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_DATA_MANAGEMENT_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_DATA_MANAGEMENT_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;

END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (
              MAKE_FROM_USAGE_OPTION,
              ASSEMBLY_COMPONENT_USAGE))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_USAGE');

END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRECISION_QUALIFIER'

             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' +

                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_assignment
   ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;

ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
  WR2: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);

END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));

END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_DATA_MANAGEMENT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_DATA_MANAGEMENT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']

       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

ENTITY standard_uncertainty
  
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_assignment
   ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY uncertainty_qualifier
  ;
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ( 'PRODUCT_DATA_MANAGEMENT_MIM_LF.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );

  WR2: value_range_wr2 ( item_element );
  WR3: value_range_wr3 ( item_element );
END_ENTITY;

ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('PRODUCT_DATA_MANAGEMENT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'

       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;

 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;

ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);

END_FUNCTION;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));

    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);

END_FUNCTION;

FUNCTION acyclic_product_definition_relationship
 (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));

    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);

END_FUNCTION;

FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);

END_FUNCTION;

FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                 LIST [2:3] OF 
direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);

END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);

 END_FUNCTION;

 FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);

 END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;

END_FUNCTION;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN

    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);

END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(item) THEN

       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);


END_FUNCTION;

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;

END_FUNCTION;

 FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);

 END_FUNCTION;

FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);

END_FUNCTION;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));

  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));

END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;

END_FUNCTION;

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));

  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));

  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);

END_FUNCTION;

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;

END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN

         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);

 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;

 END_FUNCTION;

 FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                      : vector;
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF (vec) THEN

       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag < 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);

 END_FUNCTION;

 FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);

 END_FUNCTION;

FUNCTION type_check_function
 (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;

END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('PRODUCT_DATA_MANAGEMENT_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));

  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);

END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);

END_FUNCTION;

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);

END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;

END_FUNCTION;

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;

END_FUNCTION;

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 

  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);

END_FUNCTION;

FUNCTION value_range_wr1
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
'PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 <* agg | (
'PRODUCT_DATA_MANAGEMENT_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF

(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;

      END_FUNCTION;

FUNCTION value_range_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY (i <* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i <* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;

      END_FUNCTION;

FUNCTION value_range_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY(i1 <* agg |
('PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 <* agg |
('PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND

(i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;

      END_FUNCTION;

 FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN

         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);

 END_FUNCTION;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'PRODUCT_DATA_MANAGEMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 

		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

RULE subtype_exclusiveness_representation_item FOR 
(representation_item);
WHERE
  WR1: SIZEOF(QUERY (cri <* representation_item | NOT (type_check_function(cri,['PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM','PRODUCT_DATA_MANAGEMENT_MIM_LF.VALUE_REPRESENTATION_ITEM','PRODUCT_DATA_MANAGEMENT_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;

END_RULE;

(*** 2003=>1994 conversion: insert a rule to control if instances are legal according to USE/REF clauses ***)

RULE validate_dependently_instantiable_entity_data_types FOR
      (application_context,application_context_element,attribute_value_role,cartesian_transformation_operator,classification_role,contract_type,document_type,document_usage_constraint,event_occurrence_role,local_time,placement,point,product_context,product_definition_context_role,product_definition_effectivity,representation_map,vector --<list this first and all subsequent relevant referencedentity data types here>
      );
LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := application_context + application_context_element + attribute_value_role + cartesian_transformation_operator + classification_role + contract_type + document_type + document_usage_constraint + event_occurrence_role + local_time + placement + point + product_context + product_definition_context_role + product_definition_effectivity + representation_map + vector;--<make a union of all implicit populations of the FOR-clause>
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;

WHERE
  WR1: dependently_instantiated(all_instances, set_of_input_types,
                                previous_in_chain);
END_RULE;

FUNCTION dependently_instantiated(
            set_of_input_instances : SET OF GENERIC:igen;
            set_of_input_types     : SET OF STRING;
            previous_in_chain      : LIST OF GENERIC:cgen): BOOLEAN;
(*'dependently_instantiated' To test whether all instances in the
  input set_of_input_instances are referenced by independently
  instantiable instances. If so, this function returns true.
  Set_of_input_types includes the type strings for all input instances.
  The instances in previous_in_chain are used to detect cyclic
  references during recursive calls to this function. The parameter
  lists already tested instances in a chain of references.
*)
LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types <= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all => invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);
END_FUNCTION; -- end dependently_instantiated



END_SCHEMA;

