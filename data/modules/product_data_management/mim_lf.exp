(*
   $Id: mim_lf.exp,v 1.1 2004/05/18 15:40:44 mikeward Exp $
   N - ISO/CD-TS - 10303- product_data_management - EXPRESS MIM_LF*)
(* UNDER DEVELOPMENT *)
SCHEMA Product_data_management_mim_lf;
(* Original schemas: 
  schema = action_schema ;
  schema = activity_method_mim ;
  schema = activity_mim ;
  schema = alias_identification_mim ;
  schema = application_context_schema ;
  schema = approval_mim ;
  schema = approval_schema ;
  schema = assembly_structure_mim ;
  schema = basic_attribute_schema ;
  schema = certification_mim ;
  schema = certification_schema ;
  schema = class_mim ;
  schema = classification_assignment_mim ;
  schema = classification_mim ;
  schema = classification_schema ;
  schema = configuration_effectivity_mim ;
  schema = configuration_item_mim ;
  schema = configuration_management_schema ;
  schema = contextual_shape_positioning_mim ;
  schema = contract_mim ;
  schema = contract_schema ;
  schema = date_time_assignment_mim ;
  schema = date_time_mim ;
  schema = date_time_schema ;
  schema = document_and_version_identification_mim ;
  schema = document_assignment_mim ;
  schema = document_definition_mim ;
  schema = document_management_mim ;
  schema = document_properties_mim ;
  schema = document_schema ;
  schema = document_structure_mim ;
  schema = effectivity_application_mim ;
  schema = effectivity_mim ;
  schema = effectivity_schema ;
  schema = elemental_geometric_shape_mim ;
  schema = event_assignment_mim ;
  schema = event_mim ;
  schema = experience_schema ;
  schema = extended_measure_representation_mim ;
  schema = external_class_mim ;
  schema = external_item_identification_assignment_mim ;
  schema = external_model_mim ;
  schema = external_reference_schema ;
  schema = file_identification_mim ;
  schema = foundation_representation_mim ;
  schema = geometric_model_schema ;
  schema = geometry_schema ;
  schema = group_schema ;
  schema = identification_assignment_mim ;
  schema = incomplete_data_reference_mechanism_mim ;
  schema = independent_property_mim ;
  schema = independent_property_representation_mim ;
  schema = location_schema ;
  schema = management_resource_information_mim ;
  schema = management_resources_schema ;
  schema = material_property_definition_schema ;
  schema = material_property_representation_schema ;
  schema = measure_representation_mim ;
  schema = measure_schema ;
  schema = multi_linguism_mim ;
  schema = name_assignment_mim ;
  schema = part_and_version_identification_mim ;
  schema = part_definition_relationship_mim ;
  schema = part_view_definition_mim ;
  schema = person_organization_assignment_mim ;
  schema = person_organization_mim ;
  schema = person_organization_schema ;
  schema = process_property_assignment_mim ;
  schema = process_property_representation_schema ;
  schema = process_property_schema ;
  schema = product_categorization_mim ;
  schema = product_concept_identification_mim ;
  schema = product_concept_schema ;
  schema = product_data_management_mim ;
  schema = product_definition_schema ;
  schema = product_identification_mim ;
  schema = product_property_definition_schema ;
  schema = product_property_representation_schema ;
  schema = product_replacement_mim ;
  schema = product_structure_mim ;
  schema = product_structure_schema ;
  schema = product_version_mim ;
  schema = product_version_relationship_mim ;
  schema = product_view_definition_mim ;
  schema = product_view_definition_properties_mim ;
  schema = product_view_definition_relationship_mim ;
  schema = project_mim ;
  schema = property_assignment_mim ;
  schema = qualifications_schema ;
  schema = qualified_measure_schema ;
  schema = representation_schema ;
  schema = security_classification_mim ;
  schema = security_classification_schema ;
  schema = shape_property_assignment_mim ;
  schema = single_part_representation_mim ;
  schema = support_resource_schema ;
  schema = time_interval_mim ;
  schema = topology_schema ;
  schema = value_with_unit_mim ;
  schema = work_order_mim ;
  schema = work_request_mim ;
*)
 
CONSTANT
  dummy_gri : geometric_representation_item := representation_item('')||
  geometric_representation_item();
END_CONSTANT;
 
TYPE action_items = SELECT 
  (configuration_effectivity, product_definition, product_definition_formation
  , product_definition_relationship);
END_TYPE;
 
TYPE action_request_item = SELECT 
  (product_definition, product_definition_formation, 
  product_definition_relationship, property_definition);
END_TYPE;
 
TYPE ahead_or_behind = ENUMERATION OF 
  (ahead, exact, behind);
END_TYPE;
 
TYPE amount_of_substance_measure = REAL;
END_TYPE;
 
TYPE approval_item = SELECT 
  (certification, contract, product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE area_measure = REAL;
END_TYPE;
 
TYPE attribute_language_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, 
  applied_organizational_project_assignment, approval, approval_relationship, 
  approval_status, certification, certification_type, contract, date_role, 
  date_time_role, document_relationship, document_usage_role, external_source, 
  identification_role, multi_language_attribute_assignment, object_role, 
  organization_relationship, organizational_project, 
  organizational_project_relationship, organizational_project_role, 
  person_and_organization, product, product_category, product_definition, 
  product_definition_formation, product_definition_relationship);
END_TYPE;
 
TYPE attribute_type = SELECT 
  (label, text);
END_TYPE;
 
TYPE celsius_temperature_measure = REAL;
END_TYPE;
 
TYPE certification_item = SELECT 
  (product_definition_formation_relationship);
END_TYPE;
 
TYPE characterized_action_definition = SELECT 
  (action, action_method, action_relationship);
END_TYPE;
 
TYPE characterized_definition = SELECT 
  (characterized_object, characterized_product_definition, shape_definition);
END_TYPE;
 
TYPE characterized_product_definition = SELECT 
  (product_definition, product_definition_relationship);
END_TYPE;
 
TYPE classification_item = SELECT 
  (document_file, product_definition);
END_TYPE;
 
TYPE classification_select = SELECT 
  (product);
END_TYPE;
 
TYPE complete_membership_select = SELECT 
  (product);
END_TYPE;
 
TYPE compound_item_definition = SELECT 
  (list_representation_item);
END_TYPE;
 
TYPE configuration_design_item = SELECT 
  (product_definition, product_definition_formation);
END_TYPE;
 
TYPE context_dependent_measure = REAL;
END_TYPE;
 
TYPE contract_item = SELECT 
  (product_definition_formation);
END_TYPE;
 
TYPE count_measure = NUMBER;
END_TYPE;
 
TYPE date_and_time_item = SELECT 
  (applied_organization_assignment, applied_person_and_organization_assignment
  , applied_security_classification_assignment, approval_person_organization, 
  certification, contract, document_file, event_occurrence, 
  organizational_project, product_definition, product_definition_formation, 
  product_definition_relationship, security_classification);
END_TYPE;
 
TYPE date_item = SELECT 
  (applied_organization_assignment, applied_person_and_organization_assignment
  , applied_security_classification_assignment, approval_person_organization, 
  certification, contract, document_file, event_occurrence, 
  organizational_project, product_definition, product_definition_formation, 
  product_definition_relationship, security_classification);
END_TYPE;
 
TYPE date_time_or_event_occurrence = SELECT 
  (date_time_select, event_occurrence);
END_TYPE;
 
TYPE date_time_select = SELECT 
  (date, date_and_time, local_time);
END_TYPE;
 
TYPE day_in_month_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 31};
END_TYPE;
 
TYPE derived_property_select = SELECT 
  (action_property, property_definition);
END_TYPE;
 
TYPE description_attribute_select = SELECT 
  (action_request_solution, application_context, approval_role, 
  configuration_design, context_dependent_shape_representation, date_role, 
  date_time_role, effectivity, external_source, organization_role, 
  person_and_organization, person_and_organization_role, 
  property_definition_representation, representation);
END_TYPE;
 
TYPE descriptive_measure = STRING;
END_TYPE;
 
TYPE dimension_count = INTEGER;
WHERE
  wr1 : SELF > 0;
END_TYPE;
 
TYPE document_reference_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE effectivity_item = SELECT 
  (product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE electric_current_measure = REAL;
END_TYPE;
 
TYPE event_occurrence_item = SELECT 
  (organizational_project);
END_TYPE;
 
TYPE external_identification_item = SELECT 
  (document_file, product_definition);
END_TYPE;
 
TYPE founded_item_select = SELECT 
  (representation_item);
END_TYPE;
 
TYPE hour_in_day = INTEGER;
WHERE
  wr1 : {0 <= SELF < 24};
END_TYPE;
 
TYPE id_attribute_select = SELECT 
  (action, address, application_context, group, organizational_project, 
  product_category, property_definition, representation, shape_aspect, 
  shape_aspect_relationship);
END_TYPE;
 
TYPE identification_item = SELECT 
  (approval_status, contract, document_file, organization, product, 
  product_definition, product_definition_formation, 
  security_classification_level, shape_representation);
END_TYPE;
 
TYPE identifier = STRING;
END_TYPE;
 
TYPE label = STRING;
END_TYPE;
 
TYPE length_measure = REAL;
END_TYPE;
 
TYPE list_of_two_representation_items = list_representation_item;
WHERE
  wr1 : HIINDEX(SELF) = 2;
END_TYPE;
 
TYPE list_representation_item =  LIST [1:?] OF representation_item;
END_TYPE;
 
TYPE luminous_intensity_measure = REAL;
END_TYPE;
 
TYPE mass_measure = REAL;
END_TYPE;
 
TYPE measure_value = SELECT 
  (amount_of_substance_measure, area_measure, celsius_temperature_measure, 
  context_dependent_measure, count_measure, descriptive_measure, 
  electric_current_measure, length_measure, luminous_intensity_measure, 
  mass_measure, numeric_measure, parameter_value, plane_angle_measure, 
  positive_length_measure, positive_plane_angle_measure, positive_ratio_measure
  , ratio_measure, solid_angle_measure, thermodynamic_temperature_measure, 
  time_measure, volume_measure);
END_TYPE;
 
TYPE minute_in_hour = INTEGER;
WHERE
  wr1 : {0 <= SELF <= 59};
END_TYPE;
 
TYPE month_in_year_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 12};
END_TYPE;
 
TYPE multi_language_attribute_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, 
  applied_organizational_project_assignment, approval, approval_relationship, 
  approval_status, certification, certification_type, contract, date_role, 
  date_time_role, document_relationship, document_usage_role, external_source, 
  identification_role, object_role, organization_relationship, 
  organizational_project, organizational_project_relationship, 
  organizational_project_role, person_and_organization, product, 
  product_category, product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE name_attribute_select = SELECT 
  (action_request_solution, address, configuration_design, 
  context_dependent_shape_representation, derived_unit, effectivity, 
  person_and_organization, product_definition, 
  property_definition_representation);
END_TYPE;
 
TYPE name_item = SELECT 
  (external_class_library);
END_TYPE;
 
TYPE numeric_measure = NUMBER;
END_TYPE;
 
TYPE organization_item = SELECT 
  (applied_identification_assignment, 
  applied_security_classification_assignment, contract, document_file, product
  , product_definition, product_definition_formation);
END_TYPE;
 
TYPE parameter_value = REAL;
END_TYPE;
 
TYPE person_and_organization_item = SELECT 
  (applied_identification_assignment, 
  applied_security_classification_assignment, contract, document_file, product
  , product_definition, product_definition_formation);
END_TYPE;
 
TYPE person_organization_select = SELECT 
  (organization, person, person_and_organization);
END_TYPE;
 
TYPE plane_angle_measure = REAL;
END_TYPE;
 
TYPE positive_length_measure = length_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE positive_ratio_measure = ratio_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE product_or_formation_or_definition = SELECT 
  (product, product_definition_formation, product_definition);
END_TYPE;
 
TYPE project_item = SELECT 
  (executed_action, product_concept);
END_TYPE;
 
TYPE ratio_measure = REAL;
END_TYPE;
 
TYPE represented_definition = SELECT 
  (general_property, property_definition, shape_aspect, 
  shape_aspect_relationship);
END_TYPE;
 
TYPE role_select = SELECT 
  (action_assignment, action_request_assignment, approval_assignment, 
  approval_date_time, certification_assignment, contract_assignment, 
  document_reference, effectivity_assignment, name_assignment, 
  security_classification_assignment);
END_TYPE;
 
TYPE second_in_minute = REAL;
WHERE
  wr1 : {0 <= SELF <= 60.0};
END_TYPE;
 
TYPE security_classification_item = SELECT 
  (document_file, product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE shape_definition = SELECT 
  (product_definition_shape, shape_aspect, shape_aspect_relationship);
END_TYPE;
 
TYPE si_prefix = ENUMERATION OF 
  (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, 
  nano, pico, femto, atto);
END_TYPE;
 
TYPE si_unit_name = ENUMERATION OF 
  (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz
  , newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, 
  tesla, henry, degree_celsius, lumen, lux, becquerel, gray, sievert);
END_TYPE;
 
TYPE solid_angle_measure = REAL;
END_TYPE;
 
TYPE source = ENUMERATION OF 
  (made, bought, not_known);
END_TYPE;
 
TYPE source_item = SELECT 
  (identifier);
END_TYPE;
 
TYPE text = STRING;
END_TYPE;
 
TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;
 
TYPE time_measure = REAL;
END_TYPE;
 
TYPE transformation = SELECT 
  (item_defined_transformation, functionally_defined_transformation);
END_TYPE;
 
TYPE unit = SELECT 
  (derived_unit, named_unit);
END_TYPE;
 
TYPE value_qualifier = SELECT 
  (precision_qualifier, type_qualifier);
END_TYPE;
 
TYPE vector_or_direction = SELECT 
  (vector, direction);
END_TYPE;
 
TYPE volume_measure = REAL;
END_TYPE;
 
TYPE year_number = INTEGER;
END_TYPE;
 
ENTITY action;
  name : label;
  description :  OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY action_assignment ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY action_directive;
  name : label;
  description :  OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET [1:?] OF versioned_action_request;
END_ENTITY;
 
ENTITY action_method;
  name : label;
  description :  OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;
 
ENTITY action_property;
  name : label;
  description : text;
  definition : characterized_action_definition;
END_ENTITY;
 
ENTITY action_property_representation;
  name : label;
  description : text;
  property : action_property;
  representation : representation;
END_ENTITY;
 
ENTITY action_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;
 
ENTITY action_request_assignment ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;
 
ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;
 
ENTITY address;
  internal_location :  OPTIONAL label;
  street_number :  OPTIONAL label;
  street :  OPTIONAL label;
  postal_box :  OPTIONAL label;
  town :  OPTIONAL label;
  region :  OPTIONAL label;
  postal_code :  OPTIONAL label;
  country :  OPTIONAL label;
  facsimile_number :  OPTIONAL label;
  telephone_number :  OPTIONAL label;
  electronic_mail_address :  OPTIONAL label;
  telex_number :  OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  wr1 : EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR
     EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code
    ) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number
    ) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;
 
ENTITY alternate_product_relationship;
  name : label;
  definition :  OPTIONAL text;
  alternate : product;
  base : product;
  basis : text;
UNIQUE
  ur1 : alternate, base;
WHERE
  wr1 : alternate :<>: base;
END_ENTITY;
 
ENTITY amount_of_substance_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(
    SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY amount_of_substance_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value(SELF);
  id : identifier := get_id_value(SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element FOR 
  frame_of_reference;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY application_context_element
SUPERTYPE OF (ONEOF (product_concept_context, product_context, 
product_definition_context));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;
 
ENTITY application_context_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;
 
ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;
 
ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1:?] OF action_items;
END_ENTITY;
 
ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1:?] OF action_request_item;
END_ENTITY;
 
ENTITY applied_approval_assignment
SUBTYPE OF (approval_assignment);
  items : SET [1:?] OF approval_item;
END_ENTITY;
 
ENTITY applied_certification_assignment
SUBTYPE OF (certification_assignment);
  items : SET [1:?] OF certification_item;
END_ENTITY;
 
ENTITY applied_contract_assignment
SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;
 
ENTITY applied_date_and_time_assignment
SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
 
ENTITY applied_date_assignment
SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;
 
ENTITY applied_document_reference
SUBTYPE OF (document_reference);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;
 
ENTITY applied_document_usage_constraint_assignment
SUBTYPE OF (document_usage_constraint_assignment);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;
 
ENTITY applied_effectivity_assignment
SUBTYPE OF (effectivity_assignment);
  items : SET [1:?] OF effectivity_item;
END_ENTITY;
 
ENTITY applied_event_occurrence_assignment
SUBTYPE OF (event_occurrence_assignment);
  items : SET [1:?] OF event_occurrence_item;
END_ENTITY;
 
ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1:?] OF external_identification_item;
END_ENTITY;
 
ENTITY applied_identification_assignment
SUBTYPE OF (identification_assignment);
  items : SET [1:?] OF identification_item;
END_ENTITY;
 
ENTITY applied_name_assignment
SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;
 
ENTITY applied_organization_assignment
SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;
 
ENTITY applied_organizational_project_assignment
SUBTYPE OF (organizational_project_assignment);
  items : SET [1:?] OF project_item;
END_ENTITY;
 
ENTITY applied_person_and_organization_assignment
SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;
 
ENTITY applied_security_classification_assignment
SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;
 
ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;
 
ENTITY approval_assignment ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;
 
ENTITY approval_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;
 
ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY approval_status;
  name : label;
END_ENTITY;
 
ENTITY area_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY area_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY assembly_component_usage
SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, 
specified_higher_usage_occurrence, promissory_usage_occurrence))
SUBTYPE OF (product_definition_usage);
  reference_designator :  OPTIONAL identifier;
END_ENTITY;
 
ENTITY assembly_component_usage_substitute;
  name : label;
  definition :  OPTIONAL text;
  base : assembly_component_usage;
  substitute : assembly_component_usage;
UNIQUE
  ur1 : base, substitute;
WHERE
  wr1 : base.relating_product_definition :=: substitute.
    relating_product_definition;
  wr2 : base :<>: substitute;
END_ENTITY;
 
ENTITY attribute_classification_assignment ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;
 
ENTITY attribute_language_assignment
SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : language;
  items : SET [1:?] OF attribute_language_item;
WHERE
  wr1 : SELF\attribute_classification_assignment.role.name IN ['primary', 
    'translated'];
  wr2 : SELF\attribute_classification_assignment.attribute_name <> '';
END_ENTITY;
 
ENTITY attribute_value_assignment ABSTRACT SUPERTYPE;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;
 
ENTITY attribute_value_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY axis2_placement_2d
SUBTYPE OF (placement);
  ref_direction :  OPTIONAL direction;
DERIVE
  p :  LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY axis2_placement_3d
SUBTYPE OF (placement);
  axis :  OPTIONAL direction;
  ref_direction :  OPTIONAL direction;
DERIVE
  p :  LIST [3:3] OF direction := build_axes(axis, ref_direction);
WHERE
  wr1 : SELF\placement.location.dim = 3;
  wr2 : NOT EXISTS(axis) OR (axis.dim = 3);
  wr3 : NOT EXISTS(ref_direction) OR (ref_direction.dim = 3);
  wr4 : NOT EXISTS(axis) OR NOT EXISTS(ref_direction) OR (cross_product(axis, 
    ref_direction).magnitude > 0.0);
END_ENTITY;
 
ENTITY calendar_date
SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  wr1 : valid_calendar_date(SELF);
END_ENTITY;
 
ENTITY cartesian_point
SUBTYPE OF (point);
  coordinates :  LIST [1:3] OF length_measure;
END_ENTITY;
 
ENTITY cartesian_transformation_operator
SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, 
cartesian_transformation_operator_3d))
SUBTYPE OF (geometric_representation_item, functionally_defined_transformation)
  ;
  axis1 :  OPTIONAL direction;
  axis2 :  OPTIONAL direction;
  local_origin : cartesian_point;
  scale :  OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  wr1 : scl > 0.0;
END_ENTITY;
 
ENTITY cartesian_transformation_operator_2d
SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u :  LIST [2:2] OF direction := base_axis(2, SELF\
  cartesian_transformation_operator.axis1, SELF\
  cartesian_transformation_operator.axis2, ?);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY cartesian_transformation_operator_3d
SUBTYPE OF (cartesian_transformation_operator);
  axis3 :  OPTIONAL direction;
DERIVE
  u :  LIST [3:3] OF direction := base_axis(3, SELF\
  cartesian_transformation_operator.axis1, SELF\
  cartesian_transformation_operator.axis2, axis3);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY celsius_temperature_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN 
    TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;
 
ENTITY certification_assignment ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY certification_type;
  description : label;
END_ENTITY;
 
ENTITY characterized_object;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY class
SUPERTYPE OF (ONEOF (class_by_extension, class_by_intension))
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY class_by_extension
SUBTYPE OF (class);
END_ENTITY;
 
ENTITY class_by_intension
SUBTYPE OF (class);
END_ENTITY;
 
ENTITY classification
SUBTYPE OF (applied_classification_assignment);
  SELF\applied_classification_assignment.items : SET 
  [1:1] OF classification_select;
DERIVE
  classified : classification_select := SELF\
  applied_classification_assignment.items[1];
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;
 
ENTITY classification_assignment ABSTRACT SUPERTYPE;
  assigned_class : group;
  role : classification_role;
END_ENTITY;
 
ENTITY applied_classification_assignment
SUBTYPE OF (classification_assignment);
  items : SET [1:?] OF classification_item;
END_ENTITY;
 
ENTITY classification_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY complete_membership
SUBTYPE OF (classification_assignment);
  members : SET OF complete_membership_select;
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;
 
ENTITY compound_representation_item
SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;
 
ENTITY configuration_design;
  configuration : configuration_item;
  design : configuration_design_item;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
UNIQUE
  ur1 : configuration, design;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY configuration_effectivity
SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  ur1 : configuration, usage, id;
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_USAGE' IN TYPEOF(
    SELF\product_definition_effectivity.usage);
END_ENTITY;
 
ENTITY configuration_item;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  item_concept : product_concept;
  purpose :  OPTIONAL label;
END_ENTITY;
 
ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN 
    TYPEOF(SELF.represented_product_relation.definition);
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
  wr3 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY context_dependent_unit
SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;
 
ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;
 
ENTITY contract_assignment ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY contract_type;
  description : label;
END_ENTITY;
 
ENTITY conversion_based_unit
SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;
 
ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset :  OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset, 0);
WHERE
  wr1 : {0 <= hour_offset < 24};
  wr2 : {0 <= actual_minute_offset <= 59};
  wr3 : NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = 
    exact));
END_ENTITY;
 
ENTITY date
SUPERTYPE OF (calendar_date);
  year_component : year_number;
END_ENTITY;
 
ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;
 
ENTITY date_and_time_assignment ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;
 
ENTITY date_assignment ABSTRACT SUPERTYPE;
  assigned_date : date;
  role : date_role;
END_ENTITY;
 
ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY dated_effectivity
SUBTYPE OF (effectivity);
  effectivity_end_date :  OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;
 
ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  wr1 : (SIZEOF(elements) > 1) OR (SIZEOF(elements) = 1) AND (elements[1].
    exponent <> 1.0);
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;
 
ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;
 
ENTITY descriptive_representation_item
SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;
 
ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;
 
ENTITY directed_action
SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;
 
ENTITY direction
SUBTYPE OF (geometric_representation_item);
  direction_ratios :  LIST [2:3] OF REAL;
WHERE
  wr1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;
 
ENTITY document;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET OF document_representation_type FOR 
  represented_document;
END_ENTITY;
 
ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  wr1 : SELF\characterized_object.name = '';
  wr2 : NOT EXISTS(SELF\characterized_object.description);
  wr3 : SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN [
    'digital', 'physical'])) = 1;
END_ENTITY;
 
ENTITY document_product_association;
  name : label;
  description :  OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;
 
ENTITY document_product_equivalence
SUBTYPE OF (document_product_association);
WHERE
  wr1 : SELF\document_product_association.name = 'equivalence';
  wr2 : NOT ('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT' IN TYPEOF(SELF\
    document_product_association.related_product)) OR (SELF\
    document_product_association.relating_document.kind.product_data_type = 
    'configuration controlled document') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\
    document_product_association.related_product, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
     | prpc.name = 'document')) = 1);
  wr3 : NOT ('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN 
    TYPEOF(SELF.related_product)) OR (SELF\document_product_association.
    relating_document.kind.product_data_type = 
    'configuration controlled document version') AND (SIZEOF(QUERY(prpc <* 
    USEDIN(SELF.related_product\product_definition_formation.of_product, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
     | prpc.name = 'document')) = 1);
  wr4 : NOT ('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF
    .related_product)) OR (SELF\document_product_association.relating_document.
    kind.product_data_type = 'configuration controlled document definition') 
    AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.
    related_product\product_definition.formation.of_product, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
     | prpc.name = 'document')) = 1);
END_ENTITY;
 
ENTITY document_reference ABSTRACT SUPERTYPE;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY document_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;
 
ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;
 
ENTITY document_type;
  product_data_type : label;
END_ENTITY;
 
ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;
 
ENTITY document_usage_constraint_assignment ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;
 
ENTITY document_usage_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY double_toleranced_measure_item
SUBTYPE OF (compound_representation_item);
  SELF\compound_representation_item.item_element : 
  list_of_two_representation_items;
END_ENTITY;
 
ENTITY effectivity
SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, 
lot_effectivity, time_interval_based_effectivity));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY effectivity_assignment ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY effectivity_relationship;
  name : label;
  description :  OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;
 
ENTITY electric_current_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY electric_current_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY event_occurrence;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY event_occurrence_assignment ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;
 
ENTITY event_occurrence_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;
 
ENTITY event_occurrence_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY executed_action
SUBTYPE OF (action);
END_ENTITY;
 
ENTITY external_class_library
SUBTYPE OF (external_source);
END_ENTITY;
 
ENTITY external_identification_assignment ABSTRACT SUPERTYPE
SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;
 
ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY externally_defined_class
SUBTYPE OF (class, externally_defined_item);
END_ENTITY;
 
ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;
 
ENTITY functionally_defined_transformation;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY general_property;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY general_property_association;
  name : label;
  description :  OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  wr1 : SIZEOF(USEDIN(derived_definition, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION'
    )) = 1;
  wr2 : derived_definition.name = base_definition.name;
END_ENTITY;
 
ENTITY general_property_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;
 
ENTITY geometric_representation_context
SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;
 
ENTITY geometric_representation_item
SUPERTYPE OF (ONEOF (point, direction, vector, placement, 
cartesian_transformation_operator))
SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  wr1 : SIZEOF(QUERY(using_rep <* using_representations(SELF) | NOT (
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF
    (using_rep.context_of_items)))) = 0;
END_ENTITY;
 
ENTITY global_uncertainty_assigned_context
SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;
 
ENTITY global_unit_assigned_context
SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY;
 
ENTITY group;
  name : label;
  description :  OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;
 
ENTITY identification_assignment ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;
 
ENTITY identification_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY item_defined_transformation;
  name : label;
  description :  OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;
 
ENTITY language
SUBTYPE OF (group);
WHERE
  wr1 : SELF\group.name <> '';
END_ENTITY;
 
ENTITY length_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY length_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY local_time;
  hour_component : hour_in_day;
  minute_component :  OPTIONAL minute_in_hour;
  second_component :  OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  wr1 : valid_time(SELF);
END_ENTITY;
 
ENTITY lot_effectivity
SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;
 
ENTITY luminous_intensity_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF
    \measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY luminous_intensity_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 1.0);
END_ENTITY;
 
ENTITY make_from_usage_option
SUBTYPE OF (product_definition_usage);
  ranking : INTEGER;
  ranking_rationale : text;
  quantity : measure_with_unit;
WHERE
  wr1 : NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.
    value_component > 0);
END_ENTITY;
 
ENTITY mapped_item
SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  wr1 : acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;
 
ENTITY mass_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY mass_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY measure_representation_item
SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;
 
ENTITY measure_with_unit
SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, 
time_measure_with_unit, electric_current_measure_with_unit, 
thermodynamic_temperature_measure_with_unit, 
celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, 
luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, 
solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit
, ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
WHERE
  wr1 : valid_units(SELF);
END_ENTITY;
 
ENTITY multi_language_attribute_assignment
SUBTYPE OF (attribute_value_assignment);
  items : SET [1:?] OF multi_language_attribute_item;
DERIVE
  translation_language : language := language_indication[1]\
  attribute_classification_assignment.assigned_class;
INVERSE
  language_indication : SET [1:1] OF attribute_language_assignment FOR items;
WHERE
  wr1 : SELF\attribute_value_assignment.role.name = 'alternate language';
  wr2 : SIZEOF(QUERY(ala <* language_indication | (ala\
    attribute_classification_assignment.attribute_name = 'attribute_value') AND
     (ala\attribute_classification_assignment.role.name = 'translated'))) = 1;
  wr3 : SELF\attribute_value_assignment.attribute_name <> '';
  wr4 : SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')
     | (ata\attribute_value_assignment.attribute_name = SELF\
    attribute_value_assignment.attribute_name) AND (ata.translation_language
     :=: translation_language))) > 1)) = 0;
  wr5 : SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') | (
    ata\attribute_classification_assignment.role.name = 'primary') AND (ata\
    attribute_classification_assignment.attribute_name = SELF\
    attribute_value_assignment.attribute_name) AND (ata\
    attribute_classification_assignment.assigned_class :=: translation_language
    ))) > 0)) = 0;
END_ENTITY;
 
ENTITY name_assignment ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;
 
ENTITY named_unit
SUPERTYPE OF (ONEOF (si_unit, conversion_based_unit, context_dependent_unit)
 ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, 
thermodynamic_temperature_unit, amount_of_substance_unit, 
luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, 
volume_unit, ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;
 
ENTITY next_assembly_usage_occurrence
SUBTYPE OF (assembly_component_usage);
END_ENTITY;
 
ENTITY object_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY organization;
  id :  OPTIONAL identifier;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY organization_assignment ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;
 
ENTITY organization_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;
 
ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY organizational_address
SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY organizational_project;
  name : label;
  description :  OPTIONAL text;
  responsible_organizations : SET [1:?] OF organization;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY organizational_project_assignment ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;
 
ENTITY organizational_project_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;
 
ENTITY organizational_project_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY person;
  id : identifier;
  last_name :  OPTIONAL label;
  first_name :  OPTIONAL label;
  middle_names :  OPTIONAL  LIST [1:?] OF label;
  prefix_titles :  OPTIONAL  LIST [1:?] OF label;
  suffix_titles :  OPTIONAL  LIST [1:?] OF label;
WHERE
  wr1 : EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;
 
ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY person_and_organization_address
SUBTYPE OF (organizational_address, personal_address);
  SELF\personal_address.people : SET [1:1] OF person;
  SELF\organizational_address.organizations : SET [1:1] OF organization;
WHERE
  wr1 : SIZEOF(QUERY(pao <* USEDIN(SELF\personal_address.people[1], 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.
    the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;
 
ENTITY person_and_organization_assignment ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;
 
ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY personal_address
SUBTYPE OF (address);
  people : SET [1:?] OF person;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY placement
SUPERTYPE OF (ONEOF (axis2_placement_2d, axis2_placement_3d))
SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;
 
ENTITY plane_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY plane_angle_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY point
SUPERTYPE OF (cartesian_point)
SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;
 
ENTITY product;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  frame_of_reference : SET [1:?] OF product_context;
END_ENTITY;
 
ENTITY product_category;
  name : label;
  description :  OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY product_category_relationship;
  name : label;
  description :  OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  wr1 : acyclic_product_category_relationship(SELF, [SELF.sub_category]);
END_ENTITY;
 
ENTITY product_concept;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  market_context : product_concept_context;
UNIQUE
  ur1 : id;
END_ENTITY;
 
ENTITY product_concept_context
SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;
 
ENTITY product_context
SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;
 
ENTITY product_definition;
  id : identifier;
  description :  OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY product_definition_context
SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;
 
ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;
 
ENTITY product_definition_context_role;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY product_definition_effectivity
SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'
    )) = 0;
END_ENTITY;
 
ENTITY product_definition_formation;
  id : identifier;
  description :  OPTIONAL text;
  of_product : product;
UNIQUE
  ur1 : id, of_product;
END_ENTITY;
 
ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;
 
ENTITY product_definition_formation_with_specified_source
SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;
 
ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;
 
ENTITY product_definition_shape
SUBTYPE OF (property_definition);
UNIQUE
  ur1 : SELF\property_definition.definition;
WHERE
  wr1 : SIZEOF([
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\
    property_definition.definition)) > 0;
END_ENTITY;
 
ENTITY product_definition_usage
SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
SUBTYPE OF (product_definition_relationship);
UNIQUE
  ur1 : SELF\product_definition_relationship.id, SELF\
    product_definition_relationship.relating_product_definition, SELF\
    product_definition_relationship.related_product_definition;
WHERE
  wr1 : acyclic_product_definition_relationship(SELF, [SELF\
    product_definition_relationship.related_product_definition], 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;
 
ENTITY product_definition_with_associated_documents
SUBTYPE OF (product_definition);
  documentation_ids : SET [1:?] OF document;
END_ENTITY;
 
ENTITY product_related_product_category
SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY;
 
ENTITY promissory_usage_occurrence
SUBTYPE OF (assembly_component_usage);
END_ENTITY;
 
ENTITY property_definition;
  name : label;
  description :  OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY qualified_representation_item
SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  wr1 : SIZEOF(QUERY(temp <* qualifiers | 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp))) < 2;
END_ENTITY;
 
ENTITY quantified_assembly_component_usage
SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
WHERE
  wr1 : NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.
    value_component > 0);
END_ENTITY;
 
ENTITY ratio_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY ratio_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY relative_event_occurrence
SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;
 
ENTITY representation;
  name : label;
  items : SET [1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id : identifier := get_id_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 
    1;
END_ENTITY;
 
ENTITY representation_context;
  context_identifier : identifier;
  context_type : text;
INVERSE
  representations_in_context : SET [1:?] OF representation FOR context_of_items
  ;
END_ENTITY;
 
ENTITY representation_item;
  name : label;
WHERE
  wr1 : SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;
 
ENTITY representation_map;
  mapping_origin : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?] OF mapped_item FOR mapping_source;
WHERE
  wr1 : item_in_context(SELF.mapping_origin, SELF.mapped_representation.
    context_of_items);
END_ENTITY;
 
ENTITY representation_relationship;
  name : label;
  description :  OPTIONAL text;
  rep_1 : representation;
  rep_2 : representation;
END_ENTITY;
 
ENTITY representation_relationship_with_transformation
SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  wr1 : SELF\representation_relationship.rep_1.context_of_items :<>: SELF\
    representation_relationship.rep_2.context_of_items;
END_ENTITY;
 
ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;
 
ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;
 
ENTITY security_classification_assignment ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;
 
ENTITY security_classification_level;
  name : label;
END_ENTITY;
 
ENTITY serial_numbered_effectivity
SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id :  OPTIONAL identifier;
END_ENTITY;
 
ENTITY shape_aspect;
  name : label;
  description :  OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY shape_aspect_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY shape_definition_representation
SUBTYPE OF (property_definition_representation);
WHERE
  wr1 : ('PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
    SELF.definition)) OR ('PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION' IN 
    TYPEOF(SELF.definition.definition));
  wr2 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
    used_representation);
END_ENTITY;
 
ENTITY shape_representation
SUBTYPE OF (representation);
END_ENTITY;
 
ENTITY shape_representation_relationship
SUBTYPE OF (representation_relationship);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF\
    representation_relationship.rep_1) + TYPEOF(SELF\
    representation_relationship.rep_2);
END_ENTITY;
 
ENTITY si_unit
SUBTYPE OF (named_unit);
  prefix :  OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(
  name);
END_ENTITY;
 
ENTITY solid_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY solid_angle_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY specified_higher_usage_occurrence
SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage : next_assembly_usage_occurrence;
UNIQUE
  ur1 : upper_usage, next_usage;
WHERE
  wr1 : SELF :<>: upper_usage;
  wr2 : SELF\product_definition_relationship.relating_product_definition :=: 
    upper_usage.relating_product_definition;
  wr3 : SELF\product_definition_relationship.related_product_definition :=: 
    next_usage.related_product_definition;
  wr4 : (upper_usage.related_product_definition :=: next_usage.
    relating_product_definition) OR (SIZEOF(QUERY(pdr <* USEDIN(upper_usage.
    related_product_definition, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
    ) | pdr.relating_product_definition :=: next_usage.
    relating_product_definition)) = 1);
  wr5 : SIZEOF(['PRODUCT_DATA_MANAGEMENT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE'
    , 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] * 
    TYPEOF(upper_usage)) = 1;
END_ENTITY;
 
ENTITY thermodynamic_temperature_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN 
    TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY thermodynamic_temperature_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY time_interval;
  id : identifier;
  name : label;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY time_interval_based_effectivity
SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;
 
ENTITY time_interval_relationship;
  name : label;
  description :  OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;
 
ENTITY time_interval_with_bounds
SUBTYPE OF (time_interval);
  primary_bound :  OPTIONAL date_time_or_event_occurrence;
  secondary_bound :  OPTIONAL date_time_or_event_occurrence;
  duration :  OPTIONAL time_measure_with_unit;
WHERE
  wr1 : NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  wr2 : EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;
 
ENTITY time_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY time_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 1.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY type_qualifier;
  name : label;
END_ENTITY;
 
ENTITY uncertainty_measure_with_unit
SUBTYPE OF (measure_with_unit);
  name : label;
  description :  OPTIONAL text;
WHERE
  wr1 : valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY;
 
ENTITY value_range
SUBTYPE OF (compound_representation_item);
WHERE
  wr1 : ('PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'SET_REPRESENTATION_ITEM' IN 
    TYPEOF(item_element)) AND value_range_wr1(item_element);
  wr2 : value_range_wr2(item_element);
  wr3 : value_range_wr3(item_element);
END_ENTITY;
 
ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  wr1 : SIZEOF(QUERY(rep <* using_representations(SELF) | NOT (
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(rep
    .context_of_items)))) = 0;
END_ENTITY;
 
ENTITY vector
SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
WHERE
  wr1 : magnitude >= 0.0;
END_ENTITY;
 
ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description :  OPTIONAL text;
END_ENTITY;
 
ENTITY volume_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY volume_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\
    named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.
    dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.
    dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.
    dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;
 

(* in pdm_schema *)
FUNCTION acyclic_mapped_representation(parent_set : SET OF representation; 
  children_set : SET OF representation_item) : BOOLEAN;
LOCAL
  x : SET OF representation_item;
  y : SET OF representation_item;
END_LOCAL;
  x := QUERY(z <* children_set | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MAPPED_ITEM' 
  IN TYPEOF(z));
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set
       THEN
        RETURN (FALSE);
      END_IF;
      IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item.
      mapping_source.mapped_representation, x[i]\mapped_item.mapping_source.
      mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  x := children_set - x;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      y := QUERY(z <* bag_to_set(USEDIN(x[i], '')) | 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 

(* in pdm_schema *)
FUNCTION acyclic_product_category_relationship(relation : 
  product_category_relationship; children : SET OF product_category) : BOOLEAN;
LOCAL
  x : SET OF product_category_relationship;
  local_children : SET OF product_category;
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(children);
    IF relation.category :=: children[i] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN(relation.category, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'))
  ;
  local_children := children + relation.category;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;


(* in pdm_schema *)
FUNCTION acyclic_product_definition_relationship(relation : 
  product_definition_relationship; relatives : SET [1:?] OF product_definition
  ; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_relationship;
END_LOCAL;
  IF relation.relating_product_definition IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
  )) | specific_relation IN TYPEOF(pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.
    relating_product_definition, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION alias_assignment_is_valid(aia : applied_identification_assignment) : 
  BOOLEAN;
LOCAL
  item : identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'alias' THEN
    REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items);
      item := aia.items[i];
      IF SIZEOF(['PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'ALIASABLE_ITEM'] * TYPEOF
      (item)) = 0 THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 
FUNCTION assembly_shape_is_defined(assy : next_assembly_usage_occurrence) : 
  BOOLEAN;
LOCAL
  sdr_set : SET OF shape_definition_representation := [];
  srr_set : SET OF shape_representation_relationship := [];
  sdr1_set : SET OF shape_definition_representation := [];
  pd_set : SET OF property_definition := [];
  pdr_set : SET OF product_definition_relationship := [];
  pds_set : SET OF product_definition_shape := [];
  prop_set : SET OF property_definition := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(assy.related_product_definition, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  pdr_set := QUERY(pdr <* bag_to_set(USEDIN(assy.related_product_definition, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
  )) | SIZEOF(USEDIN(pdr, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')) > 0);
  IF SIZEOF(pd_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(pd_set);
      sdr_set := sdr_set + QUERY(pdr <* USEDIN(pd_set[i], 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
      ) | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN 
      TYPEOF(pdr));
    END_REPEAT;
  END_IF;
  IF SIZEOF(pdr_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(pdr_set);
      prop_set := prop_set + bag_to_set(USEDIN(pdr_set[i], 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
    END_REPEAT;
    IF SIZEOF(prop_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(prop_set);
        sdr_set := sdr_set + QUERY(pdr <* USEDIN(prop_set[i], 
        'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
        ) | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN
         TYPEOF(pdr));
      END_REPEAT;
    END_IF;
  END_IF;
  IF SIZEOF(sdr_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(sdr_set);
      srr_set := QUERY(rr <* bag_to_set(USEDIN(sdr_set[i]\
      property_definition_representation.used_representation, 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2')) | 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP' IN 
      TYPEOF(rr));
      pd_set := bag_to_set(USEDIN(assy.relating_product_definition, 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
      IF SIZEOF(pd_set) > 0 THEN
        REPEAT i := 1 TO HIINDEX(pd_set);
          sdr1_set := sdr1_set + QUERY(pdr <* USEDIN(pd_set[i], 
          'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
          ) | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' 
          IN TYPEOF(pdr));
        END_REPEAT;
      END_IF;
      IF (SIZEOF(sdr_set) > 0) AND (SIZEOF(sdr1_set) > 0) THEN
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set);
            IF SIZEOF(QUERY(pdr <* bag_to_set(USEDIN(srr_set[j]\
            representation_relationship.rep_1, 
            'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'
            )) | 
            'PRODUCT_DATA_MANAGEMENT_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF(pdr)) * sdr1_set) >= 1 THEN
              pds_set := QUERY(x <* bag_to_set(USEDIN(assy, 
              'PRODUCT_DATA_MANAGEMENT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'))
               | 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN 
              TYPEOF(x));
              IF SIZEOF(pds_set) = 0 THEN
                RETURN (FALSE);
              END_IF;
              REPEAT k := 1 TO HIINDEX(pds_set);
                IF SIZEOF(QUERY(cdsr <* USEDIN(pds_set[k], 
                'PRODUCT_DATA_MANAGEMENT_MIM_LF.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.REPRESENTED_PRODUCT_RELATION'
                ) | cdsr.representation_relation :=: srr_set[j])) > 0 THEN
                  RETURN (FALSE);
                END_IF;
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;


(* in pdm_schema *) 
FUNCTION bag_to_set(the_bag :  BAG  OF GENERIC : intype) : SET OF GENERIC : 
  intype;
LOCAL
  the_set : SET OF GENERIC : intype := [];
END_LOCAL;
  IF SIZEOF(the_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
END_FUNCTION;


(* in pdm_schema *) 
FUNCTION base_axis(dim : INTEGER; axis1 : direction; axis2 : direction; axis3
   : direction) :  LIST [2:3] OF direction;
LOCAL
  u :  LIST [2:3] OF direction;
  factor : REAL;
  d1 : direction;
  d2 : direction;
END_LOCAL;
  IF dim = 3 THEN
    d1 := NVL(normalise(axis3), dummy_gri||direction([0.0, 0.0, 1.0]));
    d2 := first_proj_axis(d1, axis1);
    u := [d2, second_proj_axis(d1, d2, axis2), d1];
  ELSE
    IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2, u[2]);
        IF factor < 0.0 THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri||direction([1.0, 0.0]), dummy_gri||direction([0.0, 1.0]
        )];
      END_IF;
    END_IF;
  END_IF;
  RETURN (u);
END_FUNCTION;


(* in pdm_schema *) 
FUNCTION build_2axes(ref_direction : direction) :  LIST [2:2] OF direction;
LOCAL
  d : direction := NVL(normalise(ref_direction), dummy_gri||direction([1.0, 0.0
  ]));
END_LOCAL;
  RETURN ([d, orthogonal_complement(d)]);
END_FUNCTION;


(* in pdm_schema *) 
FUNCTION build_axes(axis : direction; ref_direction : direction) :  LIST [3:3]
   OF direction;
LOCAL
  d1 : direction;
  d2 : direction;
END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri||direction([0.0, 0.0, 1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN ([d2, normalise(cross_product(d1, d2)).orientation, d1]);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION cross_product(arg1 : direction; arg2 : direction) : vector;
LOCAL
  mag : REAL;
  res : direction;
  v1 :  LIST [3:3] OF REAL;
  v2 :  LIST [3:3] OF REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(arg1) OR (arg1.dim = 2) OR NOT EXISTS(arg2) OR (arg2.dim = 2)
   THEN
    RETURN (?);
  ELSE
    v1 := normalise(arg1).direction_ratios;
    v2 := normalise(arg2).direction_ratios;
    res := dummy_gri||direction([v1[2] * v2[3] - v1[3] * v2[2], v1[3] * v2[1]
     - v1[1] * v2[3], v1[1] * v2[2] - v1[2] * v2[1]]);
    mag := 0.0;
    REPEAT i := 1 TO 3;
      mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      result := dummy_gri||vector(res, SQRT(mag));
    ELSE
      result := dummy_gri||vector(arg1, 0.0);
    END_IF;
    RETURN (result);
  END_IF;
END_FUNCTION;
 
(* in pdm_schema *)  
FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
LOCAL
  result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0);
END_LOCAL;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + x.elements[i].exponent
       * x.elements[i].unit.dimensions.length_exponent;
      result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x
      .elements[i].unit.dimensions.mass_exponent;
      result.time_exponent := result.time_exponent + x.elements[i].exponent * x
      .elements[i].unit.dimensions.time_exponent;
      result.electric_current_exponent := result.electric_current_exponent + x.
      elements[i].exponent * x.elements[i].unit.dimensions.
      electric_current_exponent;
      result.thermodynamic_temperature_exponent := result.
      thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[
      i].unit.dimensions.thermodynamic_temperature_exponent;
      result.amount_of_substance_exponent := result.
      amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].
      unit.dimensions.amount_of_substance_exponent;
      result.luminous_intensity_exponent := result.luminous_intensity_exponent
       + x.elements[i].exponent * x.elements[i].unit.dimensions.
      luminous_intensity_exponent;
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
LOCAL
  x : SET OF representation;
  y : representation_context;
  dim : dimension_count;
END_LOCAL;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN (dim);
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(item) THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  x := using_representations(item);
  y := x[1].context_of_items;
  dim := y\geometric_representation_context.coordinate_space_dimension;
  RETURN (dim);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF 
     metre : 
    RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
     gram : 
    RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
     second : 
    RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
     ampere : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
     kelvin : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
     mole : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
     candela : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
     radian : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
     steradian : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
     hertz : 
    RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
     newton : 
    RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
     pascal : 
    RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
     joule : 
    RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
     watt : 
    RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
     coulomb : 
    RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
     volt : 
    RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
     farad : 
    RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
     ohm : 
    RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
     siemens : 
    RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
     weber : 
    RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
     tesla : 
    RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
     henry : 
    RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
     degree_celsius : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
     lumen : 
    RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
     lux : 
    RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
     becquerel : 
    RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
     gray : 
    RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
     sievert : 
    RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE  : RETURN (?);
  END_CASE;
END_FUNCTION;


(* in pdm_schema *)  
FUNCTION dot_product(arg1 : direction; arg2 : direction) : REAL;
LOCAL
  scalar : REAL;
  vec1 : direction;
  vec2 : direction;
  ndim : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) THEN
    scalar := ?;
  ELSE
    IF arg1.dim <> arg2.dim THEN
      scalar := ?;
    ELSE
      vec1 := normalise(arg1);
      vec2 := normalise(arg2);
      ndim := arg1.dim;
      scalar := 0.0;
      REPEAT i := 1 TO ndim;
        scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (scalar);
END_FUNCTION;


(* in pdm_schema *)  
FUNCTION first_proj_axis(z_axis : direction; arg : direction) : direction;
LOCAL
  x_axis : direction;
  v : direction;
  z : direction;
  x_vec : vector;
END_LOCAL;
  IF NOT EXISTS(z_axis) THEN
    RETURN (?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF (z.direction_ratios <> [1.0, 0.0, 0.0]) AND (z.direction_ratios <> [-
      1.0, 0.0, 0.0]) THEN
        v := dummy_gri||direction([1.0, 0.0, 0.0]);
      ELSE
        v := dummy_gri||direction([0.0, 1.0, 0.0]);
      END_IF;
    ELSE
      IF arg.dim <> 3 THEN
        RETURN (?);
      END_IF;
      IF cross_product(arg, z).magnitude = 0.0 THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN (x_axis);
END_FUNCTION;


(* in pdm_schema *)  
FUNCTION get_description_value(obj : description_attribute_select) : text;
LOCAL
  description_bag :  BAG  OF description_attribute := USEDIN(obj, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM');
END_LOCAL;
  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION get_id_value(obj : id_attribute_select) : identifier;
LOCAL
  id_bag :  BAG  OF id_attribute := USEDIN(obj, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM');
END_LOCAL;
  IF SIZEOF(id_bag) = 1 THEN
    RETURN (id_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION get_name_value(obj : name_attribute_select) : label;
LOCAL
  name_bag :  BAG  OF name_attribute := USEDIN(obj, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM');
END_LOCAL;
  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;


(* in pdm_schema *)  
FUNCTION get_role(obj : role_select) : object_role;
LOCAL
  role_bag :  BAG  OF role_association := USEDIN(obj, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE');
END_LOCAL;
  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 
FUNCTION initial_context_is_additional(pd : product_definition) : BOOLEAN;
LOCAL
  initial_context : product_definition_context;
  context_associations : SET OF product_definition_context_association;
END_LOCAL;
  initial_context := pd.frame_of_reference;
  context_associations := QUERY(pdca <* bag_to_set(USEDIN(pd, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION'
  )) | (pdca.role.name = 'additional context') AND (pdca.frame_of_reference
   :=: initial_context));
  RETURN (SIZEOF(context_associations) > 0);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION item_in_context(item : representation_item; cntxt : 
  representation_context) : BOOLEAN;
LOCAL
  y :  BAG  OF representation_item;
END_LOCAL;
  IF SIZEOF(USEDIN(item, 'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS')
   * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
  ELSE
    y := QUERY(z <* USEDIN(item, '') | 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
    IF SIZEOF(y) > 0 THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION leap_year(year : year_number) : BOOLEAN;
  IF (year MOD 4 = 0) AND (year MOD 100 <> 0) OR (year MOD 400 = 0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION normalise(arg : vector_or_direction) : vector_or_direction;
LOCAL
  ndim : INTEGER;
  v : direction;
  result : vector_or_direction;
  vec : vector;
  mag : REAL;
END_LOCAL;
  IF NOT EXISTS(arg) THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
      v := dummy_gri||direction(arg.orientation.direction_ratios);
      IF arg.magnitude = 0.0 THEN
        RETURN (?);
      ELSE
        vec := dummy_gri||vector(v, 1.0);
      END_IF;
    ELSE
      v := dummy_gri||direction(arg.direction_ratios);
    END_IF;
    mag := 0.0;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i]/mag;
      END_REPEAT;
      IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION orthogonal_complement(vec : direction) : direction;
LOCAL
  result : direction;
END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS(vec) THEN
    RETURN (?);
  ELSE
    result := dummy_gri||direction([-vec.direction_ratios[2], vec.
    direction_ratios[1]]);
    RETURN (result);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION scalar_times_vector(scalar : REAL; vec : vector_or_direction) : vector
  ;
LOCAL
  v : direction;
  mag : REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(scalar) OR NOT EXISTS(vec) THEN
    RETURN (?);
  ELSE
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(vec) THEN
      v := dummy_gri||direction(vec.orientation.direction_ratios);
      mag := scalar * vec.magnitude;
    ELSE
      v := dummy_gri||direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF mag < 0.0 THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri||vector(normalise(v), mag);
  END_IF;
  RETURN (result);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION second_proj_axis(z_axis : direction; x_axis : direction; arg : 
  direction) : direction;
LOCAL
  y_axis : vector;
  v : direction;
  temp : vector;
END_LOCAL;
  IF NOT EXISTS(arg) THEN
    v := dummy_gri||direction([0.0, 1.0, 0.0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN (y_axis.orientation);
END_FUNCTION;
 
FUNCTION type_check_function(the_type : GENERIC; sub_names : SET OF STRING; 
  criterion : INTEGER) : LOGICAL;
  IF NOT EXISTS(the_type) OR NOT ({0 <= criterion <= 3}) OR (SIZEOF(sub_names)
   = 0) THEN
    RETURN (UNKNOWN);
  ELSE
    CASE criterion OF 
       0 : 
      RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
       1 : 
      RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
       2 : 
      RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
       3 : 
      RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
    END_CASE;
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION using_items(item : founded_item_select; checked_items : SET OF 
  founded_item_select) : SET OF founded_item_select;
LOCAL
  new_check_items : SET OF founded_item_select;
  result_items : SET OF founded_item_select;
  next_items : SET OF founded_item_select;
END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  next_items := QUERY(z <* bag_to_set(USEDIN(item, '')) | (
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.FOUNDED_ITEM' IN TYPEOF(z)));
  IF SIZEOF(next_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] + using_items(next_items[i
        ], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (result_items);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION using_representations(item : founded_item_select) : SET OF 
  representation;
LOCAL
  results : SET OF representation;
  result_bag :  BAG  OF representation;
  intermediate_items : SET OF founded_item_select;
END_LOCAL;
  results := [];
  result_bag := USEDIN(item, 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  intermediate_items := using_items(item, []);
  IF SIZEOF(intermediate_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i], 
      'PRODUCT_DATA_MANAGEMENT_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (results);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION valid_calendar_date(date : calendar_date) : LOGICAL;
  CASE date.month_component OF 
     1 : 
    RETURN ({1 <= date.day_component <= 31});
     2 : 
      BEGIN
        IF leap_year(date.year_component) THEN
          RETURN ({1 <= date.day_component <= 29});
        ELSE
          RETURN ({1 <= date.day_component <= 28});
        END_IF;
      END;
     3 : 
    RETURN ({1 <= date.day_component <= 31});
     4 : 
    RETURN ({1 <= date.day_component <= 30});
     5 : 
    RETURN ({1 <= date.day_component <= 31});
     6 : 
    RETURN ({1 <= date.day_component <= 30});
     7 : 
    RETURN ({1 <= date.day_component <= 31});
     8 : 
    RETURN ({1 <= date.day_component <= 31});
     9 : 
    RETURN ({1 <= date.day_component <= 30});
     10 : 
    RETURN ({1 <= date.day_component <= 31});
     11 : 
    RETURN ({1 <= date.day_component <= 30});
     12 : 
    RETURN ({1 <= date.day_component <= 31});
  END_CASE;
  RETURN (FALSE);
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION valid_measure_value(m : measure_value) : BOOLEAN;
  IF 'REAL' IN TYPEOF(m) THEN
    RETURN (m > 0.0);
  ELSE
    IF 'INTEGER' IN TYPEOF(m) THEN
      RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION valid_time(time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component)
   THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component
  ) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION value_range_wr1(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY(i1 <* agg | 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)))
   = 2) OR (SIZEOF(QUERY(i2 <* agg | 
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2))) = 
  2)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION value_range_wr2(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF (SIZEOF(QUERY(i <* agg | i.name = 'upper limit')) = 1) AND (SIZEOF(QUERY(i
   <* agg | i.name = 'lower limit')) = 1) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION value_range_wr3(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF SIZEOF(QUERY(i1 <* agg | (
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) 
  AND (SIZEOF(QUERY(i2 <* agg | (
  'PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i2)) 
  AND (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\
  measure_with_unit.unit_component))) = 1))) = 2 THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 

(* in pdm_schema *) 
FUNCTION vector_difference(arg1 : vector_or_direction; arg2 : 
  vector_or_direction) : vector;
LOCAL
  result : vector;
  res : direction;
  vec1 : direction;
  vec2 : direction;
  mag : REAL;
  mag1 : REAL;
  mag2 : REAL;
  ndim : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) OR (arg1.dim <> arg2.dim) THEN
    RETURN (?);
  ELSE
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
      mag1 := arg1.magnitude;
      vec1 := arg1.orientation;
    ELSE
      mag1 := 1.0;
      vec1 := arg1;
    END_IF;
    IF 'PRODUCT_DATA_MANAGEMENT_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
      mag2 := arg2.magnitude;
      vec2 := arg2.orientation;
    ELSE
      mag2 := 1.0;
      vec2 := arg2;
    END_IF;
    vec1 := normalise(vec1);
    vec2 := normalise(vec2);
    ndim := SIZEOF(vec1.direction_ratios);
    mag := 0.0;
    res := dummy_gri||direction(vec1.direction_ratios);
    REPEAT i := 1 TO ndim;
      res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.
      direction_ratios[i];
      mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      result := dummy_gri||vector(res, SQRT(mag));
    ELSE
      result := dummy_gri||vector(vec1, 0.0);
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION version_assignment_is_valid(aia : applied_identification_assignment)
   : BOOLEAN;
LOCAL
  item : identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'version' THEN
    REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items);
      item := aia.items[i];
      IF SIZEOF(['PRODUCT_DATA_MANAGEMENT_MIM_LF.' + 'VERSIONABLE_ITEM'] * 
      TYPEOF(item)) = 0 THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 
RULE aliases_are_valid FOR (applied_identification_assignment);
WHERE
  wr1 : SIZEOF(QUERY(aia <* applied_identification_assignment | NOT 
    alias_assignment_is_valid(aia))) = 0;
END_RULE;
 
RULE compatible_dimension FOR (cartesian_point, direction, 
  representation_context, geometric_representation_context);
WHERE
  wr1 : SIZEOF(QUERY(x <* cartesian_point | SIZEOF(QUERY(y <* 
    geometric_representation_context | item_in_context(x, y) AND (HIINDEX(x.
    coordinates) <> y.coordinate_space_dimension))) > 0)) = 0;
  wr2 : SIZEOF(QUERY(x <* direction | SIZEOF(QUERY(y <* 
    geometric_representation_context | item_in_context(x, y) AND (HIINDEX(x.
    direction_ratios) <> y.coordinate_space_dimension))) > 0)) = 0;
END_RULE;
 
RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);
WHERE
  wr1 : SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence | NOT 
    assembly_shape_is_defined(nauo))) = 0;
END_RULE;
 
RULE product_requires_category FOR (product);
WHERE
  wr1 : SIZEOF(QUERY(p <* product | SIZEOF(USEDIN(p, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
    ) = 0)) = 0;
END_RULE;
 
RULE restrict_document_definition_category FOR (product_definition);
LOCAL
  document_definitions : SET OF product_definition := [];
END_LOCAL;
  document_definitions := QUERY(pd <* product_definition | pd.
  frame_of_reference.name IN ['digital document definition', 
  'physical document definition']);
WHERE
  wr1 : SIZEOF(QUERY(pd <* document_definitions | SIZEOF(QUERY(prpc <* USEDIN(
    pd.formation.of_product, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
     | prpc.name IN ['document'])) = 0)) = 0;
END_RULE;
 
RULE restrict_language_assignment_per_attribute FOR (
  attribute_language_assignment);
WHERE
  wr1 : SIZEOF(QUERY(ala1 <* attribute_language_assignment | SIZEOF(QUERY(it
     <* ala1.items | SIZEOF(QUERY(ala2 <* USEDIN(it, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') | (
    ala1\attribute_classification_assignment.attribute_name = ala2\
    attribute_classification_assignment.attribute_name) AND (ala1\
    attribute_classification_assignment.assigned_class :=: ala2\
    attribute_classification_assignment.assigned_class))) > 1)) > 0)) = 0;
END_RULE;
 
RULE restrict_part_definition_category FOR (product_definition);
LOCAL
  part_definitions : SET OF product_definition := [];
END_LOCAL;
  part_definitions := QUERY(pd <* product_definition | pd.frame_of_reference.
  name = 'part definition');
WHERE
  wr1 : SIZEOF(QUERY(pd <* part_definitions | SIZEOF(QUERY(prpc <* USEDIN(pd.
    formation.of_product, 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')
     | prpc.name IN ['part', 'raw material', 'tool'])) = 0)) = 0;
END_RULE;
 
RULE subtype_exclusiveness_compound_representation_item FOR (
  compound_representation_item);
WHERE
  wr1 : SIZEOF(QUERY(cri <* compound_representation_item | NOT 
    type_check_function(cri, [
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.DOUBLE_TOLERANCED_MEASURE_ITEM', 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.VALUE_RANGE'], 3))) = 0;
END_RULE;
 
RULE subtype_exclusiveness_representation_item FOR (representation_item);
WHERE
  wr1 : SIZEOF(QUERY(cri <* representation_item | NOT type_check_function(cri, 
    ['PRODUCT_DATA_MANAGEMENT_MIM_LF.MEASURE_REPRESENTATION_ITEM', 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.VALUE_REPRESENTATION_ITEM', 
    'PRODUCT_DATA_MANAGEMENT_MIM_LF.COMPOUND_REPRESENTATION_ITEM'], 3))) = 0;
END_RULE;
 
RULE valid_context_partitions FOR (product_definition);
WHERE
  wr1 : SIZEOF(QUERY(pd <* product_definition | initial_context_is_additional(
    pd))) = 0;
END_RULE;
 
RULE version_assignments_are_valid FOR (applied_identification_assignment);
WHERE
  wr1 : SIZEOF(QUERY(aia <* applied_identification_assignment | NOT 
    version_assignment_is_valid(aia))) = 0;
END_RULE;
 
END_SCHEMA;

