<?xml version="1.0"?>
<!-- $Id: express2xml.js,v 1.25 2002/11/06 00:59:57 thendrix Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  description.file="mim_descriptions.xml"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.25"
    source="../data/modules/product_occurrence/mim.exp"/>

  <schema name="Product_occurrence_mim">
    <interface
      kind="use"
      schema="Extended_measure_representation_mim">
    </interface>

    <interface
      kind="use"
      schema="Measure_representation_mim">
    </interface>

    <interface
      kind="use"
      schema="Part_view_definition_mim">
    </interface>

    <interface
      kind="use"
      schema="Product_breakdown_mim">
    </interface>

    <interface
      kind="use"
      schema="Product_view_definition_relationship_mim">
    </interface>

    <interface
      kind="use"
      schema="Specified_product_mim">
    </interface>

    <interface
      kind="use"
      schema="product_structure_schema">
      <interfaced.item
        name="product_definition_occurrence_relationship"/>
    </interface>

    <rule
      name="restrict_part_occurrence"
      appliesto="product_definition">
      <algorithm>
LOCAL
  part_occurrences: SET[1:?] OF product_definition := [];
END_LOCAL;
  part_occurrences := QUERY(pd &lt;* product_definition | ( pd.frame_of_reference.name = 'part occurrence' ));
      </algorithm>

      <where
        label="wr1"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | ( NOT( pd.name IN [ 'single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0">
      </where>
      <where
        label="wr2"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  (SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd ,'PRODUCT_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' +'RELATED_PRODUCT_DEFINITION' ) |  pdr.name = 'definition usage' ) ) &lt;&gt;1 ) AND ( SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'PRODUCT_OCCURRENCE_MIM.' +'CONFIGURATION_DESIGN.' + 'DESIGN' ) | ( cd.name = 'occurrence usage definition' ) AND ( NOT ('PRODUCT_OCCURRENCE_MIM.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) &lt;&gt;1 ) ) ) = 0">
      </where>
      <where
        label="wr3"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  (SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'PRODUCT_OCCURRENCE_MIM.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.' +'RELATED_PRODUCT_DEFINITION' ) | ( 'PRODUCT_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND ( SIZEOF ( USEDIN ( pd , 'PRODUCT_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.' +'OCCURRENCE' ) ) = 0 ) ) ) = 0">
      </where>
      <where
        label="wr4"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  ( pd.name = 'selected instance' ) AND ( SIZEOF ( QUERY ( prd&lt;* USEDIN ( pd ,'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION' ) | (prd.name = 'occurrence selection' ) AND ( SIZEOF (QUERY ( pdr &lt;* USEDIN ( prd , 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ( pdr.used_representation.name = 'selection criteria' ) AND ( SIZEOF ( pdr.used_representation.items ) = 2 ) AND ( SIZEOF ( QUERY( i &lt;* pdr.used_representation.items | ( SIZEOF (['PRODUCT_OCCURRENCE_MIM.' + 'MEASURE_REPRESENTATION_ITEM' ,'PRODUCT_OCCURRENCE_MIM.' + 'VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND ( i.name = 'selection quantity' ) ) ) = 1 ) AND( SIZEOF ( QUERY ( i &lt;* pdr.used_representation.items |( 'PRODUCT_OCCURRENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND ( i.name = 'selection control' )))= 1)))= 1)))= 0)))= 0">
      </where>
      <where
        label="wr5"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  ( pd.name = 'quantified instance' ) AND ( SIZEOF ( QUERY ( ppd &lt;* USEDIN ( pd , 'PRODUCT_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION.' + 'DEFINITION' ) | ( ppd.name ='occurrence quantity' ) AND ( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( ppd , 'PRODUCT_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION' ) | ( pdr.used_representation.name = 'quantity' ) AND ( SIZEOF ( pdr.used_representation.items ) = 1 ) AND (SIZEOF ( QUERY ( i &lt;* pdr.used_representation.items | ('PRODUCT_OCCURRENCE_MIM.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND ( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0">
      </where>
      <where
        label="wr6"
        expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | ( pd.name = 'specified instance' ) AND ( SIZEOF ( QUERY ( pdor &lt;* USEDIN ( pd , 'PRODUCT_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.' +'OCCURRENCE' ) | 'PRODUCT_OCCURRENCE_MIM.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor. occurrence_usage ) ) ) = 0 ) ) ) = 0">
      </where>

    </rule>

    <rule
      name="restrict_part_occurrence_category"
      appliesto="product_definition">
      <algorithm>
LOCAL
  part_occurrences: SET OF product_definition := [];
END_LOCAL;
  part_occurrences :=  QUERY( pd &lt;* product_definition |(pd.frame_of_reference.name = 'part occurrence'));
      </algorithm>

      <where
        label="WR1"
        expression="SIZEOF( QUERY( pd &lt;* part_occurrences | (SIZEOF( QUERY( prpc &lt;* USEDIN(pd.formation.of_product, 'PRODUCT_OCCURRENCE_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |   prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0">
      </where>

    </rule>

    <function
      name="types_of_product">
      <parameter
        name="obj">
        <typename
          name="product"/>
      </parameter>
      <aggregate
        type="SET"/>
      <builtintype
        type="STRING"/>
      <algorithm>
LOCAL
  category_assignments: BAG OF product_related_product_category;
  categories: SET OF STRING:=[];
  i: INTEGER;
END_LOCAL;

category_assignments := USEDIN(obj,'PRODUCT_OCCURRENCE_MIM.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
   
REPEAT i := 1 TO HIINDEX(category_assignments) BY 1;
   categories := categories + category_assignments[i].category.name;
END_REPEAT;

RETURN(categories);
      </algorithm>

    </function>

  </schema>

</express>
