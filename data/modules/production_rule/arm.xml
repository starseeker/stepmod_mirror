<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="production_rule_arm schema_instance"/>
   <schema name="Production_rule_arm">
      <interface kind="use" schema="Specification_document_arm"/>
      <interface kind="use" schema="Software_arm"/>
      <interface kind="use" schema="Date_time_assignment_arm"/>
      <interface kind="use" schema="Activity_arm"/>
      <interface kind="use" schema="Identification_assignment_arm"/>
      <interface kind="use" schema="Product_identification_arm"/>
      <interface kind="reference" schema="Product_identification_arm">
         <interfaced.item name="types_of_product"/>
      </interface>
      <type name="built_in_functions">
         <enumeration extensible="YES" items="attr_val"/>
      </type>
      <type name="clause_select">
         <select selectitems="Simple_clause Complex_clause"/>
      </type>
      <type name="constants">
         <select extensible="YES" selectitems="pr_number pr_string pr_logical"/>
      </type>
      <type name="expression_syntax">
         <enumeration extensible="YES" items="express"/>
      </type>
      <type name="function_symbol">
         <select selectitems="pr_string built_in_functions"/>
      </type>
      <type name="pr_identification_item">
         <select basedon="identification_item" selectitems="Rule_set"/>
      </type>
      <type name="pr_logical">
         <builtintype type="LOGICAL"/>
      </type>
      <type name="pr_number">
         <builtintype type="NUMBER"/>
      </type>
      <type name="pr_string">
         <builtintype type="STRING"/>
      </type>
      <type name="predicate_symbol">
         <builtintype type="STRING"/>
      </type>
      <type name="scope_select">
         <select selectitems="Rule_definition Rule_set Rule_set_group"/>
      </type>
      <type name="term_select">
         <select selectitems="Symbol constants Func Scalar_variable Row_value Row_variable"/>
      </type>
      <entity name="Abstract_variable" abstract.supertype="YES" super.expression="ONEOF (Scalar_variable, Row_variable)">
         <explicit name="name">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="scope">
            <typename name="scope_select"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="name"/>
            <unique.attribute attribute="scope"/>
         </unique>
      </entity>
      <entity name="Atomic_formula" abstract.supertype="YES" super.expression="ONEOF (Rule_condition, Ground_fact)">
         <explicit name="predicate_symbol">
            <typename name="predicate_symbol"/>
         </explicit>
         <explicit name="terms">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="term_select"/>
         </explicit>
      </entity>
      <entity name="Attribute_assertion" supertypes="Fact_type">
         <explicit name="entity_type">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="attribute">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Back_chaining_rule" supertypes="Rule_definition">
         <explicit name="head">
            <typename name="Rule_condition"/>
         </explicit>
         <explicit name="body">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="Rule_condition"/>
         </explicit>
         <where label="WR1" expression="SELF.head.positive = TRUE"/>
         <where label="WR2" expression="local_vars_of(SELF.head) &lt;= local_vars_of(SELF.body)"/>
      </entity>
      <entity name="Complex_clause" abstract.supertype="YES" super.expression="ONEOF (Complex_conjunctive_clause, Complex_disjunctive_clause)">
         <explicit name="clauses">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="clause_select"/>
         </explicit>
      </entity>
      <entity name="Complex_conjunctive_clause" supertypes="Complex_clause"/>
      <entity name="Complex_disjunctive_clause" supertypes="Complex_clause"/>
      <entity name="Entity_assertion" supertypes="Fact_type"/>
      <entity name="Enum_reference_prefix">
         <explicit name="prefix">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Extent">
         <explicit name="source">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="query_expression">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="syntax" optional="YES">
            <typename name="expression_syntax"/>
         </explicit>
      </entity>
      <entity name="Fact_type" abstract.supertype="YES" super.expression="ONEOF (Entity_assertion, Attribute_assertion)">
         <explicit name="source">
            <typename name="Extent"/>
         </explicit>
         <explicit name="predicate_symbol">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Forward_chaining_rule" supertypes="Rule_definition">
         <explicit name="premise">
            <typename name="clause_select"/>
         </explicit>
         <explicit name="conclusion">
            <typename name="Literal_conjunction"/>
         </explicit>
         <where label="WR1" expression="local_vars_of(SELF.conclusion) &lt;= local_vars_of(SELF.premise)"/>
      </entity>
      <entity name="Func">
         <explicit name="func_sym">
            <typename name="function_symbol"/>
         </explicit>
         <explicit name="terms">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="term_select"/>
         </explicit>
      </entity>
      <entity name="Global_assignment">
         <explicit name="variable">
            <typename name="Abstract_variable"/>
         </explicit>
         <explicit name="val">
            <typename name="term_select"/>
         </explicit>
         <where label="WR1" expression="NOT(contains_variable(SELF.val))"/>
      </entity>
      <entity name="Ground_fact" supertypes="Atomic_formula">
         <where label="WR1" expression="SIZEOF(QUERY(r &lt;* SELF\Atomic_formula.terms | contains_variable(r))) = 0"/>
      </entity>
      <entity name="Literal_conjunction" supertypes="Simple_clause"/>
      <entity name="Literal_disjunction" supertypes="Simple_clause"/>
      <entity name="Row_value">
         <explicit name="values">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="term_select"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(v &lt;* SELF.values | contains_variable(v))) = 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(v &lt;* SELF.values | 'PRODUCTION_RULE_ARM.ROW_VALUE' IN TYPEOF(v))) = 0"/>
      </entity>
      <entity name="Row_variable" supertypes="Abstract_variable"/>
      <entity name="Rule_action" abstract.supertype="YES" super.expression="ONEOF (Rule_submission, Rule_adoption, Rule_rejection, Rule_supersedence, Rule_creation, Rule_expiration, Rule_change_request, Rule_request, Rule_modification)">
         <explicit name="subject_rule">
            <typename name="Rule_version"/>
         </explicit>
         <derived name="subject_action_assignment" expression="bag_to_set(QUERY(temp &lt;* USEDIN ( SELF , 'PERSON_ORGANIZATION_ASSIGNMENT_ARM.' + &#10;                                       'ORGANIZATION_OR_PERSON_IN_ORGANIZATION_ASSIGNMENT.ITEMS' ) &#10;                    | ( temp.role = 'subject action assignment')))">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Organization_or_person_in_organization_assignment"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="subject_rule"/>
            <unique.attribute attribute="subject_action_assignment"/>
         </unique>
         <where label="WR1" expression="EXISTS (subject_action_assignment) AND (SIZEOF(subject_action_assignment) = 1 )"/>
      </entity>
      <entity name="Rule_adoption" supertypes="Rule_action"/>
      <entity name="Rule_change_request" supertypes="Rule_action">
         <explicit name="change_reason">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Rule_condition" supertypes="Atomic_formula">
         <explicit name="positive">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="Rule_creation" supertypes="Rule_action"/>
      <entity name="Rule_definition" abstract.supertype="YES" supertypes="Rule_software_definition" super.expression="ONEOF (Forward_chaining_rule, Back_chaining_rule)"/>
      <entity name="Rule_expiration" supertypes="Rule_action">
         <explicit name="expiration_rationale">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Rule_justification" supertypes="Rule_action">
         <explicit name="justified_action">
            <typename name="Rule_action"/>
         </explicit>
         <explicit name="justification_rationale">
            <builtintype type="STRING"/>
         </explicit>
         <where label="WR1" expression="SELF &lt;&gt; justified_action"/>
      </entity>
      <entity name="Rule_modification" supertypes="Rule_action">
         <explicit name="modification_rationale">
            <typename name="Rule_change_request"/>
         </explicit>
      </entity>
      <entity name="Rule_priority">
         <explicit name="priority">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="prioritized_rule">
            <typename name="Rule_definition"/>
         </explicit>
         <where label="WR1" expression="priority &gt;= 0"/>
      </entity>
      <entity name="Rule_product" supertypes="Software">
         <where label="WR1" expression="SIZEOF ( [ 'rule' ] * types_of_product ( SELF ) ) = 1"/>
      </entity>
      <entity name="Rule_rejection" supertypes="Rule_action">
         <explicit name="rejection_reason">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Rule_request" supertypes="Rule_action"/>
      <entity name="Rule_set" supertypes="Rule_software_definition">
         <explicit name="engine">
            <typename name="Language_reference_manual"/>
         </explicit>
         <explicit name="conflict_resolution_strategy" optional="YES">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="rule_member">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="Rule_priority"/>
         </explicit>
         <inverse name="purpose" entity="Identification_assignment" attribute="items"/>
         <where label="WR1" expression="purpose.role = 'purpose'"/>
      </entity>
      <entity name="Rule_set_group" supertypes="Rule_software_definition">
         <explicit name="elements">
            <aggregate type="SET" lower="2" upper="?"/>
            <typename name="Rule_set"/>
         </explicit>
      </entity>
      <entity name="Rule_software_definition" supertypes="Software_definition" super.expression="ONEOF (Rule_definition, Rule_set_group, Rule_set)">
         <explicit name="defined_version">
            <typename name="Rule_version"/>
            <redeclaration entity-ref="Product_view_definition"/>
         </explicit>
      </entity>
      <entity name="Rule_submission" supertypes="Rule_action">
         <explicit name="submission_rationale">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="Rule_supersedence" supertypes="Rule_action">
         <explicit name="superseded_rule">
            <typename name="Rule_version"/>
         </explicit>
      </entity>
      <entity name="Rule_version" supertypes="Software_version">
         <explicit name="of_product">
            <typename name="Rule_product"/>
            <redeclaration entity-ref="Product_version"/>
         </explicit>
         <inverse name="management_action" entity="Rule_action" attribute="subject_rule">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <inverse name="product_definition" entity="Rule_software_definition" attribute="defined_version">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="Scalar_variable" supertypes="Abstract_variable"/>
      <entity name="Simple_clause" abstract.supertype="YES" super.expression="ONEOF (Literal_conjunction, Literal_disjunction)">
         <explicit name="formulas">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="Rule_condition"/>
         </explicit>
      </entity>
      <entity name="Symbol">
         <explicit name="name">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <rule name="max_one_entity_prefix" appliesto="">
         <where label="WR1" expression="SIZEOF(QUERY(x &lt;* Enum_reference_prefix | TRUE)) &lt;= 1"/>
      </rule>
      <rule name="rule_software_definition_constraint" appliesto="">
         <where label="WR1" expression="SIZEOF (QUERY ( pvd &lt;* Product_view_definition | ( NOT('PRODUCT_RULE_ARM.' + 'RULE_SOFTWARE_DEFINITION' &#10;                       IN TYPEOF(pvd))) &#10;                       AND ('PRODUCT_RULE_ARM.' + 'RULE_VERSION' IN TYPEOF (pvd . defined_version)))) = 0"/>
      </rule>
      <rule name="rule_version_constraint" appliesto="">
         <where label="WR1" expression="SIZEOF (QUERY(pv &lt;* Product_version | (NOT('PRODUCT_RULE_ARM.' + 'RULE_VERSION' IN TYPEOF(pv))) &#10;                      AND ( 'PRODUCT_RULE_ARM.' + 'RULE_PRODUCT' IN TYPEOF(pv.of_product)))) = 0"/>
      </rule>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate type="BAG" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      the_set : SET OF GENERIC : intype := [];
      i       : INTEGER;
    END_LOCAL;

    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);</algorithm>
      </function>
      <function name="contains_variable">
         <parameter name="x">
            <typename name="term_select"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ('PRODUCTION_RULE_ARM.ABSTRACT_VARIABLE' IN TYPEOF(x)) THEN RETURN (TRUE);
      ELSE IF (('PRODUCTION_RULE_ARM.FUNC' IN TYPEOF(X)) AND
              (SIZEOF(QUERY(y &lt;* x.terms | contains_variable(y))) &gt; 0)) 
              THEN RETURN (TRUE);
              ELSE RETURN (FALSE);
           END_IF;
  END_IF;</algorithm>
      </function>
      <function name="local_vars_aux">
         <parameter name="thing">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="accum">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="Scalar_variable"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="Scalar_variable"/>
         <algorithm>LOCAL i,j,k : INTEGER; END_LOCAL;
  IF (('PRODUCTION_RULE_ARM.ABSTRACT_VARIABLE' IN TYPEOF(thing)) AND 
      ('PRODUCTION_RULE_ARM.RULE_DEFINITION' IN (TYPEOF(thing.scope))))
   THEN accum := accum + thing;
   ELSE IF ('PRODUCTION_RULE_ARM.RULE_CONDITION' IN TYPEOF(thing))
        THEN REPEAT i := 1 TO HIINDEX(thing\Atomic_formula.terms);
                accum := local_vars_aux(thing\Atomic_formula.terms[i],accum);
             END_REPEAT;
        ELSE IF ('PRODUCTION_RULE_ARM.SIMPLE_CLAUSE' IN TYPEOF(thing))
             THEN REPEAT j := 1 TO HIINDEX(thing.formulas);
                        accum := local_vars_aux(thing.formulas[j],accum);
                  END_REPEAT;
             ELSE IF ('PRODUCTION_RULE_ARM.COMPLEX_CLAUSE' IN TYPEOF(thing))
                  THEN REPEAT k := 1 TO HIINDEX(thing.clauses);
                        accum := local_vars_aux(thing.clauses[k],accum);
                       END_REPEAT;
                  END_IF;
             END_IF;
        END_IF;
  END_IF;
  RETURN(accum);</algorithm>
      </function>
      <function name="local_vars_of">
         <parameter name="thing">
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="Scalar_variable"/>
         <algorithm>LOCAL
    accum : SET [0:?] OF Scalar_variable := [];
  END_LOCAL;
  RETURN (local_vars_aux(thing, accum));</algorithm>
      </function>
   </schema>
</express>
