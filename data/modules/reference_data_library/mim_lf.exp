(*
 $Id: mim_lf.exp,v 1.1 2002/10/29 21:21:31 davidleal Exp $
 ISO TC184/SC4/WG12 N1221 - ISO/CD-TS 10303-1213 Reference data library - EXPRESS MIM Long form
*) 


(* ===================================================================================== *)
(* Long form schema generated by The EXPRESS Data Manager  compiler version 9.5B3        *)
(* Fri Dec 12 14:58:43 2003                                                              *)
(* The schema is converted from ISO10303 P11-2003 to ISO10303 P11-1994                   *)
(* ===================================================================================== *)

SCHEMA Reference_data_library_mim_lf;


CONSTANT

  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();
  schema_prefix : STRING := 'REFERENCE_DATA_LIBRARY_MIM_LF.';

  the_empty_space : finite_space := make_finite_space([]);

END_CONSTANT;

TYPE action_items = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_person,
   class_of_product,
   drawing_revision_class_of_document,
   drawing_sheet_revision_class_of_document,
   organization_type,
   property_condition_for_activity,
   property_condition_for_product,
   schematic_element,
   symbolization_by_schematic_element);
END_TYPE;


TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE;

TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE approval_item = SELECT (
   drawing_revision,
   drawing_sheet_revision);
END_TYPE;


TYPE area_measure = REAL;
END_TYPE;

(* Pruned unused type: area_or_view  *)


TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;

TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;

TYPE axis2_placement = SELECT (
   axis2_placement_2d);
END_TYPE;


 TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
 END_TYPE;

TYPE box_characteristic_select = SELECT
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle);
END_TYPE;

TYPE box_height = positive_ratio_measure;
END_TYPE;

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

TYPE  box_slant_angle = plane_angle_measure;
END_TYPE;

TYPE box_width = positive_ratio_measure;
END_TYPE;

TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE character_spacing_select = SELECT (
   length_measure,
   ratio_measure,
   measure_with_unit,
   descriptive_measure);
END_TYPE;


TYPE character_style_select = SELECT (
   text_style_for_defined_font);
END_TYPE;


TYPE characterized_action_definition = SELECT (
   action,
   action_method,
   action_relationship);
END_TYPE;


(* Zapped by David Leal *)
TYPE characterized_definition = SELECT (
   characterized_product_definition);
END_TYPE; 

TYPE characterized_product_definition = SELECT (
   product_definition);
END_TYPE; 


(* Pruned unused type: class_of_activity_relationship  *)


(* Pruned unused type: class_of_product_relationship  *)


TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE count_measure = NUMBER;
END_TYPE;

TYPE curve_font_or_scaled_curve_font_select = SELECT (
   curve_style_font_select);
END_TYPE;


(* Pruned unused type: curve_or_render  *)


TYPE curve_style_font_select = SELECT
  (curve_style_font,
   pre_defined_curve_font,
   externally_defined_curve_font);
END_TYPE;

TYPE date_and_time_item = SELECT (
   approval_person_organization);
END_TYPE;


(* Pruned unused type: date_and_time_item_approval  *)


TYPE date_item = SELECT (
   approval_person_organization);
END_TYPE;


(* Pruned unused type: date_item_approval  *)


(* Pruned unused type: date_time_or_event_occurrence  *)


TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE defined_symbol_select = SELECT
  (pre_defined_symbol,
   externally_defined_symbol);
END_TYPE;

TYPE derived_property_select = SELECT (
   action_property,
   property_definition);
END_TYPE;


TYPE description_attribute_select = SELECT (
   application_context,
   approval_role,
   date_role,
   date_time_role,
   external_source,
   organization_role,
   person_and_organization,
   person_and_organization_role,
   person_role,
   property_definition_representation,
   representation);
END_TYPE;


TYPE descriptive_measure = STRING;
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE draughting_approval_item = approval_item;
END_TYPE;


TYPE draughting_callout_element = SELECT
  (annotation_text_occurrence, 
   annotation_symbol_occurrence,
   annotation_curve_occurrence);
END_TYPE;

TYPE draughting_titled_item = SELECT 
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE electric_current_measure = REAL;
END_TYPE;

TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;

TYPE external_identification_item = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_person,
   class_of_product,
   drawing_revision_class_of_document,
   drawing_sheet_revision_class_of_document,
   implicit_schematic_element_definition,
   organization_type,
   property_condition_for_activity,
   property_condition_for_product,
   schematic_element,
   symbolization_by_schematic_element);
END_TYPE;


(* Pruned unused type: externally_identified_rdl_class_or_relationship  *)


(* Pruned unused type: externally_identified_schematic_element_definition  *)


TYPE fill_area_style_tile_shape_select = SELECT (
   fill_area_style_tile_symbol_with_style);
END_TYPE;


TYPE fill_style_select = SELECT (
   fill_area_style_colour,
   externally_defined_tile_style,
   fill_area_style_tiles,
   externally_defined_hatch_style,
   fill_area_style_hatching);
END_TYPE;


TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE geometric_set_select = SELECT (
   point,
   curve);
END_TYPE;


TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE;

TYPE id_attribute_select = SELECT (
   action,
   address,
   application_context,
   group,
   product_category,
   property_definition,
   representation);
END_TYPE;


TYPE identifier = STRING;
END_TYPE;

TYPE invisibility_context = SELECT (
   presentation_representation,
   presentation_set);
END_TYPE;


TYPE invisible_item = SELECT (
   styled_item,
   representation);
END_TYPE;


TYPE involved_class_select = action_items;
END_TYPE;


 TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
 END_TYPE;

TYPE label = STRING;
END_TYPE;

(* Pruned unused type: layered_item  *)


TYPE length_measure = REAL;
END_TYPE;

(* Pruned unused type: library_involved_class_select  *)


(* Pruned unused type: library_symbolized_class_select  *)


(* Pruned unused type: library_symbolized_item_select  *)


TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;

TYPE maths_boolean = BOOLEAN;
END_TYPE;

TYPE maths_enum_atom = SELECT (
   elementary_space_enumerators,
   open_closed);
END_TYPE;


(* Pruned unused type: maths_expression  *)


TYPE maths_integer = INTEGER;
END_TYPE;


TYPE maths_real = REAL;
END_TYPE;

TYPE maths_simple_atom = SELECT (
   maths_real,
   maths_integer,
   maths_boolean);
END_TYPE;


(* Pruned unused type: maths_space_or_function  *)


TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;

TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE;

TYPE name_attribute_select = SELECT (
   address,
   derived_unit,
   person_and_organization,
   product_definition,
   property_definition_representation);
END_TYPE;


TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;

TYPE null_style = ENUMERATION OF
  (null);
END_TYPE;

TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;

TYPE organization_type_item = SELECT (
   organization);
END_TYPE;


TYPE parameter_value = REAL;
END_TYPE;

TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE;

TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE presentable_text = STRING;
END_TYPE;

TYPE presentation_representation_select = SELECT 
  (presentation_representation,
   presentation_set);
END_TYPE;

TYPE presentation_size_assignment_select = SELECT 
  (presentation_view,
   presentation_area,
   area_in_set);
END_TYPE;

TYPE presentation_style_select = SELECT (
   curve_style,
   symbol_style,
   fill_area_style,
   text_style,
   null_style);
END_TYPE;


TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

(* Pruned unused type: real_interval  *)


TYPE relationship_select = space_context_select;
WHERE
  wr1 : NOT ('REFERENCE_DATA_LIBRARY_MIM.CLASS_OF_COMPOSITION_OF_PRODUCT' IN TYPEOF(SELF));
  wr2 : NOT ('REFERENCE_DATA_LIBRARY_MIM.CLASS_OF_CONNECTION_OF_PRODUCT' IN TYPEOF(SELF));
  wr3 : NOT ('REFERENCE_DATA_LIBRARY_MIM.CLASS_OF_CONTAINMENT_OF_PRODUCT' IN TYPEOF(SELF));
  wr4 : NOT ('REFERENCE_DATA_LIBRARY_MIM.CLASS_OF_INVOLVEMENT_OF_PRODUCT_IN_CONNECTION' IN TYPEOF(SELF));
END_TYPE;


TYPE represented_definition = SELECT (
   general_property,
   property_definition);
END_TYPE;


TYPE role_select = SELECT (
   action_assignment,
   approval_assignment,
   approval_date_time,
   contract_assignment,
   document_reference,
   security_classification_assignment);
END_TYPE;


TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE;

TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE;

TYPE size_select = SELECT (
   positive_length_measure,
   measure_with_unit,
   descriptive_measure);
END_TYPE;


TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE source_item = SELECT (
   identifier);
END_TYPE;


TYPE space_context_select = SELECT (
   action,
   action_method,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   general_property,
   product_definition,
   representation_item);
END_TYPE;


TYPE style_context_select = SELECT (
   group,
   representation,
   representation_item,
   presentation_set);
END_TYPE;


(* Pruned unused type: supported_item  *)


TYPE symbol_style_select = SELECT (
   symbol_colour);
END_TYPE;


TYPE symbolized_class_select = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_person,
   class_of_product,
   drawing_revision_class_of_document,
   drawing_sheet_revision_class_of_document,
   organization_type,
   property_condition_for_activity,
   property_condition_for_product,
   schematic_element,
   symbolization_by_schematic_element);
END_TYPE;


TYPE symbolized_item_select = SELECT (
   class_of_activity,
   class_of_composition_of_activity,
   class_of_composition_of_product,
   class_of_connection_of_activity,
   class_of_connection_of_product,
   class_of_containment_of_product,
   class_of_involvement_in_activity,
   class_of_involvement_of_product_in_connection,
   class_of_person,
   class_of_product,
   drawing_revision_class_of_document,
   drawing_sheet_revision_class_of_document,
   organization_type,
   property_condition_for_activity,
   property_condition_for_product,
   schematic_element,
   symbolization_by_schematic_element);
END_TYPE;


TYPE text = STRING;
END_TYPE;

TYPE text_alignment = label;
END_TYPE;

TYPE text_delineation = label;
END_TYPE;

TYPE text_or_character = SELECT (
   annotation_text,
   composite_text,
   text_literal);
END_TYPE;


TYPE text_path = ENUMERATION OF
  (left,
   right,
   up,
   down);
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_measure = REAL;
END_TYPE;

(* Pruned unused type: transformation  *)


 TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
 END_TYPE;

 TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
 END_TYPE;

 TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;

(* Pruned unused type: tuple_space  *)


TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE;

TYPE value_context_select = SELECT (
   action,
   action_method,
   general_property,
   product_definition,
   representation_item);
END_TYPE;


 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

TYPE volume_measure = REAL;
END_TYPE;

TYPE year_number = INTEGER;
END_TYPE;

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY annotation_curve_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.CURVE' IN TYPEOF (SELF\styled_item.item);

END_ENTITY;

ENTITY annotation_fill_area
  SUBTYPE OF (geometric_representation_item);
  boundaries : SET [1:?] OF curve;
END_ENTITY;

ENTITY annotation_fill_area_occurrence
  SUBTYPE OF (annotation_occurrence);
  fill_style_target : point;
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_FILL_AREA' IN

         TYPEOF (SELF.item);
END_ENTITY;

ENTITY annotation_occurrence
  SUPERTYPE OF (ONEOF (
              ANNOTATION_CURVE_OCCURRENCE,
              ANNOTATION_FILL_AREA_OCCURRENCE,
              ANNOTATION_TEXT_OCCURRENCE,
              ANNOTATION_SYMBOL_OCCURRENCE))
  SUBTYPE OF (styled_item);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN

          TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_subfigure_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (QUERY (sty <* SELF.styles |
         NOT (SIZEOF (sty.styles) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (sty <* SELF.styles |
         NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.NULL_STYLE'
               IN TYPEOF (sty.styles[1]))       ))=0;
  WR3: ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL'
           IN TYPEOF (SELF.item));
  WR4: ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAUGHTING_SUBFIGURE_REPRESENTATION'

           IN TYPEOF
           (SELF.item\mapped_item.mapping_source.mapped_representation));
END_ENTITY;

ENTITY annotation_symbol
  SUBTYPE OF(mapped_item);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_REPRESENTATION_MAP' IN
         TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_TARGET' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN

         TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_symbol_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF(
         ['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL',
          'REFERENCE_DATA_LIBRARY_MIM_LF.DEFINED_SYMBOL'] *

         TYPEOF(SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_text
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT' IN
       TYPEOF( SELF\mapped_item.mapping_target);
  WR2: 'REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_STRING_REPRESENTATION' IN
       TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
  WR3: 'REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN

       TYPEOF( SELF);
END_ENTITY;

ENTITY annotation_text_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF (
         ['REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL',
          'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT',
          'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_CHARACTER',
          'REFERENCE_DATA_LIBRARY_MIM_LF.DEFINED_CHARACTER_GLYPH',
          'REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'] *

         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET [1:?] OF approval_item;
END_ENTITY;

ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;

ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

ENTITY applied_organization_type_assignment
  SUBTYPE OF (organization_type_assignment);
  items : SET[1:?] OF organization_type_item;
END_ENTITY;

ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

ENTITY area_in_set;
  area   : presentation_area;
  in_set : presentation_set;
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF (
              UNIFORM_CURVE,
              B_SPLINE_CURVE_WITH_KNOTS,
              QUASI_UNIFORM_CURVE,
              BEZIER_CURVE)
              ANDOR 
              RATIONAL_B_SPLINE_CURVE)
  SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                         OF cartesian_point 
                                  := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
 WHERE
   WR1: ('REFERENCE_DATA_LIBRARY_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('REFERENCE_DATA_LIBRARY_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('REFERENCE_DATA_LIBRARY_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('REFERENCE_DATA_LIBRARY_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));

 END_ENTITY;

 ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

 ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

 ENTITY bounded_curve
   SUPERTYPE OF (ONEOF (
              POLYLINE,
              B_SPLINE_CURVE,
              TRIMMED_CURVE,
              COMPOSITE_CURVE))
  SUBTYPE OF (curve);
 END_ENTITY;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY camera_image
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.CAMERA_USAGE'
       IN TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'REFERENCE_DATA_LIBRARY_MIM_LF.PLANAR_BOX'
       IN TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'

       IN TYPEOF (SELF);
END_ENTITY;

ENTITY cardinality_of_related_class
  SUBTYPE OF (maths_space_context);
  SELF\maths_space_context.physical_space : relationship_select;
END_ENTITY;

ENTITY cardinality_of_relating_class
  SUBTYPE OF (maths_space_context);
  SELF\maths_space_context.physical_space : relationship_select;
END_ENTITY;

 ENTITY cartesian_point
   
  SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

 ENTITY cartesian_transformation_operator
   
  SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;

ENTITY class
  SUPERTYPE OF (ONEOF (
              CLASS_BY_EXTENSION,
              CLASS_BY_INTENSION))
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_of_activity
  SUBTYPE OF (executed_action, class);
END_ENTITY;

ENTITY class_of_composition_of_activity
  SUBTYPE OF (action_relationship, class);
  SELF\action_relationship.relating_action : class_of_activity;
  SELF\action_relationship.related_action : class_of_activity;
END_ENTITY;

ENTITY class_of_composition_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_connection_of_activity
  SUBTYPE OF (action_relationship, class);
  SELF\action_relationship.relating_action : class_of_activity;
  SELF\action_relationship.related_action : class_of_activity;
END_ENTITY;

ENTITY class_of_connection_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_connection_of_product_with_involvements
  SUBTYPE OF (class_of_connection_of_product, class_of_product);
END_ENTITY;

ENTITY class_of_containment_of_product
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_product;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_involvement_in_activity
  SUBTYPE OF (applied_action_assignment, class);
  SELF\action_assignment.assigned_action : class_of_activity;
  SELF\applied_action_assignment.items : SET[1:1] OF involved_class_select;
END_ENTITY;

ENTITY class_of_involvement_of_product_in_connection
  SUBTYPE OF (product_definition_formation_relationship, class);
  SELF\product_definition_formation_relationship.relating_product_definition_formation : class_of_connection_of_product_with_involvements;
  SELF\product_definition_formation_relationship.related_product_definition_formation : class_of_product;
END_ENTITY;

ENTITY class_of_person
  SUBTYPE OF (person_type, class);
END_ENTITY;

ENTITY class_of_product
  SUBTYPE OF (product_definition_formation, class);
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY complement;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  set_1       : class;
  set_2       : class;
  universe    : class;
WHERE
  complement_different : NOT identical_sets(set_1, set_2);
END_ENTITY;

 ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
 END_ENTITY;

 ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('REFERENCE_DATA_LIBRARY_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));

 END_ENTITY;

ENTITY composite_text
  SUBTYPE OF (geometric_representation_item);
  collected_text : SET[2:?] of text_or_character;
WHERE
  WR1: acyclic_composite_text( SELF, SELF.collected_text);
END_ENTITY;

ENTITY composite_text_with_associated_curves
  SUBTYPE OF (composite_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY composite_text_with_blanking_box
  SUBTYPE OF (composite_text);
  blanking : planar_box;
END_ENTITY;

ENTITY composite_text_with_extent
  SUBTYPE OF (composite_text);
  extent : planar_extent;
END_ENTITY;

ENTITY composition_of_schematic_element_occurrence
  SUBTYPE OF (mapped_item);
WHERE
  schematic_element_occurrence_as_part:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE' 
       IN TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  schematic_element_occurrence_as_whole:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE' 

       IN TYPEOF (using_representations(SELF));
END_ENTITY;

ENTITY compound_maths_space_context
  SUBTYPE OF (maths_space_context);
  components  :  LIST [2:?] OF maths_space_context;
END_ENTITY;

ENTITY condition_property
  SUBTYPE OF (general_property_association);
  SELF\general_property_association.base_definition : independent_property_definition;
WHERE
  link_to_condition: ('REFERENCE_DATA_LIBRARY_MIM_LF.PROPERTY_CONDITION_FOR_ACTIVITY' IN TYPEOF(SELF\general_property_association.derived_definition)) OR ('REFERENCE_DATA_LIBRARY_MIM_LF.PROPERTY_CONDITION_FOR_PRODUCT' IN TYPEOF(SELF\general_property_association.derived_definition));

END_ENTITY;

 ENTITY conic
   SUPERTYPE OF (ONEOF (
              CIRCLE,
              ELLIPSE,
              HYPERBOLA,
              PARABOLA))
  SUBTYPE OF (curve);
   position: axis2_placement;
 END_ENTITY;

ENTITY connection_of_schematic_element_occurrence
  SUBTYPE OF (mapped_item);
WHERE
  schematic_element_occurrence_as_side_1:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  schematic_element_occurrence_as_side_2:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE'

       IN TYPEOF (using_representations(SELF));
END_ENTITY;

ENTITY context_dependent_invisibility
  SUBTYPE OF (invisibility);
  presentation_context : invisibility_context;
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY curve
   SUPERTYPE OF (ONEOF (
              LINE,
              CONIC,
              OFFSET_CURVE_2D,
              CURVE_REPLICA))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

 ENTITY curve_replica
   SUBTYPE OF (curve);
   parent_curve   : curve;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_curve.dim;
   WR2: acyclic_curve_replica (SELF, parent_curve);
 END_ENTITY;

ENTITY curve_style;
  name         : label;
  curve_font   : curve_font_or_scaled_curve_font_select;
  curve_width  : size_select;
  curve_colour : colour;
END_ENTITY;

ENTITY curve_style_font;
  name         : label;
  pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;

ENTITY curve_style_font_pattern;
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

ENTITY date
  ;
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role : date_role;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY defined_maths_space_context
  SUBTYPE OF (maths_space_context);
END_ENTITY;

ENTITY defined_symbol
  SUBTYPE OF(geometric_representation_item);
  definition : defined_symbol_select;
  target     : symbol_target;
END_ENTITY;

ENTITY definition_of_schematic_element_occurrence
  SUBTYPE OF (mapped_item);
WHERE
  schematic_element_as_superset: 
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT' 
       IN TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  schematic_element_occurrence_as_subset:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE' 

       IN TYPEOF (using_representations(SELF));
END_ENTITY;

ENTITY derivation_of_schematic_element_definition
  SUBTYPE OF (mapped_item);
WHERE
  schematic_element_definition_as_base:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_DEFINITION'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  implicit_schematic_element_definition_as_derived:
    'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'IMPLICIT_SCHEMATIC_ELEMENT_DEFINITION'

       IN TYPEOF (using_representations(SELF));
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY draughting_annotation_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1:	-- curve_has_curve_style:
    (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
         AND ('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE_STYLE'
                 IN TYPEOF (sty.styles[1]))) )) = 0);
  WR2:	-- fill_area_has_fill_style:
    (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
      NOT ((SIZEOF (sty.styles) = 1)
        AND ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR3:	-- styled_fill_boundaries:
    (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (bound <*
                     SELF.item\annotation_fill_area.boundaries |
       NOT (SIZEOF (QUERY (si <*
                   USEDIN (bound, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                                  'STYLED_ITEM.ITEM') |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.' +
             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) > 0))) = 0);
  WR4:	-- symbol_has_symbol_style:
    (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)           AND
            (SIZEOF (TYPEOF (sty.styles[1]) *
                ['REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_STYLE',
                 'REFERENCE_DATA_LIBRARY_MIM_LF.NULL_STYLE']) = 1)) )) = 0);
  WR5:	-- allowable_symbol_representations:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL'
             IN TYPEOF(SELF.item)))) OR
         (SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.' +
                   'DRAUGHTING_SYMBOL_REPRESENTATION',
                  'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                  'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *
          TYPEOF (SELF.item\mapped_item.mapping_source.
                  mapped_representation)) = 1);
  WR6:	-- text_has_text_style:
    (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
        AND ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR7:	-- allowable_text:
     (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF))) OR
         (SIZEOF (TYPEOF(SELF.item) *
             ['REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT',
              'REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL']) = 1);
  WR8:	-- text_not_nested:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR    (SIZEOF (QUERY (tl <*
                   SELF.item\composite_text.collected_text |
             NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL' 
             IN TYPEOF (tl)) )) = 0);
  WR9:	-- text_alignment_literals:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL'
             IN TYPEOF (SELF.item)))) OR (SELF.item\text_literal.alignment 
             IN ['baseline left', 'baseline centre', 'baseline right']);
  WR10:	-- text_alignment_composites:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <* SELF.
                  item\composite_text.collected_text
             |('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL' IN TYPEOF(text))) |
          NOT (tl\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right']) )) = 0);
  WR11:	-- single_text_alignment:
    NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_alignment(SELF.item);
  WR12:	-- single_text_font:
    NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_font(SELF.item);
  WR13:	-- allowable_text_literals:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
               IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <*
            SELF.item\composite_text.collected_text |
            ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL' IN TYPEOF (text))) |
             NOT (SIZEOF (TYPEOF(tl) *
                  ['REFERENCE_DATA_LIBRARY_MIM_LF.' +
                   'TEXT_LITERAL_WITH_BLANKING_BOX',
                   'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0) )) = 0);
  WR14:	-- styled_text_literal_curves:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                   SELF.item\text_literal_with_associated_curves.
                   associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 
             'REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM.ITEM') |
        ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si)) )) > 0) )) = 0);
  WR15:	-- styled_composite_text_curves:
    (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
          (SIZEOF (QUERY (crv <*
                SELF.item\composite_text_with_associated_curves.
                associated_curves |
           NOT (SIZEOF (QUERY (si <*  USEDIN (crv,
                'REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM.ITEM') |
               ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'
           IN TYPEOF (si)) )) > 0) )) = 0);
WR16:	-- curve_style_has_width:
    SIZEOF (QUERY (cs <* QUERY (sty <* SELF.styles |
      ('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE_STYLE' IN TYPEOF (sty.styles[1])))
      | NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.LENGTH_MEASURE_WITH_UNIT'
        IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND
       ('REFERENCE_DATA_LIBRARY_MIM_LF.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (cs.styles[1]\curve_style.
        curve_width\measure_with_unit.value_component))))) = 0;
WR17:	-- tiling_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
      ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE'
          IN TYPEOF (sty.styles[1]))) |
      NOT ((SIZEOF (QUERY (fs <* fas.styles[1]\fill_area_style.fill_styles
                    | ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE_TILES'
                       IN TYPEOF (fs)))) <= 1)
       AND (SIZEOF (QUERY (fst <* QUERY (fs <*
                           fas.styles[1]\fill_area_style.fill_styles |
              ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs))) |
                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)
           )) = 0))
    )) = 0;
  WR18:	-- hatching_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
           ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE' 
            IN TYPEOF (sty.styles[1]))) |
             NOT (SIZEOF (QUERY (fsh <* QUERY (fs <*
                          fas.styles[1]\fill_area_style.fill_styles |
             ('REFERENCE_DATA_LIBRARY_MIM_LF.FILL_AREA_STYLE_HATCHING'
               IN TYPEOF (fs))) |
        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:
             fsh\fill_area_style_hatching.pattern_start)  )) = 0)  )) = 0;
  WR19:	-- text_style_constraint:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_STYLE' 
         IN TYPEOF(sty.styles[1]))) |
             NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.' +
                  'TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (ts.styles[1])))) = 0;
  WR20:	-- text_style_characteristics:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'

             IN TYPEOF (sty.styles[1]))) |
           NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.
                characteristics) = 4) )) = 0;
END_ENTITY;

ENTITY draughting_approval_assignment
  SUBTYPE OF (applied_approval_assignment);
(*  SELF\applied_approval_assignment.items : SET[1:?] OF draughting_approval_item; *)
END_ENTITY;

ENTITY draughting_callout
  SUBTYPE OF (geometric_representation_item);
  contents : SET [1:?] OF draughting_callout_element; 
END_ENTITY;

ENTITY draughting_drawing_revision
  SUBTYPE OF (drawing_revision);
WHERE
  WR1:	-- drawing_requires_sheets:
    (SIZEOF (USEDIN (SELF,
      'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET')) >= 1)
       AND 
    (SIZEOF (QUERY (ais <* USEDIN (SELF,
       'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') | 
        NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAWING_SHEET_REVISION'
        IN TYPEOF (ais.area))
    )) = 0);
  WR2:	 -- drawing_approval_has_date:
    SIZEOF (QUERY (app_ass <* USEDIN (SELF,
                         'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
          'REFERENCE_DATA_LIBRARY_MIM_LF.' +
          'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)
    )) = 0;
  WR3:	-- sheet_approval_has_date:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
           'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
           NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,
             'REFERENCE_DATA_LIBRARY_MIM_LF.' +
             'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
        NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
            'REFERENCE_DATA_LIBRARY_MIM_LF.' +
            'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)
      )) = 0)
    )) = 0;
  WR4:	-- drawing_approval_has_authorization:
    SIZEOF (QUERY (app_ass <* USEDIN (SELF,
                         'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
           'REFERENCE_DATA_LIBRARY_MIM_LF.' +
           'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)
    )) = 0;
  WR5:	-- sheet_approval_has_authorization:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
              NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,
                'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |
                NOT (SIZEOF (USEDIN (app_ass.assigned_approval,
                     'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                     'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)
              )) = 0)
    )) = 0;
  WR6:	-- drawing_title:
    SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                          'DRAUGHTING_TITLE.ITEMS')) <= 1;
  WR7:	-- sheet_title:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |   
             NOT (SIZEOF (USEDIN (ais.area,
                          'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                          'DRAUGHTING_TITLE.ITEMS')) <= 1)
    )) = 0;
  WR8:	-- allowable_items_of_sheet:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |   
            NOT (SIZEOF (QUERY (item <* ais.area.items |
            NOT (SIZEOF (TYPEOF(item) *
              ['REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM',
              'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM',
              'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT',
              'REFERENCE_DATA_LIBRARY_MIM_LF.PLANAR_BOX']) = 1)
      )) = 0)
    )) = 0;
  WR9:	-- sheet_contains_view_or_annotation:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
           'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
            NOT (SIZEOF (QUERY (item <* ais.area.items |
             (SIZEOF (TYPEOF(item) *
               ['REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM',
                'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM']) = 1)
      )) > 0)
    )) = 0;
  WR10:	-- planar_box_in_sheet:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
              NOT (SIZEOF (QUERY (p_b <* 
                QUERY (item <* ais.area.items |
                  ('REFERENCE_DATA_LIBRARY_MIM_LF.PLANAR_BOX' 
                   IN TYPEOF(item))) |
                   NOT (SIZEOF (USEDIN (p_b, 
                        'REFERENCE_DATA_LIBRARY_MIM_LF.PRESENTATION_SIZE.SIZE')  ) = 1)
      )) = 0)
    )) = 0;
  WR11:	 -- sheets_contain_views:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
           'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
            NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
           ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
           IN TYPEOF(item))) |
             NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.PRESENTATION_VIEW'
               IN TYPEOF(mi.mapping_source.mapped_representation))
      )) = 0)
    )) = 0;
  WR12:	 -- sheets_contain_placements:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
              NOT (SIZEOF (QUERY (a2p <* QUERY (item <* ais.area.items |
               ('REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT'
              IN TYPEOF(item))) |
                NOT (SIZEOF (USEDIN (a2p,
                             'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                             'MAPPED_ITEM.MAPPING_TARGET')) > 0)
      )) = 0)
    )) = 0;
  WR13:	-- sheets_have_unique_context:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
              NOT (SIZEOF (ais.area.context_of_items.
                   representations_in_context) = 1)   )) = 0;
  WR14:	-- views_presented_once:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
           'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
             ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
                 IN TYPEOF(item))) |
        NOT (SIZEOF (USEDIN (mi.mapping_source.mapped_representation,
                        'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) = 1)
      )) = 0)
    )) = 0;
  WR15:	-- allowable_items_of_view:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
             NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
               ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
               IN TYPEOF(item))) |
                 NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.
                              mapped_representation.items |
                   NOT (SIZEOF (TYPEOF(pv_item) *
                     ['REFERENCE_DATA_LIBRARY_MIM_LF.' +
                      'STYLED_ITEM',
                      'REFERENCE_DATA_LIBRARY_MIM_LF.CAMERA_IMAGE',
                      'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                      'AXIS2_PLACEMENT']) = 1)
        )) = 0)
      )) = 0)
    )) = 0;
  WR16:	-- views_contain_one_projection:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
            NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
                ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
                IN TYPEOF(item))) |
                NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.
                             mapped_representation.items |
                    ('REFERENCE_DATA_LIBRARY_MIM_LF.CAMERA_IMAGE'
                    IN TYPEOF(pv_item))
                )) = 1)
            )) = 0)
    )) = 0;
  WR17:	-- views_contain_one_placement:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
              NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
                ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
                IN TYPEOF(item))) |
                NOT (SIZEOF (QUERY (a2p <* QUERY (pv_item <* mi.mapping_source.
                       mapped_representation.items |
                    ('REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT'
                      IN TYPEOF(pv_item))) |
                     ('REFERENCE_DATA_LIBRARY_MIM_LF.' +
                      'REPRESENTATION_MAP.MAPPING_SOURCE' IN ROLESOF (a2p))
                  )) = 1)
              )) = 0)
    )) = 0;
  WR18:	-- views_have_unique_context:
    SIZEOF (QUERY (ais <* USEDIN (SELF,
            'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET.IN_SET') |
             NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |
                 ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'

                 IN TYPEOF(item))) |
        NOT (SIZEOF (mi.mapping_source.
                     mapped_representation.context_of_items.
                     representations_in_context) = 1)
      )) = 0)
    )) = 0;
END_ENTITY;

ENTITY draughting_model
  SUBTYPE OF (representation);
UNIQUE
  unique_id: SELF\representation.name;
WHERE
  valid_draughting_model_items:
     SIZEOF(QUERY ( it <* SELF.items |
         (NOT (SIZEOF([ 'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM',
                        'REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM',
                        'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT'] * TYPEOF(it)) = 1)) )) = 0;
  valid_mapped_items:
     SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) ) |
         (NOT (SIZEOF(['REFERENCE_DATA_LIBRARY_MIM_LF.SHAPE_REPRESENTATION',
                       'REFERENCE_DATA_LIBRARY_MIM_LF.DRAUGHTING_MODEL'] * TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) = 1 )) )) = 0;
  valid_use_of_style:
     SIZEOF(QUERY ( smi <* QUERY ( si <* QUERY ( it <* SELF.items |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM' IN TYPEOF(it)) ) |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM' IN TYPEOF(si\styled_item.item)) ) |
         (NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.SHAPE_REPRESENTATION' 
         IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source.mapped_representation)) AND
         (SIZEOF(QUERY ( sty <* smi\styled_item.styles |
         (NOT (SIZEOF(QUERY ( psa <* sty.styles |
         (NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE_STYLE' IN TYPEOF(psa))) )) = 1 )) )) = 1))) )) = 0;

END_ENTITY;

ENTITY draughting_subfigure_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_OCCURRENCE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.DRAUGHTING_CALLOUT',
              'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT']
               * TYPEOF (item)) = 1))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
         SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_OCCURRENCE',
                  'REFERENCE_DATA_LIBRARY_MIM_LF.DRAUGHTING_CALLOUT'] *
           TYPEOF (item)) = 1)) >= 1;
  WR3: SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) | 
            NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
          | NOT (SIZEOF (QUERY (aso <*
            USEDIN (a_s, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 
                         'STYLED_ITEM.ITEM') |
          NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'

            IN TYPEOF(aso)))) = 0))) = 0))) > 0;
  WR4: NOT (acyclic_mapped_item_usage (SELF));
  WR5: SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_symbol_representation
  SUBTYPE of (symbol_representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (TYPEOF (item) *
            ['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_CURVE_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT']) = 1)
       )) = 0;
  WR2: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         (SIZEOF (TYPEOF (item) *
            ['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_CURVE_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',
             'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT_OCCURRENCE']) = 1)
       )) >= 1;
  WR3: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'
          IN TYPEOF (item))) = 0;
  WR4: 
    SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) |
         NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
           ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL' IN TYPEOF(mi))) |
         NOT (SIZEOF (QUERY(aso <*
             USEDIN(a_s, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                         'STYLED_ITEM.ITEM') |
             NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'

                  IN TYPEOF(aso))
          )) = 0) )) = 0) )) > 0;
  WR5: 
    NOT (acyclic_mapped_item_usage (SELF));
  WR6: 
    SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_text_literal_with_delineation
  SUBTYPE OF (text_literal_with_delineation);
WHERE
  WR1: SELF.delineation IN ['underline', 'overline'];
END_ENTITY;

ENTITY draughting_title;
  items    : SET [1:?] OF draughting_titled_item;
  language : label;
  contents : text;
END_ENTITY;

ENTITY drawing_definition;
  drawing_number : identifier;
  drawing_type   : OPTIONAL label;
END_ENTITY;

ENTITY drawing_revision
  SUBTYPE OF (presentation_set);
  revision_identifier : identifier;
  drawing_identifier  : drawing_definition;
  intended_scale      : OPTIONAL text;
UNIQUE
  UR1: revision_identifier, drawing_identifier;
END_ENTITY;

ENTITY drawing_revision_class_of_document
  SUBTYPE OF (class, product_definition_formation, drawing_revision);
WHERE
  appropriate_category: SELF.of_product.name = 'document';
END_ENTITY;

ENTITY drawing_sheet_revision
  SUBTYPE OF (presentation_area);
  revision_identifier : identifier;
WHERE
  WR1: SIZEOF( QUERY(item <* SELF\representation.items |
       ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM' IN (TYPEOF(item)))
       AND
       ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAWING_SHEET_REVISION' IN

       (TYPEOF(item\mapped_item.mapping_source.mapped_representation)))))=0;
END_ENTITY;

ENTITY drawing_sheet_revision_class_of_document
  SUBTYPE OF (class, product_definition_formation, drawing_sheet_revision);
WHERE
  appropriate_category: SELF.of_product.name = 'document';
END_ENTITY;

ENTITY drawing_sheet_revision_usage
  SUBTYPE OF (area_in_set);
  sheet_number : identifier;
UNIQUE
  UR1: sheet_number, in_set;
WHERE
  WR1: ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAWING_SHEET_REVISION' IN 
                  TYPEOF(SELF\area_in_set.area)) 
              AND
              ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAWING_REVISION' 

               IN TYPEOF (SELF\area_in_set.in_set));
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;

 ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY explicit_schematic_element_definition
  SUBTYPE OF (schematic_element_definition);
WHERE
  not_derived_or_defined_by_assembly:
      (SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION'
         IN TYPEOF(it) ) ) = 0) AND
      (SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE'

         IN TYPEOF(it) ) ) >= 0);
END_ENTITY;

ENTITY explicitly_enumerated_maths_space_context
  SUBTYPE OF (maths_space_context);
  members  :  SET [1:?] OF maths_value_context;
END_ENTITY;

ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : product_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_source;
  source_id   : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1 : SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +

                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY externally_defined_curve_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_hatch_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY;

ENTITY externally_defined_symbol
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY externally_defined_tile_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style;
  name       : label;
  fill_styles : SET [1:?] OF fill_style_select;
WHERE
  WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'REFERENCE_DATA_LIBRARY_MIM_LF.'+

         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;

ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

ENTITY fill_area_style_hatching
  SUBTYPE OF (geometric_representation_item);
  hatch_line_appearance         : curve_style;
  start_of_next_hatch_line      : one_direction_repeat_factor;
  point_of_reference_hatch_line : cartesian_point;
  pattern_start                 : cartesian_point;
  hatch_line_angle              : plane_angle_measure;
END_ENTITY;

ENTITY fill_area_style_tile_symbol_with_style
  SUBTYPE OF (geometric_representation_item);
  symbol : annotation_symbol_occurrence;
END_ENTITY;

ENTITY fill_area_style_tiles
  SUBTYPE OF (geometric_representation_item);
  tiling_pattern : two_direction_repeat_factor;
  tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
  tiling_scale   : positive_ratio_measure;
END_ENTITY;

ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;

ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;

ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'REFERENCE_DATA_LIBRARY_MIM_LF.GENERIC_EXPRESSION' IN TYPEOF (member))

       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;

  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       SIMPLE_GENERIC_EXPRESSION,
                       UNARY_GENERIC_EXPRESSION,
                       BINARY_GENERIC_EXPRESSION,
                       MULTIPLE_ARITY_GENERIC_EXPRESSION));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
END_ENTITY;

ENTITY generic_variable
ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

 ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
 WHERE
   WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'REFERENCE_DATA_LIBRARY_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0;

 END_ENTITY;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR,
              CURVE,
              GEOMETRIC_SET))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN

      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

 ENTITY geometric_set
   
  SUBTYPE OF (geometric_representation_item);
   elements :  SET [1:?] OF geometric_set_select;
 END_ENTITY;

ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_CURVE_SET',
           
'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT_2D',
            'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *
          
['REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_CURVE_SET',
            'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['REFERENCE_DATA_LIBRARY_MIM_LF.B_SPLINE_CURVE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.CIRCLE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_CURVE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.ELLIPSE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.OFFSET_CURVE_2D',
              'REFERENCE_DATA_LIBRARY_MIM_LF.POINT',
              'REFERENCE_DATA_LIBRARY_MIM_LF.POLYLINE',
              'REFERENCE_DATA_LIBRARY_MIM_LF.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         ('AIC_- GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('REFERENCE_DATA_LIBRARY_MIM_LF.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['REFERENCE_DATA_LIBRARY_MIM_LF.CARTESIAN_POINT',
                'REFERENCE_DATA_LIBRARY_MIM_LF.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
        
     ('REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_CURVE_SET'
           IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pl <* 
           QUERY (elem <* gcs\geometric_set.elements |
             ('REFERENCE_DATA_LIBRARY_MIM_LF.POLYLINE'

                  IN TYPEOF (elem))) |
             NOT (SIZEOF (pl\polyline.points) > 2)
         )) = 0)
       )) = 0;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

 ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY implicit_schematic_element_definition
  SUBTYPE OF (schematic_element_definition);
WHERE
  no_styled_item: 
      SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM' IN TYPEOF(it) ) ) = 0;
  either_derived_once_or_defined_by_assembly:
      (SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION' IN TYPEOF(it) ) ) = 1) 
         OR (SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE' IN TYPEOF(it) ) ) >= 1);

END_ENTITY;

ENTITY independent_property_definition
  SUPERTYPE OF (ONEOF (
              POINT_PROPERTY_DEFINITION,
              RANGE_PROPERTY_DEFINITION))
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;

ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;

ENTITY intersection;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  operand     : SET[2:?] OF class;
  resultant   : class;
END_ENTITY;

ENTITY intra_page_connector
  SUBTYPE OF (page_connector);
END_ENTITY;

ENTITY invisibility;
  invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

 ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;

ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (
                       ELEMENTARY_SPACE,
                       FINITE_INTEGER_INTERVAL,
                       INTEGER_INTERVAL_FROM_MIN,
                       INTEGER_INTERVAL_TO_MAX,
                       FINITE_REAL_INTERVAL,
                       REAL_INTERVAL_FROM_MIN,
                       REAL_INTERVAL_TO_MAX,
                       FINITE_SPACE,
                       UNIFORM_PRODUCT_SPACE,
                       LISTED_PRODUCT_SPACE,
                       EXTENDED_TUPLE_SPACE))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY maths_space_context
  SUPERTYPE OF (ONEOF (
              COMPOUND_MATHS_SPACE_CONTEXT,
              DEFINED_MATHS_SPACE_CONTEXT,
              EXPLICITLY_ENUMERATED_MATHS_SPACE_CONTEXT));
  id              :  identifier;
  name            :  label;
  description     :  OPTIONAL text; 
  abstract_space  :  maths_space;
  physical_space  :  space_context_select;
END_ENTITY;

ENTITY maths_value_context;
  id              :  identifier;
  name            :  label;
  description     :  OPTIONAL text; 
  abstract_value  :  maths_value;
  physical_value  :  value_context_select;
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY membership_of_maths_space_context;
  space_context  :  maths_space_context;
  value_context  :  maths_value_context;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY off_page_connector
  SUBTYPE OF (page_connector);
END_ENTITY;

 ENTITY offset_curve_2d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
 WHERE
   WR1: basis_curve.dim = 2;
 END_ENTITY;

ENTITY on_page_connector
  SUBTYPE OF (page_connector);
END_ENTITY;

ENTITY one_direction_repeat_factor
  SUBTYPE OF (geometric_representation_item);
  repeat_factor : vector;
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_organization_type : organization_type;
  role : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY page_connector
  SUBTYPE OF (schematic_element_definition);
END_ENTITY;

 ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY person_and_organization_address 
SUBTYPE OF (organizational_address, personal_address); 
  SELF\personal_address.people: SET[1:1] of person;
  SELF\organizational_address.organizations: SET[1:1] of organization;
WHERE 
WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'REFERENCE_DATA_LIBRARY_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | 

   pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1; 
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY person_assignment
  ABSTRACT SUPERTYPE;
  assigned_person : person;
  role : person_role;
END_ENTITY;

ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

END_ENTITY;

ENTITY person_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

 ENTITY placement
   
  SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY point
   SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT,
              POINT_ON_CURVE))
  SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY point_on_curve
   SUBTYPE OF (point);
   basis_curve     : curve;
   point_parameter : parameter_value;
 END_ENTITY;

ENTITY point_property_definition
  SUBTYPE OF (independent_property_definition);
END_ENTITY;

 ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;

ENTITY power_set;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  base        : class;
  derived     : class;
WHERE
  derived_different : NOT identical_sets(base, derived);
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

ENTITY pre_defined_symbol
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY presentation_area
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                                             'AREA_IN_SET.AREA') | 
           SIZEOF (USEDIN (ais, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                                'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
         (SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +

                                'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;

ENTITY presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SELF\representation.
            context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: 'REFERENCE_DATA_LIBRARY_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT'

       IN TYPEOF (SELF\representation.context_of_items);
END_ENTITY;

ENTITY presentation_set;
INVERSE
  areas : SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;

ENTITY presentation_size;
  unit : presentation_size_assignment_select;
  size : planar_box;
WHERE
  WR1: (('REFERENCE_DATA_LIBRARY_MIM_LF.PRESENTATION_REPRESENTATION'
         IN TYPEOF (SELF.unit)) AND
         item_in_context (SELF.size, 
                          SELF.unit\representation.context_of_items)
       )
            OR
       (
        ('REFERENCE_DATA_LIBRARY_MIM_LF.AREA_IN_SET'

          IN TYPEOF (SELF.unit)) AND
        (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0)
       ); 
END_ENTITY;

ENTITY presentation_style_assignment;
  styles : SET [1:?] OF presentation_style_select;
WHERE
  WR1: SIZEOF (QUERY (style1 <* SELF.styles |
         NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.' +
                       'SURFACE_STYLE_USAGE',
                       'REFERENCE_DATA_LIBRARY_MIM_LF.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
  WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'REFERENCE_DATA_LIBRARY_MIM_LF.SURFACE_STYLE_USAGE' IN

         TYPEOF(style1)
         )) <= 2;
END_ENTITY;

ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

ENTITY presentation_view
  SUBTYPE OF (presentation_representation);
END_ENTITY;

ENTITY presented_item
  ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY presented_item_representation;
  presentation : presentation_representation_select;
  item         : presented_item;
END_ENTITY;

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY proper_subset
  SUBTYPE OF (subset);
WHERE
  subset_different : NOT identical_sets(superset, subset);
END_ENTITY;

ENTITY property_condition_for_activity
  SUBTYPE OF (action_property);
  SELF\action_property.definition : class_of_activity;
END_ENTITY;

ENTITY property_condition_for_product
  SUBTYPE OF (property_definition);
WHERE
  link_to_class: 'REFERENCE_DATA_LIBRARY_MIM_LF.CLASS_OF_PRODUCT' IN TYPEOF(SELF\property_definition.definition.formation);

END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;

END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;

END_ENTITY;

ENTITY property_space
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY property_symmetry
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY property_symmetry_by_library_reference
  SUBTYPE OF (property_symmetry, externally_defined_item);
END_ENTITY;

ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;

 ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

ENTITY range_property_definition
  SUBTYPE OF (independent_property_definition);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

 ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
                                
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                               := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;

ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;

ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;

ENTITY reference_between_page_connectors
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : page_connector;
  SELF\representation_relationship.rep_2 : page_connector;
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' +

                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_context_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  representation_basis  :  representation_context;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

ENTITY same_membership;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  set_1       : class;
  set_2       : class;
END_ENTITY;

ENTITY schematic_drawing
  SUBTYPE OF (schematic_element_definition, drawing_sheet_revision);
END_ENTITY;

ENTITY schematic_element
  ABSTRACT SUPERTYPE OF (ONEOF (
                       SCHEMATIC_ELEMENT_DEFINITION,
                       SCHEMATIC_ELEMENT_OCCURRENCE))
  SUBTYPE OF (class, draughting_model, presentation_representation);
WHERE
  valid_mapping:
      SIZEOF( QUERY(it <* SELF.items |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.DRAUGHTING_MODEL' 
             IN TYPEOF (it\mapped_item.mapping_source.mapped_representation)) AND
         (NOT( SIZEOF( ['REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DERIVATION_OF_SCHEMATIC_ELEMENT_DEFINITION',
                        'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE',
                        'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DEFINITION_OF_SCHEMATIC_ELEMENT_OCCURRENCE' ] * TYPEOF(it) ) = 1 ))

            ) ) = 0;
END_ENTITY;

ENTITY schematic_element_definition
  SUPERTYPE OF (ONEOF (
              EXPLICIT_SCHEMATIC_ELEMENT_DEFINITION,
              IMPLICIT_SCHEMATIC_ELEMENT_DEFINITION))
  SUBTYPE OF (schematic_element);
END_ENTITY;

ENTITY schematic_element_occurrence
  SUBTYPE OF (schematic_element);
INVERSE
  usage_in_map : SET[1:?] OF representation_map FOR mapped_representation;
WHERE
  no_styled_item:
      SIZEOF( QUERY(it <* SELF.items |
         'REFERENCE_DATA_LIBRARY_MIM_LF.STYLED_ITEM' IN TYPEOF(it) ) ) = 0;
  defined_with_respect_to_definition_no_more_than_once:
      SIZEOF( QUERY(it <* SELF.usage_in_map.map_usage |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DEFINITION_OF_SCHEMATIC_ELEMENT_OCCURRENCE' IN TYPEOF(it)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_DEFINITION'
              IN TYPEOF (it\mapped_item.mapping_source.mapped_representation) ) 
            ) ) <= 1;
  referenced_as_usage_or_defined_with_respect_to_occurrence:
       SIZEOF( QUERY(it <* SELF.usage_in_map.map_usage |
         'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'USAGE_OF_SCHEMATIC_ELEMENT_OCCURRENCE' IN TYPEOF(it) ) ) +
       SIZEOF( QUERY(it <* SELF.usage_in_map.map_usage |
         ('REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DEFINITION_OF_SCHEMATIC_ELEMENT_OCCURRENCE' IN TYPEOF(it)) AND
         ('REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE'

             IN TYPEOF (it\mapped_item.mapping_source.mapped_representation) ) ) ) 
        = 1;
END_ENTITY;

ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;

END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF (
                       GENERIC_LITERAL,
                       GENERIC_VARIABLE))

SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY space_for_property_definition
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : property_space;
  SELF\general_property_relationship.related_property : independent_property_definition;
END_ENTITY;

ENTITY standard_property_symmetry
  SUBTYPE OF (property_symmetry_by_library_reference);
WHERE
  valid_standard_class: (SELF\property_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1099') AND (SELF\property_symmetry_by_library_reference\externally_defined_item.item_id IN ['PS001', 'PS002', 'PS003', 'PS004', 'PS005', 'PS006', 'PS007', 'PS008', 'PS009', 'PS010', 'PS011', 'PS012', 'PS013']);
END_ENTITY;

ENTITY standard_tensor_order_and_symmetry
  SUBTYPE OF (tensor_order_and_symmetry_by_library_reference);
WHERE
  valid_standard_class: (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.source.source_id = 'ISO-TS-10303-1080') AND (SELF\tensor_order_and_symmetry_by_library_reference\externally_defined_item.item_id IN ['TO001', 'TO002', 'TO003', 'TO004', 'TO005', 'TO006', 'TO007', 'TO008', 'TO009']);
END_ENTITY;

ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles :  SET [1:?] OF presentation_style_assignment;
  item   :  representation_item;
WHERE
  WR1: (SIZEOF(SELF.styles) = 1)
               XOR
       (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('REFERENCE_DATA_LIBRARY_MIM_LF.' +

              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;

ENTITY subset;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  subset      : class;
  superset    : class;
END_ENTITY;

ENTITY symbol_colour;
  colour_of_symbol : colour;
END_ENTITY;

ENTITY symbol_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY symbol_representation_map
  SUBTYPE OF (representation_map);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_map.mapped_representation);
  WR2: 'REFERENCE_DATA_LIBRARY_MIM_LF.AXIS2_PLACEMENT' IN

         TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY symbol_style;
  name            : label; 
  style_of_symbol : symbol_style_select;
END_ENTITY;

ENTITY symbol_target
  SUBTYPE OF (geometric_representation_item);
  placement         : axis2_placement;
  x_scale           : positive_ratio_measure;
  y_scale           : positive_ratio_measure;
END_ENTITY;

ENTITY symbolization_by_schematic_element
  SUBTYPE OF (class, presented_item_representation);
  SELF\presented_item_representation.presentation : schematic_element;
  SELF\presented_item_representation.item : symbolized_item;
END_ENTITY;

ENTITY symbolization_of_member_or_subclass_by_schematic_element
  SUBTYPE OF (class, presented_item_representation);
  SELF\presented_item_representation.presentation : schematic_element_definition;
  SELF\presented_item_representation.item : symbolized_class;
END_ENTITY;

ENTITY symbolized_class
  SUBTYPE OF (presented_item);
  item : symbolized_class_select;
END_ENTITY;

ENTITY symbolized_item
  SUBTYPE OF (presented_item);
  item : symbolized_item_select;
END_ENTITY;

ENTITY symmetry_for_property_definition
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : property_symmetry;
  SELF\general_property_relationship.related_property : independent_property_definition;
END_ENTITY;

ENTITY tensor_order_and_symmetry
  SUBTYPE OF (general_property, class);
END_ENTITY;

ENTITY tensor_order_and_symmetry_by_library_reference
  SUBTYPE OF (tensor_order_and_symmetry, externally_defined_item);
END_ENTITY;

ENTITY tensor_order_and_symmetry_for_property_space
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.relating_property : tensor_order_and_symmetry;
  SELF\general_property_relationship.related_property : property_space;
END_ENTITY;

ENTITY terminator_symbol
  SUBTYPE OF (annotation_symbol_occurrence);
  annotated_curve : annotation_curve_occurrence;
END_ENTITY;

ENTITY text_literal
  SUBTYPE OF (geometric_representation_item);
  literal   : presentable_text;
  placement : axis2_placement;
  alignment : text_alignment;
  path      : text_path;
  font      : font_select;
END_ENTITY;

ENTITY text_literal_with_associated_curves
  SUBTYPE OF (text_literal);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY text_literal_with_blanking_box
  SUBTYPE OF (text_literal);
  blanking : planar_box;
END_ENTITY;

ENTITY text_literal_with_delineation
  SUBTYPE OF (text_literal);
  delineation : text_delineation;
END_ENTITY;

ENTITY text_literal_with_extent
  SUBTYPE OF (text_literal);
  extent : planar_extent;
END_ENTITY;

ENTITY text_style;
  name                 : label;
  character_appearance : character_style_select;
END_ENTITY;

ENTITY text_style_for_defined_font;
  text_colour : colour;
END_ENTITY;

ENTITY text_style_with_box_characteristics
  SUBTYPE OF (text_style);
  characteristics : SET [1:4] OF box_characteristic_select;
WHERE
  WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
         SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
       )) = 0;
END_ENTITY;

ENTITY text_style_with_mirror
  SUBTYPE OF (text_style);
  mirror_placement : axis2_placement;
END_ENTITY;

ENTITY text_style_with_spacing
  SUBTYPE OF (text_style);
  character_spacing : character_spacing_select;
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

 ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
   basis_curve           : curve;
   trim_1                : SET[1:2] OF trimming_select;
   trim_2                : SET[1:2] OF trimming_select;
   sense_agreement       : BOOLEAN;
   master_representation : trimming_preference;
 WHERE
   WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
   WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
 END_ENTITY;

ENTITY two_direction_repeat_factor
  SUBTYPE OF (one_direction_repeat_factor);
  second_repeat_factor : vector;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

 ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;

ENTITY union;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  operand     : SET[2:?] OF class;
  resultant   : class;
END_ENTITY;

ENTITY unit_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  unit_basis  :  unit;
END_ENTITY;

ENTITY usage_of_schematic_element_occurrence
  SUBTYPE OF (mapped_item);
WHERE
  schematic_element_occurrence_as_part:
     'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'SCHEMATIC_ELEMENT_OCCURRENCE'
        IN TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  implicit_schematic_element_definition_as_whole:
     'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'IMPLICIT_SCHEMATIC_ELEMENT_DEFINITION'

        IN TYPEOF (using_representations(SELF));
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'REFERENCE_DATA_LIBRARY_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);

END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('REFERENCE_DATA_LIBRARY_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'REFERENCE_DATA_LIBRARY_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'REFERENCE_DATA_LIBRARY_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'REFERENCE_DATA_LIBRARY_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 

	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;


END_FUNCTION;

FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;

  LOCAL
   i : INTEGER;
   local_composite_text : SET [0:?] OF composite_text;
   local_annotation_text : SET [0:?] OF annotation_text;
   local_children : SET [0:?] OF text_or_character;
  END_LOCAL;

  local_composite_text := QUERY (child <* child_text |
                          ('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_composite_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      IF (start_composite :=: local_composite_text[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;

  local_children := child_text;

  IF (SIZEOF (local_composite_text)) > 0 THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      local_children := local_children +
                        local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;


  local_annotation_text := QUERY (child <* child_text |
                          ('REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_annotation_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_annotation_text);
      local_children := local_children +
      QUERY (item <* local_annotation_text[i]\mapped_item.
                     mapping_source.mapped_representation.items |
        SIZEOF(['REFERENCE_DATA_LIBRARY_MIM_LF.ANNOTATION_TEXT',
                'REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_TEXT'] *

                TYPEOF(item)) > 0);
    END_REPEAT;
  END_IF;

  IF (local_children :<>: child_text) THEN
    RETURN (acyclic_composite_text (start_composite, local_children));
  ELSE
    RETURN (TRUE);
  END_IF;


 END_FUNCTION;

 FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve)
                                              : BOOLEAN;
   IF NOT (('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN

      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION;

FUNCTION acyclic_mapped_item_usage (rep: representation) : BOOLEAN;
  -- returns TRUE if the representation contains one or more mapped_items
  -- that are a mapping of the representation itself
  LOCAL
    items : SET OF representation_item;
  END_LOCAL;

  items := QUERY (item <* rep.items |
           'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM' IN TYPEOF (item));

  IF SIZEOF (items) = 0
  THEN 
    RETURN (FALSE);
  ELSE 
    REPEAT i := 1 TO HIINDEX (items);
      IF items[i]\mapped_item.mapping_source.mapped_representation :=: rep
      THEN 
        RETURN (TRUE);
      ELSE 
        RETURN (acyclic_mapped_item_usage(items[i]\
                  mapped_item.mapping_source.mapped_representation));
      END_IF;
    END_REPEAT;
  RETURN (FALSE);
  END_IF;

END_FUNCTION;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'REFERENCE_DATA_LIBRARY_MIM_LF.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);

END_FUNCTION;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));

    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;

RETURN (TRUE);      END_FUNCTION;

FUNCTION bag_to_set
 (the_bag : BAG OF GENERIC : intype) : SET OF GENERIC : intype; 
   LOCAL
    the_set: SET OF GENERIC : intype := [];
  END_LOCAL;
  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag [i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);

END_FUNCTION;

FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);

END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);

 END_FUNCTION;

FUNCTION check_text_alignment (ct : composite_text) : BOOLEAN;

  LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF(a) = 1);

END_FUNCTION;

FUNCTION check_text_font (ct : composite_text) : BOOLEAN;

  LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF(f) <= 1);

END_FUNCTION;

 FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                               knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);

 END_FUNCTION;

 FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);

 END_FUNCTION;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN

    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);

      END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'REFERENCE_DATA_LIBRARY_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'REFERENCE_DATA_LIBRARY_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'REFERENCE_DATA_LIBRARY_MIM_LF.VECTOR' IN TYPEOF(item) THEN

       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);


END_FUNCTION;

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;

		      END_FUNCTION;

FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));

END_FUNCTION;

FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);

END_FUNCTION;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));

  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));

END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;

END_FUNCTION;

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));

  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'REFERENCE_DATA_LIBRARY_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));

  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;

END_FUNCTION;

FUNCTION identical_sets
  (set_a : class;
   set_b : class) : BOOLEAN;
  
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;
  
  IF (set_a = set_b) THEN
    RETURN (TRUE);
  END_IF;
  
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));

END_FUNCTION;

FUNCTION identical_to_one_of_set_of_sets
  (set_a       : class;
   set_of_sets : SET OF class) : BOOLEAN;
  
  LOCAL
    i                            : INTEGER;
    initial_size                 : INTEGER;
    augmented_size               : INTEGER;
    set_of_forward_equivalences  : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets        : SET OF class := [];
  END_LOCAL;
  
  --  test membership of the specified set of sets
  
  IF (set_a IN set_of_sets) THEN
    RETURN (TRUE);
  END_IF;
  
  --  extend the specified set to include all sets that have the same membership
  --  as an existing member
  
  initial_size := SIZEOF(set_of_sets);
  IF (initial_size = 0) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'REFERENCE_DATA_LIBRARY_MIM_LF.SAME_MEMBERSHIP.SET_1');
    set_of_backward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'REFERENCE_DATA_LIBRARY_MIM_LF.SAME_MEMBERSHIP.SET_2');

  END_REPEAT;
  
  augmented_set_of_sets := set_of_sets;
  IF (SIZEOF(set_of_forward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(set_of_backward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  
  -- if the specified set of sets has been augmented, then test membership
  
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));

END_FUNCTION;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));

END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);

END_FUNCTION;

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;

END_FUNCTION;

 FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                      low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;

 END_FUNCTION;

FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );

END_FUNCTION;

FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);

END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'REFERENCE_DATA_LIBRARY_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'REFERENCE_DATA_LIBRARY_MIM_LF.VECTOR' IN TYPEOF(arg) THEN

         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);

 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;

 END_FUNCTION;

FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);

END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('REFERENCE_DATA_LIBRARY_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));

  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);

END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'REFERENCE_DATA_LIBRARY_MIM_LF.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);

END_FUNCTION;

FUNCTION valid_basis_curve_in_2d_wireframe
   (crv: curve) : BOOLEAN;
   -- check for valid basic curve types
  IF SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.POLYLINE',
               'REFERENCE_DATA_LIBRARY_MIM_LF.B_SPLINE_CURVE',
               'REFERENCE_DATA_LIBRARY_MIM_LF.ELLIPSE',
               'REFERENCE_DATA_LIBRARY_MIM_LF.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('REFERENCE_DATA_LIBRARY_MIM_LF.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['REFERENCE_DATA_LIBRARY_MIM_LF.LINE',
                   'REFERENCE_DATA_LIBRARY_MIM_LF.PARABOLA',
                   'REFERENCE_DATA_LIBRARY_MIM_LF.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('REFERENCE_DATA_LIBRARY_MIM_LF.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('REFERENCE_DATA_LIBRARY_MIM_LF.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('REFERENCE_DATA_LIBRARY_MIM_LF.COMPOSITE_CURVE') 

          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);

END_FUNCTION;

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);

END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;

END_FUNCTION;

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;

END_FUNCTION;

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'REFERENCE_DATA_LIBRARY_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'REFERENCE_DATA_LIBRARY_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 

  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);

		      END_FUNCTION;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

(*** 2003=>1994 conversion: insert a rule to control if instances are legal according to USE/REF clauses ***)

  RULE validate_dependently_instantiable_entity_data_types FOR
      (annotation_text,application_context,application_context_element,area_in_set,b_spline_curve,binary_generic_expression,bounded_curve,cartesian_point,cartesian_transformation_operator,colour,colour_specification,conic,contract,contract_type,curve_style_font_pattern,description_attribute,direction,document,document_representation_type,document_type,drawing_definition,environment,extended_tuple_space,founded_item,functionally_defined_transformation,generic_expression,generic_literal,generic_variable,geometric_representation_item,identification_assignment,identification_role,invisibility,local_time,multiple_arity_generic_expression,name_attribute,one_direction_repeat_factor,organization_role,organization_type_role,person_and_organization_role,person_role,placement,planar_box,planar_extent,point,pre_defined_item,presentation_area,presentation_set,presentation_style_assignment,product_context,product_definition_context,quantifier_expression,role_association,security_classification,security_classification_level,simple_generic_expression,symbol_target,two_direction_repeat_factor,unary_generic_expression,variable_semantics,vector --<list this first and all subsequent relevant referencedentity data types here>
      );
  LOCAL
    number_of_input_instances : INTEGER;
    previous_in_chain         : LIST OF INTEGER := []; 
    set_of_input_types        : SET OF STRING := [];
    all_instances             : SET OF INTEGER := []; 
  END_LOCAL;

  all_instances := annotation_text + application_context + application_context_element + area_in_set + b_spline_curve + binary_generic_expression + bounded_curve + cartesian_point + cartesian_transformation_operator + colour + colour_specification + conic + contract + contract_type + curve_style_font_pattern + description_attribute + direction + document + document_representation_type + document_type + drawing_definition + environment + extended_tuple_space + founded_item + functionally_defined_transformation + generic_expression + generic_literal + generic_variable + geometric_representation_item + identification_assignment + identification_role + invisibility + local_time + multiple_arity_generic_expression + name_attribute + one_direction_repeat_factor + organization_role + organization_type_role + person_and_organization_role + person_role + placement + planar_box + planar_extent + point + pre_defined_item + presentation_area + presentation_set + presentation_style_assignment + product_context + product_definition_context + quantifier_expression + role_association + security_classification + security_classification_level + simple_generic_expression + symbol_target + two_direction_repeat_factor + unary_generic_expression + variable_semantics + vector;--<make a union of all implicit populations of the FOR-clause>
  number_of_input_instances := SIZEOF(all_instances);
  (* Collect all type strings of all FOR instances into one set. *)
  REPEAT i:=1 TO number_of_input_instances;
    set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
  END_REPEAT;

  WHERE
   WR1: dependently_instantiated(all_instances, set_of_input_types,
                                 previous_in_chain);
  END_RULE;

  FUNCTION dependently_instantiated(
          set_of_input_instances : SET OF GENERIC;
          set_of_input_types     : SET OF STRING;
          previous_in_chain      : LIST OF GENERIC): BOOLEAN;
  (*'dependently_instantiated' To test whether all instances in the
    input set_of_input_instances are referenced by independently
    instantiable instances. If so, this function returns true.
    Set_of_input_types includes the type strings for all input instances.
    The instances in previous_in_chain are used to detect cyclic
    references during recursive calls to this function. The parameter
    lists already tested instances in a chain of references.
   *)
  LOCAL
    number_of_input_instances     : INTEGER;
    number_of_referring_instances : INTEGER;
    bag_of_referring_instances    : BAG OF GENERIC := []; 
    dependently_instantiated_flag : BOOLEAN;
    previous_in_chain_plus        : LIST OF GENERIC := [];
    recursion                     : BOOLEAN;
    result                        : BOOLEAN := true;
    set_of_types                  : SET OF STRING := [];
  END_LOCAL;

  IF EXISTS(set_of_input_instances) THEN
    number_of_input_instances := SIZEOF(set_of_input_instances);
    (* Add the declared type of bag_of_referring_instances to the set of
       types of the REFERENCEd instances for the subset comparison later.
     *)
    set_of_input_types := set_of_input_types + 'GENERIC';
    REPEAT i:=1 TO number_of_input_instances;
      (* Determine all references to the current input instance. *)
      bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
      IF EXISTS(bag_of_referring_instances) THEN
        number_of_referring_instances := SIZEOF(bag_of_referring_instances);
        dependently_instantiated_flag := false;
        REPEAT j:=1 TO number_of_referring_instances;
          (* Determine the type strings of the current referencing instance.
           *)
          set_of_types := TYPEOF(bag_of_referring_instances[j]);
          (* If the referencing instance is of one of the types of the
             only dependently instantiable select items, the current input
             instance may still be invalidly instantiated.
             Otherwise it is OK, and the next input instance is tested.
           *)
          IF set_of_types <= set_of_input_types THEN -- subset operator
            (* The referring instance is of one of the restricted types.
               However, it may itself be referred to by a valid instance;
               then also the current instance would be valid.
               Thus, call this function recursively with the referring
               instance as input.
               To avoid an infinite loop in case a set of instances
               reference each other in a closed loop, test first whether
               the current referencing instance is in the list of
               previously processed chain members.
             *)
            IF EXISTS(previous_in_chain) THEN
              recursion := true;
              REPEAT k:=1 TO SIZEOF(previous_in_chain);
                IF previous_in_chain[k] :=: bag_of_referring_instances[j]
                  THEN
                  (* No recursion. *)
                  recursion := false;
                  ESCAPE;
                END_IF;
              END_REPEAT;
            END_IF;
            IF recursion THEN
              previous_in_chain_plus := previous_in_chain +
                                        set_of_input_instances[i];
              IF dependently_instantiated([bag_of_referring_instances[j]],
                                          set_of_input_types,
                                          previous_in_chain_plus) THEN
                dependently_instantiated_flag := true;
                ESCAPE; -- dependently instantiated; next input instance
              ELSE
                (* Not dependently instantiated: go to next referring
                   instance. *)
                SKIP;
              END_IF;
            END_IF;
          ELSE
            dependently_instantiated_flag := true;
            ESCAPE; -- dependently instantiated; take next input instance
          END_IF;
        END_REPEAT;
        IF NOT dependently_instantiated_flag THEN
          RETURN(false);
        END_IF;
      ELSE
        RETURN(false); -- not referenced at all => invalidly instantiated
      END_IF;
    END_REPEAT;
  ELSE
    RETURN(false); -- no input
  END_IF;

  RETURN(true);
  END_FUNCTION; -- end dependently_instantiated



END_SCHEMA;

