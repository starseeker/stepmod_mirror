<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-03-30T15:27:10" rcs.revision="1.0" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="requirement_decomposition_arm schema_instance"/>
   <schema name="REQUIREMENT_DECOMPOSITION_ARM">
      <interface kind="use" schema="ANALYTICAL_MODEL_ARM"/>
      <interface kind="use" schema="CHARACTERISTIC_ARM"/>
      <interface kind="use" schema="CONDUCTIVITY_MATERIAL_ASPECTS_ARM"/>
      <interface kind="use" schema="ELEMENTAL_GEOMETRIC_SHAPE_ARM"/>
      <interface kind="use" schema="FUNCTIONAL_SPECIFICATION_ARM"/>
      <interface kind="use" schema="PART_AND_VERSION_IDENTIFICATION_ARM"/>
      <interface kind="use" schema="PRODUCT_RULE_ARM"/>
      <interface kind="use" schema="REQUIREMENT_ASSIGNMENT_ARM"/>
      <interface kind="use" schema="REQUIREMENT_VIEW_DEFINITION_ARM"/>
      <interface kind="use" schema="SPECIFICATION_DOCUMENT_ARM"/>
      <type name="material_conductivity_classification">
         <enumeration items="conductive resistive semi_conductive non_conductive"/>
      </type>
      <type name="rd_material_item_select">
         <select extensible="YES" genericentity="YES" basedon="material_item_select" selectitems="requirement_definition_property"/>
      </type>
      <type name="relationship_operation">
         <enumeration items="and_operation derived_from or_operation precedence supplemental"/>
      </type>
      <entity name="constraint_occurrence" supertypes="requirement_definition_property" super.expression="view_based_constraint_occurrence">
         <explicit name="logical_relation" optional="YES">
            <typename name="rule_complex_clause"/>
         </explicit>
         <where label="wr1" expression=" ( ( 'requirement_decomposition_arm.' + 'view_based_constraint_occurrence' ) in typeof ( self ) ) or exists ( logical_relation ) "/>
      </entity>
      <entity name="design_characteristic_occurrence" supertypes="requirement_definition_property"/>
      <entity name="design_requirement_occurrence" supertypes="requirement_definition_property"/>
      <entity name="electrical_requirement_occurrence" supertypes="requirement_definition_property" super.expression="material_electrical_conductivity_requirement_occurrence"/>
      <entity name="electromagnetic_requirement_occurrence" supertypes="requirement_definition_property"/>
      <entity name="inspection_requirement_occurrence" supertypes="requirement_definition_property"/>
      <entity name="material_electrical_conductivity_requirement_occurrence" supertypes="electrical_requirement_occurrence">
         <explicit name="electrical_conductivity_characteristic">
            <typename name="material_conductivity_classification"/>
         </explicit>
      </entity>
      <entity name="mechanical_requirement_occurrence" supertypes="requirement_definition_property"/>
      <entity name="operational_requirement_occurrence_relationship">
         <explicit name="relationship_type">
            <typename name="relationship_operation"/>
         </explicit>
         <explicit name="relating_requirement_occurrence">
            <typename name="requirement_view_definition"/>
         </explicit>
         <explicit name="related_requirement_occurrence">
            <typename name="requirement_view_definition"/>
         </explicit>
         <where label="wr1" expression=" relating_requirement_occurrence :&lt;&gt;: related_requirement_occurrence "/>
      </entity>
      <entity name="purpose_occurrence" supertypes="requirement_definition_property"/>
      <entity name="requirement_definition_property" super.expression="ONEOF (thermal_requirement_occurrence, electromagnetic_requirement_occurrence, electrical_requirement_occurrence, mechanical_requirement_occurrence) ANDOR ONEOF (design_requirement_occurrence, inspection_requirement_occurrence, test_requirement_occurrence, purpose_occurrence, constraint_occurrence, design_characteristic_occurrence)">
         <explicit name="associated_definition">
            <typename name="requirement_view_definition"/>
         </explicit>
         <explicit name="required_analytical_representation" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="analytical_model_application"/>
         </explicit>
         <explicit name="required_functional_specification" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="functional_specification"/>
         </explicit>
         <explicit name="required_part" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </explicit>
         <explicit name="required_coordinated_characteristic" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="coordinated_characteristic"/>
         </explicit>
         <explicit name="requirement_specification">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="specification_definition"/>
         </explicit>
         <explicit name="required_characteristic" optional="YES">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="characteristic"/>
         </explicit>
         <explicit name="reference_clause" optional="YES">
            <typename name="document_definition"/>
         </explicit>
         <inverse name="required_material" entity="material_identification" attribute="items">
            <inverse.aggregate type="SET" lower="0" upper="1"/>
         </inverse>
         <unique label="ur1">
            <unique.attribute entity-ref="requirement_definition_property" attribute="associated_definition"/>
         </unique>
         <where label="wr1" expression=" not ( sizeof ( required_material ) = 1 ) or ( 'conductivity_material_aspects.' + 'material_identification_with_conductivity_classification' in typeof ( required_material ) ) "/>
      </entity>
      <entity name="shape_and_view_based_constraint_occurrence" supertypes="view_based_constraint_occurrence">
         <explicit name="constraining_shape">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_model"/>
         </explicit>
         <where label="wr1" expression=" valid_constraining_shape ( constraining_shape , self \ view_based_constraint_occurrence . constraining_part ) "/>
      </entity>
      <entity name="test_requirement_occurrence" supertypes="requirement_definition_property">
         <where label="wr1" expression=" sizeof ( self \ requirement_definition_property . required_analytical_representation ) + sizeof ( self \ requirement_definition_property . required_functional_specification ) &gt; 0 "/>
      </entity>
      <entity name="thermal_requirement_occurrence" supertypes="requirement_definition_property"/>
      <entity name="view_based_constraint_occurrence" supertypes="constraint_occurrence" super.expression="shape_and_view_based_constraint_occurrence">
         <explicit name="constraining_part">
            <typename name="product_view_definition"/>
         </explicit>
      </entity>
      <subtype.constraint name="rd_model_parameter_subtypes" entity="model_parameter" super.expression="ONEOF (analytical_model_parameter, category_model_parameter, rule_function_domain_parameter, rule_function_range_parameter)"/>
      <function name="get_requirement_definition_property">
         <parameter name="ra">
            <typename name="requirement_assignment"/>
         </parameter>
         <parameter name="req_type">
            <builtintype type="STRING"/>
         </parameter>
         <typename name="requirement_definition_property"/>
         <algorithm> local requirements : set [ 0 : ? ] of requirement_definition_property ; end_local ; requirements := usedin ( ra . assigned_requirement , 'requirement_decomposition.' + 'requirement_defintion_property.associated_definition' ) ; repeat i := 1 to sizeof ( requirements ) by 1 ; if ( req_type in typeof ( requirements [ i ] ) ) then return ( requirements [ i ] ) ; end_if ; end_repeat ; return ( ? ) ; </algorithm>
      </function>
      <function name="get_rvd">
         <parameter name="input">
            <typename name="requirement_assignment_item"/>
         </parameter>
         <parameter name="id">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="requirement_view_definition"/>
         <algorithm> local rvd : set [ 0 : ? ] of requirement_view_definition := [ ] ; ra : set [ 0 : ? ] of requirement_assignment := [ ] ; end_local ; ra := ( query ( rai &lt;* usedin ( input , 'requirement_assignment_arm.' + 'requirement_assignment.assigned_to' ) | ( rai . id = id ) ) ) ; repeat i := 1 to sizeof ( ra ) by 1 ; rvd := rvd + ra [ i ] . assigned_requirement ; end_repeat ; return ( rvd ) ; </algorithm>
      </function>
      <function name="valid_constraining_shape">
         <parameter name="sd">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="geometric_model"/>
         </parameter>
         <parameter name="eepd">
            <typename name="product_view_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm> return ( true ) ; </algorithm>
      </function>
   </schema>
</express>
