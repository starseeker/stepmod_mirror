<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-02-28T09:42:00" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="shape_composition_mim schema_instance"/>
   <schema name="Shape_composition_mim">
      <interface kind="use" schema="Shape_property_assignment_mim"/>
      <interface kind="use" schema="shape_aspect_definition_schema">
         <interfaced.item name="composite_shape_aspect"/>
      </interface>
      <interface kind="use" schema="shape_dimension_schema">
         <interfaced.item name="dimensional_location"/>
      </interface>
      <entity name="composite_group_shape_aspect" supertypes="composite_shape_aspect"/>
      <entity name="composite_unit_shape_aspect" supertypes="composite_shape_aspect"/>
      <rule name="composite_shape_element_constraint" appliesto="composite_shape_aspect">
         <where label="WR1" expression="SIZEOF(QUERY(csa &lt;* composite_shape_aspect |&#10;        SIZEOF(QUERY(sar &lt;* USEDIN(csa,&#10;       'SHAPE_COMPOSITION_MIM.'&#10;        + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |&#10;        (sar\shape_aspect_relationship.name = 'composing')&#10;        )) &lt; 2)) = 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(csa &lt;* composite_shape_aspect |&#10;        NOT ((SIZEOF(TYPEOF(csa)) &gt; 2) OR &#10;        (csa\shape_aspect.description &lt;&gt; '') OR &#10;        (csa\shape_aspect.name &lt;&gt; ''))&#10;        )) = 0"/>
      </rule>
      <rule name="shape_element_composing_relationship_constraint" appliesto="shape_aspect_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(sar &lt;* shape_aspect_relationship |&#10;       (sar\shape_aspect_relationship.name = 'composing') AND&#10;       ('SHAPE_COMPOSITION_MIM.'&#10;       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))&#10;       )) = 0"/>
      </rule>
      <rule name="shape_element_constituent_relationship_unique_constraint" appliesto="shape_aspect_relationship">
         <algorithm>LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r &lt;* shape_aspect_relationship | (r\shape_aspect_relationship.name IN [
'constituent', 'composing', 
'bare die terminal surface constituent relationship',
'interconnect module terminal surface constituent relationship',
'package terminal surface constituent relationship'] ) );
  sa_bag : BAG OF shape_aspect := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i].relating_shape_aspect ) THEN
    IF( NOT( sar[i].relating_shape_aspect IN sa_bag ) ) THEN
      sa_bag := sa_bag + sar[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r &lt;* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;</algorithm>
         <where label="WR1" expression="pass"/>
      </rule>
      <rule name="shape_element_locating_relationship_unique_constraint" appliesto="dimensional_location">
         <algorithm>LOCAL
  sa_bag : BAG OF shape_aspect := [];
  dl_bag : BAG OF dimensional_location;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF EXISTS( dimensional_location[i].relating_shape_aspect ) THEN
    IF( NOT( dimensional_location[i].relating_shape_aspect IN sa_bag ) )
                                                              THEN
      sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  dl_bag := QUERY( r &lt;* dimensional_location | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(dl_bag) by 1;
    IF EXISTS( dl_bag[j].related_shape_aspect ) THEN
      IF ( dl_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;</algorithm>
         <where label="WR1" expression="pass"/>
      </rule>
      <rule name="subtype_mandatory_composite_shape_aspect" appliesto="composite_shape_aspect">
         <where label="WR1" expression="SIZEOF (QUERY (csa &lt;* composite_shape_aspect |&#10;       NOT (SIZEOF&#10;       (['SHAPE_COMPOSITION_MIM.' +&#10;       'COMPOSITE_GROUP_SHAPE_ASPECT',&#10;       'SHAPE_COMPOSITION_MIM.' +&#10;       'COMPOSITE_UNIT_SHAPE_ASPECT']&#10;       * TYPEOF(csa)) = 1))) = 0"/>
      </rule>
   </schema>
</express>
