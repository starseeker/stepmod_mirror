<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: module.xml,v 1.36 2011/08/26 12:05:08 liutkuviene Exp $ -->
<!-- Generated by mkmodule.js, Eurostep Limited, http://www.eurostep.com --><!DOCTYPE module SYSTEM "../../../dtd/module.dtd">

<module name="specification_control" name.french="Contrôle de spécification" 
	part="1112" version="4" 
	wg.number="6672" 
	wg.number.arm="6673" 
	wg.number.mim="6674" 
	wg.number.supersedes="5499" 
	wg.number.arm.supersedes="5500" 
	wg.number.mim.supersedes="5501" 
	checklist.internal_review="6563" 
	checklist.project_leader="6564" 
	checklist.convener="6565" 
	status="TS" 
	language="E" 
	publication.year="2011-12" publication.date="2011-12-15" published="y" 
	previous.revision.year="2010" previous.revision.cancelled="NO" revision.complete="YES" rcs.date="$Date: 2011/08/26 12:05:08 $" rcs.revision="$Revision: 1.36 $" development.folder="dvlp" sc4.working_group="12" xmlns:xlink="http://www.w3.org/1999/xlink">
	<keywords>
    module, diversity, diversity management, product variant, product family
 </keywords>
	<!-- Reference to contacts detailed in stepmod/data/basic/contacts.xml -->
	<contacts>
		<projlead ref="ap203ed2.projlead"/>
		<editor ref="ap203ed2.editor"/>
	</contacts>
	
	<changes>
		<change version="2">
			<arm.changes>
				<arm.deletions>
					<modified.object type="USE_FROM" name="Effectivity_application_arm" />
					<modified.object type="USE_FROM" name="Functional_breakdown_arm" />
					<modified.object type="USE_FROM" name="Product_occurrence_arm" />
					<modified.object type="USE_FROM" name="Physical_breakdown_arm" />
					<modified.object type="USE_FROM" name="Specified_product_arm" />
				</arm.deletions>
			</arm.changes>
		</change>
		<change version="3">
			<description>
				Minor editorial changes.
			</description>
		</change>
		<change version="4">
			<arm.changes>
				<arm.additions>
					<modified.object type="USE_FROM" name="Requirement_view_definition_arm" />
				</arm.additions>
				<arm.modifications>
					<modified.object type="ENTITY" name="Design_constraint_definition" />
				</arm.modifications>
				<arm.deletions>
					<modified.object type="USE_FROM" name="Requirement_identification_and_version_arm" />
					<modified.object type="ENTITY" name="Design_constraint_relationship" />
				</arm.deletions>
			</arm.changes>
			
			<mim.changes>
				<mim.additions>
					<modified.object type="USE_FROM" name="Requirement_view_definition_mim" />
				</mim.additions>
				<mim.deletions>
					<modified.object type="USE_FROM" name="Requirement_identification_and_version_mim" />
				</mim.deletions>
			</mim.changes>
		</change>
	</changes>
	<!-- Introduction -->
	<purpose>
This part of ISO 10303 specifies an application module for the representation of products with a large number of variants. 
This application module provides a Unit of Functionality for application protocols.
 <note>
This application module defines UOF S7 of ISO 10303-214.
 </note>
	</purpose>
	<!-- Items in scope -->
	<inscope>
      <li>product classes used to identify sets of similar products to be offered to the market;</li>
      <li>specifications used to describe characteristics of the products;</li>
      <li>specification categories used to group similar characteristics of the products;</li>
      <li>specification expressions used to control the usage of a part within a product and to represent conditions for product classes; 
</li>
      <li>product functions used to describe the functional requirements for products and components of products; 
</li>
      <li>product components used to describe the common decomposition structure of all products of a product class or of various alternative solutions; 
</li>
      <li>alternative solutions used to describe the variants for a product component or for a product function; 
</li>
      <li>item instances used to identify an occurrence of a component in an assembly structure; 
      	<example number="1">An item instance could identify the elements of an alternative solution.</example>
		</li>
      <li>configurations used to link the parts (item instances), alternative solutions, product components, or product functions with their usage cases; 
      	<example number="2">An usage case is the the conditions under which configurations are used.</example>
		</li>
      <li>product specifications are used to identify a manufacturable product out of a product class by its specific characteristics (specifications); 
      	<example number="3">A customer order for a piece of furniture is a product identification.</example>
		</li>
      <li>items within the scope of application module <module_ref linkend="alternative_solution:1_scope">Alternative solution</module_ref>, ISO/TS 10303-1109;</li>
      <li>items within the scope of application module <module_ref linkend="part_collection:1_scope">Part collection</module_ref>, ISO/TS 10303-1115;</li>
      <li>items within the scope of application module <module_ref linkend="product_placement:1_scope">Product placement</module_ref>, ISO/TS 10303-1343;</li>
      <li>items within the scope of application module <module_ref linkend="requirement_view_definition_arm:1_scope">Requirement view definition</module_ref>, ISO/TS 10303-1141;</li>
      <li>items within the scope of application module <module_ref linkend="specification_based_configuration:1_scope">Specification based configuration</module_ref>, ISO/TS 10303-1108.</li>
   </inscope>
	<!-- Items out of scope -->
	
 <normrefs>
 	<normref.inc normref="ref10303-41"/>
 </normrefs>
 
<!--
 <definition/>

 <abbreviations/>
-->
	<!-- Clause 4 ARM  -->
	<arm>
		<!-- Note ARM short form EXPRESS is in arm_sf.xml -->
		<!-- Units of functionality -->
		<uof name="Specification_Control">
			<description>
The Specification_control UOF specifies the data structure to represent products with a large number of variants.
<example>Examples for automotive products are passenger cars, trucks, busses, or engines or components of these products.
</example>
				<p>Because of the large number of variants, there is no unique identification for each of the variants that could be produced. 
The main concepts that are used to handle this large number of variants are the following: 
</p>
				<ul>
					<li>product classes are used to identify sets of similar products to be offered to the market; 
</li>
					<li>specifications are used to describe characteristics of the products; 
</li>
					<li>specification categories are used to group similar characteristics of the products; 
</li>
					<li>specification expressions are used to control the usage of a part within a product and to represent conditions for product classes; 
</li>
					<li>function elements are used to describe the functional requirements for products and components of products; 
</li>
					<li>physical elements are used to describe the common decomposition structure of all products of a product class or of various alternative solutions; 
</li>
					<li>alternative solutions are used to describe the variants for a product component or for a product function; 
</li>
					<li>item instances are used to identify an occurrence of a component in an assembly structure, for example to identify the elements of an alternative solution; 
</li>
					<li>configurations are used to link the parts (item instances), alternative solutions, physical elements, or function elements with their usage cases, i.e., the conditions under which they are used; 
</li>
					<li>product specifications are used to identify a manufacturable product out of a product class by its specific characteristics (specifications), e.g., a customer order for a car; 
</li>
				</ul>
			</description>
			<uof.ae entity="Breakdown_node_relationship"/>
			<uof.ae entity="Class_breakdown_association"/>
			<uof.ae entity="Design_constraint_context_association"/>
			<uof.ae entity="Design_constraint_definition"/>
			<uof.ae entity="Design_constraint_association"/>
			<uof.ae entity="Part_function_association"/>
			<uof.ae entity="Part_occurrence_relationship"/>
			<uof.ae entity="Replaced_usage_relationship"/>
			<uof.ae entity="Specification_category_breakdown_influence"/>
		</uof>
		<!-- Short form EXPRESS-G -->
		<express-g>
			<imgfile file="armexpg1.xml"/>
			<imgfile file="armexpg2.xml"/>
		</express-g>
	</arm>
	<!-- Clause 5.1 Mapping specification -->
	<mapping_table>
		<ae entity="Configuration" original_module="specification_based_configuration" extensible="NO">
			<aimelt xml:space="preserve">configured_effectivity_assignment</aimelt>
			<source xml:space="preserve">ISO 1033-1108</source>
			<aa attribute="configured_element" assertion_to="Alternative_solution">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
	 configured_effectivity_assignment
	 configured_effectivity_assignment.items[1] -&gt; configured_effectivity_item
	 configured_effectivity_item = product_definition
	 product_definition
	 {product_definition.frame_of_reference -&gt;
	 product_definition_context &lt;=
	 application_context_element
	 application_context_element.name = 'alternative definition'}
	 </refpath>
			</aa>
			<aa attribute="is_solution_for" assertion_to="Class_condition_association">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
	 configured_effectivity_assignment &lt;=
	 effectivity_assignment &lt;- effectivity_context_assignment.assigned_effectivity_assignment
	 {effectivity_context_assignment.role -&gt; effectivity_context_role
	 effectivity_context_role.name = 'specification based condition'}
	 effectivity_context_assignment =&gt; configured_effectivity_context_assignment
	 configured_effectivity_context_assignment.items[1] -&gt; configured_effectivity_context_item
	 configured_effectivity_context_item = product_concept_feature_association
		</refpath>
			</aa>
			<aa attribute="is_solution_for" assertion_to="Class_specification_association">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
	 configured_effectivity_assignment &lt;=
	 effectivity_assignment &lt;- effectivity_context_assignment.assigned_effectivity_assignment
	 {effectivity_context_assignment.role -&gt; effectivity_context_role
	 effectivity_context_role.name = 'specification based condition'}
	 effectivity_context_assignment =&gt; configured_effectivity_context_assignment
	 configured_effectivity_context_assignment.items[1] -&gt; configured_effectivity_context_item
	 configured_effectivity_context_item = product_concept_feature_association
	 </refpath>
			</aa>
			<aa attribute="configuration_type">
				<aimelt xml:space="preserve">object_role.description</aimelt>
				<refpath xml:space="preserve">
	 configured_effectivity_assignment &lt;= effectivity_assignment
	 effectivity_assignment.role -&gt; object_role
	 object_role.description
	 {(object_role.description = 'exception')
	 (object_role.description = 'inherited')
	 (object_role.description = 'local')}
	 </refpath>
			</aa>
			<aa attribute="inheritance_type">
				<aimelt xml:space="preserve">object_role.name</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
				<refpath xml:space="preserve">
	 configured_effectivity_assignment &lt;= effectivity_assignment
   effectivity_assignment.role -&gt; object_role
	 object_role.name
	 {(object_role.name = 'design')
	 (object_role.name = 'usage')}
	 </refpath>
			</aa>
		</ae>
		<ae entity="Design_constraint_definition" extensible="NO">
			<aimelt xml:space="preserve">product_definition</aimelt>
			<source xml:space="preserve">ISO 10303-41</source>
			<rules>constraint_definition_requires_constraint_category</rules>
			<refpath xml:space="preserve">
product_definition.frame_of_reference -&gt; product_definition_context
product_definition_context &lt;= application_context_element
{application_context_element.name = 'design constraint definition'}
</refpath>
		</ae>
		<ae entity="Design_constraint_association" extensible="NO">
			<aimelt xml:space="preserve">product_definition_relationship</aimelt>
			<source xml:space="preserve">ISO 10303-41</source>
			<rules>restrict_product_definitions_for_design_constraint_association</rules>
			<refpath xml:space="preserve">
{product_definition_relationship.name = 'design constraint association'}
</refpath>
			<aa attribute="constraint_definition" assertion_to="Design_constraint_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.relating_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'design constraint definition'}
</refpath>
			</aa>
			<aa attribute="constrained_object" assertion_to="Alternative_solution">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'alternative definition'}
</refpath>
			</aa>
			<aa attribute="constrained_object" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'functional definition'}
</refpath>
			</aa>
			<aa attribute="constrained_object" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'conceptual definition'}
</refpath>
			</aa>
			<aa attribute="name">
				<aimelt xml:space="preserve">product_definition_relationship.description</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
			</aa>
		</ae>
		<ae entity="Design_constraint_context_association" extensible="NO">
			<aimelt xml:space="preserve">configuration_design</aimelt>
			<source xml:space="preserve">ISO 10303-44</source>
			<rules>restrict_configuration_design_for_design_constraint</rules>
			<refpath xml:space="preserve">
{configuration_design.name = 'design constraint usage'}
</refpath>
			<aa attribute="constraint_definition" assertion_to="Design_constraint_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
configuration_design.design -&gt;
configuration_design_item
configuration_design_item = product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'design constraint definition'}
</refpath>
			</aa>
			<aa attribute="constraint_context" assertion_to="Product_class">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
configuration_design
{configuration_design.name = 'design constraint usage'}
configuration_design.configuration -&gt;
configuration_item
{configuration_item.name = 'design constraint usage'}
configuration_item.item_concept -&gt;
product_concept =&gt; 
product_class 
</refpath>
			</aa>
		</ae>
		<ae entity="Class_breakdown_association" extensible="NO">
			<aimelt xml:space="preserve">configuration_design</aimelt>
			<source xml:space="preserve">ISO 10303-44</source>
			<rules>restrict_configuration_design_for_class_breakdown_association</rules>
			<aa attribute="considered_class" assertion_to="Product_class">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
configuration_design.configuration -&gt; configuration_item
{(configuration_item.name = 'functional structure item')
(configuration_item.name = 'conceptual structure item')}
configuration_item.item_concept -&gt;
product_concept =&gt;
product_class
</refpath>
			</aa>
			<aa attribute="breakdown_element" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
configuration_design
{configuration_design.configuration -&gt; configuration_item
configuration_item.name = 'functional structure item'}
configuration_design.design -&gt; configuration_design_item
configuration_design_item = product_definition
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'functional definition'}
</refpath>
			</aa>
			<aa attribute="breakdown_element" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
configuration_design
{configuration_design.configuration -&gt; configuration_item
configuration_item.name = 'conceptual structure item'}
configuration_design.design -&gt; configuration_design_item
configuration_design_item = product_definition
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'conceptual definition'}
</refpath>
			</aa>
			<aa attribute="relation_type">
				<aimelt xml:space="preserve">configuration_design.name</aimelt>
				<source xml:space="preserve">ISO 10303-44</source>
			</aa>
			<aa attribute="description">
				<aimelt xml:space="preserve">configuration_design.description</aimelt>
				<source xml:space="preserve">ISO 10303-44</source>
			</aa>
		</ae>
		<ae entity="Breakdown_node_relationship" extensible="NO">
			<aimelt xml:space="preserve">product_definition_usage</aimelt>
			<source xml:space="preserve">ISO 10303-44</source>
			<aa attribute="relating" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.relating_product_definition -&gt;
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'conceptual definition'}
</refpath>
			</aa>
			<aa attribute="relating" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.relating_product_definition -&gt;
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'functional definition'}
</refpath>
			</aa>
			<aa attribute="relating" assertion_to="Alternative_solution">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.relating_product_definition -&gt;
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'alternative definition'}
</refpath>
			</aa>
			<aa attribute="related" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.related_product_definition -&gt;
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'conceptual definition'}
</refpath>
			</aa>
			<aa attribute="related" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.related_product_definition -&gt;
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'functional definition'}
</refpath>
			</aa>
			<aa attribute="relation_type">
				<aimelt xml:space="preserve">product_definition_relationship.name</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.name
</refpath>
			</aa>
			<aa attribute="description">
				<aimelt xml:space="preserve">product_definition_relationship.description</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
				<refpath xml:space="preserve">
product_definition_usage &lt;= product_definition_relationship
product_definition_relationship.description
</refpath>
			</aa>
		</ae>
		<ae entity="Complex_node_relationship" extensible="NO">
			<aimelt xml:space="preserve">product_definition_formation_relationship</aimelt>
			<source xml:space="preserve">ISO 10303-41</source>
			<aa attribute="relating" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.relating_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='conceptual product'}
</refpath>
			</aa>
			<aa attribute="relating" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.relating_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='functionality'}
</refpath>
			</aa>
			<aa attribute="relating" assertion_to="Alternative_solution">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.relating_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='alternative solution'}
</refpath>
			</aa>
			<aa attribute="related" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.related_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='conceptual product'}
</refpath>
			</aa>
			<aa attribute="related" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.related_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='functionality'}
</refpath>
			</aa>
			<aa attribute="related" assertion_to="Alternative_solution">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_formation_relationship.related_product_definition_formation -&gt;
product_definition_formation
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='alternative solution'}
</refpath>
			</aa>
			<aa attribute="relation_type">
				<aimelt xml:space="preserve">product_definition_formation_relationship.name</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
			</aa>
			<aa attribute="description">
				<aimelt xml:space="preserve">product_definition_formation_relationship.description</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
			</aa>
		</ae>
		
		<ae entity="Effectivity_assignment" original_module="effectivity_application" extensible="NO">
			<aa attribute="items" assertion_to="Replaced_usage_relationship">
				<refpath_extend extended_select="effectivity_item" xml:space="preserve">
       			effectivity_item *&gt; effectivity_specification_for_replacement
       			effectivity_specification_for_replacement = product_definition_substitute
     			</refpath_extend>
			</aa>
		</ae>
		
		<ae entity="Part_function_association" extensible="NO">
			<aimelt xml:space="preserve">product_definition_relationship</aimelt>
			<source xml:space="preserve">ISO 10303-41</source>
			<aa attribute="relating_view" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.relating_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'functional definition'}
</refpath>
			</aa>
			<aa attribute="related_view" assertion_to="Part_view_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part definition'}
</refpath>
			</aa>
		</ae>
		<ae entity="Part_occurrence_relationship" extensible="NO">
			<alt_map id="1">
				<description>If the Part_occurrence_relationship is not a Replaced_usage_relationship</description>
				<aimelt xml:space="preserve">product_definition_relationship</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
			</alt_map>
			<alt_map id="2">
				<description>If the Part_occurrence_relationship is a Replaced_usage_relationship</description>
				<aimelt xml:space="preserve">product_definition_substitute</aimelt>
				<source xml:space="preserve">ISO 10303-41</source>
			</alt_map>
			<aa attribute="SELF\Product_view_definition.relating_view" assertion_to="Part_occurrence">
				<alt_map alt_map.inc="1">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_relationship.relating_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
				<alt_map alt_map.inc="2">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.context_relationship -&gt;
product_definition_relationship.relating_product_definition -&gt; 
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
			</aa>
			<aa attribute="relating_view" assertion_to="Part_occurrence">
				<alt_map alt_map.inc="1">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_relationship.relating_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
				<alt_map alt_map.inc="2">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.context_relationship -&gt;
product_definition_relationship.relating_product_definition -&gt; 
product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
			</aa>
			<aa attribute="related_view" assertion_to="Part_occurrence">
				<alt_map alt_map.inc="1">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
				<alt_map alt_map.inc="2">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.substitute_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
			</aa>
			<aa attribute="SELF\Product_view_definition.related_view" assertion_to="Part_occurrence">
				<alt_map alt_map.inc="1">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_relationship.related_product_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
				<alt_map alt_map.inc="2">
					<aimelt xml:space="preserve">PATH</aimelt>
					<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.substitute_definition -&gt; product_definition
{product_definition.frame_of_reference -&gt;
product_definition_context &lt;=
application_context_element
application_context_element.name = 'part occurrence'}
</refpath>
				</alt_map>
			</aa>
		</ae>
		<ae entity="Replaced_usage_relationship" extensible="NO">
			<aimelt xml:space="preserve">product_definition_substitute</aimelt>
			<source xml:space="preserve">ISO 10303-41</source>
			<aa attribute="usage_context" assertion_to="instance_usage_context_select">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
					product_definition_substitute
					product_definition_substitute.substitute_definition -&gt;
					product_definition
					product_definition.frame_of_reference -&gt;
					product_definition_context
					product_definition_context =&gt;
					instance_usage_context_assignment
					instance_usage_context_assignment.items[i] -&gt;
					instance_usage_context_select 
				</refpath>
			</aa>
			<aa attribute="usage_context" assertion_to="Solution_element">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.context_relationship -&gt;
product_definition_relationship =&gt;
product_definition_usage
{product_definition_relationship.name = 'realization'}
</refpath>
			</aa>
			<aa attribute="usage_context" assertion_to="Collected_item_association">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
product_definition_substitute
product_definition_substitute.context_relationship -&gt;
product_definition_relationship
{product_definition_relationship.name = 'collection membership'}
</refpath>
			</aa>
		</ae>
		<ae entity="Specification_category_breakdown_influence" extensible="NO">
			<aimelt xml:space="preserve">class_usage_effectivity_context_assignment</aimelt>
			<source xml:space="preserve">ISO 10303-1112</source>
			<aa attribute="influencing_category" assertion_to="Class_category_association">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
class_usage_effectivity_context_assignment &lt;=
effectivity_context_assignment
{effectivity_context_assignment.role -&gt;
effectivity_context_role
effectivity_context_role.name = 'class usage influence'}
effectivity_context_assignment.assigned_effectivity_assignment -&gt;
effectivity_assignment
{effectivity_assignment.assigned_effectivity -&gt;
|effectivity|
effectivity.id = 'class usage'}
effectivity_assignment =&gt;
applied_effectivity_assignment
applied_effectivity_assignment.items[i] -&gt;
effectivity_item
effectivity_item = product_concept_feature_category_usage
product_concept_feature_category_usage
</refpath>
			</aa>
			<aa attribute="influenced_breakdown_node" assertion_to="Physical_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
class_usage_effectivity_context_assignment
class_usage_effectivity_context_assignment.items[1] -&gt; class_usage_effectivity_context_item
class_usage_effectivity_context_item = product_definition
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='conceptual product'}
</refpath>
			</aa>
			<aa attribute="influenced_breakdown_node" assertion_to="Functional_element_definition">
				<aimelt xml:space="preserve">PATH</aimelt>
				<refpath xml:space="preserve">
class_usage_effectivity_context_assignment
class_usage_effectivity_context_assignment.items[1] -&gt; class_usage_effectivity_context_item
class_usage_effectivity_context_item = product_definition
{product_definition_formation.of_product -&gt; product
product &lt;-
product_related_product_category.products[i]
product_related_product_category &lt;= product_category
product_category.name='functional product'}
</refpath>
			</aa>
		</ae>
	</mapping_table>
	<!-- Clause 5.2 MIM -->
	<mim>
		<!--  Note MIM short form express is in mim.xml -->
		<express-g>
			<imgfile file="mimexpg1.xml"/>
			<imgfile file="mimexpg2.xml"/>
		</express-g>
		<shortnames>
			<shortname name="CUECA" entity="class_usage_effectivity_context_assignment"/>
			<shortname name="IUCA" entity="instance_usage_context_assignment"/>
		</shortnames>
	</mim>
	<usage_guide>
This clause describes the MIM entities used by this part of ISO 10303 that provide the capability to describe products proposed to the market with a large number of variants.

<example number="1">Examples for automotive products are passenger cars, trucks, busses, engines, or components of these products.
</example>
		<example number="2">
Examples for furniture products are sofas, wardrobes, kitchens, or components of these products.
</example>
Because of the large number of variants, there is no explicit representation for each of the variants that could be produced. 
The main concepts that are used to handle this large number of variants are illustrated in Figure F.1.
   <figure id="f1" number="F.1">
			<title>Main concepts of specification control</title>
			<img src="fig_81.gif"/>
		</figure>
These main concepts are the following:
<ul>
			<li>
				<b>product_class</b> is used to identify a set of similar products to be offered to the market; 
A product_class is a product_concept and a characterized_object. 
The characterized_object may have property_definition entities associated to it through property_definition.definition and the select type characterized_definition.
<p>The instances of product_class may build a hierarchical tree-like structure through instances of product_concept_relationship that have the attribute name set to 'hierarchy' and that reference with the attribute related_product_concept the product_class that is a subclass of the product_class referenced by the attribute relating_product_concept.
</p>
				<note number="1">
Since the market context information is not needed from an ARM perspective or would be represented using an particular product_concept_feature, 
the mandatory attribute market_context points to an entity product_concept_context with:
<dl>
						<dt>- attribute market_segment_type ='/NULL'
</dt>
						<dt> 
- inherited attribute application_context_element.name = '/NULL' 
</dt>
					</dl>
				</note>
			</li>
			<li>
				<b>product_concept_feature</b> is used to describe a characteristic of the products within a product_class. 
<p>The product_concept_feature is associated to a product_class through a product_concept_feature_association with the attribute name set to 'replaceable standard', 'non replaceable standard', 'availability', 'identification', 'option', 'part usage', or any other non standardized value.

For a definition of the meaning of the standardized values, see ARM definition of Class_specification_association. 
</p>
				<b>package_product_concept_feature</b> is a subtype of product_concept_feature that is used when the characteristic is in fact a set of other characteristics, for example a package of several options for a passenger car. 
In this case, there is an inclusion_product_concept_feature, a subtype of conditional_concept_feature, with the inherited attribute condition referencing a concept_feature_relationship_with_condition with the attribute conditional_operator set to 'implication'. 
The inherited attribute relating_product_concept_feature of the concept_feature_relationship_with_condition references the package_product_concept_feature, and the inherited attribute related_product_concept_feature references either the one product_concept_feature that belongs to the package or another conditional_concept_feature that references the product_concept_feature instances of the package through an 'and' operation.
Figure F.2 provides an example of package with two product_concept_feature.
   <figure id="f2" number="F.2">
					<title>Package of two specifications</title>
					<img src="fig_82.gif"/>
				</figure>
			</li>
			<li>
				<b>product_concept_feature_category</b> is used to group similar instances of product_concept_feature, like the different outside colour characteristics of the products. 
A product_concept_feature_category is a group of instances of product_concept_feature. 
Instances of product_concept_feature are assigned to their product_concept_feature_category through an instance of applied_group_assignment. 
For this group_assignment, the attribute items references, through the select type group_item, instances of product_concept_feature or package_product_concept_feature, the attribute assigned_group references product_concept_feature_category or exclusive_product_concept_feature_category, the attribute role references object_role with the attribute name set to 'specification category member'.

<p>exclusive_product_concept_feature_category is a subtype of product_concept_feature_category that is used when the members of the group are mutually exclusive in their usage within a product.
</p>
				<example number="3">An exclusive_product_concept_feature_category would be used if there is exactly one outside colour that can be chosen for a particular product. 
</example>
				<p>

product_concept_feature_category is associated to product_class through product_concept_feature_category_usage that is subtype of group_assignment. 
For this group_assignment the attribute items references, through the select type category_usage_item, an instance of product_class, the attribute assigned_group references product_concept_feature_category or exclusive_product_concept_feature_category, the attribute role references object_role with the attribute name set to 'mandatory category usage' or 'optional category usage'. For a definition of the meaning of the two values, see ARM definition of Class_category_association.
</p>
			</li>
			<li>
				<b>conditional_concept_feature</b> is used to control the usage of a product classified as 'part' or 'tool' (by product_related_product_category) within the products of a product_class and to represent global conditions for instances of a product_class. 
The conditional_concept_feature is subtype of product_concept_feature.

<p>The conditional_concept_feature is used to build up boolean conditions for instances of product_concept_feature. 
The conditional_concept_feature references with its attribute condition a concept_feature_relationship_with_condition that represents a binary boolean operation. 
A concept_feature_relationship_with_condition is subtype of concept_feature_relationship with the attribute conditional_operator pointing to a concept_feature_operator with the attribute name set to 'and', 'or', 'oneof', 'not', or 'implication'. 
The intended usage of the unary 'not' operation is that the inherited attributes relating_product_concept_feature and related_product_concept_feature reference the same instance of product_concept_feature.
The value 'implication' is only allowed, if the inclusion_product_concept_feature subtype of conditional_concept_feature is used. 
This is ensured by the rule restrict_concept_feature_operator. 
</p>
For a definition of the meaning of the other values, see ARM definition of Specification_expression.

<p>conditional_concept_feature may be associated to a product_class through product_concept_feature_association with the attribute name set to 'part usage', 'identification', 'validity', 'design case', or any other non standardized value. 
For a definition of the meaning of the standardized values, see ARM definition of Class_condition_association. 
</p>
				<p>The value 'part usage', which is also applicable for the association of a product_concept_feature to a product_class, see above, indicates that the conditional_concept_feature (or product_concept_feature) controls the usage of a part within a product of the associated product_class.
In this case, the product_concept_feature_association is referenced by a configured_effectivity_context_assignment that is a subtype of effectivity_context_assignment through the select type configured_effectivity_context_item.
</p>
			</li>
			<li>
				<b>product_definition</b> that has a product_definition_context with the inherited attribute name set to 'functional definition'.
It is used to describe the functional requirements for the products or the components of the products of a product_class. 
<p>Such instances of product_definition for functional requirements may be related to instances of product_class through an instance of configuration_design and configuration_item. 
In this case the attribute name of configuration_design is set to 'functionality'. 
For a definition of the meaning of the standardized value, see ARM definition of Class_breakdown_association.
</p>
			</li>
			<li>
				<b>product_definition</b> that has a product_definition_context with the inherited attribute name set to 'conceptual definition'.
It is used to describe the common decomposition structure of all products of a product_class.
<p>Such instances of product_definition for a common decomposition structure may be related to instances of product_class through an instance of configuration_design and configuration_item. 
In this case the attribute name of configuration_design is set to 'realization'.
For a definition of the meaning of the standardized value, see ARM definition of Class_breakdown_association.
</p>
			</li>
			<li>
				<b>product_definition</b> that has a product_definition_context with the inherited attribute name set to 'alternative definition'.
It is used to describe a variant in the realization of a product_definition with context 'functional definition' or 'conceptual definition'. 
<p>An instance of product_definition with context 'alternative definition' shall be associated to another product definition where it is a variant of through an instance of product_definition_relationship with the attribute name set to 'solution alternative definition'. 
The related_product_definition points to the variant (with context 'alternative definition') and the relating_product_definition references a product_definition with context 'functional definition', 'conceptual definition', or 'alternative definition'. 
In the latter case, the product_definition instance with context 'alternative solution' defines a variant of another instance of product_definition with context 'alternative solution', for example, where the first level defines technically different solutions and the second level defines different suppliers for the same technical solution.
</p>
				<p>All instances of product_definition with context 'alternative definition' that are defined through this path as variant of the same instance of product_definition are the mutually exclusive variants.
</p>
			</li>
			<li>
				<b>product_definition</b> that has a product_definition_context with the inherited attribute name set to 'part occurrence'.
It is used to identify an occurrence of a component in an assembly structure, for example, to identify the component occurrences of a product_definition with context 'alternative definition'. 
A product_definition with context 'part occurrence' defines exactly one occurrence of a part within a given assembly structure. 
<p>An instance of product_definition with context 'part occurrence' may be defined as an element (as related_product_definition), of a product_definition instance with context 'alternative solution' (as relating_product_definition), through a product_defininition_relationship with the attribute name set to 'realization'.
</p>
				<p>A product_definition with context 'part occurrence' may also represent a component occurrence in an explicit product structure defined by assembly_component_usage.
In this case it is linked to the assembly_component_usage by a product_definition_occurrence_relationship.
</p>
			</li>
			<li>
				<b>product_definition_usage</b> with the attribute name set to 'decomposition', 'occurrence', 'realization', 'functionality', or 'specialization' is used to define the structure for product_definition instances with context 'functional definition', 'conceptual definition', or 'alternative definition' as relating_product_definition. 
The related_product_definition is an instance of product_definition with context 'functional definition', 'conceptual definition', or 'part occurrence'. 
<p>With this tree-like decomposition structures for product_definition instances with the same context, attribute name set to 'decomposition', 'specialization', or 'occurrence' as well as relationships between product_definition_instances with different context, attribute name set to 'realization' or 'functionality', can be defined. 
For a detailed definition of the meaning of the standardized values for the attribute name of product_definition_relationship, see ARM definition of Breakdown_node_relationship.
</p>
			</li>
			<li>
				<b>configured_effectivity_context_assignment</b> and <b>configured_effectivity_assignment</b> are used to link a product_definition instance with context 'part occurrence', 'alternative definition', 'conceptual definition', or 'functional definition' with the condition under which it is used or designed.
The configured_effectivity_context_assignment is a subtype of effectivity_context_assignment that references with its attribute items, through the select type configured_effectivity_context_item, the product_concept_feature_association that defines the usage case or condition. 
The inherited attribute assigned_effectivity_assignment references the configured_effectivity_assignment instance.

<p>configured_effectivity_assignment is a subtype of effectivity_assignment that references with its attribute items, through the select type configured_effectivity_item, the product_definition with context 'part occurrence', 'alternative definition', 'conceptual definition', or 'functional definition' to which the usage case or condition applies. 
The attribute role references an object_role instance with the attribute name set to 'design' or 'usage' and with the attribute description set to 'inherited', 'local', or 'exception'. 
For a definition of the meaning of the standardized values for the name attribute and for the description attribute, see ARM definition of Configuration.
</p>
				<p>configured_effectivity_assignment references with its inherited attribute assigned_effectivity an instance of effectivity with an id of 'configuration validity' to indicate the valid use of the item contained in the items attribute. dated_effectivity or time_interval_based_effectivity instances may additionally be assigned to a configured_effectivity_assignment through applied_effectivity_assignment instances to indicate the time range for which the configuration is valid.
</p>
			</li>
			<li>
				<b>product_identification</b> and <b>product_specification</b> are used to identify a potentially manufacturable product selected among a product_class by its specific characteristics (product_concept_feature instances), for example, a customer order for a passenger car. 
Both these entities are subtypes of configuration_item.
They reference with their inherited attribute item_concept, the product_class of the manufacturable product. 
The attribute item_concept_feature of product_specification points to a set of product_concept_feature_association instances that define the specified characteristics of the manufacturable product.
</li>
		</ul>
	</usage_guide>

<bibliography>
	<bibitem.inc ref="ISO10303-214"/>
	<bibitem.inc ref="ref8824-1"/>
	<bibitem.inc ref="AMConGde06"/>
</bibliography>
</module>
