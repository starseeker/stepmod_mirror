<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: arm_lf.xml,v 1.3 2006/03/01 10:33:26 dmprice Exp $ -->
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<?xml-stylesheet type="text/xsl"
href="../../../xsl/express.xsl" ?>
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name=" Eurostep EXPRESS Parser (Eep!)"
    owner="Eurostep Limited"
    url="www.eurostep.com"
    version="1, 3, 26, 36"
    source="C:\sourceforge\stepmod\stepmod\data\modules\state_based_behaviour\arm_lf.exp"/>

  <schema name="state_based_behaviour_arm_lf">
    <type name="alias_identification_item">
      <select
        selectitems="Behaviour Behaviour_version"
      />
    </type>

    <type name="any_number_value">
      <builtintype type="NUMBER"
      />
    </type>

    <type name="any_string_value">
      <builtintype type="STRING"
      />
    </type>

    <type name="assigned_name_select">
      <select
        selectitems="Activity_method Condition Description_text_assignment External_class_library General_model_parameter Product Product_view_definition State_based_behaviour_model State_definition State_transition_definition"
      />
    </type>

    <type name="behaviour_and_version_identification_item">
      <select
        selectitems="Behaviour Behaviour_version"
      />
    </type>

    <type name="behaviour_item">
      <select
        selectitems="Behaviour_view_definition"
      />
    </type>

    <type name="behaviour_model">
      <select
        selectitems="State_based_behaviour_model"
      />
    </type>

    <type name="behaviour_view_definition_identification_item">
      <select
        selectitems="Behaviour_view_definition"
      />
    </type>

    <type name="classification_item">
      <select
        selectitems="Activity_method Applied_state_definition_assignment Behaviour Behaviour_view_definition Condition Condition_assignment Condition_parameter Condition_relationship Constrained_general_parameter_relationship Description_text Description_text_assignment General_model_parameter Parameter_value_representation_item Product Product_version Product_view_definition State_based_behaviour_model State_definition State_definition_relationship"
      />
    </type>

    <type name="condition_classification_item">
      <select
        selectitems="Condition Condition_assignment Condition_parameter Condition_relationship"
      />
    </type>

    <type name="condition_item">
      <select
        selectitems="State_transition_definition"
      />
    </type>

    <type name="condition_parameter_item">
      <select
        selectitems="Condition_relationship Generic_expression Product_view_definition Value_with_unit"
      />
    </type>

    <type name="description_item">
      <select
        selectitems="Activity_method Behaviour Behaviour_version Behaviour_view_definition Condition General_model_parameter Product Product_version Product_view_definition State_based_behaviour_model State_definition State_definition_relationship"
      />
    </type>

    <type name="expression_assignment_item">
      <select
        selectitems="Condition"
      />
    </type>

    <type name="external_class_assigned_name_select">
      <select
        selectitems="External_class_library"
      />
    </type>

    <type name="gmp_classification_item">
      <select
        selectitems="Constrained_general_parameter_relationship General_model_parameter Parameter_value_representation_item"
      />
    </type>

    <type name="identification_item">
      <select
        selectitems="Activity_method Behaviour_view_definition Product Product_version Product_view_definition State_based_behaviour_model"
      />
    </type>

    <type name="length_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="measure_value">
      <select
        selectitems="any_number_value any_string_value length_measure plane_angle_measure"
      />
    </type>

    <type name="parameter_value_select">
      <select
        selectitems="Generic_expression Product_view_definition Value_with_unit"
      />
    </type>

    <type name="plane_angle_measure">
      <builtintype type="REAL"
      />
    </type>

    <type name="property_assignment_select">
      <select
        selectitems="Activity_method Behaviour_view_definition Product_view_definition"
      />
    </type>

    <type name="represented_definition">
      <select
        selectitems="Assigned_property Independent_property"
      />
    </type>

    <type name="sbb_assigned_name_select">
      <select
        selectitems="Activity_method Condition Description_text_assignment General_model_parameter Product Product_view_definition State_based_behaviour_model State_definition State_transition_definition"
      />
    </type>

    <type name="sbb_behaviour_model">
      <select
        selectitems="State_based_behaviour_model"
      />
    </type>

    <type name="sbb_classification_item">
      <select
        selectitems="Activity_method Applied_state_definition_assignment Behaviour Behaviour_view_definition Condition Description_text Description_text_assignment General_model_parameter Product Product_version Product_view_definition State_based_behaviour_model State_definition State_definition_relationship"
      />
    </type>

    <type name="sbb_condition_item">
      <select
        selectitems="State_transition_definition"
      />
    </type>

    <type name="sbb_condition_parameter_item">
      <select
        selectitems="Condition_relationship parameter_value_select"
      />
    </type>

    <type name="sbb_description_item">
      <select
        selectitems="Activity_method Behaviour Behaviour_version Behaviour_view_definition Condition General_model_parameter Product Product_version Product_view_definition State_based_behaviour_model State_definition State_definition_relationship"
      />
    </type>

    <type name="sbb_expression_assignment_item">
      <select
        selectitems="Condition"
      />
    </type>

    <type name="sbb_identification_item">
      <select
        selectitems="Activity_method Product Product_version Product_view_definition State_based_behaviour_model"
      />
    </type>

    <type name="sbb_parameter_value_select">
      <select
        selectitems="Generic_expression Product_view_definition Value_with_unit"
      />
    </type>

    <type name="sbb_property_assignment_select">
      <select
        selectitems="Activity_method Behaviour_view_definition Product_view_definition"
      />
    </type>

    <type name="sbb_state_definition_of_item">
      <select
        selectitems="Product_view_definition"
      />
    </type>

    <type name="state_based_behaviour_element">
      <select
        selectitems="State_definition State_definition_relationship"
      />
    </type>

    <type name="state_definition_of_item">
      <select
        selectitems="Product_view_definition"
      />
    </type>

    <entity name="Abs_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Acos_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Activity_method"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="consequence"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="purpose">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Alias_identification"
      supertypes="Identification_assignment"
    >
      <derived
        name="role"
        expression="&apos;alias&apos;">
        <builtintype type="STRING"
        />
        <redeclaration
          entity-ref="Identification_assignment"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(QUERY(item &lt;* SELF\Identification_assignment.items | NOT (&apos;ALIAS_IDENTIFICATION_ARM.ALIAS_IDENTIFICATION_ITEM&apos; IN TYPEOF(item)))) = 0">
      </where>
    </entity>

    <entity name="Amount_of_substance_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="And_expression"
      supertypes="Multiple_arity_boolean_expression"
    >
    </entity>

    <entity name="Applied_independent_property"
      supertypes="Assigned_property"
    >
      <explicit
        name="base_independent_property">
        <typename name="Independent_property"/>
      </explicit>
      <derived
        name="name"
        expression="base_independent_property.property_type">
        <builtintype type="STRING"
        />
        <redeclaration
          entity-ref="Assigned_property"/>
      </derived>
    </entity>

    <entity name="Applied_state_definition_assignment"
    >
      <explicit
        name="described_state_definition">
        <typename name="State_definition"/>
      </explicit>
      <explicit
        name="assigned_to">
        <typename name="state_definition_of_item"/>
      </explicit>
      <explicit
        name="role">
        <typename name="State_definition_role"/>
      </explicit>
    </entity>

    <entity name="Asin_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Assigned_property"
    >
      <explicit
        name="id"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="described_element">
        <typename name="property_assignment_select"/>
      </explicit>
    </entity>

    <entity name="Atan_function"
      supertypes="Binary_function_call"
    >
    </entity>

    <entity name="Behaviour"
      supertypes="Product"
    >
    </entity>

    <entity name="Behaviour_description_association"
    >
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="representation">
        <typename name="behaviour_model"/>
      </explicit>
      <explicit
        name="represented_item">
        <typename name="behaviour_item"/>
      </explicit>
      <explicit
        name="role"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Behaviour_version"
      supertypes="Product_version"
    >
      <explicit
        name="of_product">
        <typename name="Behaviour"/>
        <redeclaration
          entity-ref="Product_version"/>
      </explicit>
    </entity>

    <entity name="Behaviour_version_sequence"
      supertypes="Product_version_relationship"
    >
      <explicit
        name="predecessor">
        <typename name="Behaviour_version"/>
        <redeclaration
          entity-ref="Product_version_relationship"
          old_name="relating_version"/>
      </explicit>
      <explicit
        name="successor">
        <typename name="Behaviour_version"/>
        <redeclaration
          entity-ref="Product_version_relationship"
          old_name="related_version"/>
      </explicit>
    </entity>

    <entity name="Behaviour_view_definition"
      supertypes="Product_view_definition"
    >
      <explicit
        name="defined_version">
        <typename name="Behaviour_version"/>
        <redeclaration
          entity-ref="Product_view_definition"/>
      </explicit>
    </entity>

    <entity name="Binary_boolean_expression"
      abstract.supertype="YES"
      supertypes="Boolean_expression Binary_generic_expression"
      super.expression="ONEOF(Xor_expression, Equals_expression)"
    >
    </entity>

    <entity name="Binary_function_call"
      abstract.supertype="YES"
      supertypes="Binary_numeric_expression"
      super.expression="Atan_function"
    >
    </entity>

    <entity name="Binary_generic_expression"
      abstract.supertype="YES"
      supertypes="Generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="Generic_expression"/>
      </explicit>
    </entity>

    <entity name="Binary_numeric_expression"
      abstract.supertype="YES"
      supertypes="Numeric_expression Binary_generic_expression"
      super.expression="ONEOF(Minus_expression, Div_expression, Mod_expression, Slash_expression, Power_expression, Binary_function_call)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="Numeric_expression"/>
        <redeclaration
          entity-ref="Binary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Boolean_defined_function"
      abstract.supertype="YES"
      supertypes="Defined_function Boolean_expression"
    >
    </entity>

    <entity name="Boolean_expression"
      abstract.supertype="YES"
      supertypes="Expression"
      super.expression="ONEOF(Simple_boolean_expression, Unary_boolean_expression, Binary_boolean_expression, Multiple_arity_boolean_expression, Comparison_expression, Interval_expression, Boolean_defined_function)"
    >
    </entity>

    <entity name="Boolean_literal"
      supertypes="Simple_boolean_expression Generic_literal"
    >
      <explicit
        name="the_value">
        <builtintype type="BOOLEAN"
        />
      </explicit>
    </entity>

    <entity name="Boolean_variable"
      supertypes="Simple_boolean_expression Variable"
    >
    </entity>

    <entity name="Class"
      super.expression="ONEOF(Class_by_extension, Class_by_intension)"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Class_by_extension"
      supertypes="Class"
    >
    </entity>

    <entity name="Class_by_intension"
      supertypes="Class"
    >
    </entity>

    <entity name="Classification_assignment"
    >
      <explicit
        name="assigned_class">
        <typename name="Class"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="classification_item"/>
      </explicit>
      <explicit
        name="role"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Comparison_equal"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Comparison_expression"
      abstract.supertype="YES"
      supertypes="Boolean_expression Binary_generic_expression"
      super.expression="ONEOF(Comparison_equal, Comparison_greater, Comparison_greater_equal, Comparison_less, Comparison_less_equal, Comparison_not_equal, Like_expression)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="Expression"/>
        <redeclaration
          entity-ref="Binary_generic_expression"/>
      </explicit>
      <where
        label="WR1"
        expression="((&apos;NUMERIC_EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[1])) AND (&apos;NUMERIC_EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[2]))) OR ((&apos;BOOLEAN_EXPRESSION_ARM.BOOLEAN_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[1])) AND (&apos;BOOLEAN_EXPRESSION_ARM.BOOLEAN_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[2]))) OR ((&apos;STRING_EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[1])) AND (&apos;STRING_EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF\Binary_generic_expression.operands[2])))">
      </where>
    </entity>

    <entity name="Comparison_greater"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Comparison_greater_equal"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Comparison_less"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Comparison_less_equal"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Comparison_not_equal"
      supertypes="Comparison_expression"
    >
    </entity>

    <entity name="Composition_of_state_definition"
      supertypes="State_definition_relationship"
    >
      <explicit
        name="whole">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
        <redeclaration
          entity-ref="State_definition_relationship"
          old_name="relating"/>
      </explicit>
      <explicit
        name="part">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
        <redeclaration
          entity-ref="State_definition_relationship"
          old_name="related"/>
      </explicit>
    </entity>

    <entity name="Concat_expression"
      supertypes="String_expression Multiple_arity_generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="String_expression"/>
        <redeclaration
          entity-ref="Multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Condition"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Condition_assignment"
    >
      <explicit
        name="assigned_condition">
        <typename name="Condition"/>
      </explicit>
      <explicit
        name="item">
        <typename name="condition_item"/>
      </explicit>
    </entity>

    <entity name="Condition_parameter"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="condition">
        <typename name="Condition"/>
      </explicit>
      <explicit
        name="parameter"
        optional="YES">
        <typename name="condition_parameter_item"/>
      </explicit>
    </entity>

    <entity name="Condition_relationship"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="relating_condition">
        <typename name="Condition"/>
      </explicit>
      <explicit
        name="related_condition">
        <typename name="Condition"/>
      </explicit>
    </entity>

    <entity name="Constrained_general_parameter_relationship"
      supertypes="Independent_property_relationship"
    >
      <explicit
        name="relating">
        <typename name="General_model_parameter"/>
        <redeclaration
          entity-ref="Independent_property_relationship"/>
      </explicit>
      <explicit
        name="related">
        <typename name="General_model_parameter"/>
        <redeclaration
          entity-ref="Independent_property_relationship"/>
      </explicit>
      <explicit
        name="required_class">
        <typename name="Class"/>
      </explicit>
      <where
        label="WR1"
        expression="(required_class.id IN CLASSOF(related)) AND (required_class.id IN CLASSOF(relating))">
      </where>
    </entity>

    <entity name="Context_dependent_unit"
      supertypes="Unit"
    >
      <where
        label="WR1"
        expression="EXISTS(SELF\Unit.name)">
      </where>
    </entity>

    <entity name="Conversion_based_unit"
      supertypes="Unit"
    >
      <explicit
        name="conversion_factor">
        <typename name="Value_with_unit"/>
      </explicit>
      <where
        label="WR1"
        expression="EXISTS(SELF\Unit.name)">
      </where>
    </entity>

    <entity name="Cos_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Defined_function"
      abstract.supertype="YES"
    >
    </entity>

    <entity name="Derived_unit"
      supertypes="Unit"
    >
      <explicit
        name="elements">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="Derived_unit_element"/>
      </explicit>
    </entity>

    <entity name="Derived_unit_element"
    >
      <explicit
        name="base_unit">
        <typename name="Unit"/>
      </explicit>
      <explicit
        name="exponent">
        <builtintype type="REAL"
        />
      </explicit>
    </entity>

    <entity name="Description_text"
    >
      <explicit
        name="description">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Description_text_assignment"
    >
      <explicit
        name="description">
        <typename name="Description_text"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="description_item"/>
      </explicit>
    </entity>

    <entity name="Div_expression"
      supertypes="Binary_numeric_expression"
    >
    </entity>

    <entity name="Duration"
      supertypes="Value_with_unit"
    >
      <where
        label="WR1"
        expression="&apos;VALUE_WITH_UNIT_ARM.&apos; + &apos;TIME_UNIT&apos; IN TYPEOF(SELF\Value_with_unit.unit)">
      </where>
    </entity>

    <entity name="Electric_current_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Environment"
    >
      <explicit
        name="syntactic_representation">
        <typename name="Generic_variable"/>
      </explicit>
      <explicit
        name="semantics">
        <typename name="Variable_semantics"/>
      </explicit>
    </entity>

    <entity name="Equals_expression"
      supertypes="Binary_boolean_expression"
    >
    </entity>

    <entity name="Exp_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Expression"
      abstract.supertype="YES"
      supertypes="Generic_expression"
      super.expression="ONEOF(Numeric_expression, Boolean_expression, String_expression)"
    >
    </entity>

    <entity name="Expression_assignment"
    >
      <explicit
        name="expression">
        <typename name="Expression"/>
      </explicit>
      <explicit
        name="item">
        <typename name="expression_assignment_item"/>
      </explicit>
    </entity>

    <entity name="External_class"
      supertypes="Class"
    >
      <explicit
        name="external_source">
        <typename name="External_class_library"/>
      </explicit>
    </entity>

    <entity name="External_class_library"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Format_function"
      supertypes="String_expression Binary_generic_expression"
    >
      <derived
        name="value_to_format"
        expression="SELF\Binary_generic_expression.operands[1]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="format_string"
        expression="SELF\Binary_generic_expression.operands[2]">
        <typename name="Generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="((&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos;) IN TYPEOF(value_to_format)) AND ((&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos;) IN TYPEOF(format_string))">
      </where>
    </entity>

    <entity name="General_model_parameter"
      supertypes="Independent_property"
    >
    </entity>

    <entity name="Generic_expression"
      abstract.supertype="YES"
      super.expression="ONEOF(Simple_generic_expression, Unary_generic_expression, Binary_generic_expression, Multiple_arity_generic_expression)"
    >
      <where
        label="WR1"
        expression="Is_Acyclic(SELF)">
      </where>
    </entity>

    <entity name="Generic_literal"
      abstract.supertype="YES"
      supertypes="Simple_generic_expression"
    >
    </entity>

    <entity name="Generic_variable"
      abstract.supertype="YES"
      supertypes="Simple_generic_expression"
      super.expression="Variable"
    >
      <inverse
        name="interpretation"
        entity="Environment"
        attribute="syntactic_representation">
      </inverse>
    </entity>

    <entity name="Identification_assignment"
    >
      <explicit
        name="identifier">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="role">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="identification_item"/>
      </explicit>
    </entity>

    <entity name="Independent_property"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="property_type">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Independent_property_relationship"
    >
      <explicit
        name="relation_type">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="relating">
        <typename name="Independent_property"/>
      </explicit>
      <explicit
        name="related">
        <typename name="Independent_property"/>
      </explicit>
    </entity>

    <entity name="Independent_property_representation"
      supertypes="Property_definition_representation"
    >
      <explicit
        name="property">
        <typename name="Independent_property"/>
        <redeclaration
          entity-ref="Property_definition_representation"
          old_name="definition"/>
      </explicit>
    </entity>

    <entity name="Index_expression"
      supertypes="String_expression Binary_generic_expression"
    >
      <derived
        name="operand"
        expression="SELF\Binary_generic_expression.operands[1]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="index"
        expression="SELF\Binary_generic_expression.operands[2]">
        <typename name="Generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="(&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(operand)) AND (&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(index))">
      </where>
      <where
        label="WR2"
        expression="Is_int_expr(index)">
      </where>
    </entity>

    <entity name="Int_literal"
      supertypes="Literal_number"
    >
      <explicit
        name="the_value">
        <builtintype type="INTEGER"
        />
        <redeclaration
          entity-ref="Literal_number"/>
      </explicit>
    </entity>

    <entity name="Int_numeric_variable"
      supertypes="Numeric_variable"
    >
    </entity>

    <entity name="Int_value_function"
      supertypes="Value_function"
    >
    </entity>

    <entity name="Integer_defined_function"
      abstract.supertype="YES"
      supertypes="Numeric_defined_function"
    >
    </entity>

    <entity name="Interval_expression"
      supertypes="Boolean_expression Multiple_arity_generic_expression"
    >
      <derived
        name="interval_low"
        expression="SELF\Multiple_arity_generic_expression.operands[1]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="interval_item"
        expression="SELF\Multiple_arity_generic_expression.operands[2]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="interval_high"
        expression="SELF\Multiple_arity_generic_expression.operands[3]">
        <typename name="Generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="(&apos;EXPRESSION_ARM.EXPRESSION&apos; IN TYPEOF(interval_low)) AND (&apos;EXPRESSION_ARM.EXPRESSION&apos; IN TYPEOF(interval_item)) AND (&apos;EXPRESSION_ARM.EXPRESSION&apos; IN TYPEOF(interval_high))">
      </where>
      <where
        label="WR2"
        expression="((&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_low)) AND (&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_high)) AND (&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_item))) OR ((&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF.interval_low)) AND (&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF.interval_item)) AND (&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(SELF.interval_high)))">
      </where>
    </entity>

    <entity name="Length_function"
      supertypes="Numeric_expression Unary_generic_expression"
    >
      <explicit
        name="operand">
        <typename name="String_expression"/>
        <redeclaration
          entity-ref="Unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Length_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Like_expression"
      supertypes="Comparison_expression"
    >
      <where
        label="WR1"
        expression="(&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF\Comparison_expression.operands[1])) AND (&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(SELF\Comparison_expression.operands[2]))">
      </where>
    </entity>

    <entity name="Literal_number"
      abstract.supertype="YES"
      supertypes="Simple_numeric_expression Generic_literal"
      super.expression="ONEOF(Int_literal, Real_literal)"
    >
      <explicit
        name="the_value">
        <builtintype type="NUMBER"
        />
      </explicit>
    </entity>

    <entity name="Log_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Log10_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Log2_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Luminous_intensity_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Mass_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Maximum_function"
      supertypes="Multiple_arity_function_call"
    >
    </entity>

    <entity name="Minimum_function"
      supertypes="Multiple_arity_function_call"
    >
    </entity>

    <entity name="Minus_expression"
      supertypes="Binary_numeric_expression"
    >
    </entity>

    <entity name="Minus_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Mod_expression"
      supertypes="Binary_numeric_expression"
    >
    </entity>

    <entity name="Mult_expression"
      supertypes="Multiple_arity_numeric_expression"
    >
    </entity>

    <entity name="Multiple_arity_boolean_expression"
      abstract.supertype="YES"
      supertypes="Boolean_expression Multiple_arity_generic_expression"
      super.expression="ONEOF(And_expression, Or_expression)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="Boolean_expression"/>
        <redeclaration
          entity-ref="Multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Multiple_arity_function_call"
      abstract.supertype="YES"
      supertypes="Multiple_arity_numeric_expression"
    >
    </entity>

    <entity name="Multiple_arity_generic_expression"
      abstract.supertype="YES"
      supertypes="Generic_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="Generic_expression"/>
      </explicit>
    </entity>

    <entity name="Multiple_arity_numeric_expression"
      abstract.supertype="YES"
      supertypes="Numeric_expression Multiple_arity_generic_expression"
      super.expression="ONEOF(Plus_expression, Mult_expression, Multiple_arity_function_call)"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="?"
        />
        <typename name="Numeric_expression"/>
        <redeclaration
          entity-ref="Multiple_arity_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Name_assignment"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="role">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="items">
        <typename name="assigned_name_select"/>
      </explicit>
    </entity>

    <entity name="Named_variable_semantics"
      supertypes="Variable_semantics"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="variable_context">
        <typename name="Generic_expression"/>
      </explicit>
    </entity>

    <entity name="Not_expression"
      supertypes="Unary_boolean_expression"
    >
      <explicit
        name="operand">
        <typename name="Boolean_expression"/>
        <redeclaration
          entity-ref="Unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Numeric_defined_function"
      abstract.supertype="YES"
      supertypes="Numeric_expression Defined_function"
      super.expression="ONEOF(Integer_defined_function, Real_defined_function)"
    >
    </entity>

    <entity name="Numeric_expression"
      abstract.supertype="YES"
      supertypes="Expression"
    >
      <derived
        name="is_int"
        expression="Is_int_expr(SELF)">
        <builtintype type="BOOLEAN"
        />
      </derived>
      <derived
        name="sql_mappable"
        expression="Is_sql_mappable(SELF)">
        <builtintype type="BOOLEAN"
        />
      </derived>
    </entity>

    <entity name="Numeric_variable"
      supertypes="Simple_numeric_expression Variable"
      super.expression="ONEOF(Int_numeric_variable, Real_numeric_variable)"
    >
      <where
        label="WR1"
        expression="(&apos;EXPRESSION_ARM.INT_NUMERIC_VARIABLE&apos; IN TYPEOF(SELF)) OR (&apos;EXPRESSION_ARM.REAL_NUMERIC_VARIABLE&apos; IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="Numerical_representation_context"
      supertypes="Representation_context"
    >
      <explicit
        name="units"
        optional="YES">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="Unit"/>
      </explicit>
      <explicit
        name="accuracies"
        optional="YES">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="Uncertainty_with_unit"/>
      </explicit>
    </entity>

    <entity name="Odd_function"
      supertypes="Unary_boolean_expression"
    >
      <explicit
        name="operand">
        <typename name="Numeric_expression"/>
        <redeclaration
          entity-ref="Unary_generic_expression"/>
      </explicit>
      <where
        label="WR1"
        expression="Is_int_expr(SELF\Numeric_expression)">
      </where>
    </entity>

    <entity name="Or_expression"
      supertypes="Multiple_arity_boolean_expression"
    >
    </entity>

    <entity name="Parameter_value_representation_item"
      supertypes="Representation_item"
    >
      <explicit
        name="parameter_value">
        <typename name="parameter_value_select"/>
      </explicit>
    </entity>

    <entity name="Plane_angle_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Plus_expression"
      supertypes="Multiple_arity_numeric_expression"
    >
    </entity>

    <entity name="Power_expression"
      supertypes="Binary_numeric_expression"
    >
    </entity>

    <entity name="Product"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Product_category"
    >
      <explicit
        name="id"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Product_category_assignment"
    >
      <explicit
        name="category">
        <typename name="Product_category"/>
      </explicit>
      <explicit
        name="products">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="Product"/>
      </explicit>
    </entity>

    <entity name="Product_category_hierarchy"
    >
      <explicit
        name="super_category">
        <typename name="Product_category"/>
      </explicit>
      <explicit
        name="sub_category">
        <typename name="Product_category"/>
      </explicit>
    </entity>

    <entity name="Product_version"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="of_product">
        <typename name="Product"/>
      </explicit>
    </entity>

    <entity name="Product_version_relationship"
    >
      <explicit
        name="relation_type"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="relating_version">
        <typename name="Product_version"/>
      </explicit>
      <explicit
        name="related_version">
        <typename name="Product_version"/>
      </explicit>
      <where
        label="WR1"
        expression="relating_version :&lt;&gt;: related_version">
      </where>
      <where
        label="WR2"
        expression="EXISTS(relation_type) OR (TYPEOF(SELF\Product_version_relationship) &lt;&gt; TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="Product_view_definition"
    >
      <explicit
        name="id"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="additional_characterization"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="initial_context">
        <typename name="View_definition_context"/>
      </explicit>
      <explicit
        name="additional_contexts">
        <aggregate type="SET"
          lower="0"
          upper="?"
        />
        <typename name="View_definition_context"/>
      </explicit>
      <explicit
        name="defined_version">
        <typename name="Product_version"/>
      </explicit>
      <where
        label="WR1"
        expression="NOT (initial_context IN additional_contexts)">
      </where>
      <where
        label="WR2"
        expression="EXISTS(id) OR (TYPEOF(SELF\Product_view_definition) &lt;&gt; TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="Property_definition_representation"
      abstract.supertype="YES"
    >
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="definition">
        <typename name="represented_definition"/>
      </explicit>
      <explicit
        name="rep">
        <typename name="Representation"/>
      </explicit>
      <explicit
        name="role"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Property_representation"
      supertypes="Property_definition_representation"
    >
      <explicit
        name="property">
        <typename name="Assigned_property"/>
        <redeclaration
          entity-ref="Property_definition_representation"
          old_name="definition"/>
      </explicit>
    </entity>

    <entity name="Ratio_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Real_defined_function"
      abstract.supertype="YES"
      supertypes="Numeric_defined_function"
    >
    </entity>

    <entity name="Real_literal"
      supertypes="Literal_number"
    >
      <explicit
        name="the_value">
        <builtintype type="REAL"
        />
        <redeclaration
          entity-ref="Literal_number"/>
      </explicit>
    </entity>

    <entity name="Real_numeric_variable"
      supertypes="Numeric_variable"
    >
    </entity>

    <entity name="Representation"
    >
      <explicit
        name="id"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="name"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="context_of_items">
        <typename name="Representation_context"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="Representation_item"/>
      </explicit>
      <where
        label="WR1"
        expression="EXISTS(name) OR (TYPEOF(SELF\Representation) &lt;&gt; TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="Representation_context"
    >
      <explicit
        name="id">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="kind">
        <builtintype type="STRING"
        />
      </explicit>
      <inverse
        name="representations_in_context"
        entity="Representation"
        attribute="context_of_items">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"
        />
      </inverse>
    </entity>

    <entity name="Representation_item"
      abstract.supertype="YES"
    >
      <explicit
        name="name"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Representation_relationship"
    >
      <explicit
        name="relation_type"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="rep_1">
        <typename name="Representation"/>
      </explicit>
      <explicit
        name="rep_2">
        <typename name="Representation"/>
      </explicit>
      <where
        label="WR1"
        expression="EXISTS(relation_type) OR (TYPEOF(SELF\Representation_relationship) &lt;&gt; TYPEOF(SELF))">
      </where>
      <where
        label="WR2"
        expression="EXISTS(description) OR (TYPEOF(SELF\Representation_relationship) &lt;&gt; TYPEOF(SELF))">
      </where>
    </entity>

    <entity name="Simple_boolean_expression"
      abstract.supertype="YES"
      supertypes="Boolean_expression Simple_generic_expression"
      super.expression="ONEOF(Boolean_literal, Boolean_variable)"
    >
    </entity>

    <entity name="Simple_generic_expression"
      abstract.supertype="YES"
      supertypes="Generic_expression"
      super.expression="ONEOF(Generic_literal, Generic_variable)"
    >
    </entity>

    <entity name="Simple_numeric_expression"
      abstract.supertype="YES"
      supertypes="Numeric_expression Simple_generic_expression"
      super.expression="ONEOF(Literal_number, Numeric_variable)"
    >
    </entity>

    <entity name="Simple_string_expression"
      abstract.supertype="YES"
      supertypes="String_expression Simple_generic_expression"
      super.expression="ONEOF(String_literal, String_variable)"
    >
    </entity>

    <entity name="Sin_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Slash_expression"
      supertypes="Binary_numeric_expression"
    >
    </entity>

    <entity name="Solid_angle_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Sql_mappable_defined_function"
      abstract.supertype="YES"
      supertypes="Defined_function"
    >
    </entity>

    <entity name="Square_root_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="State_based_behaviour_model"
      supertypes="Representation"
    >
      <explicit
        name="context_of_items">
        <typename name="State_based_behaviour_representation_context"/>
        <redeclaration
          entity-ref="Representation"/>
      </explicit>
      <explicit
        name="items">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_based_behaviour_representation_item"/>
        <redeclaration
          entity-ref="Representation"/>
      </explicit>
    </entity>

    <entity name="State_based_behaviour_representation_context"
      supertypes="Representation_context"
    >
    </entity>

    <entity name="State_based_behaviour_representation_item"
      supertypes="Representation_item"
    >
      <explicit
        name="item">
        <typename name="state_based_behaviour_element"/>
      </explicit>
    </entity>

    <entity name="State_definition"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="State_definition_relationship"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="relating">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
      </explicit>
      <explicit
        name="related">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
      </explicit>
    </entity>

    <entity name="State_definition_role"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="State_transition_definition"
      supertypes="State_definition_relationship"
    >
      <explicit
        name="end_state">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
        <redeclaration
          entity-ref="State_definition_relationship"
          old_name="relating"/>
      </explicit>
      <explicit
        name="start_state">
        <aggregate type="SET"
          lower="1"
          upper="?"
        />
        <typename name="State_definition"/>
        <redeclaration
          entity-ref="State_definition_relationship"
          old_name="related"/>
      </explicit>
    </entity>

    <entity name="String_defined_function"
      abstract.supertype="YES"
      supertypes="Defined_function String_expression"
    >
    </entity>

    <entity name="String_expression"
      abstract.supertype="YES"
      supertypes="Expression"
      super.expression="ONEOF(Simple_string_expression, Index_expression, Substring_expression, Concat_expression, Format_function, String_defined_function)"
    >
    </entity>

    <entity name="String_literal"
      supertypes="Simple_string_expression Generic_literal"
    >
      <explicit
        name="the_value">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="String_representation_item"
      supertypes="Representation_item"
    >
      <explicit
        name="string_value">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="String_variable"
      supertypes="Simple_string_expression Variable"
    >
    </entity>

    <entity name="Substring_expression"
      supertypes="String_expression Multiple_arity_generic_expression"
    >
      <derived
        name="operand"
        expression="SELF\Multiple_arity_generic_expression.operands[1]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="index1"
        expression="SELF\Multiple_arity_generic_expression.operands[2]">
        <typename name="Generic_expression"/>
      </derived>
      <derived
        name="index2"
        expression="SELF\Multiple_arity_generic_expression.operands[3]">
        <typename name="Generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="(&apos;EXPRESSION_ARM.STRING_EXPRESSION&apos; IN TYPEOF(operand)) AND (&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(index1)) AND (&apos;EXPRESSION_ARM.NUMERIC_EXPRESSION&apos; IN TYPEOF(index2))">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(SELF\Multiple_arity_generic_expression.operands) = 3">
      </where>
      <where
        label="WR3"
        expression="Is_int_expr(index1)">
      </where>
      <where
        label="WR4"
        expression="Is_int_expr(index2)">
      </where>
    </entity>

    <entity name="Supplied_part_relationship"
      supertypes="Product_version_relationship"
    >
      <where
        label="WR1"
        expression="SELF\Product_version_relationship.relation_type IN [&apos;supplied item&apos;, &apos;supplied document&apos;]">
      </where>
    </entity>

    <entity name="Tan_function"
      supertypes="Unary_function_call"
    >
    </entity>

    <entity name="Thermodynamic_temperature_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Time_unit"
      supertypes="Unit"
    >
    </entity>

    <entity name="Unary_boolean_expression"
      abstract.supertype="YES"
      supertypes="Boolean_expression Unary_generic_expression"
    >
    </entity>

    <entity name="Unary_function_call"
      abstract.supertype="YES"
      supertypes="Unary_numeric_expression"
      super.expression="ONEOF(Abs_function, Minus_function, Sin_function, Cos_function, Tan_function, Asin_function, Acos_function, Exp_function, Log_function, Log2_function, Log10_function, Square_root_function)"
    >
    </entity>

    <entity name="Unary_generic_expression"
      abstract.supertype="YES"
      supertypes="Generic_expression"
    >
      <explicit
        name="operand">
        <typename name="Generic_expression"/>
      </explicit>
    </entity>

    <entity name="Unary_numeric_expression"
      abstract.supertype="YES"
      supertypes="Numeric_expression Unary_generic_expression"
      super.expression="Unary_function_call"
    >
      <explicit
        name="operand">
        <typename name="Numeric_expression"/>
        <redeclaration
          entity-ref="Unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Uncertainty_with_unit"
      supertypes="Value_with_unit"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
    </entity>

    <entity name="Unit"
      super.expression="ONEOF(Amount_of_substance_unit, Electric_current_unit, Length_unit, Luminous_intensity_unit, Mass_unit, Plane_angle_unit, Ratio_unit, Solid_angle_unit, Thermodynamic_temperature_unit, Time_unit)"
    >
      <explicit
        name="name">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="si_unit">
        <builtintype type="BOOLEAN"
        />
      </explicit>
    </entity>

    <entity name="Value_function"
      supertypes="Numeric_expression Unary_generic_expression"
      super.expression="Int_value_function"
    >
      <explicit
        name="operand">
        <typename name="String_expression"/>
        <redeclaration
          entity-ref="Unary_generic_expression"/>
      </explicit>
    </entity>

    <entity name="Value_with_unit"
    >
      <explicit
        name="unit">
        <typename name="Unit"/>
      </explicit>
      <explicit
        name="value_component">
        <typename name="measure_value"/>
      </explicit>
    </entity>

    <entity name="Variable"
      abstract.supertype="YES"
      supertypes="Generic_variable"
    >
    </entity>

    <entity name="Variable_semantics"
      abstract.supertype="YES"
    >
    </entity>

    <entity name="View_definition_context"
    >
      <explicit
        name="application_domain">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="life_cycle_stage">
        <builtintype type="STRING"
        />
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <builtintype type="STRING"
        />
      </explicit>
      <where
        label="WR1"
        expression="(SIZEOF(USEDIN(SELF, &apos;PRODUCT_VIEW_DEFINITION_ARM.&apos; + &apos;PRODUCT_VIEW_DEFINITION.INITIAL_CONTEXT&apos;)) &gt; 0) OR (SIZEOF(USEDIN(SELF, &apos;PRODUCT_VIEW_DEFINITION_ARM.&apos; + &apos;PRODUCT_VIEW_DEFINITION.ADDITIONAL_CONTEXTS&apos;)) &gt; 0)">
      </where>
    </entity>

    <entity name="Xor_expression"
      supertypes="Binary_boolean_expression"
    >
      <explicit
        name="operands">
        <aggregate type="LIST"
          lower="2"
          upper="2"
        />
        <typename name="Boolean_expression"/>
        <redeclaration
          entity-ref="Binary_generic_expression"/>
      </explicit>
    </entity>

    <function name="Acyclic">
      <parameter name="arg1">
        <typename name="Generic_expression"/>
      </parameter>
      <parameter name="arg2">
        <aggregate type="SET"
        />
        <typename name="Generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    result : BOOLEAN;
  END_LOCAL;

  IF (&apos;GENERIC_EXPRESSION_ARM.SIMPLE_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1)) THEN
    RETURN (TRUE);
  END_IF;
  IF arg1 IN arg2 THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.UNARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    RETURN (Acyclic(arg1\Unary_generic_expression.operand, arg2 + [arg1]));
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.BINARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    RETURN (Acyclic(arg1\Binary_generic_expression.operands[1], arg2 + [arg1]) AND Acyclic(arg1\Binary_generic_expression.operands[2], arg2 + [arg1]));
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg1) THEN
    result := TRUE;
    REPEAT i := 1 TO SIZEOF(arg1\Multiple_arity_generic_expression.operands);
      result := result AND Acyclic(arg1\Multiple_arity_generic_expression.operands[i], arg2 + [arg1]);
    END_REPEAT;
    RETURN (result);
  END_IF;
      </algorithm>
    </function>

    <function name="CLASSOF">
      <parameter name="the_instance">
        <builtintype type="GENERICENTITY"
          typelabel="ininst"
        />
      </parameter>
      <aggregate type="SET"
      />
      <builtintype type="STRING"
      />
      <algorithm>
  LOCAL
    result : SET OF STRING;
    classifications : BAG OF Classification_assignment;
  END_LOCAL;

  result := TYPEOF(the_instance);
  classifications := USEDIN(the_instance, &apos;GENERAL_MODEL_PARAMETER_ARM.CLASSIFICATION_ASSIGNMENT.ITEMS&apos;);
  REPEAT i := LOINDEX(classifications) TO HIINDEX(classifications);
    result := result + classifications[i].assigned_class.id;
  END_REPEAT;
  RETURN (result);
      </algorithm>
    </function>

    <function name="Is_Acyclic">
      <parameter name="arg">
        <typename name="Generic_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  RETURN (Acyclic(arg, []));
      </algorithm>
    </function>

    <function name="Is_int_expr">
      <parameter name="arg">
        <typename name="Numeric_expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
  END_LOCAL;

  IF &apos;EXPRESSION_ARM.INT_LITERAL&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.REAL_LITERAL&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;EXPRESSION_ARM.INT_NUMERIC_VARIABLE&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.REAL_NUMERIC_VARIABLE&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;NUMERIC_FUNCTION_ARM.ABS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_int_expr(arg\Unary_numeric_expression.operand));
  END_IF;
  IF &apos;NUMERIC_FUNCTION.MINUS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_int_expr(arg\Unary_numeric_expression.operand));
  END_IF;
  IF (&apos;NUMERIC_FUNCTION_ARM.SIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.COS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.TAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.ASIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.ACOS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.Atan_function&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.EXP_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.LOG_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.LOG2_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.LOG10_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.SQUARE_ROOT_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.PLUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.MULT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.MAXIMUM_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;NUMERIC_FUNCTION_ARM.MINIMUM_FUNCTION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\Multiple_arity_numeric_expression.operands);
      IF NOT Is_int_expr(arg\Multiple_arity_numeric_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.MINUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.POWER_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (Is_int_expr(arg\Binary_numeric_expression.operands[1]) AND Is_int_expr(arg\Binary_numeric_expression.operands[2]));
  END_IF;
  IF (&apos;EXPRESSION_ARM.DIV_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.MOD_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.SLASH_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;NUMERIC_FUNCTION_ARM.LENGTH_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;NUMERIC_FUNCTION_ARM.VALUE_FUNCTION&apos; IN TYPEOF(arg) THEN
    IF &apos;NUMERIC_FUNCTION_ARM.INT_VALUE_FUNCTION&apos; IN TYPEOF(arg) THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF &apos;NUMERIC_FUNCTION_ARM.INTEGER_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;NUMERIC_FUNCTION_ARM.REAL_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;EXPRESSION_ARM.BOOLEAN_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;EXPRESSION_ARM.STRING_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="Is_sql_mappable">
      <parameter name="arg">
        <typename name="Expression"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
  END_LOCAL;

  IF &apos;EXPRESSION_ARM.SIMPLE_NUMERIC_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.SQL_MAPPABLE_DEFINED_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.MINUS_FUNCTION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_sql_mappable(arg\Unary_numeric_expression.operand));
  END_IF;
  IF (&apos;EXPRESSION_ARM.ABS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.SIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.TAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.ASIN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.ACOS_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.ATAN_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.EXP_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.LOG_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.LOG2_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.LOG10_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.SQUARE_ROOT_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.VALUE_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.LENGTH_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.PLUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.MULT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.MAXIMUM_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.MAXIMUM_FUNCTION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\Multiple_arity_numeric_expression.operands);
      IF NOT Is_sql_mappable(arg\Multiple_arity_numeric_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.MINUS_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.SLASH_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (Is_sql_mappable(arg\Binary_numeric_expression.operands[1]) AND Is_sql_mappable(arg\Binary_numeric_expression.operands[2]));
  END_IF;
  IF (&apos;EXPRESSION_ARM.DIV_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.MOD_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.POWER_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;EXPRESSION_ARM.SIMPLE_BOOLEAN_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.NOT_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_sql_mappable(arg\Unary_generic_expression.operand));
  END_IF;
  IF (&apos;EXPRESSION_ARM.ODD_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.XOR_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.AND_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.OR_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    REPEAT i := 1 TO SIZEOF(arg\Multiple_arity_boolean_expression.operands);
      IF NOT Is_sql_mappable(arg\Multiple_arity_boolean_expression.operands[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  IF &apos;EXPRESSION_ARM.EQUALS_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_sql_mappable(arg\Binary_generic_expression.operands[1]) AND Is_sql_mappable(arg\Binary_generic_expression.operands[2]));
  END_IF;
  IF (&apos;EXPRESSION_ARM.COMPARISON_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COMPARISON_GREATER&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COMPARISON_GREATER_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COMPARISON_LESS&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COMPARISON_LESS_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.COMPARISON_NOT_EQUAL&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.LIKE_EXPRESSION&apos; IN TYPEOF(arg)) THEN
    RETURN (Is_sql_mappable(arg\Comparison_expression.operands[1]) AND Is_sql_mappable(arg\Comparison_expression.operands[2]));
  END_IF;
  IF &apos;EXPRESSION_ARM.INTERVAL_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (Is_sql_mappable(arg\Interval_expression.interval_low) AND Is_sql_mappable(arg\Interval_expression.interval_high) AND Is_sql_mappable(arg\Interval_expression.interval_item));
  END_IF;
  IF (&apos;NUMERIC_FUNCTION_ARM.NUMERIC_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.BOOLEAN_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.STRING_DEFINED_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  IF &apos;EXPRESSION_ARM.SIMPLE_STRING_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (TRUE);
  END_IF;
  IF (&apos;EXPRESSION_ARM.INDEX_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.SUBSTRING_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.CONCAT_EXPRESSION&apos; IN TYPEOF(arg)) OR (&apos;EXPRESSION_ARM.FORMAT_FUNCTION&apos; IN TYPEOF(arg)) THEN
    RETURN (FALSE);
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="types_of_product">
      <parameter name="obj">
        <typename name="Product"/>
      </parameter>
      <aggregate type="SET"
      />
      <builtintype type="STRING"
      />
      <algorithm>
  LOCAL
    category_assignments : BAG OF Product_category_assignment;
    categories : SET OF STRING := [];
    i : INTEGER;
  END_LOCAL;

  category_assignments := USEDIN(obj, &apos;PRODUCT_IDENTIFICATION_ARM.&apos; + &apos;PRODUCT_CATEGORY_ASSIGNMENT.PRODUCTS&apos;);
  REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
    categories := categories + category_assignments[i].category.name;
  END_REPEAT;
  RETURN (categories);
      </algorithm>
    </function>

    <function name="Used_variables">
      <parameter name="arg">
        <typename name="Generic_expression"/>
      </parameter>
      <aggregate type="SET"
      />
      <typename name="Generic_variable"/>
      <algorithm>
  LOCAL
    result : SET OF Generic_variable := [];
  END_LOCAL;

  IF &apos;GENERIC_EXPRESSION_ARM.GENERIC_VARIABLE&apos; IN TYPEOF(arg) THEN
    RETURN;
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.UNARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (Used_variables(arg\Unary_generic_expression.operand));
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.BINARY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg) THEN
    RETURN (Used_variables(arg\Binary_generic_expression.operands[1]) + Used_variables(arg\Binary_generic_expression.operands[2]));
  END_IF;
  IF &apos;GENERIC_EXPRESSION_ARM.MULTIPLE_ARITY_GENERIC_EXPRESSION&apos; IN TYPEOF(arg) THEN
    REPEAT i := 1 TO SIZEOF(arg\Multiple_arity_generic_expression.operands);
      result := result + Used_variables(arg\Multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  RETURN ([]);
      </algorithm>
    </function>

  </schema>

</express>