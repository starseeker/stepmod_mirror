(*
   $Id: mim_lf.exp,v 1.13 2008/07/15 14:18:43 abhpf Exp $
   ISO TC184/SC4/WG3 N2330 - ISO/CD-TS 10303-1371 State based behaviour -  EXPRESS MIM Long form
*)


(* ===================================================================================== *)
(* Long form schema generated by The EXPRESS Data Manager  compiler version 9.7.1B.20070802*)
(* Tue Oct 14 18:55:47 2008                                                                *)
(* The schema is converted from ISO10303 P11-2003 to ISO10303 P11-1994                     *)
(* ===================================================================================== *)

SCHEMA State_based_behaviour_mim_LF;


(*
USE FROM action_schema   
  (action_method); 

USE FROM Activity_method_mim;    

USE FROM Alias_identification_mim;    

USE FROM basic_attribute_schema   
  (description_attribute); 

USE FROM Behaviour_description_assignment_mim;    

USE FROM Behaviour_identification_and_version_mim;    

USE FROM Behaviour_view_definition_mim;    

USE FROM Class_mim;    

USE FROM Classification_assignment_mim;    

USE FROM Condition_mim;    

USE FROM Description_assignment_mim;    

USE FROM Expression_assignment_mim;    

USE FROM systems_engineering_representation_schema   
  (description_text);

USE FROM Expression_mim;    

USE FROM External_class_mim;    

USE FROM External_item_identification_assignment_mim;    

USE FROM External_state_based_behaviour_model_mim;    

USE FROM File_identification_mim;    

USE FROM Foundation_representation_mim;    

USE FROM Foundation_state_definition_mim;    

USE FROM General_model_parameter_mim;    

USE FROM Generic_expression_mim;    

USE FROM Identification_assignment_mim;    

USE FROM Independent_property_mim;    

USE FROM Independent_property_representation_mim;    

USE FROM Numeric_function_mim;    

USE FROM Parameter_value_specification_mim;    

USE FROM Product_categorization_mim;    

USE FROM product_definition_schema   
  (product,
   product_definition,
   product_definition_formation); 

USE FROM Product_identification_mim;    

USE FROM product_property_definition_schema   
  (characterized_object); 

USE FROM Product_version_mim;    

USE FROM Product_version_relationship_mim;    

USE FROM Product_view_definition_mim;    

USE FROM Property_assignment_mim;    

USE FROM representation_schema   
  (representation); 

USE FROM State_based_behaviour_representation_mim;    

USE FROM state_type_schema   
  (state_type,
   state_type_assignment,
   state_type_relationship); 

USE FROM Textual_expression_representation_mim;    

USE FROM Value_with_unit_mim;    
*)
(* USED FROM (measure_schema); *)
TYPE acceleration_measure = REAL;
  END_TYPE;

(* Pruned unused type: sbb_expression_assignment_item  *)


(* Pruned unused type: sbb_behaviour_item_groupable_item  *)


(* Pruned unused type: sbb_behaviour_model_groupable_item  *)


(* Pruned unused type: sbb_classification_item  *)


(* Pruned unused type: sbb_description_item  *)


(* Pruned unused type: sbb_external_identification_item  *)


(* Pruned unused type: sbb_identification_item  *)


(* Pruned unused type: sbb_parameter_value_select  *)


(* Pruned unused type: sbb_state_type_of_item  *)


(* Pruned unused type: aliasable_item  *)

(* USED FROM (Identification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE identification_item = SELECT (
   action_method,
   applied_action_method_assignment,
   applied_description_text_assignment,
   applied_external_identification_assignment,
   condition,
   document_file,
   external_class_library,
   general_model_parameter,
   general_property,
   general_property_relationship,
   product,
   product_category,
   product_definition,
   product_definition_context,
   product_definition_formation,
   property_definition,
   representation,
   state_based_behaviour_model,
   state_type,
   state_type_assignment,
   state_type_relationship);
END_TYPE;


(* Pruned unused type: versionable_item  *)


(* Pruned unused type: behaviour_item_groupable_item  *)


(* Pruned unused type: behaviour_model_groupable_item  *)

(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE role_select = SELECT (
   document_reference,
   group_assignment,
   name_assignment);
END_TYPE;


(* Pruned unused type: behaviour_definition_identification_item  *)

(* USED FROM (Group_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE groupable_item = SELECT (
   action_method,
   generic_expression,
   named_variable_semantics,
   parameter_value_representation_item,
   parameter_value_select,
   product_definition,
   state_based_behaviour_model,
   state_based_behaviour_representation_item,
   state_type,
   state_type_relationship);
   WHERE
  WR1: NOT ('STATE_BASED_BEHAVIOUR_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE; 

(* Pruned unused type: behaviour_and_version_identification_item  *)

(* USED FROM (Classification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE classification_item = SELECT (
   action_method,
   action_method_relationship,
   applied_action_method_assignment,
   applied_description_text_assignment,
   applied_external_identification_assignment,
   applied_identification_assignment,
   class,
   condition,
   constrained_general_parameter_relationship,
   context_dependent_unit,
   conversion_based_unit,
   derived_unit,
   description_text,
   descriptive_representation_item,
   document_file,
   external_class_library,
   general_model_parameter,
   general_property,
   general_property_relationship,
   measure_with_unit,
   named_unit,
   parameter_value_representation_item,
   product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   property_definition,
   property_definition_representation,
   representation,
   representation_context,
   representation_item,
   state_based_behaviour_model,
   state_type,
   state_type_assignment,
   state_type_relationship,
   text_based_representation,
   uncertainty_measure_with_unit);
END_TYPE;


(* Pruned unused type: condition_action_method_items  *)


(* Pruned unused type: condition_classification_item  *)


(* Pruned unused type: condition_name_item  *)

(* USED FROM (Activity_method_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE action_method_items = SELECT (
   action_method,
   action_method_relationship,
   applied_classification_assignment,
   applied_identification_assignment,
   parameter_value_select,
   product,
   product_definition,
   product_definition_formation,
   product_related_product_category,
   property_definition,
   property_definition_representation,
   representation,
   state_type,
   state_type_relationship);
END_TYPE;

(* USED FROM (Name_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE name_item = SELECT (
   applied_action_method_assignment,
   external_class_library,
   named_variable_semantics);
END_TYPE;

(* USED FROM (Description_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE description_item = SELECT (
   action_method,
   applied_action_method_assignment,
   condition,
   general_model_parameter,
   groupable_item,
   product,
   product_definition,
   product_definition_formation,
   representation,
   state_based_behaviour_model,
   state_type,
   state_type_relationship);
END_TYPE;

(* USED FROM (Expression_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE expression_assignment_item = SELECT (
   condition);
END_TYPE;


(* Pruned unused type: external_class_name_item  *)

(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE description_attribute_select = SELECT (
   application_context,
   external_source,
   property_definition_representation,
   representation);
END_TYPE;

(* USED FROM (External_item_identification_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE external_identification_item = SELECT (
   document_file,
   product,
   product_definition);
END_TYPE;

(* USED FROM (support_resource_schema); *)
  TYPE identifier = STRING;
  END_TYPE;

(* Pruned unused type: external_sbb_model_document_reference_item  *)

(* USED FROM (Document_assignment_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE document_reference_item = SELECT (
   external_state_based_behaviour_model);
END_TYPE;


(* Pruned unused type: document_location_select  *)


(* Pruned unused type: file_identification_item  *)


(* Pruned unused type: file_version_item  *)


(* Pruned unused type: file_location_select  *)


(* Pruned unused type: state_based_behaviour_element_groupable_item  *)


(* Pruned unused type: state_based_behaviour_representation_item_groupable_item  *)

(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE id_attribute_select = SELECT (
   product_category,
   property_definition,
   application_context,
   group,
   representation);
END_TYPE;

(* USED FROM (Foundation_state_definition_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE state_type_of_item = SELECT (
   action_method,
   applied_external_identification_assignment,
   group,
   product_definition,
   product_definition_formation);
END_TYPE;


(* Pruned unused type: cgpr_required_class_classification_item  *)


(* Pruned unused type: gmp_classification_item  *)


(* Pruned unused type: parameter_value_representation_item_groupable_item  *)


(* Pruned unused type: parameter_value_select_groupable_item  *)

(* USED FROM (Parameter_value_specification_mim); *)
(* This SELECT set has been been expanded or truncated for EXPRESS E1 layout. *)
TYPE parameter_value_select = SELECT (
   generic_expression,
   measure_with_unit,
   product_definition,
   representation,
   representation_item,
   state_type);
END_TYPE;


(* Pruned unused type: generic_expression_groupable_item  *)


(* Pruned unused type: named_variable_semantics_name_item  *)


(* Pruned unused type: named_variable_semantics_variable_context_groupable_item  *)

(* USED FROM (basic_attribute_schema); *)
(* This SELECT set has been pruned. *)
TYPE name_attribute_select = SELECT (
   derived_unit,
   product_definition,
   property_definition_representation);
END_TYPE;


(* Pruned unused type: ter_classification_item  *)

(* USED FROM (Textual_expression_representation_mim); *)
(* This EXTENSIBLE SELECT have been replaced with plain SELECT for EXPRESS E1 layout. *)
TYPE text_based_item_select = SELECT (
   included_text_based_representation,
   textual_expression_composition,
   textual_expression_representation_item);
END_TYPE;

(* USED FROM (external_reference_schema); *)
  TYPE message = STRING;
  END_TYPE;
(* USED FROM (external_reference_schema); *)
  TYPE source_item = SELECT (identifier, message);
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE absorbed_dose_measure = REAL;
  END_TYPE;

(* Pruned unused type: sbb_action_method_items  *)

(* USED FROM (measure_schema); *)
  TYPE radioactivity_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
TYPE amount_of_substance_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE area_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE celsius_temperature_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE context_dependent_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE count_measure = NUMBER;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE descriptive_measure = STRING;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE capacitance_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE dose_equivalent_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE electric_charge_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE electric_current_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE conductance_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE electric_potential_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE energy_measure = REAL;
  END_TYPE;  
(* USED FROM (measure_schema); *)
  TYPE force_measure = REAL;
  END_TYPE;  
(* USED FROM (measure_schema); *)
  TYPE frequency_measure = REAL;
  END_TYPE; 
(* USED FROM (measure_schema); *)
  TYPE magnetic_flux_density_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE illuminance_measure = REAL;
  END_TYPE;  
(* USED FROM (measure_schema); *)
  TYPE inductance_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE length_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE luminous_intensity_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE luminous_flux_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE mass_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE measure_value = SELECT 
    (absorbed_dose_measure,
     dose_equivalent_measure,
     radioactivity_measure,
     acceleration_measure,
     amount_of_substance_measure, 
     area_measure, 
     celsius_temperature_measure, 
     context_dependent_measure, 
     count_measure, 
     descriptive_measure, 
     capacitance_measure,
     electric_charge_measure,
     conductance_measure,
     electric_current_measure, 
     electric_potential_measure,
     energy_measure,
     magnetic_flux_density_measure,
     force_measure,
     frequency_measure,
     illuminance_measure,
     inductance_measure,
     length_measure, 
     luminous_flux_measure,
     luminous_intensity_measure, 
     magnetic_flux_measure,
     mass_measure, 
     numeric_measure, 
     non_negative_length_measure,
     parameter_value, 
     plane_angle_measure, 
     positive_length_measure, 
     positive_plane_angle_measure, 
     positive_ratio_measure, 
     power_measure,
     pressure_measure,
     ratio_measure, 
     resistance_measure,
     solid_angle_measure, 
     thermodynamic_temperature_measure, 
     time_measure, 
     velocity_measure,
     volume_measure);
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE magnetic_flux_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE non_negative_length_measure = length_measure;
   WHERE
    WR1: SELF >= 0.0;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE numeric_measure = NUMBER;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE parameter_value = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE plane_angle_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE positive_length_measure = non_negative_length_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE positive_plane_angle_measure = plane_angle_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE positive_ratio_measure = ratio_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE power_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE pressure_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE ratio_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE resistance_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE si_prefix = ENUMERATION OF (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto);
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE si_unit_name = ENUMERATION OF (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz, newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, tesla, henry, degree_Celsius, lumen, lux, becquerel, gray, sievert);
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE solid_angle_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE time_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE unit = SELECT (derived_unit, named_unit);
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE velocity_measure = REAL;
  END_TYPE;
(* USED FROM (measure_schema); *)
  TYPE volume_measure = REAL;
  END_TYPE;
(* USED FROM (representation_schema); *)
  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE;
(* USED FROM (representation_schema); *)
  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE;

(* Chained implicit interfaced from: support_resource_schema *)
  TYPE label = STRING;
  END_TYPE;

(* Chained implicit interfaced from: support_resource_schema *)
  TYPE text = STRING;
  END_TYPE;

(* Implicit interfaced from: document_schema *)
  TYPE product_or_formation_or_definition = SELECT (product, product_definition_formation, product_definition);
  END_TYPE;

(* Implicit interfaced from: representation_schema *)
(* This SELECT set has been pruned. *)
TYPE founded_item_select = SELECT (
   representation_item);
END_TYPE;


(* Implicit interfaced from: product_property_definition_schema *)
(* This SELECT set has been pruned. *)
TYPE derived_property_select = SELECT (
   property_definition);
END_TYPE;


(* Implicit interfaced from: product_property_definition_schema *)
(* This SELECT set has been pruned. *)
TYPE characterized_definition = SELECT (
   characterized_object);
END_TYPE;


(* Implicit interfaced from: product_property_representation_schema *)
(* This SELECT set has been pruned. *)
TYPE represented_definition = SELECT (
   general_property,
   property_definition);
END_TYPE;


(* Implicit interfaced from: representation_schema *)
  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE;

(* Pruned unused type: supported_item  *)

(* USED FROM (ISO13584_expressions_schema); *)
ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sbb_characterized_applied_action_method_assignment
  SUBTYPE OF (characterized_object, applied_action_method_assignment);
END_ENTITY;

ENTITY sbb_characterized_document_file	
  SUBTYPE OF (characterized_object, document_file);
END_ENTITY;

ENTITY sbb_characterized_general_property
  SUBTYPE OF (characterized_object, general_property);
END_ENTITY;

ENTITY sbb_characterized_general_property_relationship
  SUBTYPE OF (characterized_object, general_property_relationship);
END_ENTITY;

ENTITY sbb_characterized_generic_expression	
  SUBTYPE OF (characterized_object, generic_expression);
END_ENTITY;

ENTITY sbb_characterized_product
  SUBTYPE OF (characterized_object, product);
END_ENTITY;

ENTITY sbb_characterized_product_category
  SUBTYPE OF (characterized_object, product_category);
END_ENTITY;

ENTITY sbb_characterized_product_definition
  SUBTYPE OF (characterized_object, product_definition);
END_ENTITY;

ENTITY sbb_characterized_product_definition_formation
  SUBTYPE OF (characterized_object, product_definition_formation);
END_ENTITY;

ENTITY sbb_characterized_product_definition_formation_relationship
  SUBTYPE OF (characterized_object, product_definition_formation_relationship);
END_ENTITY;

ENTITY sbb_characterized_property_definition
  SUBTYPE OF (characterized_object, property_definition);
END_ENTITY;

ENTITY sbb_characterized_property_definition_representation
  SUBTYPE OF (characterized_object, property_definition_representation);
END_ENTITY;

ENTITY sbb_characterized_representation
  SUBTYPE OF (characterized_object, representation);
END_ENTITY;

ENTITY sbb_characterized_representation_context
  SUBTYPE OF (characterized_object, representation_context);
END_ENTITY;

ENTITY sbb_characterized_representation_item
  SUBTYPE OF (characterized_object, representation_item);
END_ENTITY;
(* USED FROM (action_schema); *)
  ENTITY action_method;
    name : label;
    description : OPTIONAL text;
    consequence : text;
    purpose : text;
  END_ENTITY;
(* USED FROM (Identification_assignment_mim); *)
ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
  ENTITY description_attribute;
    attribute_value : text;
    described_item : description_attribute_select;
  END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
  ENTITY object_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
  ENTITY role_association;
    role : object_role;
    item_with_role : role_select;
  END_ENTITY;
(* USED FROM (Group_mim); *)
ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;
(* USED FROM (classification_schema); *)
ENTITY class
  SUBTYPE OF (group);
END_ENTITY;
(* USED FROM (classification_schema); *)
ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;
(* USED FROM (classification_schema); *)
ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;
(* USED FROM (group_schema); *)
  ENTITY group;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (Classification_assignment_mim); *)
ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY classification_assignment
     ABSTRACT SUPERTYPE;
    assigned_class : group;
    role : classification_role;
  END_ENTITY;
(* USED FROM (Condition_mim); *)
ENTITY condition
  SUBTYPE OF (action_method);
END_ENTITY;
(* USED FROM (action_schema); *)
  ENTITY action_method_relationship;
    name : label;
    description : OPTIONAL text;
    relating_method : action_method;
    related_method : action_method;
  END_ENTITY;
(* USED FROM (Activity_method_assignment_mim); *)
ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET[1:?] OF action_method_items;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY action_method_assignment
     ABSTRACT SUPERTYPE;
    assigned_action_method : action_method;
    role : action_method_role;
  END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY action_method_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY name_assignment
     ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;
(* USED FROM (Name_assignment_mim); *)
ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;
(* USED FROM (Description_assignment_mim); *)
ENTITY applied_description_text_assignment
  SUBTYPE OF (description_text_assignment);
  items : SET[1:?] OF description_item;
END_ENTITY;
(* USED FROM (Expression_assignment_mim); *)
ENTITY applied_expression_assignment
SUBTYPE OF (expression_assignment);
  items : SET [1 : ?] OF expression_assignment_item;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY binary_boolean_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        XOR_EXPRESSION,
                        EQUALS_EXPRESSION))

SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
(* Pruned SUPERTYPE *)
ENTITY binary_function_call
 ABSTRACT SUPERTYPE

SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY binary_numeric_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        MINUS_EXPRESSION,
                        DIV_EXPRESSION,
                        MOD_EXPRESSION,
                        SLASH_EXPRESSION,
                        POWER_EXPRESSION,
                        BINARY_FUNCTION_CALL))

SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY boolean_defined_function 
 ABSTRACT SUPERTYPE

SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY boolean_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        SIMPLE_BOOLEAN_EXPRESSION,
                        UNARY_BOOLEAN_EXPRESSION,
                        BINARY_BOOLEAN_EXPRESSION,
                        MULTIPLE_ARITY_BOOLEAN_EXPRESSION,
                        COMPARISON_EXPRESSION,
                        INTERVAL_EXPRESSION,
                        BOOLEAN_DEFINED_FUNCTION))

SUBTYPE OF (expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        COMPARISON_EQUAL,
                        COMPARISON_GREATER,
                        COMPARISON_GREATER_EQUAL,
                        COMPARISON_LESS,
                        COMPARISON_LESS_EQUAL,
                        COMPARISON_NOT_EQUAL,
                        LIKE_EXPRESSION))

SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('STATE_BASED_BEHAVIOUR_MIM_LF.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('STATE_BASED_BEHAVIOUR_MIM_LF.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY defined_function
 ABSTRACT SUPERTYPE OF ((ONEOF (
                        NUMERIC_DEFINED_FUNCTION,
                        STRING_DEFINED_FUNCTION,
                        BOOLEAN_DEFINED_FUNCTION))
                        ANDOR 
                        SQL_MAPPABLE_DEFINED_FUNCTION);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        NUMERIC_EXPRESSION,
                        BOOLEAN_EXPRESSION,
                        STRING_EXPRESSION))

SUBTYPE OF (generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('STATE_BASED_BEHAVIOUR_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('STATE_BASED_BEHAVIOUR_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('STATE_BASED_BEHAVIOUR_MIM_LF.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY literal_number 
 ABSTRACT SUPERTYPE OF (ONEOF (
                        INT_LITERAL,
                        REAL_LITERAL))

SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY multiple_arity_boolean_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        AND_EXPRESSION,
                        OR_EXPRESSION))

SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY multiple_arity_function_call
 ABSTRACT SUPERTYPE OF (ONEOF (
                        MAXIMUM_FUNCTION,
                        MINIMUM_FUNCTION))

SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY multiple_arity_numeric_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        PLUS_EXPRESSION,
                        MULT_EXPRESSION,
                        MULTIPLE_ARITY_FUNCTION_CALL))

SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY numeric_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        SIMPLE_NUMERIC_EXPRESSION,
                        UNARY_NUMERIC_EXPRESSION,
                        BINARY_NUMERIC_EXPRESSION,
                        MULTIPLE_ARITY_NUMERIC_EXPRESSION,
                        LENGTH_FUNCTION,
                        VALUE_FUNCTION,
                        NUMERIC_DEFINED_FUNCTION))

SUBTYPE OF (expression);
DERIVE
	is_int: LOGICAL := is_int_expr (SELF);
	sql_mappable: LOGICAL := is_SQL_mappable (SELF);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY numeric_variable
SUPERTYPE OF (ONEOF (
              INT_NUMERIC_VARIABLE,
              REAL_NUMERIC_VARIABLE))

SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('STATE_BASED_BEHAVIOUR_MIM_LF.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('STATE_BASED_BEHAVIOUR_MIM_LF.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY simple_boolean_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        BOOLEAN_LITERAL,
                        BOOLEAN_VARIABLE))

SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY simple_numeric_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        LITERAL_NUMBER,
                        NUMERIC_VARIABLE))

SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY simple_string_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        STRING_LITERAL,
                        STRING_VARIABLE))

SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY SQL_mappable_defined_function
 ABSTRACT SUPERTYPE

SUBTYPE OF (defined_function);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY string_defined_function 
 ABSTRACT SUPERTYPE

SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY string_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        SIMPLE_STRING_EXPRESSION,
                        INDEX_EXPRESSION,
                        SUBSTRING_EXPRESSION,
                        CONCAT_EXPRESSION,
                        FORMAT_FUNCTION,
                        STRING_DEFINED_FUNCTION))

SUBTYPE OF (expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY unary_boolean_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        NOT_EXPRESSION,
                        ODD_FUNCTION))

SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
(* Pruned SUPERTYPE *)
ENTITY unary_numeric_expression
 ABSTRACT SUPERTYPE

SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;
(* USED FROM (systems_engineering_representation_schema); *)
ENTITY expression_assignment
   ABSTRACT SUPERTYPE;
  assigned_expression : expression;
  role : expression_role;
END_ENTITY;
(* USED FROM (systems_engineering_representation_schema); *)
ENTITY description_text;
  description : text;
END_ENTITY;
(* USED FROM (External_class_mim); *)
  ENTITY external_class_library
    SUBTYPE OF (external_source);
  END_ENTITY;
(* USED FROM (External_class_mim); *)
  ENTITY externally_defined_class
    SUBTYPE OF (class, externally_defined_item);
  END_ENTITY;
(* USED FROM (external_reference_schema); *)
  ENTITY external_source;
    source_id : source_item;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (external_reference_schema); *)
  ENTITY externally_defined_item;
    item_id : source_item;
    source : external_source;
  END_ENTITY;
(* USED FROM (External_item_identification_assignment_mim); *)
ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY external_identification_assignment
     ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
    source : external_source;
  END_ENTITY;
(* USED FROM (External_state_based_behaviour_model_mim); *)
ENTITY external_state_based_behaviour_model
  SUBTYPE OF (state_based_behaviour_model);
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;
(* USED FROM (Document_assignment_mim); *)
ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT('STATE_BASED_BEHAVIOUR_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  WR3: NOT('STATE_BASED_BEHAVIOUR_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'STATE_BASED_BEHAVIOUR_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT('STATE_BASED_BEHAVIOUR_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'STATE_BASED_BEHAVIOUR_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
END_ENTITY;
(* USED FROM (document_schema); *)
  ENTITY document_product_association;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_product : product_or_formation_or_definition;
  END_ENTITY;
(* USED FROM (File_identification_mim); *)
ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY document_reference
     ABSTRACT SUPERTYPE;
    assigned_document : document;
    source : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY document_usage_constraint_assignment
     ABSTRACT SUPERTYPE;
    assigned_document_usage : document_usage_constraint;
    role : document_usage_role;
  END_ENTITY;
(* USED FROM (State_based_behaviour_representation_mim); *)
ENTITY state_based_behaviour_model
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : state_based_behaviour_representation_context;
  SELF\representation.items : SET[1:?] OF state_based_behaviour_representation_item;
END_ENTITY;
(* USED FROM (State_based_behaviour_representation_mim); *)
ENTITY state_based_behaviour_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;
(* USED FROM (State_based_behaviour_representation_mim); *)
ENTITY state_based_behaviour_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;
(* USED FROM (document_schema); *)
  ENTITY document;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    kind : document_type;
  INVERSE
    representation_types : SET [0:?] OF document_representation_type FOR represented_document;
  END_ENTITY;
(* USED FROM (document_schema); *)
  ENTITY document_representation_type;
    name : label;
    represented_document : document;
  END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
  ENTITY characterized_object;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
  ENTITY id_attribute;
    attribute_value : identifier;
    identified_item : id_attribute_select;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
    units : SET [1:?] OF unit;
  END_ENTITY;
(* USED FROM (qualified_measure_schema); *)
ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY representation;
      name             : label;
      items            : SET[1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id               : identifier := get_id_value (SELF);
      description      : text := get_description_value (SELF);
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' +
                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
         <= 1;
      WR2: SIZEOF (USEDIN (SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' +
                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
         <= 1;
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
  END_ENTITY;
(* USED FROM (representation_schema); *)
(* Pruned SUPERTYPE *)
  ENTITY representation_item
    SUPERTYPE OF (ONEOF (
              COMPOUND_REPRESENTATION_ITEM,
              MAPPED_ITEM));
      name : label;
    WHERE
      WR1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      WR1: valid_measure_value (SELF\measure_with_unit.value_component);
  END_ENTITY;
(* USED FROM (Foundation_state_definition_mim); *)
ENTITY applied_state_type_assignment
  SUBTYPE OF (state_type_assignment);
  items : SET[1:?] OF state_type_of_item;
END_ENTITY;
(* USED FROM (state_type_schema); *)
ENTITY state_type;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* USED FROM (state_type_schema); *)
ENTITY state_type_assignment
   ABSTRACT SUPERTYPE;
  assigned_state_type : state_type;
  role : state_type_role;
END_ENTITY;
(* USED FROM (state_type_schema); *)
ENTITY state_type_relationship;
  name : label;
  description : OPTIONAL text;
  relating_state_type : SET[1:?] OF state_type;
  related_state_type : SET[1:?] OF state_type;
END_ENTITY;
(* USED FROM (General_model_parameter_mim); *)
ENTITY constrained_general_parameter_relationship
  SUBTYPE OF (general_property_relationship);
  SELF\general_property_relationship.related_property : general_model_parameter;
  SELF\general_property_relationship.relating_property : general_model_parameter;
END_ENTITY;
(* USED FROM (General_model_parameter_mim); *)
ENTITY general_model_parameter
  SUBTYPE OF (general_property);
END_ENTITY;
(* USED FROM (General_model_parameter_mim); *)
ENTITY parameter_value_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
  ENTITY general_property;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
  ENTITY general_property_relationship;
    name : label;
    description : OPTIONAL text;
    relating_property : general_property;
    related_property : general_property;
  END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY binary_generic_expression
 ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY generic_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        SIMPLE_GENERIC_EXPRESSION,
                        UNARY_GENERIC_EXPRESSION,
                        BINARY_GENERIC_EXPRESSION,
                        MULTIPLE_ARITY_GENERIC_EXPRESSION));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY generic_literal
 ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
END_ENTITY; 
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY generic_variable
 ABSTRACT SUPERTYPE

SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY multiple_arity_generic_expression
 ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY simple_generic_expression
 ABSTRACT SUPERTYPE OF (ONEOF (
                        GENERIC_LITERAL,
                        GENERIC_VARIABLE))

SUBTYPE OF (generic_expression);
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY unary_generic_expression
 ABSTRACT SUPERTYPE

SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;
(* USED FROM (ISO13584_generic_expressions_schema); *)
ENTITY variable_semantics
 ABSTRACT SUPERTYPE;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY variable
 ABSTRACT SUPERTYPE OF (ONEOF (
                        NUMERIC_VARIABLE,
                        BOOLEAN_VARIABLE,
                        STRING_VARIABLE))

SUBTYPE OF(generic_variable);
END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY identification_assignment
     ABSTRACT SUPERTYPE;
    assigned_id : identifier;
    role : identification_role;
  END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY identification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY sbb_characterized_action_method
  SUBTYPE OF (action_method, characterized_object);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY integer_defined_function 
 ABSTRACT SUPERTYPE

SUBTYPE OF (numeric_defined_function);
END_ENTITY ;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY numeric_defined_function
 ABSTRACT SUPERTYPE OF (ONEOF (
                        INTEGER_DEFINED_FUNCTION,
                        REAL_DEFINED_FUNCTION))

SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(operand);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY real_defined_function 
 ABSTRACT SUPERTYPE

SUBTYPE OF (numeric_defined_function);
END_ENTITY ;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY unary_function_call
 ABSTRACT SUPERTYPE OF (ONEOF (
                        ABS_FUNCTION,
                        MINUS_FUNCTION,
                        SIN_FUNCTION,
                        COS_FUNCTION,
                        TAN_FUNCTION,
                        ASIN_FUNCTION,
                        ACOS_FUNCTION,
                        EXP_FUNCTION,
                        LOG_FUNCTION,
                        LOG2_FUNCTION,
                        LOG10_FUNCTION,
                        SQUARE_ROOT_FUNCTION))

SUBTYPE OF (unary_numeric_expression);
END_ENTITY;
(* USED FROM (ISO13584_expressions_schema); *)
ENTITY value_function
SUPERTYPE OF (
              INT_VALUE_FUNCTION)

SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;
(* USED FROM (Parameter_value_specification_mim); *)
ENTITY named_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT,
              ACCELERATION_MEASURE_WITH_UNIT,
              CAPACITANCE_MEASURE_WITH_UNIT,
              ELECTRIC_CHARGE_MEASURE_WITH_UNIT,
              CONDUCTANCE_MEASURE_WITH_UNIT,
              ELECTRIC_POTENTIAL_MEASURE_WITH_UNIT,
              ENERGY_MEASURE_WITH_UNIT,
              MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT,
              FORCE_MEASURE_WITH_UNIT,
              FREQUENCY_MEASURE_WITH_UNIT,
              ILLUMINANCE_MEASURE_WITH_UNIT,
              INDUCTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_FLUX_MEASURE_WITH_UNIT,
              MAGNETIC_FLUX_MEASURE_WITH_UNIT,
              POWER_MEASURE_WITH_UNIT,
              PRESSURE_MEASURE_WITH_UNIT,
              RESISTANCE_MEASURE_WITH_UNIT,
              VELOCITY_MEASURE_WITH_UNIT,
              ABSORBED_DOSE_MEASURE_WITH_UNIT,
              RADIOACTIVITY_MEASURE_WITH_UNIT,
              DOSE_EQUIVALENT_MEASURE_WITH_UNIT));
    value_component : measure_value;
    unit_component : unit;
  WHERE
    WR1: valid_units(SELF);
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_category;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_category_relationship;
    name : label;
    description : OPTIONAL text;
    category : product_category;
    sub_category : product_category;
  WHERE
    WR1: acyclic_product_category_relationship(SELF, [SELF.sub_category]);
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_definition;
    id : identifier;
    description : OPTIONAL text;
    formation : product_definition_formation;
    frame_of_reference : product_definition_context;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_definition_formation;
    id : identifier;
    description : OPTIONAL text;
    of_product : product;
  UNIQUE
    UR1: id, of_product;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
    products : SET [1:?] OF product;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_definition_formation_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition_formation : product_definition_formation;
    related_product_definition_formation : product_definition_formation;
  END_ENTITY;
(* USED FROM (application_context_schema); *)
  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
    life_cycle_stage : label;
  END_ENTITY;
(* USED FROM (basic_attribute_schema); *)
  ENTITY name_attribute;
    attribute_value : label;
    named_item : name_attribute_select;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_definition_context_association;
    definition : product_definition;
    frame_of_reference : product_definition_context;
    role : product_definition_context_role;
  END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
  ENTITY general_property_association;
    name : label;
    description : OPTIONAL text;
    base_definition : general_property;
    derived_definition : derived_property_select;
  WHERE
    WR1: SIZEOF(USEDIN(derived_definition, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
    WR2: derived_definition.name = base_definition.name;
  END_ENTITY;
(* USED FROM (product_property_definition_schema); *)
  ENTITY property_definition;
    name : label;
    description : OPTIONAL text;
    definition : characterized_definition;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (product_property_representation_schema); *)
  ENTITY property_definition_representation;
    definition : represented_definition;
    used_representation : representation;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (group_schema); *)
  ENTITY group_relationship;
    name : label;
    description : OPTIONAL text;
    relating_group : group;
    related_group : group;
  END_ENTITY;
(* USED FROM (management_resources_schema); *)
  ENTITY group_assignment
     ABSTRACT SUPERTYPE;
    assigned_group : group;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;
(* USED FROM (Textual_expression_representation_mim); *)
ENTITY included_text_based_representation
  SUBTYPE OF (representation_item);
END_ENTITY;
(* USED FROM (Textual_expression_representation_mim); *)
ENTITY text_based_representation
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : text_based_representation_context;
  SELF\representation.items : SET[1:?] OF text_based_item_select;
END_ENTITY;
(* USED FROM (Textual_expression_representation_mim); *)
ENTITY text_based_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;
(* USED FROM (Textual_expression_representation_mim); *)
ENTITY textual_expression_composition
  SUBTYPE OF (compound_representation_item);
END_ENTITY;
(* USED FROM (Textual_expression_representation_mim); *)
ENTITY textual_expression_representation_item
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;
(* USED FROM (external_reference_schema); *)
  ENTITY external_source_relationship;
    name : label;
    description : OPTIONAL text;
    relating_source : external_source;
    related_source : external_source;
  END_ENTITY;
(* USED FROM (external_reference_schema); *)
  ENTITY externally_defined_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_item : externally_defined_item;
    related_item : externally_defined_item;
  END_ENTITY;
(* USED FROM (external_reference_schema); *)
  ENTITY pre_defined_item;
    name : label;
  END_ENTITY;
(* USED FROM (product_definition_schema); *)
  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
    documentation_ids : SET [1:?] OF document;
  END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY absorbed_dose_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray);  
END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_absorbed_dose_unit
     SUBTYPE OF (absorbed_dose_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.gray;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY acceleration_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY acceleration_unit
    SUBTYPE OF (derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY radioactivity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY radioactivity_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel);  
END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_radioactivity_unit
     SUBTYPE OF (radioactivity_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.becquerel;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY area_unit
   SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
    name : label;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
     name : label;
     conversion_factor : measure_with_unit;
   DERIVE
     SELF\named_unit.dimensions : dimensional_exponents := 
    derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY derived_unit
    SUPERTYPE OF (ONEOF (
              ABSORBED_DOSE_UNIT,
              ACCELERATION_UNIT,
              RADIOACTIVITY_UNIT,
              AREA_UNIT,
              CAPACITANCE_UNIT,
              DOSE_EQUIVALENT_UNIT,
              ELECTRIC_CHARGE_UNIT,
              CONDUCTANCE_UNIT,
              ELECTRIC_POTENTIAL_UNIT,
              ENERGY_UNIT,
              MAGNETIC_FLUX_DENSITY_UNIT,
              FORCE_UNIT,
              FREQUENCY_UNIT,
              ILLUMINANCE_UNIT,
              INDUCTANCE_UNIT,
              MAGNETIC_FLUX_UNIT,
              POWER_UNIT,
              PRESSURE_UNIT,
              RESISTANCE_UNIT,
              VELOCITY_UNIT,
              VOLUME_UNIT));
    elements : SET [1:?] OF derived_unit_element;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
    WR2: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY derived_unit_element;
    unit : named_unit;
    exponent : REAL;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY dimensional_exponents;
    length_exponent : REAL;
    mass_exponent : REAL;
    time_exponent : REAL;
    electric_current_exponent : REAL;
    thermodynamic_temperature_exponent : REAL;
    amount_of_substance_exponent : REAL;
    luminous_intensity_exponent : REAL;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY capacitance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY capacitance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_capacitance_unit
     SUBTYPE OF (capacitance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.farad;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
(* USED FROM (measure_schema); *)
ENTITY dose_equivalent_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert);  
END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_dose_equivalent_unit
     SUBTYPE OF (dose_equivalent_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.sievert;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_charge_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_charge_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_electric_charge_unit
     SUBTYPE OF (electric_charge_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.coulomb;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
   ENTITY conductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY conductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_conductance_unit
     SUBTYPE OF (conductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.siemens;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_potential_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY electric_potential_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_electric_potential_unit
     SUBTYPE OF (electric_potential_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.volt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY energy_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY energy_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_energy_unit
     SUBTYPE OF (energy_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.joule;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY magnetic_flux_density_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY magnetic_flux_density_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_magnetic_flux_density_unit
     SUBTYPE OF (magnetic_flux_density_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.tesla;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY force_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY force_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_force_unit
     SUBTYPE OF (force_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.newton;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY frequency_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY frequency_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_frequency_unit
     SUBTYPE OF (frequency_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.hertz;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY illuminance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY illuminance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_illuminance_unit
     SUBTYPE OF (illuminance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.lux;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY inductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY inductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_inductance_unit
     SUBTYPE OF (inductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.henry;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY length_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND 
    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.time_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY luminous_flux_unit
    SUBTYPE OF(named_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY luminous_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY magnetic_flux_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY magnetic_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_magnetic_flux_unit
     SUBTYPE OF (magnetic_flux_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.weber;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY mass_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY named_unit
    SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_FLUX_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              RATIO_UNIT));
    dimensions : dimensional_exponents;
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY power_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY power_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_power_unit
     SUBTYPE OF (power_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.watt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY pressure_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY pressure_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_pressure_unit
     SUBTYPE OF (pressure_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.pascal;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY resistance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm);  
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY resistance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_resistance_unit
     SUBTYPE OF (resistance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.ohm;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY si_unit
    SUBTYPE OF (named_unit);
    prefix : OPTIONAL si_prefix;
    name : si_unit_name;
  DERIVE
    SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
  WHERE
    WR1: NOT(('STATE_BASED_BEHAVIOUR_MIM_LF.MASS_UNIT' IN TYPEOF(SELF)) AND
             (SIZEOF(USEDIN(SELF,'STATE_BASED_BEHAVIOUR_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
            (prefix = si_prefix.kilo); 
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY time_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY velocity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
  WHERE
   WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'STATE_BASED_BEHAVIOUR_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;
(* USED FROM (measure_schema); *)
  ENTITY volume_unit
    SUBTYPE OF (derived_unit);
   WHERE
     WR1: derive_dimensional_exponents(SELF) = 
          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY;
(* USED FROM (representation_schema); *)
  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET[1:?] OF mapped_item FOR mapping_source;
    WHERE
      WR1: item_in_context(SELF.mapping_origin,
        SELF.mapped_representation.context_of_items);
  END_ENTITY;

(* Implicit interfaced from: management_resources_schema *)
  ENTITY classification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;
(* REFERENCE FROM (systems_engineering_representation_schema); *)
ENTITY description_text_assignment
   ABSTRACT SUPERTYPE;
  description : description_text;
END_ENTITY;

(* Implicit interfaced from: systems_engineering_representation_schema *)
ENTITY expression_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* REFERENCE FROM (document_schema); *)
  ENTITY document_usage_constraint;
    source : document;
    subject_element : label;
    subject_element_value : text;
  END_ENTITY;

(* Implicit interfaced from: management_resources_schema *)
  ENTITY document_usage_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

(* Implicit interfaced from: document_schema *)
  ENTITY document_type;
    product_data_type : label;
  END_ENTITY;

(* Implicit interfaced from: state_type_schema *)
ENTITY state_type_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
(* REFERENCE FROM (application_context_schema); *)
  ENTITY product_context
    SUBTYPE OF (application_context_element);
    discipline_type : label;
  END_ENTITY;

(* Implicit interfaced from: application_context_schema *)
(* Pruned SUPERTYPE *)
  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
    name : label;
    frame_of_reference : application_context;
  END_ENTITY;

(* Implicit interfaced from: application_context_schema *)
  ENTITY application_context;
    application : label;
  DERIVE
    description : text := get_description_value(SELF);
    id : identifier := get_id_value(SELF);
  INVERSE
    context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

(* Implicit interfaced from: product_definition_schema *)
  ENTITY product_definition_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

(* Implicit interfaced from: representation_schema *)
  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
  END_ENTITY;

(* Implicit interfaced from: ISO13584_generic_expressions_schema *)
FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic
(* REFERENCE FROM (basic_attribute_schema); *)
  FUNCTION get_role (obj : role_select):object_role;
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: ISO13584_expressions_schema *)
FUNCTION is_int_expr (arg: numeric_expression) : LOGICAL;

LOCAL
	i: INTEGER := 0;
END_LOCAL;

IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COS_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('STATE_BASED_BEHAVIOUR_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('STATE_BASED_BEHAVIOUR_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('STATE_BASED_BEHAVIOUR_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'STATE_BASED_BEHAVIOUR_MIM_LF.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

(* Implicit interfaced from: ISO13584_expressions_schema *)
FUNCTION is_SQL_mappable (arg: expression) : LOGICAL;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('STATE_BASED_BEHAVIOUR_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('STATE_BASED_BEHAVIOUR_MIM_LF.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('STATE_BASED_BEHAVIOUR_MIM_LF.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('STATE_BASED_BEHAVIOUR_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('STATE_BASED_BEHAVIOUR_MIM_LF.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('STATE_BASED_BEHAVIOUR_MIM_LF.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('STATE_BASED_BEHAVIOUR_MIM_LF.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable
(* REFERENCE FROM (basic_attribute_schema); *)
  FUNCTION get_description_value (obj : description_attribute_select):text;
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
  FUNCTION using_representations (item : founded_item_select)
    : SET OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
  FUNCTION using_items (item : founded_item_select;
                        checked_items: SET OF founded_item_select)
                      : SET OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('STATE_BASED_BEHAVIOUR_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);
  END_FUNCTION;
(* REFERENCE FROM (support_resource_schema); *)
  FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
  FUNCTION valid_measure_value
    (m : measure_value) : BOOLEAN;
    IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
  END_FUNCTION;
(* REFERENCE FROM (basic_attribute_schema); *)
  FUNCTION get_id_value (obj : id_attribute_select):identifier;
    LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: ISO13584_generic_expressions_schema *)
FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('STATE_BASED_BEHAVIOUR_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'STATE_BASED_BEHAVIOUR_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'STATE_BASED_BEHAVIOUR_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'STATE_BASED_BEHAVIOUR_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);
END_FUNCTION; -- acyclic

(* Implicit interfaced from: measure_schema *)
  FUNCTION valid_units (m : measure_with_unit):BOOLEAN;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'STATE_BASED_BEHAVIOUR_MIM_LF.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'STATE_BASED_BEHAVIOUR_MIM_LF.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'STATE_BASED_BEHAVIOUR_MIM_LF.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'STATE_BASED_BEHAVIOUR_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

(* Implicit interfaced from: measure_schema *)
  FUNCTION derive_dimensional_exponents (x : unit):dimensional_exponents;
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'STATE_BASED_BEHAVIOUR_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);
  END_FUNCTION;

(* Implicit interfaced from: product_definition_schema *)
  FUNCTION acyclic_product_category_relationship (relation : product_category_relationship; children : SET OF product_category):BOOLEAN;
    LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;
(* REFERENCE FROM (basic_attribute_schema); *)
  FUNCTION get_name_value (obj : name_attribute_select):label;
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'STATE_BASED_BEHAVIOUR_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

(* Implicit interfaced from: measure_schema *)
  FUNCTION dimensions_for_si_unit (n : si_unit_name):dimensional_exponents;
    CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
  FUNCTION acyclic_mapped_representation
    (parent_set   : SET OF representation;
     children_set : SET OF representation_item) : BOOLEAN;
    LOCAL
      x,y : SET OF representation_item;
    END_LOCAL;
    -- Determine the subset of children_set that are mapped_items
    x := QUERY(z <* children_set | 'STATE_BASED_BEHAVIOUR_MIM_LF.MAPPED_ITEM'
      IN TYPEOF(z));
    -- Determine that the subset has elements
    IF SIZEOF(x) > 0 THEN
      -- Check each element of the set
      REPEAT i := 1 TO HIINDEX(x);
        -- If the selected element maps a representation in the
        -- parent_set, then return false
        IF x[i]\mapped_item.mapping_source.mapped_representation
          IN parent_set THEN
          RETURN (FALSE);
        END_IF;
        -- Recursive check of the items of mapped_representation
        IF NOT acyclic_mapped_representation
          (parent_set +
          x[i]\mapped_item.mapping_source.mapped_representation,
          x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    -- Determine the subset of children_set that are not
    -- mapped_items
    x := children_set - x;
    -- Determine that the subset has elements
    IF SIZEOF(x) > 0 THEN
      -- For each element of the set:
      REPEAT i := 1 TO HIINDEX(x);
        -- Determine the set of representation_items referenced
        y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
             'STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Recursively check for an offending mapped_item
        -- Return false for any errors encountered
        IF NOT acyclic_mapped_representation(parent_set, y) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return true when all elements are checked and
    -- no error conditions found
    RETURN (TRUE);
  END_FUNCTION;

(* Implicit interfaced from: representation_schema *)
  FUNCTION item_in_context
    (item  : representation_item;
     cntxt : representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'STATE_BASED_BEHAVIOUR_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);
  END_FUNCTION;

(*** 2003=>1994 conversion: insert a rule to control if instances are legal according to USE/REF clauses ***)

RULE validate_dependently_instantiable_entity_data_types FOR
      (application_context,application_context_element,classification_role,description_text_assignment,document_type,document_usage_constraint,document_usage_role,expression_role,mapped_item,product_context,product_definition_context_role,state_type_role --<list this first and all subsequent relevant referencedentity data types here>
      );
LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := application_context + application_context_element + classification_role + description_text_assignment + document_type + document_usage_constraint + document_usage_role + expression_role + mapped_item + product_context + product_definition_context_role + state_type_role;--<make a union of all implicit populations of the FOR-clause>
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;

WHERE
  WR1: dependently_instantiated(all_instances, set_of_input_types,
                                previous_in_chain);
END_RULE;

FUNCTION dependently_instantiated(
            set_of_input_instances : SET OF GENERIC:igen;
            set_of_input_types     : SET OF STRING;
            previous_in_chain      : LIST OF GENERIC:cgen): BOOLEAN;
(*'dependently_instantiated' To test whether all instances in the
  input set_of_input_instances are referenced by independently
  instantiable instances. If so, this function returns true.
  Set_of_input_types includes the type strings for all input instances.
  The instances in previous_in_chain are used to detect cyclic
  references during recursive calls to this function. The parameter
  lists already tested instances in a chain of references.
*)
LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types <= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all => invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);
END_FUNCTION; -- end dependently_instantiated



END_SCHEMA;


