<?xml version="1.0"?>
<?xml-stylesheet 
  type="text/xsl" 
  href="../../../xsl/descriptions.xsl"?>
<!DOCTYPE ext_descriptions SYSTEM "../../../dtd/description.dtd">
<ext_descriptions module_directory="system_structure" schema_file="arm.xml" describe.selects="YES" describe.subtype_constraints="YES" rcs.date="$Date: 2005/07/28 12:17:12 $" rcs.revision="$Revision: 1.11 $">
<!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  Schema: System_structure_arm
   <express_ref linkend="system_structure:arm:System_structure_arm"/>
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<ext_description linkend="System_structure_arm">

<p><b>Re.  Hierarchy Semanitcs -  notes from Jozsef Bedocs</b></p>
<ul>
	<li>I contend that system, subsystem, assembly, component (or whatever 
	other names one substitutes here) are not the names of levels of 
	hierarchies for design elements; but the names of types of 
	associations between design elements and their organizations.</li>
	<li>Also, naming levels of hierarchies for design elements is futile, 
	because hierarchy is true only for a named design element.  If one 
	steps back to look at the collection of design elements and their 
	inter-relationships; one would not call what they saw hierarchy. </li>
	<li>Please entertain the use of the word Design.  While we are not 
	trying to make a language, if we want a systems data exchange to be 
	used, it has to be clear and concise or it won't be used.  Apparently 
	the words being batted around are insufficiently clear.</li>
	<li>But what is clear in engineering is the word Design.  It doesn't 
	matter if you talk to a software, electrical, chemical, biological 
	or nuclear engineer (or any other type of engineer), design is design. 
	Designs are things that we may or may not build. Metrics, such as 
	mass, power, dimensions, reliability, etc are associated with elements 
	of design.</li>
</ul>


<p><b>Re.  Hierarchy Semantics -  notes from David Price</b></p>
<ul>
	<li>My understanding has been basically that "STEP 
	<express_ref linkend="product_identification:arm:Product_identification_arm.Product"/>" </li><ol>
	<li>-  has implicit subtype "design of thing" which </li>
	<li>-  has subtype "STEP 
	<express_ref linkend="part_and_version_identification:arm:Part_and_version_identification_arm.Part"/>" 
	which</li>
	<li>-  has implicit subtypes "detailed part" and "assembly"</li></ol>
	<li>So, Joe did hit the core of the issue by bringing "design" into the discussion</li>
	<li>Tom was also right "STEP Product" is now much broader in scope than "design of thing".</li>
</ul>

<p><b>Re.  System and Product -  notes from David Oliver</b></p>
<ul>
	<li>In Asheville we decided as a team to place System at the level of 
	<express_ref linkend="product_identification:arm:Product_identification_arm.Product"/>, 
	essentially equivalent to 
	<express_ref linkend="product_identification:arm:Product_identification_arm.Product"/></li>
	<ol>
	<li>-  The <express_ref linkend="product_identification:arm:Product_identification_arm"/>
	then provides a name, ID, description and 
	categorization for System.</li>
	<li>-  The <express_ref linkend="product_version:arm:Product_version_arm"/> 
	provides a version with ID and description for 
	System Version.</li>
	<li>-  The <express_ref linkend="product_version_relationship:arm:Product_version_relationship_arm"/> 
	provides a sequencing of later to 
	earlier versions or a hierarchy of versions</li>
	<li>-  The <express_ref linkend="product_view_definition:arm:Product_view_definition_arm"/> 
	provides ID, name, and additional description 
	for System view definition, and a context with application domain, life cycle 
	stage and description.</li>
	<li>-  The <express_ref linkend="product_view_definition_relationship:arm:Product_view_definition_relationship_arm"/> provides relationships among 
	Product View Definitions</li>
	</ol>
	<li>From the point of view of applications, making System equivalent to Product 
	means that we need to have designs and real manufactured things at the same 
	high level in the model. We also need to have interfaces among Systems, among 
	Designs, and among real manufactured things. It must be possible to keep these 
	interfaces consistent, and to attach interface requirements to them.</li>
</ul>

<p><b>Re.  Part the Design of real manufactured things -  notes from David Oliver</b></p>
<ul>
	<li>The <express_ref linkend="part_and_version_identification:arm:Part_and_version_identification_arm"/> 
	defines Part as design and makes 
	Part and Part Version subclasses of Product and Product Version.</li>
	<li>The <express_ref linkend="part_view_definition:arm:Part_view_definition_arm"/> 
	makes Part View Definition a subclass of Product View Definition</li>
</ul>

<p><b>Re.  Part -  notes from Erik Herzog</b></p>
<ul>
	<li>I would appreciate if you could provide more information on the use of 
	part objects. In document based systems engineering the set of physical 
	objects identified are, e.g., identified in an SSDD (System Subsystem Design 
	Description). The granularity of these descriptions are of course system dependent, 
	but typically at a very high level of abstraction and not necessarily intended for 
	realisation (i.e., they are conceptual). Requirement traceability is normally 
	provided in the document format as well.</li>
	<li>My question here is whether using part is the right thing to do. 
	The alternative would be to represent the physical components using a special 
	subtype of Product, thus indicating that the physical component "thingy" is a 
	conceptual element, i.e., a requirement in another format and not intended to 
	be seen as a realisation element.</li>
	<li>This question may appear trivial, but has some value for the creation of 
	CM baselines. A SSDD type document would normally be part of the functional 
	baseline and frozen early in the process. If  physical objects are treated 
	as part then they would naturally evolve over the processes and it 
	would be difficult to capture whether new versions of the objects are due to 
	changes in the requirements or the natural design evolution.</li>
</ul>


<p><b>Re.  Part -  notes from Tom Thurman</b></p>
<ul>
	<li>Erik:  Excellent question! I would encourage you and others interested to 
	consider developing a use case to formally drive out details.</li>
	<li>However, here are some thoughts:</li><ol>
	<li>The AP210 project has taken the approach that the STEP - Product 
	objects (i.e., product entity in ISO 10303-41) should have as few top level 
	subtypes as possible.  The reason is that the product object is the focus 
	of product identification and commerce.  The descriptions of a product you 
	describe most likely are properties of the STEP - product_view_definition 
	object or may be properties of the relationship between two such 
	STEP - product_view_definition objects.</li>
	<li>It is quite dangerous for me to make such a statement without seeing some actual 
	data because but I trust you are talking about things like - the speed shall be at 
	least 60 mph at zero deg Centigrade - for this version of the product.</li>
	<li>The granularity and level of abstraction of physical reality the properties 
	represent is exactly decided by the agreed scope of the AP and is realized in the 
	different types of Product_view_definitions an AP creates (and the relationships 
	between those views.</li></ol>
	<li>From my interpretation of the STEP part object, and how we use it in AP210, 
	it is only intended to be for products which contain atoms when delivered.</li>
	<li>Other subtypes of Product for instance software is intended to be information 
	and not atoms (when software is combined with specific media e.g., a CD that 
	combination is considered to be a part).</li>
	<li>Somewhere I have an AP210 presentation Lothar and I did at the recent PDES Inc. 
	offsite.  It shows some of the AP210 usages of Product subtypes and 
	product_view_definition subtypes.</li>
	<li>It is limiting to have a product subtype, product_version subtype, and 
	product_view_definition subtype tree, as those are currently constrained 
	to force exactly one type of product_view_definition for the product subtype, 
	and we may decide that that is not a good thing.  I am not sure how this came to be, 
	but it seems to be relatively recent in STEP (i.e, only appeared with stepmod 
	development as far as I know.)</li>
	<li>I personally don't know at what stage the part identifier (as opposed to 
	the STEP product_concept, product_model> object identifiers) is known.  
	This may play an overriding role in deciding this issue for AP233.  It was deemed 
	a non-issue in AP210 during reviews of the activity model, so that model assumes all 
	the Product identifiers are known, as well as the id owning organization.</li>
</ul>

<p><b>Re.  Real manufactured things -  notes from David Oliver</b></p>
<ul>
	<li>In the 
	<express_ref linkend="product_as_individual:arm:Product_as_individual_arm"/>, 
	<b>Product as Realized </b>represents 
	versions of real manufactured things. <b>Product as Individual View</b> 
	represents the details of particular versions of Product as Realized and 
	it appears to be an appropriate representation for the details about 
	versions of real things.</li>
	<li>Summary: Under the decision to make System equivalent to Product, we 
	can use Part for design and Product_as_individual_view for real manufactured 
	things. It is critical for us to know if this solution works.	We still 
	need to decide whether to use Interface arm, Product_interface_arm or a 
	third solution to represent interfaces.</li>
	<li>The Product Interface arm as defined in Draft 4 is included in this system_structure module as entities 
	<express_ref linkend="system_structure:arm:System_structure_arm.Port_based_interconnect_definition"/>
	and 
	<express_ref linkend="system_structure:arm:System_structure_arm.Product_interconnect_definition"/>
	</li>

</ul>

<p><b>Re.  Assembly -  notes from Sean Baker</b></p>
<ul>
	<li>The problem with the concept of assembly is that some user's 
	"part" is another user's assembly</li>
	<li>From the STEP viewpoint, saying something is an assembly is 
	equivalent to saying you have the breakdown into smaller physical 
	components. "assembly" is not a classification of the thing in 
	itself, but an observation on whether your organization thinks 
	about it in terms of components.</li>
	<li>In a PDM context, an assembly is something that is in itself 
	configuration controlled (in a configuration context), and is made 
	from configuration controlled parts. Here, an assembly is a 
	convenient holder for "a collection of parts". It would not affect 
	the end product if a different collection of assemblies were used, 
	as long as the same collection of parts in the same position is 
	the result. The old 'Product Manager' explicitly supported the 
	restructuring of the design assembly breakdown into a manufacturing 
	assembly breakdown. There are also often differences between the 
	assembly structure used in manufacture and the assemblies provided 
	as spares.</li>
	<li>Which all goes top reinforce that "assembly" is as much a description 
	of the user organization as the product. Since STEP does not transfer 
	business processes, it is probably best to treat "assembly" as a 
	placeholder for a family of concepts that need further specification.</li>
</ul>


<p><b>Re.  Assembly -  notes from Gerry Radack</b></p>
<ul>
	<li>If you are saying that it does not make sense to say that an Assembly is
		a kind of Product or Part I agree. Assembly should be treated as a
		relationship which is part of a structure. We should be able to say "A
		is assembled from B, C and D within structure X" but not "A is an
		assembly". Different structures are needed to account for different
		activities or purposes, e.g., manufacture, maintenance, and disposal.</li>
</ul>


<p><b>Re.  Assembly -  notes from Lothar Klein</b></p>
<ul>
	<li>In STEP an assembly is not a Product but a view to a version of a part. </li>
	<li>A Part_version can have many views some of them can be assemblies others not. 
	E.g. for the same part_version we may have</li><ol>
	<li>an assembly_view "as designed"</li>
	<li>an assembly_view "as manufactured" which could be quite different</li>
	<li>a non-assembly view for the customers/users of the product </li></ol>
	<li>All this is covered by AP214. In addition AP214 has</li><ol>
	<li> a mating_definition view to be able to say how things are connected
	with each other in very detail</li>
	<li>a collection_definition view. This is needed if you have e.g. a part
	  which is a pair of shoes, consisting of the left one and the right
	  one (each one is its own part). A pair of shoes is not an assembly
	  but a collection.</li></ol>
	<li>AP210 adds further detailed views such as usage and design views.</li>
</ul>




<p><b>Re.  Breakdown -  notes from the Editor</b></p>
<ul>
	<li>Considerable debate surrounds the breakdown modules of stepmod</li>
	<li>AP233 has no desire to take an EXPRESS modeling preference position</li>
	<li>Self imposed constraints on AP233</li><ol>
		<li>define AP233 problem needs as clearly as possible</li>
		<li>harmonize the AP233 solution with AP210/AP214/AP239/APxxx</li>
		<li>listen/act on consensus view of STEP-world experts</li></ol>
</ul>

<p><b>Re.  Breakdown -  notes from David Oliver</b></p>
<ul>
	<li>In Asheville we decided as a team to place System at the level of Product.  
	Additionally it was decided that we will not in this initial draft attempt to use</li>
	<ol><li>Functional Breakdown arm</li>
	<li>Physical Breakdown arm</li>
	<li>Product Breakdown arm</li>
	<li>System Breakdown arm</li></ol>
	<li>This raises three questions:</li><ol>
	<li>If these four arms are not used, will AP233 mappings to 
		applications and AP239 mappings to applications be in harmony?</li>
	<li>How does AP239 map these four arms to applications?</li>
	<li>What are the definitions for System Breakdown, Functional 
		Breakdown, and Physical Breakdown? The existing documentation 
		does not tell us.</li></ol>
	<li>NOTE:  There appears to be dis-harmony on the notions surrounding the concept of 
	breakdown wthin the STEP WG12 community</li>
</ul>
	

<p><b>Re.  Breakdown -  notes from Lothar Klein</b></p>
<ul>
	<li>I [Lothar Klein] propose to arrange an WG3/WG12 session on breakdown at 
	the SC4 Valencia meeting. It is important that in SC4 we come to a commonly 
	accepted models which can serve all APs and requirements.</li>
	<li>Note that all the modules are on TS level only!
	So we should be free to do incompatible changes where needed when it
	supports interpretability between different APs.</li>
	<li>In STEP a part_version is a kind of product(_version) which someone
		can build or buy. Main characteristics of a part is that it has no
		variants (it is fully specified) and that you may have one or several
		Product_individuals (those which might have a serial number and which
		are the focus of PLCS).</li>
	<li>For variant products and the early design phases AP214 introduced a
		"conceptional product structure" (see UOF S7). At about the same time
		the concept of "product breakdown" was introduced in the NATO/CALS
		Product Data Model (NPDM/NCDM) which can serve similar purposes.</li>
	<li>With the modularized development of AP236 and AP239 we got now the
		breakdown module and specialisations (zonal, functional, ...) intended
		to cover the "conceptional product structure" of AP214 and further
		needs.</li>
	<li>To the question whether or not AP233 needs breakdown I would strongly
		suggest to say YES. AP233 works in the early design phase were we
		have only vague structures which are clearly not assemblies or well
		defined "collections" as indicated above. So breakdown is the right
		thing to go for.</li>
	<li>BIG!  But I have to say that I have *big* doubts about the details in the
		breakdown modules. </li><ol>
	<li>For me a breakdown is only a *view* to a version of a product, 
			but not a product by itself !!!!!</li>
	<li>PLCS developers told me that a breakdown must be its own product - but
			they failed to convince me so far.</li>
	<li>I propose to remove all specialisations of Product and
			Product_version for breakdown.</li>
	<li>The primary entity is Breakdown_element_definition (and subtypes).</li>
	<li>People should use for its "defined_version" and "of_product just the
			supertypes product/product_version if they don't know if it will be part
			a document, an individual or whatever. </li>
	<li>Further detailed changes on the breakdown module are needed in my 
			opinion (e.g. on Breakdown_of), but this will be too much for this email.</li></ol>
	<li>AP233 - BOTTOM LINE  Caution is advised!!!!!!!!!!</li>
	<li>For some future version of AP210 I could see the need to have combined
		functional and zonal breakdowns of a PCA/PCB to separate digital and
		analog areas; or high voltage and low voltage. But these would be
		additional views to a part_version, which also has PCA/PCB views.</li>
	<li>When an airplane with a given serial number is split into regions for
		business and economy class this is a zonal_breakdown *view* of an
		individual product at a particular period of time (it may be different for
		the next flight). </li><ol>
	<li>We should not introduce an artificial Zonal_breakdown at the 
			product level for this.</li></ol>
	<li>To support a highly variant product such as a car we have to combine
		the breakdown structure with specifications and expressions to be able
		to say which combinations of components are valid and which are not.</li><ol>
	<li>In AP214 all the is done on the view level (product_definitions).
			AP236/239 misses to introduce a product for such a Variant_part.</li></ol>

</ul>


<p><b>Re.  Breakdown -  notes from David Price</b></p>
<ul>
	<li>The PLCS team believes the core requirement for the separation of Product Design 
	from System Breakdown came from the AP233 team. Therefore, they are a bit confused 
	by the idea of AP233 not using it.</li><ol>
	<li>Reason: Neither the AP233 problem nor the AP239 solution was understood 
	in sufficient depth.  Opinion were given; but not AP233 commitments could 
	possibly have been made.  An understanding of all relevant aspect of the AP233 
	problem was not fully understood. </li></ol>
	<li>The concept behind the use of the various concepts is based on the following scenario.</li>
	<li>During early concept design, System breakdowns are created by SEs (and yes, here 
	I mean the AP239 concept of breakdown)</li>
	<li>Progressively, the system elements that are related to the system breakdown are 
	related to functions (functional breakdown) or potential products (product breakdown)</li>
	<li>At some point, real products need to be designed and the STEP Product assembly 
	(i.e. Parts) concept is used.</li>
	<li>AP239 also covers the Product as Individual (i.e. thing in the real world) but I'm not 
	sure that really affect this discussion on the use of breakdown by AP233. It may though.</li>
	<li>It is the understanding of the PLCS team that both AP233 and PLCS will need both the 
	breakdown and assembly concepts.</li>
	<li>It seems to me that what they've described holds together even if the definitions in 
	the actual STEPMod modules aren't sufficient to explain all this. Also, in Asheville we 
	discussed mapping "The SE Term System" to "The STEP Product Entity". The argument was 
	that "SEs mean almost anything when the say System" and so STEP Product was the closest 
	concept. However:</li><ol>
	<li>after more thought I'm not sure that matters.</li>
	<li>We are not defining the terminology SEs use, we are defining an information 
	model for exchange. </li>
	<li>If, for the purpose of exchange, we need to make distinctions between System 
	Breakdown, System Element, Product Design, and Product As Individual then AP233 
	should include those concepts.</li></ol>
	<li>If we can fix any errors or extend in these PLCS modules working with that team so 
	they work for AP233 we get a long way towards supporting AP Interoperability.  Which is a 
	big requirement for some given AP233 took the modular approach.</li>
</ul>


<p><b>Re.  Breakdown -  notes from Erik Herzog</b></p>
<ul>
	<li>Yes, sometime during the last millennium we made the distinction between the 
	product design and system design structures, and I would be very much worried 
	if this distinction was not maintained.</li>
	<li>However, I have been away from STEP too long to immediately grasp the 
	breakdown concept and to assess whether our original intentions is supported 
	(those intentions may of course not be valid any more). Are there any 
	examples available?</li>
	<li>WHAT IS  - " the distinction between the 
	product design and system design structures" ??????? </li><ol>
	<li>The product to one is the system to another</li>
	<li>I see no distinction - this makes me nervous</li></ol>
</ul>
	

<p><b>Re.  Interfaces -  notes from David Oliver</b></p>
<ul>
	<li>The Interface Arm is subclassed to Product, Product Version, and with a 
	general capability for assignment. This appears to be a good solution 
	for interfaces but it may not work. The population of Interface Arm is a 
	critical issue for us to learn if it works.</li>
	<li>An alternative arm for interface called Product Interface arm has been 
	placed in the Structure Draft 4. It is modeled on 
	the AP210 Physical Unit Interconnect Definition arm. That AP210 arm is 
	subclassed to Part view definition. As Tom Thurman told us at Asheville, 
	this means the AP210 module applies only to design, to Part. The Product 
	Interface arm is subclassed to Product view definition so it is a possible 
	solution. We critically need to know if those most expert in EXPRESS 
	believe that the Product Interface arm will work. We critically need to 
	see if the Product interface arm can be populated with a simple example. 
	We need to choose the better of Interface arm and Product Interface arm 
	or find an even better solution.</li>
	<li>Product Interface arm as defined in Draft 4 is included herein as entities 
	   <express_ref linkend="system_structure:arm:System_structure_arm.Port_based_interconnect_definition"/>
	   and 
	   <express_ref linkend="system_structure:arm:System_structure_arm.Product_interconnect_definition"/>
	</li>
	<li>The word Interface is heavily overloaded and has different meanings in 
	different disciplines and processes.  The AP 233 definition, see the concept 
	model, defines an interface as the boundary between two things that 
	interconnect.</li>
	<li>AP233 associates with the interface a variety of emergent observable 
	characteristics that result from the interconnection and may not exist for the 
	ports of the two things. These characteristics may be dynamic, as for protocols; 
	for mechanical motion, power, and torque; for failure under cyclic conditions, 
	for performance under vibration, or for energy transfer as for current and power 
	or high pressure steam. These characteristics may be static and involve stresses 
	and strains. Most often there are important geometric characteristics.</li>
	<li>The AP233 definition of interface applies to systems, their designs, and 
	their realization in stuff made of atoms. It is not necessarily simplified 
	and abstract, but may be detailed, concrete, and subject to analysis and 
	trade studies.</li>
	<li>AP233 needs to harmonize "interface" with many AP's, for example 210 
	and 214, as well as 239.</li>  
	<li>The relative importance of the harmonization instances can be extracted 
	from the life cycle and the complexity of interfaces described. The most 
	proximate life cycle relationship is with engineering design disciplines like 
	210. The most complex relationship exists with manufacturing engineering and 
	the CAD that supports it, because manufacturing has the largest number and 
	most detailed interfaces. AP239 and maintenance has more remote and simpler 
	relationships because these exist for line replaceable units primarily. On 
	the other hand, maintenance needs the long term archival of interface 
	information much more than most AP's.</li>
	<li>To be able to work this issue we need to:</li><ol>
	<li>Broaden it beyond just two AP's.</li>
	<li>Converge on the AP233 definition for an interface. It will be in conflict 
	with many other definitions that are valid in their own domains. Too bad the 
	word is overloaded. We must have a clear distinction among different concepts.</li>
	<li>Understand the relative importance and complexity of harmonization with each 
	important AP.</li>
	<li>Attempt to harmonize with them all.</li>
	</ol>
	
</ul>

<p><b>Re.  Interfaces -  instance diagrams from Phil Spiby EUROSTEP.</b></p>

	<p>This report can be downloaded at 
	<a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/stepmod/stepmod/etc/ap233/references/system_structure/Phil_PLCS_Interface_example_1.pdf%20?rev=1.1"/>
	</p>
	
<p><b>Re.  Interface -  notes from Lothar Klein</b></p>
<ul>
	<li>Yes, this is a great work.  But unfortunately if you look in more detail it 
	proves that the interface module is not working </li><ol>
	<li>The pictures indicate that this example deals with product_individuals
	(those with a serial number)</li>
	<li>Instead it may be better to describe the whole thing on a "typical"
	design level. This is having an assembly or collection of an
	occurrence of an outlet, an occurrence of a computer and an
	occurrence of a cable.</li>
	<li>But instead the example data population works only on the definition
	level (part_view_definition)
	There are occurrences of the connectors, but no occurrences of the
	computer, cable and outlet. In other word, these examples say that
	every computer is connect with this kind of cable to this kind of
	outlet which is definitely not true since here in Germany we connect
	the computer with a different kind of cable to a different type of
	outlet. This problem can't be solved on the definition level!</li></ol>
	<li>Try to add two extension cords "EXT-A" and "EXT-B" of the same type
	(part.name="EXT") to this example and you will see that you can't
	describe the overall connections without having part_occurrences of
	
	outlet(wall), cable, extension, computer and these occurrences have to
	build a higher level of assembly (or collection).</li>
	<li>I agree to the requirement to be able to describe such connections
	without going down to the detailed terminal level.</li>
</ul>

<p><b>Re.  Interfaces -  to which Phil Spiby EUROSTEP responds in greater detail.</b></p>

	<p>This report can be downloaded at 
	<a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/stepmod/stepmod/etc/ap233/references/system_structure/Phil_PLCS_Interface_example_4.pdf?rev=1.1"/></p>


<p><b>Re.  Analytical model -  from the editor</b></p>
<ul>	
	<li>A "_lite" version of AP210 Analytical model seems to be needed.  It would 
	contain just what is needed for the generic (analytical model) function.  It would
	then use type extends to make associations AP210 does by AP210 focused entities and attributes.  </li>
	<li>the outlines for the "_lite" modules herein simply strip away all but the obvious (to the editor)</li>
	<li>as the above takes form so to will the analytical model capability</li>
</ul>

<p><b>Re.  Production_rule -  from the editor</b></p>
<ul>	
	<li>A "_lite" version of AP210 Product rules seems also to be needed.</li>
	<li>as the above takes form so to will the product rule capability</li>
	<li>product rules are tightly coupled to requirements.</li>
</ul>

<p><b>Re.  System physical architecture modelling alternatives within AP-233 -  
from Erik Herzog, Syntell AB</b></p>

<ul>	
	<li>This report can be downloaded at 
	<a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/stepmod/stepmod/etc/ap233/references/system_structure/Erik_system_structure_1.doc?rev=1.1"/></li>
	<li>David's comments can be downloaded at 
	<a href="http://cvs.sourceforge.net/viewcvs.py/*checkout*/stepmod/stepmod/etc/ap233/references/system_structure/David_system_structure_1.ppt?rev=1.1"/></li>
</ul>


</ext_description>

</ext_descriptions>
