
(* ===================================================================================== *)
(* Long form schema generated by The EXPRESS Data Manager EXPRESS Compiler version 9.00  *)
(* Mon Apr 29 15:25:46 2002                                                              *)
(* ===================================================================================== *)
SCHEMA smch_plus_203_schema;


CONSTANT

      dummy_gri : geometric_representation_item := representation_item('') || geometric_representation_item();

       (*BA ADDED DUMMY_TRI  *)
      dummy_tri : topological_representation_item := representation_item('')||
                  topological_representation_item();


END_CONSTANT;



  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE;



  TYPE approved_item = SELECT
    (product_definition_formation,
     product_definition,
     configuration_effectivity,
     configuration_item,
     security_classification,
     change_request,
     change,
     start_request,
     start_work,
     certification,
     contract);
  END_TYPE;



  TYPE area_measure = REAL;
  END_TYPE;



  TYPE area_or_view = SELECT
    (presentation_area,
     presentation_view);
  END_TYPE;



  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE;



  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE;



  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE;



  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE;



  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE;



  TYPE box_characteristic_select = SELECT
    (box_height,
     box_width,
     box_slant_angle,
     box_rotate_angle);
  END_TYPE;



  TYPE box_height = positive_ratio_measure;
  END_TYPE;



  TYPE box_rotate_angle = plane_angle_measure;
  END_TYPE;



  TYPE box_slant_angle = plane_angle_measure;
  END_TYPE;



  TYPE box_width = positive_ratio_measure;
  END_TYPE;



  TYPE central_or_parallel = ENUMERATION OF
    (central,
     parallel);
  END_TYPE;



  TYPE certified_item = SELECT
    (supplied_part_relationship);
  END_TYPE;



  TYPE change_request_item = SELECT
    (product_definition_formation);
  END_TYPE;



  TYPE character_spacing_select = SELECT
    (length_measure,
     ratio_measure,
     measure_with_unit,
     descriptive_measure);
  END_TYPE;



  TYPE character_style_select = SELECT
    (text_style_for_defined_font);
  END_TYPE;



  TYPE characterized_definition = SELECT
    (characterized_product_definition,
     shape_definition);
  END_TYPE;



  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE;



  TYPE classified_item = SELECT
    (product_definition_formation,
     assembly_component_usage);
  END_TYPE;



  TYPE configuration_design_item = SELECT
    (product_definition,
     product_definition_formation);
  END_TYPE;



  TYPE context_dependent_measure = REAL;
  END_TYPE;



  TYPE contracted_item = SELECT
    (product_definition_formation);
  END_TYPE;



  TYPE count_measure = NUMBER;
  END_TYPE;



  TYPE curve_font_or_scaled_curve_font_select = SELECT
    (curve_style_font_select);
  END_TYPE;



  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE;



  TYPE curve_or_annotation_curve_occurrence = SELECT
    (curve,
     annotation_curve_occurrence);
  END_TYPE;



  TYPE curve_or_render = SELECT
    (curve_style);
  END_TYPE;



  TYPE curve_style_font_select = SELECT
    (curve_style_font,
     pre_defined_curve_font,
     externally_defined_curve_font);
  END_TYPE;



  TYPE date_time_item = SELECT
    (product_definition,
     change_request,
     start_request,
     change,
     start_work,
     approval_person_organization,
     contract,
     security_classification,
     certification);
  END_TYPE;



  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select);
  END_TYPE;



  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE;



  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE;



  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE;



  TYPE day_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 366));
  END_TYPE;



  TYPE defined_symbol_select = SELECT
    (pre_defined_symbol,
     externally_defined_symbol);
  END_TYPE;



  TYPE derived_property_select = SELECT
    (property_definition);
  END_TYPE;



  TYPE description_attribute_select = SELECT
    (action_request_solution,
     application_context,
     approval_role,
     configuration_design,
     date_time_role,
     context_dependent_shape_representation,
     effectivity,
     external_source,
     person_and_organization_role,
     person_and_organization,
     property_definition_representation,
     representation);
  END_TYPE;



  TYPE descriptive_measure = STRING;
  END_TYPE;



  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE;



  TYPE dimension_extent_usage = ENUMERATION OF
    (origin,
     target);
  END_TYPE;



  TYPE dimensional_characteristic = SELECT
    (dimensional_location);
  END_TYPE;



  TYPE direction_count_select = SELECT
    (u_direction_count,
     v_direction_count);
  END_TYPE;



  TYPE draughting_callout_element = SELECT
    (annotation_text_occurrence,
     annotation_symbol_occurrence,
     annotation_curve_occurrence);
  END_TYPE;



  TYPE draughting_titled_item = SELECT
    (drawing_revision,
     drawing_sheet_revision);
  END_TYPE;



  TYPE fill_style_select = SELECT
    (fill_area_style_colour);
  END_TYPE;



  TYPE font_select = SELECT
    (pre_defined_text_font);
  END_TYPE;



  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE;



  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE;



  TYPE hiding_or_blanking_select = SELECT
    (presentation_area,
     presentation_view,
     annotation_fill_area);
  END_TYPE;



  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE;



  TYPE id_attribute_select = SELECT
    (action,
     application_context,
     organizational_project,
     representation);
  END_TYPE;



  TYPE identifier = STRING;
  END_TYPE;



  TYPE invisibility_context = SELECT
    (presentation_representation,
     presentation_set);
  END_TYPE;



  TYPE invisible_item = SELECT
    (styled_item,
     presentation_layer_assignment,
     presentation_representation);
  END_TYPE;



  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     quasi_uniform_knots,
     piecewise_bezier_knots,
     unspecified);
  END_TYPE;



  TYPE label = STRING;
  END_TYPE;



  TYPE layered_item = SELECT
    (presentation_representation,
     representation_item);
  END_TYPE;



  TYPE length_measure = REAL;
  END_TYPE;



  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE;



  TYPE marker_select = SELECT
    (marker_type,
     pre_defined_marker);
  END_TYPE;



  TYPE marker_type = ENUMERATION OF
    (dot,
     x,
     plus,
     asterisk,
     ring,
     square,
     triangle);
  END_TYPE;



  TYPE mass_measure = REAL;
  END_TYPE;



  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     context_dependent_measure,
     descriptive_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     positive_ratio_measure,
     count_measure);
  END_TYPE;



  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE;



  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE;



  TYPE name_attribute_select = SELECT
    (action_request_solution,
     configuration_design,
     context_dependent_shape_representation,
     derived_unit,
     effectivity,
     person_and_organization,
     product_definition,
     property_definition_representation);
  END_TYPE;



  TYPE parameter_value = REAL;
  END_TYPE;



  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE;



  TYPE person_organization_item = SELECT
    (change,
     start_work,
     change_request,
     start_request,
     configuration_item,
     product,
     product_definition_formation,
     product_definition,
     contract,
     security_classification);
  END_TYPE;



  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE;



  TYPE plane_angle_measure = REAL;
  END_TYPE;



  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE;



  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE;



  TYPE positive_ratio_measure = ratio_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE;



  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE;



  TYPE presentable_text = STRING;
  END_TYPE;



  TYPE presentation_representation_select = SELECT
    (presentation_representation,
     presentation_set);
  END_TYPE;



  TYPE presentation_size_assignment_select = SELECT
    (presentation_view,
     presentation_area,
     area_in_set);
  END_TYPE;



  TYPE presentation_style_select = SELECT
    (point_style,
     curve_style,
     surface_style_usage,
     symbol_style,
     fill_area_style,
     text_style);
  END_TYPE;



  TYPE presented_item_select = SELECT
    (product_definition);
  END_TYPE;



  TYPE product_or_formation_or_definition = SELECT
    (product,
     product_definition_formation,
     product_definition);
  END_TYPE;



  TYPE ratio_measure = REAL;
  END_TYPE;



  TYPE represented_definition = SELECT
    (property_definition,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE;



  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE;



  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE;



  TYPE role_select = SELECT
    (action_assignment,
     action_request_assignment,
     approval_assignment,
     approval_date_time,
     certification_assignment,
     contract_assignment,
     document_reference,
     security_classification_assignment);
  END_TYPE;



  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE;



  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE;



  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE;



  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE;



  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE;



  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE;



  TYPE size_select = SELECT
    (positive_length_measure,
     measure_with_unit,
     descriptive_measure);
  END_TYPE;



  TYPE solid_angle_measure = REAL;
  END_TYPE;



  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE;



  TYPE source_item = SELECT
    (identifier);
  END_TYPE;



  TYPE specified_item = SELECT
    (product_definition,
     shape_aspect);
  END_TYPE;



  TYPE start_request_item = SELECT
    (product_definition_formation);
  END_TYPE;



  TYPE style_context_select = SELECT
    (representation,
     representation_item,
     presentation_set);
  END_TYPE;



  TYPE supported_item = SELECT
    (action_directive,
     action,
     action_method);
  END_TYPE;



  TYPE surface_boundary = SELECT
    (boundary_curve,
     degenerate_pcurve);
  END_TYPE;



  TYPE surface_model = SELECT
    (shell_based_surface_model);
  END_TYPE;



  TYPE surface_side = ENUMERATION OF
    (positive,
     negative,
     both);
  END_TYPE;



  TYPE surface_side_style_select = SELECT
    (surface_side_style);
  END_TYPE;



  TYPE surface_style_element_select = SELECT
    (surface_style_fill_area,
     surface_style_boundary,
     surface_style_silhouette,
     surface_style_segmentation_curve,
     surface_style_control_grid,
     surface_style_parameter_line);
  END_TYPE;



  TYPE symbol_style_select = SELECT
    (symbol_colour);
  END_TYPE;



  TYPE terminator = SELECT
    (externally_defined_terminator_symbol,
     pre_defined_terminator_symbol,
     user_defined_terminator_symbol);
  END_TYPE;



  TYPE text = STRING;
  END_TYPE;



  TYPE text_alignment = label;
  END_TYPE;



  TYPE text_or_character = SELECT
    (annotation_text,
     composite_text,
     text_literal);
  END_TYPE;



  TYPE text_path = ENUMERATION OF
    (left,
     right,
     up,
     down);
  END_TYPE;



  TYPE tolerance_method_definition = SELECT
    (tolerance_value);
  END_TYPE;



  TYPE tolerance_select = SELECT
    (plus_minus_tolerance);
  END_TYPE;



  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE;



  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE;



  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE;



  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE;



  TYPE u_direction_count = INTEGER;
  WHERE
    wr1: (SELF > 1);
  END_TYPE;



  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE;



  TYPE v_direction_count = INTEGER;
  WHERE
    wr1: (SELF > 1);
  END_TYPE;



  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE;



  TYPE volume_measure = REAL;
  END_TYPE;



  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE;



  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE;



  TYPE work_item = SELECT
    (product_definition_formation);
  END_TYPE;



  TYPE year_number = INTEGER;
  END_TYPE;





   TYPE boolean_operator = ENUMERATION OF
      (union,
       intersection,
       difference);
   END_TYPE;





   TYPE characterized_action_definition = SELECT
      (action,
       action_method);
   END_TYPE;





   TYPE characterized_material_property = SELECT
      (material_property_representation);
   END_TYPE;





   TYPE compound_item_definition = SELECT
      (list_representation_item,
       set_representation_item);
   END_TYPE;





   TYPE csg_primitive = SELECT
      (sphere,
       ellipsoid,
       block,
       right_angular_wedge,
       faceted_primitive,
       rectangular_pyramid,
       torus,
       right_circular_cone,
       eccentric_cone,
       right_circular_cylinder,
       cyclide_segment_solid,
       primitive_2d);
   END_TYPE;





   TYPE csg_select = SELECT
      (boolean_result,
       csg_primitive);
   END_TYPE;





   TYPE document_reference_item = SELECT
      (property_definition);
   END_TYPE;





   TYPE group_item = SELECT
      (instanced_feature);
   END_TYPE;





   TYPE list_representation_item = LIST [1:?] OF representation_item;
   END_TYPE;





   TYPE property_or_shape_select = SELECT
      (property_definition,
       shape_definition);
   END_TYPE;





   TYPE set_representation_item = SET [1:?] OF representation_item;
   END_TYPE;





   TYPE shape_representation_item = SELECT
      (geometric_representation_item,
       topological_representation_item,
       solid_model,
       surface_model,
       wireframe_model);
   END_TYPE;





   TYPE value_qualifier = SELECT
      (precision_qualifier,
       type_qualifier,
       uncertainty_qualifier);
   END_TYPE;



  ENTITY action;
      name          : label;
      description   : OPTIONAL text;
      chosen_method : action_method;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY action_directive;
      name        : label;
      description : OPTIONAL text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY;



  ENTITY action_method;
      name        : label;
      description : OPTIONAL text;
      consequence : text;
      purpose     : text;
  END_ENTITY;



  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY;



  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY;



  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY;



  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP',
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb,
               'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY ( csf <* csh.
               cfs_faces | (NOT ('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN 
               TYPEOF(csf))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               msb\manifold_solid_brep.outer)) )) = 0);
      wr5: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT (
               'SMCH_PLUS_203_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION' IN 

               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
  END_ENTITY;



  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1: (SIZEOF(['SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE',
               'SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE',
               'SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE'] * TYPEOF(face_geometry)) 
               = 1);
      wr2: (SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.EDGE_LOOP',
               'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd)) = 1)) )) =
                0);
      wr3: (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
               'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | (
               NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | (
               NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.
               edge_element))) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
               'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | (
               NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | (
               NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
               edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN 
               TYPEOF(oe.edge_end)))) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
               'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | (
               NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | (
               NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.LINE',
               'SMCH_PLUS_203_SCHEMA.CONIC','SMCH_PLUS_203_SCHEMA.POLYLINE',
               'SMCH_PLUS_203_SCHEMA.PCURVE',
               'SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
               edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 
               0);
      wr6: (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
               'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | (
               NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_PATH' IN TYPEOF(elp_fbnds
               .bound))) )) = 0);
      wr7: ((NOT ('SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
               face_geometry))) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.LINE',
               'SMCH_PLUS_203_SCHEMA.CONIC','SMCH_PLUS_203_SCHEMA.POLYLINE',
               'SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(face_geometry
               \swept_surface.swept_curve)) = 1));
      wr8: (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | (
               'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                | (NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(
               vlp_fbnds.bound\vertex_loop.loop_vertex)) AND (
               'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds.

               bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry)))) )) 
               = 0);
  END_ENTITY;



  ENTITY alternate_product_relationship;
      name       : label;
      definition : OPTIONAL text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      ur1 : alternate, base;
    WHERE
      wr1: (alternate :<>: base);
  END_ENTITY;



  ENTITY annotation_curve_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(SELF\styled_item.item));

  END_ENTITY;



  ENTITY annotation_fill_area
    SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
  END_ENTITY;



  ENTITY annotation_occurrence
    SUPERTYPE OF (ONEOF (
              ANNOTATION_CURVE_OCCURRENCE,
              ANNOTATION_TEXT_OCCURRENCE,
              ANNOTATION_SYMBOL_OCCURRENCE))
  SUBTYPE OF (styled_item);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(

               SELF));
  END_ENTITY;



  ENTITY annotation_occurrence_associativity
    SUBTYPE OF (annotation_occurrence_relationship);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF.related_annotation_occurrence) * [
               'SMCH_PLUS_203_SCHEMA.ANNOTATION_FILL_AREA_OCCURRENCE',
               'SMCH_PLUS_203_SCHEMA.PROJECTION_CURVE',
               'SMCH_PLUS_203_SCHEMA.LEADER_CURVE']) = 1);

  END_ENTITY;



  ENTITY annotation_occurrence_relationship;
      name                           : label;
      description                    : text;
      relating_annotation_occurrence : annotation_occurrence;
      related_annotation_occurrence  : annotation_occurrence;
  END_ENTITY;



  ENTITY annotation_symbol_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: (SIZEOF(['SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL',
               'SMCH_PLUS_203_SCHEMA.DEFINED_SYMBOL'] * TYPEOF(SELF\

               styled_item.item)) > 0);
  END_ENTITY;



  ENTITY annotation_text
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF(SELF\
               mapped_item.mapping_target));
      wr2: ('SMCH_PLUS_203_SCHEMA.TEXT_STRING_REPRESENTATION' IN TYPEOF(
               SELF\mapped_item.mapping_source.mapped_representation));
      wr3: ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(

               SELF));
  END_ENTITY;



  ENTITY annotation_text_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1: (SIZEOF(['SMCH_PLUS_203_SCHEMA.TEXT_LITERAL',
               'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT',
               'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_CHARACTER',
               'SMCH_PLUS_203_SCHEMA.DEFINED_CHARACTER_GLYPH',
               'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT'] * TYPEOF(SELF\

               styled_item.item)) > 0);
  END_ENTITY;



  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (
              PRODUCT_CONCEPT_CONTEXT,
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY;



  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY;



  ENTITY applied_presented_item
    SUBTYPE OF (presented_item);
      items : SET [1:?] OF presented_item_select;
  END_ENTITY;



  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY;



  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY;



  ENTITY approval_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY;



  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY approval_status;
      name : label;
  END_ENTITY;



  ENTITY area_in_set;
      area   : presentation_area;
      in_set : presentation_set;
  END_ENTITY;



  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (
              NEXT_ASSEMBLY_USAGE_OCCURRENCE,
              SPECIFIED_HIGHER_USAGE_OCCURRENCE,
              PROMISSORY_USAGE_OCCURRENCE))
  SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY;



  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : OPTIONAL text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY;



  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),representation_item('') || 
             geometric_representation_item() || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY;



  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY;



  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY;



  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (
              UNIFORM_CURVE,
              B_SPLINE_CURVE_WITH_KNOTS,
              QUASI_UNIFORM_CURVE,
              BEZIER_CURVE)
              ANDOR 
              RATIONAL_B_SPLINE_CURVE)
  SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : BOOLEAN; --BA LOGICAL;
      self_intersect      : BOOLEAN; --BA LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('SMCH_PLUS_203_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (
               'SMCH_PLUS_203_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) 
               OR ('SMCH_PLUS_203_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF)) OR (
               'SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(

               SELF)));
  END_ENTITY;



  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY;



  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE_WITH_KNOTS,
              UNIFORM_SURFACE,
              QUASI_UNIFORM_SURFACE,
              BEZIER_SURFACE)
              ANDOR 
              RATIONAL_B_SPLINE_SURFACE)
  SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : BOOLEAN; --BA LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('SMCH_PLUS_203_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR (
               'SMCH_PLUS_203_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) 
               OR ('SMCH_PLUS_203_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
                ('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN 

               TYPEOF(SELF)));
  END_ENTITY;



  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY;



  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY;



  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY;



  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY;



  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (
              POLYLINE,
              B_SPLINE_CURVE,
              TRIMMED_CURVE,
              COMPOSITE_CURVE))
  SUBTYPE OF (curve);
  END_ENTITY;



  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE,
              RECTANGULAR_TRIMMED_SURFACE,
              CURVE_BOUNDED_SURFACE,
              RECTANGULAR_COMPOSITE_SURFACE))
  SUBTYPE OF (surface);
  END_ENTITY;



  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY;



  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY;



  ENTITY camera_image
    SUBTYPE OF (mapped_item);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.CAMERA_USAGE' IN TYPEOF(SELF\mapped_item.
               mapping_source));
      wr2: ('SMCH_PLUS_203_SCHEMA.PLANAR_BOX' IN TYPEOF(SELF\mapped_item.
               mapping_target));
      wr3: ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(

               SELF));
  END_ENTITY;



  ENTITY camera_image_3d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale : positive_ratio_measure := SELF\mapped_item.mapping_target\
                 planar_extent.size_in_x / SELF\mapped_item.mapping_source.
                 mapping_origin\camera_model_d3.perspective_of_volume.
                 view_window.size_in_x;
    WHERE
      wr1: ('ASSOC_DIM.CAMERA_MODEL_D3' IN TYPEOF(SELF\mapped_item.
               mapping_source.mapping_origin));
      wr2: (aspect_ratio(SELF\mapped_item.mapping_target) = aspect_ratio(
               SELF\mapped_item.mapping_source.mapping_origin\
               camera_model_d3.perspective_of_volume.view_window));
      wr3: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3
               .perspective_of_volume.front_plane_clipping AND SELF\
               mapped_item.mapping_source.mapping_origin\camera_model_d3.
               perspective_of_volume.view_volume_sides_clipping);
  END_ENTITY;



  ENTITY camera_model
    SUPERTYPE OF (
              CAMERA_MODEL_D3)
  SUBTYPE OF (geometric_representation_item);
    WHERE
      wr1: ((SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'ITEM_DEFINED_TRANSFORMATION.' + 'TRANSFORM_ITEM_1')) + 
               SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'REPRESENTATION_MAP.MAPPING_ORIGIN'))) > 0);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 'STYLED_ITEM.ITEM')) 

               = 0);
  END_ENTITY;



  ENTITY camera_model_d3
    SUBTYPE OF (camera_model);
      view_reference_system : axis2_placement_3d;
      perspective_of_volume : view_volume;
    WHERE
      wr1: ((dot_product(SELF.view_reference_system.p[3],SELF.
               perspective_of_volume.view_window.placement.p[3]) = 1) AND (
               SELF.view_reference_system.location.coordinates[3] = SELF.
               perspective_of_volume.view_window.placement.location.
               coordinates[3]));
      wr2: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY;



  ENTITY camera_model_d3_with_hlhsr
    SUBTYPE OF (camera_model_d3);
      hidden_line_surface_removal : BOOLEAN;
  END_ENTITY;



  ENTITY camera_usage
    SUBTYPE OF (representation_map);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.PRESENTATION_REPRESENTATION' IN 
               TYPEOF(SELF\representation_map.mapped_representation)));
      wr2: ('SMCH_PLUS_203_SCHEMA.CAMERA_MODEL' IN TYPEOF(SELF\

               representation_map.mapping_origin));
  END_ENTITY;



  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY;



  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (
              CARTESIAN_TRANSFORMATION_OPERATOR_2D,
              CARTESIAN_TRANSFORMATION_OPERATOR_3D))
  SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY;



  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF (cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := base_axis(2,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,?);
    WHERE
      wr1: (SELF\cartesian_transformation_operator.dim = 2);
  END_ENTITY;



  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\cartesian_transformation_operator.dim = 3);
  END_ENTITY;



  ENTITY cc_design_approval
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approved_item;
  END_ENTITY;



  ENTITY cc_design_certification
    SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certified_item;
  END_ENTITY;



  ENTITY cc_design_contract
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contracted_item;
  END_ENTITY;



  ENTITY cc_design_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_time_item;
    WHERE
      wr1: cc_design_date_time_correlation(SELF);
  END_ENTITY;



  ENTITY cc_design_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_organization_item;
    WHERE
      wr1: cc_design_person_and_organization_correlation(SELF);
  END_ENTITY;



  ENTITY cc_design_security_classification
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF classified_item;
  END_ENTITY;



  ENTITY cc_design_specification_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF specified_item;
  END_ENTITY;



  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY;



  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
      assigned_certification : certification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY certification_type;
      description : label;
  END_ENTITY;



  ENTITY change
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
  END_ENTITY;



  ENTITY change_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF change_request_item;
  END_ENTITY;



  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY;



  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY;



  ENTITY colour;
  END_ENTITY;



  ENTITY colour_rgb
    SUBTYPE OF (colour_specification);
      red   : REAL;
      green : REAL;
      blue  : REAL;
    WHERE
      wr1: ((0 <= red) AND (red <= 1));
      wr2: ((0 <= green) AND (green <= 1));
      wr3: ((0 <= blue) AND (blue <= 1));
  END_ENTITY;



  ENTITY colour_specification
    SUBTYPE OF (colour);
      name : label;
  END_ENTITY;



  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY;



  ENTITY composite_curve_on_surface
    SUPERTYPE OF (
              BOUNDARY_CURVE)
  SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY;



  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));

  END_ENTITY;



  ENTITY composite_text
    SUBTYPE OF (geometric_representation_item);
      collected_text : SET [2:?] OF text_or_character;
    WHERE
      wr1: acyclic_composite_text(SELF,SELF.collected_text);
  END_ENTITY;



  ENTITY composite_text_with_associated_curves
    SUBTYPE OF (composite_text);
      associated_curves : SET [1:?] OF curve;
  END_ENTITY;



  ENTITY composite_text_with_blanking_box
    SUBTYPE OF (composite_text);
      blanking : planar_box;
  END_ENTITY;



  ENTITY configuration_design;
      configuration : configuration_item;
      design        : configuration_design_item;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    UNIQUE
      ur1 : configuration, design;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY configuration_effectivity
    SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
    UNIQUE
      ur1 : configuration, usage, id;
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF\

               product_definition_effectivity.usage));
  END_ENTITY;



  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
  END_ENTITY;



  ENTITY conic
    SUPERTYPE OF (ONEOF (
              CIRCLE,
              ELLIPSE,
              HYPERBOLA,
              PARABOLA))
  SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY;



  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY;



  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY;



  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (
              CLOSED_SHELL,
              OPEN_SHELL))
  SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY;



  ENTITY context_dependent_over_riding_styled_item
    SUBTYPE OF (over_riding_styled_item);
      style_context : SET [1:2] OF style_context_select;
    WHERE
      wr1: ((SIZEOF(QUERY ( sc <* SELF.style_context | (
               'SMCH_PLUS_203_SCHEMA.REPRESENTATION' IN TYPEOF(sc)) )) = 1) 
               AND (SIZEOF(QUERY ( sc <* SELF.style_context | (
               'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(sc)) )) 

               = 1));
  END_ENTITY;



  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN 
               TYPEOF(SELF.represented_product_relation.definition));
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr3: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY;



  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY;



  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY contract_type;
      description : label;
  END_ENTITY;



  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY;



  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset <= 12));
      wr2: ((0 <= minute_offset) AND (minute_offset <= 59));
      wr3: (NOT ((hour_offset <> 0) AND (sense = exact)));
  END_ENTITY;



  ENTITY curve
    SUPERTYPE OF (ONEOF (
              LINE,
              CONIC,
              PCURVE,
              SURFACE_CURVE,
              OFFSET_CURVE_2D,
              OFFSET_CURVE_3D,
              CURVE_REPLICA))
  SUBTYPE OF (geometric_representation_item);
  END_ENTITY;



  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF surface_boundary;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: (NOT (implicit_outer AND (
               'SMCH_PLUS_203_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               boundaries))));
      wr2: ((NOT implicit_outer) OR ('SMCH_PLUS_203_SCHEMA.BOUNDED_SURFACE' 
               IN TYPEOF(basis_surface)));
      wr3: (SIZEOF(QUERY ( temp <* boundaries | (
               'SMCH_PLUS_203_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)) )) 
               <= 1);
      wr4: (SIZEOF(QUERY ( temp <* QUERY ( bndc <* boundaries | (
               'SMCH_PLUS_203_SCHEMA.BOUNDARY_CURVE' IN TYPEOF(bndc)) ) | (

               temp\composite_curve_on_surface.basis_surface[1] <> SELF.
               basis_surface) )) = 0);
  END_ENTITY;



  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY;



  ENTITY curve_style;
      name         : label;
      curve_font   : curve_font_or_scaled_curve_font_select;
      curve_width  : size_select;
      curve_colour : colour;
  END_ENTITY;



  ENTITY curve_style_font;
      name         : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
  END_ENTITY;



  ENTITY curve_style_font_pattern;
      visible_segment_length   : positive_length_measure;
      invisible_segment_length : positive_length_measure;
  END_ENTITY;



  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY;



  ENTITY date
    SUPERTYPE OF (ONEOF (
              CALENDAR_DATE,
              ORDINAL_DATE,
              WEEK_OF_YEAR_AND_DAY_DATE));
      year_component : year_number;
  END_ENTITY;



  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY;



  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY;



  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
      effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
      effectivity_start_date : date_time_or_event_occurrence;
  END_ENTITY;



  ENTITY defined_symbol
    SUBTYPE OF (geometric_representation_item);
      definition : defined_symbol_select;
      target     : symbol_target;
  END_ENTITY;



  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN 

               TYPEOF(SELF\representation.context_of_items));
  END_ENTITY;



  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\

               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY;



  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY;



  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY;



  ENTITY design_context
    SUBTYPE OF (product_definition_context);
    WHERE
      wr1: (SELF.life_cycle_stage = 'design');
  END_ENTITY;



  ENTITY design_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;



  ENTITY dimension_callout_relationship
    SUBTYPE OF (draughting_callout_relationship);
    WHERE
      wr1: (SELF.name IN ['primary','secondary']);
      wr2: (SIZEOF(TYPEOF(SELF.relating_draughting_callout) * [
               'ASSOC_DIM.LEADER_DIRECTED_DIMENSION',
               'ASSOC_DIM.LINEAR_DIMENSION']) = 1);
      wr3: (SIZEOF(TYPEOF(SELF.related_draughting_callout) * [
               'ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT',
               'ASSOC_DIM.LEADER_DIRECTED_CALLOUT']) = 0);
      wr4: ((SELF.related_draughting_callout.contents * SELF.
               relating_draughting_callout.contents) = SELF.
               related_draughting_callout.contents);
  END_ENTITY;



  ENTITY dimension_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      wr1: (SIZEOF(QUERY ( dct <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | ((
               'SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN 
               TYPEOF(dct)) )) <= 2);
      wr2: (SIZEOF(QUERY ( dcdc <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DRAUGHTING_CALLOUT.CONTENTS') | (('SMCH_PLUS_203_SCHEMA.' + 
               'DIMENSION_CURVE_DIRECTED_CALLOUT') IN TYPEOF(dcdc)) )) >= 1);
      wr3: ((SIZEOF(QUERY ( dct1 <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | (((
               'SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN 
               TYPEOF(dct1)) AND (dct1.role = origin)) )) <= 1) AND (
               SIZEOF(QUERY ( dct2 <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | (((
               'SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN 

               TYPEOF(dct2)) AND (dct2.role = target)) )) <= 1));
  END_ENTITY;



  ENTITY dimension_curve_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: (SIZEOF(QUERY ( d_c <* SELF\draughting_callout.contents | (
               'SMCH_PLUS_203_SCHEMA.DIMENSION_CURVE' IN TYPEOF(d_c)) )) = 1);

      wr2: (SIZEOF(SELF\draughting_callout.contents) >= 2);
  END_ENTITY;



  ENTITY dimension_curve_terminator
    SUBTYPE OF (terminator_symbol);
      role : dimension_extent_usage;
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.DIMENSION_CURVE' IN TYPEOF(SELF\

               terminator_symbol.annotated_curve));
  END_ENTITY;



  ENTITY dimension_text_associativity
    SUBTYPE OF (text_literal, mapped_item);
    WHERE
      wr1: ('ASSOC_DIM.SHAPE_DIMENSION_REPRESENTATION' IN TYPEOF(SELF\
               mapped_item.mapping_source.mapped_representation));
      wr2: ('ASSOC_DIM.DRAUGHTING_CALLOUT' IN TYPEOF(SELF\mapped_item.
               mapping_target));
      wr3: (SIZEOF(QUERY ( ato <* QUERY ( si <* USEDIN(SELF,
               'ASSOC_DIM.STYLED_ITEM.ITEM') | (
               'ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(si)) ) | (
               NOT (SIZEOF(QUERY ( dc <* USEDIN(ato,
               'ASSOC_DIM.DRAUGHTING_CALLOUT.' + 'CONTENTS') | (
               'ASSOC_DIM.DRAUGHTING_CALLOUT' IN TYPEOF(dc)) ) * [SELF\
               mapped_item.mapping_target]) = 1)) )) = 0);
  END_ENTITY;



  ENTITY dimensional_characteristic_representation;
      dimension      : dimensional_characteristic;
      representation : shape_dimension_representation;
  END_ENTITY;



  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY;



  ENTITY dimensional_location
    SUBTYPE OF (shape_aspect_relationship);
  END_ENTITY;



  ENTITY directed_action
    SUBTYPE OF (executed_action);
      directive : action_directive;
  END_ENTITY;



  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY;



  ENTITY document;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      kind        : document_type;
    INVERSE
      representation_type : SET [0:?] OF document_representation_type FOR 
                               represented_document;
  END_ENTITY;



  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY document_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_document : document;
      related_document  : document;
  END_ENTITY;



  ENTITY document_representation_type;
      name                 : label;
      represented_document : document;
  END_ENTITY;



  ENTITY document_type;
      product_data_type : label;
  END_ENTITY;



  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY;



  ENTITY document_with_class
    SUBTYPE OF (document);
      class : identifier;
  END_ENTITY;



  ENTITY draughting_annotation_occurrence
    SUBTYPE OF (annotation_occurrence);
    WHERE
      wr1 : ((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sty.styles[1])))) )) 
                = 0));
      wr3 : ((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_FILL_AREA_OCCURRENCE' 
                IN TYPEOF(SELF))) OR (SIZEOF(QUERY ( bound <* SELF.item\
                annotation_fill_area.boundaries | (NOT (SIZEOF(
                QUERY ( si <* USEDIN(bound,'SMCH_PLUS_203_SCHEMA.' + 
                'STYLED_ITEM.ITEM') | (('SMCH_PLUS_203_SCHEMA.' + 
                'ANNOTATION_CURVE_OCCURRENCE') IN TYPEOF(si)) )) > 0)) )) =
                 0));
      wr4 : ((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL_OCCURRENCE' IN 
                TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (SIZEOF(TYPEOF(sty.styles
                [1]) * ['SMCH_PLUS_203_SCHEMA.SYMBOL_STYLE',
                'SMCH_PLUS_203_SCHEMA.NULL_STYLE']) = 1))) )) = 0));
      wr5 : ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.' 
                + 'DRAUGHTING_SYMBOL_REPRESENTATION','SMCH_PLUS_203_SCHEMA.' 
                + 'DRAUGHTING_SUBFIGURE_REPRESENTATION'] * TYPEOF(SELF.item
                \mapped_item.mapping_source.mapped_representation)) = 1));
      wr6 : ((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF))) OR (SIZEOF(QUERY ( sty <* SELF.styles | (
                NOT ((SIZEOF(sty.styles) = 1) AND (
                'SMCH_PLUS_203_SCHEMA.TEXT_STYLE' IN TYPEOF(sty.styles[1])))) )) 
                = 0));
      wr7 : (NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF.item) * [
                'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT',
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL']) = 1)));
      wr8 : ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* SELF.item\
                composite_text.collected_text | (NOT (
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(tl))) )) = 0));
      wr9 : ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN 
                TYPEOF(SELF.item)))) OR (SELF.item\text_literal.alignment 
                IN ['baseline left','baseline centre','baseline right']));
      wr10: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text)) ) | (
                NOT (tl\text_literal.alignment IN ['baseline left',
                'baseline centre','baseline right'])) )) = 0));
      wr11: (NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN 
                TYPEOF(SELF.item)) AND EXISTS(SELF.item\text_literal.
                placement.ref_direction)));
      wr12: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text)) ) | 
                EXISTS(tl\text_literal.placement.ref_direction) )) = 0));
      wr13: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR check_text_alignment(SELF.item));
      wr14: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR check_text_font(SELF.item));
      wr15: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN 
                TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( tl <* 
                QUERY ( text <* SELF.item\composite_text.collected_text | (
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text)) ) | (
                NOT (SIZEOF(TYPEOF(tl) * ['SMCH_PLUS_203_SCHEMA.' + 
                'TEXT_LITERAL_WITH_BLANKING_BOX','SMCH_PLUS_203_SCHEMA.' + 
                'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0)) )) = 0));
      wr16: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND (
                'SMCH_PLUS_203_SCHEMA.TEXT_LITERAL_WITH_ASSOCIATED_CURVES' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( crv <* SELF.item
                \text_literal_with_associated_curves.associated_curves | (
                NOT (SIZEOF(QUERY ( si <* USEDIN(crv,'SMCH_PLUS_203_SCHEMA.' 
                + 'STYLED_ITEM.ITEM') | (
                'SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(si)) )) > 0)) )) = 0));
      wr17: ((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN 
                TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES' 
                IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY ( crv <* SELF.item
                \composite_text_with_associated_curves.associated_curves | 
                (NOT (SIZEOF(QUERY ( si <* USEDIN(crv,
                'SMCH_PLUS_203_SCHEMA.' + 'STYLED_ITEM.ITEM') | (
                'SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN 
                TYPEOF(si)) )) > 0)) )) = 0));
      wr18: (SIZEOF(QUERY ( cs <* QUERY ( sty <* SELF.styles | (
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sty.styles[1])) )
                 | (NOT (('SMCH_PLUS_203_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN
                 TYPEOF(cs.styles[1]\curve_style.curve_width)) AND (
                'SMCH_PLUS_203_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(cs.

                styles[1]\curve_style.curve_width\measure_with_unit.
                value_component)))) )) = 0);
      wr21: (SIZEOF(QUERY ( ts <* QUERY ( sty <* SELF.styles | (
                'AUTOMOTIVE_DESIGN.TEXT_STYLE' IN TYPEOF(sty.styles[1])) )
                 | (NOT (
                'AUTOMOTIVE_DESIGN.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' IN 
                TYPEOF(ts.styles[1]))) )) = 0);
      wr22: (SIZEOF(QUERY ( ts <* QUERY ( sty <* SELF.styles | (
                'AUTOMOTIVE_DESIGN.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' IN 
                TYPEOF(sty.styles[1])) ) | (NOT (SIZEOF(ts.styles[1]\
                text_style_with_box_characteristics.characteristics) = 4)) )) 
                = 0);
  END_ENTITY;



  ENTITY draughting_callout
    SUBTYPE OF (geometric_representation_item);
      contents : SET [1:?] OF draughting_callout_element;
  END_ENTITY;



  ENTITY draughting_callout_relationship;
      name                        : label;
      description                 : text;
      relating_draughting_callout : draughting_callout;
      related_draughting_callout  : draughting_callout;
  END_ENTITY;



  ENTITY draughting_elements
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: (SIZEOF(QUERY ( l_c <* QUERY ( con <* SELF.contents | (
               'ASSOC_DIM.LEADER_CURVE' IN TYPEOF(con)) ) | (NOT (SIZEOF(
               QUERY ( ldc <* USEDIN(l_c,'ASSOC_DIM.' + 
               'DRAUGHTING_CALLOUT.CONTENTS') | (
               'ASSOC_DIM.LEADER_DIRECTED_CALLOUT' IN TYPEOF(ldc)) )) <= 1)) )) 
               = 0);
      wr2: ((NOT ('ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(
               SELF))) OR (SIZEOF(QUERY ( con <* SELF.contents | (
               'ASSOC_DIM.PROJECTION_CURVE' IN TYPEOF(con)) )) <= 2));
  END_ENTITY;



  ENTITY draughting_model
    SUBTYPE OF (representation);
    UNIQUE
      ur1 : name;
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.STYLED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT',
               'SMCH_PLUS_203_SCHEMA.CAMERA_MODEL'] * TYPEOF(it)) = 1)) )) =
                0);
      wr2: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT (
               SIZEOF(['SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION',
               'SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL'] * TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation)) = 1)) )) 
               = 0);
      wr3: (SIZEOF(QUERY ( smi <* QUERY ( si <* QUERY ( it <* SELF.items
                | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(si\styled_item.
               item)) ) | (NOT (('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' 
               IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source.
               mapped_representation)) AND (SIZEOF(QUERY ( sty <* smi\
               styled_item.styles | (NOT (SIZEOF(QUERY ( psa <* sty.styles
                | (NOT ('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(psa))) )) 

               = 1)) )) = 1))) )) = 0);
  END_ENTITY;



  ENTITY draughting_pre_defined_colour
    SUBTYPE OF (pre_defined_colour);
    WHERE
      wr1: (SELF.name IN ['red','green','blue','yellow','magenta','cyan',
               'black','white']);
  END_ENTITY;



  ENTITY draughting_pre_defined_curve_font
    SUBTYPE OF (pre_defined_curve_font);
    WHERE
      wr1: (SELF.name IN ['continuous','chain','chain double dash',
               'dashed','dotted']);
  END_ENTITY;



  ENTITY draughting_pre_defined_text_font
    SUBTYPE OF (pre_defined_text_font);
    WHERE
      wr1: (SELF.name IN ['ISO 3098-1 font A','ISO 3098-1 font B']);
  END_ENTITY;



  ENTITY draughting_title;
      items    : SET [1:?] OF draughting_titled_item;
      language : label;
      contents : text;
  END_ENTITY;



  ENTITY drawing_definition;
      drawing_number : identifier;
      drawing_type   : OPTIONAL label;
  END_ENTITY;



  ENTITY drawing_revision
    SUBTYPE OF (presentation_set);
      revision_identifier : identifier;
      drawing_identifier  : drawing_definition;
      intended_scale      : OPTIONAL text;
    UNIQUE
      ur1 : revision_identifier, drawing_identifier;
  END_ENTITY;



  ENTITY drawing_sheet_revision
    SUBTYPE OF (presentation_area);
      revision_identifier : identifier;
    WHERE
      wr1: (SIZEOF(QUERY ( item <* SELF\representation.items | ((
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) AND (
               'SMCH_PLUS_203_SCHEMA.DRAWING_SHEET_REVISION' IN TYPEOF(item\

               mapped_item.mapping_source.mapped_representation))) )) = 0);
  END_ENTITY;



  ENTITY drawing_sheet_revision_usage
    SUBTYPE OF (area_in_set);
      sheet_number : identifier;
    UNIQUE
      ur1 : sheet_number, in_set;
    WHERE
      wr1: (('SMCH_PLUS_203_SCHEMA.DRAWING_SHEET_REVISION' IN TYPEOF(SELF\
               area_in_set.area)) AND (
               'SMCH_PLUS_203_SCHEMA.DRAWING_REVISION' IN TYPEOF(SELF\

               area_in_set.in_set)));
  END_ENTITY;



  ENTITY edge
    SUPERTYPE OF (ONEOF (
              EDGE_CURVE,
              ORIENTED_EDGE))
  SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY;



  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY;



  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (SIZEOF(
               ['SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >= 
               1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               'SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(edges))) )) = 0)) )) 
               = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
               'SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(edges\edge_curve.
               edge_geometry)) ) | (NOT (SIZEOF(pline_edges\edge_curve.
               edge_geometry\polyline.points) > 2)) )) = 0)) )) = 0)) )) = 
               0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ((
               'SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(edges.
               edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN 
               TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT 
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry,
               'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry,'CONFIG_CONTROL_DESIGN') AND 
               valid_wireframe_vertex_point(edges.edge_end\vertex_point.
               vertex_geometry,'CONFIG_CONTROL_DESIGN'))) )) = 0)) )) = 0)) )) 
               = 0);
      wr8: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( con_edges <* QUERY ( edges <* eb.ces_edges | (
               'SMCH_PLUS_203_SCHEMA.CONIC' IN TYPEOF(edges\edge_curve.
               edge_geometry)) ) | (NOT (
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(con_edges
               \edge_curve.edge_geometry\conic.position))) )) = 0)) )) = 0)) )) 
               = 0);
      wr9: (SIZEOF(QUERY ( mi <* QUERY ( item <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('SMCH_PLUS_203_SCHEMA.' + 

               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
  END_ENTITY;



  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY;



  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY;



  ENTITY effectivity
    SUPERTYPE OF (ONEOF (
              SERIAL_NUMBERED_EFFECTIVITY,
              DATED_EFFECTIVITY,
              LOT_EFFECTIVITY));
      id : identifier;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (
              PLANE,
              CYLINDRICAL_SURFACE,
              CONICAL_SURFACE,
              SPHERICAL_SURFACE,
              TOROIDAL_SURFACE))
  SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY;



  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY;



  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY;



  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY;



  ENTITY external_source;
      source_id : source_item;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY externally_defined_colour
    SUBTYPE OF (colour_specification, externally_defined_item);
  END_ENTITY;



  ENTITY externally_defined_curve_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;



  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY;



  ENTITY externally_defined_marker
    SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
  END_ENTITY;



  ENTITY externally_defined_symbol
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;



  ENTITY externally_defined_terminator_symbol
    SUBTYPE OF (externally_defined_symbol);
  END_ENTITY;



  ENTITY face
    SUPERTYPE OF (ONEOF (
              FACE_SURFACE,
              ORIENTED_FACE))
  SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | (
               'SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 

               <= 1);
  END_ENTITY;



  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY;



  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY;



  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY;



  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY;



  ENTITY faceted_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* items | (NOT (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( it <* items | (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP' IN TYPEOF(it)) ) | (NOT (
               SIZEOF(QUERY ( csh <* msb_shells(fbrep,
               'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN 
               TYPEOF(fcs)) AND ('SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(fcs\
               face_surface.face_geometry)) AND (
               'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT' IN TYPEOF(fcs\
               face_surface.face_geometry\plane.position.location)))) )) = 
               0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP' IN TYPEOF(it)) ) | (NOT (
               SIZEOF(QUERY ( csh <* msb_shells(fbrep,
               'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY ( fcs <* csh.
               cfs_faces | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (
               'SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)) )) =
                1)) )) = 0)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               msb\manifold_solid_brep.outer)) )) = 0);
      wr6: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT (
               'SMCH_PLUS_203_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION' IN 

               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
  END_ENTITY;



  ENTITY fill_area_style;
      name        : label;
      fill_styles : SET [1:?] OF fill_style_select;
    WHERE
      wr1: (SIZEOF(QUERY ( fill_style <* SELF.fill_styles | ((
               'SMCH_PLUS_203_SCHEMA.' + 'FILL_AREA_STYLE_COLOUR') IN 

               TYPEOF(fill_style)) )) <= 1);
  END_ENTITY;



  ENTITY fill_area_style_colour;
      name        : label;
      fill_colour : colour;
  END_ENTITY;



  ENTITY founded_item;
  END_ENTITY;



  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(temp)) )) = 0);

  END_ENTITY;



  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY;



  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR,
              CURVE,
              SURFACE,
              EDGE_CURVE,
              FACE_SURFACE,
              POLY_LOOP,
              VERTEX_POINT,
              SOLID_MODEL,
              SHELL_BASED_SURFACE_MODEL,
              SHELL_BASED_WIREFRAME_MODEL,
              EDGE_BASED_WIREFRAME_MODEL,
              GEOMETRIC_SET))
  SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' 

               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY;



  ENTITY geometric_set
    SUPERTYPE OF (
              GEOMETRIC_CURVE_SET)
  SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY;



  ENTITY geometrically_bounded_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* items | (NOT (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( it <* items | (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) > 0);
      wr3: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT ((
               'SMCH_PLUS_203_SCHEMA.' + 
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN 
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0);
      wr4: (SIZEOF(QUERY ( gs <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it)) ) | (NOT 
               (SIZEOF(QUERY ( pnt <* QUERY ( gsel <* gs\geometric_set.
               elements | ('SMCH_PLUS_203_SCHEMA.POINT' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_point(pnt,'CONFIG_CONTROL_DESIGN')) )) = 
               0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gs <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it)) ) | (NOT 
               (SIZEOF(QUERY ( cv <* QUERY ( gsel <* gs\geometric_set.
               elements | ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_curve(cv,'CONFIG_CONTROL_DESIGN')) )) = 0)) )) 
               = 0);
      wr6: (SIZEOF(QUERY ( gs <* QUERY ( it <* items | (
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it)) ) | (NOT 
               (SIZEOF(QUERY ( sf <* QUERY ( gsel <* gs\geometric_set.
               elements | ('SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(gsel)) )

                | (NOT gbsf_check_surface(sf,'CONFIG_CONTROL_DESIGN')) )) =
                0)) )) = 0);
  END_ENTITY;



  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (SIZEOF(
               ['SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
               = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET',
               'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >= 
               1);
      wr3: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( elem <* gcs\geometric_set.elements
                | (NOT valid_geometrically_bounded_wf_curve(elem,
               'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pnts <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.POINT' IN 
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_point(
               pnts,'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( cnc <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.CONIC' IN 
               TYPEOF(elem)) ) | (NOT (
               'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\conic
               .position))) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pline <* QUERY ( elem <* gcs\
               geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN 
               TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points) > 2)) )) 
               = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( item <* SELF\representation.items
                | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('SMCH_PLUS_203_SCHEMA.' + 

               'GEOMETRICALLY_BOUNDED_WIREFRAME_REPRESENTATION') IN TYPEOF(
               mi\mapped_item.mapping_source.mapped_representation))) )) = 
               0);
  END_ENTITY;



  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;



  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY;



  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY;



  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY;



  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY;



  ENTITY invisibility;
      invisible_items : SET [1:?] OF invisible_item;
  END_ENTITY;



  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY;



  ENTITY leader_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      wr1: (SIZEOF(QUERY ( ldc <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DRAUGHTING_CALLOUT.CONTENTS') | (('SMCH_PLUS_203_SCHEMA.' + 

               'LEADER_DIRECTED_CALLOUT') IN TYPEOF(ldc)) )) >= 1);
  END_ENTITY;



  ENTITY leader_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: (SIZEOF(QUERY ( l_1 <* SELF\draughting_callout.contents | (
               'SMCH_PLUS_203_SCHEMA.LEADER_CURVE' IN TYPEOF(l_1)) )) >= 1);

      wr2: (SIZEOF(SELF\draughting_callout.contents) >= 2);
  END_ENTITY;



  ENTITY leader_directed_dimension
    SUBTYPE OF (leader_directed_callout);
    WHERE
      wr1: (SIZEOF(QUERY ( con <* SELF.contents | (
               'ASSOC_DIM.LEADER_CURVE' IN TYPEOF(con)) )) = 1);
  END_ENTITY;



  ENTITY leader_terminator
    SUBTYPE OF (terminator_symbol);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.LEADER_CURVE' IN TYPEOF(SELF\

               terminator_symbol.annotated_curve));
  END_ENTITY;



  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY;



  ENTITY linear_dimension
    SUBTYPE OF (dimension_curve_directed_callout);
  END_ENTITY;



  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY;



  ENTITY loop
    SUPERTYPE OF (ONEOF (
              VERTEX_LOOP,
              EDGE_LOOP,
              POLY_LOOP))
  SUBTYPE OF (topological_representation_item);
  END_ENTITY;



  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY;



  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY;



  ENTITY manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* items | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL',
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
                'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
                = 0);
      wr2 : (SIZEOF(QUERY ( it <* items | (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL',
                'SMCH_PLUS_203_SCHEMA.MAPPED ITEM'] * TYPEOF(it)) = 1) )) > 
                0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.MAPPED ITEM' IN TYPEOF(it)) ) | (NOT ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' 
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation))) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( sh <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.OPEN_SHELL',
                'SMCH_PLUS_203_SCHEMA.CLOSED_SHELL'] * TYPEOF(sh)) = 1)) )) 
                = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.FACE_SURFACE',
                'SMCH_PLUS_203_SCHEMA.ORIENTED_FACE'] * TYPEOF(fa)) = 1)) )) 
                = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (
                'SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) ) | (NOT 
                (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.OFFSET_SURFACE',
                'SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA'] * TYPEOF(f_sf\
                face_surface.face_geometry)) = 1))) )) = 0)) )) = 0)) )) = 
                0);
      wr7 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                basis_surface_check(fa\face_surface.face_geometry,
                'CONFIG_CONTROL_DESIGN'))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP',
                'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnds.bound)) = 
                1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds)) ) | (NOT (
                SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | (NOT 
                ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SMCH_PLUS_203_SCHEMA.EDGE LOOP' IN TYPEOF(bnds.bound)) ) | 
                (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* elp_fbnds.bound
                \path.edge_list | ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA',
                'SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D',
                'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | 
                (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list
                 | (NOT basis_curve_check(oe.edge_element\edge_curve.
                edge_geometry,'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0))) )) 
                = 0)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds)) ) | (NOT (
                SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list | (NOT 
                (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 
                0)) )) = 0);
      wr13: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* items | (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(
                it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) ) | 
                (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.edge_list
                 | (NOT ((SIZEOF(['SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT',
                'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE',
                'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE',
                'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1) 
                AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT',
                'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE',
                'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE',
                'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.

                edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY;



  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY;



  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY;



  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY;



  ENTITY mechanical_context
    SUBTYPE OF (product_context);
    WHERE
      wr1: (SELF.discipline_type = 'mechanical');
  END_ENTITY;



  ENTITY mechanical_design_geometric_presentation_representation
    SUBTYPE OF (representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM',
                'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT'] * TYPEOF(it)) = 1)) )) 
                = 0);
      wr2 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION',
                'SMCH_PLUS_203_SCHEMA.' + 
                'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'] 
                * TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation)) = 1)) )) = 0);
      wr3 : (SIZEOF(QUERY ( smi <* QUERY ( si <* QUERY ( it <* SELF.items
                 | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(si\styled_item.
                item)) ) | (NOT ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' 
                IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source.
                mapped_representation))) )) = 0);
      wr4 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( pss <* psa.styles | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.POINT_STYLE',
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE',
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE'] * TYPEOF(pss)) =
                 1)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psbc <* QUERY ( psa <* si\styled_item.styles
                 | (('SMCH_PLUS_203_SCHEMA.' + 
                'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(psa)) ) | (NOT (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM',
                'SMCH_PLUS_203_SCHEMA.REPRESENTATION'] * TYPEOF(psbc\
                presentation_style_by_context.style_context)) = 1)) )) = 0)) )) 
                = 0);
      wr6 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ps <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.POINT_STYLE' IN TYPEOF(pss)) ) | (NOT 
                ((('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN 
                TYPEOF(ps\point_style.marker_size)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(ps\point_style.
                marker_colour)) = 1))) )) = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( cs <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(pss)) ) | (NOT 
                ((SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB',
                'SMCH_PLUS_203_SCHEMA.' + 'DRAUGHTING_PRE_DEFINED_COLOUR'] *
                 TYPEOF(cs\curve_style.curve_colour)) = 1) AND ((
                'SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN 
                TYPEOF(cs\curve_style.curve_width)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(cs\
                curve_style.curve_font)) = 1))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_SIDE_STYLE') IN
                 TYPEOF(ssu\surface_style_usage.style))) )) = 0)) )) = 0)) )) 
                = 0);
      wr9 : (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( sses <* ssu\surface_style_usage.
                style\surface_side_style.styles | (NOT (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_PARAMETER_LINE',
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_CONTROL_GRID',
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SILHOUETTE',
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SEGMENTATION_CURVE',
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_FILL_AREA',
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_BOUNDARY'] * 
                TYPEOF(sses)) = 1)) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( sspl <* QUERY ( sses <* ssu\
                surface_style_usage.style\surface_side_style.styles | ((
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_PARAMETER_LINE') IN
                 TYPEOF(sses)) ) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' 
                IN TYPEOF(sspl\surface_style_parameter_line.
                style_of_parameter_lines)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sspl\
                surface_style_parameter_line.style_of_parameter_lines\
                curve_style.curve_colour)) = 1) AND ((
                'SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN 
                TYPEOF(sspl\surface_style_parameter_line.
                style_of_parameter_lines\curve_style.curve_width)) AND (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sspl\
                surface_style_parameter_line.style_of_parameter_lines\
                curve_style.curve_font)) = 1))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr11: (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( sscg <* QUERY ( sses <* ssu\
                surface_style_usage.style\surface_side_style.styles | ((
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_CONTROL_GRID') IN 
                TYPEOF(sses)) ) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' 
                IN TYPEOF(sscg\surface_style_control_grid.
                style_of_control_grid)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sscg\
                surface_style_control_grid.style_of_control_grid\
                curve_style.curve_colour)) = 1) AND ((
                'SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN 
                TYPEOF(sscg\surface_style_control_grid.
                style_of_control_grid\curve_style.curve_width)) AND (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sscg\
                surface_style_control_grid.style_of_control_grid\
                curve_style.curve_font)) = 1))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0);
      wr12: (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( sssh <* QUERY ( sses <* ssu\
                surface_style_usage.style\surface_side_style.styles | ((
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SILHOUETTE') IN 
                TYPEOF(sses)) ) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' 
                IN TYPEOF(sssh\surface_style_silhouette.style_of_silhouette)) 
                AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB',
                'SMCH_PLUS_203_SCHEMA.' + 'DRAUGHTING_PRE_DEFINED_COLOUR'] *
                 TYPEOF(sssh\surface_style_silhouette.style_of_silhouette\
                curve_style.curve_colour)) = 1) AND ((
                'SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN 
                TYPEOF(sssh\surface_style_silhouette.style_of_silhouette\
                curve_style.curve_width)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sssh\
                surface_style_silhouette.style_of_silhouette\curve_style.
                curve_font)) = 1))) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( sssc <* QUERY ( sses <* ssu\
                surface_style_usage.style\surface_side_style.styles | ((
                'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SEGMENTATION_CURVE') 
                IN TYPEOF(sses)) ) | (NOT ((
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sssc\
                surface_style_segmentation_curve.
                style_of_segmentation_curve)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sssc\
                surface_style_segmentation_curve.
                style_of_segmentation_curve\curve_style.curve_colour)) = 1) 
                AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') 
                IN TYPEOF(sssc\surface_style_segmentation_curve.
                style_of_segmentation_curve\curve_style.curve_width)) AND (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sssc\
                surface_style_segmentation_curve.
                style_of_segmentation_curve\curve_style.curve_font)) = 1))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0);
      wr14: (SIZEOF(QUERY ( si <* QUERY ( it <* SELF.items | (
                'SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it)) ) | (NOT (
                SIZEOF(QUERY ( psa <* si\styled_item.styles | (NOT (SIZEOF(
                QUERY ( ssu <* QUERY ( pss <* psa.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)) )
                 | (NOT (SIZEOF(QUERY ( ssbd <* QUERY ( sses <* ssu\
                surface_style_usage.style\surface_side_style.styles | (
                'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) )
                 | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(ssbd\
                surface_style_boundary.style_of_boundary)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 
                'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(ssbd\
                surface_style_boundary.style_of_boundary\curve_style.
                curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 
                'POSITIVE_LENGTH_MEASURE') IN TYPEOF(ssbd\
                surface_style_boundary.style_of_boundary\curve_style.
                curve_width)) AND (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT',
                'SMCH_PLUS_203_SCHEMA.' + 

                'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(ssbd\
                surface_style_boundary.style_of_boundary\curve_style.
                curve_font)) = 1))) )) = 0)) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY;



  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY;



  ENTITY named_unit
    SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT));
      dimensions : dimensional_exponents;
  END_ENTITY;



  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY;



  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY offset_curve_2d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      wr1: (basis_curve.dim = 2);
  END_ENTITY;



  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : BOOLEAN;  --BA LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY;



  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : BOOLEAN; --BA LOGICAL;
  END_ENTITY;



  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY;



  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366)));
  END_ENTITY;



  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY organization_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY;



  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY;



  ENTITY organizational_project;
      name                      : label;
      description               : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(

               SELF.closed_shell_element)));
  END_ENTITY;



  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.

               edge_element)));
  END_ENTITY;



  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.

               face_element)));
  END_ENTITY;



  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.

               open_shell_element)));
  END_ENTITY;



  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.

               path_element)));
  END_ENTITY;



  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY;



  ENTITY over_riding_styled_item
    SUBTYPE OF (styled_item);
      over_ridden_style : styled_item;
  END_ENTITY;



  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY;



  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY;



  ENTITY path
    SUPERTYPE OF (ONEOF (
              EDGE_LOOP,
              ORIENTED_PATH))
  SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY;



  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\

               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY;



  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY;



  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY;



  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY placement
    SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT,
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY;



  ENTITY planar_box
    SUBTYPE OF (planar_extent);
      placement : axis2_placement;
  END_ENTITY;



  ENTITY planar_extent
    SUBTYPE OF (geometric_representation_item);
      size_in_x : length_measure;
      size_in_y : length_measure;
  END_ENTITY;



  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY;



  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY plus_minus_tolerance;
      range                : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
    UNIQUE
      ur1 : toleranced_dimension;
  END_ENTITY;



  ENTITY point
    SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT,
              POINT_ON_CURVE,
              POINT_ON_SURFACE,
              POINT_REPLICA,
              DEGENERATE_PCURVE))
  SUBTYPE OF (geometric_representation_item);
  END_ENTITY;



  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY;



  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY;



  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY;



  ENTITY point_style;
      name          : label;
      marker        : marker_select;
      marker_size   : size_select;
      marker_colour : colour;
  END_ENTITY;



  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY;



  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY;



  ENTITY pre_defined_colour
    SUBTYPE OF (pre_defined_item, colour);
  END_ENTITY;



  ENTITY pre_defined_curve_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;



  ENTITY pre_defined_dimension_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      wr1: (SELF.name IN ['arc length','conical taper','counterbore',
               'countersink','depth','diameter','plus minus','radius',
               'slope','spherical diameter','spherical radius','square']);
  END_ENTITY;



  ENTITY pre_defined_item;
      name : label;
  END_ENTITY;



  ENTITY pre_defined_marker
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;



  ENTITY pre_defined_symbol
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;



  ENTITY pre_defined_terminator_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      wr1: (SELF.name IN ['blanked arrow','blanked box','blanked dot',
               'dimension origin','filled arrow','filled box','filled dot',
               'integral symbol','open arrow','slash','unfilled arrow']);
  END_ENTITY;



  ENTITY pre_defined_text_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;



  ENTITY presentation_area
    SUBTYPE OF (presentation_representation);
    WHERE
      wr1: ((SIZEOF(QUERY ( ais <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'AREA_IN_SET.AREA') | (SIZEOF(USEDIN(ais,
               'SMCH_PLUS_203_SCHEMA.' + 'PRESENTATION_SIZE.UNIT')) = 1) )) 
               > 0) OR (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'PRESENTATION_SIZE.UNIT')) = 1));
  END_ENTITY;



  ENTITY presentation_layer_assignment;
      name           : label;
      description    : text;
      assigned_items : SET [1:?] OF layered_item;
  END_ENTITY;



  ENTITY presentation_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: (SELF\representation.context_of_items\
               geometric_representation_context.coordinate_space_dimension 
               = 2);
      wr2: ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN 

               TYPEOF(SELF\representation.context_of_items));
  END_ENTITY;



  ENTITY presentation_set;
    INVERSE
      areas : SET [1:?] OF area_in_set FOR in_set;
  END_ENTITY;



  ENTITY presentation_size;
      unit : presentation_size_assignment_select;
      size : planar_box;
    WHERE
      wr1: ((('SMCH_PLUS_203_SCHEMA.PRESENTATION_REPRESENTATION' IN TYPEOF(
               SELF.unit)) AND item_in_context(SELF.size,SELF.unit\
               representation.context_of_items)) OR ((
               'SMCH_PLUS_203_SCHEMA.AREA_IN_SET' IN TYPEOF(SELF.unit)) AND 

               (SIZEOF(QUERY ( ais <* SELF.unit\area_in_set.in_set.areas | 
               (NOT item_in_context(SELF.size,ais.area\representation.
               context_of_items)) )) = 0)));
  END_ENTITY;



  ENTITY presentation_style_assignment;
      styles : SET [1:?] OF presentation_style_select;
    WHERE
      wr1: (SIZEOF(QUERY ( style1 <* SELF.styles | (NOT (SIZEOF(
               QUERY ( style2 <* (SELF.styles - style1) | (NOT ((TYPEOF(
               style1) <> TYPEOF(style2)) OR (SIZEOF([
               'SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_USAGE',
               'SMCH_PLUS_203_SCHEMA.' + 'EXTERNALLY_DEFINED_STYLE'] * 
               TYPEOF(style1)) = 1))) )) = 0)) )) = 0);
      wr2: (SIZEOF(QUERY ( style1 <* SELF.styles | (
               'SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(style1)) )) 

               <= 2);
  END_ENTITY;



  ENTITY presentation_style_by_context
    SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
  END_ENTITY;



  ENTITY presentation_view
    SUBTYPE OF (presentation_representation);
  END_ENTITY;



  ENTITY presented_item
    ABSTRACT SUPERTYPE;
  END_ENTITY;



  ENTITY presented_item_representation;
      presentation : presentation_representation_select;
      item         : presented_item;
  END_ENTITY;



  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;



  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY;



  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : OPTIONAL text;
      market_context : product_concept_context;
    UNIQUE
      ur1 : id;
  END_ENTITY;



  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
      market_segment_type : label;
  END_ENTITY;



  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY;



  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY;



  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0);
  END_ENTITY;



  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY;



  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY;



  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY;



  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF\

               property_definition.definition)));
  END_ENTITY;



  ENTITY product_definition_usage
    SUPERTYPE OF (
              ASSEMBLY_COMPONENT_USAGE)
  SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],
               'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_USAGE');

  END_ENTITY;



  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY;



  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY;



  ENTITY projection_curve
    SUBTYPE OF (annotation_curve_occurrence);
  END_ENTITY;



  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY;



  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
  END_ENTITY;



  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
    WHERE
      wr1: ((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (
               quantity.value_component > 0));
  END_ENTITY;



  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY;



  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY;



  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY;



  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY;



  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: (SIZEOF(QUERY ( s <* segments | (n_v <> SIZEOF(s)) )) = 0);
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY;



  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: ((('SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
               basis_surface)) AND (NOT ('SMCH_PLUS_203_SCHEMA.PLANE' IN 
               TYPEOF(basis_surface)))) OR (
               'SMCH_PLUS_203_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(
               basis_surface)) OR (usense = (u2 > u1)));
      wr4: (('SMCH_PLUS_203_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(
               basis_surface)) OR ('SMCH_PLUS_203_SCHEMA.TOROIDAL_SURFACE' 

               IN TYPEOF(basis_surface)) OR (vsense = (v2 > v1)));
  END_ENTITY;



  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY;



  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id          : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY;



  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY;



  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY;



  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY;



  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY;



  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY;



  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY;



  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[1]));
      wr4: ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.

               associated_geometry[2]));
  END_ENTITY;



  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY;



  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 

               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY;



  ENTITY security_classification_level;
      name : label;
  END_ENTITY;



  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY;



  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY;



  ENTITY shape_aspect_associativity
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      wr1: SELF.relating_shape_aspect.product_definitional;
      wr2: (NOT SELF.related_shape_aspect.product_definitional);
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sdr <* QUERY ( pdr <* USEDIN(pd,
               'SMCH_PLUS_203_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
               'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN 
               TYPEOF(pdr)) ) | (NOT (SIZEOF(QUERY ( it <* sdr.
               used_representation.items | ((NOT (
               'SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(it))) AND ((SIZEOF(
               QUERY ( aco <* USEDIN(it,
               'SMCH_PLUS_203_SCHEMA.STYLED_ITEM.ITEM') | (SIZEOF(TYPEOF(aco) 
               * ['SMCH_PLUS_203_SCHEMA.LEADER_CURVE',
               'SMCH_PLUS_203_SCHEMA.PROJECTION_CURVE']) = 1) )) + SIZEOF(
               USEDIN(it,'SMCH_PLUS_203_SCHEMA.' + 
               'ANNOTATION_FILL_AREA.BOUNDARIES'))) >= 1)) )) = 1)) )) = 0)) )) 
               = 0);
      wr4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( sdr <* QUERY ( pdr <* USEDIN(pd,
               'SMCH_PLUS_203_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (
               'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN 

               TYPEOF(pdr)) ) | (NOT check_associative_shape_aspects(sdr)) )) 
               = 0)) )) = 0);
  END_ENTITY;



  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY;



  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF
               .definition)) OR ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION' IN 
               TYPEOF(SELF.definition.definition)));
      wr2: ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.

               used_representation));
  END_ENTITY;



  ENTITY shape_dimension_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF.items | (NOT (
               'SMCH_PLUS_203_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(

               temp))) )) = 0);
      wr2: (SIZEOF(SELF.items) <= 2);
      wr3: (SIZEOF(QUERY ( pos_mri <* QUERY ( real_mri <* SELF.items | (
               'REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)) )
                | (NOT (pos_mri\measure_with_unit.value_component > 0)) )) 
               = 0);
  END_ENTITY;



  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY;



  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\

               representation_relationship.rep_1) + TYPEOF(SELF\
               representation_relationship.rep_2)));
  END_ENTITY;



  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY;



  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY;



  ENTITY shell_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF\representation.items | (NOT (
                SIZEOF(['SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL',
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM',
                'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)) )) 
                = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF\representation.items | (SIZEOF([
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL',
                'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >=
                 1);
      wr3 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( el <* eloop\path.edge_list | (NOT (
                'SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(el.edge_element))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( pline_el <* QUERY ( el <* eloop\path.
                edge_list | ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(el.
                edge_element\edge_curve.edge_geometry)) ) | (NOT (SIZEOF(
                pline_el.edge_element\edge_curve.edge_geometry\polyline.
                points) > 2)) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( el <* eloop\path.edge_list | (NOT 
                valid_wireframe_edge_curve(el.edge_element\edge_curve.
                edge_geometry,'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0)) )) 
                = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( el <* eloop\path.edge_list | (NOT ((
                'SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_start)) AND (
                'SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_end)))) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( el <* eloop\path.edge_list | (NOT (
                valid_wireframe_vertex_point(el.edge_element.edge_start\
                vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN') AND 
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN'))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( eloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb)) ) | (NOT (
                SIZEOF(QUERY ( con_edges <* QUERY ( el <* eloop\path.
                edge_list | ('SMCH_PLUS_203_SCHEMA.CONIC' IN TYPEOF(el.
                edge_element\edge_curve.edge_geometry)) ) | (NOT (
                'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(
                con_edges.edge_element\edge_curve.edge_geometry\conic.
                position))) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( vloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(wsb)) ) | (NOT 
                ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vloop\
                vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN 
                TYPEOF(sb)) ) | (NOT (SIZEOF(QUERY ( vloop <* 
                QUERY ( wsb <* ws\wire_shell.wire_shell_extent | (
                'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(wsb)) ) | (NOT 
                valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')) )) =
                 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN 
                TYPEOF(sb)) ) | (NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex))) )) 
                = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' 
                IN TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* 
                QUERY ( sb <* sbwm\shell_based_wireframe_model.
                sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN 
                TYPEOF(sb)) ) | (NOT valid_wireframe_vertex_point(vs\
                vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry,'CONFIG_CONTROL_DESIGN')) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( mi <* QUERY ( item <* SELF\representation.
                items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) )
                 | (NOT (
                'SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_REPRESENTATION' 

                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation))) )) = 0);
  END_ENTITY;



  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(name);
  END_ENTITY;



  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY solid_model
    SUPERTYPE OF (
              MANIFOLD_SOLID_BREP)
  SUBTYPE OF (geometric_representation_item);
  END_ENTITY;



  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: ((upper_usage.related_product_definition :=: next_usage.
               relating_product_definition) OR (SIZEOF(QUERY ( pdr <* 
               USEDIN(upper_usage.related_product_definition,
               'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATED_PRODUCT_DEFINITION') | (pdr.
               relating_product_definition :=: next_usage.
               relating_product_definition) )) = 1));
      wr5: (SIZEOF(['SMCH_PLUS_203_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
               'SMCH_PLUS_203_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] * 

               TYPEOF(upper_usage)) = 1);
  END_ENTITY;



  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY;



  ENTITY start_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF start_request_item;
  END_ENTITY;



  ENTITY start_work
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
  END_ENTITY;



  ENTITY structured_dimension_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      wr1: (SIZEOF(TYPEOF(SELF) * ['ASSOC_DIM.LEADER_DIRECTED_CALLOUT',
               'ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0);
      wr2: (SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(con)) ) | (
               NOT (ato.name IN ['dimension value','tolerance value',
               'unit text','prefix text','suffix text'])) )) = 0);
      wr3: (SIZEOF(QUERY ( ato <* QUERY ( con <* SELF.contents | (
               'ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(con)) ) | (
               ato.name = 'dimension value') )) >= 1);
  END_ENTITY;



  ENTITY styled_item
    SUBTYPE OF (representation_item);
      styles : SET [1:?] OF presentation_style_assignment;
      item   : representation_item;
    WHERE
      wr1: ((SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY ( pres_style <* 
               SELF.styles | (NOT (('SMCH_PLUS_203_SCHEMA.' + 

               'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(pres_style))) )) 
               = 0));
  END_ENTITY;



  ENTITY supplied_part_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;



  ENTITY surface
    SUPERTYPE OF (ONEOF (
              ELEMENTARY_SURFACE,
              SWEPT_SURFACE,
              BOUNDED_SURFACE,
              OFFSET_SURFACE,
              SURFACE_REPLICA))
  SUBTYPE OF (geometric_representation_item);
  END_ENTITY;



  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (
              INTERSECTION_CURVE,
              SEAM_CURVE))
  SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) 
               OR (master_representation <> pcurve_s1));
      wr3: (('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) 
               OR (master_representation <> pcurve_s2));
      wr4: (NOT ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(curve_3d)));

  END_ENTITY;



  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY;



  ENTITY surface_of_revolution --BA added curve ()||

    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
(*BA    DERIVE
      axis_line : line := representation_item('') || 
        geometric_representation_item() || line(axis_position.
        location,representation_item('') || 
        geometric_representation_item() || curve()|| vector(   				 axis_position.z,1));  
  *)
  END_ENTITY;



  ENTITY surface_patch
    SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: (NOT ('SMCH_PLUS_203_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(

               parent_surface)));
  END_ENTITY;



  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY;



  ENTITY surface_side_style;
      name   : label;
      styles : SET [1:7] OF surface_style_element_select;
    WHERE
      wr1: (SIZEOF(QUERY ( style1 <* SELF.styles | (SIZEOF(
               QUERY ( style2 <* (SELF.styles - style1) | (TYPEOF(style1) =
                TYPEOF(style2)) )) > 0) )) = 0);
  END_ENTITY;



  ENTITY surface_style_boundary;
      style_of_boundary : curve_or_render;
  END_ENTITY;



  ENTITY surface_style_control_grid;
      style_of_control_grid : curve_or_render;
  END_ENTITY;



  ENTITY surface_style_fill_area;
      fill_area : fill_area_style;
  END_ENTITY;



  ENTITY surface_style_parameter_line;
      style_of_parameter_lines : curve_or_render;
      direction_counts         : SET [1:2] OF direction_count_select;
    WHERE
      wr1: ((HIINDEX(SELF.direction_counts) = 1) XOR (TYPEOF(SELF.
               direction_counts[1]) <> TYPEOF(SELF.direction_counts[2])));
  END_ENTITY;



  ENTITY surface_style_segmentation_curve;
      style_of_segmentation_curve : curve_or_render;
  END_ENTITY;



  ENTITY surface_style_silhouette;
      style_of_silhouette : curve_or_render;
  END_ENTITY;



  ENTITY surface_style_usage;
      side  : surface_side;
      style : surface_side_style_select;
  END_ENTITY;



  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (
              SURFACE_OF_LINEAR_EXTRUSION,
              SURFACE_OF_REVOLUTION))
  SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY;



  ENTITY symbol_colour;
      colour_of_symbol : colour;
  END_ENTITY;



  ENTITY symbol_style;
      name            : label;
      style_of_symbol : symbol_style_select;
  END_ENTITY;



  ENTITY symbol_target
    SUBTYPE OF (geometric_representation_item);
      placement : axis2_placement;
      x_scale   : positive_ratio_measure;
      y_scale   : positive_ratio_measure;
  END_ENTITY;



  ENTITY terminator_symbol
    SUBTYPE OF (annotation_symbol_occurrence);
      annotated_curve : annotation_curve_occurrence;
  END_ENTITY;



  ENTITY text_literal
    SUBTYPE OF (geometric_representation_item);
      literal   : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path      : text_path;
      font      : font_select;
  END_ENTITY;



  ENTITY text_literal_with_associated_curves
    SUBTYPE OF (text_literal);
      associated_curves : SET [1:?] OF curve;
  END_ENTITY;



  ENTITY text_literal_with_blanking_box
    SUBTYPE OF (text_literal);
      blanking : planar_box;
  END_ENTITY;



  ENTITY text_literal_with_extent
    SUBTYPE OF (text_literal);
      extent : planar_extent;
  END_ENTITY;



  ENTITY text_style;
      name                 : label;
      character_appearance : character_style_select;
  END_ENTITY;



  ENTITY text_style_for_defined_font;
      text_colour : colour;
  END_ENTITY;



  ENTITY text_style_with_box_characteristics
    SUBTYPE OF (text_style);
      characteristics : SET [1:4] OF box_characteristic_select;
    WHERE
      wr1: (SIZEOF(QUERY ( c1 <* SELF.characteristics | (SIZEOF(
               QUERY ( c2 <* (SELF.characteristics - c1) | (TYPEOF(c1) = 
               TYPEOF(c2)) )) > 0) )) = 0);
  END_ENTITY;



  ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
    WHERE
      wr1: (upper_bound.value_component > lower_bound.value_component);
      wr2: (upper_bound.unit_component = lower_bound.unit_component);
  END_ENTITY;



  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (
              VERTEX,
              EDGE,
              FACE_BOUND,
              FACE,
              VERTEX_SHELL,
              WIRE_SHELL,
              CONNECTED_EDGE_SET,
              CONNECTED_FACE_SET,
              LOOP
              ANDOR 
              PATH))
  SUBTYPE OF (representation_item);
  END_ENTITY;



  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY;



  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2])));
  END_ENTITY;



  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY;



  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY;



  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY;



  ENTITY user_defined_curve_font
    SUBTYPE OF (curve_style_font, mapped_item);
  END_ENTITY;



  ENTITY user_defined_marker
    SUBTYPE OF (pre_defined_marker, mapped_item);
  END_ENTITY;



  ENTITY user_defined_terminator_symbol
    SUBTYPE OF (pre_defined_symbol, mapped_item);
  END_ENTITY;



  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      wr1: (SIZEOF(QUERY ( rep <* using_representations(SELF) | (NOT (
               'SMCH_PLUS_203_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 

               TYPEOF(rep.context_of_items))) )) = 0);
  END_ENTITY;



  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY;



  ENTITY vector_style
    SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
  END_ENTITY;



  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : OPTIONAL text;
  END_ENTITY;



  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY;



  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY;



  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY;



  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY;



  ENTITY view_volume;
      projection_type            : central_or_parallel;
      projection_point           : cartesian_point;
      view_plane_distance        : length_measure;
      front_plane_distance       : length_measure;
      front_plane_clipping       : BOOLEAN;
      back_plane_distance        : length_measure;
      back_plane_clipping        : BOOLEAN;
      view_volume_sides_clipping : BOOLEAN;
      view_window                : planar_box;
  END_ENTITY;



  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SMCH_PLUS_203_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\

               measure_with_unit.unit_component));
  END_ENTITY;



  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY;



  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY;



  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: (NOT mixed_loop_type_set(wire_shell_extent));
  END_ENTITY;





   ENTITY blend
   ABSTRACT SUPERTYPE OF (
                       EDGE_BLEND) --BA add surface_blend later
  SUBTYPE OF (transition_feature);
   END_ENTITY;





   ENTITY block
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
   END_ENTITY;





   ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
      operator : boolean_operator;
      first_operand : boolean_operand;
      second_operand : boolean_operand;
   END_ENTITY;





   ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]);

   END_ENTITY;





   ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d);

   END_ENTITY;





   ENTITY box_domain;
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF, '')| NOT ('SMCH_PLUS_203_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;

   END_ENTITY;





   ENTITY boxed_half_space
   SUBTYPE OF (half_space_solid);
      enclosure : box_domain;
   END_ENTITY;





   ENTITY brep_2d
   SUBTYPE OF (solid_model);
      extent : face;
   WHERE
      WR1:
         SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_SURFACE', 'SMCH_PLUS_203_SCHEMA.SUBFACE', 'SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' ] * TYPEOF(SELF.extent)) = 0;
      WR2:
         SIZEOF(QUERY (bnds <* extent.bounds| NOT ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))) = 0;
      WR3:
         SIZEOF(QUERY (bnds <* extent.bounds| ('SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))) = 1;
      WR4:
         SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2)))) = 0))) = 0;

   END_ENTITY;





   ENTITY characterized_object;
      name : label;
      description : OPTIONAL text;
   END_ENTITY;





   ENTITY circular_area
   SUBTYPE OF (primitive_2d);
      centre : cartesian_point;
      radius : positive_length_measure;
   END_ENTITY;





   ENTITY convex_hexahedron
   SUBTYPE OF (faceted_primitive);
   WHERE
      WR1:
         SIZEOF(points) = 8;
      WR2:
         above_plane(points[1], points[2], points[3], points[4]) = 0.00000;
      WR3:
         above_plane(points[5], points[8], points[7], points[6]) = 0.00000;
      WR4:
         above_plane(points[1], points[4], points[8], points[5]) = 0.00000;
      WR5:
         above_plane(points[4], points[3], points[7], points[8]) = 0.00000;
      WR6:
         above_plane(points[3], points[2], points[6], points[7]) = 0.00000;
      WR7:
         above_plane(points[1], points[5], points[6], points[2]) = 0.00000;
      WR8:
         same_side([ points[1], points[2], points[3] ], [ points[5], points[6], points[7], points[8] ]);
      WR9:
         same_side([ points[1], points[4], points[8] ], [ points[3], points[7], points[6], points[2] ]);
      WR10:
         same_side([ points[1], points[2], points[5] ], [ points[3], points[7], points[8], points[4] ]);
      WR11:
         same_side([ points[5], points[6], points[7] ], [ points[1], points[2], points[3], points[4] ]);
      WR12:
         same_side([ points[3], points[7], points[6] ], [ points[1], points[4], points[8], points[5] ]);
      WR13:
         same_side([ points[3], points[7], points[8] ], [ points[1], points[5], points[6], points[2] ]);
   END_ENTITY;





   ENTITY csg_solid
   SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
   END_ENTITY;





   ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      radius1 : positive_length_measure;
      radius2 : positive_length_measure;
      cone_angle1 : plane_angle_measure;
      cone_angle2 : plane_angle_measure;
      turn_angle : plane_angle_measure;
   END_ENTITY;





   ENTITY data_environment;
      name : label;
      description : text;
      elements : SET [1:?] OF property_definition_representation;
   END_ENTITY;





   ENTITY date_assignment
   ABSTRACT SUPERTYPE;
      assigned_date : date;
      role : date_role;
   END_ENTITY;





   ENTITY date_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

   END_ENTITY;





   ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
   WHERE
      WR1:
         major_radius < minor_radius;
   END_ENTITY;





   ENTITY descriptive_representation_item
   SUBTYPE OF (representation_item);
      description : text;
   END_ENTITY;





   ENTITY dual_model
   SUBTYPE OF (representation_relationship);
      SELF\representation_relationship.rep_1 : procedural_representation;
      SELF\representation_relationship.rep_2 : explicit_representation;
   END_ENTITY;





   ENTITY dual_shape_model
   SUBTYPE OF (dual_model);
      SELF\representation_relationship.rep_1 : procedural_shape_representation;
      SELF\representation_relationship.rep_2 : explicit_shape_representation;
   END_ENTITY;





   ENTITY eccentric_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height : positive_length_measure;
      x_offset : length_measure;
      y_offset : length_measure;
      ratio : REAL;
   WHERE
      WR1:
         ratio >= 0.00000;
   END_ENTITY;





   ENTITY edge_blend
   ABSTRACT SUPERTYPE OF (ONEOF (
                       EDGE_BLEND_FILLET,
                       EDGE_BLEND_ROUND, EDGE_BLEND_CHAMFER))
  SUBTYPE OF (blend, selected_geometric_element);
   END_ENTITY;


   ENTITY edge_blend_chamfer
   SUBTYPE OF (edge_blend);
   END_ENTITY;


   ENTITY edge_blend_fillet
   SUPERTYPE OF (ONEOF (
              EDGE_BLEND_FILLET_CONSTANT_RADIUS,
              EDGE_BLEND_FILLET_VARIABLE_RADIUS))
  SUBTYPE OF (edge_blend);
   END_ENTITY;


   ENTITY edge_blend_fillet_constant_radius
   SUBTYPE OF (edge_blend_fillet);
   WHERE
      
      WR1:
         NOT (SELF\shape_aspect.description = 'constant radius') OR (SIZEOF(QUERY (pd <* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep <* QUERY (pdr <* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(impl_rep.used_representation.items) = 1))) = 0))) = 0);

   END_ENTITY;



   ENTITY edge_blend_fillet_variable_radius
   SUBTYPE OF (edge_blend_fillet);
   END_ENTITY;


   ENTITY edge_blend_round
   SUPERTYPE OF (ONEOF (
              edge_blend_round_constant_radius,
                   EDGE_BLEND_ROUND_VARIABLE_RADIUS))
  SUBTYPE OF (edge_blend);
   END_ENTITY;


   ENTITY edge_blend_round_constant_radius
   SUBTYPE OF (edge_blend_round);
   WHERE
      
      WR1:
         NOT (SELF\shape_aspect.description = 'constant radius') OR (SIZEOF(QUERY (pd <* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep <* QUERY (pdr <* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(impl_rep.used_representation.items) = 1))) = 0))) = 0);
      
   END_ENTITY;


   ENTITY edge_blend_round_variable_radius
   SUBTYPE OF (edge_blend_round);
   END_ENTITY;


   ENTITY elementary_brep_shape_representation
   SUBTYPE OF (shape_representation);
(*BA - problem with msb_shells no. of arguments 
 WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP', 'SMCH_PLUS_203_SCHEMA.FACETED_BREP', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM', 'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh.cfs_faces| NOT ('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs)))) = 0))) = 0))) = 0;
      WR4:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT ('SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(fcs\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.LINE', 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.POLYLINE' ] * TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end))))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds.bound\path.edge_list| ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND NOT (SIZEOF(oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) = 0))) = 0))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (msb <* QUERY (it <* items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0;
      WR10:
         SIZEOF(QUERY (brv <* QUERY (it <* items| ('SMCH_PLUS_203_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation)) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (mi <* QUERY (it <* items| ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)))| NOT ('SMCH_PLUS_203_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
      WR12:
         SIZEOF(QUERY (msb <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (csh <* msb_shells(msb)| NOT (SIZEOF(QUERY (fcs <* csh\connected_face_set.cfs_faces| NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds| ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0))) = 0))) = 0))) = 0;
*)
   END_ENTITY;





   ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
   END_ENTITY;





   ENTITY elliptic_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
   END_ENTITY;





   ENTITY expanded_uncertainty
   SUBTYPE OF (standard_uncertainty);
      coverage_factor : REAL;
   END_ENTITY;





   ENTITY explicit_representation
   SUBTYPE OF (representation);
   WHERE
      WR1:
         NOT ('SMCH_PLUS_203_SCHEMA.PROCEDURAL_REPRESENTATION' IN TYPEOF(SELF));

   END_ENTITY;





   ENTITY explicit_shape_representation
   SUBTYPE OF (explicit_representation, shape_representation);
   WHERE
      WR1:
         SIZEOF(TYPEOF(SELF) * [ 'SMCH_PLUS_203_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.MANIFOLD_SURFACE_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' ]) = 1;

   END_ENTITY;





   ENTITY explicit_shape_submodel
   SUBTYPE OF (explicit_submodel);
      SELF\explicit_submodel.submodel_elements : SET [1:?] OF shape_representation_item;
   END_ENTITY;





   ENTITY explicit_submodel;
      submodel_elements : set_representation_item;
   END_ENTITY;





   ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3], extruded_direction) <> 0.00000;
   END_ENTITY;





   ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
      extruded_direction : direction;
      depth : positive_length_measure;
   WHERE
      WR1:
         dot_product(SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3], extruded_direction) <> 0.00000;
   END_ENTITY;





   ENTITY face_based_surface_model
   SUBTYPE OF (geometric_representation_item);
      fbsm_faces : SET [1:?] OF connected_face_set;
   END_ENTITY;





   ENTITY faceted_primitive
   SUPERTYPE OF (ONEOF (
              TETRAHEDRON,
              CONVEX_HEXAHEDRON))
  SUBTYPE OF (geometric_representation_item);
      points : LIST [4:?] OF UNIQUE cartesian_point;
   WHERE
      WR1:
         points[1].dim = 3;
   END_ENTITY;


   ENTITY feature_component_definition
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.SHAPE_ASPECT.OF_SHAPE')) = 1))) = 0;

   END_ENTITY;





   ENTITY feature_definition
   SUBTYPE OF (characterized_object);
   WHERE
      WR1:
         SIZEOF(QUERY (pd <* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr <* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.' + 'SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (pd <* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep <* QUERY (pdr <* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.' + 'SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(QUERY (it <* impl_rep.used_representation.items| ('SMCH_PLUS_203_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND (it.name = 'orientation'))) = 1))) = 0))) = 0;
      

   END_ENTITY;



   ENTITY geometric_operation_sequence
   SUBTYPE OF (geometric_representation_item, operation_sequence);
   WHERE
      WR1:
         SIZEOF(QUERY (q <* SELF.created_elements| (SIZEOF(TYPEOF(q) * [ 'SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.TOPOLOGICAL_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.SOLID_MODEL', 'SMCH_PLUS_203_SCHEMA.SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.WIREFRAME_MODEL' ]) <> 1))) = 0;

   END_ENTITY;





   ENTITY geometric_set_replica
   SUBTYPE OF (geometric_set);
      parent_set : geometric_set;
      transformation : cartesian_transformation_operator;
   DERIVE
      SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
   WHERE
      WR1:
         acyclic_set_replica(SELF, parent_set);
   END_ENTITY;





   ENTITY half_space_2d
   SUBTYPE OF (geometric_representation_item);
      base_curve : curve;
      agreement_flag : BOOLEAN;
   END_ENTITY;





   ENTITY half_space_solid
   SUBTYPE OF (geometric_representation_item);
      base_surface : surface;
      agreement_flag : BOOLEAN;
   END_ENTITY;





   ENTITY instanced_feature
   SUBTYPE OF (feature_definition, shape_aspect);
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);

      WR2:
         SELF.product_definitional;
   END_ENTITY;





   ENTITY make_from_usage_option
   SUBTYPE OF (product_definition_usage);
      ranking : INTEGER;
      ranking_rationale : text;
      quantity : measure_with_unit;
   WHERE
      WR1:
         NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component > 0);
   END_ENTITY;





   ENTITY material_designation;
      name : label;
      definitions : SET [1:?] OF characterized_definition;
   END_ENTITY;





   ENTITY material_property
   SUBTYPE OF (property_definition);
   UNIQUE
      UR1 : SELF\property_definition.name, SELF\property_definition.definition;
   WHERE
      WR1:
         ('SMCH_PLUS_203_SCHEMA.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - QUERY (temp <* bag_to_set(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))| ('SMCH_PLUS_203_SCHEMA.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp)))) = 0);

   END_ENTITY;





   ENTITY material_property_representation
   SUBTYPE OF (property_definition_representation);
      dependent_environment : data_environment;
   END_ENTITY;





   ENTITY measure_qualification;
      name : label;
      description : text;
      qualified_measure : measure_with_unit;
      qualifiers : SET [1:?] OF value_qualifier;
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* qualifiers| ('SMCH_PLUS_203_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp)))) < 2;

   END_ENTITY;





   ENTITY non_manifold_surface_shape_representation
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM', 'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0;
      WR2:
         SIZEOF(QUERY (it <* SELF.items| (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) > 0;
      WR3:
         SIZEOF(QUERY (mi <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)))| NOT (('SMCH_PLUS_203_SCHEMA.' + 'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY (mr_it <* mi\mapped_item.mapping_source.mapped_representation.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(mr_it)))) > 0)))) = 0;
      WR4:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_SURFACE', 'SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' ] * TYPEOF(fa)) = 1))) = 0))) = 0))) = 0;
      WR5:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces| ('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)))| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) OR nmsf_surface_check(f_sf\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR6:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces| ('SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' IN TYPEOF(fa)))| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(o_fa\oriented_face.face_element)) OR nmsf_surface_check(o_fa\oriented_face.face_element\face_surface.face_geometry)))) = 0))) = 0))) = 0;
      WR7:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds <* fa.bounds| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.EDGE_LOOP', 'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
      WR8:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR9:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe_cv <* QUERY (oe <* elp_fbnds\path.edge_list| ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE', 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA', 'SMCH_PLUS_203_SCHEMA.LINE', 'SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D', 'SMCH_PLUS_203_SCHEMA.PCURVE', 'SMCH_PLUS_203_SCHEMA.POLYLINE', 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR10:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT nmsf_curve_check(oe.edge_element\edge_curve.edge_geometry))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR11:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR12:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe <* elp_fbnds\path.edge_list| NOT ((SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0;
      WR13:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) = 0))) = 0;
      WR14:
         SIZEOF(QUERY (fbsm <* QUERY (it <* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs <* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa <* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds| ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) = 1))) = 0)))) = 0))) = 0))) = 0;

   END_ENTITY;





   ENTITY operation_sequence
   SUBTYPE OF (representation_item);
      created_elements : list_representation_item;
   END_ENTITY;





   ENTITY organization_assignment
   ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role : organization_role;
   END_ENTITY;





   ENTITY organization_role;
      name : label;
   DERIVE
      description : text := get_description_value(SELF);
   WHERE
      WR1:
         SIZEOF(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;

   END_ENTITY;





   ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
      bounds : LIST [3:?] OF UNIQUE cartesian_point;
   END_ENTITY;





   ENTITY precision_qualifier;
      precision_value : INTEGER;
   END_ENTITY;





   ENTITY primitive_2d
   SUPERTYPE OF (ONEOF (
              CIRCULAR_AREA,
              ELLIPTIC_AREA,
              RECTANGULAR_AREA,
              POLYGONAL_AREA))
  SUBTYPE OF (geometric_representation_item);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 2;
   END_ENTITY;





   ENTITY procedural_representation
   SUBTYPE OF (representation);
      SELF\representation.items : SET [1:?] OF operation_sequence;
   END_ENTITY;





   ENTITY procedural_shape_representation
   SUBTYPE OF (procedural_representation, shape_representation);
      SELF\representation.items : SET [1:?] OF geometric_operation_sequence;
   END_ENTITY;





   ENTITY property_definition_relationship;
      name : label;
      description : text;
      relating_property_definition : property_definition;
      related_property_definition : property_definition;
   END_ENTITY;





   ENTITY qualified_representation_item
   SUBTYPE OF (representation_item);
      qualifiers : SET [1:?] OF value_qualifier;
   WHERE
      WR1:
         SIZEOF(QUERY (temp <* qualifiers| ('SMCH_PLUS_203_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp)))) < 2;

   END_ENTITY;





   ENTITY qualitative_uncertainty
   SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : text;
   END_ENTITY;





   ENTITY ratio_measure_with_unit
   SUBTYPE OF (measure_with_unit);
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);

   END_ENTITY;





   ENTITY ratio_unit
   SUBTYPE OF (named_unit);
   WHERE
      WR1:
         ((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000);
   END_ENTITY;





   ENTITY rectangle_domain;
      corner : cartesian_point;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
   WHERE
      WR1:
         SIZEOF(QUERY (item <* USEDIN(SELF, '')| NOT ('SMCH_PLUS_203_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;

   END_ENTITY;





   ENTITY rectangled_half_space
   SUBTYPE OF (half_space_2d);
      enclosure : rectangle_domain;
   END_ENTITY;





   ENTITY rectangular_area
   SUBTYPE OF (primitive_2d);
      position : axis2_placement_2d;
      x : positive_length_measure;
      y : positive_length_measure;
   END_ENTITY;





   ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      height : positive_length_measure;
   END_ENTITY;





   ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location, representation_item('') || geometric_representation_item() || vector(axis.z, 1.00000));
   END_ENTITY;





   ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
      axis : axis1_placement;
      angle : plane_angle_measure;
   DERIVE
      axis_line : line := representation_item('') || geometric_representation_item() || curve() || line(axis.location, representation_item('') || geometric_representation_item() || vector(axis.z, 1.00000));
   END_ENTITY;





   ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x : positive_length_measure;
      y : positive_length_measure;
      z : positive_length_measure;
      ltx : length_measure;
   WHERE
      WR1:
         (0.00000 <= ltx) AND (ltx < x);
   END_ENTITY;





   ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : length_measure;
      semi_angle : plane_angle_measure;
   WHERE
      WR1:
         radius >= 0.00000;
   END_ENTITY;





   ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height : positive_length_measure;
      radius : positive_length_measure;
   END_ENTITY;





   ENTITY sectioned_spine
   SUBTYPE OF (geometric_curve_set);
      cross_sections : LIST [2:?] OF curve;
      spine_points : LIST [2:?] OF point;
   WHERE
      WR1:
         SIZEOF(SELF\geometric_set.elements) = 1;
      WR2:
         'SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1]);

      WR3:
         SIZEOF(cross_sections) = SIZEOF(spine_points);
      WR4:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;





   ENTITY selected_element;
      picked_element : representation_item;
   END_ENTITY;





   ENTITY selected_geometric_element
   SUBTYPE OF (selected_element);
      SELF\selected_element.picked_element : shape_representation_item;
   END_ENTITY;





   ENTITY shape_defining_relationship
   SUBTYPE OF (shape_aspect_relationship);
   END_ENTITY;





   ENTITY shape_representation_with_parameters
   SUBTYPE OF (shape_representation);
   WHERE
      WR1:
         SIZEOF(QUERY (it <* SELF.items| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.PLACEMENT', 'SMCH_PLUS_203_SCHEMA.MEASURE_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' ] * TYPEOF(it)) = 1))) = 0;

   END_ENTITY;





   ENTITY solid_replica
   SUBTYPE OF (solid_model);
      parent_solid : solid_model;
      transformation : cartesian_transformation_operator_3d;
   WHERE
      WR1:
         acyclic_solid_replica(SELF, parent_solid);
      WR2:
         parent_solid\geometric_representation_item.dim = 3;
   END_ENTITY;





   ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
   END_ENTITY;





   ENTITY standard_uncertainty
   SUPERTYPE OF (
              EXPANDED_UNCERTAINTY)
  SUBTYPE OF (uncertainty_qualifier);
      uncertainty_value : REAL;
   END_ENTITY;





   ENTITY surface_curve_swept_area_solid
   SUBTYPE OF (swept_area_solid);
      directrix : curve;
      start_param : REAL;
      end_param : REAL;
      reference_surface : surface;
   WHERE
      WR1:
         NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface);

   END_ENTITY;





   ENTITY surface_curve_swept_face_solid
   SUBTYPE OF (swept_face_solid);
      directrix : curve;
      start_param : REAL;
      end_param : REAL;
      reference_surface : surface;
   WHERE
      WR1:
         NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface);

   END_ENTITY;





   ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF (
              REVOLVED_AREA_SOLID,
              EXTRUDED_AREA_SOLID,
              SURFACE_CURVE_SWEPT_AREA_SOLID))
  SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);

   END_ENTITY;





   ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF (
              EXTRUDED_FACE_SOLID,
              REVOLVED_FACE_SOLID,
              SURFACE_CURVE_SWEPT_FACE_SOLID))
  SUBTYPE OF (solid_model);
      swept_face : face_surface;
   WHERE
      WR1:
         'SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);

   END_ENTITY;





   ENTITY tetrahedron
   SUBTYPE OF (faceted_primitive);
   WHERE
      WR1:
         SIZEOF(points) = 4;
      WR2:
         above_plane(points[1], points[2], points[3], points[4]) <> 0.00000;
   END_ENTITY;





   ENTITY torus
   SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
   WHERE
      WR1:
         major_radius > minor_radius;
   END_ENTITY;





   ENTITY transition_feature
   ABSTRACT SUPERTYPE OF (ONEOF (BLEND))
  SUBTYPE OF (shape_aspect);
   END_ENTITY;


   ENTITY trimmed_volume
   SUBTYPE OF (solid_model);
      basis_volume : volume;
      u1 : parameter_value;
      u2 : parameter_value;
      v1 : parameter_value;
      v2 : parameter_value;
      w1 : parameter_value;
      w2 : parameter_value;
   WHERE
      WR1:
         u1 <> u2;
      WR2:
         v1 <> v2;
      WR3:
         w1 <> w2;
   END_ENTITY;





   ENTITY type_qualifier;
      name : label;
   END_ENTITY;





   ENTITY uncertainty_qualifier
   SUPERTYPE OF (ONEOF (
              STANDARD_UNCERTAINTY,
              QUALITATIVE_UNCERTAINTY));
      measure_name : label;
      description : text;
   END_ENTITY;





   ENTITY volume
   SUBTYPE OF (geometric_representation_item);
   WHERE
      WR1:
         SELF\geometric_representation_item.dim = 3;
   END_ENTITY;



  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,'SMCH_PLUS_203_SCHEMA.' + 

                'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;


  END_FUNCTION;



  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
                  'SMCH_PLUS_203_SCHEMA.' + 'ROLE_ASSOCIATION.' + 

                  'ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;


  END_FUNCTION;



  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' 

                         + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;


  END_FUNCTION;



  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'SMCH_PLUS_203_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');

    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;


  END_FUNCTION;



  FUNCTION msb_shells(
               brep: manifold_solid_brep;
               schema_name: STRING
      ): SET [1:?] OF closed_shell;
    IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;


  END_FUNCTION;



  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      RETURN(?);
    ELSE
      ndim := arg.dim;
      IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          vec := arg;
          v := arg.orientation;
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec.magnitude := 1;
          END_IF;
        END;
      ELSE
        v := arg;
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg) THEN

          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);


  END_FUNCTION;



  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      u : LIST [2:2] OF direction;
    END_LOCAL;
    u[1] := NVL(normalise(ref_direction),representation_item('') || 
        geometric_representation_item() || direction([1,0]));
    u[2] := orthogonal_complement(u[1]);
    RETURN(u);


  END_FUNCTION;



  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result.name := '';
      result.direction_ratios[1] := -vec.direction_ratios[2];
      result.direction_ratios[2] := vec.direction_ratios[1];
      RETURN(result);
    END_IF;


  END_FUNCTION;



  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      u : LIST [3:3] OF direction;
    END_LOCAL;
    u[3] := NVL(normalise(axis),representation_item('') || 
        geometric_representation_item() || direction([0,0,1]));
    u[1] := first_proj_axis(u[3],ref_direction);
    u[2] := normalise(cross_product(u[3],u[1])).orientation;
    RETURN(u);


  END_FUNCTION;



  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := representation_item('') || geometric_representation_item() 
              || direction([1,0,0]);
        ELSE
          v := representation_item('') || geometric_representation_item() 
              || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);


  END_FUNCTION;



  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res.name := '';
        res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
        res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
        res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.orientation := res;
          result.magnitude := SQRT(mag);
        ELSE
          result.orientation := arg1;
          result.magnitude := 0;
        END_IF;
        result.name := '';
        RETURN(result);
      END;
    END_IF;


  END_FUNCTION;



  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(vec) THEN

        v := vec.orientation;
        mag := scalar * vec.magnitude;
      ELSE
        v := vec;
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result.name := '';
      result.orientation := normalise(v);
      result.magnitude := mag;
    END_IF;
    RETURN(result);


  END_FUNCTION;



  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);


  END_FUNCTION;



  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN

          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.magnitude := SQRT(mag);
          result.orientation := res;
        ELSE
          result.magnitude := 0;
          result.orientation := vec1;
        END_IF;
      END;
    END_IF;
    result.name := '';
    RETURN(result);


  END_FUNCTION;



  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER
      ): ARRAY [low:u] OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      REPEAT i := 1 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;


  END_FUNCTION;



  FUNCTION constraints_param_b_spline(
               degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      l      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);


  END_FUNCTION;



  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;

    LOCAL
      n2   : INTEGER;
      n1   : INTEGER;
      res  : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
      resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    n1 := SIZEOF(lis);
    n2 := SIZEOF(lis[1]);
    IF (n1 <> ((u1 - low1) + 1)) OR (n2 <> ((u2 - low2) + 1)) THEN
      RETURN(?);
    END_IF;
    REPEAT i := 1 TO n1 BY 1;
      IF SIZEOF(lis[i]) <> n2 THEN
        RETURN(?);
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO n1 BY 1;
      resl[i] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    res := list_to_array(resl,low1,u1);
    RETURN(res);


  END_FUNCTION;



  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;


  END_FUNCTION;



  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;


  END_FUNCTION;



  FUNCTION aspect_ratio(
               p: planar_box
      ): positive_ratio_measure;
    RETURN(p.size_in_x / p.size_in_y);


  END_FUNCTION;



  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      vec    : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      u[3] := NVL(normalise(axis3),representation_item('') || 
          geometric_representation_item() || direction([0,0,1]));
      u[1] := first_proj_axis(u[3],axis1);
      u[2] := second_proj_axis(u[3],u[1],axis2);
    ELSE
      u[3] := ?;
      IF EXISTS(axis1) THEN
        u[1] := normalise(axis1);
        u[2] := orthogonal_complement(u[1]);
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          u[2] := normalise(axis2);
          u[1] := orthogonal_complement(u[2]);
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u[1].name := '';
          u[2].name := '';
          u[1].direction_ratios[1] := 1;
          u[1].direction_ratios[2] := 0;
          u[2].direction_ratios[1] := 0;
          u[2].direction_ratios[2] := 1;
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);


  END_FUNCTION;



  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := representation_item('') || geometric_representation_item() || 
          direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);


  END_FUNCTION;



  FUNCTION cc_design_date_time_correlation(
               e: cc_design_date_and_time_assignment
      ): BOOLEAN;

    LOCAL
      dt_role : STRING;
    END_LOCAL;
    dt_role := e\date_and_time_assignment.role.name;
    CASE dt_role OF
      'creation_date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'PRODUCT_DEFINITION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'request_date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF([
            'SMCH_PLUS_203_SCHEMA.CHANGE_REQUEST' + 
            'SMCH_PLUS_203_SCHEMA.START_REQUEST'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'release_date'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.CHANGE' + 
            'SMCH_PLUS_203_SCHEMA.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'start_date'           :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.CHANGE' + 
            'SMCH_PLUS_203_SCHEMA.START_WORK'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'sign_off_date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contract_date'        :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('SMCH_PLUS_203_SCHEMA.CONTRACT' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'certification_date'   :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('SMCH_PLUS_203_SCHEMA.CERTIFICATION' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification_date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'declassification_date'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 

            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE              :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION cc_design_person_and_organization_correlation(
               e: cc_design_person_and_organization_assignment
      ): BOOLEAN;

    LOCAL
      po_role : STRING;
    END_LOCAL;
    po_role := e\person_and_organization_assignment.role.name;
    CASE po_role OF
      'request_recipient'     :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' + 
            'CHANGE_REQUEST','SMCH_PLUS_203_SCHEMA.' + 'START_REQUEST'] * 
            TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'initiator'             :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' + 
            'CHANGE_REQUEST','SMCH_PLUS_203_SCHEMA.' + 'START_REQUEST',
            'SMCH_PLUS_203_SCHEMA.' + 'START_WORK','SMCH_PLUS_203_SCHEMA.' + 
            'CHANGE'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'creator'               :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' + 
            'PRODUCT_DEFINITION_FORMATION','SMCH_PLUS_203_SCHEMA.' + 
            'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1) )) THEN
          RETURN(FALSE);
        END_IF;
      'part_supplier'         :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design_supplier'       :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'design_owner'          :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('SMCH_PLUS_203_SCHEMA.PRODUCT' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'configuration_manager' :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 
            'CONFIGURATION_ITEM') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'contractor'            :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | ('SMCH_PLUS_203_SCHEMA.CONTRACT' IN 
            TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      'classification_officer'  :         IF SIZEOF(e.items) <> SIZEOF(
            QUERY ( x <* e.items | (('SMCH_PLUS_203_SCHEMA.' + 

            'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
          RETURN(FALSE);
        END_IF;
      OTHERWISE               :         RETURN(TRUE);
      END_CASE;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN

      n := SIZEOF(c\composite_curve_on_surface.segments);
      surfs := get_basis_surface(c\composite_curve_on_surface.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
              segments[i].parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);


  END_FUNCTION;



  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(arg) THEN

      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);


  END_FUNCTION;



  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve.
          segments[k].parent_curve))) AND (NOT (
          'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\composite_curve.
          segments[k].parent_curve))) AND (NOT (
          'SMCH_PLUS_203_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\

          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION acyclic_composite_text(
               start_composite: composite_text;
               child_text: SET [1:?] OF text_or_character
      ): LOGICAL;

    LOCAL
      i                     : INTEGER;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_composite_text  : SET [0:?] OF composite_text;
      local_children        : SET [0:?] OF text_or_character;
    END_LOCAL;
    local_composite_text := QUERY ( child <* child_text | (
        'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(child)) );
    IF SIZEOF(local_composite_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
        IF start_composite :=: local_composite_text[i] THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    local_children := child_text;
    IF SIZEOF(local_composite_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
        local_children := local_children + local_composite_text[i].
            collected_text;
      END_REPEAT;
    END_IF;
    local_annotation_text := QUERY ( child <* child_text | (
        'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT' IN TYPEOF(child)) );
    IF SIZEOF(local_annotation_text) > 0 THEN
      REPEAT i := 1 TO HIINDEX(local_annotation_text) BY 1;
        local_children := local_children + QUERY ( item <* 
            local_annotation_text[i]\mapped_item.mapping_source.
            mapped_representation.items | (SIZEOF([
            'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT',
            'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT'] * TYPEOF(item)) > 0) );

      END_REPEAT;
    END_IF;
    IF local_children :<>: child_text THEN
      RETURN(acyclic_composite_text(start_composite,local_children));
    ELSE
      RETURN(TRUE);
    END_IF;


  END_FUNCTION;



  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('SMCH_PLUS_203_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent)) THEN

      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;


  END_FUNCTION;



  FUNCTION check_text_alignment(
               ct: composite_text
      ): BOOLEAN;

    LOCAL
      a : SET OF text_alignment := [];
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
      a := a + [ct.collected_text[i]\text_literal.alignment];
    END_REPEAT;
    RETURN(SIZEOF(a) = 1);


  END_FUNCTION;



  FUNCTION check_text_font(
               ct: composite_text
      ): BOOLEAN;

    LOCAL
      f : SET OF font_select := [];
      i : INTEGER;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
      f := f + [ct.collected_text[i]\text_literal.font];
    END_REPEAT;
    RETURN(SIZEOF(f) <= 1);


  END_FUNCTION;



  FUNCTION valid_wireframe_edge_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.LINE',schma + '.CIRCLE',schma + '.ELLIPSE',schma 
        + '.PARABOLA',schma + '.HYPERBOLA',schma + '.B_SPLINE_CURVE',schma 
        + '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve,
            schma));
      ELSE
        IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION valid_wireframe_vertex_point(
               pnt: point;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt,
            schma));
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      i              : INTEGER;
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'SMCH_PLUS_203_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('SMCH_PLUS_203_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> 

          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);


  END_FUNCTION;



  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);


  END_FUNCTION;



  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);


  END_FUNCTION;



  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS');

        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);


  END_FUNCTION;



  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'SMCH_PLUS_203_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z))) );

    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);


  END_FUNCTION;



  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);


  END_FUNCTION;



  FUNCTION gbsf_check_point(
               pnt: point;
               schema_name: STRING
      ): BOOLEAN;
    IF NOT ((schema_name + '.POINT') IN TYPEOF(pnt)) THEN
      RETURN(TRUE);
    END_IF;
    IF (schema_name + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schema_name + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve,schema_name));
      ELSE
        IF (schema_name + '.POINT_ON_SURFACE') IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface,
              schema_name));
        ELSE
          IF (schema_name + '.DEGENERATE_PCURVE') IN TYPEOF(pnt) THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve\representation.items[1],schema_name) AND
                 gbsf_check_surface(pnt\degenerate_pcurve.basis_surface,
                schema_name));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION gbsf_check_curve(
               cv: curve;
               schema_name: STRING
      ): BOOLEAN;
    IF NOT ((schema_name + '.CURVE') IN TYPEOF(cv)) THEN
      RETURN(TRUE);
    END_IF;
    IF SIZEOF([schema_name + '.CIRCLE',schema_name + '.ELLIPSE'] * TYPEOF(
        cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schema_name + '.B_SPLINE_CURVE') IN TYPEOF(cv) THEN
        RETURN(NOT cv\b_spline_curve.self_intersect);
      ELSE
        IF (schema_name + '.COMPOSITE_CURVE') IN TYPEOF(cv) THEN
          RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (NOT 
              gbsf_check_curve(seg.parent_curve,schema_name)) )) = 0);
        ELSE
          IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv) THEN
            RETURN(gbsf_check_curve(cv\curve_replica.parent_curve,
                schema_name));
          ELSE
            IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv) THEN
              RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve,
                  schema_name) AND (NOT cv\offset_curve_3d.self_intersect));
            ELSE
              IF (schema_name + '.PCURVE') IN TYPEOF(cv) THEN
                RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
                    representation.items[1],schema_name) AND 
                    gbsf_check_surface(cv\pcurve.basis_surface,schema_name));
              ELSE
                IF (schema_name + '.POLYLINE') IN TYPEOF(cv) THEN
                  IF (SIZEOF(cv\polyline.points) > 3) AND (SIZEOF(
                      bag_to_set(USEDIN(cv,'')) - bag_to_set(USEDIN(cv,
                      schema_name + '.INTERSECTION_CURVE.BASIS_CURVE'))) = 
                      0) THEN
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF (schema_name + '.SURFACE_CURVE') IN TYPEOF(cv) THEN
                    IF gbsf_check_curve(cv\surface_curve.curve_3d,
                        schema_name) THEN
                      REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                          associated_geometry) BY 1;
                        IF (schema_name + '.SURFACE') IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_surface(cv\surface_curve.
                              associated_geometry[i],schema_name) THEN
                            RETURN(FALSE);
                          END_IF;
                        ELSE
                          IF (schema_name + '.PCURVE') IN TYPEOF(cv\
                              surface_curve.associated_geometry[i]) THEN
                            IF NOT gbsf_check_curve(cv\surface_curve.
                                associated_geometry[i],schema_name) THEN
                              RETURN(FALSE);
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF (schema_name + '.TRIMMED_CURVE') IN TYPEOF(cv)
                         THEN
                      IF SIZEOF([schema_name + '.LINE',schema_name + 
                          '.PARABOLA',schema_name + '.HYPERBOLA'] * TYPEOF(
                          cv\trimmed_curve.basis_curve)) = 1 THEN
                        RETURN(TRUE);
                      ELSE
                        RETURN(gbsf_check_curve(cv\trimmed_curve.
                            basis_curve,schema_name));
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION gbsf_check_surface(
               sf: surface;
               schema_name: STRING
      ): BOOLEAN;
    IF NOT ((schema_name + '.SURFACE') IN TYPEOF(sf)) THEN
      RETURN(TRUE);
    END_IF;
    IF (schema_name + '.B_SPLINE_SURFACE') IN TYPEOF(sf) THEN
      RETURN(NOT sf\b_spline_surface.self_intersect);
    ELSE
      IF SIZEOF([schema_name + '.SPHERICAL_SURFACE',schema_name + 
          '.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 3 THEN
        RETURN(TRUE);
      ELSE
        IF (schema_name + '.CURVE_BOUNDED_SURFACE') IN TYPEOF(sf) THEN
          IF SIZEOF([schema_name + '.CONICAL_SURFACE',schema_name + 
              '.CYLINDRICAL_SURFACE',schema_name + '.PLANE'] * TYPEOF(sf)) 
              = 1 THEN
            RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve,schema_name)) )) 
                = 0);
          ELSE
            IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface,
                schema_name) THEN
              RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                  boundaries | (NOT gbsf_check_curve(bcurve,schema_name)) )) 
                  = 0);
            END_IF;
          END_IF;
        ELSE
          IF (schema_name + '.OFFSET_SURFACE') IN TYPEOF(sf) THEN
            RETURN(gbsf_check_surface(sf\offset_surface.basis_surface,
                schema_name) AND (NOT sf\offset_surface.self_intersect));
          ELSE
            IF (schema_name + '.RECTANGULAR_COMPOSITE_SURFACE') IN TYPEOF(
                sf) THEN
              REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments) BY 1;
                REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                    segments[i]) BY 1;
                  IF NOT gbsf_check_surface(sf\
                      rectangular_composite_surface.segments[i][j].
                      parent_surface,schema_name) THEN
                    RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_REPEAT;
              RETURN(TRUE);
            ELSE
              IF (schema_name + '.RECTANGULAR_TRIMMED_SURFACE') IN TYPEOF(
                  sf) THEN
                IF SIZEOF([schema_name + '.CONICAL_SURFACE',schema_name + 
                    '.CYLINDRICAL_SURFACE',schema_name + '.PLANE'] * 
                    TYPEOF(sf\rectangular_trimmed_surface.basis_surface)) =
                     1 THEN
                  RETURN(TRUE);
                ELSE
                  RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
                      .basis_surface,schema_name));
                END_IF;
              ELSE
                IF (schema_name + '.SURFACE_REPLICA') IN TYPEOF(sf) THEN
                  RETURN(gbsf_check_surface(sf\surface_replica.
                      parent_surface,schema_name));
                ELSE
                  IF (schema_name + '.SWEPT_SURFACE') IN TYPEOF(sf) THEN
                    RETURN(gbsf_check_curve(sf\swept_surface.swept_curve,
                        schema_name));
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION valid_geometrically_bounded_wf_curve(
               crv: curve;
               schma: STRING
      ): BOOLEAN;
    IF SIZEOF([schma + '.POLYLINE',schma + '.B_SPLINE_CURVE',schma + 
        '.ELLIPSE',schma + '.CIRCLE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
        IF SIZEOF([schma + '.LINE',schma + '.PARABOLA',schma + 
            '.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1
             THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve,schma));
        END_IF;
      ELSE
        IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve,schma));
        ELSE
          IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve,schma));
          ELSE
            IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | 
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve,schma)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION valid_geometrically_bounded_wf_point(
               pnt: point;
               schma: STRING
      ): BOOLEAN;
    IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF (schma + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve,schma));
      ELSE
        IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt,schma));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;


  END_FUNCTION;



  FUNCTION basis_surface_check(
               surf: surface;
               schema_name: STRING
      ): BOOLEAN;
    IF SIZEOF([schema_name + '.B_SPLINE_SURFACE',schema_name + 
        '.ELEMENTARY_SURFACE'] * TYPEOF(surf)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (schema_name + '.SWEPT_SURFACE') IN TYPEOF(surf) THEN
        RETURN(basis_curve_check(surf\swept_surface.swept_curve,
            schema_name));
      ELSE
        IF (schema_name + '.OFFSET_SURFACE') IN TYPEOF(surf) THEN
          RETURN(basis_surface_check(surf\offset_surface.basis_surface,
              schema_name));
        ELSE
          IF (schema_name + '.SURFACE REPLICA') IN TYPEOF(surf) THEN
            RETURN(basis_surface_check(surf\surface_replica.parent_surface,
                schema_name));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION basis_curve_check(
               cv: curve;
               schema_name: STRING
      ): BOOLEAN;
    IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name + '.CONIC',
        schema_name + '.LINE',schema_name + '.POLYLINE'] * TYPEOF(cv)) = 1
         THEN
      RETURN(TRUE);
    ELSE
      IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv) THEN
        RETURN(basis_curve_check(cv\curve_replica.parent_curve,schema_name));
      ELSE
        IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv) THEN
          RETURN(basis_curve_check(cv\offset_curve_3d.basis_curve,
              schema_name));
        ELSE
          IF (schema_name + '.PCURVE') IN TYPEOF(cv) THEN
            IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name + 
                '.CONIC',schema_name + '.LINE',schema_name + '.POLYLINE'] *
                 TYPEOF(cv\pcurve.reference_to_curve\representation.items[1])) 
                = 1 THEN
              RETURN(basis_surface_check(cv\pcurve.basis_surface,
                  schema_name));
            ELSE
              IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv\pcurve.
                  reference_to_curve\representation.items[1]) THEN
                RETURN(basis_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1],schema_name) AND 
                    basis_surface_check(cv\pcurve.basis_surface,schema_name));
              END_IF;
            END_IF;
          ELSE
            IF (schema_name + '.SURFACE_CURVE') IN TYPEOF(cv) THEN
              IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name + 
                  '.CONIC',schema_name + '.LINE',schema_name + '.POLYLINE'] 
                  * TYPEOF(cv\surface_curve.curve_3d)) = 1 THEN
                REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                    associated_geometry) BY 1;
                  IF (schema_name + '.SURFACE') IN TYPEOF(cv\surface_curve
                      .associated_geometry[i]) THEN
                    IF NOT basis_surface_check(cv\surface_curve.
                        associated_geometry[i],schema_name) THEN
                      RETURN(FALSE);
                    END_IF;
                  ELSE
                    IF (schema_name + '.PCURVE') IN TYPEOF(cv\
                        surface_curve.associated_geometry[i]) THEN
                      IF NOT basis_curve_check(cv\surface_curve.
                          associated_geometry[i],schema_name) THEN
                        RETURN(FALSE);
                      END_IF;
                    END_IF;
                  END_IF;
                END_REPEAT;
              ELSE
                IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv\
                    surface_curve.curve_3d) THEN
                  IF NOT basis_curve_check(cv\curve_replica.parent_curve,
                      schema_name) THEN
                    RETURN(FALSE);
                  END_IF;
                ELSE
                  IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv\
                      surface_curve.curve_3d) THEN
                    IF NOT basis_curve_check(cv\offset_curve_3d.
                        basis_curve,schema_name) THEN
                      RETURN(FALSE);
                    END_IF;
                  ELSE
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF (schema_name + '.SURFACE') IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT basis_surface_check(cv\surface_curve.
                            associated_geometry[i],schema_name) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF (schema_name + '.PCURVE') IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT basis_curve_check(cv\surface_curve.
                              associated_geometry[i],schema_name) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN
         TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );

        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'SMCH_PLUS_203_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m
        .value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.

        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'SMCH_PLUS_203_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN

      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);


  END_FUNCTION;



  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;


  END_FUNCTION;



  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'SMCH_PLUS_203_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'SMCH_PLUS_203_SCHEMA.SHELL' IN TYPEOF(an_item) THEN

      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);


  END_FUNCTION;


FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
  LOCAL
    the_reverse : oriented_edge; 
  END_LOCAL;

  IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
    the_reverse := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge\oriented_edge.edge_element,
                       NOT (an_edge\oriented_edge.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
            edge(an_edge.edge_end, an_edge.edge_start) ||
            oriented_edge(an_edge, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;


FUNCTION path_reversed (a_path : path) : oriented_path;--BA ->tc3
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;



  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);


  END_FUNCTION;



  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    the_reverse.name := '';
    IF 'SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)

         THEN
      the_reverse.bound := a_face_bound\face_bound.bound;
      the_reverse.orientation := NOT a_face_bound\face_bound.orientation;
    ELSE
      the_reverse.bound := a_face_bound.bound;
      the_reverse.orientation := NOT a_face_bound.orientation;
    END_IF;
    RETURN(the_reverse);


  END_FUNCTION;



  FUNCTION face_reversed (a_face : face) : oriented_face;--BA ->tc3
  LOCAL
    the_reverse : oriented_face ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
         oriented_face(a_face\oriented_face.face_element,
                          NOT (a_face\oriented_face.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
      face(set_of_topology_reversed(a_face.bounds)) ||
                              oriented_face(a_face, FALSE) ;
  END_IF;
     RETURN (the_reverse);
END_FUNCTION;


  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);


  END_FUNCTION;



  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;

    LOCAL
      the_reverse : shell;
    END_LOCAL;
    IF 'SMCH_PLUS_203_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
      the_reverse := representation_item('') || 
          topological_representation_item() || connected_face_set(
          set_of_topology_reversed(a_shell\connected_face_set.cfs_faces)) 
          || open_shell() || oriented_open_shell(a_shell\
          oriented_open_shell.open_shell_element,NOT a_shell\
          oriented_open_shell.orientation);
    ELSE
      IF 'SMCH_PLUS_203_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
        the_reverse := representation_item('') || 
            topological_representation_item() || connected_face_set(
            set_of_topology_reversed(a_shell\connected_face_set.cfs_faces)) 
            || open_shell() || oriented_open_shell(a_shell,FALSE);
      ELSE
        IF 'SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
             THEN
          the_reverse := representation_item('') || 
              topological_representation_item() || connected_face_set(
              set_of_topology_reversed(a_shell\connected_face_set.cfs_faces)) 
              || closed_shell() || oriented_closed_shell(a_shell\
              oriented_closed_shell.closed_shell_element,NOT a_shell\
              oriented_closed_shell.orientation);
        ELSE
          IF 'SMCH_PLUS_203_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN

            the_reverse := representation_item('') || 
                topological_representation_item() || connected_face_set(
                set_of_topology_reversed(a_shell\connected_face_set.
                cfs_faces)) || closed_shell() || oriented_closed_shell(
                a_shell,FALSE);
          ELSE
            the_reverse := ?;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(the_reverse);


  END_FUNCTION;



  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1, choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;


  END_FUNCTION;



  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);


  END_FUNCTION;



  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('SMCH_PLUS_203_SCHEMA.POINT_REPLICA' IN TYPEOF(parent)) THEN

      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;


  END_FUNCTION;



  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS') * 
        cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );

      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): LOGICAL;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'SMCH_PLUS_203_SCHEMA.' + 

        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING
      ): LOGICAL;

    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,'SMCH_PLUS_203_SCHEMA.' + 

        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives + 
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);


  END_FUNCTION;



  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);


  END_FUNCTION;



  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(s.
            segments[i][j].parent_surface)) OR (
            'SMCH_PLUS_203_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.

            segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION check_associative_shape_aspects(
               sdr: shape_definition_representation
      ): BOOLEAN;

    LOCAL
      sr1 : SET OF representation;
      sr2 : SET OF representation;
      i   : INTEGER;
      j   : INTEGER;
      k   : INTEGER;
      dm  : SET OF representation;
      pv  : SET OF representation;
    END_LOCAL;
    IF SIZEOF(sdr.used_representation.items) <> 2 THEN
      RETURN(FALSE);
    END_IF;
    sr1 := using_representations(sdr.used_representation.items[1]);
    sr2 := using_representations(sdr.used_representation.items[2]);
    REPEAT i := 1 TO HIINDEX(sr1) BY 1;
      dm := representations_mapped_into(sr1[i]);
      REPEAT j := 1 TO HIINDEX(dm) BY 1;
        IF 'SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL' IN TYPEOF(dm[j]) THEN
          IF dm[j] IN sr2 THEN
            RETURN(TRUE);
          END_IF;
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv) BY 1;
            IF 'SMCH_PLUS_203_SCHEMA.PRESENTATION_VIEW' IN TYPEOF(pv[k])
                 THEN
              IF pv[k] IN sr2 THEN
                RETURN(TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(sr2) BY 1;
      dm := representations_mapped_into(sr2[i]);
      REPEAT j := 1 TO HIINDEX(dm) BY 1;
        IF 'SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL' IN TYPEOF(dm[j]) THEN
          IF dm[j] IN sr1 THEN
            RETURN(TRUE);
          END_IF;
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv) BY 1;
            IF 'SMCH_PLUS_203_SCHEMA.PRESENTATION_VIEW' IN TYPEOF(pv[k])

                 THEN
              IF pv[k] IN sr1 THEN
                RETURN(TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(FALSE);


  END_FUNCTION;



  FUNCTION representations_mapped_into(
               rep: representation
      ): SET OF representation;

    LOCAL
      results : SET OF representation := [];
      i       : INTEGER;
      j       : INTEGER;
      mi      : SET OF mapped_item;
      rm      : SET OF representation_map;
    END_LOCAL;
    rm := USEDIN(rep,'SMCH_PLUS_203_SCHEMA.' + 
        'REPRESENTATION_MAP.MAPPED_REPRESENTATION');
    REPEAT i := 1 TO HIINDEX(rm) BY 1;
      mi := mi + rm[i].map_usage;
    END_REPEAT;
    REPEAT j := 1 TO HIINDEX(mi) BY 1;
      results := results + USEDIN(mi[j],'SMCH_PLUS_203_SCHEMA.' + 

          'REPRESENTATION.ITEMS');
    END_REPEAT;
    RETURN(results);


  END_FUNCTION;



  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('SMCH_PLUS_203_SCHEMA.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[
          j]))) AND (NOT ('SMCH_PLUS_203_SCHEMA.CLOSED_SHELL' IN TYPEOF(m.

          sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);


  END_FUNCTION;



  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[
          j]))) AND (NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN TYPEOF(m.

          sbwm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);


  END_FUNCTION;



  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      OTHERWISE     :         RETURN(?);
      END_CASE;


  END_FUNCTION;



  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent)) THEN

      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;


  END_FUNCTION;



  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;


  END_FUNCTION;



(* ***********************************
Functions in the schema construction_history_schema
*********************************** *)



   FUNCTION above_plane
      (p1 : cartesian_point;
       p2 : cartesian_point;
       p3 : cartesian_point;
       p4 : cartesian_point ) : REAL;
   LOCAL
      dir2 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
      dir3 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
      dir4 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
      val : REAL;
      mag : REAL;
   END_LOCAL;
      IF p1.dim <> 3 THEN
         RETURN (?);
      END_IF;
      REPEAT i := 1 TO 3;
         dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
         dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
         dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
         mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
      END_REPEAT;
      mag := sqrt(mag);
      val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
      RETURN (val);

   END_FUNCTION;





   FUNCTION same_side
      (plane_pts : LIST [3:3] OF cartesian_point;
       test_points : LIST [2:?] OF cartesian_point ) : BOOLEAN;
   LOCAL
      val1 : REAL;
      val2 : REAL;
      n : INTEGER;
   END_LOCAL;
      IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
         RETURN (?);
      END_IF;
      n := SIZEOF(test_points);
      val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[1]);
      REPEAT i := 2 TO n;
         val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[i]);
         IF val1 * val2 <= 0.00000 THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
      RETURN (TRUE);

   END_FUNCTION;





   FUNCTION build_transformed_set
      (tr : cartesian_transformation_operator;
       gset : geometric_set ) : SET [0:?] OF geometric_set_select;
   LOCAL
      s : SET [1:?] OF geometric_set_select := gset.elements;
      trset : SET [0:?] OF geometric_set_select := [];
   END_LOCAL;
(*BA ---send to Jochen
      REPEAT j := 1 TO SIZEOF(s);
         IF 'CONSTRUCTION_HISTORY_SCHEMA.CURVE' IN TYPEOF(s[j]) THEN
            trset := trset + curve_replica(s[j], tr);
         ELSE
            IF 'CONSTRUCTION_HISTORY_SCHEMA.POINT' IN TYPEOF(s[j]) THEN
               trset := trset + point_replica(s[j], tr);
            ELSE
               IF 'CONSTRUCTION_HISTORY_SCHEMA.SURFACE' IN TYPEOF(s[j]) THEN
                  trset := trset + surface_replica(s[j], tr || cartesian_transformation_operator_3d(?));
               END_IF;
            END_IF;
         END_IF;
      END_REPEAT; 
      *)
      RETURN (trset);  
     



   END_FUNCTION;





   FUNCTION acyclic_set_replica
      (rep : geometric_set_replica;
       parent : geometric_set ) : BOOLEAN;
      IF NOT ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET_REPLICA' IN TYPEOF(parent)) THEN

         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_set_replica(rep, parent\geometric_set_replica.parent_set));
      END_IF;

   END_FUNCTION;





   FUNCTION nmsf_surface_check
      (surf : surface ) : BOOLEAN;
      IF 'SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
         RETURN (TRUE);
      ELSE
         IF 'SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN
            RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));
         ELSE
            IF ('SMCH_PLUS_203_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = FALSE) OR (surf\offset_surface.self_intersect = UNKNOWN) THEN
               RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
            ELSE
               IF 'SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN
                  RETURN (nmsf_surface_check(surf\surface_replica.parent_surface));
               ELSE
                  IF ('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect = FALSE) OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN

                     RETURN (TRUE);
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);

   END_FUNCTION;





   FUNCTION nmsf_curve_check
      (cv : representation_item ) : BOOLEAN;
      IF SIZEOF([ 'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE', 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA', 'SMCH_PLUS_203_SCHEMA.LINE', 'SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D' ] * TYPEOF(cv)) > 1 THEN
         RETURN (FALSE);
      ELSE
         IF ('SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN) THEN
            RETURN (TRUE);
         ELSE
            IF SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.LINE' ] * TYPEOF(cv)) = 1 THEN
               RETURN (TRUE);
            ELSE
               IF 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
                  RETURN (nmsf_curve_check(cv\curve_replica.parent_curve));
               ELSE
                  IF (('SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN))) AND NOT ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)) THEN
                     RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve));
                  ELSE
                     IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
                        RETURN (nmsf_curve_check(cv\pcurve.reference_to_curve\representation.items[1]) AND nmsf_surface_check(cv\pcurve.basis_surface));
                     ELSE
                        IF 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN
                           IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                              REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                                 IF 'SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                    IF NOT nmsf_surface_check(cv\surface_curve.associated_geometry[i]) THEN
                                       RETURN (FALSE);
                                    END_IF;
                                 ELSE
                                    IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                                       IF NOT nmsf_curve_check(cv\surface_curve.associated_geometry[i]) THEN
                                          RETURN (FALSE);
                                       END_IF;
                                    END_IF;
                                 END_IF;
                              END_REPEAT;
                              RETURN (TRUE);
                           END_IF;
                        ELSE
                           IF 'SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN

                              IF SIZEOF(cv\polyline.points) >= 3 THEN
                                 RETURN (TRUE);
                              END_IF;
                           END_IF;
                        END_IF;
                     END_IF;
                  END_IF;
               END_IF;
            END_IF;
         END_IF;
      END_IF;
      RETURN (FALSE);

   END_FUNCTION;





   FUNCTION acyclic_solid_replica
      (rep : solid_replica;
       parent : solid_model ) : BOOLEAN;
      IF NOT ('SMCH_PLUS_203_SCHEMA.SOLID_REPLICA' IN TYPEOF(parent)) THEN

         RETURN (TRUE);
      END_IF;
      IF parent :=: rep THEN
         RETURN (FALSE);
      ELSE
         RETURN (acyclic_solid_replica(rep, parent\solid_replica.parent_solid));
      END_IF;

   END_FUNCTION;



  FUNCTION assembly_shape_is_defined(
               assy: next_assembly_usage_occurrence
      ): BOOLEAN;

    LOCAL
      srr_set : SET OF shape_representation_relationship := [];
      sdr_set : SET OF shape_definition_representation := [];
    END_LOCAL;
    sdr_set := QUERY ( pdr <* bag_to_set(USEDIN(assy.
        related_product_definition,
        'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'DEFINITION.DEFINITION')) | (
        'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)) ) 
        + QUERY ( pdr <* bag_to_set(USEDIN(assy.related_product_definition,
        'SMCH_PLUS_203_SCHEMA.' + 
        'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION.' + 
        'DEFINITION.RELATED_PRODUCT_DEFINITION')) | (
        'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)) );
    IF SIZEOF(sdr_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,
            'SMCH_PLUS_203_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'))
             | ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN 
            TYPEOF(rr)) );
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
            IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
                representation_relationship.rep_1,
                'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
                 'USED_REPRESENTATION')) | (
                'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN 
                TYPEOF(pdr)) ) * QUERY ( pdr <* bag_to_set(USEDIN(assy.
                relating_product_definition,
                'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
                 'USED_REPRESENTATION.DEFINITION')) | (
                'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN 
                TYPEOF(pdr)) )) >= 1 THEN
              IF SIZEOF(QUERY ( cdsr <* USEDIN(assy,'SMCH_PLUS_203_SCHEMA.' 

                  + 'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + 
                  'REPRESENTED_PRODUCT_RELATION') | (NOT ((cdsr.
                  represented_product_relation.definition :=: assy) AND (
                  cdsr.representation_relation :=: srr_set[j]))) )) > 0
                   THEN
                RETURN(FALSE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);


  END_FUNCTION;



  FUNCTION unique_version_change_order(
               c: action
      ): BOOLEAN;

    LOCAL
      ords     : action_directive := c\directed_action.directive;
      assign   : SET OF change_request := [];
      versions : SET OF product_definition_formation := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
      assign := assign + QUERY ( ara <* bag_to_set(USEDIN(ords.requests[i],
          'SMCH_PLUS_203_SCHEMA.ACTION_REQUEST_ASSIGNMENT.' + 
          'ASSIGNED_ACTION_REQUEST')) | (
          'SMCH_PLUS_203_SCHEMA.CHANGE_REQUEST' IN TYPEOF(ara)) );

    END_REPEAT;
    REPEAT k := 1 TO SIZEOF(assign) BY 1;
      versions := versions + assign[k].items;
    END_REPEAT;
    RETURN(SIZEOF(QUERY ( vers <* versions | (NOT (SIZEOF(
        QUERY ( other_vers <* (versions - vers) | (vers.of_product :=: 
        other_vers.of_product) )) = 0)) )) = 0);


  END_FUNCTION;



  RULE acu_requires_security_classification FOR (assembly_component_usage, 
               cc_design_security_classification);

  WHERE
    wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | (NOT (SIZEOF(
             QUERY ( ccdsc <* cc_design_security_classification | (acu IN 
             ccdsc.items) )) = 1)) )) = 0);

  END_RULE;


(*this rule must be disabled to combine AP203 with other schemata
  
RULE application_context_requires_ap_definition FOR (application_context, 
             application_protocol_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
             QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
             application) AND (apd.
             application_interpreted_model_schema_name = 
             'config_control_design')) )) = 1)) )) = 0);

  END_RULE; -- application_context_requires_ap_definition

*)


  RULE approval_requires_approval_date_time FOR (approval, 
             approval_date_time);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( adt <* 
             approval_date_time | (app :=: adt.dated_approval) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE approval_requires_approval_person_organization FOR (approval, 
             approval_person_organization);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( apo <* 
             approval_person_organization | (app :=: apo.
             authorized_approval) )) >= 1)) )) = 0);

  END_RULE;



  RULE approvals_are_assigned FOR (approval, approval_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <* 
             approval_assignment | (app :=: aa.assigned_approval) )) >= 1)) )) 
             = 0);

  END_RULE;



  RULE as_required_quantity FOR (measure_with_unit);

  WHERE
    wr1: (SIZEOF(QUERY ( m <* measure_with_unit | ((
             'SMCH_PLUS_203_SCHEMA.DESCRIPTIVE_MEASURE' IN TYPEOF(m.

             value_component)) AND (NOT (m.value_component = 'as_required'))) )) 
             = 0);

  END_RULE;



  RULE certification_requires_approval FOR (certification, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (cert IN ccda.items) )) =
              1)) )) = 0);

  END_RULE;



  RULE certification_requires_date_time FOR (certification, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (cert IN
              ccdta.items) )) = 1)) )) = 0);

  END_RULE;



  RULE change_request_requires_approval FOR (change_request, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (cr IN ccda.items) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE change_request_requires_date_time FOR (change_request, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (cr IN 
             ccdta.items) )) = 1)) )) = 0);

  END_RULE;



  RULE change_request_requires_person_organization FOR (change_request, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccpoa <* cc_design_person_and_organization_assignment
              | (cr IN ccpoa.items) )) >= 1)) )) = 0);

  END_RULE;



  RULE change_requires_approval FOR (change, cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccda <* 
             cc_design_approval | (chg IN ccda.items) )) = 1)) )) = 0);

  END_RULE;



  RULE change_requires_date_time FOR (change, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccdta <* 
             cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND
              (ccdta.role.name = 'start_date')) )) = 1)) )) = 0);

  END_RULE;



  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE;



  RULE configuration_item_requires_approval FOR (configuration_item, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (ci IN ccda.items) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE configuration_item_requires_person_organization FOR (
             configuration_item, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (ci IN ccdpoa.items) )) = 1)) )) = 0);

  END_RULE;



  RULE contract_requires_approval FOR (contract, cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccda <* 
             cc_design_approval | (c IN ccda.items) )) = 1)) )) = 0);

  END_RULE;



  RULE contract_requires_person_organization FOR (contract, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccdpoa <* 
             cc_design_person_and_organization_assignment | (c IN ccdpoa.
             items) )) = 1)) )) = 0);

  END_RULE;



  RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);

  WHERE
    wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT 
             assembly_shape_is_defined(nauo)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_action_directive FOR (action_directive);

  WHERE
    wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT (SIZEOF(USEDIN(ad,
             '')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,
             '')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_certification_type FOR (certification_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,
             '')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_contract_type FOR (contract_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,'')) 
             >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_date FOR (date);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) )) 
             = 0);

  END_RULE;



  RULE dependent_instantiable_date_time_role FOR (date_time_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,
             '')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_document_type FOR (document_type);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,'')) 
             >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_named_unit FOR (named_unit);

  WHERE
    wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >=
              1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_parametric_representation_context FOR (
             parametric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (
             SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_person_and_organization_role FOR (
             person_and_organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( poar <* person_and_organization_role | (NOT (
             SIZEOF(USEDIN(poar,'')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_representation_item FOR (representation_item);

  WHERE
    wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(
             ri,'')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_security_classification_level FOR (
             security_classification_level);

  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (
             SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);

  END_RULE;



  RULE dependent_instantiable_shape_representation FOR (
             shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(
             sr,'')) >= 1)) )) = 0);

  END_RULE;



  RULE design_context_for_property FOR (product_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | ((SIZEOF(USEDIN(pd,
             'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION.DEFINITION') + 
             QUERY ( pdr <* USEDIN(pd,'SMCH_PLUS_203_SCHEMA.' + 
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
              | (SIZEOF(USEDIN(pdr,
             'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.' + 'DEFINITION')) >=
              1) )) >= 1) AND (NOT ('SMCH_PLUS_203_SCHEMA.DESIGN_CONTEXT' IN

              TYPEOF(pd.frame_of_reference)))) )) = 0);

  END_RULE;



  RULE dimensionality_is_two_or_three FOR (
             geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( g <* geometric_representation_context | (NOT ((g.
             coordinate_space_dimension = 2) OR (g.
             coordinate_space_dimension = 3))) )) = 0);

  END_RULE;



  RULE document_to_product_definition FOR (
             cc_design_specification_reference, product_definition);

  WHERE
    wr1: (SIZEOF(QUERY ( sp <* cc_design_specification_reference | (NOT ((
             (('SMCH_PLUS_203_SCHEMA.DOCUMENT_RELATIONSHIP.' + 
             'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
             assigned_document)) AND (SIZEOF(QUERY ( it <* sp.items | (NOT 
             ('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(it))) )) =
              0)) OR (NOT (('SMCH_PLUS_203_SCHEMA.DOCUMENT_RELATIONSHIP.' + 

             'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
             assigned_document))))) )) = 0);

  END_RULE;



  RULE drawing_sheet_layout_usage FOR (mapped_item);

  WHERE
    wr1: (SIZEOF(QUERY ( dsl <* QUERY ( mi <* mapped_item | (
             'ASSOC_DIM.DRAWING_SHEET_LAYOUT' IN TYPEOF(mi.mapping_source.
             mapped_representation)) ) | (NOT (SIZEOF(USEDIN(dsl,'')) = 
             SIZEOF(QUERY ( dsr <* USEDIN(dsl,'ASSOC_DIM.' + 
             'REPRESENTATION.ITEMS') | ('ASSOC_DIM.DRAWING_SHEET_REVISION' 
             IN TYPEOF(dsr)) )))) )) = 0);

  END_RULE;



  RULE effectivity_requires_approval FOR (effectivity, cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (eff IN ccda.items) )) = 
             1)) )) = 0);

  END_RULE;



  RULE geometric_representation_item_3d FOR (geometric_representation_item);

  WHERE
    wr1: (SIZEOF(QUERY ( gri <* geometric_representation_item | (NOT ((
             dimension_of(gri) = 3) OR (SIZEOF(bag_to_set(USEDIN(gri,'')) -
              bag_to_set(USEDIN(gri,
             'SMCH_PLUS_203_SCHEMA.DEFINITIONAL_REPRESENTATION.ITEMS'))) = 0))) )) 

             = 0);

  END_RULE;


(* This rule must be disabled to combine AP 203 with other schemata  
RULE global_unit_assignment FOR (global_unit_assigned_context);

  WHERE
    wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
             SIZEOF(guac.units) = 3)) )) = 0);
    wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
             SIZEOF(QUERY ( u <* guac.units | (
             'CCD_CLA_GVP_AST_ASD.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) AND (
             SIZEOF(QUERY ( u <* guac.units | (
             'CCD_CLA_GVP_AST_ASD.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) = 1) 
             AND (SIZEOF(QUERY ( u <* guac.units | (
             'CCD_CLA_GVP_AST_ASD.SOLID_ANGLE_UNIT' IN TYPEOF(u)) )) = 1))) )) 
             = 0);

  END_RULE; -- global_unit_assignment
*)


  RULE no_shape_for_make_from FOR (design_make_from_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( dmfr <* design_make_from_relationship | (NOT (
             SIZEOF(QUERY ( pd <* USEDIN(dmfr,'SMCH_PLUS_203_SCHEMA.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (
             'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) 

             = 0)) )) = 0);

  END_RULE;



  RULE no_shape_for_supplied_part FOR (supplied_part_relationship);

  WHERE
    wr1: (SIZEOF(QUERY ( spr <* supplied_part_relationship | (NOT (SIZEOF(
             QUERY ( pd <* USEDIN(spr,'SMCH_PLUS_203_SCHEMA.' + 
             'PROPERTY_DEFINITION.DEFINITION') | (
             'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) 

             = 0)) )) = 0);

  END_RULE;



  RULE product_concept_requires_configuration_item FOR (product_concept, 
             configuration_item);

  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(
             QUERY ( ci <* configuration_item | (pc :=: ci.item_concept) )) 
             >= 1)) )) = 0);

  END_RULE;



  RULE product_definition_requires_approval FOR (product_definition, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (pd IN ccda.items) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE product_definition_requires_date_time FOR (product_definition, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (pd IN 
             ccdta.items) )) = 1)) )) = 0);

  END_RULE;



  RULE product_definition_requires_person_organization FOR (
             product_definition, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (pd IN ccdpoa.items) )) = 1)) )) = 0);

  END_RULE;



  RULE product_requires_person_organization FOR (product, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( ccdpoa <* 
             cc_design_person_and_organization_assignment | (prod IN ccdpoa
             .items) )) = 1)) )) = 0);

  END_RULE;



  RULE product_requires_product_category FOR (product, 
             product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* 
             product_related_product_category | ((prod IN prpc.products) 
             AND (prpc.name IN ['assembly','inseparable_assembly','detail',
             'customer_furnished_equipment'])) )) = 1)) )) = 0);

  END_RULE;



  RULE product_requires_version FOR (product, product_definition_formation);

  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <* 
             product_definition_formation | (prod :=: pdf.of_product) )) >=
              1)) )) = 0);

  END_RULE;



  RULE product_version_requires_approval FOR (product_definition_formation, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccda <* cc_design_approval | (pdf IN ccda.items) )) 
             = 1)) )) = 0);

  END_RULE;



  RULE product_version_requires_person_organization FOR (
             product_definition_formation, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdpoa <* 
             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa
             .items) AND (ccdpoa.role.name = 'creator')) )) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdpoa <* 
             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa
             .items) AND (ccdpoa.role.name IN ['design_supplier',
             'part_supplier'])) )) >= 1)) )) = 0);

  END_RULE;



  RULE product_version_requires_security_classification FOR (
             product_definition_formation, 
             cc_design_security_classification);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdsc <* cc_design_security_classification | (
             pdf IN ccdsc.items) )) = 1)) )) = 0);

  END_RULE;



  RULE restrict_action_request_status FOR (action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status 
             IN ['proposed','in_work','issued','hold'])) )) = 0);

  END_RULE;



  RULE restrict_approval_status FOR (approval_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [
             'approved','not_yet_approved','disapproved','withdrawn'])) )) 
             = 0);

  END_RULE;



  RULE restrict_certification_type FOR (certification_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (ct.description 
             IN ['design_supplier','part_supplier'])) )) = 0);

  END_RULE;



  RULE restrict_contract_type FOR (contract_type);

  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (ct.description IN [
             'fixed_price','cost_plus'])) )) = 0);

  END_RULE;



  RULE restrict_date_time_role FOR (date_time_role);

  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (dtr.name IN [
             'creation_date','request_date','release_date','start_date',
             'contract_date','certification_date','sign_off_date',
             'classification_date','declassification_date'])) )) = 0);

  END_RULE;



  RULE restrict_document_type FOR (document_type);

  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (dt.product_data_type 
             IN ['material_specification','process_specification',
             'design_specification','surface_finish_specification',
             'cad_filename','drawing'])) )) = 0);

  END_RULE;



  RULE restrict_drawing FOR (drawing_revision);

  WHERE
    wr1 : (SIZEOF(QUERY ( dr <* drawing_revision | ((SIZEOF(dr.areas) = 0) 
              OR (SIZEOF(QUERY ( ais <* dr.areas | (NOT (
              'ASSOC_DIM.DRAWING_SHEET_REVISION' IN TYPEOF(ais.area))) )) >
               0)) )) = 0);
    wr2 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(USEDIN(dr,
              'ASSOC_DIM.' + 'DRAUGHTING_TITLE.ITEMS')) > 1) )) = 0);
    wr3 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(USEDIN(ais.area,'ASSOC_DIM.' + 
              'DRAUGHTING_TITLE.ITEMS')) > 1) )) > 0) )) = 0);
    wr4 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( item <* ais.area.items | (SIZEOF(
              TYPEOF(item) * ['ASSOC_DIM.STYLED_ITEM',
              'ASSOC_DIM.MAPPED_ITEM','ASSOC_DIM.AXIS2_PLACEMENT',
              'ASSOC_DIM.PLANAR_BOX']) <> 1) )) > 0) )) > 0) )) = 0);
    wr5 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( item <* ais.area.items | (SIZEOF(
              TYPEOF(item) * ['ASSOC_DIM.STYLED_ITEM',
              'ASSOC_DIM.MAPPED_ITEM']) = 0) )) > 0) )) > 0) )) = 0);
    wr6 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( p_b <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.PLANAR_BOX' IN TYPEOF(item)) ) | (SIZEOF(
              USEDIN(p_b,'ASSOC_DIM.' + 'PRESENTATION_SIZE.SIZE')) <> 1) )) 
              > 0) )) > 0) )) = 0);
    wr7 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item)) ) | (
              'ASSOC_DIM.PRESENTATION_VIEW' IN TYPEOF(mi\mapped_item.
              mapping_source.mapped_representation)) )) = 0) )) > 0) )) = 0);
    wr8 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( a2p <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.AXIS2_PLACEMENT' IN TYPEOF(item)) ) | (
              SIZEOF(USEDIN(a2p,'ASSOC_DIM.' + 'MAPPED_ITEM.MAPPING_TARGET')) 
              = 0) )) > 0) )) > 0) )) = 0);
    wr9 : (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(ais.area.context_of_items.
              representations_in_context) > 1) )) > 0) )) = 0);
    wr10: (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item)) ) | (
              SIZEOF(USEDIN(mi\mapped_item.mapping_source.
              mapped_representation,'ASSOC_DIM.' + 
              'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) <> 1) )) > 0) )) 
              > 0) )) = 0);
    wr11: (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item)) ) | (
              SIZEOF(QUERY ( pv_item <* mi\mapped_item.mapping_source.
              mapped_representation.items | (SIZEOF(TYPEOF(pv_item) * [
              'ASSOC_DIM.STYLED_ITEM','ASSOC_DIM.CAMERA_IMAGE',
              'ASSOC_DIM.AXIS2_PLACEMENT']) <> 1) )) > 0) )) > 0) )) > 0) )) 
              = 0);
    wr12: (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item)) ) | (
              SIZEOF(QUERY ( a2p <* QUERY ( pv_item <* mi\mapped_item.
              mapping_source.mapped_representation.items | (
              'ASSOC_DIM.AXIS2_PLACEMENT' IN TYPEOF(pv_item)) ) | (SIZEOF(
              QUERY ( rm <* USEDIN(a2p,'ASSOC_DIM.' + 
              'REPRESENTATION_MAP.MAPPING_ORIGIN') | (SIZEOF(QUERY ( mi <* 
              QUERY ( item <* ais.area.items | ('ASSOC_DIM.MAPPED_ITEM' IN 
              TYPEOF(item)) ) | (mi\mapped_item.mapping_source :=: rm) )) >
               0) )) = 1) )) <> 1) )) > 0) )) > 0) )) = 0);
    wr13: (SIZEOF(QUERY ( dr <* drawing_revision | (SIZEOF(QUERY ( ais <* 
              dr.areas | (SIZEOF(QUERY ( mi <* QUERY ( item <* ais.area.
              items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item)) ) | (
              SIZEOF(mi\mapped_item.mapping_source.mapped_representation.
              context_of_items.representations_in_context) <> 1) )) > 0) )) 
              > 0) )) = 0);

  END_RULE;



  RULE restrict_person_organization_role FOR (person_and_organization_role);

  WHERE
    wr1: (SIZEOF(QUERY ( por <* person_and_organization_role | (NOT (por.
             name IN ['request_recipient','initiator','part_supplier',
             'design_supplier','configuration_manager','contractor',
             'classification_officer','creator','design_owner'])) )) = 0);

  END_RULE;



  RULE restrict_product_category_value FOR (
             product_related_product_category);

  WHERE
    wr1: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (
             prpc.name IN ['assembly','detail',
             'customer_furnished_equipment','inseparable_assembly','cast',
             'coined','drawn','extruded','forged','formed','machined',
             'molded','rolled','sheared'])) )) = 0);

  END_RULE;



  RULE restrict_security_classification_level FOR (
             security_classification_level);

  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (scl.
             name IN ['unclassified','classified','proprietary',
             'confidential','secret','top_secret'])) )) = 0);

  END_RULE;



  RULE security_classification_optional_date_time FOR (
             security_classification, cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN 
             ccdta.items) AND ('declassification_date' = ccdta.role.name)) )) 
             <= 1)) )) = 0);

  END_RULE;



  RULE security_classification_requires_approval FOR (
             security_classification, cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (sc IN ccda.items) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE security_classification_requires_date_time FOR (
             security_classification, cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN 
             ccdta.items) AND ('classification_date' = ccdta.role.name)) )) 
             = 1)) )) = 0);

  END_RULE;



  RULE security_classification_requires_person_organization FOR (
             security_classification, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (sc IN ccdpoa.items) )) = 1)) )) = 0);

  END_RULE;



  RULE sheets_belong_to_one_drawing FOR (drawing_sheet_revision, 
             drawing_sheet_revision_usage);

  WHERE
    wr1: (SIZEOF(QUERY ( dsr <* drawing_sheet_revision | (NOT (SIZEOF(
             QUERY ( usage <* drawing_sheet_revision_usage | (dsr :=: usage
             .area) )) = 1)) )) = 0);

  END_RULE;



  RULE start_request_requires_approval FOR (start_request, 
             cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (sr IN ccda.items) )) = 1)) )) 
             = 0);

  END_RULE;



  RULE start_request_requires_date_time FOR (start_request, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (sr IN 
             ccdta.items) )) = 1)) )) = 0);

  END_RULE;



  RULE start_request_requires_person_organization FOR (start_request, 
             cc_design_person_and_organization_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (sr IN ccdpoa.items) )) >= 1)) )) = 0);

  END_RULE;



  RULE start_work_requires_approval FOR (start_work, cc_design_approval);

  WHERE
    wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccda <* 
             cc_design_approval | (sw IN ccda.items) )) = 1)) )) = 0);

  END_RULE;



  RULE start_work_requires_date_time FOR (start_work, 
             cc_design_date_and_time_assignment);

  WHERE
    wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccdta <* 
             cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND 
             (ccdta.role.name = 'start_date')) )) = 1)) )) = 0);

  END_RULE;



  RULE subtype_mandatory_action FOR (action);

  WHERE
    wr1: (SIZEOF(QUERY ( act <* action | (NOT (
             'SMCH_PLUS_203_SCHEMA.DIRECTED_ACTION' IN TYPEOF(act))) )) = 0);


  END_RULE;



  RULE subtype_mandatory_effectivity FOR (effectivity);

  WHERE
    wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT ((SIZEOF([
             'SMCH_PLUS_203_SCHEMA.SERIAL_NUMBERED_EFFECTIVITY',
             'SMCH_PLUS_203_SCHEMA.LOT_EFFECTIVITY',
             'SMCH_PLUS_203_SCHEMA.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1) 
             AND ('SMCH_PLUS_203_SCHEMA.CONFIGURATION_EFFECTIVITY' IN 

             TYPEOF(eff)))) )) = 0);

  END_RULE;



  RULE subtype_mandatory_product_context FOR (product_context);

  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_context | (NOT (
             'SMCH_PLUS_203_SCHEMA.MECHANICAL_CONTEXT' IN TYPEOF(pc))) )) = 

             0);

  END_RULE;



  RULE subtype_mandatory_product_definition_formation FOR (
             product_definition_formation);

  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             'SMCH_PLUS_203_SCHEMA.' + 

             'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN 
             TYPEOF(pdf))) )) = 0);

  END_RULE;



  RULE subtype_mandatory_product_definition_usage FOR (
             product_definition_usage);

  WHERE
    wr1: (SIZEOF(QUERY ( pdu <* product_definition_usage | (NOT ((
             'SMCH_PLUS_203_SCHEMA.' + 'ASSEMBLY_COMPONENT_USAGE') IN 

             TYPEOF(pdu))) )) = 0);

  END_RULE;


(*this rule must be disabled to combine AP 203 with other schemata
  
RULE subtype_mandatory_representation FOR (representation);

  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | (NOT (
             'CCD_CLA_GVP_AST_ASD.SHAPE_REPRESENTATION' IN TYPEOF(rep))) )) 
             = 0);

  END_RULE; -- subtype_mandatory_representation

*)


  RULE subtype_mandatory_representation_context FOR (
             representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( rep_cntxt <* representation_context | (NOT (
             'SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN 

             TYPEOF(rep_cntxt))) )) = 0);

  END_RULE;


(*this rule must be disabled to combine AP 203 with other schemata  
RULE subtype_mandatory_shape_representation FOR (shape_representation);

  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([
             'CCD_CLA_GVP_AST_ASD.' + 'ADVANCED_BREP_SHAPE_REPRESENTATION',
             'CCD_CLA_GVP_AST_ASD.FACETED_BREP_SHAPE_REPRESENTATION',
             'CCD_CLA_GVP_AST_ASD.MANIFOLD_SURFACE_SHAPE_REPRESENTATION','CCD_CLA_GVP_AST_ASD.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION','CCD_CLA_GVP_AST_ASD.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'CCD_CLA_GVP_AST_ASD.' + 
             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
             'CCD_CLA_GVP_AST_ASD.' + 
             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] * 
             TYPEOF(sr)) = 1) OR (SIZEOF(QUERY ( it <* sr\representation.
             items | (NOT ('CCD_CLA_GVP_AST_ASD.AXIS2_PLACEMENT_3D' IN 
             TYPEOF(it))) )) = 0) OR (SIZEOF(QUERY ( sdr <* QUERY ( pdr <* 
             USEDIN(sr,
             'CCD_CLA_GVP_AST_ASD.PROPERTY_DEFINITION_REPRESENTATION.' + 
             'USED_REPRESENTATION') | (
             'CCD_CLA_GVP_AST_ASD.SHAPE_DEFINITION_REPRESENTATION' IN 
             TYPEOF(pdr)) ) | (NOT (SIZEOF([
             'CCD_CLA_GVP_AST_ASD.SHAPE_ASPECT',
             'CCD_CLA_GVP_AST_ASD.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(sdr.
             definition)) = 1)) )) = 0))) )) = 0);

  END_RULE; -- subtype_mandatory_shape_representation

*)


  RULE unique_version_change_order_rule FOR (change);

  WHERE
    wr1: (SIZEOF(QUERY ( c <* change | (NOT unique_version_change_order(c.
             assigned_action)) )) = 0);

  END_RULE;



  RULE versioned_action_request_requires_solution FOR (
             versioned_action_request, action_request_solution);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_solution | (ar :=: ars.request) )) 
             >= 1)) )) = 0);

  END_RULE;



  RULE versioned_action_request_requires_status FOR (
             versioned_action_request, action_request_status);

  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_status | (ar :=: ars.
             assigned_request) )) = 1)) )) = 0);

  END_RULE;


END_SCHEMA;




90


