<?xml version='1.0' encoding='UTF-8'?>
<!-- $Id: express2xml.js,v 1.34 2004/05/06 21:27:27 thendrix Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml2.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.34"
    source="../data/reference/cax_if/ap203_smch_may3_lf.exp"/>

  <schema name="smch_plus_203_schema">

    <constant name="dummy_gri"
      expression="representation_item('') || geometric_representation_item()">
      <typename
        name="geometric_representation_item"/>
    </constant>

    <constant name="dummy_tri"
      expression="representation_item('')|| topological_representation_item()">
      <typename
        name="topological_representation_item"/>
    </constant>

    <type name="ahead_or_behind">
      <enumeration
        items="ahead exact behind">
      </enumeration>
    </type>

    <type name="approved_item">
      <select
        selectitems="product_definition_formation product_definition configuration_effectivity configuration_item security_classification change_request change start_request start_work certification contract">
      </select>
    </type>

    <type name="area_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="area_or_view">
      <select
        selectitems="presentation_area presentation_view">
      </select>
    </type>

    <type name="attribute_type">
      <select
        selectitems="label text">
      </select>
    </type>

    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>
    </type>

    <type name="b_spline_curve_form">
      <enumeration
        items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified">
      </enumeration>
    </type>

    <type name="b_spline_surface_form">
      <enumeration
        items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified">
      </enumeration>
    </type>

    <type name="boolean_operand">
      <select
        selectitems="solid_model">
      </select>
    </type>

    <type name="box_characteristic_select">
      <select
        selectitems="box_height box_width box_slant_angle box_rotate_angle">
      </select>
    </type>

    <type name="box_height">
      <typename
        name="positive_ratio_measure"/>
    </type>

    <type name="box_rotate_angle">
      <typename
        name="plane_angle_measure"/>
    </type>

    <type name="box_slant_angle">
      <typename
        name="plane_angle_measure"/>
    </type>

    <type name="box_width">
      <typename
        name="positive_ratio_measure"/>
    </type>

    <type name="central_or_parallel">
      <enumeration
        items="central parallel">
      </enumeration>
    </type>

    <type name="certified_item">
      <select
        selectitems="supplied_part_relationship">
      </select>
    </type>

    <type name="change_request_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="character_spacing_select">
      <select
        selectitems="length_measure ratio_measure measure_with_unit descriptive_measure">
      </select>
    </type>

    <type name="character_style_select">
      <select
        selectitems="text_style_for_defined_font">
      </select>
    </type>

    <type name="characterized_definition">
      <select
        selectitems="characterized_product_definition shape_definition">
      </select>
    </type>

    <type name="characterized_product_definition">
      <select
        selectitems="product_definition product_definition_relationship">
      </select>
    </type>

    <type name="classified_item">
      <select
        selectitems="product_definition_formation assembly_component_usage">
      </select>
    </type>

    <type name="configuration_design_item">
      <select
        selectitems="product_definition product_definition_formation">
      </select>
    </type>

    <type name="context_dependent_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="contracted_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="count_measure">
      <builtintype
        type="NUMBER">
      </builtintype>
    </type>

    <type name="curve_font_or_scaled_curve_font_select">
      <select
        selectitems="curve_style_font_select">
      </select>
    </type>

    <type name="curve_on_surface">
      <select
        selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>
    </type>

    <type name="curve_or_annotation_curve_occurrence">
      <select
        selectitems="curve annotation_curve_occurrence">
      </select>
    </type>

    <type name="curve_or_render">
      <select
        selectitems="curve_style">
      </select>
    </type>

    <type name="curve_style_font_select">
      <select
        selectitems="curve_style_font pre_defined_curve_font externally_defined_curve_font">
      </select>
    </type>

    <type name="date_time_item">
      <select
        selectitems="product_definition change_request start_request change start_work approval_person_organization contract security_classification certification">
      </select>
    </type>

    <type name="date_time_or_event_occurrence">
      <select
        selectitems="date_time_select">
      </select>
    </type>

    <type name="date_time_select">
      <select
        selectitems="date local_time date_and_time">
      </select>
    </type>

    <type name="day_in_month_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((1 &lt;= SELF) AND (SELF &lt;= 31))">
      </where>
    </type>

    <type name="day_in_week_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((1 &lt;= SELF) AND (SELF &lt;= 7))">
      </where>
    </type>

    <type name="day_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((1 &lt;= SELF) AND (SELF &lt;= 366))">
      </where>
    </type>

    <type name="defined_symbol_select">
      <select
        selectitems="pre_defined_symbol externally_defined_symbol">
      </select>
    </type>

    <type name="derived_property_select">
      <select
        selectitems="property_definition">
      </select>
    </type>

    <type name="description_attribute_select">
      <select
        selectitems="action_request_solution application_context approval_role configuration_design date_time_role context_dependent_shape_representation effectivity external_source person_and_organization_role person_and_organization property_definition_representation representation">
      </select>
    </type>

    <type name="descriptive_measure">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="(SELF &gt; 0)">
      </where>
    </type>

    <type name="dimension_extent_usage">
      <enumeration
        items="origin target">
      </enumeration>
    </type>

    <type name="dimensional_characteristic">
      <select
        selectitems="dimensional_location">
      </select>
    </type>

    <type name="direction_count_select">
      <select
        selectitems="u_direction_count v_direction_count">
      </select>
    </type>

    <type name="draughting_callout_element">
      <select
        selectitems="annotation_text_occurrence annotation_symbol_occurrence annotation_curve_occurrence">
      </select>
    </type>

    <type name="draughting_titled_item">
      <select
        selectitems="drawing_revision drawing_sheet_revision">
      </select>
    </type>

    <type name="fill_style_select">
      <select
        selectitems="fill_area_style_colour">
      </select>
    </type>

    <type name="font_select">
      <select
        selectitems="pre_defined_text_font">
      </select>
    </type>

    <type name="founded_item_select">
      <select
        selectitems="founded_item representation_item">
      </select>
    </type>

    <type name="geometric_set_select">
      <select
        selectitems="point curve surface">
      </select>
    </type>

    <type name="hiding_or_blanking_select">
      <select
        selectitems="presentation_area presentation_view annotation_fill_area">
      </select>
    </type>

    <type name="hour_in_day">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((0 &lt;= SELF) AND (SELF &lt; 24))">
      </where>
    </type>

    <type name="id_attribute_select">
      <select
        selectitems="action application_context organizational_project representation">
      </select>
    </type>

    <type name="identifier">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="invisibility_context">
      <select
        selectitems="presentation_representation presentation_set">
      </select>
    </type>

    <type name="invisible_item">
      <select
        selectitems="styled_item presentation_layer_assignment presentation_representation">
      </select>
    </type>

    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified">
      </enumeration>
    </type>

    <type name="label">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="layered_item">
      <select
        selectitems="presentation_representation representation_item">
      </select>
    </type>

    <type name="length_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="list_of_reversible_topology_item">
      <aggregate
        type="LIST"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>
    </type>

    <type name="marker_select">
      <select
        selectitems="marker_type pre_defined_marker">
      </select>
    </type>

    <type name="marker_type">
      <enumeration
        items="dot x plus asterisk ring square triangle">
      </enumeration>
    </type>

    <type name="mass_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="measure_value">
      <select
        selectitems="length_measure mass_measure plane_angle_measure solid_angle_measure area_measure volume_measure ratio_measure parameter_value context_dependent_measure descriptive_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure count_measure">
      </select>
    </type>

    <type name="minute_in_hour">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((0 &lt;= SELF) AND (SELF &lt;= 59))">
      </where>
    </type>

    <type name="month_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((1 &lt;= SELF) AND (SELF &lt;= 12))">
      </where>
    </type>

    <type name="name_attribute_select">
      <select
        selectitems="action_request_solution configuration_design context_dependent_shape_representation derived_unit effectivity person_and_organization product_definition property_definition_representation">
      </select>
    </type>

    <type name="parameter_value">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="pcurve_or_surface">
      <select
        selectitems="pcurve surface">
      </select>
    </type>

    <type name="person_organization_item">
      <select
        selectitems="change start_work change_request start_request configuration_item product product_definition_formation product_definition contract security_classification">
      </select>
    </type>

    <type name="person_organization_select">
      <select
        selectitems="person organization person_and_organization">
      </select>
    </type>

    <type name="plane_angle_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="positive_length_measure">
      <typename
        name="length_measure"/>
      <where
        label="wr1"
        expression="(SELF &gt; 0)">
      </where>
    </type>

    <type name="positive_plane_angle_measure">
      <typename
        name="plane_angle_measure"/>
      <where
        label="wr1"
        expression="(SELF &gt; 0)">
      </where>
    </type>

    <type name="positive_ratio_measure">
      <typename
        name="ratio_measure"/>
      <where
        label="wr1"
        expression="(SELF &gt; 0)">
      </where>
    </type>

    <type name="preferred_surface_curve_representation">
      <enumeration
        items="curve_3d pcurve_s1 pcurve_s2">
      </enumeration>
    </type>

    <type name="presentable_text">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="presentation_representation_select">
      <select
        selectitems="presentation_representation presentation_set">
      </select>
    </type>

    <type name="presentation_size_assignment_select">
      <select
        selectitems="presentation_view presentation_area area_in_set">
      </select>
    </type>

    <type name="presentation_style_select">
      <select
        selectitems="point_style curve_style surface_style_usage symbol_style fill_area_style text_style">
      </select>
    </type>

    <type name="presented_item_select">
      <select
        selectitems="product_definition">
      </select>
    </type>

    <type name="product_or_formation_or_definition">
      <select
        selectitems="product product_definition_formation product_definition">
      </select>
    </type>

    <type name="ratio_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="represented_definition">
      <select
        selectitems="property_definition shape_aspect shape_aspect_relationship">
      </select>
    </type>

    <type name="reversible_topology">
      <select
        selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item">
      </select>
    </type>

    <type name="reversible_topology_item">
      <select
        selectitems="edge path face face_bound closed_shell open_shell">
      </select>
    </type>

    <type name="role_select">
      <select
        selectitems="action_assignment action_request_assignment approval_assignment approval_date_time certification_assignment contract_assignment document_reference security_classification_assignment">
      </select>
    </type>

    <type name="second_in_minute">
      <builtintype
        type="REAL">
      </builtintype>
      <where
        label="wr1"
        expression="((0 &lt;= SELF) AND (SELF &lt;= 60))">
      </where>
    </type>

    <type name="set_of_reversible_topology_item">
      <aggregate
        type="SET"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>
    </type>

    <type name="shape_definition">
      <select
        selectitems="product_definition_shape shape_aspect shape_aspect_relationship">
      </select>
    </type>

    <type name="shell">
      <select
        selectitems="vertex_shell wire_shell open_shell closed_shell">
      </select>
    </type>

    <type name="si_prefix">
      <enumeration
        items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto">
      </enumeration>
    </type>

    <type name="si_unit_name">
      <enumeration
        items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_celsius lumen lux becquerel gray sievert">
      </enumeration>
    </type>

    <type name="size_select">
      <select
        selectitems="positive_length_measure measure_with_unit descriptive_measure">
      </select>
    </type>

    <type name="solid_angle_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="source">
      <enumeration
        items="made bought not_known">
      </enumeration>
    </type>

    <type name="source_item">
      <select
        selectitems="identifier">
      </select>
    </type>

    <type name="specified_item">
      <select
        selectitems="product_definition shape_aspect">
      </select>
    </type>

    <type name="start_request_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="style_context_select">
      <select
        selectitems="representation representation_item presentation_set">
      </select>
    </type>

    <type name="supported_item">
      <select
        selectitems="action_directive action action_method">
      </select>
    </type>

    <type name="surface_boundary">
      <select
        selectitems="boundary_curve degenerate_pcurve">
      </select>
    </type>

    <type name="surface_model">
      <select
        selectitems="shell_based_surface_model">
      </select>
    </type>

    <type name="surface_side">
      <enumeration
        items="positive negative both">
      </enumeration>
    </type>

    <type name="surface_side_style_select">
      <select
        selectitems="surface_side_style">
      </select>
    </type>

    <type name="surface_style_element_select">
      <select
        selectitems="surface_style_fill_area surface_style_boundary surface_style_silhouette surface_style_segmentation_curve surface_style_control_grid surface_style_parameter_line">
      </select>
    </type>

    <type name="symbol_style_select">
      <select
        selectitems="symbol_colour">
      </select>
    </type>

    <type name="terminator">
      <select
        selectitems="externally_defined_terminator_symbol pre_defined_terminator_symbol user_defined_terminator_symbol">
      </select>
    </type>

    <type name="text">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="text_alignment">
      <typename
        name="label"/>
    </type>

    <type name="text_or_character">
      <select
        selectitems="annotation_text composite_text text_literal">
      </select>
    </type>

    <type name="text_path">
      <enumeration
        items="left right up down">
      </enumeration>
    </type>

    <type name="tolerance_method_definition">
      <select
        selectitems="tolerance_value">
      </select>
    </type>

    <type name="tolerance_select">
      <select
        selectitems="plus_minus_tolerance">
      </select>
    </type>

    <type name="transformation">
      <select
        selectitems="item_defined_transformation functionally_defined_transformation">
      </select>
    </type>

    <type name="transition_code">
      <enumeration
        items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature">
      </enumeration>
    </type>

    <type name="trimming_preference">
      <enumeration
        items="cartesian parameter unspecified">
      </enumeration>
    </type>

    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value">
      </select>
    </type>

    <type name="u_direction_count">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="(SELF &gt; 1)">
      </where>
    </type>

    <type name="unit">
      <select
        selectitems="named_unit derived_unit">
      </select>
    </type>

    <type name="v_direction_count">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="(SELF &gt; 1)">
      </where>
    </type>

    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>
    </type>

    <type name="volume_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="week_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="wr1"
        expression="((1 &lt;= SELF) AND (SELF &lt;= 53))">
      </where>
    </type>

    <type name="wireframe_model">
      <select
        selectitems="shell_based_wireframe_model edge_based_wireframe_model">
      </select>
    </type>

    <type name="work_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
    </type>

    <type name="boolean_operator">
      <enumeration
        items="union intersection difference">
      </enumeration>
    </type>

    <type name="characterized_action_definition">
      <select
        selectitems="action action_method">
      </select>
    </type>

    <type name="characterized_material_property">
      <select
        selectitems="material_property_representation">
      </select>
    </type>

    <type name="compound_item_definition">
      <select
        selectitems="list_representation_item set_representation_item">
      </select>
    </type>

    <type name="csg_primitive">
      <select
        selectitems="sphere ellipsoid block right_angular_wedge faceted_primitive rectangular_pyramid torus right_circular_cone eccentric_cone right_circular_cylinder cyclide_segment_solid primitive_2d">
      </select>
    </type>

    <type name="csg_select">
      <select
        selectitems="boolean_result csg_primitive">
      </select>
    </type>

    <type name="document_reference_item">
      <select
        selectitems="property_definition">
      </select>
    </type>

    <type name="group_item">
      <select
        selectitems="instanced_feature">
      </select>
    </type>

    <type name="list_representation_item">
      <aggregate
        type="LIST"
        lower="1"
        upper="?"/>
      <typename
        name="representation_item"/>
    </type>

    <type name="property_or_shape_select">
      <select
        selectitems="property_definition shape_definition">
      </select>
    </type>

    <type name="set_representation_item">
      <aggregate
        type="SET"
        lower="1"
        upper="?"/>
      <typename
        name="representation_item"/>
    </type>

    <type name="shape_representation_item">
      <select
        selectitems="geometric_representation_item topological_representation_item solid_model surface_model wireframe_model">
      </select>
    </type>

    <type name="value_qualifier">
      <select
        selectitems="precision_qualifier type_qualifier uncertainty_qualifier">
      </select>
    </type>

    <entity
      name="action">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="chosen_method">
        <typename
          name="action_method"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="action_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_action">
        <typename
          name="action"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="action_directive">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="analysis">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="comment">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="requests">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_method">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="consequence">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="action_request_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_action_request">
        <typename
          name="versioned_action_request"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="action_request_solution">
      <explicit
        name="method">
        <typename
          name="action_method"/>
      </explicit>
      <explicit
        name="request">
        <typename
          name="versioned_action_request"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="action_request_status">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="assigned_request">
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_status">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="assigned_action">
        <typename
          name="executed_action"/>
      </explicit>
    </entity>

    <entity
      name="address">
      <explicit
        name="internal_location"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_box"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="town"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="region"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_code"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="country"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="facsimile_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telephone_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="electronic_mail_address"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telex_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <where
        label="wr1"
        expression="(EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number))">
      </where>
    </entity>

    <entity
      name="advanced_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* SELF.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP','SMCH_PLUS_203_SCHEMA.FACETED_BREP','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* SELF.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt; 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (msb &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| (NOT (SIZEOF(QUERY (csh &lt;* msb_shells(msb,'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY (csf &lt;* csh. cfs_faces | (NOT ('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(csf))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (msb &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (brv &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (csh &lt;* brv\brep_with_voids.voids | csh\ oriented_closed_shell.orientation)) = 0)))) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it))) | (NOT ('SMCH_PLUS_203_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))))= 0)">
      </where>
    </entity>

    <entity
      name="advanced_face"
      supertypes="face_surface">
      <where
        label="wr1"
        expression="(SIZEOF(['SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE','SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE','SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE'] * TYPEOF(face_geometry))= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (bnd &lt;* bounds | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.EDGE_LOOP','SMCH_PLUS_203_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd)) = 1)))) =0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) | (NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | (NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe. edge_element))))) = 0)))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) | (NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | (NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe. edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end)))))) = 0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) | (NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.LINE','SMCH_PLUS_203_SCHEMA.CONIC','SMCH_PLUS_203_SCHEMA.POLYLINE','SMCH_PLUS_203_SCHEMA.PCURVE','SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe. edge_element\edge_curve.edge_geometry)) = 1)))) = 0)))) =0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) | (NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound))))) = 0)">
      </where>
      <where
        label="wr7"
        expression="((NOT ('SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE' IN TYPEOF(face_geometry))) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.LINE','SMCH_PLUS_203_SCHEMA.CONIC','SMCH_PLUS_203_SCHEMA.POLYLINE','SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(face_geometry\swept_surface.swept_curve)) = 1))">
      </where>
      <where
        label="wr8"
        expression="(SIZEOF(QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| (NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds.bound\vertex_loop.loop_vertex)) AND ('SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds. bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))))= 0)">
      </where>
    </entity>

    <entity
      name="alternate_product_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="definition"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="alternate">
        <typename
          name="product"/>
      </explicit>
      <explicit
        name="base">
        <typename
          name="product"/>
      </explicit>
      <explicit
        name="basis">
        <typename
          name="text"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="alternate"/>
        <unique.attribute
          attribute="base"/>
      </unique>
      <where
        label="wr1"
        expression="(alternate :&lt;&gt;: base)">
      </where>
    </entity>

    <entity
      name="annotation_curve_occurrence"
      supertypes="annotation_occurrence">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(SELF\styled_item.item))">
      </where>
    </entity>

    <entity
      name="annotation_fill_area"
      supertypes="geometric_representation_item">
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="curve"/>
      </explicit>
    </entity>

    <entity
      name="annotation_occurrence"
      super.expression="(ONEOF ( ANNOTATION_CURVE_OCCURRENCE, ANNOTATION_TEXT_OCCURRENCE, ANNOTATION_SYMBOL_OCCURRENCE))"
      supertypes="styled_item">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="annotation_occurrence_associativity"
      supertypes="annotation_occurrence_relationship">
      <where
        label="wr1"
        expression="(SIZEOF(TYPEOF(SELF.related_annotation_occurrence) * ['SMCH_PLUS_203_SCHEMA.ANNOTATION_FILL_AREA_OCCURRENCE','SMCH_PLUS_203_SCHEMA.PROJECTION_CURVE','SMCH_PLUS_203_SCHEMA.LEADER_CURVE']) = 1)">
      </where>
    </entity>

    <entity
      name="annotation_occurrence_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_annotation_occurrence">
        <typename
          name="annotation_occurrence"/>
      </explicit>
      <explicit
        name="related_annotation_occurrence">
        <typename
          name="annotation_occurrence"/>
      </explicit>
    </entity>

    <entity
      name="annotation_symbol_occurrence"
      supertypes="annotation_occurrence">
      <where
        label="wr1"
        expression="(SIZEOF(['SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL','SMCH_PLUS_203_SCHEMA.DEFINED_SYMBOL'] * TYPEOF(SELF\ styled_item.item)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="annotation_text"
      supertypes="mapped_item">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF(SELF\ mapped_item.mapping_target))">
      </where>
      <where
        label="wr2"
        expression="('SMCH_PLUS_203_SCHEMA.TEXT_STRING_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation))">
      </where>
      <where
        label="wr3"
        expression="('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="annotation_text_occurrence"
      supertypes="annotation_occurrence">
      <where
        label="wr1"
        expression="(SIZEOF(['SMCH_PLUS_203_SCHEMA.TEXT_LITERAL','SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT','SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_CHARACTER','SMCH_PLUS_203_SCHEMA.DEFINED_CHARACTER_GLYPH','SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT'] * TYPEOF(SELF\ styled_item.item)) &gt; 0)">
      </where>
    </entity>

    <entity
      name="application_context">
      <explicit
        name="application">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <inverse
        name="context_elements"
        entity="application_context_element"
        attribute="frame_of_reference">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="application_context_element"
      super.expression="(ONEOF ( PRODUCT_CONCEPT_CONTEXT, PRODUCT_CONTEXT, PRODUCT_DEFINITION_CONTEXT))">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="application_protocol_definition">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="application_interpreted_model_schema_name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="application_protocol_year">
        <typename
          name="year_number"/>
      </explicit>
      <explicit
        name="application">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="applied_presented_item"
      supertypes="presented_item">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="presented_item_select"/>
      </explicit>
    </entity>

    <entity
      name="approval">
      <explicit
        name="status">
        <typename
          name="approval_status"/>
      </explicit>
      <explicit
        name="level">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="approval_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_approval">
        <typename
          name="approval"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="approval_date_time">
      <explicit
        name="date_time">
        <typename
          name="date_time_select"/>
      </explicit>
      <explicit
        name="dated_approval">
        <typename
          name="approval"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="approval_person_organization">
      <explicit
        name="person_organization">
        <typename
          name="person_organization_select"/>
      </explicit>
      <explicit
        name="authorized_approval">
        <typename
          name="approval"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="approval_role"/>
      </explicit>
    </entity>

    <entity
      name="approval_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_approval">
        <typename
          name="approval"/>
      </explicit>
      <explicit
        name="related_approval">
        <typename
          name="approval"/>
      </explicit>
    </entity>

    <entity
      name="approval_role">
      <explicit
        name="role">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="approval_status">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="area_in_set">
      <explicit
        name="area">
        <typename
          name="presentation_area"/>
      </explicit>
      <explicit
        name="in_set">
        <typename
          name="presentation_set"/>
      </explicit>
    </entity>

    <entity
      name="area_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
      </where>
    </entity>

    <entity
      name="area_unit"
      supertypes="named_unit">
      <where
        label="wr1"
        expression="((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\ named_unit.dimensions.mass_exponent = 0) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
      </where>
    </entity>

    <entity
      name="assembly_component_usage"
      super.expression="(ONEOF ( NEXT_ASSEMBLY_USAGE_OCCURRENCE, SPECIFIED_HIGHER_USAGE_OCCURRENCE, PROMISSORY_USAGE_OCCURRENCE))"
      supertypes="product_definition_usage">
      <explicit
        name="reference_designator"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
    </entity>

    <entity
      name="assembly_component_usage_substitute">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="definition"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="base">
        <typename
          name="assembly_component_usage"/>
      </explicit>
      <explicit
        name="substitute">
        <typename
          name="assembly_component_usage"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="base"/>
        <unique.attribute
          attribute="substitute"/>
      </unique>
      <where
        label="wr1"
        expression="(base.relating_product_definition :=: substitute. relating_product_definition)">
      </where>
      <where
        label="wr2"
        expression="(base :&lt;&gt;: substitute)">
      </where>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis),representation_item('') || geometric_representation_item() || direction([0,0,1]))">
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\placement.location.dim = 3)">
      </where>
      <where
        label="wr2"
        expression="((NOT EXISTS(axis)) OR (axis.dim = 3))">
      </where>
      <where
        label="wr3"
        expression="((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3))">
      </where>
      <where
        label="wr4"
        expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (cross_product(axis,ref_direction).magnitude &gt; 0))">
      </where>
    </entity>

    <entity
      name="b_spline_curve"
      super.expression="(ONEOF ( UNIFORM_CURVE, B_SPLINE_CURVE_WITH_KNOTS, QUASI_UNIFORM_CURVE, BEZIER_CURVE) ANDOR RATIONAL_B_SPLINE_CURVE)"
      supertypes="bounded_curve">
      <explicit
        name="degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename
          name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(control_points_list,0, upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="cartesian_point"/>
      </derived>
      <where
        label="wr1"
        expression="(('SMCH_PLUS_203_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('SMCH_PLUS_203_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('SMCH_PLUS_203_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF)) OR ('SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF)))">
      </where>
    </entity>

    <entity
      name="b_spline_curve_with_knots"
      supertypes="b_spline_curve">
      <explicit
        name="knot_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="constraints_param_b_spline(degree,upper_index_on_knots, upper_index_on_control_points,knot_multiplicities,knots)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(knot_multiplicities) = upper_index_on_knots)">
      </where>
    </entity>

    <entity
      name="b_spline_surface"
      super.expression="(ONEOF ( B_SPLINE_SURFACE_WITH_KNOTS, UNIFORM_SURFACE, QUASI_UNIFORM_SURFACE, BEZIER_SURFACE) ANDOR RATIONAL_B_SPLINE_SURFACE)"
      supertypes="bounded_surface">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="surface_form">
        <typename
          name="b_spline_surface_form"/>
      </explicit>
      <explicit
        name="u_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="v_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array(control_points_list,0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="wr1"
        expression="(('SMCH_PLUS_203_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('SMCH_PLUS_203_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('SMCH_PLUS_203_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF)))">
      </where>
    </entity>

    <entity
      name="b_spline_surface_with_knots"
      supertypes="b_spline_surface">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities, u_knots)">
      </where>
      <where
        label="wr2"
        expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities, v_knots)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(u_multiplicities) = knot_u_upper)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(v_multiplicities) = knot_v_upper)">
      </where>
    </entity>

    <entity
      name="bezier_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="bezier_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="boundary_curve"
      supertypes="composite_curve_on_surface">
      <where
        label="wr1"
        expression="SELF\composite_curve.closed_curve">
      </where>
    </entity>

    <entity
      name="bounded_curve"
      super.expression="(ONEOF ( POLYLINE, B_SPLINE_CURVE, TRIMMED_CURVE, COMPOSITE_CURVE))"
      supertypes="curve">
    </entity>

    <entity
      name="bounded_surface"
      super.expression="(ONEOF ( B_SPLINE_SURFACE, RECTANGULAR_TRIMMED_SURFACE, CURVE_BOUNDED_SURFACE, RECTANGULAR_COMPOSITE_SURFACE))"
      supertypes="surface">
    </entity>

    <entity
      name="brep_with_voids"
      supertypes="manifold_solid_brep">
      <explicit
        name="voids">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="oriented_closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="calendar_date"
      supertypes="date">
      <explicit
        name="day_component">
        <typename
          name="day_in_month_number"/>
      </explicit>
      <explicit
        name="month_component">
        <typename
          name="month_in_year_number"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_calendar_date(SELF)">
      </where>
    </entity>

    <entity
      name="camera_image"
      supertypes="mapped_item">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.CAMERA_USAGE' IN TYPEOF(SELF\mapped_item. mapping_source))">
      </where>
      <where
        label="wr2"
        expression="('SMCH_PLUS_203_SCHEMA.PLANAR_BOX' IN TYPEOF(SELF\mapped_item. mapping_target))">
      </where>
      <where
        label="wr3"
        expression="('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="camera_image_3d_with_scale"
      supertypes="camera_image">
      <derived
        name="scale"
        expression="SELF\mapped_item.mapping_target\ planar_extent.size_in_x / SELF\mapped_item.mapping_source. mapping_origin\camera_model_d3.perspective_of_volume. view_window.size_in_x">
        <typename
          name="positive_ratio_measure"/>
      </derived>
      <where
        label="wr1"
        expression="('ASSOC_DIM.CAMERA_MODEL_D3' IN TYPEOF(SELF\mapped_item. mapping_source.mapping_origin))">
      </where>
      <where
        label="wr2"
        expression="(aspect_ratio(SELF\mapped_item.mapping_target) = aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\ camera_model_d3.perspective_of_volume.view_window))">
      </where>
      <where
        label="wr3"
        expression="(SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.perspective_of_volume.front_plane_clipping AND SELF\ mapped_item.mapping_source.mapping_origin\camera_model_d3. perspective_of_volume.view_volume_sides_clipping)">
      </where>
    </entity>

    <entity
      name="camera_model"
      super.expression="( CAMERA_MODEL_D3)"
      supertypes="geometric_representation_item">
      <where
        label="wr1"
        expression="((SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ITEM_DEFINED_TRANSFORMATION.' + 'TRANSFORM_ITEM_1')) + SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'REPRESENTATION_MAP.MAPPING_ORIGIN'))) &gt; 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' + 'STYLED_ITEM.ITEM'))= 0)">
      </where>
    </entity>

    <entity
      name="camera_model_d3"
      supertypes="camera_model">
      <explicit
        name="view_reference_system">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="perspective_of_volume">
        <typename
          name="view_volume"/>
      </explicit>
      <where
        label="wr1"
        expression="((dot_product(SELF.view_reference_system.p[3],SELF. perspective_of_volume.view_window.placement.p[3]) = 1) AND (SELF.view_reference_system.location.coordinates[3] = SELF. perspective_of_volume.view_window.placement.location. coordinates[3]))">
      </where>
      <where
        label="wr2"
        expression="(SELF\geometric_representation_item.dim = 3)">
      </where>
    </entity>

    <entity
      name="camera_model_d3_with_hlhsr"
      supertypes="camera_model_d3">
      <explicit
        name="hidden_line_surface_removal">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="camera_usage"
      supertypes="representation_map">
      <where
        label="wr1"
        expression="(NOT ('SMCH_PLUS_203_SCHEMA.PRESENTATION_REPRESENTATION' IN TYPEOF(SELF\representation_map.mapped_representation)))">
      </where>
      <where
        label="wr2"
        expression="('SMCH_PLUS_203_SCHEMA.CAMERA_MODEL' IN TYPEOF(SELF\ representation_map.mapping_origin))">
      </where>
    </entity>

    <entity
      name="cartesian_point"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(ONEOF ( CARTESIAN_TRANSFORMATION_OPERATOR_2D, CARTESIAN_TRANSFORMATION_OPERATOR_3D))"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale,1)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="wr1"
        expression="(scl &gt; 0)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_2d"
      supertypes="cartesian_transformation_operator">
      <derived
        name="u"
        expression="base_axis(2,SELF\ cartesian_transformation_operator.axis1,SELF\ cartesian_transformation_operator.axis2,?)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\cartesian_transformation_operator.dim = 2)">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3,SELF\ cartesian_transformation_operator.axis1,SELF\ cartesian_transformation_operator.axis2,axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\cartesian_transformation_operator.dim = 3)">
      </where>
    </entity>

    <entity
      name="cc_design_approval"
      supertypes="approval_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="approved_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_certification"
      supertypes="certification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="certified_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_contract"
      supertypes="contract_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="contracted_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_date_and_time_assignment"
      supertypes="date_and_time_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="date_time_item"/>
      </explicit>
      <where
        label="wr1"
        expression="cc_design_date_time_correlation(SELF)">
      </where>
    </entity>

    <entity
      name="cc_design_person_and_organization_assignment"
      supertypes="person_and_organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person_organization_item"/>
      </explicit>
      <where
        label="wr1"
        expression="cc_design_person_and_organization_correlation(SELF)">
      </where>
    </entity>

    <entity
      name="cc_design_security_classification"
      supertypes="security_classification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="classified_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_specification_reference"
      supertypes="document_reference">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="specified_item"/>
      </explicit>
    </entity>

    <entity
      name="certification">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="certification_type"/>
      </explicit>
    </entity>

    <entity
      name="certification_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_certification">
        <typename
          name="certification"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="certification_type">
      <explicit
        name="description">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="change"
      supertypes="action_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="work_item"/>
      </explicit>
    </entity>

    <entity
      name="change_request"
      supertypes="action_request_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="change_request_item"/>
      </explicit>
    </entity>

    <entity
      name="circle"
      supertypes="conic">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="closed_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="colour">
    </entity>

    <entity
      name="colour_rgb"
      supertypes="colour_specification">
      <explicit
        name="red">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="green">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="blue">
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="wr1"
        expression="((0 &lt;= red) AND (red &lt;= 1))">
      </where>
      <where
        label="wr2"
        expression="((0 &lt;= green) AND (green &lt;= 1))">
      </where>
      <where
        label="wr3"
        expression="((0 &lt;= blue) AND (blue &lt;= 1))">
      </where>
    </entity>

    <entity
      name="colour_specification"
      supertypes="colour">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="composite_curve"
      supertypes="bounded_curve">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt; discontinuous">
        <builtintype
          type="LOGICAL"/>
      </derived>
      <where
        label="wr1"
        expression="(((NOT closed_curve) AND (SIZEOF(QUERY (temp &lt;* segments | (temp.transition = discontinuous))) = 1)) OR (closed_curve AND (SIZEOF(QUERY (temp &lt;* segments | (temp.transition = discontinuous))) = 0)))">
      </where>
    </entity>

    <entity
      name="composite_curve_on_surface"
      super.expression="( BOUNDARY_CURVE)"
      supertypes="composite_curve">
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="0"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(basis_surface) &gt; 0)">
      </where>
      <where
        label="wr2"
        expression="constraints_composite_curve_on_surface(SELF)">
      </where>
    </entity>

    <entity
      name="composite_curve_segment"
      supertypes="founded_item">
      <explicit
        name="transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))">
      </where>
    </entity>

    <entity
      name="composite_text"
      supertypes="geometric_representation_item">
      <explicit
        name="collected_text">
        <aggregate
          type="SET"
          lower="2"
          upper="?"/>
        <typename
          name="text_or_character"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_composite_text(SELF,SELF.collected_text)">
      </where>
    </entity>

    <entity
      name="composite_text_with_associated_curves"
      supertypes="composite_text">
      <explicit
        name="associated_curves">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="curve"/>
      </explicit>
    </entity>

    <entity
      name="composite_text_with_blanking_box"
      supertypes="composite_text">
      <explicit
        name="blanking">
        <typename
          name="planar_box"/>
      </explicit>
    </entity>

    <entity
      name="configuration_design">
      <explicit
        name="configuration">
        <typename
          name="configuration_item"/>
      </explicit>
      <explicit
        name="design">
        <typename
          name="configuration_design_item"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <unique
        label="ur1">
        <unique.attribute
          attribute="configuration"/>
        <unique.attribute
          attribute="design"/>
      </unique>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="configuration_effectivity"
      supertypes="product_definition_effectivity">
      <explicit
        name="configuration">
        <typename
          name="configuration_design"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="configuration"/>
        <unique.attribute
          attribute="usage"/>
        <unique.attribute
          attribute="id"/>
      </unique>
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF\ product_definition_effectivity.usage))">
      </where>
    </entity>

    <entity
      name="configuration_item">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="item_concept">
        <typename
          name="product_concept"/>
      </explicit>
      <explicit
        name="purpose"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="conic"
      super.expression="(ONEOF ( CIRCLE, ELLIPSE, HYPERBOLA, PARABOLA))"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
    </entity>

    <entity
      name="conical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="wr1"
        expression="(radius &gt;= 0)">
      </where>
    </entity>

    <entity
      name="connected_edge_set"
      supertypes="topological_representation_item">
      <explicit
        name="ces_edges">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="edge"/>
      </explicit>
    </entity>

    <entity
      name="connected_face_set"
      super.expression="(ONEOF ( CLOSED_SHELL, OPEN_SHELL))"
      supertypes="topological_representation_item">
      <explicit
        name="cfs_faces">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
      </explicit>
    </entity>

    <entity
      name="context_dependent_over_riding_styled_item"
      supertypes="over_riding_styled_item">
      <explicit
        name="style_context">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="style_context_select"/>
      </explicit>
      <where
        label="wr1"
        expression="((SIZEOF(QUERY (sc &lt;* SELF.style_context | ('SMCH_PLUS_203_SCHEMA.REPRESENTATION' IN TYPEOF(sc)))) = 1) AND (SIZEOF(QUERY (sc &lt;* SELF.style_context | ('SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(sc))))= 1))">
      </where>
    </entity>

    <entity
      name="context_dependent_shape_representation">
      <explicit
        name="representation_relation">
        <typename
          name="shape_representation_relationship"/>
      </explicit>
      <explicit
        name="represented_product_relation">
        <typename
          name="product_definition_shape"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition))">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="context_dependent_unit"
      supertypes="named_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="contract">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="contract_type"/>
      </explicit>
    </entity>

    <entity
      name="contract_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_contract">
        <typename
          name="contract"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="contract_type">
      <explicit
        name="description">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="conversion_based_unit"
      supertypes="named_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="conversion_factor">
        <typename
          name="measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="coordinated_universal_time_offset">
      <explicit
        name="hour_offset">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="minute_offset"
        optional="YES">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="sense">
        <typename
          name="ahead_or_behind"/>
      </explicit>
      <where
        label="wr1"
        expression="((0 &lt;= hour_offset) AND (hour_offset &lt;= 12))">
      </where>
      <where
        label="wr2"
        expression="((0 &lt;= minute_offset) AND (minute_offset &lt;= 59))">
      </where>
      <where
        label="wr3"
        expression="(NOT ((hour_offset &lt;&gt; 0) AND (sense = exact)))">
      </where>
    </entity>

    <entity
      name="curve"
      super.expression="(ONEOF ( LINE, CONIC, PCURVE, SURFACE_CURVE, OFFSET_CURVE_2D, OFFSET_CURVE_3D, CURVE_REPLICA))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="curve_bounded_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="surface_boundary"/>
      </explicit>
      <explicit
        name="implicit_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="wr1"
        expression="(NOT (implicit_outer AND ('SMCH_PLUS_203_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(boundaries))))">
      </where>
      <where
        label="wr2"
        expression="((NOT implicit_outer) OR ('SMCH_PLUS_203_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface)))">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (temp &lt;* boundaries | ('SMCH_PLUS_203_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))))&lt;= 1)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (temp &lt;* QUERY (bndc &lt;* boundaries | ('SMCH_PLUS_203_SCHEMA.BOUNDARY_CURVE' IN TYPEOF(bndc))) | (temp\composite_curve_on_surface.basis_surface[1] &lt;&gt; SELF. basis_surface))) = 0)">
      </where>
    </entity>

    <entity
      name="curve_replica"
      supertypes="curve">
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="wr1"
        expression="(transformation.dim = parent_curve.dim)">
      </where>
      <where
        label="wr2"
        expression="acyclic_curve_replica(SELF,parent_curve)">
      </where>
    </entity>

    <entity
      name="curve_style">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="curve_font">
        <typename
          name="curve_font_or_scaled_curve_font_select"/>
      </explicit>
      <explicit
        name="curve_width">
        <typename
          name="size_select"/>
      </explicit>
      <explicit
        name="curve_colour">
        <typename
          name="colour"/>
      </explicit>
    </entity>

    <entity
      name="curve_style_font">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="pattern_list">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="curve_style_font_pattern"/>
      </explicit>
    </entity>

    <entity
      name="curve_style_font_pattern">
      <explicit
        name="visible_segment_length">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="invisible_segment_length">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cylindrical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="date"
      super.expression="(ONEOF ( CALENDAR_DATE, ORDINAL_DATE, WEEK_OF_YEAR_AND_DAY_DATE))">
      <explicit
        name="year_component">
        <typename
          name="year_number"/>
      </explicit>
    </entity>

    <entity
      name="date_and_time">
      <explicit
        name="date_component">
        <typename
          name="date"/>
      </explicit>
      <explicit
        name="time_component">
        <typename
          name="local_time"/>
      </explicit>
    </entity>

    <entity
      name="date_and_time_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_date_and_time">
        <typename
          name="date_and_time"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="date_time_role"/>
      </explicit>
    </entity>

    <entity
      name="date_time_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="dated_effectivity"
      supertypes="effectivity">
      <explicit
        name="effectivity_end_date"
        optional="YES">
        <typename
          name="date_time_or_event_occurrence"/>
      </explicit>
      <explicit
        name="effectivity_start_date">
        <typename
          name="date_time_or_event_occurrence"/>
      </explicit>
    </entity>

    <entity
      name="defined_symbol"
      supertypes="geometric_representation_item">
      <explicit
        name="definition">
        <typename
          name="defined_symbol_select"/>
      </explicit>
      <explicit
        name="target">
        <typename
          name="symbol_target"/>
      </explicit>
    </entity>

    <entity
      name="definitional_representation"
      supertypes="representation">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items))">
      </where>
    </entity>

    <entity
      name="degenerate_pcurve"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(reference_to_curve\representation.items) = 1)">
      </where>
      <where
        label="wr2"
        expression="('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\ representation.items[1]))">
      </where>
      <where
        label="wr3"
        expression="(reference_to_curve\representation.items[1]\ geometric_representation_item.dim = 2)">
      </where>
    </entity>

    <entity
      name="derived_unit">
      <explicit
        name="elements">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="derived_unit_element"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <where
        label="wr1"
        expression="((SIZEOF(elements) &gt; 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent &lt;&gt; 1)))">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="derived_unit_element">
      <explicit
        name="unit">
        <typename
          name="named_unit"/>
      </explicit>
      <explicit
        name="exponent">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="description_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="described_item">
        <typename
          name="description_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="design_context"
      supertypes="product_definition_context">
      <where
        label="wr1"
        expression="(SELF.life_cycle_stage = 'design')">
      </where>
    </entity>

    <entity
      name="design_make_from_relationship"
      supertypes="product_definition_relationship">
    </entity>

    <entity
      name="dimension_callout_relationship"
      supertypes="draughting_callout_relationship">
      <where
        label="wr1"
        expression="(SELF.name IN ['primary','secondary'])">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(TYPEOF(SELF.relating_draughting_callout) * ['ASSOC_DIM.LEADER_DIRECTED_DIMENSION','ASSOC_DIM.LINEAR_DIMENSION']) = 1)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(TYPEOF(SELF.related_draughting_callout) * ['ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT','ASSOC_DIM.LEADER_DIRECTED_CALLOUT']) = 0)">
      </where>
      <where
        label="wr4"
        expression="((SELF.related_draughting_callout.contents * SELF. relating_draughting_callout.contents) = SELF. related_draughting_callout.contents)">
      </where>
    </entity>

    <entity
      name="dimension_curve"
      supertypes="annotation_curve_occurrence">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (dct &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | (('SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN TYPEOF(dct)))) &lt;= 2)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (dcdc &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_CALLOUT.CONTENTS') | (('SMCH_PLUS_203_SCHEMA.' +'DIMENSION_CURVE_DIRECTED_CALLOUT') IN TYPEOF(dcdc)))) &gt;= 1)">
      </where>
      <where
        label="wr3"
        expression="((SIZEOF(QUERY (dct1 &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | ((('SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN TYPEOF(dct1)) AND (dct1.role = origin)))) &lt;= 1) AND (SIZEOF(QUERY (dct2 &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'TERMINATOR_SYMBOL.ANNOTATED_CURVE') | ((('SMCH_PLUS_203_SCHEMA.' + 'DIMENSION_CURVE_TERMINATOR') IN TYPEOF(dct2)) AND (dct2.role = target)))) &lt;= 1))">
      </where>
    </entity>

    <entity
      name="dimension_curve_directed_callout"
      supertypes="draughting_callout">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (d_c &lt;* SELF\draughting_callout.contents | ('SMCH_PLUS_203_SCHEMA.DIMENSION_CURVE' IN TYPEOF(d_c)))) = 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(SELF\draughting_callout.contents) &gt;= 2)">
      </where>
    </entity>

    <entity
      name="dimension_curve_terminator"
      supertypes="terminator_symbol">
      <explicit
        name="role">
        <typename
          name="dimension_extent_usage"/>
      </explicit>
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.DIMENSION_CURVE' IN TYPEOF(SELF\ terminator_symbol.annotated_curve))">
      </where>
    </entity>

    <entity
      name="dimension_text_associativity"
      supertypes="text_literal mapped_item">
      <where
        label="wr1"
        expression="('ASSOC_DIM.SHAPE_DIMENSION_REPRESENTATION' IN TYPEOF(SELF\ mapped_item.mapping_source.mapped_representation))">
      </where>
      <where
        label="wr2"
        expression="('ASSOC_DIM.DRAUGHTING_CALLOUT' IN TYPEOF(SELF\mapped_item. mapping_target))">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (ato &lt;* QUERY (si &lt;* USEDIN(SELF,'ASSOC_DIM.STYLED_ITEM.ITEM') | ('ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(si))) | (NOT (SIZEOF(QUERY (dc &lt;* USEDIN(ato,'ASSOC_DIM.DRAUGHTING_CALLOUT.' + 'CONTENTS') | ('ASSOC_DIM.DRAUGHTING_CALLOUT' IN TYPEOF(dc))) * [SELF\ mapped_item.mapping_target]) = 1)))) = 0)">
      </where>
    </entity>

    <entity
      name="dimensional_characteristic_representation">
      <explicit
        name="dimension">
        <typename
          name="dimensional_characteristic"/>
      </explicit>
      <explicit
        name="representation">
        <typename
          name="shape_dimension_representation"/>
      </explicit>
    </entity>

    <entity
      name="dimensional_exponents">
      <explicit
        name="length_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="mass_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="time_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="electric_current_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="thermodynamic_temperature_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="amount_of_substance_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="luminous_intensity_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="dimensional_location"
      supertypes="shape_aspect_relationship">
    </entity>

    <entity
      name="directed_action"
      supertypes="executed_action">
      <explicit
        name="directive">
        <typename
          name="action_directive"/>
      </explicit>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (tmp &lt;* direction_ratios | (tmp &lt;&gt; 0))) &gt; 0)">
      </where>
    </entity>

    <entity
      name="document">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="document_type"/>
      </explicit>
      <inverse
        name="representation_type"
        entity="document_representation_type"
        attribute="represented_document">
        <inverse.aggregate
          type="SET"
          lower="0"
          upper="?"/>
      </inverse>
    </entity>

    <entity
      name="document_reference"
      abstract.supertype="YES">
      <explicit
        name="assigned_document">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="source">
        <typename
          name="label"/>
      </explicit>
      <derived
        name="role"
        expression="get_role(SELF)">
        <typename
          name="object_role"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="document_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_document">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="related_document">
        <typename
          name="document"/>
      </explicit>
    </entity>

    <entity
      name="document_representation_type">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="represented_document">
        <typename
          name="document"/>
      </explicit>
    </entity>

    <entity
      name="document_type">
      <explicit
        name="product_data_type">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="document_usage_constraint">
      <explicit
        name="source">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="subject_element">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="subject_element_value">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="document_with_class"
      supertypes="document">
      <explicit
        name="class">
        <typename
          name="identifier"/>
      </explicit>
    </entity>

    <entity
      name="draughting_annotation_occurrence"
      supertypes="annotation_occurrence">
      <where
        label="wr1"
        expression="((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (sty &lt;* SELF.styles | (NOT ((SIZEOF(sty.styles) = 1) AND ('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sty.styles[1]))))))= 0))">
      </where>
      <where
        label="wr3"
        expression="((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_FILL_AREA_OCCURRENCE' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (bound &lt;* SELF.item\ annotation_fill_area.boundaries | (NOT (SIZEOF(QUERY (si &lt;* USEDIN(bound,'SMCH_PLUS_203_SCHEMA.' +'STYLED_ITEM.ITEM') | (('SMCH_PLUS_203_SCHEMA.' +'ANNOTATION_CURVE_OCCURRENCE') IN TYPEOF(si)))) &gt; 0)))) =0))">
      </where>
      <where
        label="wr4"
        expression="((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL_OCCURRENCE' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (sty &lt;* SELF.styles | (NOT ((SIZEOF(sty.styles) = 1) AND (SIZEOF(TYPEOF(sty.styles[1]) * ['SMCH_PLUS_203_SCHEMA.SYMBOL_STYLE','SMCH_PLUS_203_SCHEMA.NULL_STYLE']) = 1))))) = 0))">
      </where>
      <where
        label="wr5"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.ANNOTATION_SYMBOL' IN TYPEOF(SELF.item)))) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.'+ 'DRAUGHTING_SYMBOL_REPRESENTATION','SMCH_PLUS_203_SCHEMA.'+ 'DRAUGHTING_SUBFIGURE_REPRESENTATION'] * TYPEOF(SELF.item\mapped_item.mapping_source.mapped_representation)) = 1))">
      </where>
      <where
        label="wr6"
        expression="((NOT ('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (sty &lt;* SELF.styles | (NOT ((SIZEOF(sty.styles) = 1) AND ('SMCH_PLUS_203_SCHEMA.TEXT_STYLE' IN TYPEOF(sty.styles[1]))))))= 0))">
      </where>
      <where
        label="wr7"
        expression="(NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF.item) * ['SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT','SMCH_PLUS_203_SCHEMA.TEXT_LITERAL']) = 1)))">
      </where>
      <where
        label="wr8"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (tl &lt;* SELF.item\ composite_text.collected_text | (NOT ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(tl))))) = 0))">
      </where>
      <where
        label="wr9"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(SELF.item)))) OR (SELF.item\text_literal.alignment IN ['baseline left','baseline centre','baseline right']))">
      </where>
      <where
        label="wr10"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (tl &lt;* QUERY (text &lt;* SELF.item\composite_text.collected_text | ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text))) | (NOT (tl\text_literal.alignment IN ['baseline left','baseline centre','baseline right'])))) = 0))">
      </where>
      <where
        label="wr11"
        expression="(NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(SELF.item)) AND EXISTS(SELF.item\text_literal. placement.ref_direction)))">
      </where>
      <where
        label="wr12"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (tl &lt;* QUERY (text &lt;* SELF.item\composite_text.collected_text | ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text))) | EXISTS(tl\text_literal.placement.ref_direction))) = 0))">
      </where>
      <where
        label="wr13"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR check_text_alignment(SELF.item))">
      </where>
      <where
        label="wr14"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR check_text_font(SELF.item))">
      </where>
      <where
        label="wr15"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (tl &lt;* QUERY (text &lt;* SELF.item\composite_text.collected_text | ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL' IN TYPEOF(text))) | (NOT (SIZEOF(TYPEOF(tl) * ['SMCH_PLUS_203_SCHEMA.' +'TEXT_LITERAL_WITH_BLANKING_BOX','SMCH_PLUS_203_SCHEMA.' +'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0)))) = 0))">
      </where>
      <where
        label="wr16"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (crv &lt;* SELF.item\text_literal_with_associated_curves.associated_curves | (NOT (SIZEOF(QUERY (si &lt;* USEDIN(crv,'SMCH_PLUS_203_SCHEMA.'+ 'STYLED_ITEM.ITEM') | ('SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF(si)))) &gt; 0)))) = 0))">
      </where>
      <where
        label="wr17"
        expression="((NOT (('SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF)) AND ('SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES' IN TYPEOF(SELF.item)))) OR (SIZEOF(QUERY (crv &lt;* SELF.item\composite_text_with_associated_curves.associated_curves |(NOT (SIZEOF(QUERY (si &lt;* USEDIN(crv,'SMCH_PLUS_203_SCHEMA.' + 'STYLED_ITEM.ITEM') | ('SMCH_PLUS_203_SCHEMA.ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF(si)))) &gt; 0)))) = 0))">
      </where>
      <where
        label="wr18"
        expression="(SIZEOF(QUERY (cs &lt;* QUERY (sty &lt;* SELF.styles | ('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sty.styles[1])))| (NOT (('SMCH_PLUS_203_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs.styles[1]\curve_style.curve_width)) AND ('SMCH_PLUS_203_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(cs. styles[1]\curve_style.curve_width\measure_with_unit. value_component)))))) = 0)">
      </where>
      <where
        label="wr21"
        expression="(SIZEOF(QUERY (ts &lt;* QUERY (sty &lt;* SELF.styles | ('AUTOMOTIVE_DESIGN.TEXT_STYLE' IN TYPEOF(sty.styles[1])))| (NOT ('AUTOMOTIVE_DESIGN.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' IN TYPEOF(ts.styles[1]))))) = 0)">
      </where>
      <where
        label="wr22"
        expression="(SIZEOF(QUERY (ts &lt;* QUERY (sty &lt;* SELF.styles | ('AUTOMOTIVE_DESIGN.TEXT_STYLE_WITH_BOX_CHARACTERISTICS' IN TYPEOF(sty.styles[1]))) | (NOT (SIZEOF(ts.styles[1]\ text_style_with_box_characteristics.characteristics) = 4))))= 0)">
      </where>
    </entity>

    <entity
      name="draughting_callout"
      supertypes="geometric_representation_item">
      <explicit
        name="contents">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="draughting_callout_element"/>
      </explicit>
    </entity>

    <entity
      name="draughting_callout_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_draughting_callout">
        <typename
          name="draughting_callout"/>
      </explicit>
      <explicit
        name="related_draughting_callout">
        <typename
          name="draughting_callout"/>
      </explicit>
    </entity>

    <entity
      name="draughting_elements"
      supertypes="draughting_callout">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (l_c &lt;* QUERY (con &lt;* SELF.contents | ('ASSOC_DIM.LEADER_CURVE' IN TYPEOF(con))) | (NOT (SIZEOF(QUERY (ldc &lt;* USEDIN(l_c,'ASSOC_DIM.' +'DRAUGHTING_CALLOUT.CONTENTS') | ('ASSOC_DIM.LEADER_DIRECTED_CALLOUT' IN TYPEOF(ldc)))) &lt;= 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="((NOT ('ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(SELF))) OR (SIZEOF(QUERY (con &lt;* SELF.contents | ('ASSOC_DIM.PROJECTION_CURVE' IN TYPEOF(con)))) &lt;= 2))">
      </where>
    </entity>

    <entity
      name="draughting_model"
      supertypes="representation">
      <unique
        label="ur1">
        <unique.attribute
          attribute="name"/>
      </unique>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* SELF.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.STYLED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT','SMCH_PLUS_203_SCHEMA.CAMERA_MODEL'] * TYPEOF(it)) = 1)))) =0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION','SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL'] * TYPEOF(mi\ mapped_item.mapping_source.mapped_representation)) = 1))))= 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (smi &lt;* QUERY (si &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(si\styled_item. item))) | (NOT (('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source. mapped_representation)) AND (SIZEOF(QUERY (sty &lt;* smi\ styled_item.styles | (NOT (SIZEOF(QUERY (psa &lt;* sty.styles| (NOT ('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(psa)))))= 1)))) = 1))))) = 0)">
      </where>
    </entity>

    <entity
      name="draughting_pre_defined_colour"
      supertypes="pre_defined_colour">
      <where
        label="wr1"
        expression="(SELF.name IN ['red','green','blue','yellow','magenta','cyan','black','white'])">
      </where>
    </entity>

    <entity
      name="draughting_pre_defined_curve_font"
      supertypes="pre_defined_curve_font">
      <where
        label="wr1"
        expression="(SELF.name IN ['continuous','chain','chain double dash','dashed','dotted'])">
      </where>
    </entity>

    <entity
      name="draughting_pre_defined_text_font"
      supertypes="pre_defined_text_font">
      <where
        label="wr1"
        expression="(SELF.name IN ['ISO 3098-1 font A','ISO 3098-1 font B'])">
      </where>
    </entity>

    <entity
      name="draughting_title">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="draughting_titled_item"/>
      </explicit>
      <explicit
        name="language">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="contents">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="drawing_definition">
      <explicit
        name="drawing_number">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="drawing_type"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="drawing_revision"
      supertypes="presentation_set">
      <explicit
        name="revision_identifier">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="drawing_identifier">
        <typename
          name="drawing_definition"/>
      </explicit>
      <explicit
        name="intended_scale"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="revision_identifier"/>
        <unique.attribute
          attribute="drawing_identifier"/>
      </unique>
    </entity>

    <entity
      name="drawing_sheet_revision"
      supertypes="presentation_area">
      <explicit
        name="revision_identifier">
        <typename
          name="identifier"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (item &lt;* SELF\representation.items | (('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) AND ('SMCH_PLUS_203_SCHEMA.DRAWING_SHEET_REVISION' IN TYPEOF(item\ mapped_item.mapping_source.mapped_representation))))) = 0)">
      </where>
    </entity>

    <entity
      name="drawing_sheet_revision_usage"
      supertypes="area_in_set">
      <explicit
        name="sheet_number">
        <typename
          name="identifier"/>
      </explicit>
      <unique
        label="ur1">
        <unique.attribute
          attribute="sheet_number"/>
        <unique.attribute
          attribute="in_set"/>
      </unique>
      <where
        label="wr1"
        expression="(('SMCH_PLUS_203_SCHEMA.DRAWING_SHEET_REVISION' IN TYPEOF(SELF\ area_in_set.area)) AND ('SMCH_PLUS_203_SCHEMA.DRAWING_REVISION' IN TYPEOF(SELF\ area_in_set.in_set)))">
      </where>
    </entity>

    <entity
      name="edge"
      super.expression="(ONEOF ( EDGE_CURVE, ORIENTED_EDGE))"
      supertypes="topological_representation_item">
      <explicit
        name="edge_start">
        <typename
          name="vertex"/>
      </explicit>
      <explicit
        name="edge_end">
        <typename
          name="vertex"/>
      </explicit>
    </entity>

    <entity
      name="edge_based_wireframe_model"
      supertypes="geometric_representation_item">
      <explicit
        name="ebwm_boundary">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="connected_edge_set"/>
      </explicit>
    </entity>

    <entity
      name="edge_based_wireframe_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt;=1)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (edges &lt;* eb.ces_edges | (NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(edges))))) = 0))))= 0)))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (pline_edges &lt;* QUERY (edges &lt;* eb.ces_edges | ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(edges\edge_curve. edge_geometry))) | (NOT (SIZEOF(pline_edges\edge_curve. edge_geometry\polyline.points) &gt; 2)))) = 0)))) = 0)))) =0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (edges &lt;* eb.ces_edges | (NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(edges. edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(edges.edge_end)))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (edges &lt;* eb.ces_edges | (NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (edges &lt;* eb.ces_edges | (NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point. vertex_geometry,'CONFIG_CONTROL_DESIGN') AND valid_wireframe_vertex_point(edges.edge_end\vertex_point. vertex_geometry,'CONFIG_CONTROL_DESIGN'))))) = 0)))) = 0))))= 0)">
      </where>
      <where
        label="wr8"
        expression="(SIZEOF(QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (eb &lt;* ebwm\ edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(QUERY (con_edges &lt;* QUERY (edges &lt;* eb.ces_edges | ('SMCH_PLUS_203_SCHEMA.CONIC' IN TYPEOF(edges\edge_curve. edge_geometry))) | (NOT ('SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(con_edges\edge_curve.edge_geometry\conic.position))))) = 0)))) = 0))))= 0)">
      </where>
      <where
        label="wr9"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item))) | (NOT (('SMCH_PLUS_203_SCHEMA.' +'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\ mapped_item.mapping_source.mapped_representation))))) = 0)">
      </where>
    </entity>

    <entity
      name="edge_curve"
      supertypes="edge geometric_representation_item">
      <explicit
        name="edge_geometry">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="edge_loop"
      supertypes="loop path">
      <derived
        name="ne"
        expression="SIZEOF(SELF\path.edge_list)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="wr1"
        expression="(SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne]. edge_end)">
      </where>
    </entity>

    <entity
      name="effectivity"
      super.expression="(ONEOF ( SERIAL_NUMBERED_EFFECTIVITY, DATED_EFFECTIVITY, LOT_EFFECTIVITY))">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <derived
        name="name"
        expression="get_name_value(SELF)">
        <typename
          name="label"/>
      </derived>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="elementary_surface"
      super.expression="(ONEOF ( PLANE, CYLINDRICAL_SURFACE, CONICAL_SURFACE, SPHERICAL_SURFACE, TOROIDAL_SURFACE))"
      supertypes="surface">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
    </entity>

    <entity
      name="ellipse"
      supertypes="conic">
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="evaluated_degenerate_pcurve"
      supertypes="degenerate_pcurve">
      <explicit
        name="equivalent_point">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="executed_action"
      supertypes="action">
    </entity>

    <entity
      name="external_source">
      <explicit
        name="source_id">
        <typename
          name="source_item"/>
      </explicit>
      <derived
        name="description"
        expression="get_description_value(SELF)">
        <typename
          name="text"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="externally_defined_colour"
      supertypes="colour_specification externally_defined_item">
    </entity>

    <entity
      name="externally_defined_curve_font"
      supertypes="externally_defined_item">
    </entity>

    <entity
      name="externally_defined_item">
      <explicit
        name="item_id">
        <typename
          name="source_item"/>
      </explicit>
      <explicit
        name="source">
        <typename
          name="external_source"/>
      </explicit>
    </entity>

    <entity
      name="externally_defined_marker"
      supertypes="externally_defined_symbol pre_defined_marker">
    </entity>

    <entity
      name="externally_defined_symbol"
      supertypes="externally_defined_item">
    </entity>

    <entity
      name="externally_defined_terminator_symbol"
      supertypes="externally_defined_symbol">
    </entity>

    <entity
      name="face"
      super.expression="(ONEOF ( FACE_SURFACE, ORIENTED_FACE))"
      supertypes="topological_representation_item">
      <explicit
        name="bounds">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face_bound"/>
      </explicit>
      <where
        label="wr1"
        expression="(NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))))">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (temp &lt;* bounds | ('SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp))))&lt;= 1)">
      </where>
    </entity>

    <entity
      name="face_bound"
      supertypes="topological_representation_item">
      <explicit
        name="bound">
        <typename
          name="loop"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="face_outer_bound"
      supertypes="face_bound">
    </entity>

    <entity
      name="face_surface"
      supertypes="face geometric_representation_item">
      <explicit
        name="face_geometry">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="faceted_brep"
      supertypes="manifold_solid_brep">
    </entity>

    <entity
      name="faceted_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.FACETED_BREP','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.FACETED_BREP','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt; 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (fbrep &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.FACETED_BREP' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (csh &lt;* msb_shells(fbrep,'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY (fcs &lt;* csh. cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs)) AND ('SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(fcs\ face_surface.face_geometry)) AND ('SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT' IN TYPEOF(fcs\ face_surface.face_geometry\plane.position.location)))))) =0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (fbrep &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.FACETED_BREP' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (csh &lt;* msb_shells(fbrep,'CONFIG_CONTROL_DESIGN') | (NOT (SIZEOF(QUERY (fcs &lt;* csh. cfs_faces | (NOT (SIZEOF(QUERY (bnds &lt;* fcs.bounds | ('SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))) =1)))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (msb &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)))| ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb\manifold_solid_brep.outer)))) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (brv &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (csh &lt;* brv\brep_with_voids.voids | csh\ oriented_closed_shell.orientation)) = 0)))) = 0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it))) | (NOT ('SMCH_PLUS_203_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))))= 0)">
      </where>
    </entity>

    <entity
      name="fill_area_style">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="fill_styles">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="fill_style_select"/>
      </explicit>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (fill_style &lt;* SELF.fill_styles | (('SMCH_PLUS_203_SCHEMA.' + 'FILL_AREA_STYLE_COLOUR') IN TYPEOF(fill_style)))) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="fill_area_style_colour">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="fill_colour">
        <typename
          name="colour"/>
      </explicit>
    </entity>

    <entity
      name="founded_item">
    </entity>

    <entity
      name="functionally_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="geometric_curve_set"
      supertypes="geometric_set">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (temp &lt;* SELF\geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(temp)))) = 0)">
      </where>
    </entity>

    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF ( POINT, DIRECTION, VECTOR, PLACEMENT, CARTESIAN_TRANSFORMATION_OPERATOR, CURVE, SURFACE, EDGE_CURVE, FACE_SURFACE, POLY_LOOP, VERTEX_POINT, SOLID_MODEL, SHELL_BASED_SURFACE_MODEL, SHELL_BASED_WIREFRAME_MODEL, EDGE_BASED_WIREFRAME_MODEL, GEOMETRIC_SET))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (using_rep &lt;* using_representations(SELF) | (NOT ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items))))) = 0)">
      </where>
    </entity>

    <entity
      name="geometric_set"
      super.expression="( GEOMETRIC_CURVE_SET)"
      supertypes="geometric_representation_item">
      <explicit
        name="elements">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="geometric_set_select"/>
      </explicit>
    </entity>

    <entity
      name="geometrically_bounded_surface_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt; 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it))) | (NOT (('SMCH_PLUS_203_SCHEMA.' +'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))))= 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (gs &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it))) | (NOT(SIZEOF(QUERY (pnt &lt;* QUERY (gsel &lt;* gs\geometric_set. elements | ('SMCH_PLUS_203_SCHEMA.POINT' IN TYPEOF(gsel)))| (NOT gbsf_check_point(pnt,'CONFIG_CONTROL_DESIGN')))) =0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (gs &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it))) | (NOT(SIZEOF(QUERY (cv &lt;* QUERY (gsel &lt;* gs\geometric_set. elements | ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(gsel)))| (NOT gbsf_check_curve(cv,'CONFIG_CONTROL_DESIGN')))) = 0))))= 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (gs &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET' IN TYPEOF(it))) | (NOT(SIZEOF(QUERY (sf &lt;* QUERY (gsel &lt;* gs\geometric_set. elements | ('SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(gsel)))| (NOT gbsf_check_surface(sf,'CONFIG_CONTROL_DESIGN')))) =0)))) = 0)">
      </where>
    </entity>

    <entity
      name="geometrically_bounded_wireframe_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt;=1)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| (NOT (SIZEOF(QUERY (elem &lt;* gcs\geometric_set.elements| (NOT valid_geometrically_bounded_wf_curve(elem,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| (NOT (SIZEOF(QUERY (pnts &lt;* QUERY (elem &lt;* gcs\ geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.POINT' IN TYPEOF(elem))) | (NOT valid_geometrically_bounded_wf_point(pnts,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| (NOT (SIZEOF(QUERY (cnc &lt;* QUERY (elem &lt;* gcs\ geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.CONIC' IN TYPEOF(elem))) | (NOT ('SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\conic.position))))) = 0)))) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(it)))| (NOT (SIZEOF(QUERY (pline &lt;* QUERY (elem &lt;* gcs\ geometric_set.elements | ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(elem))) | (NOT (SIZEOF(pline\polyline.points) &gt; 2))))= 0)))) = 0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items| ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item))) | (NOT (('SMCH_PLUS_203_SCHEMA.' +'GEOMETRICALLY_BOUNDED_WIREFRAME_REPRESENTATION') IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))) =0)">
      </where>
    </entity>

    <entity
      name="global_uncertainty_assigned_context"
      supertypes="representation_context">
      <explicit
        name="uncertainty">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="uncertainty_measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="global_unit_assigned_context"
      supertypes="representation_context">
      <explicit
        name="units">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="unit"/>
      </explicit>
    </entity>

    <entity
      name="hyperbola"
      supertypes="conic">
      <explicit
        name="semi_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="id_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="identified_item">
        <typename
          name="id_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="intersection_curve"
      supertypes="surface_curve">
      <where
        label="wr1"
        expression="(SIZEOF(SELF\surface_curve.associated_geometry) = 2)">
      </where>
      <where
        label="wr2"
        expression="(associated_surface(SELF\surface_curve.associated_geometry[1])&lt;&gt; associated_surface(SELF\surface_curve.associated_geometry[2]))">
      </where>
    </entity>

    <entity
      name="invisibility">
      <explicit
        name="invisible_items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="invisible_item"/>
      </explicit>
    </entity>

    <entity
      name="item_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="transform_item_1">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="transform_item_2">
        <typename
          name="representation_item"/>
      </explicit>
    </entity>

    <entity
      name="leader_curve"
      supertypes="annotation_curve_occurrence">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (ldc &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_CALLOUT.CONTENTS') | (('SMCH_PLUS_203_SCHEMA.' +'LEADER_DIRECTED_CALLOUT') IN TYPEOF(ldc)))) &gt;= 1)">
      </where>
    </entity>

    <entity
      name="leader_directed_callout"
      supertypes="draughting_callout">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (l_1 &lt;* SELF\draughting_callout.contents | ('SMCH_PLUS_203_SCHEMA.LEADER_CURVE' IN TYPEOF(l_1)))) &gt;= 1)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(SELF\draughting_callout.contents) &gt;= 2)">
      </where>
    </entity>

    <entity
      name="leader_directed_dimension"
      supertypes="leader_directed_callout">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (con &lt;* SELF.contents | ('ASSOC_DIM.LEADER_CURVE' IN TYPEOF(con)))) = 1)">
      </where>
    </entity>

    <entity
      name="leader_terminator"
      supertypes="terminator_symbol">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.LEADER_CURVE' IN TYPEOF(SELF\ terminator_symbol.annotated_curve))">
      </where>
    </entity>

    <entity
      name="length_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
      </where>
    </entity>

    <entity
      name="length_unit"
      supertypes="named_unit">
      <where
        label="wr1"
        expression="((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\ named_unit.dimensions.mass_exponent = 0) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
      </where>
    </entity>

    <entity
      name="line"
      supertypes="curve">
      <explicit
        name="pnt">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename
          name="vector"/>
      </explicit>
      <where
        label="wr1"
        expression="(dir.dim = pnt.dim)">
      </where>
    </entity>

    <entity
      name="linear_dimension"
      supertypes="dimension_curve_directed_callout">
    </entity>

    <entity
      name="local_time">
      <explicit
        name="hour_component">
        <typename
          name="hour_in_day"/>
      </explicit>
      <explicit
        name="minute_component"
        optional="YES">
        <typename
          name="minute_in_hour"/>
      </explicit>
      <explicit
        name="second_component"
        optional="YES">
        <typename
          name="second_in_minute"/>
      </explicit>
      <explicit
        name="zone">
        <typename
          name="coordinated_universal_time_offset"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_time(SELF)">
      </where>
    </entity>

    <entity
      name="loop"
      super.expression="(ONEOF ( VERTEX_LOOP, EDGE_LOOP, POLY_LOOP))"
      supertypes="topological_representation_item">
    </entity>

    <entity
      name="lot_effectivity"
      supertypes="effectivity">
      <explicit
        name="effectivity_lot_id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="effectivity_lot_size">
        <typename
          name="measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="manifold_solid_brep"
      supertypes="solid_model">
      <explicit
        name="outer">
        <typename
          name="closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="manifold_surface_shape_representation"
      supertypes="shape_representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (it &lt;* items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED ITEM'] * TYPEOF(it)) = 1))) &gt;0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.MAPPED ITEM' IN TYPEOF(it))) | (NOT ('SMCH_PLUS_203_SCHEMA.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source. mapped_representation))))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (sh &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.OPEN_SHELL','SMCH_PLUS_203_SCHEMA.CLOSED_SHELL'] * TYPEOF(sh)) = 1))))= 0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.FACE_SURFACE','SMCH_PLUS_203_SCHEMA.ORIENTED_FACE'] * TYPEOF(fa)) = 1))))= 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (f_sf &lt;* QUERY (fa &lt;* cfs.cfs_faces | ('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fa))) | (NOT(('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.OFFSET_SURFACE','SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA'] * TYPEOF(f_sf\ face_surface.face_geometry)) = 1))))) = 0)))) = 0)))) =0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR basis_surface_check(fa\face_surface.face_geometry,'CONFIG_CONTROL_DESIGN'))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr8"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds &lt;* fa.bounds | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.EDGE_LOOP','SMCH_PLUS_203_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnds.bound)) =1)))) = 0))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr9"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds))) | (NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | (NOT('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))))= 0)))) = 0))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr10"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds | ('SMCH_PLUS_203_SCHEMA.EDGE LOOP' IN TYPEOF(bnds.bound))) |(NOT (SIZEOF(QUERY (oe_cv &lt;* QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))) | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_REPLICA','SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D','SMCH_PLUS_203_SCHEMA.SURFACE_CURVE'] * TYPEOF(oe_cv. edge_element\edge_curve.edge_geometry)) = 1)))) = 0)))) =0))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr11"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) |(NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| (NOT basis_curve_check(oe.edge_element\edge_curve. edge_geometry,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0)))))= 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr12"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds))) | (NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | (NOT(('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe. edge_element.edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe. edge_element.edge_end)))))) = 0)))) = 0))))) = 0)))) =0)))) = 0)">
      </where>
      <where
        label="wr13"
        expression="(SIZEOF(QUERY (sbsm &lt;* QUERY (it &lt;* items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (cfs &lt;* sbsm\ shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces | (NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) |(NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| (NOT ((SIZEOF(['SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT','SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE','SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE','SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe. edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT','SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE','SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE','SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe. edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))))= 0)))) = 0))))) = 0)))) = 0)))) = 0)">
      </where>
    </entity>

    <entity
      name="mapped_item"
      supertypes="representation_item">
      <explicit
        name="mapping_source">
        <typename
          name="representation_map"/>
      </explicit>
      <explicit
        name="mapping_target">
        <typename
          name="representation_item"/>
      </explicit>
      <where
        label="wr1"
        expression="acyclic_mapped_representation(using_representations(SELF),[SELF])">
      </where>
    </entity>

    <entity
      name="mass_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="wr1"
        expression="('SMCH_PLUS_203_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
      </where>
    </entity>

    <entity
      name="mass_unit"
      supertypes="named_unit">
      <where
        label="wr1"
        expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\ named_unit.dimensions.mass_exponent = 1) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
      </where>
    </entity>

    <entity
      name="measure_representation_item"
      supertypes="representation_item measure_with_unit">
    </entity>

    <entity
      name="measure_with_unit"
      super.expression="(ONEOF ( LENGTH_MEASURE_WITH_UNIT, MASS_MEASURE_WITH_UNIT, PLANE_ANGLE_MEASURE_WITH_UNIT, SOLID_ANGLE_MEASURE_WITH_UNIT, AREA_MEASURE_WITH_UNIT, VOLUME_MEASURE_WITH_UNIT))">
      <explicit
        name="value_component">
        <typename
          name="measure_value"/>
      </explicit>
      <explicit
        name="unit_component">
        <typename
          name="unit"/>
      </explicit>
      <where
        label="wr1"
        expression="valid_units(SELF)">
      </where>
    </entity>

    <entity
      name="mechanical_context"
      supertypes="product_context">
      <where
        label="wr1"
        expression="(SELF.discipline_type = 'mechanical')">
      </where>
    </entity>

    <entity
      name="mechanical_design_geometric_presentation_representation"
      supertypes="representation">
      <where
        label="wr1"
        expression="(SIZEOF(QUERY (it &lt;* SELF.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.STYLED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT'] * TYPEOF(it)) = 1))))= 0)">
      </where>
      <where
        label="wr2"
        expression="(SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION','SMCH_PLUS_203_SCHEMA.' +'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']* TYPEOF(mi\mapped_item.mapping_source. mapped_representation)) = 1)))) = 0)">
      </where>
      <where
        label="wr3"
        expression="(SIZEOF(QUERY (smi &lt;* QUERY (si &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(si\styled_item. item))) | (NOT ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(smi\styled_item.item\mapped_item.mapping_source. mapped_representation))))) = 0)">
      </where>
      <where
        label="wr4"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (pss &lt;* psa.styles | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.POINT_STYLE','SMCH_PLUS_203_SCHEMA.CURVE_STYLE','SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE'] * TYPEOF(pss)) =1)))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr5"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psbc &lt;* QUERY (psa &lt;* si\styled_item.styles| (('SMCH_PLUS_203_SCHEMA.' +'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(psa))) | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM','SMCH_PLUS_203_SCHEMA.REPRESENTATION'] * TYPEOF(psbc\ presentation_style_by_context.style_context)) = 1)))) = 0))))= 0)">
      </where>
      <where
        label="wr6"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ps &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.POINT_STYLE' IN TYPEOF(pss))) | (NOT((('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(ps\point_style.marker_size)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(ps\point_style. marker_colour)) = 1))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr7"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (cs &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(pss))) | (NOT((SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(cs\curve_style.curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(cs\curve_style.curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(cs\ curve_style.curve_font)) = 1))))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr8"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_SIDE_STYLE') IN TYPEOF(ssu\surface_style_usage.style))))) = 0)))) = 0))))= 0)">
      </where>
      <where
        label="wr9"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (sses &lt;* ssu\surface_style_usage. style\surface_side_style.styles | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_PARAMETER_LINE','SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_CONTROL_GRID','SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SILHOUETTE','SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SEGMENTATION_CURVE','SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_FILL_AREA','SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_BOUNDARY'] * TYPEOF(sses)) = 1)))) = 0)))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr10"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (sspl &lt;* QUERY (sses &lt;* ssu\ surface_style_usage.style\surface_side_style.styles | (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_PARAMETER_LINE') IN TYPEOF(sses))) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sspl\surface_style_parameter_line. style_of_parameter_lines)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sspl\ surface_style_parameter_line.style_of_parameter_lines\ curve_style.curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(sspl\surface_style_parameter_line. style_of_parameter_lines\curve_style.curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sspl\ surface_style_parameter_line.style_of_parameter_lines\ curve_style.curve_font)) = 1))))) = 0)))) = 0)))) = 0))))= 0)">
      </where>
      <where
        label="wr11"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (sscg &lt;* QUERY (sses &lt;* ssu\ surface_style_usage.style\surface_side_style.styles | (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_CONTROL_GRID') IN TYPEOF(sses))) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sscg\surface_style_control_grid. style_of_control_grid)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sscg\ surface_style_control_grid.style_of_control_grid\ curve_style.curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(sscg\surface_style_control_grid. style_of_control_grid\curve_style.curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sscg\ surface_style_control_grid.style_of_control_grid\ curve_style.curve_font)) = 1))))) = 0)))) = 0)))) = 0))))= 0)">
      </where>
      <where
        label="wr12"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (sssh &lt;* QUERY (sses &lt;* ssu\ surface_style_usage.style\surface_side_style.styles | (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SILHOUETTE') IN TYPEOF(sses))) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sssh\surface_style_silhouette.style_of_silhouette)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' + 'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sssh\surface_style_silhouette.style_of_silhouette\ curve_style.curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(sssh\surface_style_silhouette.style_of_silhouette\ curve_style.curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sssh\ surface_style_silhouette.style_of_silhouette\curve_style. curve_font)) = 1))))) = 0)))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr13"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (sssc &lt;* QUERY (sses &lt;* ssu\ surface_style_usage.style\surface_side_style.styles | (('SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_SEGMENTATION_CURVE') IN TYPEOF(sses))) | (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(sssc\ surface_style_segmentation_curve. style_of_segmentation_curve)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(sssc\ surface_style_segmentation_curve. style_of_segmentation_curve\curve_style.curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' + 'POSITIVE_LENGTH_MEASURE') IN TYPEOF(sssc\surface_style_segmentation_curve. style_of_segmentation_curve\curve_style.curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(sssc\ surface_style_segmentation_curve. style_of_segmentation_curve\curve_style.curve_font)) = 1)))))= 0)))) = 0)))) = 0)))) = 0)">
      </where>
      <where
        label="wr14"
        expression="(SIZEOF(QUERY (si &lt;* QUERY (it &lt;* SELF.items | ('SMCH_PLUS_203_SCHEMA.STYLED_ITEM' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (psa &lt;* si\styled_item.styles | (NOT (SIZEOF(QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(pss)))| (NOT (SIZEOF(QUERY (ssbd &lt;* QUERY (sses &lt;* ssu\ surface_style_usage.style\surface_side_style.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)))| (NOT (('SMCH_PLUS_203_SCHEMA.CURVE_STYLE' IN TYPEOF(ssbd\ surface_style_boundary.style_of_boundary)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.COLOUR_RGB','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF(ssbd\ surface_style_boundary.style_of_boundary\curve_style. curve_colour)) = 1) AND (('SMCH_PLUS_203_SCHEMA.' +'POSITIVE_LENGTH_MEASURE') IN TYPEOF(ssbd\ surface_style_boundary.style_of_boundary\curve_style. curve_width)) AND (SIZEOF(['SMCH_PLUS_203_SCHEMA.CURVE_STYLE_FONT','SMCH_PLUS_203_SCHEMA.' +'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF(ssbd\ surface_style_boundary.style_of_boundary\curve_style. curve_font)) = 1))))) = 0)))) = 0)))) = 0)))) = 0)">
      </where>
    </entity>

    <entity
      name="name_attribute">
      <explicit
        name="attribute_value">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="named_item">
        <typename
          name="name_attribute_select"/>
      </explicit>
    </entity>

    <entity
      name="named_unit"
      super.expression="(ONEOF ( SI_UNIT, CONVERSION_BASED_UNIT, CONTEXT_DEPENDENT_UNIT) ANDOR ONEOF ( LENGTH_UNIT, MASS_UNIT, PLANE_ANGLE_UNIT, SOLID_ANGLE_UNIT, AREA_UNIT, VOLUME_UNIT))">
      <explicit
        name="dimensions">
        <typename
          name="dimensional_exponents"/>
      </explicit>
    </entity>

    <entity
      name="next_assembly_usage_occurrence"
      supertypes="assembly_component_usage">
    </entity>

    <entity
      name="object_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="offset_curve_2d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <where
        label="wr1"
        expression="(basis_curve.dim = 2)">
      </where>
    </entity>

    <entity
      name="offset_curve_3d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="ref_direction">
        <typename
          name="direction"/>
      </explicit>
      <where
        label="wr1"
        expression="((basis_curve.dim = 3) AND (ref_direction.dim = 3))">
      </where>
    </entity>

    <entity
      name="offset_surface"
      supertypes="surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="open_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="ordinal_date"
      supertypes="date">
      <explicit
        name="day_component">
        <typename
          name="day_in_year_number"/>
      </explicit>
      <where
        label="wr1"
        expression="(((NOT leap_year(SELF.year_component)) AND (1 &lt;= day_component) AND (day_component &lt;= 365)) OR (leap_year(SELF. year_component) AND (1 &lt;= day_component) AND (day_component&lt;= 366)))">
      </where>
    </entity>

    <entity
      name="organization">
      <explicit
        name="id"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organization_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_organization">
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="related_organization">
        <typename
          name="organization"/>
      </explicit>
    </entity>

    <entity
      name="organizational_address"
      supertypes="address">
      <explicit
        name="organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organizational_project">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="responsible_organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
      <derived
        name="id"
        expression="get_id_value(SELF)">
        <typename
          name="identifier"/>
      </derived>
      <where
        label="wr1"
        expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
      </where>
    </entity>

    <entity
      name="oriented_closed_shell"
      supertypes="closed_shell">
      <explicit
        name="closed_shell_element">
        <typename
          name="closed_shell"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="cfs_faces"
        expression="conditional_reverse(SELF. orientation,SELF. closed_shell_element.cfs_faces)">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
        <redeclaration
          entity-ref="connected_face_set"/>
        </derived>
        <where
          label="wr1"
          expression="(NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element)))">
        </where>
      </entity>

      <entity
        name="oriented_edge"
        supertypes="edge">
        <explicit
          name="edge_element">
          <typename
            name="edge"/>
        </explicit>
        <explicit
          name="orientation">
          <builtintype
            type="BOOLEAN"/>
        </explicit>
        <derived
          name="edge_start"
          expression="boolean_choose(SELF.orientation, SELF.edge_element.edge_start,SELF. edge_element.edge_end)">
          <typename
            name="vertex"/>
          <redeclaration
            entity-ref="edge"/>
          </derived>
          <derived
            name="edge_end"
            expression="boolean_choose(SELF.orientation, SELF.edge_element.edge_end,SELF. edge_element.edge_start)">
            <typename
              name="vertex"/>
            <redeclaration
              entity-ref="edge"/>
            </derived>
            <where
              label="wr1"
              expression="(NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF. edge_element)))">
            </where>
          </entity>

          <entity
            name="oriented_face"
            supertypes="face">
            <explicit
              name="face_element">
              <typename
                name="face"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <derived
              name="bounds"
              expression="conditional_reverse(SELF.orientation,SELF.face_element.bounds)">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="face_bound"/>
              <redeclaration
                entity-ref="face"/>
              </derived>
              <where
                label="wr1"
                expression="(NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF. face_element)))">
              </where>
            </entity>

            <entity
              name="oriented_open_shell"
              supertypes="open_shell">
              <explicit
                name="open_shell_element">
                <typename
                  name="open_shell"/>
              </explicit>
              <explicit
                name="orientation">
                <builtintype
                  type="BOOLEAN"/>
              </explicit>
              <derived
                name="cfs_faces"
                expression="conditional_reverse(SELF. orientation,SELF. open_shell_element.cfs_faces)">
                <aggregate
                  type="SET"
                  lower="1"
                  upper="?"/>
                <typename
                  name="face"/>
                <redeclaration
                  entity-ref="connected_face_set"/>
                </derived>
                <where
                  label="wr1"
                  expression="(NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF. open_shell_element)))">
                </where>
              </entity>

              <entity
                name="oriented_path"
                supertypes="path">
                <explicit
                  name="path_element">
                  <typename
                    name="path"/>
                </explicit>
                <explicit
                  name="orientation">
                  <builtintype
                    type="BOOLEAN"/>
                </explicit>
                <derived
                  name="edge_list"
                  expression="conditional_reverse(SELF.orientation,SELF. path_element.edge_list)">
                  <aggregate
                    type="LIST"
                    lower="1"
                    upper="?"
                    unique="YES"/>
                  <typename
                    name="oriented_edge"/>
                  <redeclaration
                    entity-ref="path"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(NOT ('SMCH_PLUS_203_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF. path_element)))">
                  </where>
                </entity>

                <entity
                  name="outer_boundary_curve"
                  supertypes="boundary_curve">
                </entity>

                <entity
                  name="over_riding_styled_item"
                  supertypes="styled_item">
                  <explicit
                    name="over_ridden_style">
                    <typename
                      name="styled_item"/>
                  </explicit>
                </entity>

                <entity
                  name="parabola"
                  supertypes="conic">
                  <explicit
                    name="focal_dist">
                    <typename
                      name="length_measure"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(focal_dist &lt;&gt; 0)">
                  </where>
                </entity>

                <entity
                  name="parametric_representation_context"
                  supertypes="representation_context">
                </entity>

                <entity
                  name="path"
                  super.expression="(ONEOF ( EDGE_LOOP, ORIENTED_PATH))"
                  supertypes="topological_representation_item">
                  <explicit
                    name="edge_list">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"
                      unique="YES"/>
                    <typename
                      name="oriented_edge"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="path_head_to_tail(SELF)">
                  </where>
                </entity>

                <entity
                  name="pcurve"
                  supertypes="curve">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="reference_to_curve">
                    <typename
                      name="definitional_representation"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(SIZEOF(reference_to_curve\representation.items) = 1)">
                  </where>
                  <where
                    label="wr2"
                    expression="('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\ representation.items[1]))">
                  </where>
                  <where
                    label="wr3"
                    expression="(reference_to_curve\representation.items[1]\ geometric_representation_item.dim = 2)">
                  </where>
                </entity>

                <entity
                  name="person">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="last_name"
                    optional="YES">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="first_name"
                    optional="YES">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="middle_names"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="prefix_titles"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="suffix_titles"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(EXISTS(last_name) OR EXISTS(first_name))">
                  </where>
                </entity>

                <entity
                  name="person_and_organization">
                  <explicit
                    name="the_person">
                    <typename
                      name="person"/>
                  </explicit>
                  <explicit
                    name="the_organization">
                    <typename
                      name="organization"/>
                  </explicit>
                  <derived
                    name="name"
                    expression="get_name_value(SELF)">
                    <typename
                      name="label"/>
                  </derived>
                  <derived
                    name="description"
                    expression="get_description_value(SELF)">
                    <typename
                      name="text"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="person_and_organization_assignment"
                  abstract.supertype="YES">
                  <explicit
                    name="assigned_person_and_organization">
                    <typename
                      name="person_and_organization"/>
                  </explicit>
                  <explicit
                    name="role">
                    <typename
                      name="person_and_organization_role"/>
                  </explicit>
                </entity>

                <entity
                  name="person_and_organization_role">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <derived
                    name="description"
                    expression="get_description_value(SELF)">
                    <typename
                      name="text"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="personal_address"
                  supertypes="address">
                  <explicit
                    name="people">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="person"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                </entity>

                <entity
                  name="placement"
                  super.expression="(ONEOF ( AXIS1_PLACEMENT, AXIS2_PLACEMENT_2D, AXIS2_PLACEMENT_3D))"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="location">
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="planar_box"
                  supertypes="planar_extent">
                  <explicit
                    name="placement">
                    <typename
                      name="axis2_placement"/>
                  </explicit>
                </entity>

                <entity
                  name="planar_extent"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="size_in_x">
                    <typename
                      name="length_measure"/>
                  </explicit>
                  <explicit
                    name="size_in_y">
                    <typename
                      name="length_measure"/>
                  </explicit>
                </entity>

                <entity
                  name="plane"
                  supertypes="elementary_surface">
                </entity>

                <entity
                  name="plane_angle_measure_with_unit"
                  supertypes="measure_with_unit">
                  <where
                    label="wr1"
                    expression="('SMCH_PLUS_203_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
                  </where>
                </entity>

                <entity
                  name="plane_angle_unit"
                  supertypes="named_unit">
                  <where
                    label="wr1"
                    expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\ named_unit.dimensions.mass_exponent = 0) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
                  </where>
                </entity>

                <entity
                  name="plus_minus_tolerance">
                  <explicit
                    name="range">
                    <typename
                      name="tolerance_method_definition"/>
                  </explicit>
                  <explicit
                    name="toleranced_dimension">
                    <typename
                      name="dimensional_characteristic"/>
                  </explicit>
                  <unique
                    label="ur1">
                    <unique.attribute
                      attribute="toleranced_dimension"/>
                  </unique>
                </entity>

                <entity
                  name="point"
                  super.expression="(ONEOF ( CARTESIAN_POINT, POINT_ON_CURVE, POINT_ON_SURFACE, POINT_REPLICA, DEGENERATE_PCURVE))"
                  supertypes="geometric_representation_item">
                </entity>

                <entity
                  name="point_on_curve"
                  supertypes="point">
                  <explicit
                    name="basis_curve">
                    <typename
                      name="curve"/>
                  </explicit>
                  <explicit
                    name="point_parameter">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                </entity>

                <entity
                  name="point_on_surface"
                  supertypes="point">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="point_parameter_u">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="point_parameter_v">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                </entity>

                <entity
                  name="point_replica"
                  supertypes="point">
                  <explicit
                    name="parent_pt">
                    <typename
                      name="point"/>
                  </explicit>
                  <explicit
                    name="transformation">
                    <typename
                      name="cartesian_transformation_operator"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(transformation.dim = parent_pt.dim)">
                  </where>
                  <where
                    label="wr2"
                    expression="acyclic_point_replica(SELF,parent_pt)">
                  </where>
                </entity>

                <entity
                  name="point_style">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="marker">
                    <typename
                      name="marker_select"/>
                  </explicit>
                  <explicit
                    name="marker_size">
                    <typename
                      name="size_select"/>
                  </explicit>
                  <explicit
                    name="marker_colour">
                    <typename
                      name="colour"/>
                  </explicit>
                </entity>

                <entity
                  name="poly_loop"
                  supertypes="loop geometric_representation_item">
                  <explicit
                    name="polygon">
                    <aggregate
                      type="LIST"
                      lower="3"
                      upper="?"
                      unique="YES"/>
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="polyline"
                  supertypes="bounded_curve">
                  <explicit
                    name="points">
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="?"/>
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="pre_defined_colour"
                  supertypes="pre_defined_item colour">
                </entity>

                <entity
                  name="pre_defined_curve_font"
                  supertypes="pre_defined_item">
                </entity>

                <entity
                  name="pre_defined_dimension_symbol"
                  supertypes="pre_defined_symbol">
                  <where
                    label="wr1"
                    expression="(SELF.name IN ['arc length','conical taper','counterbore','countersink','depth','diameter','plus minus','radius','slope','spherical diameter','spherical radius','square'])">
                  </where>
                </entity>

                <entity
                  name="pre_defined_item">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="pre_defined_marker"
                  supertypes="pre_defined_item">
                </entity>

                <entity
                  name="pre_defined_symbol"
                  supertypes="pre_defined_item">
                </entity>

                <entity
                  name="pre_defined_terminator_symbol"
                  supertypes="pre_defined_symbol">
                  <where
                    label="wr1"
                    expression="(SELF.name IN ['blanked arrow','blanked box','blanked dot','dimension origin','filled arrow','filled box','filled dot','integral symbol','open arrow','slash','unfilled arrow'])">
                  </where>
                </entity>

                <entity
                  name="pre_defined_text_font"
                  supertypes="pre_defined_item">
                </entity>

                <entity
                  name="presentation_area"
                  supertypes="presentation_representation">
                  <where
                    label="wr1"
                    expression="((SIZEOF(QUERY (ais &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'AREA_IN_SET.AREA') | (SIZEOF(USEDIN(ais,'SMCH_PLUS_203_SCHEMA.' + 'PRESENTATION_SIZE.UNIT')) = 1)))&gt; 0) OR (SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'PRESENTATION_SIZE.UNIT')) = 1))">
                  </where>
                </entity>

                <entity
                  name="presentation_layer_assignment">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="assigned_items">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="layered_item"/>
                  </explicit>
                </entity>

                <entity
                  name="presentation_representation"
                  supertypes="representation">
                  <where
                    label="wr1"
                    expression="(SELF\representation.context_of_items\ geometric_representation_context.coordinate_space_dimension= 2)">
                  </where>
                  <where
                    label="wr2"
                    expression="('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items))">
                  </where>
                </entity>

                <entity
                  name="presentation_set">
                  <inverse
                    name="areas"
                    entity="area_in_set"
                    attribute="in_set">
                    <inverse.aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                  </inverse>
                </entity>

                <entity
                  name="presentation_size">
                  <explicit
                    name="unit">
                    <typename
                      name="presentation_size_assignment_select"/>
                  </explicit>
                  <explicit
                    name="size">
                    <typename
                      name="planar_box"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="((('SMCH_PLUS_203_SCHEMA.PRESENTATION_REPRESENTATION' IN TYPEOF(SELF.unit)) AND item_in_context(SELF.size,SELF.unit\ representation.context_of_items)) OR (('SMCH_PLUS_203_SCHEMA.AREA_IN_SET' IN TYPEOF(SELF.unit)) AND(SIZEOF(QUERY (ais &lt;* SELF.unit\area_in_set.in_set.areas |(NOT item_in_context(SELF.size,ais.area\representation. context_of_items)))) = 0)))">
                  </where>
                </entity>

                <entity
                  name="presentation_style_assignment">
                  <explicit
                    name="styles">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="presentation_style_select"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(SIZEOF(QUERY (style1 &lt;* SELF.styles | (NOT (SIZEOF(QUERY (style2 &lt;* (SELF.styles - style1) | (NOT ((TYPEOF(style1) &lt;&gt; TYPEOF(style2)) OR (SIZEOF(['SMCH_PLUS_203_SCHEMA.' + 'SURFACE_STYLE_USAGE','SMCH_PLUS_203_SCHEMA.' + 'EXTERNALLY_DEFINED_STYLE'] * TYPEOF(style1)) = 1))))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(QUERY (style1 &lt;* SELF.styles | ('SMCH_PLUS_203_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF(style1))))&lt;= 2)">
                  </where>
                </entity>

                <entity
                  name="presentation_style_by_context"
                  supertypes="presentation_style_assignment">
                  <explicit
                    name="style_context">
                    <typename
                      name="style_context_select"/>
                  </explicit>
                </entity>

                <entity
                  name="presentation_view"
                  supertypes="presentation_representation">
                </entity>

                <entity
                  name="presented_item"
                  abstract.supertype="YES">
                </entity>

                <entity
                  name="presented_item_representation">
                  <explicit
                    name="presentation">
                    <typename
                      name="presentation_representation_select"/>
                  </explicit>
                  <explicit
                    name="item">
                    <typename
                      name="presented_item"/>
                  </explicit>
                </entity>

                <entity
                  name="product">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="frame_of_reference">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="product_context"/>
                  </explicit>
                </entity>

                <entity
                  name="product_category">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                </entity>

                <entity
                  name="product_category_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="category">
                    <typename
                      name="product_category"/>
                  </explicit>
                  <explicit
                    name="sub_category">
                    <typename
                      name="product_category"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="acyclic_product_category_relationship(SELF,[SELF.sub_category])">
                  </where>
                </entity>

                <entity
                  name="product_concept">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="market_context">
                    <typename
                      name="product_concept_context"/>
                  </explicit>
                  <unique
                    label="ur1">
                    <unique.attribute
                      attribute="id"/>
                  </unique>
                </entity>

                <entity
                  name="product_concept_context"
                  supertypes="application_context_element">
                  <explicit
                    name="market_segment_type">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_context"
                  supertypes="application_context_element">
                  <explicit
                    name="discipline_type">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="formation">
                    <typename
                      name="product_definition_formation"/>
                  </explicit>
                  <explicit
                    name="frame_of_reference">
                    <typename
                      name="product_definition_context"/>
                  </explicit>
                  <derived
                    name="name"
                    expression="get_name_value(SELF)">
                    <typename
                      name="label"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="product_definition_context"
                  supertypes="application_context_element">
                  <explicit
                    name="life_cycle_stage">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_effectivity"
                  supertypes="effectivity">
                  <explicit
                    name="usage">
                    <typename
                      name="product_definition_relationship"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0)">
                  </where>
                </entity>

                <entity
                  name="product_definition_formation">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="of_product">
                    <typename
                      name="product"/>
                  </explicit>
                  <unique
                    label="ur1">
                    <unique.attribute
                      attribute="id"/>
                    <unique.attribute
                      attribute="of_product"/>
                  </unique>
                </entity>

                <entity
                  name="product_definition_formation_with_specified_source"
                  supertypes="product_definition_formation">
                  <explicit
                    name="make_or_buy">
                    <typename
                      name="source"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_relationship">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="relating_product_definition">
                    <typename
                      name="product_definition"/>
                  </explicit>
                  <explicit
                    name="related_product_definition">
                    <typename
                      name="product_definition"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_shape"
                  supertypes="property_definition">
                  <unique
                    label="ur1">
                    <unique.attribute
                      attribute="definition"/>
                  </unique>
                  <where
                    label="wr1"
                    expression="(NOT ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF\ property_definition.definition)))">
                  </where>
                </entity>

                <entity
                  name="product_definition_usage"
                  super.expression="( ASSEMBLY_COMPONENT_USAGE)"
                  supertypes="product_definition_relationship">
                  <unique
                    label="ur1">
                    <unique.attribute
                      attribute="id"/>
                    <unique.attribute
                      attribute="relating_product_definition"/>
                    <unique.attribute
                      attribute="related_product_definition"/>
                  </unique>
                  <where
                    label="wr1"
                    expression="acyclic_product_definition_relationship(SELF,[SELF\ product_definition_relationship.related_product_definition],'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_USAGE')">
                  </where>
                </entity>

                <entity
                  name="product_definition_with_associated_documents"
                  supertypes="product_definition">
                  <explicit
                    name="documentation_ids">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="document"/>
                  </explicit>
                </entity>

                <entity
                  name="product_related_product_category"
                  supertypes="product_category">
                  <explicit
                    name="products">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="product"/>
                  </explicit>
                </entity>

                <entity
                  name="projection_curve"
                  supertypes="annotation_curve_occurrence">
                </entity>

                <entity
                  name="promissory_usage_occurrence"
                  supertypes="assembly_component_usage">
                </entity>

                <entity
                  name="property_definition">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="definition">
                    <typename
                      name="characterized_definition"/>
                  </explicit>
                </entity>

                <entity
                  name="property_definition_representation">
                  <explicit
                    name="definition">
                    <typename
                      name="represented_definition"/>
                  </explicit>
                  <explicit
                    name="used_representation">
                    <typename
                      name="representation"/>
                  </explicit>
                  <derived
                    name="description"
                    expression="get_description_value(SELF)">
                    <typename
                      name="text"/>
                  </derived>
                  <derived
                    name="name"
                    expression="get_name_value(SELF)">
                    <typename
                      name="label"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="quantified_assembly_component_usage"
                  supertypes="assembly_component_usage">
                  <explicit
                    name="quantity">
                    <typename
                      name="measure_with_unit"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="((NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component &gt; 0))">
                  </where>
                </entity>

                <entity
                  name="quasi_uniform_curve"
                  supertypes="b_spline_curve">
                </entity>

                <entity
                  name="quasi_uniform_surface"
                  supertypes="b_spline_surface">
                </entity>

                <entity
                  name="rational_b_spline_curve"
                  supertypes="b_spline_curve">
                  <explicit
                    name="weights_data">
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="?"/>
                    <builtintype
                      type="REAL"/>
                  </explicit>
                  <derived
                    name="weights"
                    expression="list_to_array(weights_data,0, upper_index_on_control_points)">
                    <aggregate
                      type="ARRAY"
                      lower="0"
                      upper="upper_index_on_control_points"/>
                    <builtintype
                      type="REAL"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. control_points_list))">
                  </where>
                  <where
                    label="wr2"
                    expression="curve_weights_positive(SELF)">
                  </where>
                </entity>

                <entity
                  name="rational_b_spline_surface"
                  supertypes="b_spline_surface">
                  <explicit
                    name="weights_data">
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="?"/>
                    <builtintype
                      type="REAL"/>
                  </explicit>
                  <derived
                    name="weights"
                    expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
                    <aggregate
                      type="ARRAY"
                      lower="0"
                      upper="u_upper"/>
                    <builtintype
                      type="REAL"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface. control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1])))">
                  </where>
                  <where
                    label="wr2"
                    expression="surface_weights_positive(SELF)">
                  </where>
                </entity>

                <entity
                  name="rectangular_composite_surface"
                  supertypes="bounded_surface">
                  <explicit
                    name="segments">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="LIST"/>
                  </explicit>
                  <derived
                    name="n_u"
                    expression="SIZEOF(segments)">
                    <builtintype
                      type="INTEGER"/>
                  </derived>
                  <derived
                    name="n_v"
                    expression="SIZEOF(segments[1])">
                    <builtintype
                      type="INTEGER"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(QUERY (s &lt;* segments | (n_v &lt;&gt; SIZEOF(s)))) = 0)">
                  </where>
                  <where
                    label="wr2"
                    expression="constraints_rectangular_composite_surface(SELF)">
                  </where>
                </entity>

                <entity
                  name="rectangular_trimmed_surface"
                  supertypes="bounded_surface">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="u1">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="u2">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="v1">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="v2">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="usense">
                    <builtintype
                      type="BOOLEAN"/>
                  </explicit>
                  <explicit
                    name="vsense">
                    <builtintype
                      type="BOOLEAN"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(u1 &lt;&gt; u2)">
                  </where>
                  <where
                    label="wr2"
                    expression="(v1 &lt;&gt; v2)">
                  </where>
                  <where
                    label="wr3"
                    expression="((('SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR ('SMCH_PLUS_203_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 &gt; u1)))">
                  </where>
                  <where
                    label="wr4"
                    expression="(('SMCH_PLUS_203_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('SMCH_PLUS_203_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)) OR (vsense = (v2 &gt; v1)))">
                  </where>
                </entity>

                <entity
                  name="reparametrised_composite_curve_segment"
                  supertypes="composite_curve_segment">
                  <explicit
                    name="param_length">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(param_length &gt; 0)">
                  </where>
                </entity>

                <entity
                  name="representation">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="items">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="representation_item"/>
                  </explicit>
                  <explicit
                    name="context_of_items">
                    <typename
                      name="representation_context"/>
                  </explicit>
                  <derived
                    name="id"
                    expression="get_id_value(SELF)">
                    <typename
                      name="identifier"/>
                  </derived>
                  <derived
                    name="description"
                    expression="get_description_value(SELF)">
                    <typename
                      name="text"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="representation_context">
                  <explicit
                    name="context_identifier">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="context_type">
                    <typename
                      name="text"/>
                  </explicit>
                  <inverse
                    name="representations_in_context"
                    entity="representation"
                    attribute="context_of_items">
                    <inverse.aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                  </inverse>
                </entity>

                <entity
                  name="representation_item">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(SIZEOF(using_representations(SELF)) &gt; 0)">
                  </where>
                </entity>

                <entity
                  name="representation_map">
                  <explicit
                    name="mapping_origin">
                    <typename
                      name="representation_item"/>
                  </explicit>
                  <explicit
                    name="mapped_representation">
                    <typename
                      name="representation"/>
                  </explicit>
                  <inverse
                    name="map_usage"
                    entity="mapped_item"
                    attribute="mapping_source">
                    <inverse.aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                  </inverse>
                  <where
                    label="wr1"
                    expression="item_in_context(SELF.mapping_origin,SELF.mapped_representation. context_of_items)">
                  </where>
                </entity>

                <entity
                  name="representation_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="rep_1">
                    <typename
                      name="representation"/>
                  </explicit>
                  <explicit
                    name="rep_2">
                    <typename
                      name="representation"/>
                  </explicit>
                </entity>

                <entity
                  name="representation_relationship_with_transformation"
                  supertypes="representation_relationship">
                  <explicit
                    name="transformation_operator">
                    <typename
                      name="transformation"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="(SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items)">
                  </where>
                </entity>

                <entity
                  name="role_association">
                  <explicit
                    name="role">
                    <typename
                      name="object_role"/>
                  </explicit>
                  <explicit
                    name="item_with_role">
                    <typename
                      name="role_select"/>
                  </explicit>
                </entity>

                <entity
                  name="seam_curve"
                  supertypes="surface_curve">
                  <where
                    label="wr1"
                    expression="(SIZEOF(SELF\surface_curve.associated_geometry) = 2)">
                  </where>
                  <where
                    label="wr2"
                    expression="(associated_surface(SELF\surface_curve.associated_geometry[1])= associated_surface(SELF\surface_curve.associated_geometry[2]))">
                  </where>
                  <where
                    label="wr3"
                    expression="('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve. associated_geometry[1]))">
                  </where>
                  <where
                    label="wr4"
                    expression="('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve. associated_geometry[2]))">
                  </where>
                </entity>

                <entity
                  name="security_classification">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="purpose">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="security_level">
                    <typename
                      name="security_classification_level"/>
                  </explicit>
                </entity>

                <entity
                  name="security_classification_assignment"
                  abstract.supertype="YES">
                  <explicit
                    name="assigned_security_classification">
                    <typename
                      name="security_classification"/>
                  </explicit>
                  <derived
                    name="role"
                    expression="get_role(SELF)">
                    <typename
                      name="object_role"/>
                  </derived>
                  <where
                    label="wr1"
                    expression="(SIZEOF(USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1)">
                  </where>
                </entity>

                <entity
                  name="security_classification_level">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="serial_numbered_effectivity"
                  supertypes="effectivity">
                  <explicit
                    name="effectivity_start_id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="effectivity_end_id"
                    optional="YES">
                    <typename
                      name="identifier"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_aspect">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="of_shape">
                    <typename
                      name="product_definition_shape"/>
                  </explicit>
                  <explicit
                    name="product_definitional">
                    <builtintype
                      type="LOGICAL"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_aspect_associativity"
                  supertypes="shape_aspect_relationship">
                  <where
                    label="wr1"
                    expression="SELF.relating_shape_aspect.product_definitional">
                  </where>
                  <where
                    label="wr2"
                    expression="(NOT SELF.related_shape_aspect.product_definitional)">
                  </where>
                  <where
                    label="wr3"
                    expression="(SIZEOF(QUERY (pd &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY (sdr &lt;* QUERY (pdr &lt;* USEDIN(pd,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr))) | (NOT (SIZEOF(QUERY (it &lt;* sdr. used_representation.items | ((NOT ('SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(it))) AND ((SIZEOF(QUERY (aco &lt;* USEDIN(it,'SMCH_PLUS_203_SCHEMA.STYLED_ITEM.ITEM') | (SIZEOF(TYPEOF(aco)* ['SMCH_PLUS_203_SCHEMA.LEADER_CURVE','SMCH_PLUS_203_SCHEMA.PROJECTION_CURVE']) = 1))) + SIZEOF(USEDIN(it,'SMCH_PLUS_203_SCHEMA.' +'ANNOTATION_FILL_AREA.BOUNDARIES'))) &gt;= 1)))) = 1)))) = 0))))= 0)">
                  </where>
                  <where
                    label="wr4"
                    expression="(SIZEOF(QUERY (pd &lt;* USEDIN(SELF,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY (sdr &lt;* QUERY (pdr &lt;* USEDIN(pd,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr))) | (NOT check_associative_shape_aspects(sdr))))= 0)))) = 0)">
                  </where>
                </entity>

                <entity
                  name="shape_aspect_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="relating_shape_aspect">
                    <typename
                      name="shape_aspect"/>
                  </explicit>
                  <explicit
                    name="related_shape_aspect">
                    <typename
                      name="shape_aspect"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_definition_representation"
                  supertypes="property_definition_representation">
                  <where
                    label="wr1"
                    expression="(('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition)))">
                  </where>
                  <where
                    label="wr2"
                    expression="('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF. used_representation))">
                  </where>
                </entity>

                <entity
                  name="shape_dimension_representation"
                  supertypes="shape_representation">
                  <where
                    label="wr1"
                    expression="(SIZEOF(QUERY (temp &lt;* SELF.items | (NOT ('SMCH_PLUS_203_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(temp))))) = 0)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(SELF.items) &lt;= 2)">
                  </where>
                  <where
                    label="wr3"
                    expression="(SIZEOF(QUERY (pos_mri &lt;* QUERY (real_mri &lt;* SELF.items | ('REAL' IN TYPEOF(real_mri\measure_with_unit.value_component)))| (NOT (pos_mri\measure_with_unit.value_component &gt; 0))))= 0)">
                  </where>
                </entity>

                <entity
                  name="shape_representation"
                  supertypes="representation">
                </entity>

                <entity
                  name="shape_representation_relationship"
                  supertypes="representation_relationship">
                  <where
                    label="wr1"
                    expression="('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\ representation_relationship.rep_1) + TYPEOF(SELF\ representation_relationship.rep_2)))">
                  </where>
                </entity>

                <entity
                  name="shell_based_surface_model"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="sbsm_boundary">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="shell"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="constraints_geometry_shell_based_surface_model(SELF)">
                  </where>
                </entity>

                <entity
                  name="shell_based_wireframe_model"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="sbwm_boundary">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="shell"/>
                  </explicit>
                  <where
                    label="wr1"
                    expression="constraints_geometry_shell_based_wireframe_model(SELF)">
                  </where>
                </entity>

                <entity
                  name="shell_based_wireframe_shape_representation"
                  supertypes="shape_representation">
                  <where
                    label="wr1"
                    expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (NOT (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM','SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))))= 0)">
                  </where>
                  <where
                    label="wr2"
                    expression="(SIZEOF(QUERY (it &lt;* SELF\representation.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL','SMCH_PLUS_203_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt;=1)">
                  </where>
                  <where
                    label="wr3"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (el &lt;* eloop\path.edge_list | (NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(el.edge_element)))))= 0)))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr4"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (pline_el &lt;* QUERY (el &lt;* eloop\path. edge_list | ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(el. edge_element\edge_curve.edge_geometry))) | (NOT (SIZEOF(pline_el.edge_element\edge_curve.edge_geometry\polyline. points) &gt; 2)))) = 0)))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr5"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (el &lt;* eloop\path.edge_list | (NOT valid_wireframe_edge_curve(el.edge_element\edge_curve. edge_geometry,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0))))= 0)))) = 0)">
                  </where>
                  <where
                    label="wr6"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (el &lt;* eloop\path.edge_list | (NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(el. edge_element.edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(el. edge_element.edge_end)))))) = 0)))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr7"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (el &lt;* eloop\path.edge_list | (NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\ vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN') AND valid_wireframe_vertex_point(el.edge_element.edge_end\ vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')))))= 0)))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr8"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(wsb))) | (NOT (SIZEOF(QUERY (con_edges &lt;* QUERY (el &lt;* eloop\path. edge_list | ('SMCH_PLUS_203_SCHEMA.CONIC' IN TYPEOF(el. edge_element\edge_curve.edge_geometry))) | (NOT ('SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(con_edges.edge_element\edge_curve.edge_geometry\conic. position))))) = 0)))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr9"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (vloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(wsb))) | (NOT('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vloop\ vertex_loop.loop_vertex))))) = 0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr10"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(sb))) | (NOT (SIZEOF(QUERY (vloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent | ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(wsb))) | (NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\ vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')))) =0)))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr11"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (vs &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN TYPEOF(sb))) | (NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vs\vertex_shell.vertex_shell_extent.loop_vertex)))))= 0)))) = 0)">
                  </where>
                  <where
                    label="wr12"
                    expression="(SIZEOF(QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(it))) | (NOT (SIZEOF(QUERY (vs &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model. sbwm_boundary | ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN TYPEOF(sb))) | (NOT valid_wireframe_vertex_point(vs\ vertex_shell.vertex_shell_extent.loop_vertex\vertex_point. vertex_geometry,'CONFIG_CONTROL_DESIGN')))) = 0)))) = 0)">
                  </where>
                  <where
                    label="wr13"
                    expression="(SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* SELF\representation. items | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)))| (NOT ('SMCH_PLUS_203_SCHEMA.SHELL_BASED_WIREFRAME_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source. mapped_representation))))) = 0)">
                  </where>
                </entity>

                <entity
                  name="si_unit"
                  supertypes="named_unit">
                  <explicit
                    name="prefix"
                    optional="YES">
                    <typename
                      name="si_prefix"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="si_unit_name"/>
                  </explicit>
                  <derived
                    name="dimensions"
                    expression="dimensions_for_si_unit(name)">
                    <typename
                      name="dimensional_exponents"/>
                    <redeclaration
                      entity-ref="named_unit"/>
                    </derived>
                  </entity>

                  <entity
                    name="solid_angle_measure_with_unit"
                    supertypes="measure_with_unit">
                    <where
                      label="wr1"
                      expression="('SMCH_PLUS_203_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
                    </where>
                  </entity>

                  <entity
                    name="solid_angle_unit"
                    supertypes="named_unit">
                    <where
                      label="wr1"
                      expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\ named_unit.dimensions.mass_exponent = 0) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
                    </where>
                  </entity>

                  <entity
                    name="solid_model"
                    super.expression="( MANIFOLD_SOLID_BREP)"
                    supertypes="geometric_representation_item">
                  </entity>

                  <entity
                    name="specified_higher_usage_occurrence"
                    supertypes="assembly_component_usage">
                    <explicit
                      name="upper_usage">
                      <typename
                        name="assembly_component_usage"/>
                    </explicit>
                    <explicit
                      name="next_usage">
                      <typename
                        name="next_assembly_usage_occurrence"/>
                    </explicit>
                    <unique
                      label="ur1">
                      <unique.attribute
                        attribute="upper_usage"/>
                      <unique.attribute
                        attribute="next_usage"/>
                    </unique>
                    <where
                      label="wr1"
                      expression="(SELF :&lt;&gt;: upper_usage)">
                    </where>
                    <where
                      label="wr2"
                      expression="(SELF\product_definition_relationship. relating_product_definition :=: upper_usage. relating_product_definition)">
                    </where>
                    <where
                      label="wr3"
                      expression="(SELF\product_definition_relationship. related_product_definition :=: next_usage. related_product_definition)">
                    </where>
                    <where
                      label="wr4"
                      expression="((upper_usage.related_product_definition :=: next_usage. relating_product_definition) OR (SIZEOF(QUERY (pdr &lt;* USEDIN(upper_usage.related_product_definition,'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +'RELATED_PRODUCT_DEFINITION') | (pdr. relating_product_definition :=: next_usage. relating_product_definition))) = 1))">
                    </where>
                    <where
                      label="wr5"
                      expression="(SIZEOF(['SMCH_PLUS_203_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE','SMCH_PLUS_203_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] * TYPEOF(upper_usage)) = 1)">
                    </where>
                  </entity>

                  <entity
                    name="spherical_surface"
                    supertypes="elementary_surface">
                    <explicit
                      name="radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="start_request"
                    supertypes="action_request_assignment">
                    <explicit
                      name="items">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="start_request_item"/>
                    </explicit>
                  </entity>

                  <entity
                    name="start_work"
                    supertypes="action_assignment">
                    <explicit
                      name="items">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="work_item"/>
                    </explicit>
                  </entity>

                  <entity
                    name="structured_dimension_callout"
                    supertypes="draughting_callout">
                    <where
                      label="wr1"
                      expression="(SIZEOF(TYPEOF(SELF) * ['ASSOC_DIM.LEADER_DIRECTED_CALLOUT','ASSOC_DIM.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0)">
                    </where>
                    <where
                      label="wr2"
                      expression="(SIZEOF(QUERY (ato &lt;* QUERY (con &lt;* SELF.contents | ('ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(con))) | (NOT (ato.name IN ['dimension value','tolerance value','unit text','prefix text','suffix text'])))) = 0)">
                    </where>
                    <where
                      label="wr3"
                      expression="(SIZEOF(QUERY (ato &lt;* QUERY (con &lt;* SELF.contents | ('ASSOC_DIM.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(con))) | (ato.name = 'dimension value'))) &gt;= 1)">
                    </where>
                  </entity>

                  <entity
                    name="styled_item"
                    supertypes="representation_item">
                    <explicit
                      name="styles">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="presentation_style_assignment"/>
                    </explicit>
                    <explicit
                      name="item">
                      <typename
                        name="representation_item"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="((SIZEOF(SELF.styles) = 1) XOR (SIZEOF(QUERY (pres_style &lt;* SELF.styles | (NOT (('SMCH_PLUS_203_SCHEMA.' +'PRESENTATION_STYLE_BY_CONTEXT') IN TYPEOF(pres_style)))))= 0))">
                    </where>
                  </entity>

                  <entity
                    name="supplied_part_relationship"
                    supertypes="product_definition_relationship">
                  </entity>

                  <entity
                    name="surface"
                    super.expression="(ONEOF ( ELEMENTARY_SURFACE, SWEPT_SURFACE, BOUNDED_SURFACE, OFFSET_SURFACE, SURFACE_REPLICA))"
                    supertypes="geometric_representation_item">
                  </entity>

                  <entity
                    name="surface_curve"
                    super.expression="(ONEOF ( INTERSECTION_CURVE, SEAM_CURVE))"
                    supertypes="curve">
                    <explicit
                      name="curve_3d">
                      <typename
                        name="curve"/>
                    </explicit>
                    <explicit
                      name="associated_geometry">
                      <aggregate
                        type="LIST"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="pcurve_or_surface"/>
                    </explicit>
                    <explicit
                      name="master_representation">
                      <typename
                        name="preferred_surface_curve_representation"/>
                    </explicit>
                    <derived
                      name="basis_surface"
                      expression="get_basis_surface(SELF)">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="surface"/>
                    </derived>
                    <where
                      label="wr1"
                      expression="(curve_3d.dim = 3)">
                    </where>
                    <where
                      label="wr2"
                      expression="(('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation &lt;&gt; pcurve_s1))">
                    </where>
                    <where
                      label="wr3"
                      expression="(('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation &lt;&gt; pcurve_s2))">
                    </where>
                    <where
                      label="wr4"
                      expression="(NOT ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(curve_3d)))">
                    </where>
                  </entity>

                  <entity
                    name="surface_of_linear_extrusion"
                    supertypes="swept_surface">
                    <explicit
                      name="extrusion_axis">
                      <typename
                        name="vector"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_of_revolution"
                    supertypes="swept_surface">
                    <explicit
                      name="axis_position">
                      <typename
                        name="axis1_placement"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_patch"
                    supertypes="founded_item">
                    <explicit
                      name="parent_surface">
                      <typename
                        name="bounded_surface"/>
                    </explicit>
                    <explicit
                      name="u_transition">
                      <typename
                        name="transition_code"/>
                    </explicit>
                    <explicit
                      name="v_transition">
                      <typename
                        name="transition_code"/>
                    </explicit>
                    <explicit
                      name="u_sense">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="v_sense">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <inverse
                      name="using_surfaces"
                      entity="rectangular_composite_surface"
                      attribute="segments">
                      <inverse.aggregate
                        type="BAG"
                        lower="1"
                        upper="?"/>
                    </inverse>
                    <where
                      label="wr1"
                      expression="(NOT ('SMCH_PLUS_203_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)))">
                    </where>
                  </entity>

                  <entity
                    name="surface_replica"
                    supertypes="surface">
                    <explicit
                      name="parent_surface">
                      <typename
                        name="surface"/>
                    </explicit>
                    <explicit
                      name="transformation">
                      <typename
                        name="cartesian_transformation_operator_3d"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="acyclic_surface_replica(SELF,parent_surface)">
                    </where>
                  </entity>

                  <entity
                    name="surface_side_style">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="styles">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="7"/>
                      <typename
                        name="surface_style_element_select"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(SIZEOF(QUERY (style1 &lt;* SELF.styles | (SIZEOF(QUERY (style2 &lt;* (SELF.styles - style1) | (TYPEOF(style1) = TYPEOF(style2)))) &gt; 0))) = 0)">
                    </where>
                  </entity>

                  <entity
                    name="surface_style_boundary">
                    <explicit
                      name="style_of_boundary">
                      <typename
                        name="curve_or_render"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_style_control_grid">
                    <explicit
                      name="style_of_control_grid">
                      <typename
                        name="curve_or_render"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_style_fill_area">
                    <explicit
                      name="fill_area">
                      <typename
                        name="fill_area_style"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_style_parameter_line">
                    <explicit
                      name="style_of_parameter_lines">
                      <typename
                        name="curve_or_render"/>
                    </explicit>
                    <explicit
                      name="direction_counts">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="direction_count_select"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="((HIINDEX(SELF.direction_counts) = 1) XOR (TYPEOF(SELF. direction_counts[1]) &lt;&gt; TYPEOF(SELF.direction_counts[2])))">
                    </where>
                  </entity>

                  <entity
                    name="surface_style_segmentation_curve">
                    <explicit
                      name="style_of_segmentation_curve">
                      <typename
                        name="curve_or_render"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_style_silhouette">
                    <explicit
                      name="style_of_silhouette">
                      <typename
                        name="curve_or_render"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_style_usage">
                    <explicit
                      name="side">
                      <typename
                        name="surface_side"/>
                    </explicit>
                    <explicit
                      name="style">
                      <typename
                        name="surface_side_style_select"/>
                    </explicit>
                  </entity>

                  <entity
                    name="swept_surface"
                    super.expression="(ONEOF ( SURFACE_OF_LINEAR_EXTRUSION, SURFACE_OF_REVOLUTION))"
                    supertypes="surface">
                    <explicit
                      name="swept_curve">
                      <typename
                        name="curve"/>
                    </explicit>
                  </entity>

                  <entity
                    name="symbol_colour">
                    <explicit
                      name="colour_of_symbol">
                      <typename
                        name="colour"/>
                    </explicit>
                  </entity>

                  <entity
                    name="symbol_style">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="style_of_symbol">
                      <typename
                        name="symbol_style_select"/>
                    </explicit>
                  </entity>

                  <entity
                    name="symbol_target"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="placement">
                      <typename
                        name="axis2_placement"/>
                    </explicit>
                    <explicit
                      name="x_scale">
                      <typename
                        name="positive_ratio_measure"/>
                    </explicit>
                    <explicit
                      name="y_scale">
                      <typename
                        name="positive_ratio_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="terminator_symbol"
                    supertypes="annotation_symbol_occurrence">
                    <explicit
                      name="annotated_curve">
                      <typename
                        name="annotation_curve_occurrence"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_literal"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="literal">
                      <typename
                        name="presentable_text"/>
                    </explicit>
                    <explicit
                      name="placement">
                      <typename
                        name="axis2_placement"/>
                    </explicit>
                    <explicit
                      name="alignment">
                      <typename
                        name="text_alignment"/>
                    </explicit>
                    <explicit
                      name="path">
                      <typename
                        name="text_path"/>
                    </explicit>
                    <explicit
                      name="font">
                      <typename
                        name="font_select"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_literal_with_associated_curves"
                    supertypes="text_literal">
                    <explicit
                      name="associated_curves">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="curve"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_literal_with_blanking_box"
                    supertypes="text_literal">
                    <explicit
                      name="blanking">
                      <typename
                        name="planar_box"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_literal_with_extent"
                    supertypes="text_literal">
                    <explicit
                      name="extent">
                      <typename
                        name="planar_extent"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_style">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="character_appearance">
                      <typename
                        name="character_style_select"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_style_for_defined_font">
                    <explicit
                      name="text_colour">
                      <typename
                        name="colour"/>
                    </explicit>
                  </entity>

                  <entity
                    name="text_style_with_box_characteristics"
                    supertypes="text_style">
                    <explicit
                      name="characteristics">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="4"/>
                      <typename
                        name="box_characteristic_select"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(SIZEOF(QUERY (c1 &lt;* SELF.characteristics | (SIZEOF(QUERY (c2 &lt;* (SELF.characteristics - c1) | (TYPEOF(c1) = TYPEOF(c2)))) &gt; 0))) = 0)">
                    </where>
                  </entity>

                  <entity
                    name="tolerance_value">
                    <explicit
                      name="lower_bound">
                      <typename
                        name="measure_with_unit"/>
                    </explicit>
                    <explicit
                      name="upper_bound">
                      <typename
                        name="measure_with_unit"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(upper_bound.value_component &gt; lower_bound.value_component)">
                    </where>
                    <where
                      label="wr2"
                      expression="(upper_bound.unit_component = lower_bound.unit_component)">
                    </where>
                  </entity>

                  <entity
                    name="topological_representation_item"
                    super.expression="(ONEOF ( VERTEX, EDGE, FACE_BOUND, FACE, VERTEX_SHELL, WIRE_SHELL, CONNECTED_EDGE_SET, CONNECTED_FACE_SET, LOOP ANDOR PATH))"
                    supertypes="representation_item">
                  </entity>

                  <entity
                    name="toroidal_surface"
                    supertypes="elementary_surface">
                    <explicit
                      name="major_radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="minor_radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="trimmed_curve"
                    supertypes="bounded_curve">
                    <explicit
                      name="basis_curve">
                      <typename
                        name="curve"/>
                    </explicit>
                    <explicit
                      name="trim_1">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="trimming_select"/>
                    </explicit>
                    <explicit
                      name="trim_2">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="trimming_select"/>
                    </explicit>
                    <explicit
                      name="sense_agreement">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="master_representation">
                      <typename
                        name="trimming_preference"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2])))">
                    </where>
                    <where
                      label="wr2"
                      expression="((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2])))">
                    </where>
                  </entity>

                  <entity
                    name="uncertainty_measure_with_unit"
                    supertypes="measure_with_unit">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="description"
                      optional="YES">
                      <typename
                        name="text"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="valid_measure_value(SELF\measure_with_unit.value_component)">
                    </where>
                  </entity>

                  <entity
                    name="uniform_curve"
                    supertypes="b_spline_curve">
                  </entity>

                  <entity
                    name="uniform_surface"
                    supertypes="b_spline_surface">
                  </entity>

                  <entity
                    name="user_defined_curve_font"
                    supertypes="curve_style_font mapped_item">
                  </entity>

                  <entity
                    name="user_defined_marker"
                    supertypes="pre_defined_marker mapped_item">
                  </entity>

                  <entity
                    name="user_defined_terminator_symbol"
                    supertypes="pre_defined_symbol mapped_item">
                  </entity>

                  <entity
                    name="value_representation_item"
                    supertypes="representation_item">
                    <explicit
                      name="value_component">
                      <typename
                        name="measure_value"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(SIZEOF(QUERY (rep &lt;* using_representations(SELF) | (NOT ('SMCH_PLUS_203_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(rep.context_of_items))))) = 0)">
                    </where>
                  </entity>

                  <entity
                    name="vector"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="orientation">
                      <typename
                        name="direction"/>
                    </explicit>
                    <explicit
                      name="magnitude">
                      <typename
                        name="length_measure"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(magnitude &gt;= 0)">
                    </where>
                  </entity>

                  <entity
                    name="vector_style"
                    supertypes="curve_style pre_defined_terminator_symbol">
                  </entity>

                  <entity
                    name="versioned_action_request">
                    <explicit
                      name="id">
                      <typename
                        name="identifier"/>
                    </explicit>
                    <explicit
                      name="version">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="purpose">
                      <typename
                        name="text"/>
                    </explicit>
                    <explicit
                      name="description"
                      optional="YES">
                      <typename
                        name="text"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex"
                    supertypes="topological_representation_item">
                  </entity>

                  <entity
                    name="vertex_loop"
                    supertypes="loop">
                    <explicit
                      name="loop_vertex">
                      <typename
                        name="vertex"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex_point"
                    supertypes="vertex geometric_representation_item">
                    <explicit
                      name="vertex_geometry">
                      <typename
                        name="point"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex_shell"
                    supertypes="topological_representation_item">
                    <explicit
                      name="vertex_shell_extent">
                      <typename
                        name="vertex_loop"/>
                    </explicit>
                  </entity>

                  <entity
                    name="view_volume">
                    <explicit
                      name="projection_type">
                      <typename
                        name="central_or_parallel"/>
                    </explicit>
                    <explicit
                      name="projection_point">
                      <typename
                        name="cartesian_point"/>
                    </explicit>
                    <explicit
                      name="view_plane_distance">
                      <typename
                        name="length_measure"/>
                    </explicit>
                    <explicit
                      name="front_plane_distance">
                      <typename
                        name="length_measure"/>
                    </explicit>
                    <explicit
                      name="front_plane_clipping">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="back_plane_distance">
                      <typename
                        name="length_measure"/>
                    </explicit>
                    <explicit
                      name="back_plane_clipping">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="view_volume_sides_clipping">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="view_window">
                      <typename
                        name="planar_box"/>
                    </explicit>
                  </entity>

                  <entity
                    name="volume_measure_with_unit"
                    supertypes="measure_with_unit">
                    <where
                      label="wr1"
                      expression="('SMCH_PLUS_203_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component))">
                    </where>
                  </entity>

                  <entity
                    name="volume_unit"
                    supertypes="named_unit">
                    <where
                      label="wr1"
                      expression="((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\ named_unit.dimensions.mass_exponent = 0) AND (SELF\ named_unit.dimensions.time_exponent = 0) AND (SELF\ named_unit.dimensions.electric_current_exponent = 0) AND (SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND (SELF\ named_unit.dimensions.luminous_intensity_exponent = 0))">
                    </where>
                  </entity>

                  <entity
                    name="week_of_year_and_day_date"
                    supertypes="date">
                    <explicit
                      name="week_component">
                      <typename
                        name="week_in_year_number"/>
                    </explicit>
                    <explicit
                      name="day_component"
                      optional="YES">
                      <typename
                        name="day_in_week_number"/>
                    </explicit>
                  </entity>

                  <entity
                    name="wire_shell"
                    supertypes="topological_representation_item">
                    <explicit
                      name="wire_shell_extent">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="loop"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="(NOT mixed_loop_type_set(wire_shell_extent))">
                    </where>
                  </entity>

                  <entity
                    name="blend"
                    abstract.supertype="YES"
                    super.expression="( EDGE_BLEND)"
                    supertypes="transition_feature">
                  </entity>

                  <entity
                    name="block"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="position">
                      <typename
                        name="axis2_placement_3d"/>
                    </explicit>
                    <explicit
                      name="x">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="y">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="z">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="boolean_result"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="operator">
                      <typename
                        name="boolean_operator"/>
                    </explicit>
                    <explicit
                      name="first_operand">
                      <typename
                        name="boolean_operand"/>
                    </explicit>
                    <explicit
                      name="second_operand">
                      <typename
                        name="boolean_operand"/>
                    </explicit>
                  </entity>

                  <entity
                    name="bounded_pcurve"
                    supertypes="pcurve bounded_curve">
                    <where
                      label="WR1"
                      expression="'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1])">
                    </where>
                  </entity>

                  <entity
                    name="bounded_surface_curve"
                    supertypes="surface_curve bounded_curve">
                    <where
                      label="WR1"
                      expression="'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d)">
                    </where>
                  </entity>

                  <entity
                    name="box_domain">
                    <explicit
                      name="corner">
                      <typename
                        name="cartesian_point"/>
                    </explicit>
                    <explicit
                      name="xlength">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="ylength">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="zlength">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="SIZEOF(QUERY (item &lt;* USEDIN(SELF, '')| NOT ('SMCH_PLUS_203_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0">
                    </where>
                  </entity>

                  <entity
                    name="boxed_half_space"
                    supertypes="half_space_solid">
                    <explicit
                      name="enclosure">
                      <typename
                        name="box_domain"/>
                    </explicit>
                  </entity>

                  <entity
                    name="brep_2d"
                    supertypes="solid_model">
                    <explicit
                      name="extent">
                      <typename
                        name="face"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_SURFACE', 'SMCH_PLUS_203_SCHEMA.SUBFACE', 'SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' ] * TYPEOF(SELF.extent)) = 0">
                    </where>
                    <where
                      label="WR2"
                      expression="SIZEOF(QUERY (bnds &lt;* extent.bounds| NOT ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))) = 0">
                    </where>
                    <where
                      label="WR3"
                      expression="SIZEOF(QUERY (bnds &lt;* extent.bounds| ('SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))) = 1">
                    </where>
                    <where
                      label="WR4"
                      expression="SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* extent.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| NOT (('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2)))) = 0))) = 0">
                    </where>
                  </entity>

                  <entity
                    name="characterized_object">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="description"
                      optional="YES">
                      <typename
                        name="text"/>
                    </explicit>
                  </entity>

                  <entity
                    name="circular_area"
                    supertypes="primitive_2d">
                    <explicit
                      name="centre">
                      <typename
                        name="cartesian_point"/>
                    </explicit>
                    <explicit
                      name="radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="convex_hexahedron"
                    supertypes="faceted_primitive">
                    <where
                      label="WR1"
                      expression="SIZEOF(points) = 8">
                    </where>
                    <where
                      label="WR2"
                      expression="above_plane(points[1], points[2], points[3], points[4]) = 0.00000">
                    </where>
                    <where
                      label="WR3"
                      expression="above_plane(points[5], points[8], points[7], points[6]) = 0.00000">
                    </where>
                    <where
                      label="WR4"
                      expression="above_plane(points[1], points[4], points[8], points[5]) = 0.00000">
                    </where>
                    <where
                      label="WR5"
                      expression="above_plane(points[4], points[3], points[7], points[8]) = 0.00000">
                    </where>
                    <where
                      label="WR6"
                      expression="above_plane(points[3], points[2], points[6], points[7]) = 0.00000">
                    </where>
                    <where
                      label="WR7"
                      expression="above_plane(points[1], points[5], points[6], points[2]) = 0.00000">
                    </where>
                    <where
                      label="WR8"
                      expression="same_side([ points[1], points[2], points[3] ], [ points[5], points[6], points[7], points[8] ])">
                    </where>
                    <where
                      label="WR9"
                      expression="same_side([ points[1], points[4], points[8] ], [ points[3], points[7], points[6], points[2] ])">
                    </where>
                    <where
                      label="WR10"
                      expression="same_side([ points[1], points[2], points[5] ], [ points[3], points[7], points[8], points[4] ])">
                    </where>
                    <where
                      label="WR11"
                      expression="same_side([ points[5], points[6], points[7] ], [ points[1], points[2], points[3], points[4] ])">
                    </where>
                    <where
                      label="WR12"
                      expression="same_side([ points[3], points[7], points[6] ], [ points[1], points[4], points[8], points[5] ])">
                    </where>
                    <where
                      label="WR13"
                      expression="same_side([ points[3], points[7], points[8] ], [ points[1], points[5], points[6], points[2] ])">
                    </where>
                  </entity>

                  <entity
                    name="csg_solid"
                    supertypes="solid_model">
                    <explicit
                      name="tree_root_expression">
                      <typename
                        name="csg_select"/>
                    </explicit>
                  </entity>

                  <entity
                    name="cyclide_segment_solid"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="position">
                      <typename
                        name="axis2_placement_3d"/>
                    </explicit>
                    <explicit
                      name="radius1">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="radius2">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="cone_angle1">
                      <typename
                        name="plane_angle_measure"/>
                    </explicit>
                    <explicit
                      name="cone_angle2">
                      <typename
                        name="plane_angle_measure"/>
                    </explicit>
                    <explicit
                      name="turn_angle">
                      <typename
                        name="plane_angle_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="data_environment">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="description">
                      <typename
                        name="text"/>
                    </explicit>
                    <explicit
                      name="elements">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="property_definition_representation"/>
                    </explicit>
                  </entity>

                  <entity
                    name="date_assignment"
                    abstract.supertype="YES">
                    <explicit
                      name="assigned_date">
                      <typename
                        name="date"/>
                    </explicit>
                    <explicit
                      name="role">
                      <typename
                        name="date_role"/>
                    </explicit>
                  </entity>

                  <entity
                    name="date_role">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <derived
                      name="description"
                      expression="get_description_value(SELF)">
                      <typename
                        name="text"/>
                    </derived>
                    <where
                      label="WR1"
                      expression="SIZEOF(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                    </where>
                  </entity>

                  <entity
                    name="degenerate_toroidal_surface"
                    supertypes="toroidal_surface">
                    <explicit
                      name="select_outer">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="major_radius &lt; minor_radius">
                    </where>
                  </entity>

                  <entity
                    name="descriptive_representation_item"
                    supertypes="representation_item">
                    <explicit
                      name="description">
                      <typename
                        name="text"/>
                    </explicit>
                  </entity>

                  <entity
                    name="dual_model"
                    supertypes="representation_relationship">
                    <explicit
                      name="rep_1">
                      <typename
                        name="procedural_representation"/>
                      <redeclaration
                        entity-ref="representation_relationship"/>
                      </explicit>
                      <explicit
                        name="rep_2">
                        <typename
                          name="explicit_representation"/>
                        <redeclaration
                          entity-ref="representation_relationship"/>
                        </explicit>
                      </entity>

                      <entity
                        name="dual_shape_model"
                        supertypes="dual_model">
                        <explicit
                          name="rep_1">
                          <typename
                            name="procedural_shape_representation"/>
                          <redeclaration
                            entity-ref="representation_relationship"/>
                          </explicit>
                          <explicit
                            name="rep_2">
                            <typename
                              name="explicit_shape_representation"/>
                            <redeclaration
                              entity-ref="representation_relationship"/>
                            </explicit>
                          </entity>

                          <entity
                            name="eccentric_cone"
                            supertypes="geometric_representation_item">
                            <explicit
                              name="position">
                              <typename
                                name="axis2_placement_3d"/>
                            </explicit>
                            <explicit
                              name="semi_axis_1">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="semi_axis_2">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="height">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="x_offset">
                              <typename
                                name="length_measure"/>
                            </explicit>
                            <explicit
                              name="y_offset">
                              <typename
                                name="length_measure"/>
                            </explicit>
                            <explicit
                              name="ratio">
                              <builtintype
                                type="REAL"/>
                            </explicit>
                            <where
                              label="WR1"
                              expression="ratio &gt;= 0.00000">
                            </where>
                          </entity>

                          <entity
                            name="edge_blend"
                            abstract.supertype="YES"
                            super.expression="(ONEOF ( EDGE_BLEND_FILLET, EDGE_BLEND_ROUND, EDGE_BLEND_CHAMFER))"
                            supertypes="blend selected_geometric_element">
                          </entity>

                          <entity
                            name="edge_blend_chamfer"
                            supertypes="edge_blend">
                          </entity>

                          <entity
                            name="edge_blend_fillet"
                            super.expression="(ONEOF ( EDGE_BLEND_FILLET_CONSTANT_RADIUS, EDGE_BLEND_FILLET_VARIABLE_RADIUS))"
                            supertypes="edge_blend">
                          </entity>

                          <entity
                            name="edge_blend_fillet_constant_radius"
                            supertypes="edge_blend_fillet">
                            <where
                              label="WR1"
                              expression="NOT (SELF\shape_aspect.description = 'constant radius') OR (SIZEOF(QUERY (pd &lt;* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep &lt;* QUERY (pdr &lt;* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(impl_rep.used_representation.items) = 1))) = 0))) = 0)">
                            </where>
                          </entity>

                          <entity
                            name="edge_blend_fillet_variable_radius"
                            supertypes="edge_blend_fillet">
                          </entity>

                          <entity
                            name="edge_blend_round"
                            super.expression="(ONEOF ( edge_blend_round_constant_radius, EDGE_BLEND_ROUND_VARIABLE_RADIUS))"
                            supertypes="edge_blend">
                          </entity>

                          <entity
                            name="edge_blend_round_constant_radius"
                            supertypes="edge_blend_round">
                            <where
                              label="WR1"
                              expression="NOT (SELF\shape_aspect.description = 'constant radius') OR (SIZEOF(QUERY (pd &lt;* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep &lt;* QUERY (pdr &lt;* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(impl_rep.used_representation.items) = 1))) = 0))) = 0)">
                            </where>
                          </entity>

                          <entity
                            name="edge_blend_round_variable_radius"
                            supertypes="edge_blend_round">
                          </entity>

                          <entity
                            name="elementary_brep_shape_representation"
                            supertypes="shape_representation">
                          </entity>

                          <entity
                            name="ellipsoid"
                            supertypes="geometric_representation_item">
                            <explicit
                              name="position">
                              <typename
                                name="axis2_placement_3d"/>
                            </explicit>
                            <explicit
                              name="semi_axis_1">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="semi_axis_2">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="semi_axis_3">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                          </entity>

                          <entity
                            name="elliptic_area"
                            supertypes="primitive_2d">
                            <explicit
                              name="position">
                              <typename
                                name="axis2_placement_2d"/>
                            </explicit>
                            <explicit
                              name="semi_axis_1">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                            <explicit
                              name="semi_axis_2">
                              <typename
                                name="positive_length_measure"/>
                            </explicit>
                          </entity>

                          <entity
                            name="expanded_uncertainty"
                            supertypes="standard_uncertainty">
                            <explicit
                              name="coverage_factor">
                              <builtintype
                                type="REAL"/>
                            </explicit>
                          </entity>

                          <entity
                            name="explicit_representation"
                            supertypes="representation">
                            <where
                              label="WR1"
                              expression="NOT ('SMCH_PLUS_203_SCHEMA.PROCEDURAL_REPRESENTATION' IN TYPEOF(SELF))">
                            </where>
                          </entity>

                          <entity
                            name="explicit_shape_representation"
                            supertypes="explicit_representation shape_representation">
                            <where
                              label="WR1"
                              expression="SIZEOF(TYPEOF(SELF) * [ 'SMCH_PLUS_203_SCHEMA.ADVANCED_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.ELEMENTARY_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.FACETED_BREP_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.MANIFOLD_SURFACE_SHAPE_REPRESENTATION', 'SMCH_PLUS_203_SCHEMA.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' ]) = 1">
                            </where>
                          </entity>

                          <entity
                            name="explicit_shape_submodel"
                            supertypes="explicit_submodel">
                            <explicit
                              name="submodel_elements">
                              <aggregate
                                type="SET"
                                lower="1"
                                upper="?"/>
                              <typename
                                name="shape_representation_item"/>
                              <redeclaration
                                entity-ref="explicit_submodel"/>
                              </explicit>
                            </entity>

                            <entity
                              name="explicit_submodel">
                              <explicit
                                name="submodel_elements">
                                <typename
                                  name="set_representation_item"/>
                              </explicit>
                            </entity>

                            <entity
                              name="extruded_area_solid"
                              supertypes="swept_area_solid">
                              <explicit
                                name="extruded_direction">
                                <typename
                                  name="direction"/>
                              </explicit>
                              <explicit
                                name="depth">
                                <typename
                                  name="positive_length_measure"/>
                              </explicit>
                              <where
                                label="WR1"
                                expression="dot_product(SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3], extruded_direction) &lt;&gt; 0.00000">
                              </where>
                            </entity>

                            <entity
                              name="extruded_face_solid"
                              supertypes="swept_face_solid">
                              <explicit
                                name="extruded_direction">
                                <typename
                                  name="direction"/>
                              </explicit>
                              <explicit
                                name="depth">
                                <typename
                                  name="positive_length_measure"/>
                              </explicit>
                              <where
                                label="WR1"
                                expression="dot_product(SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3], extruded_direction) &lt;&gt; 0.00000">
                              </where>
                            </entity>

                            <entity
                              name="face_based_surface_model"
                              supertypes="geometric_representation_item">
                              <explicit
                                name="fbsm_faces">
                                <aggregate
                                  type="SET"
                                  lower="1"
                                  upper="?"/>
                                <typename
                                  name="connected_face_set"/>
                              </explicit>
                            </entity>

                            <entity
                              name="faceted_primitive"
                              super.expression="(ONEOF ( TETRAHEDRON, CONVEX_HEXAHEDRON))"
                              supertypes="geometric_representation_item">
                              <explicit
                                name="points">
                                <aggregate
                                  type="LIST"
                                  lower="4"
                                  upper="?"
                                  unique="YES"/>
                                <typename
                                  name="cartesian_point"/>
                              </explicit>
                              <where
                                label="WR1"
                                expression="points[1].dim = 3">
                              </where>
                            </entity>

                            <entity
                              name="feature_component_definition"
                              supertypes="characterized_object">
                              <where
                                label="WR1"
                                expression="SIZEOF(QUERY (pd &lt;* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.SHAPE_ASPECT.OF_SHAPE')) = 1))) = 0">
                              </where>
                            </entity>

                            <entity
                              name="feature_definition"
                              supertypes="characterized_object">
                              <where
                                label="WR1"
                                expression="SIZEOF(QUERY (pd &lt;* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (pdr &lt;* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.' + 'SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))) = 1))) = 0">
                              </where>
                              <where
                                label="WR2"
                                expression="SIZEOF(QUERY (pd &lt;* USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| NOT (SIZEOF(QUERY (impl_rep &lt;* QUERY (pdr &lt;* USEDIN(pd, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| ('SMCH_PLUS_203_SCHEMA.' + 'SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))| NOT (SIZEOF(QUERY (it &lt;* impl_rep.used_representation.items| ('SMCH_PLUS_203_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND (it.name = 'orientation'))) = 1))) = 0))) = 0">
                              </where>
                            </entity>

                            <entity
                              name="geometric_operation_sequence"
                              supertypes="geometric_representation_item operation_sequence">
                              <where
                                label="WR1"
                                expression="SIZEOF(QUERY (q &lt;* SELF.created_elements| (SIZEOF(TYPEOF(q) * [ 'SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.TOPOLOGICAL_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.SOLID_MODEL', 'SMCH_PLUS_203_SCHEMA.SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.WIREFRAME_MODEL' ]) &lt;&gt; 1))) = 0">
                              </where>
                            </entity>

                            <entity
                              name="geometric_set_replica"
                              supertypes="geometric_set">
                              <explicit
                                name="parent_set">
                                <typename
                                  name="geometric_set"/>
                              </explicit>
                              <explicit
                                name="transformation">
                                <typename
                                  name="cartesian_transformation_operator"/>
                              </explicit>
                              <derived
                                name="elements"
                                expression="build_transformed_set(transformation, parent_set)">
                                <aggregate
                                  type="SET"
                                  lower="1"
                                  upper="?"/>
                                <typename
                                  name="geometric_set_select"/>
                                <redeclaration
                                  entity-ref="geometric_set"/>
                                </derived>
                                <where
                                  label="WR1"
                                  expression="acyclic_set_replica(SELF, parent_set)">
                                </where>
                              </entity>

                              <entity
                                name="half_space_2d"
                                supertypes="geometric_representation_item">
                                <explicit
                                  name="base_curve">
                                  <typename
                                    name="curve"/>
                                </explicit>
                                <explicit
                                  name="agreement_flag">
                                  <builtintype
                                    type="BOOLEAN"/>
                                </explicit>
                              </entity>

                              <entity
                                name="half_space_solid"
                                supertypes="geometric_representation_item">
                                <explicit
                                  name="base_surface">
                                  <typename
                                    name="surface"/>
                                </explicit>
                                <explicit
                                  name="agreement_flag">
                                  <builtintype
                                    type="BOOLEAN"/>
                                </explicit>
                              </entity>

                              <entity
                                name="instanced_feature"
                                supertypes="feature_definition shape_aspect">
                                <where
                                  label="WR1"
                                  expression="'SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition)">
                                </where>
                                <where
                                  label="WR2"
                                  expression="SELF.product_definitional">
                                </where>
                              </entity>

                              <entity
                                name="make_from_usage_option"
                                supertypes="product_definition_usage">
                                <explicit
                                  name="ranking">
                                  <builtintype
                                    type="INTEGER"/>
                                </explicit>
                                <explicit
                                  name="ranking_rationale">
                                  <typename
                                    name="text"/>
                                </explicit>
                                <explicit
                                  name="quantity">
                                  <typename
                                    name="measure_with_unit"/>
                                </explicit>
                                <where
                                  label="WR1"
                                  expression="NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.value_component &gt; 0)">
                                </where>
                              </entity>

                              <entity
                                name="material_designation">
                                <explicit
                                  name="name">
                                  <typename
                                    name="label"/>
                                </explicit>
                                <explicit
                                  name="definitions">
                                  <aggregate
                                    type="SET"
                                    lower="1"
                                    upper="?"/>
                                  <typename
                                    name="characterized_definition"/>
                                </explicit>
                              </entity>

                              <entity
                                name="material_property"
                                supertypes="property_definition">
                                <unique
                                  label="UR1">
                                  <unique.attribute
                                    entity-ref="property_definition"
                                    attribute="name"/>
                                  <unique.attribute
                                    entity-ref="property_definition"
                                    attribute="definition"/>
                                </unique>
                                <where
                                  label="WR1"
                                  expression="('SMCH_PLUS_203_SCHEMA.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) - QUERY (temp &lt;* bag_to_set(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))| ('SMCH_PLUS_203_SCHEMA.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp)))) = 0)">
                                </where>
                              </entity>

                              <entity
                                name="material_property_representation"
                                supertypes="property_definition_representation">
                                <explicit
                                  name="dependent_environment">
                                  <typename
                                    name="data_environment"/>
                                </explicit>
                              </entity>

                              <entity
                                name="measure_qualification">
                                <explicit
                                  name="name">
                                  <typename
                                    name="label"/>
                                </explicit>
                                <explicit
                                  name="description">
                                  <typename
                                    name="text"/>
                                </explicit>
                                <explicit
                                  name="qualified_measure">
                                  <typename
                                    name="measure_with_unit"/>
                                </explicit>
                                <explicit
                                  name="qualifiers">
                                  <aggregate
                                    type="SET"
                                    lower="1"
                                    upper="?"/>
                                  <typename
                                    name="value_qualifier"/>
                                </explicit>
                                <where
                                  label="WR1"
                                  expression="SIZEOF(QUERY (temp &lt;* qualifiers| ('SMCH_PLUS_203_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp)))) &lt; 2">
                                </where>
                              </entity>

                              <entity
                                name="non_manifold_surface_shape_representation"
                                supertypes="shape_representation">
                                <where
                                  label="WR1"
                                  expression="SIZEOF(QUERY (it &lt;* SELF.items| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM', 'SMCH_PLUS_203_SCHEMA.AXIS2_PLACEMENT_3D' ] * TYPEOF(it)) = 1))) = 0">
                                </where>
                                <where
                                  label="WR2"
                                  expression="SIZEOF(QUERY (it &lt;* SELF.items| (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL', 'SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' ] * TYPEOF(it)) = 1))) &gt; 0">
                                </where>
                                <where
                                  label="WR3"
                                  expression="SIZEOF(QUERY (mi &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)))| NOT (('SMCH_PLUS_203_SCHEMA.' + 'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY (mr_it &lt;* mi\mapped_item.mapping_source.mapped_representation.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(mr_it)))) &gt; 0)))) = 0">
                                </where>
                                <where
                                  label="WR4"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.FACE_SURFACE', 'SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' ] * TYPEOF(fa)) = 1))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR5"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (f_sf &lt;* QUERY (fa &lt;* cfs.cfs_faces| ('SMCH_PLUS_203_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)))| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(f_sf)) OR nmsf_surface_check(f_sf\face_surface.face_geometry)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR6"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (o_fa &lt;* QUERY (fa &lt;* cfs.cfs_faces| ('SMCH_PLUS_203_SCHEMA.ORIENTED_FACE' IN TYPEOF(fa)))| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(o_fa\oriented_face.face_element)) OR nmsf_surface_check(o_fa\oriented_face.face_element\face_surface.face_geometry)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR7"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (bnds &lt;* fa.bounds| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.EDGE_LOOP', 'SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' ] * TYPEOF(bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR8"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds\path.edge_list| NOT ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR9"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe_cv &lt;* QUERY (oe &lt;* elp_fbnds\path.edge_list| ('SMCH_PLUS_203_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)))| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE', 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA', 'SMCH_PLUS_203_SCHEMA.LINE', 'SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D', 'SMCH_PLUS_203_SCHEMA.PCURVE', 'SMCH_PLUS_203_SCHEMA.POLYLINE', 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR10"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds\path.edge_list| NOT nmsf_curve_check(oe.edge_element\edge_curve.edge_geometry))) = 0))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR11"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds\path.edge_list| NOT (('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR12"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF(QUERY (oe &lt;* elp_fbnds\path.edge_list| NOT ((SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR13"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                                <where
                                  label="WR14"
                                  expression="SIZEOF(QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items| ('SMCH_PLUS_203_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(it)))| NOT (SIZEOF(QUERY (cfs &lt;* fbsm\face_based_surface_model.fbsm_faces| NOT (SIZEOF(QUERY (fa &lt;* cfs.cfs_faces| NOT (('SMCH_PLUS_203_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR (SIZEOF(QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds| ('SMCH_PLUS_203_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)))| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CARTESIAN_POINT', 'SMCH_PLUS_203_SCHEMA.DEGENERATE_PCURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_CURVE', 'SMCH_PLUS_203_SCHEMA.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) = 1))) = 0)))) = 0))) = 0))) = 0">
                                </where>
                              </entity>

                              <entity
                                name="operation_sequence"
                                supertypes="representation_item">
                                <explicit
                                  name="created_elements">
                                  <typename
                                    name="list_representation_item"/>
                                </explicit>
                              </entity>

                              <entity
                                name="organization_assignment"
                                abstract.supertype="YES">
                                <explicit
                                  name="assigned_organization">
                                  <typename
                                    name="organization"/>
                                </explicit>
                                <explicit
                                  name="role">
                                  <typename
                                    name="organization_role"/>
                                </explicit>
                              </entity>

                              <entity
                                name="organization_role">
                                <explicit
                                  name="name">
                                  <typename
                                    name="label"/>
                                </explicit>
                                <derived
                                  name="description"
                                  expression="get_description_value(SELF)">
                                  <typename
                                    name="text"/>
                                </derived>
                                <where
                                  label="WR1"
                                  expression="SIZEOF(USEDIN(SELF, 'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1">
                                </where>
                              </entity>

                              <entity
                                name="polygonal_area"
                                supertypes="primitive_2d">
                                <explicit
                                  name="bounds">
                                  <aggregate
                                    type="LIST"
                                    lower="3"
                                    upper="?"
                                    unique="YES"/>
                                  <typename
                                    name="cartesian_point"/>
                                </explicit>
                              </entity>

                              <entity
                                name="precision_qualifier">
                                <explicit
                                  name="precision_value">
                                  <builtintype
                                    type="INTEGER"/>
                                </explicit>
                              </entity>

                              <entity
                                name="primitive_2d"
                                super.expression="(ONEOF ( CIRCULAR_AREA, ELLIPTIC_AREA, RECTANGULAR_AREA, POLYGONAL_AREA))"
                                supertypes="geometric_representation_item">
                                <where
                                  label="WR1"
                                  expression="SELF\geometric_representation_item.dim = 2">
                                </where>
                              </entity>

                              <entity
                                name="procedural_representation"
                                supertypes="representation">
                                <explicit
                                  name="items">
                                  <aggregate
                                    type="SET"
                                    lower="1"
                                    upper="?"/>
                                  <typename
                                    name="operation_sequence"/>
                                  <redeclaration
                                    entity-ref="representation"/>
                                  </explicit>
                                </entity>

                                <entity
                                  name="procedural_shape_representation"
                                  supertypes="procedural_representation shape_representation">
                                  <explicit
                                    name="items">
                                    <aggregate
                                      type="SET"
                                      lower="1"
                                      upper="?"/>
                                    <typename
                                      name="geometric_operation_sequence"/>
                                    <redeclaration
                                      entity-ref="representation"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="property_definition_relationship">
                                    <explicit
                                      name="name">
                                      <typename
                                        name="label"/>
                                    </explicit>
                                    <explicit
                                      name="description">
                                      <typename
                                        name="text"/>
                                    </explicit>
                                    <explicit
                                      name="relating_property_definition">
                                      <typename
                                        name="property_definition"/>
                                    </explicit>
                                    <explicit
                                      name="related_property_definition">
                                      <typename
                                        name="property_definition"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="qualified_representation_item"
                                    supertypes="representation_item">
                                    <explicit
                                      name="qualifiers">
                                      <aggregate
                                        type="SET"
                                        lower="1"
                                        upper="?"/>
                                      <typename
                                        name="value_qualifier"/>
                                    </explicit>
                                    <where
                                      label="WR1"
                                      expression="SIZEOF(QUERY (temp &lt;* qualifiers| ('SMCH_PLUS_203_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp)))) &lt; 2">
                                    </where>
                                  </entity>

                                  <entity
                                    name="qualitative_uncertainty"
                                    supertypes="uncertainty_qualifier">
                                    <explicit
                                      name="uncertainty_value">
                                      <typename
                                        name="text"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="ratio_measure_with_unit"
                                    supertypes="measure_with_unit">
                                    <where
                                      label="WR1"
                                      expression="'SMCH_PLUS_203_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)">
                                    </where>
                                  </entity>

                                  <entity
                                    name="ratio_unit"
                                    supertypes="named_unit">
                                    <where
                                      label="WR1"
                                      expression="((((((SELF\named_unit.dimensions.length_exponent = 0.00000) AND (SELF\named_unit.dimensions.mass_exponent = 0.00000)) AND (SELF\named_unit.dimensions.time_exponent = 0.00000)) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.00000)) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.00000)) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.00000)) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.00000)">
                                    </where>
                                  </entity>

                                  <entity
                                    name="rectangle_domain">
                                    <explicit
                                      name="corner">
                                      <typename
                                        name="cartesian_point"/>
                                    </explicit>
                                    <explicit
                                      name="xlength">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="ylength">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <where
                                      label="WR1"
                                      expression="SIZEOF(QUERY (item &lt;* USEDIN(SELF, '')| NOT ('SMCH_PLUS_203_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0">
                                    </where>
                                  </entity>

                                  <entity
                                    name="rectangled_half_space"
                                    supertypes="half_space_2d">
                                    <explicit
                                      name="enclosure">
                                      <typename
                                        name="rectangle_domain"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="rectangular_area"
                                    supertypes="primitive_2d">
                                    <explicit
                                      name="position">
                                      <typename
                                        name="axis2_placement_2d"/>
                                    </explicit>
                                    <explicit
                                      name="x">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="y">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="rectangular_pyramid"
                                    supertypes="geometric_representation_item">
                                    <explicit
                                      name="position">
                                      <typename
                                        name="axis2_placement_3d"/>
                                    </explicit>
                                    <explicit
                                      name="xlength">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="ylength">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="height">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="revolved_area_solid"
                                    supertypes="swept_area_solid">
                                    <explicit
                                      name="axis">
                                      <typename
                                        name="axis1_placement"/>
                                    </explicit>
                                    <explicit
                                      name="angle">
                                      <typename
                                        name="plane_angle_measure"/>
                                    </explicit>
                                    <derived
                                      name="axis_line"
                                      expression="representation_item('') || geometric_representation_item() || curve() || line(axis.location, representation_item('') || geometric_representation_item() || vector(axis.z, 1.00000))">
                                      <typename
                                        name="line"/>
                                    </derived>
                                  </entity>

                                  <entity
                                    name="revolved_face_solid"
                                    supertypes="swept_face_solid">
                                    <explicit
                                      name="axis">
                                      <typename
                                        name="axis1_placement"/>
                                    </explicit>
                                    <explicit
                                      name="angle">
                                      <typename
                                        name="plane_angle_measure"/>
                                    </explicit>
                                    <derived
                                      name="axis_line"
                                      expression="representation_item('') || geometric_representation_item() || curve() || line(axis.location, representation_item('') || geometric_representation_item() || vector(axis.z, 1.00000))">
                                      <typename
                                        name="line"/>
                                    </derived>
                                  </entity>

                                  <entity
                                    name="right_angular_wedge"
                                    supertypes="geometric_representation_item">
                                    <explicit
                                      name="position">
                                      <typename
                                        name="axis2_placement_3d"/>
                                    </explicit>
                                    <explicit
                                      name="x">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="y">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="z">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="ltx">
                                      <typename
                                        name="length_measure"/>
                                    </explicit>
                                    <where
                                      label="WR1"
                                      expression="(0.00000 &lt;= ltx) AND (ltx &lt; x)">
                                    </where>
                                  </entity>

                                  <entity
                                    name="right_circular_cone"
                                    supertypes="geometric_representation_item">
                                    <explicit
                                      name="position">
                                      <typename
                                        name="axis1_placement"/>
                                    </explicit>
                                    <explicit
                                      name="height">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="radius">
                                      <typename
                                        name="length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="semi_angle">
                                      <typename
                                        name="plane_angle_measure"/>
                                    </explicit>
                                    <where
                                      label="WR1"
                                      expression="radius &gt;= 0.00000">
                                    </where>
                                  </entity>

                                  <entity
                                    name="right_circular_cylinder"
                                    supertypes="geometric_representation_item">
                                    <explicit
                                      name="position">
                                      <typename
                                        name="axis1_placement"/>
                                    </explicit>
                                    <explicit
                                      name="height">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                    <explicit
                                      name="radius">
                                      <typename
                                        name="positive_length_measure"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="sectioned_spine"
                                    supertypes="geometric_curve_set">
                                    <explicit
                                      name="cross_sections">
                                      <aggregate
                                        type="LIST"
                                        lower="2"
                                        upper="?"/>
                                      <typename
                                        name="curve"/>
                                    </explicit>
                                    <explicit
                                      name="spine_points">
                                      <aggregate
                                        type="LIST"
                                        lower="2"
                                        upper="?"/>
                                      <typename
                                        name="point"/>
                                    </explicit>
                                    <where
                                      label="WR1"
                                      expression="SIZEOF(SELF\geometric_set.elements) = 1">
                                    </where>
                                    <where
                                      label="WR2"
                                      expression="'SMCH_PLUS_203_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1])">
                                    </where>
                                    <where
                                      label="WR3"
                                      expression="SIZEOF(cross_sections) = SIZEOF(spine_points)">
                                    </where>
                                    <where
                                      label="WR4"
                                      expression="SELF\geometric_representation_item.dim = 3">
                                    </where>
                                  </entity>

                                  <entity
                                    name="selected_element">
                                    <explicit
                                      name="picked_element">
                                      <typename
                                        name="representation_item"/>
                                    </explicit>
                                  </entity>

                                  <entity
                                    name="selected_geometric_element"
                                    supertypes="selected_element">
                                    <explicit
                                      name="picked_element">
                                      <typename
                                        name="shape_representation_item"/>
                                      <redeclaration
                                        entity-ref="selected_element"/>
                                      </explicit>
                                    </entity>

                                    <entity
                                      name="shape_defining_relationship"
                                      supertypes="shape_aspect_relationship">
                                    </entity>

                                    <entity
                                      name="shape_representation_with_parameters"
                                      supertypes="shape_representation">
                                      <where
                                        label="WR1"
                                        expression="SIZEOF(QUERY (it &lt;* SELF.items| NOT (SIZEOF([ 'SMCH_PLUS_203_SCHEMA.PLACEMENT', 'SMCH_PLUS_203_SCHEMA.MEASURE_REPRESENTATION_ITEM', 'SMCH_PLUS_203_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' ] * TYPEOF(it)) = 1))) = 0">
                                      </where>
                                    </entity>

                                    <entity
                                      name="solid_replica"
                                      supertypes="solid_model">
                                      <explicit
                                        name="parent_solid">
                                        <typename
                                          name="solid_model"/>
                                      </explicit>
                                      <explicit
                                        name="transformation">
                                        <typename
                                          name="cartesian_transformation_operator_3d"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="acyclic_solid_replica(SELF, parent_solid)">
                                      </where>
                                      <where
                                        label="WR2"
                                        expression="parent_solid\geometric_representation_item.dim = 3">
                                      </where>
                                    </entity>

                                    <entity
                                      name="sphere"
                                      supertypes="geometric_representation_item">
                                      <explicit
                                        name="radius">
                                        <typename
                                          name="positive_length_measure"/>
                                      </explicit>
                                      <explicit
                                        name="centre">
                                        <typename
                                          name="point"/>
                                      </explicit>
                                    </entity>

                                    <entity
                                      name="standard_uncertainty"
                                      super.expression="( EXPANDED_UNCERTAINTY)"
                                      supertypes="uncertainty_qualifier">
                                      <explicit
                                        name="uncertainty_value">
                                        <builtintype
                                          type="REAL"/>
                                      </explicit>
                                    </entity>

                                    <entity
                                      name="surface_curve_swept_area_solid"
                                      supertypes="swept_area_solid">
                                      <explicit
                                        name="directrix">
                                        <typename
                                          name="curve"/>
                                      </explicit>
                                      <explicit
                                        name="start_param">
                                        <builtintype
                                          type="REAL"/>
                                      </explicit>
                                      <explicit
                                        name="end_param">
                                        <builtintype
                                          type="REAL"/>
                                      </explicit>
                                      <explicit
                                        name="reference_surface">
                                        <typename
                                          name="surface"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface)">
                                      </where>
                                    </entity>

                                    <entity
                                      name="surface_curve_swept_face_solid"
                                      supertypes="swept_face_solid">
                                      <explicit
                                        name="directrix">
                                        <typename
                                          name="curve"/>
                                      </explicit>
                                      <explicit
                                        name="start_param">
                                        <builtintype
                                          type="REAL"/>
                                      </explicit>
                                      <explicit
                                        name="end_param">
                                        <builtintype
                                          type="REAL"/>
                                      </explicit>
                                      <explicit
                                        name="reference_surface">
                                        <typename
                                          name="surface"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface)">
                                      </where>
                                    </entity>

                                    <entity
                                      name="swept_area_solid"
                                      super.expression="(ONEOF ( REVOLVED_AREA_SOLID, EXTRUDED_AREA_SOLID, SURFACE_CURVE_SWEPT_AREA_SOLID))"
                                      supertypes="solid_model">
                                      <explicit
                                        name="swept_area">
                                        <typename
                                          name="curve_bounded_surface"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="'SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface)">
                                      </where>
                                    </entity>

                                    <entity
                                      name="swept_face_solid"
                                      super.expression="(ONEOF ( EXTRUDED_FACE_SOLID, REVOLVED_FACE_SOLID, SURFACE_CURVE_SWEPT_FACE_SOLID))"
                                      supertypes="solid_model">
                                      <explicit
                                        name="swept_face">
                                        <typename
                                          name="face_surface"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="'SMCH_PLUS_203_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry)">
                                      </where>
                                    </entity>

                                    <entity
                                      name="tetrahedron"
                                      supertypes="faceted_primitive">
                                      <where
                                        label="WR1"
                                        expression="SIZEOF(points) = 4">
                                      </where>
                                      <where
                                        label="WR2"
                                        expression="above_plane(points[1], points[2], points[3], points[4]) &lt;&gt; 0.00000">
                                      </where>
                                    </entity>

                                    <entity
                                      name="torus"
                                      supertypes="geometric_representation_item">
                                      <explicit
                                        name="position">
                                        <typename
                                          name="axis1_placement"/>
                                      </explicit>
                                      <explicit
                                        name="major_radius">
                                        <typename
                                          name="positive_length_measure"/>
                                      </explicit>
                                      <explicit
                                        name="minor_radius">
                                        <typename
                                          name="positive_length_measure"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="major_radius &gt; minor_radius">
                                      </where>
                                    </entity>

                                    <entity
                                      name="transition_feature"
                                      abstract.supertype="YES"
                                      super.expression="(ONEOF (BLEND))"
                                      supertypes="shape_aspect">
                                    </entity>

                                    <entity
                                      name="trimmed_volume"
                                      supertypes="solid_model">
                                      <explicit
                                        name="basis_volume">
                                        <typename
                                          name="volume"/>
                                      </explicit>
                                      <explicit
                                        name="u1">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <explicit
                                        name="u2">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <explicit
                                        name="v1">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <explicit
                                        name="v2">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <explicit
                                        name="w1">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <explicit
                                        name="w2">
                                        <typename
                                          name="parameter_value"/>
                                      </explicit>
                                      <where
                                        label="WR1"
                                        expression="u1 &lt;&gt; u2">
                                      </where>
                                      <where
                                        label="WR2"
                                        expression="v1 &lt;&gt; v2">
                                      </where>
                                      <where
                                        label="WR3"
                                        expression="w1 &lt;&gt; w2">
                                      </where>
                                    </entity>

                                    <entity
                                      name="type_qualifier">
                                      <explicit
                                        name="name">
                                        <typename
                                          name="label"/>
                                      </explicit>
                                    </entity>

                                    <entity
                                      name="uncertainty_qualifier"
                                      super.expression="(ONEOF ( STANDARD_UNCERTAINTY, QUALITATIVE_UNCERTAINTY))">
                                      <explicit
                                        name="measure_name">
                                        <typename
                                          name="label"/>
                                      </explicit>
                                      <explicit
                                        name="description">
                                        <typename
                                          name="text"/>
                                      </explicit>
                                    </entity>

                                    <entity
                                      name="volume"
                                      supertypes="geometric_representation_item">
                                      <where
                                        label="WR1"
                                        expression="SELF\geometric_representation_item.dim = 3">
                                      </where>
                                    </entity>

                                    <function
                                      name="get_id_value">
                                      <parameter
                                        name="obj">
                                        <typename
                                          name="id_attribute_select"/>
                                      </parameter>
                                      <typename
                                        name="identifier"/>
                                      <algorithm>
LOCAL
id_bag : BAG OF id_attribute := USEDIN(obj,'SMCH_PLUS_203_SCHEMA.' +
'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM');
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
RETURN(id_bag[1].attribute_value);
ELSE
RETURN(?);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="get_role">
                                      <parameter
                                        name="obj">
                                        <typename
                                          name="role_select"/>
                                      </parameter>
                                      <typename
                                        name="object_role"/>
                                      <algorithm>
LOCAL
role_bag : BAG OF role_association := USEDIN(obj,
'SMCH_PLUS_203_SCHEMA.' + 'ROLE_ASSOCIATION.' +
'ITEM_WITH_ROLE');
END_LOCAL;
IF SIZEOF(role_bag) = 1 THEN
RETURN(role_bag[1].role);
ELSE
RETURN(?);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="get_description_value">
                                      <parameter
                                        name="obj">
                                        <typename
                                          name="description_attribute_select"/>
                                      </parameter>
                                      <typename
                                        name="text"/>
                                      <algorithm>
LOCAL
description_bag : BAG OF description_attribute := USEDIN(obj,
'SMCH_PLUS_203_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.'
+ 'DESCRIBED_ITEM');
END_LOCAL;
IF SIZEOF(description_bag) = 1 THEN
RETURN(description_bag[1].attribute_value);
ELSE
RETURN(?);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="get_name_value">
                                      <parameter
                                        name="obj">
                                        <typename
                                          name="name_attribute_select"/>
                                      </parameter>
                                      <typename
                                        name="label"/>
                                      <algorithm>
LOCAL
name_bag : BAG OF name_attribute := USEDIN(obj,
'SMCH_PLUS_203_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM');
END_LOCAL;
IF SIZEOF(name_bag) = 1 THEN
RETURN(name_bag[1].attribute_value);
ELSE
RETURN(?);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="msb_shells">
                                      <parameter
                                        name="brep">
                                        <typename
                                          name="manifold_solid_brep"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"
                                        lower="1"
                                        upper="?"/>
                                      <typename
                                        name="closed_shell"/>
                                      <algorithm>
IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
RETURN(brep\brep_with_voids.voids + brep.outer);
ELSE
RETURN([brep.outer]);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="normalise">
                                      <parameter
                                        name="arg">
                                        <typename
                                          name="vector_or_direction"/>
                                      </parameter>
                                      <typename
                                        name="vector_or_direction"/>
                                      <algorithm>
LOCAL
ndim : INTEGER;
v : direction;
vec : vector;
mag : REAL;
result : vector_or_direction;
END_LOCAL;
IF NOT EXISTS(arg) THEN
RETURN(?);
ELSE
ndim := arg.dim;
IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
BEGIN
vec := arg;
v := arg.orientation;
IF arg.magnitude = 0 THEN
RETURN(?);
ELSE
vec.magnitude := 1;
END_IF;
END;
ELSE
v := arg;
END_IF;
mag := 0;
REPEAT i := 1 TO ndim BY 1;
mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
mag := SQRT(mag);
REPEAT i := 1 TO ndim BY 1;
v.direction_ratios[i] := v.direction_ratios[i] / mag;
END_REPEAT;
IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
vec.orientation := v;
result := vec;
ELSE
result := v;
END_IF;
ELSE
RETURN(?);
END_IF;
END_IF;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="build_2axes">
                                      <parameter
                                        name="ref_direction">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <aggregate
                                        type="LIST"
                                        lower="2"
                                        upper="2"/>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
u : LIST [2:2] OF direction;
END_LOCAL;
u[1] := NVL(normalise(ref_direction),representation_item('') ||
geometric_representation_item() || direction([1,0]));
u[2] := orthogonal_complement(u[1]);
RETURN(u);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="orthogonal_complement">
                                      <parameter
                                        name="vec">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
result : direction;
END_LOCAL;
IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN
RETURN(?);
ELSE
result.name := '';
result.direction_ratios[1] := -vec.direction_ratios[2];
result.direction_ratios[2] := vec.direction_ratios[1];
RETURN(result);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="build_axes">
                                      <parameter
                                        name="axis">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="ref_direction">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <aggregate
                                        type="LIST"
                                        lower="3"
                                        upper="3"/>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
u : LIST [3:3] OF direction;
END_LOCAL;
u[3] := NVL(normalise(axis),representation_item('') ||
geometric_representation_item() || direction([0,0,1]));
u[1] := first_proj_axis(u[3],ref_direction);
u[2] := normalise(cross_product(u[3],u[1])).orientation;
RETURN(u);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="first_proj_axis">
                                      <parameter
                                        name="z_axis">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="arg">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
x_vec : vector;
v : direction;
z : direction;
x_axis : direction;
END_LOCAL;
IF NOT EXISTS(z_axis) THEN
RETURN(?);
ELSE
z := normalise(z_axis);
IF NOT EXISTS(arg) THEN
IF z.direction_ratios &lt;&gt; [1,0,0] THEN
v := representation_item('') || geometric_representation_item()
|| direction([1,0,0]);
ELSE
v := representation_item('') || geometric_representation_item()
|| direction([0,1,0]);
END_IF;
ELSE
IF arg.dim &lt;&gt; 3 THEN
RETURN(?);
END_IF;
IF cross_product(arg,z).magnitude = 0 THEN
RETURN(?);
ELSE
v := normalise(arg);
END_IF;
END_IF;
x_vec := scalar_times_vector(dot_product(v,z),z);
x_axis := vector_difference(v,x_vec).orientation;
x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="cross_product">
                                      <parameter
                                        name="arg1">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="arg2">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <typename
                                        name="vector"/>
                                      <algorithm>
LOCAL
v2 : LIST [3:3] OF REAL;
v1 : LIST [3:3] OF REAL;
mag : REAL;
res : direction;
result : vector;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
.dim = 2) THEN
RETURN(?);
ELSE
BEGIN
v1 := normalise(arg1).direction_ratios;
v2 := normalise(arg2).direction_ratios;
res.name := '';
res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
mag := 0;
REPEAT i := 1 TO 3 BY 1;
mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
result.orientation := res;
result.magnitude := SQRT(mag);
ELSE
result.orientation := arg1;
result.magnitude := 0;
END_IF;
result.name := '';
RETURN(result);
END;
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="scalar_times_vector">
                                      <parameter
                                        name="scalar">
                                        <builtintype
                                          type="REAL"/>
                                      </parameter>
                                      <parameter
                                        name="vec">
                                        <typename
                                          name="vector_or_direction"/>
                                      </parameter>
                                      <typename
                                        name="vector"/>
                                      <algorithm>
LOCAL
v : direction;
mag : REAL;
result : vector;
END_LOCAL;
IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
RETURN(?);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(vec) THEN
v := vec.orientation;
mag := scalar * vec.magnitude;
ELSE
v := vec;
mag := scalar;
END_IF;
IF mag &lt; 0 THEN
REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
v.direction_ratios[i] := -v.direction_ratios[i];
END_REPEAT;
mag := -mag;
END_IF;
result.name := '';
result.orientation := normalise(v);
result.magnitude := mag;
END_IF;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="dot_product">
                                      <parameter
                                        name="arg1">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="arg2">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <builtintype
                                        type="REAL"/>
                                      <algorithm>
LOCAL
ndim : INTEGER;
scalar : REAL;
vec1 : direction;
vec2 : direction;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
scalar := ?;
ELSE
IF arg1.dim &lt;&gt; arg2.dim THEN
scalar := ?;
ELSE
BEGIN
vec1 := normalise(arg1);
vec2 := normalise(arg2);
ndim := arg1.dim;
scalar := 0;
REPEAT i := 1 TO ndim BY 1;
scalar := scalar + (vec1.direction_ratios[i] * vec2.
direction_ratios[i]);
END_REPEAT;
END;
END_IF;
END_IF;
RETURN(scalar);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="vector_difference">
                                      <parameter
                                        name="arg1">
                                        <typename
                                          name="vector_or_direction"/>
                                      </parameter>
                                      <parameter
                                        name="arg2">
                                        <typename
                                          name="vector_or_direction"/>
                                      </parameter>
                                      <typename
                                        name="vector"/>
                                      <algorithm>
LOCAL
ndim : INTEGER;
mag2 : REAL;
mag1 : REAL;
mag : REAL;
res : direction;
vec1 : direction;
vec2 : direction;
result : vector;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
RETURN(?);
ELSE
BEGIN
IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1;
vec1 := arg1;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1;
vec2 := arg2;
END_IF;
vec1 := normalise(vec1);
vec2 := normalise(vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0;
REPEAT i := 1 TO ndim BY 1;
res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
mag2 * vec2.direction_ratios[i]);
mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
result.magnitude := SQRT(mag);
result.orientation := res;
ELSE
result.magnitude := 0;
result.orientation := vec1;
END_IF;
END;
END_IF;
result.name := '';
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="list_to_array">
                                      <parameter
                                        name="lis">
                                        <aggregate
                                          type="LIST"
                                          lower="0"
                                          upper="?"/>
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <parameter
                                        name="low">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="u">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <aggregate
                                        type="ARRAY"
                                        lower="low"
                                        upper="u"/>
                                      <builtintype
                                        type="GENERIC"/>
                                      <algorithm>
LOCAL
n : INTEGER;
res : ARRAY [low:u] OF GENERIC:t;
END_LOCAL;
n := SIZEOF(lis);
IF n &lt;&gt; ((u - low) + 1) THEN
RETURN(?);
ELSE
REPEAT i := 1 TO n BY 1;
res[(low + i) - 1] := lis[i];
END_REPEAT;
RETURN(res);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="constraints_param_b_spline">
                                      <parameter
                                        name="degree">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="up_knots">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="up_cp">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="knot_mult">
                                        <aggregate
                                          type="LIST"/>
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="knots">
                                        <aggregate
                                          type="LIST"/>
                                        <typename
                                          name="parameter_value"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
k : INTEGER;
l : INTEGER;
sum : INTEGER;
result : BOOLEAN := TRUE;
END_LOCAL;
sum := knot_mult[1];
REPEAT i := 2 TO up_knots BY 1;
sum := sum + knot_mult[i];
END_REPEAT;
IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR (sum &lt;&gt; (
degree + up_cp + 2)) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[1];
IF (k &lt; 1) OR (k &gt; (degree + 1)) THEN
result := FALSE;
RETURN(result);
END_IF;
REPEAT i := 2 TO up_knots BY 1;
IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[i];
IF (i &lt; up_knots) AND (k &gt; degree) THEN
result := FALSE;
RETURN(result);
END_IF;
IF (i = up_knots) AND (k &gt; (degree + 1)) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="make_array_of_array">
                                      <parameter
                                        name="lis">
                                        <aggregate
                                          type="LIST"
                                          lower="1"
                                          upper="?"/>
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <parameter
                                        name="low1">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="u1">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="low2">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="u2">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <aggregate
                                        type="ARRAY"
                                        lower="low1"
                                        upper="u1"/>
                                      <builtintype
                                        type="GENERIC"/>
                                      <algorithm>
LOCAL
n2 : INTEGER;
n1 : INTEGER;
res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
END_LOCAL;
n1 := SIZEOF(lis);
n2 := SIZEOF(lis[1]);
IF (n1 &lt;&gt; ((u1 - low1) + 1)) OR (n2 &lt;&gt; ((u2 - low2) + 1)) THEN
RETURN(?);
END_IF;
REPEAT i := 1 TO n1 BY 1;
IF SIZEOF(lis[i]) &lt;&gt; n2 THEN
RETURN(?);
END_IF;
END_REPEAT;
REPEAT i := 1 TO n1 BY 1;
resl[i] := list_to_array(lis[i],low2,u2);
END_REPEAT;
res := list_to_array(resl,low1,u1);
RETURN(res);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_calendar_date">
                                      <parameter
                                        name="date">
                                        <typename
                                          name="calendar_date"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
CASE date.month_component OF
1 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 31));
2 : BEGIN
IF leap_year(date.year_component) THEN
RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 29));
ELSE
RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 28));
END_IF;
END;
3 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 31));
4 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 30));
5 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 31));
6 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 30));
7 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 31));
8 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 31));
9 : RETURN((1 &lt;= date.day_component) AND (date.day_component
&lt;= 30));
10 : RETURN((1 &lt;= date.day_component) AND (date.
day_component &lt;= 31));
11 : RETURN((1 &lt;= date.day_component) AND (date.
day_component &lt;= 30));
12 : RETURN((1 &lt;= date.day_component) AND (date.
day_component &lt;= 31));
END_CASE;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="leap_year">
                                      <parameter
                                        name="year">
                                        <typename
                                          name="year_number"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF (((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) =
0) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="aspect_ratio">
                                      <parameter
                                        name="p">
                                        <typename
                                          name="planar_box"/>
                                      </parameter>
                                      <typename
                                        name="positive_ratio_measure"/>
                                      <algorithm>
RETURN(p.size_in_x / p.size_in_y);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="base_axis">
                                      <parameter
                                        name="dim">
                                        <builtintype
                                          type="INTEGER"/>
                                      </parameter>
                                      <parameter
                                        name="axis1">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="axis2">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="axis3">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <aggregate
                                        type="LIST"
                                        lower="2"
                                        upper="3"/>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
u : LIST [2:3] OF direction;
vec : direction;
factor : REAL;
END_LOCAL;
IF dim = 3 THEN
u[3] := NVL(normalise(axis3),representation_item('') ||
geometric_representation_item() || direction([0,0,1]));
u[1] := first_proj_axis(u[3],axis1);
u[2] := second_proj_axis(u[3],u[1],axis2);
ELSE
u[3] := ?;
IF EXISTS(axis1) THEN
u[1] := normalise(axis1);
u[2] := orthogonal_complement(u[1]);
IF EXISTS(axis2) THEN
factor := dot_product(axis2,u[2]);
IF factor &lt; 0 THEN
u[2].direction_ratios[1] := -u[2].direction_ratios[1];
u[2].direction_ratios[2] := -u[2].direction_ratios[2];
END_IF;
END_IF;
ELSE
IF EXISTS(axis2) THEN
u[2] := normalise(axis2);
u[1] := orthogonal_complement(u[2]);
u[1].direction_ratios[1] := -u[1].direction_ratios[1];
u[1].direction_ratios[2] := -u[1].direction_ratios[2];
ELSE
u[1].name := '';
u[2].name := '';
u[1].direction_ratios[1] := 1;
u[1].direction_ratios[2] := 0;
u[2].direction_ratios[1] := 0;
u[2].direction_ratios[2] := 1;
END_IF;
END_IF;
END_IF;
RETURN(u);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="second_proj_axis">
                                      <parameter
                                        name="z_axis">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="x_axis">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <parameter
                                        name="arg">
                                        <typename
                                          name="direction"/>
                                      </parameter>
                                      <typename
                                        name="direction"/>
                                      <algorithm>
LOCAL
temp : vector;
v : direction;
y_axis : vector;
END_LOCAL;
IF NOT EXISTS(arg) THEN
v := representation_item('') || geometric_representation_item() ||
direction([0,1,0]);
ELSE
v := arg;
END_IF;
temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
y_axis := vector_difference(v,temp);
temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
y_axis := vector_difference(y_axis,temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="cc_design_date_time_correlation">
                                      <parameter
                                        name="e">
                                        <typename
                                          name="cc_design_date_and_time_assignment"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
dt_role : STRING;
END_LOCAL;
dt_role := e\date_and_time_assignment.role.name;
CASE dt_role OF
'creation_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'request_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF([
'SMCH_PLUS_203_SCHEMA.CHANGE_REQUEST' +
'SMCH_PLUS_203_SCHEMA.START_REQUEST'] * TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'release_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.CHANGE' +
'SMCH_PLUS_203_SCHEMA.START_WORK'] * TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'start_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.CHANGE' +
'SMCH_PLUS_203_SCHEMA.START_WORK'] * TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'sign_off_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'contract_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | ('SMCH_PLUS_203_SCHEMA.CONTRACT' IN
TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'certification_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | ('SMCH_PLUS_203_SCHEMA.CERTIFICATION' IN
TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'classification_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'SECURITY_CLASSIFICATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'declassification_date' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'SECURITY_CLASSIFICATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
OTHERWISE : RETURN(TRUE);
END_CASE;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="cc_design_person_and_organization_correlation">
                                      <parameter
                                        name="e">
                                        <typename
                                          name="cc_design_person_and_organization_assignment"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
po_role : STRING;
END_LOCAL;
po_role := e\person_and_organization_assignment.role.name;
CASE po_role OF
'request_recipient' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' +
'CHANGE_REQUEST','SMCH_PLUS_203_SCHEMA.' + 'START_REQUEST'] *
TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'initiator' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' +
'CHANGE_REQUEST','SMCH_PLUS_203_SCHEMA.' + 'START_REQUEST',
'SMCH_PLUS_203_SCHEMA.' + 'START_WORK','SMCH_PLUS_203_SCHEMA.' +
'CHANGE'] * TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'creator' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (SIZEOF(['SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION_FORMATION','SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1))) THEN
RETURN(FALSE);
END_IF;
'part_supplier' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'design_supplier' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'design_owner' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | ('SMCH_PLUS_203_SCHEMA.PRODUCT' IN
TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'configuration_manager' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'CONFIGURATION_ITEM') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'contractor' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | ('SMCH_PLUS_203_SCHEMA.CONTRACT' IN
TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
'classification_officer' : IF SIZEOF(e.items) &lt;&gt; SIZEOF(
QUERY (x &lt;* e.items | (('SMCH_PLUS_203_SCHEMA.' +
'SECURITY_CLASSIFICATION') IN TYPEOF(x)))) THEN
RETURN(FALSE);
END_IF;
OTHERWISE : RETURN(TRUE);
END_CASE;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="get_basis_surface">
                                      <parameter
                                        name="c">
                                        <typename
                                          name="curve_on_surface"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"
                                        lower="0"
                                        upper="2"/>
                                      <typename
                                        name="surface"/>
                                      <algorithm>
LOCAL
surfs : SET [0:2] OF surface;
n : INTEGER;
END_LOCAL;
surfs := [];
IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(c) THEN
surfs := [c\pcurve.basis_surface];
ELSE
IF 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
n := SIZEOF(c\surface_curve.associated_geometry);
REPEAT i := 1 TO n BY 1;
surfs := surfs + associated_surface(c\surface_curve.
associated_geometry[i]);
END_REPEAT;
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN
n := SIZEOF(c\composite_curve_on_surface.segments);
surfs := get_basis_surface(c\composite_curve_on_surface.segments[1].
parent_curve);
IF n &gt; 1 THEN
REPEAT i := 2 TO n BY 1;
surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
segments[i].parent_curve);
END_REPEAT;
END_IF;
END_IF;
RETURN(surfs);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="associated_surface">
                                      <parameter
                                        name="arg">
                                        <typename
                                          name="pcurve_or_surface"/>
                                      </parameter>
                                      <typename
                                        name="surface"/>
                                      <algorithm>
LOCAL
surf : surface;
END_LOCAL;
IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
surf := arg.basis_surface;
ELSE
surf := arg;
END_IF;
RETURN(surf);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="constraints_composite_curve_on_surface">
                                      <parameter
                                        name="c">
                                        <typename
                                          name="composite_curve_on_surface"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
REPEAT k := 1 TO n_segments BY 1;
IF (NOT ('SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve.
segments[k].parent_curve))) AND (NOT (
'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\composite_curve.
segments[k].parent_curve))) AND (NOT (
'SMCH_PLUS_203_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
composite_curve.segments[k].parent_curve))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_composite_text">
                                      <parameter
                                        name="start_composite">
                                        <typename
                                          name="composite_text"/>
                                      </parameter>
                                      <parameter
                                        name="child_text">
                                        <aggregate
                                          type="SET"
                                          lower="1"
                                          upper="?"/>
                                        <typename
                                          name="text_or_character"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
LOCAL
i : INTEGER;
local_annotation_text : SET [0:?] OF annotation_text;
local_composite_text : SET [0:?] OF composite_text;
local_children : SET [0:?] OF text_or_character;
END_LOCAL;
local_composite_text := QUERY (child &lt;* child_text | (
'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT' IN TYPEOF(child)));
IF SIZEOF(local_composite_text) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
IF start_composite :=: local_composite_text[i] THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
local_children := child_text;
IF SIZEOF(local_composite_text) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(local_composite_text) BY 1;
local_children := local_children + local_composite_text[i].
collected_text;
END_REPEAT;
END_IF;
local_annotation_text := QUERY (child &lt;* child_text | (
'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT' IN TYPEOF(child)));
IF SIZEOF(local_annotation_text) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(local_annotation_text) BY 1;
local_children := local_children + QUERY (item &lt;*
local_annotation_text[i]\mapped_item.mapping_source.
mapped_representation.items | (SIZEOF([
'SMCH_PLUS_203_SCHEMA.ANNOTATION_TEXT',
'SMCH_PLUS_203_SCHEMA.COMPOSITE_TEXT'] * TYPEOF(item)) &gt; 0));
END_REPEAT;
END_IF;
IF local_children :&lt;&gt;: child_text THEN
RETURN(acyclic_composite_text(start_composite,local_children));
ELSE
RETURN(TRUE);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_curve_replica">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="curve_replica"/>
                                      </parameter>
                                      <parameter
                                        name="parent">
                                        <typename
                                          name="curve"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ('SMCH_PLUS_203_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent)) THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="check_text_alignment">
                                      <parameter
                                        name="ct">
                                        <typename
                                          name="composite_text"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
a : SET OF text_alignment := [];
i : INTEGER;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
a := a + [ct.collected_text[i]\text_literal.alignment];
END_REPEAT;
RETURN(SIZEOF(a) = 1);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="check_text_font">
                                      <parameter
                                        name="ct">
                                        <typename
                                          name="composite_text"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
f : SET OF font_select := [];
i : INTEGER;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(ct.collected_text) BY 1;
f := f + [ct.collected_text[i]\text_literal.font];
END_REPEAT;
RETURN(SIZEOF(f) &lt;= 1);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_wireframe_edge_curve">
                                      <parameter
                                        name="crv">
                                        <typename
                                          name="curve"/>
                                      </parameter>
                                      <parameter
                                        name="schma">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF SIZEOF([schma + '.LINE',schma + '.CIRCLE',schma + '.ELLIPSE',schma
+ '.PARABOLA',schma + '.HYPERBOLA',schma + '.B_SPLINE_CURVE',schma
+ '.POLYLINE'] * TYPEOF(crv)) = 1 THEN
RETURN(TRUE);
ELSE
IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve,
schma));
ELSE
IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
basis_curve,schma));
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_wireframe_vertex_point">
                                      <parameter
                                        name="pnt">
                                        <typename
                                          name="point"/>
                                      </parameter>
                                      <parameter
                                        name="schma">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
RETURN(TRUE);
ELSE
IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt,
schma));
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="mixed_loop_type_set">
                                      <parameter
                                        name="l">
                                        <aggregate
                                          type="SET"
                                          lower="0"
                                          upper="?"/>
                                        <typename
                                          name="loop"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
LOCAL
i : INTEGER;
poly_loop_type : LOGICAL;
END_LOCAL;
IF SIZEOF(l) &lt;= 1 THEN
RETURN(FALSE);
END_IF;
poly_loop_type := 'SMCH_PLUS_203_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
REPEAT i := 2 TO SIZEOF(l) BY 1;
IF ('SMCH_PLUS_203_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt;
poly_loop_type THEN
RETURN(TRUE);
END_IF;
END_REPEAT;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="list_to_set">
                                      <parameter
                                        name="l">
                                        <aggregate
                                          type="LIST"
                                          lower="0"
                                          upper="?"/>
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"/>
                                      <builtintype
                                        type="GENERIC"/>
                                      <algorithm>
LOCAL
s : SET OF GENERIC:t := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(l) BY 1;
s := s + l[i];
END_REPEAT;
RETURN(s);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="list_face_loops">
                                      <parameter
                                        name="f">
                                        <typename
                                          name="face"/>
                                      </parameter>
                                      <aggregate
                                        type="LIST"
                                        lower="0"
                                        upper="?"/>
                                      <typename
                                        name="loop"/>
                                      <algorithm>
LOCAL
loops : LIST [0:?] OF loop := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
loops := loops + f.bounds[i].bound;
END_REPEAT;
RETURN(loops);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="dimension_of">
                                      <parameter
                                        name="item">
                                        <typename
                                          name="geometric_representation_item"/>
                                      </parameter>
                                      <typename
                                        name="dimension_count"/>
                                      <algorithm>
LOCAL
x : SET OF representation;
y : representation_context;
END_LOCAL;
x := using_representations(item);
y := x[1].context_of_items;
RETURN(y\geometric_representation_context.coordinate_space_dimension);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="using_representations">
                                      <parameter
                                        name="item">
                                        <typename
                                          name="founded_item_select"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"/>
                                      <typename
                                        name="representation"/>
                                      <algorithm>
LOCAL
results : SET OF representation;
intermediate_items : SET OF founded_item_select;
result_bag : BAG OF representation;
END_LOCAL;
results := [];
result_bag := USEDIN(item,'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS');
IF SIZEOF(result_bag) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
results := results + result_bag[i];
END_REPEAT;
END_IF;
intermediate_items := using_items(item,[]);
IF SIZEOF(intermediate_items) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
result_bag := USEDIN(intermediate_items[i],
'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS');
IF SIZEOF(result_bag) &gt; 0 THEN
REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
results := results + result_bag[j];
END_REPEAT;
END_IF;
END_REPEAT;
END_IF;
RETURN(results);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="using_items">
                                      <parameter
                                        name="item">
                                        <typename
                                          name="founded_item_select"/>
                                      </parameter>
                                      <parameter
                                        name="checked_items">
                                        <aggregate
                                          type="SET"/>
                                        <typename
                                          name="founded_item_select"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"/>
                                      <typename
                                        name="founded_item_select"/>
                                      <algorithm>
LOCAL
next_items : SET OF founded_item_select;
new_check_items : SET OF founded_item_select;
result_items : SET OF founded_item_select;
END_LOCAL;
result_items := [];
new_check_items := checked_items + item;
next_items := QUERY (z &lt;* bag_to_set(USEDIN(item,'')) | ((
'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
'SMCH_PLUS_203_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z))));
IF SIZEOF(next_items) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(next_items) BY 1;
IF NOT (next_items[i] IN new_check_items) THEN
result_items := result_items + next_items[i] + using_items(
next_items[i],new_check_items);
END_IF;
END_REPEAT;
END_IF;
RETURN(result_items);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="bag_to_set">
                                      <parameter
                                        name="the_bag">
                                        <aggregate
                                          type="BAG"/>
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"/>
                                      <builtintype
                                        type="GENERIC"/>
                                      <algorithm>
LOCAL
the_set : SET OF GENERIC:intype := [];
END_LOCAL;
IF SIZEOF(the_bag) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
the_set := the_set + the_bag[i];
END_REPEAT;
END_IF;
RETURN(the_set);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="gbsf_check_point">
                                      <parameter
                                        name="pnt">
                                        <typename
                                          name="point"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ((schema_name + '.POINT') IN TYPEOF(pnt)) THEN
RETURN(TRUE);
END_IF;
IF (schema_name + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
RETURN(TRUE);
ELSE
IF (schema_name + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve,schema_name));
ELSE
IF (schema_name + '.POINT_ON_SURFACE') IN TYPEOF(pnt) THEN
RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface,
schema_name));
ELSE
IF (schema_name + '.DEGENERATE_PCURVE') IN TYPEOF(pnt) THEN
RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
reference_to_curve\representation.items[1],schema_name) AND
gbsf_check_surface(pnt\degenerate_pcurve.basis_surface,
schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="gbsf_check_curve">
                                      <parameter
                                        name="cv">
                                        <typename
                                          name="curve"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ((schema_name + '.CURVE') IN TYPEOF(cv)) THEN
RETURN(TRUE);
END_IF;
IF SIZEOF([schema_name + '.CIRCLE',schema_name + '.ELLIPSE'] * TYPEOF(
cv)) = 1 THEN
RETURN(TRUE);
ELSE
IF (schema_name + '.B_SPLINE_CURVE') IN TYPEOF(cv) THEN
RETURN(NOT cv\b_spline_curve.self_intersect);
ELSE
IF (schema_name + '.COMPOSITE_CURVE') IN TYPEOF(cv) THEN
RETURN(SIZEOF(QUERY (seg &lt;* cv\composite_curve.segments | (NOT
gbsf_check_curve(seg.parent_curve,schema_name)))) = 0);
ELSE
IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv) THEN
RETURN(gbsf_check_curve(cv\curve_replica.parent_curve,
schema_name));
ELSE
IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv) THEN
RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve,
schema_name) AND (NOT cv\offset_curve_3d.self_intersect));
ELSE
IF (schema_name + '.PCURVE') IN TYPEOF(cv) THEN
RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
representation.items[1],schema_name) AND
gbsf_check_surface(cv\pcurve.basis_surface,schema_name));
ELSE
IF (schema_name + '.POLYLINE') IN TYPEOF(cv) THEN
IF (SIZEOF(cv\polyline.points) &gt; 3) AND (SIZEOF(
bag_to_set(USEDIN(cv,'')) - bag_to_set(USEDIN(cv,
schema_name + '.INTERSECTION_CURVE.BASIS_CURVE'))) =
0) THEN
RETURN(TRUE);
END_IF;
ELSE
IF (schema_name + '.SURFACE_CURVE') IN TYPEOF(cv) THEN
IF gbsf_check_curve(cv\surface_curve.curve_3d,
schema_name) THEN
REPEAT i := 1 TO SIZEOF(cv\surface_curve.
associated_geometry) BY 1;
IF (schema_name + '.SURFACE') IN TYPEOF(cv\
surface_curve.associated_geometry[i]) THEN
IF NOT gbsf_check_surface(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF (schema_name + '.PCURVE') IN TYPEOF(cv\
surface_curve.associated_geometry[i]) THEN
IF NOT gbsf_check_curve(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
RETURN(TRUE);
END_IF;
ELSE
IF (schema_name + '.TRIMMED_CURVE') IN TYPEOF(cv)
THEN
IF SIZEOF([schema_name + '.LINE',schema_name +
'.PARABOLA',schema_name + '.HYPERBOLA'] * TYPEOF(
cv\trimmed_curve.basis_curve)) = 1 THEN
RETURN(TRUE);
ELSE
RETURN(gbsf_check_curve(cv\trimmed_curve.
basis_curve,schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="gbsf_check_surface">
                                      <parameter
                                        name="sf">
                                        <typename
                                          name="surface"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ((schema_name + '.SURFACE') IN TYPEOF(sf)) THEN
RETURN(TRUE);
END_IF;
IF (schema_name + '.B_SPLINE_SURFACE') IN TYPEOF(sf) THEN
RETURN(NOT sf\b_spline_surface.self_intersect);
ELSE
IF SIZEOF([schema_name + '.SPHERICAL_SURFACE',schema_name +
'.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 3 THEN
RETURN(TRUE);
ELSE
IF (schema_name + '.CURVE_BOUNDED_SURFACE') IN TYPEOF(sf) THEN
IF SIZEOF([schema_name + '.CONICAL_SURFACE',schema_name +
'.CYLINDRICAL_SURFACE',schema_name + '.PLANE'] * TYPEOF(sf))
= 1 THEN
RETURN(SIZEOF(QUERY (bcurve &lt;* sf\curve_bounded_surface.
boundaries | (NOT gbsf_check_curve(bcurve,schema_name))))
= 0);
ELSE
IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface,
schema_name) THEN
RETURN(SIZEOF(QUERY (bcurve &lt;* sf\curve_bounded_surface.
boundaries | (NOT gbsf_check_curve(bcurve,schema_name))))
= 0);
END_IF;
END_IF;
ELSE
IF (schema_name + '.OFFSET_SURFACE') IN TYPEOF(sf) THEN
RETURN(gbsf_check_surface(sf\offset_surface.basis_surface,
schema_name) AND (NOT sf\offset_surface.self_intersect));
ELSE
IF (schema_name + '.RECTANGULAR_COMPOSITE_SURFACE') IN TYPEOF(
sf) THEN
REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
segments) BY 1;
REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
segments[i]) BY 1;
IF NOT gbsf_check_surface(sf\
rectangular_composite_surface.segments[i][j].
parent_surface,schema_name) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);
ELSE
IF (schema_name + '.RECTANGULAR_TRIMMED_SURFACE') IN TYPEOF(
sf) THEN
IF SIZEOF([schema_name + '.CONICAL_SURFACE',schema_name +
'.CYLINDRICAL_SURFACE',schema_name + '.PLANE'] *
TYPEOF(sf\rectangular_trimmed_surface.basis_surface)) =
1 THEN
RETURN(TRUE);
ELSE
RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
.basis_surface,schema_name));
END_IF;
ELSE
IF (schema_name + '.SURFACE_REPLICA') IN TYPEOF(sf) THEN
RETURN(gbsf_check_surface(sf\surface_replica.
parent_surface,schema_name));
ELSE
IF (schema_name + '.SWEPT_SURFACE') IN TYPEOF(sf) THEN
RETURN(gbsf_check_curve(sf\swept_surface.swept_curve,
schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_geometrically_bounded_wf_curve">
                                      <parameter
                                        name="crv">
                                        <typename
                                          name="curve"/>
                                      </parameter>
                                      <parameter
                                        name="schma">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF SIZEOF([schma + '.POLYLINE',schma + '.B_SPLINE_CURVE',schma +
'.ELLIPSE',schma + '.CIRCLE'] * TYPEOF(crv)) = 1 THEN
RETURN(TRUE);
ELSE
IF (schma + '.TRIMMED_CURVE') IN TYPEOF(crv) THEN
IF SIZEOF([schma + '.LINE',schma + '.PARABOLA',schma +
'.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.basis_curve)) = 1
THEN
RETURN(TRUE);
ELSE
RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
basis_curve,schma));
END_IF;
ELSE
IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF(crv) THEN
RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
basis_curve,schma));
ELSE
IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv) THEN
RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
parent_curve,schma));
ELSE
IF (schma + '.COMPOSITE_CURVE') IN TYPEOF(crv) THEN
RETURN(SIZEOF(QUERY (ccs &lt;* crv\composite_curve.segments |
(NOT valid_geometrically_bounded_wf_curve(ccs.
parent_curve,schma)))) = 0);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_geometrically_bounded_wf_point">
                                      <parameter
                                        name="pnt">
                                        <typename
                                          name="point"/>
                                      </parameter>
                                      <parameter
                                        name="schma">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF (schma + '.CARTESIAN_POINT') IN TYPEOF(pnt) THEN
RETURN(TRUE);
ELSE
IF (schma + '.POINT_ON_CURVE') IN TYPEOF(pnt) THEN
RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
basis_curve,schma));
ELSE
IF (schma + '.POINT_REPLICA') IN TYPEOF(pnt) THEN
RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
parent_pt,schma));
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_time">
                                      <parameter
                                        name="time">
                                        <typename
                                          name="local_time"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF EXISTS(time.second_component) THEN
RETURN(EXISTS(time.minute_component));
ELSE
RETURN(TRUE);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="basis_surface_check">
                                      <parameter
                                        name="surf">
                                        <typename
                                          name="surface"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF SIZEOF([schema_name + '.B_SPLINE_SURFACE',schema_name +
'.ELEMENTARY_SURFACE'] * TYPEOF(surf)) = 1 THEN
RETURN(TRUE);
ELSE
IF (schema_name + '.SWEPT_SURFACE') IN TYPEOF(surf) THEN
RETURN(basis_curve_check(surf\swept_surface.swept_curve,
schema_name));
ELSE
IF (schema_name + '.OFFSET_SURFACE') IN TYPEOF(surf) THEN
RETURN(basis_surface_check(surf\offset_surface.basis_surface,
schema_name));
ELSE
IF (schema_name + '.SURFACE REPLICA') IN TYPEOF(surf) THEN
RETURN(basis_surface_check(surf\surface_replica.parent_surface,
schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="basis_curve_check">
                                      <parameter
                                        name="cv">
                                        <typename
                                          name="curve"/>
                                      </parameter>
                                      <parameter
                                        name="schema_name">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name + '.CONIC',
schema_name + '.LINE',schema_name + '.POLYLINE'] * TYPEOF(cv)) = 1
THEN
RETURN(TRUE);
ELSE
IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv) THEN
RETURN(basis_curve_check(cv\curve_replica.parent_curve,schema_name));
ELSE
IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv) THEN
RETURN(basis_curve_check(cv\offset_curve_3d.basis_curve,
schema_name));
ELSE
IF (schema_name + '.PCURVE') IN TYPEOF(cv) THEN
IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name +
'.CONIC',schema_name + '.LINE',schema_name + '.POLYLINE'] *
TYPEOF(cv\pcurve.reference_to_curve\representation.items[1]))
= 1 THEN
RETURN(basis_surface_check(cv\pcurve.basis_surface,
schema_name));
ELSE
IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv\pcurve.
reference_to_curve\representation.items[1]) THEN
RETURN(basis_curve_check(cv\pcurve.reference_to_curve\
representation.items[1],schema_name) AND
basis_surface_check(cv\pcurve.basis_surface,schema_name));
END_IF;
END_IF;
ELSE
IF (schema_name + '.SURFACE_CURVE') IN TYPEOF(cv) THEN
IF SIZEOF([schema_name + '.B_SPLINE_CURVE',schema_name +
'.CONIC',schema_name + '.LINE',schema_name + '.POLYLINE']
* TYPEOF(cv\surface_curve.curve_3d)) = 1 THEN
REPEAT i := 1 TO SIZEOF(cv\surface_curve.
associated_geometry) BY 1;
IF (schema_name + '.SURFACE') IN TYPEOF(cv\surface_curve
.associated_geometry[i]) THEN
IF NOT basis_surface_check(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF (schema_name + '.PCURVE') IN TYPEOF(cv\
surface_curve.associated_geometry[i]) THEN
IF NOT basis_curve_check(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
ELSE
IF (schema_name + '.CURVE_REPLICA') IN TYPEOF(cv\
surface_curve.curve_3d) THEN
IF NOT basis_curve_check(cv\curve_replica.parent_curve,
schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF (schema_name + '.OFFSET_CURVE_3D') IN TYPEOF(cv\
surface_curve.curve_3d) THEN
IF NOT basis_curve_check(cv\offset_curve_3d.
basis_curve,schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
REPEAT i := 1 TO SIZEOF(cv\surface_curve.
associated_geometry) BY 1;
IF (schema_name + '.SURFACE') IN TYPEOF(cv\
surface_curve.associated_geometry[i]) THEN
IF NOT basis_surface_check(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF (schema_name + '.PCURVE') IN TYPEOF(cv\
surface_curve.associated_geometry[i]) THEN
IF NOT basis_curve_check(cv\surface_curve.
associated_geometry[i],schema_name) THEN
RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_mapped_representation">
                                      <parameter
                                        name="parent_set">
                                        <aggregate
                                          type="SET"/>
                                        <typename
                                          name="representation"/>
                                      </parameter>
                                      <parameter
                                        name="children_set">
                                        <aggregate
                                          type="SET"/>
                                        <typename
                                          name="representation_item"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
x : SET OF representation_item;
y : SET OF representation_item;
END_LOCAL;
x := QUERY (z &lt;* children_set | ('SMCH_PLUS_203_SCHEMA.MAPPED_ITEM' IN
TYPEOF(z)));
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF x[i]\mapped_item.mapping_source.mapped_representation IN
parent_set THEN
RETURN(FALSE);
END_IF;
IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
.mapping_source.mapped_representation,x[i]\mapped_item.
mapping_source.mapped_representation.items) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
x := children_set - x;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
y := QUERY (z &lt;* bag_to_set(USEDIN(x[i],'')) | (
'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)));
IF NOT acyclic_mapped_representation(parent_set,y) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_units">
                                      <parameter
                                        name="m">
                                        <typename
                                          name="measure_with_unit"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF 'SMCH_PLUS_203_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(1,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,1,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,1,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,1,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m
.value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,1,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,1,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,1) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(2,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(3,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(1,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="derive_dimensional_exponents">
                                      <parameter
                                        name="x">
                                        <typename
                                          name="unit"/>
                                      </parameter>
                                      <typename
                                        name="dimensional_exponents"/>
                                      <algorithm>
LOCAL
i : INTEGER;
result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
0);
END_LOCAL;
IF 'SMCH_PLUS_203_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
result.length_exponent := result.length_exponent + (x.elements[i].
exponent * x.elements[i].unit.dimensions.length_exponent);
result.mass_exponent := result.mass_exponent + (x.elements[i].
exponent * x.elements[i].unit.dimensions.mass_exponent);
result.time_exponent := result.time_exponent + (x.elements[i].
exponent * x.elements[i].unit.dimensions.time_exponent);
result.electric_current_exponent := result.
electric_current_exponent + (x.elements[i].exponent * x.
elements[i].unit.dimensions.electric_current_exponent);
result.thermodynamic_temperature_exponent := result.
thermodynamic_temperature_exponent + (x.elements[i].exponent *
x.elements[i].unit.dimensions.
thermodynamic_temperature_exponent);
result.amount_of_substance_exponent := result.
amount_of_substance_exponent + (x.elements[i].exponent * x.
elements[i].unit.dimensions.amount_of_substance_exponent);
result.luminous_intensity_exponent := result.
luminous_intensity_exponent + (x.elements[i].exponent * x.
elements[i].unit.dimensions.luminous_intensity_exponent);
END_REPEAT;
ELSE
result := x.dimensions;
END_IF;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="conditional_reverse">
                                      <parameter
                                        name="p">
                                        <builtintype
                                          type="BOOLEAN"/>
                                      </parameter>
                                      <parameter
                                        name="an_item">
                                        <typename
                                          name="reversible_topology"/>
                                      </parameter>
                                      <typename
                                        name="reversible_topology"/>
                                      <algorithm>
IF p THEN
RETURN(an_item);
ELSE
RETURN(topology_reversed(an_item));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="topology_reversed">
                                      <parameter
                                        name="an_item">
                                        <typename
                                          name="reversible_topology"/>
                                      </parameter>
                                      <typename
                                        name="reversible_topology"/>
                                      <algorithm>
IF 'SMCH_PLUS_203_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
RETURN(edge_reversed(an_item));
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.PATH' IN TYPEOF(an_item) THEN
RETURN(path_reversed(an_item));
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
RETURN(face_bound_reversed(an_item));
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.FACE' IN TYPEOF(an_item) THEN
RETURN(face_reversed(an_item));
END_IF;
IF 'SMCH_PLUS_203_SCHEMA.SHELL' IN TYPEOF(an_item) THEN
RETURN(shell_reversed(an_item));
END_IF;
IF 'SET' IN TYPEOF(an_item) THEN
RETURN(set_of_topology_reversed(an_item));
END_IF;
IF 'LIST' IN TYPEOF(an_item) THEN
RETURN(list_of_topology_reversed(an_item));
END_IF;
RETURN(?);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="edge_reversed">
                                      <parameter
                                        name="an_edge">
                                        <typename
                                          name="edge"/>
                                      </parameter>
                                      <typename
                                        name="oriented_edge"/>
                                      <algorithm>
LOCAL
the_reverse : oriented_edge;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge)) THEN
the_reverse := dummy_tri ||
edge(an_edge.edge_end, an_edge.edge_start) ||
oriented_edge(an_edge\oriented_edge.edge_element,
NOT (an_edge\oriented_edge.orientation)) ;
ELSE
the_reverse := dummy_tri ||
edge(an_edge.edge_end, an_edge.edge_start) ||
oriented_edge(an_edge, FALSE);
END_IF;
RETURN (the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="path_reversed">
                                      <parameter
                                        name="a_path">
                                        <typename
                                          name="path"/>
                                      </parameter>
                                      <typename
                                        name="oriented_path"/>
                                      <algorithm>
LOCAL
the_reverse : oriented_path ;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path)) THEN
the_reverse := dummy_tri ||
path(list_of_topology_reversed (a_path.edge_list)) ||
oriented_path(a_path\oriented_path.path_element,
NOT(a_path\oriented_path.orientation)) ;
ELSE
the_reverse := dummy_tri ||
path(list_of_topology_reversed (a_path.edge_list)) ||
oriented_path(a_path, FALSE);
END_IF;
RETURN (the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="list_of_topology_reversed">
                                      <parameter
                                        name="a_list">
                                        <typename
                                          name="list_of_reversible_topology_item"/>
                                      </parameter>
                                      <typename
                                        name="list_of_reversible_topology_item"/>
                                      <algorithm>
LOCAL
the_reverse : list_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_list) BY 1;
the_reverse := topology_reversed(a_list[i]) + the_reverse;
END_REPEAT;
RETURN(the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="face_bound_reversed">
                                      <parameter
                                        name="a_face_bound">
                                        <typename
                                          name="face_bound"/>
                                      </parameter>
                                      <typename
                                        name="face_bound"/>
                                      <algorithm>
LOCAL
the_reverse : face_bound;
END_LOCAL;
the_reverse.name := '';
IF 'SMCH_PLUS_203_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
THEN
the_reverse.bound := a_face_bound\face_bound.bound;
the_reverse.orientation := NOT a_face_bound\face_bound.orientation;
ELSE
the_reverse.bound := a_face_bound.bound;
the_reverse.orientation := NOT a_face_bound.orientation;
END_IF;
RETURN(the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="face_reversed">
                                      <parameter
                                        name="a_face">
                                        <typename
                                          name="face"/>
                                      </parameter>
                                      <typename
                                        name="oriented_face"/>
                                      <algorithm>
LOCAL
the_reverse : oriented_face ;
END_LOCAL;
IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face)) THEN
the_reverse := dummy_tri ||
face(set_of_topology_reversed(a_face.bounds)) ||
oriented_face(a_face\oriented_face.face_element,
NOT (a_face\oriented_face.orientation)) ;
ELSE
the_reverse := dummy_tri ||
face(set_of_topology_reversed(a_face.bounds)) ||
oriented_face(a_face, FALSE) ;
END_IF;
RETURN (the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="set_of_topology_reversed">
                                      <parameter
                                        name="a_set">
                                        <typename
                                          name="set_of_reversible_topology_item"/>
                                      </parameter>
                                      <typename
                                        name="set_of_reversible_topology_item"/>
                                      <algorithm>
LOCAL
the_reverse : set_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_set) BY 1;
the_reverse := the_reverse + topology_reversed(a_set[i]);
END_REPEAT;
RETURN(the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="shell_reversed">
                                      <parameter
                                        name="a_shell">
                                        <typename
                                          name="shell"/>
                                      </parameter>
                                      <typename
                                        name="shell"/>
                                      <algorithm>
LOCAL
the_reverse : shell;
END_LOCAL;
IF 'SMCH_PLUS_203_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
the_reverse := representation_item('') ||
topological_representation_item() || connected_face_set(
set_of_topology_reversed(a_shell\connected_face_set.cfs_faces))
|| open_shell() || oriented_open_shell(a_shell\
oriented_open_shell.open_shell_element,NOT a_shell\
oriented_open_shell.orientation);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
the_reverse := representation_item('') ||
topological_representation_item() || connected_face_set(
set_of_topology_reversed(a_shell\connected_face_set.cfs_faces))
|| open_shell() || oriented_open_shell(a_shell,FALSE);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
THEN
the_reverse := representation_item('') ||
topological_representation_item() || connected_face_set(
set_of_topology_reversed(a_shell\connected_face_set.cfs_faces))
|| closed_shell() || oriented_closed_shell(a_shell\
oriented_closed_shell.closed_shell_element,NOT a_shell\
oriented_closed_shell.orientation);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
the_reverse := representation_item('') ||
topological_representation_item() || connected_face_set(
set_of_topology_reversed(a_shell\connected_face_set.
cfs_faces)) || closed_shell() || oriented_closed_shell(
a_shell,FALSE);
ELSE
the_reverse := ?;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(the_reverse);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="boolean_choose">
                                      <parameter
                                        name="b">
                                        <builtintype
                                          type="BOOLEAN"/>
                                      </parameter>
                                      <parameter
                                        name="choice1">
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <parameter
                                        name="choice2">
                                        <builtintype
                                          type="GENERIC"/>
                                      </parameter>
                                      <builtintype
                                        type="GENERIC"/>
                                      <algorithm>
IF b THEN
RETURN(choice1);
ELSE
RETURN(choice2);
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="path_head_to_tail">
                                      <parameter
                                        name="a_path">
                                        <typename
                                          name="path"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
LOCAL
n : INTEGER;
p : BOOLEAN := TRUE;
END_LOCAL;
n := SIZEOF(a_path.edge_list);
REPEAT i := 2 TO n BY 1;
p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
.edge_start);
END_REPEAT;
RETURN(p);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_point_replica">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="point_replica"/>
                                      </parameter>
                                      <parameter
                                        name="parent">
                                        <typename
                                          name="point"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ('SMCH_PLUS_203_SCHEMA.POINT_REPLICA' IN TYPEOF(parent)) THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="item_in_context">
                                      <parameter
                                        name="item">
                                        <typename
                                          name="representation_item"/>
                                      </parameter>
                                      <parameter
                                        name="cntxt">
                                        <typename
                                          name="representation_context"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
y : BAG OF representation_item;
END_LOCAL;
IF SIZEOF(USEDIN(item,'SMCH_PLUS_203_SCHEMA.REPRESENTATION.ITEMS') *
cntxt.representations_in_context) &gt; 0 THEN
RETURN(TRUE);
ELSE
y := QUERY (z &lt;* USEDIN(item,'') | (
'SMCH_PLUS_203_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)));
IF SIZEOF(y) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(y) BY 1;
IF item_in_context(y[i],cntxt) THEN
RETURN(TRUE);
END_IF;
END_REPEAT;
END_IF;
END_IF;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_product_category_relationship">
                                      <parameter
                                        name="relation">
                                        <typename
                                          name="product_category_relationship"/>
                                      </parameter>
                                      <parameter
                                        name="children">
                                        <aggregate
                                          type="SET"/>
                                        <typename
                                          name="product_category"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
LOCAL
x : SET OF product_category_relationship;
local_children : SET OF product_category;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(children) BY 1;
IF relation.category :=: children[i] THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.category,'SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
local_children := children + relation.category;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF NOT acyclic_product_category_relationship(x[i],local_children)
THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_product_definition_relationship">
                                      <parameter
                                        name="relation">
                                        <typename
                                          name="product_definition_relationship"/>
                                      </parameter>
                                      <parameter
                                        name="relatives">
                                        <aggregate
                                          type="SET"
                                          lower="1"
                                          upper="?"/>
                                        <typename
                                          name="product_definition"/>
                                      </parameter>
                                      <parameter
                                        name="specific_relation">
                                        <builtintype
                                          type="STRING"/>
                                      </parameter>
                                      <builtintype
                                        type="LOGICAL"/>
                                      <algorithm>
LOCAL
x : SET OF product_definition_relationship;
END_LOCAL;
IF relation.relating_product_definition IN relatives THEN
RETURN(FALSE);
END_IF;
x := QUERY (pd &lt;* bag_to_set(USEDIN(relation.
relating_product_definition,'SMCH_PLUS_203_SCHEMA.' +
'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
| (specific_relation IN TYPEOF(pd)));
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF NOT acyclic_product_definition_relationship(x[i],relatives +
relation.relating_product_definition,specific_relation) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="curve_weights_positive">
                                      <parameter
                                        name="b">
                                        <typename
                                          name="rational_b_spline_curve"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
IF b.weights[i] &lt;= 0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="surface_weights_positive">
                                      <parameter
                                        name="b">
                                        <typename
                                          name="rational_b_spline_surface"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper BY 1;
REPEAT j := 0 TO b.v_upper BY 1;
IF b.weights[i][j] &lt;= 0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="constraints_rectangular_composite_surface">
                                      <parameter
                                        name="s">
                                        <typename
                                          name="rectangular_composite_surface"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
REPEAT i := 1 TO s.n_u BY 1;
REPEAT j := 1 TO s.n_v BY 1;
IF NOT (('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(s.
segments[i][j].parent_surface)) OR (
'SMCH_PLUS_203_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.
segments[i][j].parent_surface))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u - 1 BY 1;
REPEAT j := 1 TO s.n_v BY 1;
IF s.segments[i][j].u_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u BY 1;
REPEAT j := 1 TO s.n_v - 1 BY 1;
IF s.segments[i][j].v_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="check_associative_shape_aspects">
                                      <parameter
                                        name="sdr">
                                        <typename
                                          name="shape_definition_representation"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
sr1 : SET OF representation;
sr2 : SET OF representation;
i : INTEGER;
j : INTEGER;
k : INTEGER;
dm : SET OF representation;
pv : SET OF representation;
END_LOCAL;
IF SIZEOF(sdr.used_representation.items) &lt;&gt; 2 THEN
RETURN(FALSE);
END_IF;
sr1 := using_representations(sdr.used_representation.items[1]);
sr2 := using_representations(sdr.used_representation.items[2]);
REPEAT i := 1 TO HIINDEX(sr1) BY 1;
dm := representations_mapped_into(sr1[i]);
REPEAT j := 1 TO HIINDEX(dm) BY 1;
IF 'SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL' IN TYPEOF(dm[j]) THEN
IF dm[j] IN sr2 THEN
RETURN(TRUE);
END_IF;
pv := representations_mapped_into(dm[j]);
REPEAT k := 1 TO HIINDEX(pv) BY 1;
IF 'SMCH_PLUS_203_SCHEMA.PRESENTATION_VIEW' IN TYPEOF(pv[k])
THEN
IF pv[k] IN sr2 THEN
RETURN(TRUE);
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO HIINDEX(sr2) BY 1;
dm := representations_mapped_into(sr2[i]);
REPEAT j := 1 TO HIINDEX(dm) BY 1;
IF 'SMCH_PLUS_203_SCHEMA.DRAUGHTING_MODEL' IN TYPEOF(dm[j]) THEN
IF dm[j] IN sr1 THEN
RETURN(TRUE);
END_IF;
pv := representations_mapped_into(dm[j]);
REPEAT k := 1 TO HIINDEX(pv) BY 1;
IF 'SMCH_PLUS_203_SCHEMA.PRESENTATION_VIEW' IN TYPEOF(pv[k])
THEN
IF pv[k] IN sr1 THEN
RETURN(TRUE);
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="representations_mapped_into">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="representation"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"/>
                                      <typename
                                        name="representation"/>
                                      <algorithm>
LOCAL
results : SET OF representation := [];
i : INTEGER;
j : INTEGER;
mi : SET OF mapped_item;
rm : SET OF representation_map;
END_LOCAL;
rm := USEDIN(rep,'SMCH_PLUS_203_SCHEMA.' +
'REPRESENTATION_MAP.MAPPED_REPRESENTATION');
REPEAT i := 1 TO HIINDEX(rm) BY 1;
mi := mi + rm[i].map_usage;
END_REPEAT;
REPEAT j := 1 TO HIINDEX(mi) BY 1;
results := results + USEDIN(mi[j],'SMCH_PLUS_203_SCHEMA.' +
'REPRESENTATION.ITEMS');
END_REPEAT;
RETURN(results);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="constraints_geometry_shell_based_surface_model">
                                      <parameter
                                        name="m">
                                        <typename
                                          name="shell_based_surface_model"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
IF (NOT ('SMCH_PLUS_203_SCHEMA.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[
j]))) AND (NOT ('SMCH_PLUS_203_SCHEMA.CLOSED_SHELL' IN TYPEOF(m.
sbsm_boundary[j]))) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="constraints_geometry_shell_based_wireframe_model">
                                      <parameter
                                        name="m">
                                        <typename
                                          name="shell_based_wireframe_model"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
IF (NOT ('SMCH_PLUS_203_SCHEMA.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[
j]))) AND (NOT ('SMCH_PLUS_203_SCHEMA.VERTEX_SHELL' IN TYPEOF(m.
sbwm_boundary[j]))) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="dimensions_for_si_unit">
                                      <parameter
                                        name="n">
                                        <typename
                                          name="si_unit_name"/>
                                      </parameter>
                                      <typename
                                        name="dimensional_exponents"/>
                                      <algorithm>
CASE n OF
metre : RETURN(dimensional_exponents(1,0,0,0,0,0,0));
gram : RETURN(dimensional_exponents(0,1,0,0,0,0,0));
second : RETURN(dimensional_exponents(0,0,1,0,0,0,0));
ampere : RETURN(dimensional_exponents(0,0,0,1,0,0,0));
kelvin : RETURN(dimensional_exponents(0,0,0,0,1,0,0));
mole : RETURN(dimensional_exponents(0,0,0,0,0,1,0));
candela : RETURN(dimensional_exponents(0,0,0,0,0,0,1));
radian : RETURN(dimensional_exponents(0,0,0,0,0,0,0));
steradian : RETURN(dimensional_exponents(0,0,0,0,0,0,0));
hertz : RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
newton : RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
pascal : RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
joule : RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
watt : RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
coulomb : RETURN(dimensional_exponents(0,0,1,1,0,0,0));
volt : RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
farad : RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
ohm : RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
siemens : RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
weber : RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
tesla : RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
henry : RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
degree_celsius : RETURN(dimensional_exponents(0,0,0,0,1,0,0));
lumen : RETURN(dimensional_exponents(0,0,0,0,0,0,1));
lux : RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
becquerel : RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
gray : RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
sievert : RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
OTHERWISE : RETURN(?);
END_CASE;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_surface_replica">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="surface_replica"/>
                                      </parameter>
                                      <parameter
                                        name="parent">
                                        <typename
                                          name="surface"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ('SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent)) THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_surface_replica(rep,parent\surface_replica.
parent_surface));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="valid_measure_value">
                                      <parameter
                                        name="m">
                                        <typename
                                          name="measure_value"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF 'REAL' IN TYPEOF(m) THEN
RETURN(m &gt; 0);
ELSE
IF 'INTEGER' IN TYPEOF(m) THEN
RETURN(m &gt; 0);
ELSE
RETURN(TRUE);
END_IF;
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="above_plane">
                                      <parameter
                                        name="p1">
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <parameter
                                        name="p2">
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <parameter
                                        name="p3">
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <parameter
                                        name="p4">
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <builtintype
                                        type="REAL"/>
                                      <algorithm>
LOCAL
dir2 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
dir3 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
dir4 : direction := dummy_gri || direction([ 1.00000, 0.00000, 0.00000 ]);
val : REAL;
mag : REAL;
END_LOCAL;
IF p1.dim &lt;&gt; 3 THEN
RETURN (?);
END_IF;
REPEAT i := 1 TO 3;
dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
END_REPEAT;
mag := sqrt(mag);
val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
RETURN (val);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="same_side">
                                      <parameter
                                        name="plane_pts">
                                        <aggregate
                                          type="LIST"
                                          lower="3"
                                          upper="3"/>
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <parameter
                                        name="test_points">
                                        <aggregate
                                          type="LIST"
                                          lower="2"
                                          upper="?"/>
                                        <typename
                                          name="cartesian_point"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
val1 : REAL;
val2 : REAL;
n : INTEGER;
END_LOCAL;
IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
RETURN (?);
END_IF;
n := SIZEOF(test_points);
val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[1]);
REPEAT i := 2 TO n;
val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[i]);
IF val1 * val2 &lt;= 0.00000 THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN (TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="build_transformed_set">
                                      <parameter
                                        name="tr">
                                        <typename
                                          name="cartesian_transformation_operator"/>
                                      </parameter>
                                      <parameter
                                        name="gset">
                                        <typename
                                          name="geometric_set"/>
                                      </parameter>
                                      <aggregate
                                        type="SET"
                                        lower="0"
                                        upper="?"/>
                                      <typename
                                        name="geometric_set_select"/>
                                      <algorithm>
LOCAL
s : SET [1:?] OF geometric_set_select := gset.elements;
trset : SET [0:?] OF geometric_set_select := [];
END_LOCAL;
RETURN (trset);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_set_replica">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="geometric_set_replica"/>
                                      </parameter>
                                      <parameter
                                        name="parent">
                                        <typename
                                          name="geometric_set"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_SET_REPLICA' IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF parent :=: rep THEN
RETURN (FALSE);
ELSE
RETURN (acyclic_set_replica(rep, parent\geometric_set_replica.parent_set));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="nmsf_surface_check">
                                      <parameter
                                        name="surf">
                                        <typename
                                          name="surface"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF 'SMCH_PLUS_203_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
RETURN (TRUE);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN
RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));
ELSE
IF ('SMCH_PLUS_203_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf)) AND (surf\offset_surface.self_intersect = FALSE) OR (surf\offset_surface.self_intersect = UNKNOWN) THEN
RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
ELSE
IF 'SMCH_PLUS_203_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf) THEN
RETURN (nmsf_surface_check(surf\surface_replica.parent_surface));
ELSE
IF ('SMCH_PLUS_203_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND (surf\b_spline_surface.self_intersect = FALSE) OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN
RETURN (TRUE);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="nmsf_curve_check">
                                      <parameter
                                        name="cv">
                                        <typename
                                          name="representation_item"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF SIZEOF([ 'SMCH_PLUS_203_SCHEMA.BOUNDED_CURVE', 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA', 'SMCH_PLUS_203_SCHEMA.LINE', 'SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D' ] * TYPEOF(cv)) &gt; 1 THEN
RETURN (FALSE);
ELSE
IF ('SMCH_PLUS_203_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN) THEN
RETURN (TRUE);
ELSE
IF SIZEOF([ 'SMCH_PLUS_203_SCHEMA.CONIC', 'SMCH_PLUS_203_SCHEMA.LINE' ] * TYPEOF(cv)) = 1 THEN
RETURN (TRUE);
ELSE
IF 'SMCH_PLUS_203_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
RETURN (nmsf_curve_check(cv\curve_replica.parent_curve));
ELSE
IF (('SMCH_PLUS_203_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN))) AND NOT ('SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)) THEN
RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve));
ELSE
IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
RETURN (nmsf_curve_check(cv\pcurve.reference_to_curve\representation.items[1]) AND nmsf_surface_check(cv\pcurve.basis_surface));
ELSE
IF 'SMCH_PLUS_203_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv) THEN
IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
IF 'SMCH_PLUS_203_SCHEMA.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
IF NOT nmsf_surface_check(cv\surface_curve.associated_geometry[i]) THEN
RETURN (FALSE);
END_IF;
ELSE
IF 'SMCH_PLUS_203_SCHEMA.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
IF NOT nmsf_curve_check(cv\surface_curve.associated_geometry[i]) THEN
RETURN (FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
RETURN (TRUE);
END_IF;
ELSE
IF 'SMCH_PLUS_203_SCHEMA.POLYLINE' IN TYPEOF(cv) THEN
IF SIZEOF(cv\polyline.points) &gt;= 3 THEN
RETURN (TRUE);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="acyclic_solid_replica">
                                      <parameter
                                        name="rep">
                                        <typename
                                          name="solid_replica"/>
                                      </parameter>
                                      <parameter
                                        name="parent">
                                        <typename
                                          name="solid_model"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
IF NOT ('SMCH_PLUS_203_SCHEMA.SOLID_REPLICA' IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
IF parent :=: rep THEN
RETURN (FALSE);
ELSE
RETURN (acyclic_solid_replica(rep, parent\solid_replica.parent_solid));
END_IF;
                                      </algorithm>
                                    </function>

                                    <function
                                      name="assembly_shape_is_defined">
                                      <parameter
                                        name="assy">
                                        <typename
                                          name="next_assembly_usage_occurrence"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
srr_set : SET OF shape_representation_relationship := [];
sdr_set : SET OF shape_definition_representation := [];
END_LOCAL;
sdr_set := QUERY (pdr &lt;* bag_to_set(USEDIN(assy.
related_product_definition,
'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
'DEFINITION.DEFINITION')) | (
'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)))
+ QUERY (pdr &lt;* bag_to_set(USEDIN(assy.related_product_definition,
'SMCH_PLUS_203_SCHEMA.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION.' +
'DEFINITION.RELATED_PRODUCT_DEFINITION')) | (
'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
IF SIZEOF(sdr_set) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
srr_set := QUERY (rr &lt;* bag_to_set(USEDIN(sdr_set[i]\
property_definition_representation.used_representation,
'SMCH_PLUS_203_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'))
| ('SMCH_PLUS_203_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN
TYPEOF(rr)));
IF SIZEOF(srr_set) &gt; 0 THEN
REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
IF SIZEOF(QUERY (pdr &lt;* bag_to_set(USEDIN(srr_set[j]\
representation_relationship.rep_1,
'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
'USED_REPRESENTATION')) | (
'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN
TYPEOF(pdr))) * QUERY (pdr &lt;* bag_to_set(USEDIN(assy.
relating_product_definition,
'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' +
'USED_REPRESENTATION.DEFINITION')) | (
'SMCH_PLUS_203_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN
TYPEOF(pdr)))) &gt;= 1 THEN
IF SIZEOF(QUERY (cdsr &lt;* USEDIN(assy,'SMCH_PLUS_203_SCHEMA.'
+ 'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
'REPRESENTED_PRODUCT_RELATION') | (NOT ((cdsr.
represented_product_relation.definition :=: assy) AND (
cdsr.representation_relation :=: srr_set[j]))))) &gt; 0
THEN
RETURN(FALSE);
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                                      </algorithm>
                                    </function>

                                    <function
                                      name="unique_version_change_order">
                                      <parameter
                                        name="c">
                                        <typename
                                          name="action"/>
                                      </parameter>
                                      <builtintype
                                        type="BOOLEAN"/>
                                      <algorithm>
LOCAL
ords : action_directive := c\directed_action.directive;
assign : SET OF change_request := [];
versions : SET OF product_definition_formation := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
assign := assign + QUERY (ara &lt;* bag_to_set(USEDIN(ords.requests[i],
'SMCH_PLUS_203_SCHEMA.ACTION_REQUEST_ASSIGNMENT.' +
'ASSIGNED_ACTION_REQUEST')) | (
'SMCH_PLUS_203_SCHEMA.CHANGE_REQUEST' IN TYPEOF(ara)));
END_REPEAT;
REPEAT k := 1 TO SIZEOF(assign) BY 1;
versions := versions + assign[k].items;
END_REPEAT;
RETURN(SIZEOF(QUERY (vers &lt;* versions | (NOT (SIZEOF(
QUERY (other_vers &lt;* (versions - vers) | (vers.of_product :=:
other_vers.of_product))) = 0)))) = 0);
                                      </algorithm>
                                    </function>

                                    <rule
                                      name="acu_requires_security_classification"
                                      appliesto="assembly_component_usage cc_design_security_classification">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (acu &lt;* assembly_component_usage | (NOT (SIZEOF(QUERY (ccdsc &lt;* cc_design_security_classification | (acu IN ccdsc.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="approval_requires_approval_date_time"
                                      appliesto="approval approval_date_time">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (app &lt;* approval | (NOT (SIZEOF(QUERY (adt &lt;* approval_date_time | (app :=: adt.dated_approval))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="approval_requires_approval_person_organization"
                                      appliesto="approval approval_person_organization">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (app &lt;* approval | (NOT (SIZEOF(QUERY (apo &lt;* approval_person_organization | (app :=: apo. authorized_approval))) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="approvals_are_assigned"
                                      appliesto="approval approval_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (app &lt;* approval | (NOT (SIZEOF(QUERY (aa &lt;* approval_assignment | (app :=: aa.assigned_approval))) &gt;= 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="as_required_quantity"
                                      appliesto="measure_with_unit">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (m &lt;* measure_with_unit | (('SMCH_PLUS_203_SCHEMA.DESCRIPTIVE_MEASURE' IN TYPEOF(m. value_component)) AND (NOT (m.value_component = 'as_required')))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="certification_requires_approval"
                                      appliesto="certification cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (cert &lt;* certification | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (cert IN ccda.items))) =1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="certification_requires_date_time"
                                      appliesto="certification cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (cert &lt;* certification | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | (cert IN ccdta.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="change_request_requires_approval"
                                      appliesto="change_request cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (cr &lt;* change_request | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (cr IN ccda.items))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="change_request_requires_date_time"
                                      appliesto="change_request cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (cr &lt;* change_request | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | (cr IN ccdta.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="change_request_requires_person_organization"
                                      appliesto="change_request cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (cr &lt;* change_request | (NOT (SIZEOF(QUERY (ccpoa &lt;* cc_design_person_and_organization_assignment| (cr IN ccpoa.items))) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="change_requires_approval"
                                      appliesto="change cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (chg &lt;* change | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (chg IN ccda.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="change_requires_date_time"
                                      appliesto="change cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (chg &lt;* change | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND(ccdta.role.name = 'start_date')))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="compatible_dimension"
                                      appliesto="cartesian_point direction representation_context geometric_representation_context">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (x &lt;* cartesian_point | (SIZEOF(QUERY (y &lt;* geometric_representation_context | (item_in_context(x,y) AND (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension)))) &gt;0))) = 0)">
                                      </where>
                                      <where
                                        label="wr2"
                                        expression="(SIZEOF(QUERY (x &lt;* direction | (SIZEOF(QUERY (y &lt;* geometric_representation_context | (item_in_context(x,y) AND (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension))))&gt; 0))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="configuration_item_requires_approval"
                                      appliesto="configuration_item cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ci &lt;* configuration_item | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (ci IN ccda.items))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="configuration_item_requires_person_organization"
                                      appliesto="configuration_item cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ci &lt;* configuration_item | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment| (ci IN ccdpoa.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="contract_requires_approval"
                                      appliesto="contract cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (c &lt;* contract | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (c IN ccda.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="contract_requires_person_organization"
                                      appliesto="contract cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (c &lt;* contract | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | (c IN ccdpoa. items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="coordinated_assembly_and_shape"
                                      appliesto="next_assembly_usage_occurrence">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (nauo &lt;* next_assembly_usage_occurrence | (NOT assembly_shape_is_defined(nauo)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_action_directive"
                                      appliesto="action_directive">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ad &lt;* action_directive | (NOT (SIZEOF(USEDIN(ad,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_approval_status"
                                      appliesto="approval_status">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ast &lt;* approval_status | (NOT (SIZEOF(USEDIN(ast,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_certification_type"
                                      appliesto="certification_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ct &lt;* certification_type | (NOT (SIZEOF(USEDIN(ct,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_contract_type"
                                      appliesto="contract_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ct &lt;* contract_type | (NOT (SIZEOF(USEDIN(ct,''))&gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_date"
                                      appliesto="date">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dt &lt;* date | (NOT (SIZEOF(USEDIN(dt,'')) &gt;= 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_date_time_role"
                                      appliesto="date_time_role">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dtr &lt;* date_time_role | (NOT (SIZEOF(USEDIN(dtr,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_document_type"
                                      appliesto="document_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dt &lt;* document_type | (NOT (SIZEOF(USEDIN(dt,''))&gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_named_unit"
                                      appliesto="named_unit">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (nu &lt;* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) &gt;=1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_parametric_representation_context"
                                      appliesto="parametric_representation_context">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (prc &lt;* parametric_representation_context | (NOT (SIZEOF(USEDIN(prc,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_person_and_organization_role"
                                      appliesto="person_and_organization_role">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (poar &lt;* person_and_organization_role | (NOT (SIZEOF(USEDIN(poar,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_representation_item"
                                      appliesto="representation_item">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ri &lt;* representation_item | (NOT (SIZEOF(USEDIN(ri,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_security_classification_level"
                                      appliesto="security_classification_level">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (scl &lt;* security_classification_level | (NOT (SIZEOF(USEDIN(scl,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dependent_instantiable_shape_representation"
                                      appliesto="shape_representation">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sr &lt;* shape_representation | (NOT (SIZEOF(USEDIN(sr,'')) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="design_context_for_property"
                                      appliesto="product_definition">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pd &lt;* product_definition | ((SIZEOF(USEDIN(pd,'SMCH_PLUS_203_SCHEMA.' + 'PROPERTY_DEFINITION.DEFINITION') + QUERY (pdr &lt;* USEDIN(pd,'SMCH_PLUS_203_SCHEMA.' +'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| (SIZEOF(USEDIN(pdr,'SMCH_PLUS_203_SCHEMA.PROPERTY_DEFINITION.' + 'DEFINITION')) &gt;=1))) &gt;= 1) AND (NOT ('SMCH_PLUS_203_SCHEMA.DESIGN_CONTEXT' IN TYPEOF(pd.frame_of_reference)))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="dimensionality_is_two_or_three"
                                      appliesto="geometric_representation_context">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (g &lt;* geometric_representation_context | (NOT ((g. coordinate_space_dimension = 2) OR (g. coordinate_space_dimension = 3))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="document_to_product_definition"
                                      appliesto="cc_design_specification_reference product_definition">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sp &lt;* cc_design_specification_reference | (NOT (((('SMCH_PLUS_203_SCHEMA.DOCUMENT_RELATIONSHIP.' +'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference. assigned_document)) AND (SIZEOF(QUERY (it &lt;* sp.items | (NOT('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(it))))) =0)) OR (NOT (('SMCH_PLUS_203_SCHEMA.DOCUMENT_RELATIONSHIP.' +'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference. assigned_document))))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="drawing_sheet_layout_usage"
                                      appliesto="mapped_item">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dsl &lt;* QUERY (mi &lt;* mapped_item | ('ASSOC_DIM.DRAWING_SHEET_LAYOUT' IN TYPEOF(mi.mapping_source. mapped_representation))) | (NOT (SIZEOF(USEDIN(dsl,'')) = SIZEOF(QUERY (dsr &lt;* USEDIN(dsl,'ASSOC_DIM.' +'REPRESENTATION.ITEMS') | ('ASSOC_DIM.DRAWING_SHEET_REVISION' IN TYPEOF(dsr)))))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="effectivity_requires_approval"
                                      appliesto="effectivity cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (eff &lt;* effectivity | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (eff IN ccda.items))) =1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="geometric_representation_item_3d"
                                      appliesto="geometric_representation_item">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (gri &lt;* geometric_representation_item | (NOT ((dimension_of(gri) = 3) OR (SIZEOF(bag_to_set(USEDIN(gri,'')) - bag_to_set(USEDIN(gri,'SMCH_PLUS_203_SCHEMA.DEFINITIONAL_REPRESENTATION.ITEMS'))) = 0)))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="no_shape_for_make_from"
                                      appliesto="design_make_from_relationship">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dmfr &lt;* design_make_from_relationship | (NOT (SIZEOF(QUERY (pd &lt;* USEDIN(dmfr,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION.DEFINITION') | ('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd))))= 0)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="no_shape_for_supplied_part"
                                      appliesto="supplied_part_relationship">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (spr &lt;* supplied_part_relationship | (NOT (SIZEOF(QUERY (pd &lt;* USEDIN(spr,'SMCH_PLUS_203_SCHEMA.' +'PROPERTY_DEFINITION.DEFINITION') | ('SMCH_PLUS_203_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd))))= 0)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_concept_requires_configuration_item"
                                      appliesto="product_concept configuration_item">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pc &lt;* product_concept | (NOT (SIZEOF(QUERY (ci &lt;* configuration_item | (pc :=: ci.item_concept)))&gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_definition_requires_approval"
                                      appliesto="product_definition cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pd &lt;* product_definition | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (pd IN ccda.items))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_definition_requires_date_time"
                                      appliesto="product_definition cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pd &lt;* product_definition | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | (pd IN ccdta.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_definition_requires_person_organization"
                                      appliesto="product_definition cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pd &lt;* product_definition | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment| (pd IN ccdpoa.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_requires_person_organization"
                                      appliesto="product cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (prod &lt;* product | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | (prod IN ccdpoa.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_requires_product_category"
                                      appliesto="product product_related_product_category">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (prod &lt;* product | (NOT (SIZEOF(QUERY (prpc &lt;* product_related_product_category | ((prod IN prpc.products) AND (prpc.name IN ['assembly','inseparable_assembly','detail','customer_furnished_equipment'])))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_requires_version"
                                      appliesto="product product_definition_formation">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (prod &lt;* product | (NOT (SIZEOF(QUERY (pdf &lt;* product_definition_formation | (prod :=: pdf.of_product))) &gt;=1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_version_requires_approval"
                                      appliesto="product_definition_formation cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pdf &lt;* product_definition_formation | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (pdf IN ccda.items)))= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_version_requires_person_organization"
                                      appliesto="product_definition_formation cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pdf &lt;* product_definition_formation | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator')))) = 1)))) = 0)">
                                      </where>
                                      <where
                                        label="wr2"
                                        expression="(SIZEOF(QUERY (pdf &lt;* product_definition_formation | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name IN ['design_supplier','part_supplier'])))) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="product_version_requires_security_classification"
                                      appliesto="product_definition_formation cc_design_security_classification">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pdf &lt;* product_definition_formation | (NOT (SIZEOF(QUERY (ccdsc &lt;* cc_design_security_classification | (pdf IN ccdsc.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_action_request_status"
                                      appliesto="action_request_status">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ars &lt;* action_request_status | (NOT (ars.status IN ['proposed','in_work','issued','hold'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_approval_status"
                                      appliesto="approval_status">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ast &lt;* approval_status | (NOT (ast.name IN ['approved','not_yet_approved','disapproved','withdrawn']))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_certification_type"
                                      appliesto="certification_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ct &lt;* certification_type | (NOT (ct.description IN ['design_supplier','part_supplier'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_contract_type"
                                      appliesto="contract_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ct &lt;* contract_type | (NOT (ct.description IN ['fixed_price','cost_plus'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_date_time_role"
                                      appliesto="date_time_role">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dtr &lt;* date_time_role | (NOT (dtr.name IN ['creation_date','request_date','release_date','start_date','contract_date','certification_date','sign_off_date','classification_date','declassification_date'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_document_type"
                                      appliesto="document_type">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dt &lt;* document_type | (NOT (dt.product_data_type IN ['material_specification','process_specification','design_specification','surface_finish_specification','cad_filename','drawing'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_drawing"
                                      appliesto="drawing_revision">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | ((SIZEOF(dr.areas) = 0) OR (SIZEOF(QUERY (ais &lt;* dr.areas | (NOT ('ASSOC_DIM.DRAWING_SHEET_REVISION' IN TYPEOF(ais.area))))) &gt;0)))) = 0)">
                                      </where>
                                      <where
                                        label="wr2"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(USEDIN(dr,'ASSOC_DIM.' + 'DRAUGHTING_TITLE.ITEMS')) &gt; 1))) = 0)">
                                      </where>
                                      <where
                                        label="wr3"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(USEDIN(ais.area,'ASSOC_DIM.' +'DRAUGHTING_TITLE.ITEMS')) &gt; 1))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr4"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (item &lt;* ais.area.items | (SIZEOF(TYPEOF(item) * ['ASSOC_DIM.STYLED_ITEM','ASSOC_DIM.MAPPED_ITEM','ASSOC_DIM.AXIS2_PLACEMENT','ASSOC_DIM.PLANAR_BOX']) &lt;&gt; 1))) &gt; 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr5"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (item &lt;* ais.area.items | (SIZEOF(TYPEOF(item) * ['ASSOC_DIM.STYLED_ITEM','ASSOC_DIM.MAPPED_ITEM']) = 0))) &gt; 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr6"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (p_b &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.PLANAR_BOX' IN TYPEOF(item))) | (SIZEOF(USEDIN(p_b,'ASSOC_DIM.' + 'PRESENTATION_SIZE.SIZE')) &lt;&gt; 1)))&gt; 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr7"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | ('ASSOC_DIM.PRESENTATION_VIEW' IN TYPEOF(mi\mapped_item. mapping_source.mapped_representation)))) = 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr8"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (a2p &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.AXIS2_PLACEMENT' IN TYPEOF(item))) | (SIZEOF(USEDIN(a2p,'ASSOC_DIM.' + 'MAPPED_ITEM.MAPPING_TARGET'))= 0))) &gt; 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr9"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(ais.area.context_of_items. representations_in_context) &gt; 1))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr10"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | (SIZEOF(USEDIN(mi\mapped_item.mapping_source. mapped_representation,'ASSOC_DIM.' +'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) &lt;&gt; 1))) &gt; 0)))&gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr11"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | (SIZEOF(QUERY (pv_item &lt;* mi\mapped_item.mapping_source. mapped_representation.items | (SIZEOF(TYPEOF(pv_item) * ['ASSOC_DIM.STYLED_ITEM','ASSOC_DIM.CAMERA_IMAGE','ASSOC_DIM.AXIS2_PLACEMENT']) &lt;&gt; 1))) &gt; 0))) &gt; 0))) &gt; 0)))= 0)">
                                      </where>
                                      <where
                                        label="wr12"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | (SIZEOF(QUERY (a2p &lt;* QUERY (pv_item &lt;* mi\mapped_item. mapping_source.mapped_representation.items | ('ASSOC_DIM.AXIS2_PLACEMENT' IN TYPEOF(pv_item))) | (SIZEOF(QUERY (rm &lt;* USEDIN(a2p,'ASSOC_DIM.' +'REPRESENTATION_MAP.MAPPING_ORIGIN') | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area.items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | (mi\mapped_item.mapping_source :=: rm))) &gt;0))) = 1))) &lt;&gt; 1))) &gt; 0))) &gt; 0))) = 0)">
                                      </where>
                                      <where
                                        label="wr13"
                                        expression="(SIZEOF(QUERY (dr &lt;* drawing_revision | (SIZEOF(QUERY (ais &lt;* dr.areas | (SIZEOF(QUERY (mi &lt;* QUERY (item &lt;* ais.area. items | ('ASSOC_DIM.MAPPED_ITEM' IN TYPEOF(item))) | (SIZEOF(mi\mapped_item.mapping_source.mapped_representation. context_of_items.representations_in_context) &lt;&gt; 1))) &gt; 0)))&gt; 0))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_person_organization_role"
                                      appliesto="person_and_organization_role">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (por &lt;* person_and_organization_role | (NOT (por. name IN ['request_recipient','initiator','part_supplier','design_supplier','configuration_manager','contractor','classification_officer','creator','design_owner'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_product_category_value"
                                      appliesto="product_related_product_category">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (prpc &lt;* product_related_product_category | (NOT (prpc.name IN ['assembly','detail','customer_furnished_equipment','inseparable_assembly','cast','coined','drawn','extruded','forged','formed','machined','molded','rolled','sheared'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="restrict_security_classification_level"
                                      appliesto="security_classification_level">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (scl &lt;* security_classification_level | (NOT (scl. name IN ['unclassified','classified','proprietary','confidential','secret','top_secret'])))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="security_classification_optional_date_time"
                                      appliesto="security_classification cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sc &lt;* security_classification | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | ((sc IN ccdta.items) AND ('declassification_date' = ccdta.role.name))))&lt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="security_classification_requires_approval"
                                      appliesto="security_classification cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sc &lt;* security_classification | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (sc IN ccda.items))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="security_classification_requires_date_time"
                                      appliesto="security_classification cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sc &lt;* security_classification | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | ((sc IN ccdta.items) AND ('classification_date' = ccdta.role.name))))= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="security_classification_requires_person_organization"
                                      appliesto="security_classification cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sc &lt;* security_classification | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment| (sc IN ccdpoa.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="sheets_belong_to_one_drawing"
                                      appliesto="drawing_sheet_revision drawing_sheet_revision_usage">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (dsr &lt;* drawing_sheet_revision | (NOT (SIZEOF(QUERY (usage &lt;* drawing_sheet_revision_usage | (dsr :=: usage.area))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="start_request_requires_approval"
                                      appliesto="start_request cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sr &lt;* start_request | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (sr IN ccda.items))) = 1))))= 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="start_request_requires_date_time"
                                      appliesto="start_request cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sr &lt;* start_request | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | (sr IN ccdta.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="start_request_requires_person_organization"
                                      appliesto="start_request cc_design_person_and_organization_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sr &lt;* start_request | (NOT (SIZEOF(QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment| (sr IN ccdpoa.items))) &gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="start_work_requires_approval"
                                      appliesto="start_work cc_design_approval">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sw &lt;* start_work | (NOT (SIZEOF(QUERY (ccda &lt;* cc_design_approval | (sw IN ccda.items))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="start_work_requires_date_time"
                                      appliesto="start_work cc_design_date_and_time_assignment">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (sw &lt;* start_work | (NOT (SIZEOF(QUERY (ccdta &lt;* cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND(ccdta.role.name = 'start_date')))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_action"
                                      appliesto="action">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (act &lt;* action | (NOT ('SMCH_PLUS_203_SCHEMA.DIRECTED_ACTION' IN TYPEOF(act))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_effectivity"
                                      appliesto="effectivity">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (eff &lt;* effectivity | (NOT ((SIZEOF(['SMCH_PLUS_203_SCHEMA.SERIAL_NUMBERED_EFFECTIVITY','SMCH_PLUS_203_SCHEMA.LOT_EFFECTIVITY','SMCH_PLUS_203_SCHEMA.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1) AND ('SMCH_PLUS_203_SCHEMA.CONFIGURATION_EFFECTIVITY' IN TYPEOF(eff)))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_product_context"
                                      appliesto="product_context">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pc &lt;* product_context | (NOT ('SMCH_PLUS_203_SCHEMA.MECHANICAL_CONTEXT' IN TYPEOF(pc))))) =0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_product_definition_formation"
                                      appliesto="product_definition_formation">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pdf &lt;* product_definition_formation | (NOT (('SMCH_PLUS_203_SCHEMA.' +'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN TYPEOF(pdf))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_product_definition_usage"
                                      appliesto="product_definition_usage">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (pdu &lt;* product_definition_usage | (NOT (('SMCH_PLUS_203_SCHEMA.' + 'ASSEMBLY_COMPONENT_USAGE') IN TYPEOF(pdu))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="subtype_mandatory_representation_context"
                                      appliesto="representation_context">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (rep_cntxt &lt;* representation_context | (NOT ('SMCH_PLUS_203_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(rep_cntxt))))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="unique_version_change_order_rule"
                                      appliesto="change">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (c &lt;* change | (NOT unique_version_change_order(c. assigned_action)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="versioned_action_request_requires_solution"
                                      appliesto="versioned_action_request action_request_solution">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ar &lt;* versioned_action_request | (NOT (SIZEOF(QUERY (ars &lt;* action_request_solution | (ar :=: ars.request)))&gt;= 1)))) = 0)">
                                      </where>
                                    </rule>

                                    <rule
                                      name="versioned_action_request_requires_status"
                                      appliesto="versioned_action_request action_request_status">
                                      <where
                                        label="wr1"
                                        expression="(SIZEOF(QUERY (ar &lt;* versioned_action_request | (NOT (SIZEOF(QUERY (ars &lt;* action_request_status | (ar :=: ars. assigned_request))) = 1)))) = 0)">
                                      </where>
                                    </rule>

                                  </schema>
                                </express>
