<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-02-08T19:10:43" rcs.revision="1.0" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="config_control_design schema_instance"/>
   <schema name="config_control_design">
      <constant name="dummy_gri" expression="representation_item('') ||&#10;                 geometric_representation_item()">
         <typename name="geometric_representation_item"/>
      </constant>
      <constant name="dummy_tri" expression="representation_item('')&#10;                 || topological_representation_item()">
         <typename name="topological_representation_item"/>
      </constant>
      <type name="ahead_or_behind">
         <enumeration items="ahead behind"/>
      </type>
      <type name="approved_item">
         <select selectitems="product_definition_formation product_definition configuration_effectivity configuration_item security_classification change_request change start_request start_work certification contract"/>
      </type>
      <type name="area_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="boolean_operand">
         <select selectitems="solid_model"/>
      </type>
      <type name="certified_item">
         <select selectitems="supplied_part_relationship"/>
      </type>
      <type name="change_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="characterized_definition">
         <select selectitems="characterized_product_definition shape_definition"/>
      </type>
      <type name="characterized_product_definition">
         <select selectitems="product_definition product_definition_relationship"/>
      </type>
      <type name="classified_item">
         <select selectitems="product_definition_formation assembly_component_usage"/>
      </type>
      <type name="context_dependent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="contracted_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="count_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="date_time_item">
         <select selectitems="product_definition change_request start_request change start_work approval_person_organization contract security_classification certification"/>
      </type>
      <type name="date_time_select">
         <select selectitems="date local_time date_and_time"/>
      </type>
      <type name="day_in_month_number">
         <builtintype type="INTEGER"/>
      </type>
      <type name="day_in_week_number">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="((1 &lt;= SELF) AND (SELF &lt;= 7))"/>
      </type>
      <type name="day_in_year_number">
         <builtintype type="INTEGER"/>
      </type>
      <type name="descriptive_measure">
         <builtintype type="STRING"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="(SELF &gt; 0)"/>
      </type>
      <type name="founded_item_select">
         <select selectitems="founded_item representation_item"/>
      </type>
      <type name="geometric_set_select">
         <select selectitems="point curve surface"/>
      </type>
      <type name="hour_in_day">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="((0 &lt;= SELF) AND (SELF &lt; 24))"/>
      </type>
      <type name="identifier">
         <builtintype type="STRING"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots unspecified quasi_uniform_knots piecewise_bezier_knots"/>
      </type>
      <type name="label">
         <builtintype type="STRING"/>
      </type>
      <type name="length_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="list_of_reversible_topology_item">
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="mass_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="measure_value">
         <select selectitems="length_measure mass_measure plane_angle_measure solid_angle_measure area_measure volume_measure parameter_value context_dependent_measure descriptive_measure positive_length_measure positive_plane_angle_measure count_measure"/>
      </type>
      <type name="minute_in_hour">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="((0 &lt;= SELF) AND (SELF &lt;= 59))"/>
      </type>
      <type name="month_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="((1 &lt;= SELF) AND (SELF &lt;= 12))"/>
      </type>
      <type name="parameter_value">
         <builtintype type="REAL"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="person_organization_item">
         <select selectitems="change start_work change_request start_request configuration_item product product_definition_formation product_definition contract security_classification"/>
      </type>
      <type name="person_organization_select">
         <select selectitems="person organization person_and_organization"/>
      </type>
      <type name="plane_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="positive_length_measure">
         <typename name="length_measure"/>
         <where label="wr1" expression="(SELF &gt; 0)"/>
      </type>
      <type name="positive_plane_angle_measure">
         <typename name="plane_angle_measure"/>
         <where label="wr1" expression="(SELF &gt; 0)"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="reversible_topology">
         <select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item"/>
      </type>
      <type name="reversible_topology_item">
         <select selectitems="edge path face face_bound closed_shell open_shell"/>
      </type>
      <type name="second_in_minute">
         <builtintype type="REAL"/>
         <where label="wr1" expression="((0 &lt;= SELF) AND (SELF &lt; 60))"/>
      </type>
      <type name="set_of_reversible_topology_item">
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="shape_definition">
         <select selectitems="product_definition_shape shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="shell">
         <select selectitems="vertex_shell wire_shell open_shell closed_shell"/>
      </type>
      <type name="si_prefix">
         <enumeration items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto"/>
      </type>
      <type name="si_unit_name">
         <enumeration items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_celsius lumen lux becquerel gray sievert"/>
      </type>
      <type name="solid_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="source">
         <enumeration items="made bought not_known"/>
      </type>
      <type name="specified_item">
         <select selectitems="product_definition shape_aspect"/>
      </type>
      <type name="start_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="supported_item">
         <select selectitems="action_directive action action_method"/>
      </type>
      <type name="surface_model">
         <select selectitems="shell_based_surface_model"/>
      </type>
      <type name="text">
         <builtintype type="STRING"/>
      </type>
      <type name="transformation">
         <select selectitems="item_defined_transformation functionally_defined_transformation"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="unit">
         <select selectitems="named_unit"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      <type name="volume_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="week_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="wr1" expression="((1 &lt;= SELF) AND (SELF &lt;= 53))"/>
      </type>
      <type name="wireframe_model">
         <select selectitems="shell_based_wireframe_model edge_based_wireframe_model"/>
      </type>
      <type name="work_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="year_number">
         <builtintype type="INTEGER"/>
      </type>
      <entity name="action">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="chosen_method">
            <typename name="action_method"/>
         </explicit>
      </entity>
      <entity name="action_assignment" abstract.supertype="YES">
         <explicit name="assigned_action">
            <typename name="action"/>
         </explicit>
      </entity>
      <entity name="action_directive">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="analysis">
            <typename name="text"/>
         </explicit>
         <explicit name="comment">
            <typename name="text"/>
         </explicit>
         <explicit name="requests">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_method">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="consequence">
            <typename name="text"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_request_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_request_solution">
         <explicit name="method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_request_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_action">
            <typename name="executed_action"/>
         </explicit>
      </entity>
      <entity name="address">
         <explicit name="internal_location" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_box" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="town" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="region" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_code" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="country" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="facsimile_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telephone_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="electronic_mail_address" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telex_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <where label="wr1" expression="(EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(&#10;               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(&#10;               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(&#10;               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(&#10;               electronic_mail_address) OR EXISTS(telex_number))"/>
      </entity>
      <entity name="advanced_brep_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',&#10;               'CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;               1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) &gt;&#10;                0)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )&#10;                | (NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(msb) | (NOT (&#10;               SIZEOF(QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces | (&#10;               NOT ('CONFIG_CONTROL_DESIGN.ADVANCED_FACE'&#10;               IN TYPEOF(fcs))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )&#10;                | ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(&#10;               msb\manifold_solid_brep.outer)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( brv &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( csh &lt;* brv\brep_with_voids.voids | csh\&#10;               oriented_closed_shell.orientation )) = 0)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT&#10;               ('CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION'&#10;               IN TYPEOF(mi\mapped_item.mapping_source.&#10;               mapped_representation))) )) = 0)"/>
      </entity>
      <entity name="advanced_face" supertypes="face_surface">
         <where label="wr1" expression="(SIZEOF(['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF(&#10;                face_geometry)) = 1)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound\path.&#10;                edge_list | (NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN&#10;                TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound\path.&#10;                edge_list | (NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',&#10;                'CONFIG_CONTROL_DESIGN.CONIC',&#10;                'CONFIG_CONTROL_DESIGN.POLYLINE',&#10;                'CONFIG_CONTROL_DESIGN.SURFACE_CURVE',&#10;                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF(oe.&#10;                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =&#10;                 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound\path.&#10;                edge_list | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;                TYPEOF(oe\edge.edge_start)) AND (&#10;                'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe\edge.&#10;                edge_start\vertex_point.vertex_geometry)) AND (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe\edge.&#10;                edge_end)) AND ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN&#10;                TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))) ))&#10;                = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(&#10;                elp_fbnds.bound)) )) = 0)"/>
         <where label="wr6" expression="((NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(&#10;                face_geometry))) OR (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',&#10;                'CONFIG_CONTROL_DESIGN.CONIC',&#10;                'CONFIG_CONTROL_DESIGN.POLYLINE',&#10;                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF(&#10;                face_geometry\swept_surface.swept_curve)) = 1))"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( vlp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'&#10;                IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(&#10;                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (&#10;                'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds&#10;                \face_bound.bound\vertex_loop.loop_vertex\vertex_point.&#10;                vertex_geometry)))) )) = 0)"/>
         <where label="wr8" expression="(SIZEOF(QUERY ( bnd &lt;* bounds | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP',&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF(bnd.bound)) =&#10;                 1)) )) = 0)"/>
         <where label="wr9" expression="(SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds.bound\path.&#10;                edge_list | (('CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN&#10;                TYPEOF(oe\oriented_edge.edge_element\edge_curve.&#10;                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag &lt;* oe.&#10;                edge_element\edge_curve.edge_geometry\surface_curve.&#10;                associated_geometry | (NOT ('CONFIG_CONTROL_DESIGN.PCURVE'&#10;                IN TYPEOF(sc_ag))) )) = 0))) )) = 0)) )) = 0)"/>
         <where label="wr10" expression="(((NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(&#10;                face_geometry))) OR (NOT ('CONFIG_CONTROL_DESIGN.POLYLINE'&#10;                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (&#10;                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.&#10;                points) &gt;= 3)) AND (SIZEOF(QUERY ( elp_fbnds &lt;*&#10;                QUERY ( bnds &lt;* bounds | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP'&#10;                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe &lt;*&#10;                elp_fbnds.bound\path.edge_list | ((&#10;                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(oe\oriented_edge&#10;                .edge_element\edge_curve.edge_geometry)) AND (NOT (SIZEOF(&#10;                oe\oriented_edge.edge_element\edge_curve.edge_geometry\&#10;                polyline.points) &gt;= 3))) )) = 0)) )) = 0))"/>
      </entity>
      <entity name="alternate_product_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition">
            <typename name="text"/>
         </explicit>
         <explicit name="alternate">
            <typename name="product"/>
         </explicit>
         <explicit name="base">
            <typename name="product"/>
         </explicit>
         <explicit name="basis">
            <typename name="text"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="alternate_product_relationship" attribute="alternate"/>
            <unique.attribute entity-ref="alternate_product_relationship" attribute="base"/>
         </unique>
         <where label="wr1" expression="(alternate :&lt;&gt;: base)"/>
      </entity>
      <entity name="application_context">
         <explicit name="application">
            <typename name="text"/>
         </explicit>
         <inverse name="context_elements" entity="application_context_element" attribute="frame_of_reference">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="application_context_element" super.expression="ONEOF (product_context, product_definition_context, product_concept_context)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_protocol_definition">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="application_interpreted_model_schema_name">
            <typename name="label"/>
         </explicit>
         <explicit name="application_protocol_year">
            <typename name="year_number"/>
         </explicit>
         <explicit name="application">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="approval">
         <explicit name="status">
            <typename name="approval_status"/>
         </explicit>
         <explicit name="level">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_assignment" abstract.supertype="YES">
         <explicit name="assigned_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_date_time">
         <explicit name="date_time">
            <typename name="date_time_select"/>
         </explicit>
         <explicit name="dated_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_person_organization">
         <explicit name="person_organization">
            <typename name="person_organization_select"/>
         </explicit>
         <explicit name="authorized_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="role">
            <typename name="approval_role"/>
         </explicit>
      </entity>
      <entity name="approval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="related_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_role">
         <explicit name="role">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_status">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="area_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.AREA_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="area_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="assembly_component_usage" supertypes="product_definition_usage" super.expression="ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence)">
         <explicit name="reference_designator" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="assembly_component_usage_substitute">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition">
            <typename name="text"/>
         </explicit>
         <explicit name="base">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="substitute">
            <typename name="assembly_component_usage"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="assembly_component_usage_substitute" attribute="base"/>
            <unique.attribute entity-ref="assembly_component_usage_substitute" attribute="substitute"/>
         </unique>
         <where label="wr1" expression="(base.relating_product_definition :=: substitute.&#10;               relating_product_definition)"/>
         <where label="wr2" expression="(base :&lt;&gt;: substitute)"/>
      </entity>
      <entity name="axis1_placement" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="z" expression="NVL(normalise(axis),dummy_gri ||&#10;             direction([0,0,1]))">
            <typename name="direction"/>
         </derived>
         <where label="wr1" expression="(SELF\geometric_representation_item.dim = 3)"/>
      </entity>
      <entity name="axis2_placement_2d" supertypes="placement">
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_2axes(ref_direction)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="wr1" expression="(SELF\geometric_representation_item.dim = 2)"/>
      </entity>
      <entity name="axis2_placement_3d" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_axes(axis,ref_direction)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="wr1" expression="(SELF\placement.location.dim = 3)"/>
         <where label="wr2" expression="((NOT EXISTS(axis)) OR (axis.dim = 3))"/>
         <where label="wr3" expression="((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3))"/>
         <where label="wr4" expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (&#10;               cross_product(axis,ref_direction).magnitude &gt; 0))"/>
      </entity>
      <entity name="b_spline_curve" supertypes="bounded_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve">
         <explicit name="degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="curve_form">
            <typename name="b_spline_curve_form"/>
         </explicit>
         <explicit name="closed_curve">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="upper_index_on_control_points" expression="SIZEOF(&#10;                                         control_points_list) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="list_to_array(&#10;                                         control_points_list,0,&#10;                                         upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="wr1" expression="(('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (&#10;               'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF))&#10;               OR ('CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF)) OR&#10;                ('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN&#10;               TYPEOF(SELF)))"/>
      </entity>
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
         <explicit name="knot_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="upper_index_on_knots" expression="SIZEOF(knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="wr1" expression="constraints_param_b_spline(degree,upper_index_on_knots,&#10;               upper_index_on_control_points,knot_multiplicities,knots)"/>
         <where label="wr2" expression="(SIZEOF(knot_multiplicities) = upper_index_on_knots)"/>
      </entity>
      <entity name="b_spline_surface" supertypes="bounded_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="surface_form">
            <typename name="b_spline_surface_form"/>
         </explicit>
         <explicit name="u_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="v_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="u_upper" expression="SIZEOF(control_points_list) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="v_upper" expression="SIZEOF(control_points_list[1]) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="make_array_of_array(&#10;                          control_points_list,0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="wr1" expression="(('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR (&#10;               'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN&#10;               TYPEOF(SELF))&#10;               OR ('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF))&#10;               OR ('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN&#10;               TYPEOF(SELF)))"/>
      </entity>
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
         <explicit name="u_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="knot_u_upper" expression="SIZEOF(u_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_v_upper" expression="SIZEOF(v_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="wr1" expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,&#10;               u_knots)"/>
         <where label="wr2" expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,&#10;               v_knots)"/>
         <where label="wr3" expression="(SIZEOF(u_multiplicities) = knot_u_upper)"/>
         <where label="wr4" expression="(SIZEOF(v_multiplicities) = knot_v_upper)"/>
      </entity>
      <entity name="bezier_curve" supertypes="b_spline_curve"/>
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
         <where label="wr1" expression="SELF\composite_curve.closed_curve"/>
      </entity>
      <entity name="bounded_curve" supertypes="curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve)"/>
      <entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.&#10;               reference_to_curve.items[1]))"/>
      </entity>
      <entity name="bounded_surface" supertypes="surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)"/>
      <entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\&#10;               surface_curve.curve_3d))"/>
      </entity>
      <entity name="brep_with_voids" supertypes="manifold_solid_brep">
         <explicit name="voids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="oriented_closed_shell"/>
         </explicit>
      </entity>
      <entity name="calendar_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_month_number"/>
         </explicit>
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
         <where label="wr1" expression="valid_calendar_date(SELF)"/>
      </entity>
      <entity name="cartesian_point" supertypes="point">
         <explicit name="coordinates">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="cartesian_transformation_operator" supertypes="geometric_representation_item functionally_defined_transformation" super.expression="cartesian_transformation_operator_3d">
         <explicit name="axis1" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="axis2" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="local_origin">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="scale" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived name="scl" expression="NVL(scale,1)">
            <builtintype type="REAL"/>
         </derived>
         <where label="wr1" expression="(scl &gt; 0)"/>
      </entity>
      <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
         <explicit name="axis3" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="u" expression="base_axis(3,SELF\&#10;             cartesian_transformation_operator.axis1,SELF\&#10;             cartesian_transformation_operator.axis2,axis3)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="wr1" expression="(SELF\geometric_representation_item.dim = 3)"/>
      </entity>
      <entity name="cc_design_approval" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="approved_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_certification" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="certified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_contract" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="contracted_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_time_item"/>
         </explicit>
         <where label="wr1" expression="cc_design_date_time_correlation(SELF)"/>
      </entity>
      <entity name="cc_design_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person_organization_item"/>
         </explicit>
         <where label="wr1" expression="cc_design_person_and_organization_correlation(SELF)"/>
      </entity>
      <entity name="cc_design_security_classification" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="classified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_specification_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="specified_item"/>
         </explicit>
      </entity>
      <entity name="certification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="certification_type"/>
         </explicit>
      </entity>
      <entity name="certification_assignment" abstract.supertype="YES">
         <explicit name="assigned_certification">
            <typename name="certification"/>
         </explicit>
      </entity>
      <entity name="certification_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="change" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="change_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="change_request_item"/>
         </explicit>
      </entity>
      <entity name="circle" supertypes="conic">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="closed_shell" supertypes="connected_face_set"/>
      <entity name="composite_curve" supertypes="bounded_curve">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="composite_curve_segment"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="n_segments" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="closed_curve" expression="segments[n_segments].transition &lt;&gt;&#10;                        discontinuous">
            <builtintype type="LOGICAL"/>
         </derived>
         <where label="wr1" expression="(((NOT closed_curve) AND (SIZEOF(QUERY ( temp &lt;* segments | (&#10;               temp.transition = discontinuous) )) = 1)) OR (closed_curve&#10;               AND (SIZEOF(QUERY ( temp &lt;* segments | (temp.transition =&#10;               discontinuous) )) = 0)))"/>
      </entity>
      <entity name="composite_curve_on_surface" supertypes="composite_curve" super.expression="boundary_curve">
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="0" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="wr1" expression="(SIZEOF(basis_surface) &gt; 0)"/>
         <where label="wr2" expression="constraints_composite_curve_on_surface(SELF)"/>
      </entity>
      <entity name="composite_curve_segment" supertypes="founded_item">
         <explicit name="transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <inverse name="using_curves" entity="composite_curve" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve))"/>
      </entity>
      <entity name="configuration_design">
         <explicit name="configuration">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="design">
            <typename name="product_definition_formation"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="configuration_design" attribute="configuration"/>
            <unique.attribute entity-ref="configuration_design" attribute="design"/>
         </unique>
      </entity>
      <entity name="configuration_effectivity" supertypes="product_definition_effectivity">
         <explicit name="configuration">
            <typename name="configuration_design"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="configuration_effectivity" attribute="configuration"/>
            <unique.attribute entity-ref="configuration_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="configuration_effectivity" attribute="id"/>
         </unique>
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF(&#10;               SELF\product_definition_effectivity.usage))"/>
      </entity>
      <entity name="configuration_item">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="item_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="purpose" optional="YES">
            <typename name="label"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="configuration_item" attribute="id"/>
         </unique>
      </entity>
      <entity name="conic" supertypes="curve" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="conical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where label="wr1" expression="(radius &gt;= 0)"/>
      </entity>
      <entity name="connected_edge_set" supertypes="topological_representation_item">
         <explicit name="ces_edges">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="connected_face_set" supertypes="topological_representation_item" super.expression="ONEOF (closed_shell, open_shell)">
         <explicit name="cfs_faces">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
         </explicit>
      </entity>
      <entity name="context_dependent_shape_representation">
         <explicit name="representation_relation">
            <typename name="shape_representation_relationship"/>
         </explicit>
         <explicit name="represented_product_relation">
            <typename name="product_definition_shape"/>
         </explicit>
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN&#10;               TYPEOF(SELF.represented_product_relation.definition))"/>
      </entity>
      <entity name="context_dependent_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="contract">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="contract_type"/>
         </explicit>
      </entity>
      <entity name="contract_assignment" abstract.supertype="YES">
         <explicit name="assigned_contract">
            <typename name="contract"/>
         </explicit>
      </entity>
      <entity name="contract_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="conversion_based_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="conversion_factor">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="coordinated_universal_time_offset">
         <explicit name="hour_offset">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_offset" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="sense">
            <typename name="ahead_or_behind"/>
         </explicit>
      </entity>
      <entity name="curve" supertypes="geometric_representation_item" super.expression="ONEOF (line, conic, pcurve, surface_curve, offset_curve_3d, curve_replica)"/>
      <entity name="curve_bounded_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="boundary_curve"/>
         </explicit>
         <explicit name="implicit_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="wr1" expression="(NOT (implicit_outer AND (&#10;               'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(&#10;               boundaries))))"/>
         <where label="wr2" expression="((NOT implicit_outer) OR (&#10;               'CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN TYPEOF(&#10;               basis_surface)))"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( temp &lt;* boundaries | (&#10;               'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE'&#10;               IN TYPEOF(temp)) )) &lt;= 1)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( temp &lt;* boundaries | (temp\&#10;               composite_curve_on_surface.basis_surface[1] &lt;&gt; SELF.&#10;               basis_surface) )) = 0)"/>
      </entity>
      <entity name="curve_replica" supertypes="curve">
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="wr1" expression="(transformation.dim = parent_curve.dim)"/>
         <where label="wr2" expression="acyclic_curve_replica(SELF,parent_curve)"/>
      </entity>
      <entity name="cylindrical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="date" super.expression="ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date)">
         <explicit name="year_component">
            <typename name="year_number"/>
         </explicit>
      </entity>
      <entity name="date_and_time">
         <explicit name="date_component">
            <typename name="date"/>
         </explicit>
         <explicit name="time_component">
            <typename name="local_time"/>
         </explicit>
      </entity>
      <entity name="date_and_time_assignment" abstract.supertype="YES">
         <explicit name="assigned_date_and_time">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="role">
            <typename name="date_time_role"/>
         </explicit>
      </entity>
      <entity name="date_time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="dated_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_date">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="effectivity_end_date" optional="YES">
            <typename name="date_and_time"/>
         </explicit>
      </entity>
      <entity name="definitional_representation" supertypes="representation">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;               TYPEOF(SELF\representation.context_of_items))"/>
      </entity>
      <entity name="degenerate_pcurve" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="wr1" expression="(SIZEOF(reference_to_curve\representation.items) = 1)"/>
         <where label="wr2" expression="('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(reference_to_curve\&#10;               representation.items[1]))"/>
         <where label="wr3" expression="(reference_to_curve\representation.items[1]\&#10;               geometric_representation_item.dim = 2)"/>
      </entity>
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
         <explicit name="select_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="wr1" expression="(major_radius &lt; minor_radius)"/>
      </entity>
      <entity name="design_context" supertypes="product_definition_context">
         <where label="wr1" expression="(SELF.life_cycle_stage = 'design')"/>
      </entity>
      <entity name="design_make_from_relationship" supertypes="product_definition_relationship"/>
      <entity name="dimensional_exponents">
         <explicit name="length_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="mass_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="time_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="electric_current_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="thermodynamic_temperature_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="amount_of_substance_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="luminous_intensity_exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="directed_action" supertypes="executed_action">
         <explicit name="directive">
            <typename name="action_directive"/>
         </explicit>
      </entity>
      <entity name="direction" supertypes="geometric_representation_item">
         <explicit name="direction_ratios">
            <aggregate type="LIST" lower="2" upper="3"/>
            <builtintype type="REAL"/>
         </explicit>
         <where label="wr1" expression="(SIZEOF(QUERY ( tmp &lt;* direction_ratios | (tmp &lt;&gt; 0) )) &gt; 0)"/>
      </entity>
      <entity name="document">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="document_type"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="document" attribute="id"/>
         </unique>
      </entity>
      <entity name="document_reference" abstract.supertype="YES">
         <explicit name="assigned_document">
            <typename name="document"/>
         </explicit>
         <explicit name="source">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_type">
         <explicit name="product_data_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint">
         <explicit name="source">
            <typename name="document"/>
         </explicit>
         <explicit name="subject_element">
            <typename name="label"/>
         </explicit>
         <explicit name="subject_element_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="document_with_class" supertypes="document">
         <explicit name="class">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="edge" supertypes="topological_representation_item" super.expression="ONEOF (edge_curve, oriented_edge)">
         <explicit name="edge_start">
            <typename name="vertex"/>
         </explicit>
         <explicit name="edge_end">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="ebwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="connected_edge_set"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;               1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))&#10;               &gt;= 1)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( ebwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN&#10;               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb &lt;* ebwm\&#10;               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(&#10;               QUERY ( edges &lt;* eb.ces_edges | (NOT (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF(edges))) ))&#10;               = 0)) )) = 0)) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( ebwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN&#10;               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb &lt;* ebwm\&#10;               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(&#10;               QUERY ( pline_edges &lt;* QUERY ( edges &lt;* eb.ces_edges | (&#10;               'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(edges\edge_curve.&#10;               edge_geometry)) ) | (NOT (SIZEOF(pline_edges\edge_curve.&#10;               edge_geometry\polyline.points) &gt; 2)) )) = 0)) )) = 0)) )) =&#10;               0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( ebwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN&#10;               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb &lt;* ebwm\&#10;               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(&#10;               QUERY ( edges &lt;* eb.ces_edges | (NOT ((&#10;               'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(edges.&#10;               edge_start)) AND ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;               TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( ebwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN&#10;               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb &lt;* ebwm\&#10;               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(&#10;               QUERY ( edges &lt;* eb.ces_edges | (NOT&#10;               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry))&#10;               )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( ebwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN&#10;               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb &lt;* ebwm\&#10;               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(&#10;               QUERY ( edges &lt;* eb.ces_edges | (NOT (&#10;               valid_wireframe_vertex_point(edges.edge_start\vertex_point.&#10;               vertex_geometry) AND valid_wireframe_vertex_point(edges.&#10;               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0))&#10;               )) = 0)"/>
         <where label="wr8" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT&#10;               (('CONFIG_CONTROL_DESIGN.' +&#10;               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\&#10;               mapped_item.mapping_source.mapped_representation))) )) = 0)"/>
         <where label="wr9" expression="(SELF.context_of_items\geometric_representation_context.&#10;               coordinate_space_dimension = 3)"/>
      </entity>
      <entity name="edge_curve" supertypes="edge geometric_representation_item">
         <explicit name="edge_geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="edge_loop" supertypes="loop path">
         <derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="wr1" expression="(SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].&#10;               edge_end)"/>
      </entity>
      <entity name="effectivity" super.expression="ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="elementary_surface" supertypes="surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="ellipse" supertypes="conic">
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
         <explicit name="equivalent_point">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="executed_action" supertypes="action"/>
      <entity name="face" supertypes="topological_representation_item" super.expression="ONEOF (face_surface, oriented_face)">
         <explicit name="bounds">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
         </explicit>
         <where label="wr1" expression="(NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))))"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( temp &lt;* bounds | (&#10;               'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp)) ))&#10;               &lt;= 1)"/>
      </entity>
      <entity name="face_bound" supertypes="topological_representation_item">
         <explicit name="bound">
            <typename name="loop"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="face_outer_bound" supertypes="face_bound"/>
      <entity name="face_surface" supertypes="face geometric_representation_item">
         <explicit name="face_geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="faceted_brep" supertypes="manifold_solid_brep"/>
      <entity name="faceted_brep_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* items | (NOT (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;               1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* items | (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) &gt;&#10;                0)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( fbrep &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(fbrep) | (NOT (SIZEOF(&#10;               QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces | (NOT ((&#10;               'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF(fcs)) AND (&#10;               'CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF(fcs\face_surface.&#10;               face_geometry)) AND ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT'&#10;               IN TYPEOF(fcs\face_surface.face_geometry\elementary_surface.&#10;               position.location)))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( fbrep &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( csh &lt;* msb_shells(fbrep) | (NOT (SIZEOF(&#10;               QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces | (NOT (&#10;               SIZEOF(QUERY ( bnds &lt;* fcs.bounds | (&#10;               'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds)) ))&#10;               = 1)) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( msb &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )&#10;                | ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(&#10;               msb\manifold_solid_brep.outer)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( brv &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( csh &lt;* brv\brep_with_voids.voids | csh\&#10;               oriented_closed_shell.orientation )) = 0)) )) = 0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* items | (&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT&#10;               ('CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION'&#10;               IN TYPEOF(mi\mapped_item.mapping_source.&#10;               mapped_representation))) )) = 0)"/>
      </entity>
      <entity name="founded_item"/>
      <entity name="functionally_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="geometric_curve_set" supertypes="geometric_set">
         <where label="wr1" expression="(SIZEOF(QUERY ( temp &lt;* SELF\geometric_set.elements | (&#10;               'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(temp)) )) = 0)"/>
      </entity>
      <entity name="geometric_representation_context" supertypes="representation_context">
         <explicit name="coordinate_space_dimension">
            <typename name="dimension_count"/>
         </explicit>
      </entity>
      <entity name="geometric_representation_item" supertypes="representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, shell_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set)">
         <derived name="dim" expression="dimension_of(SELF)">
            <typename name="dimension_count"/>
         </derived>
         <where label="wr1" expression="(SIZEOF(QUERY ( using_rep &lt;* using_representations(SELF) | (&#10;               NOT (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;               TYPEOF(using_rep.context_of_items))) )) = 0)"/>
      </entity>
      <entity name="geometric_set" supertypes="geometric_representation_item" super.expression="geometric_curve_set">
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_set_select"/>
         </explicit>
      </entity>
      <entity name="geometrically_bounded_surface_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;               1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) &gt;&#10;                0)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT&#10;               ((('CONFIG_CONTROL_DESIGN.' +&#10;               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN&#10;               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))&#10;               AND (SIZEOF(QUERY ( mr_it &lt;* mi\mapped_item.mapping_source.&#10;               mapped_representation.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(mr_it)) )) &gt;&#10;                0))) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( gs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( pnt &lt;* QUERY ( gsel &lt;* gs\geometric_set.&#10;               elements | ('CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF(gsel)) )&#10;                | (NOT gbsf_check_point(pnt)) )) = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( gs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( cv &lt;* QUERY ( gsel &lt;* gs\geometric_set.&#10;               elements | ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(gsel)) )&#10;                | (NOT gbsf_check_curve(cv)) )) = 0)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( gs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (&#10;               NOT (SIZEOF(QUERY ( sf &lt;* QUERY ( gsel &lt;* gs\geometric_set.&#10;               elements | ('CONFIG_CONTROL_DESIGN.SURFACE' IN&#10;               TYPEOF(gsel)) ) | (NOT gbsf_check_surface(sf)) ))&#10;               = 0)) )) = 0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( gs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (&#10;               SIZEOF(QUERY ( gsel &lt;* gs\geometric_set.elements | (&#10;               'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(gsel)) )) &gt; 0) ))&#10;               &gt; 0)"/>
      </entity>
      <entity name="geometrically_bounded_wireframe_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF(TYPEOF(it) * [&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF(TYPEOF(it) * [&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1) )) &gt;= 1)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( gcs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )&#10;                | (NOT (SIZEOF(QUERY ( crv &lt;* QUERY ( elem &lt;* gcs\&#10;               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.CURVE' IN&#10;               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_curve(&#10;               crv)) )) = 0)) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( gcs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )&#10;                | (NOT (SIZEOF(QUERY ( pnts &lt;* QUERY ( elem &lt;* gcs\&#10;               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.POINT' IN&#10;               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_point(&#10;               pnts)) )) = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( gcs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )&#10;                | (NOT (SIZEOF(QUERY ( cnc &lt;* QUERY ( elem &lt;* gcs\&#10;               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.CONIC' IN&#10;               TYPEOF(elem)) ) | (NOT (&#10;               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\&#10;               conic.position))) )) = 0)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( gcs &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )&#10;                | (NOT (SIZEOF(QUERY ( pline &lt;* QUERY ( elem &lt;* gcs\&#10;               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.POLYLINE'&#10;               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points)&#10;               &gt; 2)) )) = 0)) )) = 0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (&#10;               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT&#10;               (('CONFIG_CONTROL_DESIGN.' +&#10;               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN&#10;               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)&#10;               )) )) = 0)"/>
      </entity>
      <entity name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="global_unit_assigned_context" supertypes="representation_context">
         <explicit name="units">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="hyperbola" supertypes="conic">
         <explicit name="semi_axis">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_imag_axis">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="intersection_curve" supertypes="surface_curve">
         <where label="wr1" expression="(SIZEOF(SELF\surface_curve.associated_geometry) = 2)"/>
         <where label="wr2" expression="(associated_surface(SELF\surface_curve.associated_geometry[1])&#10;               &lt;&gt; associated_surface(SELF\surface_curve.associated_geometry&#10;               [2]))"/>
      </entity>
      <entity name="item_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="length_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="length_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="line" supertypes="curve">
         <explicit name="pnt">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="dir">
            <typename name="vector"/>
         </explicit>
         <where label="wr1" expression="(dir.dim = pnt.dim)"/>
      </entity>
      <entity name="local_time">
         <explicit name="hour_component">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_component" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="second_component" optional="YES">
            <typename name="second_in_minute"/>
         </explicit>
         <explicit name="zone">
            <typename name="coordinated_universal_time_offset"/>
         </explicit>
         <where label="wr1" expression="valid_time(SELF)"/>
      </entity>
      <entity name="loop" supertypes="topological_representation_item" super.expression="ONEOF (vertex_loop, edge_loop, poly_loop)"/>
      <entity name="lot_effectivity" supertypes="effectivity">
         <explicit name="effectivity_lot_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_lot_size">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="manifold_solid_brep" supertypes="solid_model">
         <explicit name="outer">
            <typename name="closed_shell"/>
         </explicit>
      </entity>
      <entity name="manifold_surface_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;                'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;                 1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))&#10;                &gt; 0)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (&#10;                NOT (('CONFIG_CONTROL_DESIGN.'+&#10;               'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'&#10;                IN TYPEOF(mi\mapped_item.mapping_source.&#10;                mapped_representation)) AND (SIZEOF(QUERY ( mr_it &lt;* mi\&#10;                mapped_item.mapping_source.mapped_representation.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(mr_it)) )) &gt; 0))) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sh &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.OPEN_SHELL',&#10;                'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL',&#10;                'CONFIG_CONTROL_DESIGN.CLOSED_SHELL'] * TYPEOF(sh)) = 1))&#10;                )) = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT (&#10;                SIZEOF(['CONFIG_CONTROL_DESIGN.FACE_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF(fa)) = 1))&#10;                )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( f_sf &lt;* QUERY ( fa &lt;* cfs\connected_face_set.&#10;                cfs_faces | ('CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN&#10;                TYPEOF(fa)) ) | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (&#10;                SIZEOF(['CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.OFFSET_SURFACE',&#10;                'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA',&#10;                'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF(f_sf\&#10;                face_surface.face_geometry)) = 1))) )) = 0)) )) = 0)) )) =&#10;                0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR&#10;                msf_surface_check(fa\face_surface.face_geometry))) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
         <where label="wr8" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( bnds &lt;* fa.bounds | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP',&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF(bnds.bound))&#10;                = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr9" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds\path.edge_list | (&#10;                NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF(oe.&#10;                edge_element))))) = 0)))) = 0))))) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr10" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe_cv &lt;* QUERY ( oe &lt;* elp_fbnds\&#10;                path.edge_list | ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN&#10;                TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',&#10;                'CONFIG_CONTROL_DESIGN.CONIC',&#10;                'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',&#10;                'CONFIG_CONTROL_DESIGN.LINE',&#10;                'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D',&#10;                'CONFIG_CONTROL_DESIGN.PCURVE',&#10;                'CONFIG_CONTROL_DESIGN.POLYLINE',&#10;                'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * TYPEOF(oe_cv.&#10;                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =&#10;                 0))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr11" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds\path.edge_list | (&#10;                NOT msf_curve_check(oe.edge_element\edge_curve.&#10;                edge_geometry)) )) = 0)) )) = 0))) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
         <where label="wr12" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds\path.edge_list | (&#10;                NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe.&#10;                edge_element.edge_start)) AND (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe.&#10;                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) =&#10;                0)) )) = 0)"/>
         <where label="wr13" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( elp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(QUERY ( oe &lt;* elp_fbnds\path.edge_list | (&#10;                NOT ((SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',&#10;                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.&#10;                edge_element.edge_start\vertex_point.vertex_geometry)) = 1)&#10;                AND (SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',&#10;                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.&#10;                edge_element.edge_end\vertex_point.vertex_geometry))&#10;                = 1))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr14" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( vlp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'&#10;                IN TYPEOF(bnds.bound)) )&#10;                 | (NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(&#10;                vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) = 0)) ))&#10;                = 0)) )) = 0)"/>
         <where label="wr15" expression="(SIZEOF(QUERY ( sbsm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs &lt;* sbsm\&#10;                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(&#10;                QUERY ( fa &lt;* cfs\connected_face_set.cfs_faces | (NOT ((&#10;                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (&#10;                SIZEOF(QUERY ( vlp_fbnds &lt;* QUERY ( bnds &lt;* fa.bounds | (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'&#10;                IN TYPEOF(bnds.bound)) )&#10;                 | (NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',&#10;                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',&#10;                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(&#10;                vlp_fbnds\vertex_loop.loop_vertex\vertex_point.&#10;                vertex_geometry)) = 1)) )) = 0))) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
      </entity>
      <entity name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="representation_item"/>
         </explicit>
         <where label="wr1" expression="acyclic_mapped_representation(using_representations(SELF),&#10;           [SELF])"/>
      </entity>
      <entity name="mass_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.MASS_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="mass_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 1) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="measure_with_unit" super.expression="ONEOF (length_measure_with_unit, mass_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit)">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <explicit name="unit_component">
            <typename name="unit"/>
         </explicit>
         <where label="wr1" expression="valid_units(SELF)"/>
      </entity>
      <entity name="mechanical_context" supertypes="product_context">
         <where label="wr1" expression="(SELF.discipline_type = 'mechanical')"/>
      </entity>
      <entity name="named_unit" super.expression="ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit)">
         <explicit name="dimensions">
            <typename name="dimensional_exponents"/>
         </explicit>
      </entity>
      <entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="offset_curve_3d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="ref_direction">
            <typename name="direction"/>
         </explicit>
         <where label="wr1" expression="((basis_curve.dim = 3) AND (ref_direction.dim = 3))"/>
      </entity>
      <entity name="offset_surface" supertypes="surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="open_shell" supertypes="connected_face_set"/>
      <entity name="ordinal_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_year_number"/>
         </explicit>
         <where label="wr1" expression="(((NOT leap_year(SELF.year_component)) AND (1 &lt;= day_component)&#10;               AND (day_component &lt;= 365)) OR (leap_year(SELF.&#10;               year_component) AND (1 &lt;= day_component) AND (day_component&#10;               &lt;= 366)))"/>
      </entity>
      <entity name="organization">
         <explicit name="id" optional="YES">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organization_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="related_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="organizational_address" supertypes="address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_project">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="responsible_organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="oriented_closed_shell" supertypes="closed_shell">
         <explicit name="closed_shell_element">
            <typename name="closed_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.orientation,SELF.&#10;          closed_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(&#10;               SELF.closed_shell_element)))"/>
      </entity>
      <entity name="oriented_edge" supertypes="edge">
         <explicit name="edge_element">
            <typename name="edge"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_start" expression="boolean_choose(SELF.orientation,&#10;                                SELF.edge_element.edge_start,SELF.&#10;                                edge_element.edge_end)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <derived name="edge_end" expression="boolean_choose(SELF.orientation,&#10;                                SELF.edge_element.edge_end,SELF.&#10;                                edge_element.edge_start)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(SELF.&#10;               edge_element)))"/>
      </entity>
      <entity name="oriented_face" supertypes="face">
         <explicit name="face_element">
            <typename name="face"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="bounds" expression="conditional_reverse(&#10;                            SELF.orientation,SELF.face_element.bounds)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
            <redeclaration entity-ref="face"/>
         </derived>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF.&#10;               face_element)))"/>
      </entity>
      <entity name="oriented_open_shell" supertypes="open_shell">
         <explicit name="open_shell_element">
            <typename name="open_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.&#10;                                             orientation,SELF.&#10;                                             open_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(&#10;               SELF.open_shell_element)))"/>
      </entity>
      <entity name="oriented_path" supertypes="path">
         <explicit name="path_element">
            <typename name="path"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_list" expression="conditional_reverse(SELF.orientation,SELF.&#10;                               path_element.edge_list)">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
            <redeclaration entity-ref="path"/>
         </derived>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(SELF.&#10;               path_element)))"/>
      </entity>
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
      <entity name="parabola" supertypes="conic">
         <explicit name="focal_dist">
            <typename name="length_measure"/>
         </explicit>
         <where label="wr1" expression="(focal_dist &lt;&gt; 0)"/>
      </entity>
      <entity name="parametric_representation_context" supertypes="representation_context"/>
      <entity name="path" supertypes="topological_representation_item" super.expression="ONEOF (edge_loop, oriented_path)">
         <explicit name="edge_list">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
         </explicit>
         <where label="wr1" expression="path_head_to_tail(SELF)"/>
      </entity>
      <entity name="pcurve" supertypes="curve">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="wr1" expression="(SIZEOF(reference_to_curve\representation.items) = 1)"/>
         <where label="wr2" expression="('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(reference_to_curve\&#10;               representation.items[1]))"/>
         <where label="wr3" expression="(reference_to_curve\representation.items[1]\&#10;               geometric_representation_item.dim = 2)"/>
      </entity>
      <entity name="person">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="last_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="first_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="middle_names" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="prefix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="suffix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="person" attribute="id"/>
         </unique>
         <where label="wr1" expression="(EXISTS(last_name) OR EXISTS(first_name))"/>
      </entity>
      <entity name="person_and_organization">
         <explicit name="the_person">
            <typename name="person"/>
         </explicit>
         <explicit name="the_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_person_and_organization">
            <typename name="person_and_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="person_and_organization_role"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="personal_address" supertypes="address">
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="placement" supertypes="geometric_representation_item" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)">
         <explicit name="location">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="plane" supertypes="elementary_surface"/>
      <entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="plane_angle_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="point" supertypes="geometric_representation_item" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve)"/>
      <entity name="point_on_curve" supertypes="point">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="point_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_surface" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_replica" supertypes="point">
         <explicit name="parent_pt">
            <typename name="point"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="wr1" expression="(transformation.dim = parent_pt.dim)"/>
         <where label="wr2" expression="acyclic_point_replica(SELF,parent_pt)"/>
      </entity>
      <entity name="poly_loop" supertypes="loop geometric_representation_item">
         <explicit name="polygon">
            <aggregate type="LIST" unique="YES" lower="3" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="polyline" supertypes="bounded_curve">
         <explicit name="points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="product">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_context"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="product" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_category">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_category_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="category">
            <typename name="product_category"/>
         </explicit>
         <explicit name="sub_category">
            <typename name="product_category"/>
         </explicit>
         <where label="wr1" expression="acyclic_product_category_relationship(SELF,[SELF.sub_category])"/>
      </entity>
      <entity name="product_concept">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="market_context">
            <typename name="product_concept_context"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="product_concept" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_concept_context" supertypes="application_context_element">
         <explicit name="market_segment_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_context" supertypes="application_context_element">
         <explicit name="discipline_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
      </entity>
      <entity name="product_definition_context" supertypes="application_context_element">
         <explicit name="life_cycle_stage">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage">
            <typename name="product_definition_relationship"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="product_definition_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="product_definition_effectivity" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product">
            <typename name="product"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="product_definition_formation" attribute="id"/>
            <unique.attribute entity-ref="product_definition_formation" attribute="of_product"/>
         </unique>
      </entity>
      <entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity name="product_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="product_definition_shape" supertypes="property_definition">
         <unique label="ur1">
            <unique.attribute entity-ref="product_definition_shape" attribute="definition"/>
         </unique>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF\&#10;               property_definition.definition)))"/>
      </entity>
      <entity name="product_definition_usage" supertypes="product_definition_relationship" super.expression="assembly_component_usage">
         <unique label="ur1">
            <unique.attribute entity-ref="product_definition_usage" attribute="id"/>
            <unique.attribute entity-ref="product_definition_usage" attribute="relating_product_definition"/>
            <unique.attribute entity-ref="product_definition_usage" attribute="related_product_definition"/>
         </unique>
         <where label="wr1" expression="acyclic_product_definition_relationship(SELF,[SELF\&#10;               product_definition_relationship.related_product_definition],&#10;               'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE')"/>
      </entity>
      <entity name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="product_related_product_category" supertypes="product_category">
         <explicit name="products">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="promissory_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="property_definition">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_definition"/>
         </explicit>
      </entity>
      <entity name="property_definition_representation">
         <explicit name="definition">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="list_to_array(weights_data,0,&#10;                   upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="wr1" expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.&#10;               control_points_list))"/>
         <where label="wr2" expression="curve_weights_positive(SELF)"/>
      </entity>
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="wr1" expression="((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.&#10;               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(&#10;               SELF\b_spline_surface.control_points_list[1])))"/>
         <where label="wr2" expression="surface_weights_positive(SELF)"/>
      </entity>
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="surface_patch"/>
         </explicit>
         <derived name="n_u" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="n_v" expression="SIZEOF(segments[1])">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="wr1" expression="([] = QUERY ( s &lt;* segments | (n_v &lt;&gt; SIZEOF(s)) ))"/>
         <where label="wr2" expression="constraints_rectangular_composite_surface(SELF)"/>
      </entity>
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="usense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vsense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="wr1" expression="(u1 &lt;&gt; u2)"/>
         <where label="wr2" expression="(v1 &lt;&gt; v2)"/>
         <where label="wr3" expression="((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(&#10;               basis_surface)) AND (NOT ('CONFIG_CONTROL_DESIGN.PLANE' IN&#10;               TYPEOF(basis_surface)))) OR (&#10;               'CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF(&#10;               basis_surface)) OR (usense = (u2 &gt; u1)))"/>
         <where label="wr4" expression="(('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN TYPEOF(&#10;               basis_surface)) OR ('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'&#10;               IN TYPEOF(basis_surface)) OR (vsense = (v2 &gt; v1)))"/>
      </entity>
      <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
         <explicit name="param_length">
            <typename name="parameter_value"/>
         </explicit>
         <where label="wr1" expression="(param_length &gt; 0)"/>
      </entity>
      <entity name="representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="representation_context"/>
         </explicit>
      </entity>
      <entity name="representation_context">
         <explicit name="context_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type">
            <typename name="text"/>
         </explicit>
         <inverse name="representations_in_context" entity="representation" attribute="context_of_items">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="representation_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="wr1" expression="(SIZEOF(using_representations(SELF)) &gt; 0)"/>
      </entity>
      <entity name="representation_map">
         <explicit name="mapping_origin">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation">
            <typename name="representation"/>
         </explicit>
         <inverse name="map_usage" entity="mapped_item" attribute="mapping_source">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="wr1" expression="item_in_context(SELF.mapping_origin,SELF.mapped_representation.&#10;               context_of_items)"/>
      </entity>
      <entity name="representation_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1">
            <typename name="representation"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator">
            <typename name="transformation"/>
         </explicit>
         <where label="wr1" expression="(SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;:&#10;               SELF\representation_relationship.rep_2.context_of_items)"/>
      </entity>
      <entity name="seam_curve" supertypes="surface_curve">
         <where label="wr1" expression="(SIZEOF(SELF\surface_curve.associated_geometry) = 2)"/>
         <where label="wr2" expression="(associated_surface(SELF\surface_curve.associated_geometry[1])&#10;               = associated_surface(SELF\surface_curve.associated_geometry[&#10;               2]))"/>
         <where label="wr3" expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.&#10;               associated_geometry[1]))"/>
         <where label="wr4" expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.&#10;               associated_geometry[2]))"/>
      </entity>
      <entity name="security_classification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="security_level">
            <typename name="security_classification_level"/>
         </explicit>
      </entity>
      <entity name="security_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_security_classification">
            <typename name="security_classification"/>
         </explicit>
      </entity>
      <entity name="security_classification_level">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="serial_numbered_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_end_id" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="shape_aspect">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="of_shape">
            <typename name="product_definition_shape"/>
         </explicit>
         <explicit name="product_definitional">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="shape_aspect_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="shape_definition_representation" supertypes="property_definition_representation">
         <where label="wr1" expression="(('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.&#10;               definition.definition)) OR (&#10;               'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(&#10;               SELF.definition)))"/>
         <where label="wr2" expression="('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF.&#10;               used_representation))"/>
      </entity>
      <entity name="shape_representation" supertypes="representation"/>
      <entity name="shape_representation_relationship" supertypes="representation_relationship">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\&#10;               representation_relationship.rep_1) + TYPEOF(SELF\&#10;               representation_relationship.rep_2)))"/>
      </entity>
      <entity name="shell_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="sbsm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="wr1" expression="constraints_geometry_shell_based_surface_model(SELF)"/>
      </entity>
      <entity name="shell_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="sbwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="wr1" expression="constraints_geometry_shell_based_wireframe_model(SELF)"/>
      </entity>
      <entity name="shell_based_wireframe_shape_representation" supertypes="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (NOT (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;                'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =&#10;                 1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( it &lt;* SELF.items | (SIZEOF([&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))&#10;                &gt;= 1)"/>
         <where label="wr3" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( eloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN&#10;                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el &lt;* eloop\path.&#10;                edge_list | (NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN&#10;                TYPEOF(el.edge_element))) )) = 0)) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
         <where label="wr4" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( eloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN&#10;                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el &lt;*&#10;                QUERY ( el &lt;* eloop\path.edge_list | (&#10;                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(el.edge_element\&#10;                edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_el.&#10;                edge_element\edge_curve.edge_geometry\polyline.points)&#10;                &gt; 2)) )) = 0)) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr5" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( eloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN&#10;                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el &lt;* eloop\path.&#10;                edge_list | (NOT valid_wireframe_edge_curve(el.edge_element&#10;                \edge_curve.edge_geometry)) )) = 0)) )) = 0)) )) = 0)) )) =&#10;                 0)"/>
         <where label="wr6" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( eloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN&#10;                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el &lt;* eloop\path.&#10;                edge_list | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;                TYPEOF(el.edge_element.edge_start)) AND (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(el.&#10;                edge_element.edge_end)))) )) = 0)) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
         <where label="wr7" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( eloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN&#10;                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el &lt;* eloop\path.&#10;                edge_list | (NOT (valid_wireframe_vertex_point(el.&#10;                edge_element.edge_start\vertex_point.vertex_geometry) AND&#10;                valid_wireframe_vertex_point(el.edge_element.edge_end\&#10;                vertex_point.vertex_geometry))) )) = 0)) ))&#10;                = 0)) )) = 0)) )) = 0)"/>
         <where label="wr8" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( vloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN&#10;                 TYPEOF(wsb)) ) | (NOT (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(vloop\&#10;                vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) = 0)"/>
         <where label="wr9" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT&#10;                (SIZEOF(QUERY ( vloop &lt;* QUERY ( wsb &lt;* ws\wire_shell.&#10;                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN&#10;                 TYPEOF(wsb)) ) | (NOT valid_wireframe_vertex_point(vloop\&#10;                vertex_loop.loop_vertex\vertex_point.vertex_geometry)) )) =&#10;                 0)) )) = 0)) )) = 0)"/>
         <where label="wr10" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) ) | (&#10;                NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(vs\&#10;                vertex_shell.vertex_shell_extent.loop_vertex))) )) = 0)) ))&#10;                = 0)"/>
         <where label="wr11" expression="(SIZEOF(QUERY ( sbwm &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN&#10;                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs &lt;* QUERY ( sb &lt;*&#10;                sbwm\shell_based_wireframe_model.sbwm_boundary | (&#10;                'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) ) | (&#10;                NOT valid_wireframe_vertex_point(vs\vertex_shell.&#10;                vertex_shell_extent.loop_vertex\vertex_point.&#10;                vertex_geometry)) )) = 0)) )) = 0)"/>
         <where label="wr12" expression="(SIZEOF(QUERY ( mi &lt;* QUERY ( it &lt;* SELF.items | (&#10;                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (&#10;                NOT (('CONFIG_CONTROL_DESIGN.' +&#10;                'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\&#10;                mapped_item.mapping_source.mapped_representation))) ))&#10;                = 0)"/>
         <where label="wr13" expression="(SELF.context_of_items\geometric_representation_context.&#10;                coordinate_space_dimension = 3)"/>
      </entity>
      <entity name="si_unit" supertypes="named_unit">
         <explicit name="prefix" optional="YES">
            <typename name="si_prefix"/>
         </explicit>
         <explicit name="name">
            <typename name="si_unit_name"/>
         </explicit>
         <derived name="dimensions" expression="dimensions_for_si_unit(SELF.name)">
            <typename name="dimensional_exponents"/>
            <redeclaration entity-ref="named_unit"/>
         </derived>
      </entity>
      <entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="solid_angle_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="solid_model" supertypes="geometric_representation_item" super.expression="manifold_solid_brep"/>
      <entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
         <explicit name="upper_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="next_usage">
            <typename name="next_assembly_usage_occurrence"/>
         </explicit>
         <unique label="ur1">
            <unique.attribute entity-ref="specified_higher_usage_occurrence" attribute="upper_usage"/>
            <unique.attribute entity-ref="specified_higher_usage_occurrence" attribute="next_usage"/>
         </unique>
         <where label="wr1" expression="(SELF :&lt;&gt;: upper_usage)"/>
         <where label="wr2" expression="(SELF\product_definition_relationship.&#10;               relating_product_definition :=: upper_usage.&#10;               relating_product_definition)"/>
         <where label="wr3" expression="(SELF\product_definition_relationship.&#10;               related_product_definition :=: next_usage.&#10;               related_product_definition)"/>
         <where label="wr4" expression="(upper_usage.related_product_definition :=: next_usage.&#10;               relating_product_definition)"/>
         <where label="wr5" expression="(NOT ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN&#10;               TYPEOF(upper_usage)))"/>
      </entity>
      <entity name="spherical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="start_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="start_request_item"/>
         </explicit>
      </entity>
      <entity name="start_work" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="supplied_part_relationship" supertypes="product_definition_relationship"/>
      <entity name="surface" supertypes="geometric_representation_item" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)"/>
      <entity name="surface_curve" supertypes="curve" super.expression="ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve">
         <explicit name="curve_3d">
            <typename name="curve"/>
         </explicit>
         <explicit name="associated_geometry">
            <aggregate type="LIST" lower="1" upper="2"/>
            <typename name="pcurve_or_surface"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="preferred_surface_curve_representation"/>
         </explicit>
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="wr1" expression="(curve_3d.dim = 3)"/>
         <where label="wr2" expression="(('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[&#10;               1])) OR (master_representation &lt;&gt; pcurve_s1))"/>
         <where label="wr3" expression="(('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[&#10;               2])) OR (master_representation &lt;&gt; pcurve_s2))"/>
         <where label="wr4" expression="(NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(curve_3d)))"/>
      </entity>
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
         <explicit name="extrusion_axis">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="surface_of_revolution" supertypes="swept_surface">
         <explicit name="axis_position">
            <typename name="axis1_placement"/>
         </explicit>
         <derived name="axis_line" expression="dummy_gri || curve() || line(axis_position.&#10;                     location,dummy_gri || vector(axis_position.z,1))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="surface_patch" supertypes="founded_item">
         <explicit name="parent_surface">
            <typename name="bounded_surface"/>
         </explicit>
         <explicit name="u_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="v_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="u_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="v_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <inverse name="using_surfaces" entity="rectangular_composite_surface" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="wr1" expression="(NOT ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(&#10;               parent_surface)))"/>
      </entity>
      <entity name="surface_replica" supertypes="surface">
         <explicit name="parent_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where label="wr1" expression="acyclic_surface_replica(SELF,parent_surface)"/>
      </entity>
      <entity name="swept_surface" supertypes="surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution)">
         <explicit name="swept_curve">
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="topological_representation_item" supertypes="representation_item" super.expression="ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path))"/>
      <entity name="toroidal_surface" supertypes="elementary_surface">
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="trimmed_curve" supertypes="bounded_curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="trim_1">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="trim_2">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="sense_agreement">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="trimming_preference"/>
         </explicit>
         <where label="wr1" expression="((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt;&#10;           TYPEOF(trim_1[2])))"/>
         <where label="wr2" expression="((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt;&#10;           TYPEOF(trim_2[2])))"/>
      </entity>
      <entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where label="wr1" expression="valid_measure_value(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="uniform_curve" supertypes="b_spline_curve"/>
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
      <entity name="vector" supertypes="geometric_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="length_measure"/>
         </explicit>
         <where label="wr1" expression="(magnitude &gt;= 0)"/>
      </entity>
      <entity name="versioned_action_request">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="version">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="vertex" supertypes="topological_representation_item"/>
      <entity name="vertex_loop" supertypes="loop">
         <explicit name="loop_vertex">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="vertex_point" supertypes="vertex geometric_representation_item">
         <explicit name="vertex_geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="vertex_shell" supertypes="topological_representation_item">
         <explicit name="vertex_shell_extent">
            <typename name="vertex_loop"/>
         </explicit>
      </entity>
      <entity name="volume_measure_with_unit" supertypes="measure_with_unit">
         <where label="wr1" expression="('CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\&#10;               measure_with_unit.unit_component))"/>
      </entity>
      <entity name="volume_unit" supertypes="named_unit">
         <where label="wr1" expression="((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\&#10;               named_unit.dimensions.mass_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.time_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.electric_current_exponent = 0) AND (&#10;               SELF\named_unit.dimensions.&#10;               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit&#10;               .dimensions.amount_of_substance_exponent = 0) AND (SELF\&#10;               named_unit.dimensions.luminous_intensity_exponent = 0))"/>
      </entity>
      <entity name="week_of_year_and_day_date" supertypes="date">
         <explicit name="week_component">
            <typename name="week_in_year_number"/>
         </explicit>
         <explicit name="day_component" optional="YES">
            <typename name="day_in_week_number"/>
         </explicit>
      </entity>
      <entity name="wire_shell" supertypes="topological_representation_item">
         <explicit name="wire_shell_extent">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="loop"/>
         </explicit>
         <where label="wr1" expression="(NOT mixed_loop_type_set(wire_shell_extent))"/>
      </entity>
      <rule name="acu_requires_security_classification" appliesto="assembly_component_usage cc_design_security_classification">
         <where label="wr1" expression="(SIZEOF(QUERY ( acu &lt;* assembly_component_usage | (NOT (SIZEOF(&#10;             QUERY ( ccdsc &lt;* cc_design_security_classification | (acu IN&#10;             ccdsc.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="application_context_requires_ap_definition" appliesto="application_context application_protocol_definition">
         <where label="wr1" expression="(SIZEOF(QUERY ( ac &lt;* application_context | (NOT (SIZEOF(&#10;             QUERY ( apd &lt;* application_protocol_definition | ((ac :=: apd.&#10;             application) AND (apd.&#10;             application_interpreted_model_schema_name =&#10;             'config_control_design')) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="approval_date_time_constraints" appliesto="approval_date_time">
         <where label="wr1" expression="(SIZEOF(QUERY ( adt &lt;* approval_date_time | (NOT (SIZEOF(TYPEOF(&#10;             adt.date_time) * ['CONFIG_CONTROL_DESIGN.DATE_AND_TIME'])&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="approval_person_organization_constraints" appliesto="approval_person_organization">
         <where label="wr1" expression="(SIZEOF(QUERY ( apo &lt;* approval_person_organization | (NOT (&#10;             SIZEOF(TYPEOF(apo.person_organization) * [&#10;             'CONFIG_CONTROL_DESIGN.PERSON_AND_ORGANIZATION'])&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="approval_requires_approval_date_time" appliesto="approval approval_date_time">
         <where label="wr1" expression="(SIZEOF(QUERY ( app &lt;* approval | (NOT (SIZEOF(QUERY ( adt &lt;*&#10;             approval_date_time | (app :=: adt.dated_approval) )) = 1)) ))&#10;             = 0)"/>
      </rule>
      <rule name="approval_requires_approval_person_organization" appliesto="approval approval_person_organization">
         <where label="wr1" expression="(SIZEOF(QUERY ( app &lt;* approval | (NOT (SIZEOF(QUERY ( apo &lt;*&#10;             approval_person_organization | (app :=: apo.&#10;             authorized_approval) )) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="approvals_are_assigned" appliesto="approval approval_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( app &lt;* approval | (NOT (SIZEOF(QUERY ( aa &lt;*&#10;             approval_assignment | (app :=: aa.assigned_approval) ))&#10;             &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="as_required_quantity" appliesto="measure_with_unit">
         <where label="wr1" expression="(SIZEOF(QUERY ( m &lt;* measure_with_unit | ((&#10;             'CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF(m.&#10;             value_component)) AND (NOT (m.value_component =&#10;             'as_required'))) )) = 0)"/>
      </rule>
      <rule name="certification_requires_approval" appliesto="certification cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( cert &lt;* certification | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (cert IN ccda.items) )) =&#10;              1)) )) = 0)"/>
      </rule>
      <rule name="certification_requires_date_time" appliesto="certification cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( cert &lt;* certification | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | (cert IN&#10;              ccdta.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="change_request_requires_approval" appliesto="change_request cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( cr &lt;* change_request | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (cr IN ccda.items) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="change_request_requires_date_time" appliesto="change_request cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( cr &lt;* change_request | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | (cr IN&#10;             ccdta.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="change_request_requires_person_organization" appliesto="change_request cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( cr &lt;* change_request | (NOT (SIZEOF(&#10;             QUERY ( ccpoa &lt;* cc_design_person_and_organization_assignment&#10;              | (cr IN ccpoa.items) )) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="change_requires_approval" appliesto="change cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( chg &lt;* change | (NOT (SIZEOF(QUERY ( ccda &lt;*&#10;             cc_design_approval | (chg IN ccda.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="change_requires_date_time" appliesto="change cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( chg &lt;* change | (NOT (SIZEOF(QUERY ( ccdta &lt;*&#10;             cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND&#10;              (ccdta.role.name = 'start_date')) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="compatible_dimension" appliesto="cartesian_point direction representation_context geometric_representation_context">
         <where label="wr1" expression="(SIZEOF(QUERY ( x &lt;* cartesian_point | (SIZEOF(QUERY ( y &lt;*&#10;             geometric_representation_context | (item_in_context(x,y) AND (&#10;             HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension)) )) &gt;&#10;             0) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( x &lt;* direction | (SIZEOF(QUERY ( y &lt;*&#10;             geometric_representation_context | (item_in_context(x,y) AND (&#10;             HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension))&#10;             )) &gt; 0) )) = 0)"/>
      </rule>
      <rule name="configuration_item_requires_approval" appliesto="configuration_item cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( ci &lt;* configuration_item | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (ci IN ccda.items) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="configuration_item_requires_person_organization" appliesto="configuration_item cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( ci &lt;* configuration_item | (NOT (SIZEOF(&#10;             QUERY ( ccdpoa &lt;* cc_design_person_and_organization_assignment&#10;              | (ci IN ccdpoa.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="contract_requires_approval" appliesto="contract cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( c &lt;* contract | (NOT (SIZEOF(QUERY ( ccda &lt;*&#10;             cc_design_approval | (c IN ccda.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="contract_requires_person_organization" appliesto="contract cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( c &lt;* contract | (NOT (SIZEOF(QUERY ( ccdpoa &lt;*&#10;             cc_design_person_and_organization_assignment | (c IN ccdpoa.&#10;             items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="coordinated_assembly_and_shape" appliesto="next_assembly_usage_occurrence">
         <where label="wr1" expression="(SIZEOF(QUERY ( nauo &lt;* next_assembly_usage_occurrence | (NOT&#10;             assembly_shape_is_defined(nauo,'CONFIG_CONTROL_DESIGN')) )) =&#10;             0)"/>
      </rule>
      <rule name="dependent_instantiable_action_directive" appliesto="action_directive">
         <where label="wr1" expression="(SIZEOF(QUERY ( ad &lt;* action_directive | (NOT (SIZEOF(USEDIN(ad,&#10;             '')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_approval_status" appliesto="approval_status">
         <where label="wr1" expression="(SIZEOF(QUERY ( ast &lt;* approval_status | (NOT (SIZEOF(USEDIN(ast,&#10;             '')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_certification_type" appliesto="certification_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( ct &lt;* certification_type | (NOT (SIZEOF(USEDIN(ct,&#10;             '')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_contract_type" appliesto="contract_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( ct &lt;* contract_type | (NOT (SIZEOF(USEDIN(ct,''))&#10;             &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_date" appliesto="date">
         <where label="wr1" expression="(SIZEOF(QUERY ( dt &lt;* date | (NOT (SIZEOF(USEDIN(dt,'')) &gt;= 1)) ))&#10;             = 0)"/>
      </rule>
      <rule name="dependent_instantiable_date_time_role" appliesto="date_time_role">
         <where label="wr1" expression="(SIZEOF(QUERY ( dtr &lt;* date_time_role | (NOT (SIZEOF(USEDIN(dtr,&#10;             '')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_document_type" appliesto="document_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( dt &lt;* document_type | (NOT (SIZEOF(USEDIN(dt,''))&#10;             &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_named_unit" appliesto="named_unit">
         <where label="wr1" expression="(SIZEOF(QUERY ( nu &lt;* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) &gt;=&#10;              1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_parametric_representation_context" appliesto="parametric_representation_context">
         <where label="wr1" expression="(SIZEOF(QUERY ( prc &lt;* parametric_representation_context | (NOT (&#10;             SIZEOF(USEDIN(prc,'')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_person_and_organization_role" appliesto="person_and_organization_role">
         <where label="wr1" expression="(SIZEOF(QUERY ( poar &lt;* person_and_organization_role | (NOT (&#10;             SIZEOF(USEDIN(poar,'')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_representation_item" appliesto="representation_item">
         <where label="wr1" expression="(SIZEOF(QUERY ( ri &lt;* representation_item | (NOT (SIZEOF(USEDIN(&#10;             ri,'')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_security_classification_level" appliesto="security_classification_level">
         <where label="wr1" expression="(SIZEOF(QUERY ( scl &lt;* security_classification_level | (NOT (&#10;             SIZEOF(USEDIN(scl,'')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="dependent_instantiable_shape_representation" appliesto="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( sr &lt;* shape_representation | (NOT (SIZEOF(USEDIN(&#10;             sr,'')) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="design_context_for_property" appliesto="product_definition">
         <where label="wr1" expression="(SIZEOF(QUERY ( pd &lt;* product_definition | ((SIZEOF(USEDIN(pd,&#10;             'CONFIG_CONTROL_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION') +&#10;              QUERY ( pdr &lt;* USEDIN(pd,'CONFIG_CONTROL_DESIGN.' +&#10;             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')&#10;              | (SIZEOF(USEDIN(pdr,&#10;             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION'))&#10;             &gt;= 1) )) &gt;= 1) AND (NOT (&#10;             'CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF(pd.&#10;             frame_of_reference)))) )) = 0)"/>
      </rule>
      <rule name="document_to_product_definition" appliesto="cc_design_specification_reference">
         <where label="wr1" expression="(SIZEOF(QUERY ( sp &lt;* cc_design_specification_reference | (NOT ((&#10;             (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +&#10;             'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.&#10;             assigned_document)) AND (SIZEOF(QUERY ( it &lt;* sp.items | (NOT&#10;             ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF(it))) ))&#10;             = 0)) OR (NOT (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.'&#10;             + 'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.&#10;             assigned_document))))) )) = 0)"/>
      </rule>
      <rule name="effectivity_requires_approval" appliesto="effectivity cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( eff &lt;* effectivity | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (eff IN ccda.items) )) =&#10;             1)) )) = 0)"/>
      </rule>
      <rule name="geometric_representation_item_3d" appliesto="geometric_representation_item">
         <where label="wr1" expression="(SIZEOF(QUERY ( gri &lt;* geometric_representation_item | (NOT ((&#10;             dimension_of(gri) = 3) OR (SIZEOF(QUERY ( ur &lt;*&#10;             using_representations(gri) | (&#10;             'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION' IN TYPEOF(&#10;             ur)) )) &gt; 0))) )) = 0)"/>
      </rule>
      <rule name="global_unit_assignment" appliesto="global_unit_assigned_context">
         <where label="wr1" expression="(SIZEOF(QUERY ( guac &lt;* global_unit_assigned_context | (NOT (&#10;             SIZEOF(guac.units) = 3)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( guac &lt;* global_unit_assigned_context | (NOT ((&#10;             SIZEOF(QUERY ( u &lt;* guac.units | (&#10;             'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) AND&#10;             (SIZEOF(QUERY ( u &lt;* guac.units | (&#10;             'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) = 1)&#10;             AND (SIZEOF(QUERY ( u &lt;* guac.units | (&#10;             'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(u)) ))&#10;             = 1))) )) = 0)"/>
      </rule>
      <rule name="no_shape_for_make_from" appliesto="design_make_from_relationship">
         <where label="wr1" expression="(SIZEOF(QUERY ( dmfr &lt;* design_make_from_relationship | (NOT (&#10;             SIZEOF(QUERY ( pd &lt;* USEDIN(dmfr,'CONFIG_CONTROL_DESIGN.' +&#10;             'PROPERTY_DEFINITION.DEFINITION') | (&#10;             'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'&#10;             IN TYPEOF(pd)) )) = 0)) )) = 0)"/>
      </rule>
      <rule name="no_shape_for_supplied_part" appliesto="supplied_part_relationship">
         <where label="wr1" expression="(SIZEOF(QUERY ( spr &lt;* supplied_part_relationship | (NOT (SIZEOF(&#10;             QUERY ( pd &lt;* USEDIN(spr,'CONFIG_CONTROL_DESIGN.' +&#10;             'PROPERTY_DEFINITION.DEFINITION') | (&#10;             'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'&#10;             IN TYPEOF(pd)) )) = 0)) )) = 0)"/>
      </rule>
      <rule name="product_concept_requires_configuration_item" appliesto="product_concept configuration_item">
         <where label="wr1" expression="(SIZEOF(QUERY ( pc &lt;* product_concept | (NOT (SIZEOF(&#10;             QUERY ( ci &lt;* configuration_item | (pc :=: ci.item_concept) ))&#10;             &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="product_definition_requires_approval" appliesto="product_definition cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( pd &lt;* product_definition | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (pd IN ccda.items) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="product_definition_requires_date_time" appliesto="product_definition cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( pd &lt;* product_definition | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | (pd IN&#10;             ccdta.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="product_definition_requires_person_organization" appliesto="product_definition cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( pd &lt;* product_definition | (NOT (SIZEOF(&#10;             QUERY ( ccdpoa &lt;* cc_design_person_and_organization_assignment&#10;              | (pd IN ccdpoa.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="product_requires_person_organization" appliesto="product cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( prod &lt;* product | (NOT (SIZEOF(QUERY ( ccdpoa &lt;*&#10;             cc_design_person_and_organization_assignment | (prod IN ccdpoa&#10;             .items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="product_requires_product_category" appliesto="product product_related_product_category">
         <where label="wr1" expression="(SIZEOF(QUERY ( prod &lt;* product | (NOT (SIZEOF(QUERY ( prpc &lt;*&#10;             product_related_product_category | ((prod IN prpc.products)&#10;             AND (prpc.name IN ['assembly','inseparable_assembly','detail',&#10;             'customer_furnished_equipment'])) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="product_requires_version" appliesto="product product_definition_formation">
         <where label="wr1" expression="(SIZEOF(QUERY ( prod &lt;* product | (NOT (SIZEOF(QUERY ( pdf &lt;*&#10;             product_definition_formation | (prod :=: pdf.of_product) )) &gt;=&#10;              1)) )) = 0)"/>
      </rule>
      <rule name="product_version_requires_approval" appliesto="product_definition_formation cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( pdf &lt;* product_definition_formation | (NOT (&#10;             SIZEOF(QUERY ( ccda &lt;* cc_design_approval |&#10;             (pdf IN ccda.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="product_version_requires_person_organization" appliesto="product_definition_formation cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( pdf &lt;* product_definition_formation | (NOT (&#10;             SIZEOF(QUERY ( ccdpoa &lt;*&#10;             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa&#10;             .items) AND (ccdpoa.role.name = 'creator')) )) = 1)) )) = 0)"/>
         <where label="wr2" expression="(SIZEOF(QUERY ( pdf &lt;* product_definition_formation | (NOT (&#10;             SIZEOF(QUERY ( ccdpoa &lt;*&#10;             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa&#10;             .items) AND (ccdpoa.role.name IN ['design_supplier',&#10;             'part_supplier'])) )) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="product_version_requires_security_classification" appliesto="product_definition_formation cc_design_security_classification">
         <where label="wr1" expression="(SIZEOF(QUERY ( pdf &lt;* product_definition_formation | (NOT (&#10;             SIZEOF(QUERY ( ccdsc &lt;* cc_design_security_classification | (&#10;             pdf IN ccdsc.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="restrict_action_request_status" appliesto="action_request_status">
         <where label="wr1" expression="(SIZEOF(QUERY ( ars &lt;* action_request_status | (NOT (ars.status&#10;             IN ['proposed','in_work','issued','hold'])) )) = 0)"/>
      </rule>
      <rule name="restrict_approval_status" appliesto="approval_status">
         <where label="wr1" expression="(SIZEOF(QUERY ( ast &lt;* approval_status | (NOT (ast.name IN [&#10;             'approved','not_yet_approved','disapproved','withdrawn'])) ))&#10;             = 0)"/>
      </rule>
      <rule name="restrict_certification_type" appliesto="certification_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( ct &lt;* certification_type | (NOT (ct.description&#10;             IN ['design_supplier','part_supplier'])) )) = 0)"/>
      </rule>
      <rule name="restrict_contract_type" appliesto="contract_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( ct &lt;* contract_type | (NOT (ct.description IN [&#10;             'fixed_price','cost_plus'])) )) = 0)"/>
      </rule>
      <rule name="restrict_date_time_role" appliesto="date_time_role">
         <where label="wr1" expression="(SIZEOF(QUERY ( dtr &lt;* date_time_role | (NOT (dtr.name IN [&#10;             'creation_date','request_date','release_date','start_date',&#10;             'contract_date','certification_date','sign_off_date',&#10;             'classification_date','declassification_date'])) )) = 0)"/>
      </rule>
      <rule name="restrict_document_type" appliesto="document_type">
         <where label="wr1" expression="(SIZEOF(QUERY ( dt &lt;* document_type | (NOT (dt.product_data_type&#10;             IN ['material_specification','process_specification',&#10;             'design_specification','surface_finish_specification',&#10;             'cad_filename','drawing'])) )) = 0)"/>
      </rule>
      <rule name="restrict_person_organization_role" appliesto="person_and_organization_role">
         <where label="wr1" expression="(SIZEOF(QUERY ( por &lt;* person_and_organization_role | (NOT (por.&#10;             name IN ['request_recipient','initiator','part_supplier',&#10;             'design_supplier','configuration_manager','contractor',&#10;             'classification_officer','creator','design_owner'])) )) = 0)"/>
      </rule>
      <rule name="restrict_product_category_value" appliesto="product_related_product_category">
         <where label="wr1" expression="(SIZEOF(QUERY ( prpc &lt;* product_related_product_category | (NOT (&#10;             prpc.name IN ['assembly','detail',&#10;             'customer_furnished_equipment','inseparable_assembly','cast',&#10;             'coined','drawn','extruded','forged','formed','machined',&#10;             'molded','rolled','sheared'])) )) = 0)"/>
      </rule>
      <rule name="restrict_security_classification_level" appliesto="security_classification_level">
         <where label="wr1" expression="(SIZEOF(QUERY ( scl &lt;* security_classification_level | (NOT (scl.&#10;             name IN ['unclassified','classified','proprietary',&#10;             'confidential','secret','top_secret'])) )) = 0)"/>
      </rule>
      <rule name="security_classification_optional_date_time" appliesto="security_classification cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sc &lt;* security_classification | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | ((sc IN&#10;             ccdta.items) AND ('declassification_date' = ccdta.role.name))&#10;             )) &lt;= 1)) )) = 0)"/>
      </rule>
      <rule name="security_classification_requires_approval" appliesto="security_classification cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( sc &lt;* security_classification | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (sc IN ccda.items) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="security_classification_requires_date_time" appliesto="security_classification cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sc &lt;* security_classification | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | ((sc IN&#10;             ccdta.items) AND ('classification_date' = ccdta.role.name)) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="security_classification_requires_person_organization" appliesto="security_classification cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sc &lt;* security_classification | (NOT (SIZEOF(&#10;             QUERY ( ccdpoa &lt;* cc_design_person_and_organization_assignment&#10;              | (sc IN ccdpoa.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="start_request_requires_approval" appliesto="start_request cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( sr &lt;* start_request | (NOT (SIZEOF(&#10;             QUERY ( ccda &lt;* cc_design_approval | (sr IN ccda.items) ))&#10;             = 1)) )) = 0)"/>
      </rule>
      <rule name="start_request_requires_date_time" appliesto="start_request cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sr &lt;* start_request | (NOT (SIZEOF(&#10;             QUERY ( ccdta &lt;* cc_design_date_and_time_assignment | (sr IN&#10;             ccdta.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="start_request_requires_person_organization" appliesto="start_request cc_design_person_and_organization_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sr &lt;* start_request | (NOT (SIZEOF(&#10;             QUERY ( ccdpoa &lt;* cc_design_person_and_organization_assignment&#10;              | (sr IN ccdpoa.items) )) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="start_work_requires_approval" appliesto="start_work cc_design_approval">
         <where label="wr1" expression="(SIZEOF(QUERY ( sw &lt;* start_work | (NOT (SIZEOF(QUERY ( ccda &lt;*&#10;             cc_design_approval | (sw IN ccda.items) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="start_work_requires_date_time" appliesto="start_work cc_design_date_and_time_assignment">
         <where label="wr1" expression="(SIZEOF(QUERY ( sw &lt;* start_work | (NOT (SIZEOF(QUERY ( ccdta &lt;*&#10;             cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND&#10;             (ccdta.role.name = 'start_date')) )) = 1)) )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_action" appliesto="action">
         <where label="wr1" expression="(SIZEOF(QUERY ( act &lt;* action | (NOT (&#10;             'CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act))) )) =&#10;             0)"/>
      </rule>
      <rule name="subtype_mandatory_effectivity" appliesto="effectivity">
         <where label="wr1" expression="(SIZEOF(QUERY ( eff &lt;* effectivity | (NOT ((SIZEOF([&#10;             'CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',&#10;             'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',&#10;             'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1)&#10;             AND ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN&#10;             TYPEOF(eff)))) )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_product_context" appliesto="product_context">
         <where label="wr1" expression="(SIZEOF(QUERY ( pc &lt;* product_context | (NOT (&#10;             'CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc))) ))&#10;             = 0)"/>
      </rule>
      <rule name="subtype_mandatory_product_definition_formation" appliesto="product_definition_formation">
         <where label="wr1" expression="(SIZEOF(QUERY ( pdf &lt;* product_definition_formation | (NOT ((&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN&#10;             TYPEOF(pdf))) )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_product_definition_usage" appliesto="product_definition_usage">
         <where label="wr1" expression="(SIZEOF(QUERY ( pdu &lt;* product_definition_usage | (NOT ((&#10;             'CONFIG_CONTROL_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE') IN&#10;             TYPEOF(pdu))) )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_representation" appliesto="representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( rep &lt;* representation | (NOT (&#10;             'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep)))&#10;             )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_representation_context" appliesto="representation_context">
         <where label="wr1" expression="(SIZEOF(QUERY ( rep_cntxt &lt;* representation_context | (NOT (&#10;             'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;             TYPEOF(rep_cntxt))) )) = 0)"/>
      </rule>
      <rule name="subtype_mandatory_shape_representation" appliesto="shape_representation">
         <where label="wr1" expression="(SIZEOF(QUERY ( sr &lt;* shape_representation | (NOT ((SIZEOF([&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'ADVANCED_BREP_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',&#10;             'CONFIG_CONTROL_DESIGN.' +&#10;             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] *&#10;             TYPEOF(sr)) = 1) OR (SIZEOF(QUERY ( it &lt;* sr\representation.&#10;             items | (NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN&#10;             TYPEOF(it))) )) = 0) OR (SIZEOF(QUERY ( sdr &lt;* QUERY ( pdr &lt;*&#10;             USEDIN(sr,&#10;             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +&#10;             'USED_REPRESENTATION') | (&#10;             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN&#10;             TYPEOF(pdr)) ) | (NOT (SIZEOF([&#10;             'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',&#10;             'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(&#10;             sdr.definition.definition)) = 1)) )) = 0))) )) = 0)"/>
      </rule>
      <rule name="unique_version_change_order_rule" appliesto="change">
         <where label="wr1" expression="(SIZEOF(QUERY ( c &lt;* change | (NOT unique_version_change_order(c.&#10;             assigned_action)) )) = 0)"/>
      </rule>
      <rule name="versioned_action_request_requires_solution" appliesto="versioned_action_request action_request_solution">
         <where label="wr1" expression="(SIZEOF(QUERY ( ar &lt;* versioned_action_request | (NOT (SIZEOF(&#10;             QUERY ( ars &lt;* action_request_solution | (ar :=: ars.request)&#10;             )) &gt;= 1)) )) = 0)"/>
      </rule>
      <rule name="versioned_action_request_requires_status" appliesto="versioned_action_request action_request_status">
         <where label="wr1" expression="(SIZEOF(QUERY ( ar &lt;* versioned_action_request | (NOT (SIZEOF(&#10;             QUERY ( ars &lt;* action_request_status | (ar :=: ars.&#10;             assigned_request) )) = 1)) )) = 0)"/>
      </rule>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_mapped_representation">
         <parameter name="parent_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="children_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z &lt;* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM'
        IN TYPEOF(z)) );
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN
            parent_set THEN RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z &lt;* bag_to_set(USEDIN(x[i],'')) | (
            'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_product_category_relationship">
         <parameter name="relation">
            <typename name="product_category_relationship"/>
         </parameter>
         <parameter name="children">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_category"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      i              : INTEGER;
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' +
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd &lt;* bag_to_set(USEDIN(relation.
        relating_product_definition,'CONFIG_CONTROL_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives +
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;</algorithm>
      </function>
      <function name="assembly_shape_is_defined">
         <parameter name="assy">
            <typename name="next_assembly_usage_occurrence"/>
         </parameter>
         <parameter name="schma">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      srr_set   : SET OF shape_representation_relationship := [];
      i         : INTEGER;
      j         : INTEGER;
      sdr_set   : SET OF shape_definition_representation := [];
      pr1_set   : SET OF property_definition := [];
      pdrel_set : SET OF product_definition_relationship := [];
      pr2_set   : SET OF property_definition := [];
    END_LOCAL;
    pr1_set := bag_to_set(USEDIN(assy.related_product_definition,schma +
        '.PROPERTY_DEFINITION.DEFINITION'));
    REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr &lt;* USEDIN(pr1_set[i],schma +
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma +
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,schma +
         '.PRODUCT_DEFINITION_RELATIONSHIP.' +
         'RELATED_PRODUCT_DEFINITION'));
    REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;
      pr2_set := pr2_set + USEDIN(pdrel_set[j],schma +
          '.PROPERTY_DEFINITION.DEFINITION');
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr &lt;* USEDIN(pr2_set[i],schma +
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma +
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    IF SIZEOF(sdr_set) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr &lt;* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,schma +
            '.REPRESENTATION_RELATIONSHIP.REP_2')) | ((schma +
            '.SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );
        IF SIZEOF(srr_set) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
            IF SIZEOF(QUERY ( pdr &lt;* bag_to_set(USEDIN(srr_set[j]\
                representation_relationship.rep_1,schma +
                '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                 | ((schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(
                pdr)) ) * QUERY ( pdr &lt;* bag_to_set(USEDIN(assy.
                relating_product_definition,schma +
                '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
                schma + '.SHAPE_DEFINITION_REPRESENTATION') IN
                TYPEOF(pdr)) )) &gt;= 1 THEN
              IF SIZEOF(QUERY ( cdsr &lt;* USEDIN(srr_set[j],schma +
                  '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
                  'REPRESENTATION_RELATION') | (NOT (cdsr\
                  context_dependent_shape_representation.
                  represented_product_relation\property_definition.
                  definition :=: assy)) )) &gt; 0 THEN
                RETURN(FALSE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
      surf : surface;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);</algorithm>
      </function>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate type="BAG" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor &lt; 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri ||
          direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);</algorithm>
      </function>
      <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri ||
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="3" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);</algorithm>
      </function>
      <function name="cc_design_date_time_correlation">
         <parameter name="e">
            <typename name="cc_design_date_and_time_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      dt_role : STRING;
    END_LOCAL;
      dt_role := e\date_and_time_assignment.role.name;
    CASE dt_role OF
      'creation_date'         : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'PRODUCT_DEFINITION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'request_date'         : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE_REQUEST',
                                  'CONFIG_CONTROL_DESIGN.START_REQUEST'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'release_date'         : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE',
                                  'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'start_date'          : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE',
                                  'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'sign_off_date'         : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'APPROVAL_PERSON_ORGANIZATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'contract_date'         : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.CONTRACT'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'certification_date'    : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.CERTIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'classification_date'   : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'SECURITY_CLASSIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'declassification_date' : IF SIZEOF (e.items) &lt;&gt;
                                  SIZEOF (QUERY (x &lt;* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'SECURITY_CLASSIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      OTHERWISE : RETURN(TRUE);
    END_CASE;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="cc_design_person_and_organization_correlation">
         <parameter name="e">
            <typename name="cc_design_person_and_organization_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
       po_role : STRING;
     END_LOCAL;
       po_role := e\person_and_organization_assignment.role.name;
     CASE po_role OF
      'request_recipient'      : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_REQUEST'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'initiator'              : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_WORK',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'creator'                : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   SIZEOF (['CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN (FALSE);
                                 END_IF;
      'part_supplier'          : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'design_supplier'        : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'design_owner'           : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.PRODUCT'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'configuration_manager'  : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'CONFIGURATION_ITEM'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'contractor'             : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.CONTRACT'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'classification_officer' : IF SIZEOF (e.items) &lt;&gt;
                                   SIZEOF (QUERY (x &lt;* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'SECURITY_CLASSIFICATION'
                                   IN TYPEOF (x))) THEN
                                   RETURN(FALSE);
                                 END_IF;
      OTHERWISE : RETURN(TRUE);
    END_CASE;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="closed_shell_reversed">
         <parameter name="a_shell">
            <typename name="closed_shell"/>
         </parameter>
         <typename name="oriented_closed_shell"/>
         <algorithm>LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() ||
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() ||
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="conditional_reverse">
         <parameter name="p">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF p THEN RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve.
          segments[k].parent_curve))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve
          .segments[k].parent_curve))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_surface_model">
         <parameter name="m">
            <typename name="shell_based_surface_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.
          sbsm_boundary[j]))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_wireframe_model">
         <parameter name="m">
            <typename name="shell_based_wireframe_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.
          sbwm_boundary[j]))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN
          TYPEOF(m.sbwm_boundary[j])))
          THEN result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR (sum &lt;&gt; (
        degree + up_cp + 2)) THEN result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k &lt; 1) OR (k &gt; (degree + 1)) THEN result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i &lt; up_knots) AND (k &gt; degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k &gt; (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
            segments[i][j].parent_surface)) OR (
            'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s
            .segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] &lt;= 0 THEN result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);</algorithm>
      </function>
      <function name="derive_dimensional_exponents">
         <parameter name="x">
            <typename name="unit"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
            result.length_exponent := result.length_exponent +
            (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
            result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
            result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
            result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
            result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent *
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
            result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
            result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);</algorithm>
      </function>
      <function name="dimensions_for_si_unit">
         <parameter name="n">
            <typename name="si_unit_name"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>CASE n OF
      metre          :    RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram           :    RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second         :    RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere         :    RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin         :    RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole           :    RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela        :    RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian         :    RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian      :    RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz          :    RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton         :    RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal         :    RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule          :    RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt           :    RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb        :    RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt           :    RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad          :    RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm            :    RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens        :    RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber          :    RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla          :    RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry          :    RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius :    RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen          :    RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux            :    RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel      :    RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray           :    RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert        :    RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim &lt;&gt; arg2.dim THEN scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);</algorithm>
      </function>
      <function name="edge_reversed">
         <parameter name="an_edge">
            <typename name="edge"/>
         </parameter>
         <typename name="oriented_edge"/>
         <algorithm>LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start)
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start)
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_bound_reversed">
         <parameter name="a_face_bound">
            <typename name="face_bound"/>
         </parameter>
         <typename name="face_bound"/>
         <algorithm>LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_reversed">
         <parameter name="a_face">
            <typename name="face"/>
         </parameter>
         <typename name="oriented_face"/>
         <algorithm>LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios &lt;&gt; [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim &lt;&gt; 3 THEN RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);</algorithm>
      </function>
      <function name="gbsf_check_curve">
         <parameter name="cv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
        'CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
        'CONFIG_CONTROL_DESIGN.LINE',
        'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) &gt; 1 THEN
      RETURN(FALSE);
    ELSE
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.CIRCLE',
          'CONFIG_CONTROL_DESIGN.ELLIPSE'] * TYPEOF(cv)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv
            \b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
            self_intersect = UNKNOWN) THEN
          RETURN(TRUE);
        ELSE
          IF (('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND
              (cv\composite_curve.self_intersect = FALSE)) OR (cv\
              composite_curve.self_intersect = UNKNOWN) THEN
            RETURN(SIZEOF(QUERY ( seg &lt;* cv\composite_curve.segments | (
                NOT gbsf_check_curve(seg.parent_curve)) )) = 0);
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
              RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
            ELSE
              IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv))
                  AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                  offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                  'CONFIG_CONTROL_DESIGN.POLYLINE' IN
                  TYPEOF(cv.basis_curve))) THEN
                RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                  RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
                      representation.items[1]) AND gbsf_check_surface(cv\
                      pcurve.basis_surface));
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) &gt;= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                         THEN
                      IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                        REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                            associated_geometry) BY 1;
                          IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                              surface_curve.associated_geometry[i]) THEN
                            IF NOT gbsf_check_surface(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          ELSE
                            IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv
                                \surface_curve.associated_geometry[i])
                                 THEN
                              IF NOT gbsf_check_curve(cv\surface_curve.
                                  associated_geometry[i]) THEN
                                RETURN(FALSE);
                              END_IF;
                            END_IF;
                          END_IF;
                        END_REPEAT;
                        RETURN(TRUE);
                      END_IF;
                    ELSE
                      IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(
                          cv) THEN
                        IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
                            'CONFIG_CONTROL_DESIGN.PARABOLA',
                            'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(cv\
                            trimmed_curve.basis_curve)) = 1 THEN
                          RETURN(TRUE);
                        ELSE
                          RETURN(gbsf_check_curve(cv\trimmed_curve.
                              basis_curve));
                        END_IF;
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="gbsf_check_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt)
               THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve\representation.items[1]) AND
                gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="gbsf_check_surface">
         <parameter name="sf">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\
        b_spline_surface.self_intersect = FALSE)) OR (sf\b_spline_surface.
        self_intersect = UNKNOWN) THEN RETURN(TRUE);
    ELSE
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE',
          'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf)
             THEN
          IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
              'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
              'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
              curve_bounded_surface.basis_surface)) = 1 THEN
            RETURN(SIZEOF(QUERY ( bcurve &lt;* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
          ELSE
            IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface)
                 THEN
              RETURN(SIZEOF(QUERY ( bcurve &lt;* sf\curve_bounded_surface.
                  boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
            END_IF;
          END_IF;
        ELSE
          IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (
              sf\offset_surface.self_intersect = FALSE)) OR (sf\
              offset_surface.self_intersect = UNKNOWN) THEN
            RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN
                TYPEOF(sf) THEN
              REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments) BY 1;
                REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                    segments[i]) BY 1;
                  IF NOT gbsf_check_surface(sf\
                      rectangular_composite_surface.segments[i][j].
                      parent_surface) THEN RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_REPEAT;
              RETURN(TRUE);
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN
                  TYPEOF(sf) THEN
                IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
                    'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
                    'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
                    rectangular_trimmed_surface.basis_surface)) = 1 THEN
                  RETURN(TRUE);
                ELSE
                  RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
                      .basis_surface));
                END_IF;
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf)
                     THEN
                  RETURN(gbsf_check_surface(sf\surface_replica.
                      parent_surface));
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf)
                       THEN
                    RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n &gt; 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);</algorithm>
      </function>
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') *
        cntxt.representations_in_context) &gt; 0 THEN RETURN(TRUE);
    ELSE
      y := QUERY ( z &lt;* USEDIN(item,'') | (
          'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) &gt; 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="leap_year">
         <parameter name="year">
            <typename name="year_number"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) =
         0) THEN RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);</algorithm>
      </function>
      <function name="list_of_topology_reversed">
         <parameter name="a_list">
            <typename name="list_of_reversible_topology_item"/>
         </parameter>
         <typename name="list_of_reversible_topology_item"/>
         <algorithm>LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n &lt;&gt; ((u - low) + 1) THEN RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0"/>
         <aggregate type="ARRAY" lower="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) &lt;&gt; SIZEOF(lis) THEN RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[1]) THEN RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) &lt;&gt; SIZEOF(lis[i]) THEN RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) &lt;= 1 THEN RETURN(FALSE);
    END_IF;
    poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt;
          poly_loop_type THEN RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="msb_shells">
         <parameter name="brep">
            <typename name="manifold_solid_brep"/>
         </parameter>
         <aggregate type="SET" lower="1" upper="?"/>
         <typename name="closed_shell"/>
         <algorithm>IF SIZEOF(QUERY ( msbtype &lt;* TYPEOF(brep) | (msbtype LIKE
        '*BREP_WITH_VOIDS') )) &gt;= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;</algorithm>
      </function>
      <function name="msf_curve_check">
         <parameter name="cv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
        'CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
        'CONFIG_CONTROL_DESIGN.LINE',
        'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) &gt; 1 THEN
      RETURN(FALSE);
    ELSE
      IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
          b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
          self_intersect = UNKNOWN) THEN RETURN(TRUE);
      ELSE
        IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONIC',
            'CONFIG_CONTROL_DESIGN.LINE'] * TYPEOF(cv)) = 1 THEN
          RETURN(TRUE);
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
            RETURN(msf_curve_check(cv\curve_replica.parent_curve));
          ELSE
            IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND
                 ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'CONFIG_CONTROL_DESIGN.POLYLINE'
                IN TYPEOF(cv.basis_curve))) THEN
              RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                RETURN(msf_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND msf_surface_check(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                     THEN
                  IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT msf_surface_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT msf_curve_check(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) &gt;= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="msf_surface_check">
         <parameter name="surf">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(msf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (
            surf\offset_surface.self_intersect = FALSE)) OR (surf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(msf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN
            RETURN(msf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf))
                AND (surf\b_spline_surface.self_intersect = FALSE)) OR (
                surf\b_spline_surface.self_intersect = UNKNOWN) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN result := ?;
    ELSE
      ndim := arg.dim;
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag &gt; 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);</algorithm>
      </function>
      <function name="open_shell_reversed">
         <parameter name="a_shell">
            <typename name="open_shell"/>
         </parameter>
         <typename name="oriented_open_shell"/>
         <algorithm>LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() ||
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() ||
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);</algorithm>
      </function>
      <function name="path_reversed">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <typename name="oriented_path"/>
         <algorithm>LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN RETURN(?);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag &lt; 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="set_of_topology_reversed">
         <parameter name="a_set">
            <typename name="set_of_reversible_topology_item"/>
         </parameter>
         <typename name="set_of_reversible_topology_item"/>
         <algorithm>LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);</algorithm>
      </function>
      <function name="shell_reversed">
         <parameter name="a_shell">
            <typename name="shell"/>
         </parameter>
         <typename name="shell"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] &lt;= 0 THEN result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);</algorithm>
      </function>
      <function name="topology_reversed">
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);</algorithm>
      </function>
      <function name="unique_version_change_order">
         <parameter name="c">
            <typename name="action"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      ords     : action_directive := c\directed_action.directive;
      assign   : SET OF change_request := [];
      versions : SET OF product_definition_formation := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
      assign := assign + QUERY ( ara &lt;* bag_to_set(USEDIN(ords.requests[i],
          'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' +
          'ASSIGNED_ACTION_REQUEST')) | (
          'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF(ara)) );
    END_REPEAT;
    REPEAT k := 1 TO SIZEOF(assign) BY 1;
      versions := versions + assign[k].items;
    END_REPEAT;
    RETURN(SIZEOF(QUERY ( vers &lt;* versions | (NOT (SIZEOF(
        QUERY ( other_vers &lt;* (versions - vers) | (vers.of_product :=:
        other_vers.of_product) )) = 0)) )) = 0);</algorithm>
      </function>
      <function name="using_items">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <parameter name="checked_items">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="founded_item_select"/>
         <algorithm>LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z &lt;* bag_to_set(USEDIN(item,'')) | ((
        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'CONFIG_CONTROL_DESIGN.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
    'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);</algorithm>
      </function>
      <function name="valid_calendar_date">
         <parameter name="date">
            <typename name="calendar_date"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF NOT ((1 &lt;= date.day_component) AND (date.day_component &lt;= 31))
         THEN RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4      :       RETURN((1 &lt;= date.day_component) AND (date.
            day_component &lt;= 30));
      6      :       RETURN((1 &lt;= date.day_component) AND (date.
            day_component &lt;= 30));
      9      :       RETURN((1 &lt;= date.day_component) AND (date.
            day_component &lt;= 30));
      11     :       RETURN((1 &lt;= date.day_component) AND (date.
            day_component &lt;= 30));
      2      :       BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 &lt;= date.day_component) AND
            (date.day_component &lt;= 29));
          ELSE
            RETURN((1 &lt;= date.day_component) AND
            (date.day_component &lt;= 28));
          END_IF;
        END;
      OTHERWISE  :         RETURN(TRUE);
      END_CASE;</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF(['CONFIG_CONTROL_DESIGN.POLYLINE',
        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
        'CONFIG_CONTROL_DESIGN.ELLIPSE','CONFIG_CONTROL_DESIGN.CIRCLE'] *
        TYPEOF(crv)) = 1 THEN RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
        IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
            'CONFIG_CONTROL_DESIGN.PARABOLA',
            'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.
            basis_curve)) = 1 THEN RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve));
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv)
                 THEN
              RETURN(SIZEOF(QUERY ( ccs &lt;* crv\composite_curve.segments |
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="valid_measure_value">
         <parameter name="m">
            <typename name="measure_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m &gt; 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN RETURN(m &gt; 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;</algorithm>
      </function>
      <function name="valid_time">
         <parameter name="time">
            <typename name="local_time"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;</algorithm>
      </function>
      <function name="valid_units">
         <parameter name="m">
            <typename name="measure_with_unit"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(1,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,1,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,1,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,1,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,1,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,0,1) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(2,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(3,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(1,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="valid_wireframe_edge_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
        'CONFIG_CONTROL_DESIGN.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="valid_wireframe_vertex_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim &lt;&gt; arg2.dim)
         THEN RETURN(?);
    ELSE
      BEGIN
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag &gt; 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);</algorithm>
      </function>
   </schema>
</express>
