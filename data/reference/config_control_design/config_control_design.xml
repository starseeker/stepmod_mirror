<?xml version='1.0' encoding='UTF-8'?>
<!-- $Id: express2xml.js,v 1.38 2004/08/24 16:58:55 thendrix Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">
  <application
    name="express2xml2.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.38"
    source="../data/reference/config_control_design/config_control_design.exp"/>  <schema name="config_control_design">
    <type name="ahead_or_behind">
      <enumeration
        items="ahead behind">
      </enumeration>
    </type>

    <type name="approved_item">
      <select
        selectitems="product_definition_formation product_definition configuration_effectivity configuration_item security_classification change_request change start_request start_work certification contract">
      </select>
    </type>

    <type name="area_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>
    </type>

    <type name="b_spline_curve_form">
      <enumeration
        items="elliptic_arc polyline_form parabolic_arc circular_arc unspecified hyperbolic_arc">
      </enumeration>
    </type>

    <type name="b_spline_surface_form">
      <enumeration
        items="surf_of_linear_extrusion plane_surf generalised_cone toroidal_surf conical_surf spherical_surf unspecified ruled_surf surf_of_revolution cylindrical_surf quadric_surf">
      </enumeration>
    </type>

    <type name="boolean_operand">
      <select
        selectitems="solid_model">
      </select>
    </type>

    <type name="certified_item">
      <select
        selectitems="supplied_part_relationship">
      </select>
    </type>

    <type name="change_request_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="characterized_definition">
      <select
        selectitems="characterized_product_definition shape_definition">
      </select>
    </type>

    <type name="characterized_product_definition">
      <select
        selectitems="product_definition product_definition_relationship">
      </select>
    </type>

    <type name="classified_item">
      <select
        selectitems="product_definition_formation assembly_component_usage">
      </select>
    </type>

    <type name="context_dependent_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="contracted_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="count_measure">
      <builtintype
        type="NUMBER">
      </builtintype>
    </type>

    <type name="curve_on_surface">
      <select
        selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>
    </type>

    <type name="date_time_item">
      <select
        selectitems="product_definition change_request start_request change start_work approval_person_organization contract security_classification certification">
      </select>
    </type>

    <type name="date_time_select">
      <select
        selectitems="date_and_time">
      </select>
    </type>

    <type name="day_in_month_number">
      <builtintype
        type="INTEGER">
      </builtintype>
    </type>

    <type name="day_in_week_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="(1 &lt;= SELF) AND (SELF &lt;= 7)">
      </where>
    </type>

    <type name="day_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
    </type>

    <type name="descriptive_measure">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="geometric_set_select">
      <select
        selectitems="point curve surface">
      </select>
    </type>

    <type name="hour_in_day">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="(0 &lt;= SELF) AND (SELF &lt; 24)">
      </where>
    </type>

    <type name="identifier">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified">
      </enumeration>
    </type>

    <type name="label">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="length_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="list_of_reversible_topology_item">
      <aggregate
        type="LIST"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>
    </type>

    <type name="mass_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="measure_value">
      <select
        selectitems="area_measure context_dependent_measure count_measure descriptive_measure length_measure mass_measure plane_angle_measure parameter_value positive_length_measure positive_plane_angle_measure solid_angle_measure volume_measure">
      </select>
    </type>

    <type name="minute_in_hour">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="(0 &lt;= SELF) AND (SELF &lt;= 59)">
      </where>
    </type>

    <type name="month_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="(1 &lt;= SELF) AND (SELF &lt;= 12)">
      </where>
    </type>

    <type name="parameter_value">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="pcurve_or_surface">
      <select
        selectitems="pcurve surface">
      </select>
    </type>

    <type name="person_organization_item">
      <select
        selectitems="change start_work change_request start_request configuration_item product product_definition_formation product_definition contract security_classification">
      </select>
    </type>

    <type name="person_organization_select">
      <select
        selectitems="person_and_organization">
      </select>
    </type>

    <type name="plane_angle_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="positive_length_measure">
      <typename
        name="length_measure"/>
      <where
        label="WR1"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="positive_plane_angle_measure">
      <typename
        name="plane_angle_measure"/>
      <where
        label="WR1"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="preferred_surface_curve_representation">
      <enumeration
        items="pcurve_s2 pcurve_s1 curve_3d">
      </enumeration>
    </type>

    <type name="reversible_topology">
      <select
        selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item">
      </select>
    </type>

    <type name="reversible_topology_item">
      <select
        selectitems="edge path face face_bound closed_shell open_shell">
      </select>
    </type>

    <type name="second_in_minute">
      <builtintype
        type="REAL">
      </builtintype>
      <where
        label="WR1"
        expression="(0 &lt;= SELF) AND (SELF &lt; 60)">
      </where>
    </type>

    <type name="set_of_reversible_topology_item">
      <aggregate
        type="SET"
        lower="0"
        upper="?"/>
      <typename
        name="reversible_topology_item"/>
    </type>

    <type name="shape_definition">
      <select
        selectitems="product_definition_shape shape_aspect shape_aspect_relationship">
      </select>
    </type>

    <type name="shell">
      <select
        selectitems="open_shell closed_shell vertex_shell wire_shell">
      </select>
    </type>

    <type name="si_prefix">
      <enumeration
        items="exa pico mega femto atto centi nano hecto micro tera giga milli peta deci kilo deca">
      </enumeration>
    </type>

    <type name="si_unit_name">
      <enumeration
        items="hertz degree_celsius siemens sievert lux watt ohm second becquerel pascal henry tesla volt joule kelvin ampere gram steradian mole lumen gray candela farad radian newton metre weber coulomb">
      </enumeration>
    </type>

    <type name="solid_angle_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="source">
      <enumeration
        items="bought not_known made">
      </enumeration>
    </type>

    <type name="specified_item">
      <select
        selectitems="product_definition shape_aspect">
      </select>
    </type>

    <type name="start_request_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="supported_item">
      <select
        selectitems="action_directive action action_method">
      </select>
    </type>

    <type name="surface_model">
      <select
        selectitems="shell_based_surface_model">
      </select>
    </type>

    <type name="text">
      <builtintype
        type="STRING">
      </builtintype>
    </type>

    <type name="transformation">
      <select
        selectitems="item_defined_transformation functionally_defined_transformation">
      </select>
    </type>

    <type name="transition_code">
      <enumeration
        items="discontinuous cont_same_gradient_same_curvature cont_same_gradient continuous">
      </enumeration>
    </type>

    <type name="trimming_preference">
      <enumeration
        items="parameter unspecified cartesian">
      </enumeration>
    </type>

    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value">
      </select>
    </type>

    <type name="unit">
      <select
        selectitems="named_unit">
      </select>
    </type>

    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>
    </type>

    <type name="volume_measure">
      <builtintype
        type="REAL">
      </builtintype>
    </type>

    <type name="week_in_year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="(1 &lt;= SELF) AND (SELF &lt;= 53)">
      </where>
    </type>

    <type name="wireframe_model">
      <select
        selectitems="shell_based_wireframe_model edge_based_wireframe_model">
      </select>
    </type>

    <type name="work_item">
      <select
        selectitems="product_definition_formation">
      </select>
    </type>

    <type name="year_number">
      <builtintype
        type="INTEGER">
      </builtintype>
    </type>

    <entity
      name="action">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="chosen_method">
        <typename
          name="action_method"/>
      </explicit>
    </entity>

    <entity
      name="action_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_action">
        <typename
          name="action"/>
      </explicit>
    </entity>

    <entity
      name="action_directive">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="analysis">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="comment">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="requests">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_method">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="consequence">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="action_request_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_action_request">
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_request_solution">
      <explicit
        name="method">
        <typename
          name="action_method"/>
      </explicit>
      <explicit
        name="request">
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_request_status">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="assigned_request">
        <typename
          name="versioned_action_request"/>
      </explicit>
    </entity>

    <entity
      name="action_status">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="assigned_action">
        <typename
          name="executed_action"/>
      </explicit>
    </entity>

    <entity
      name="address">
      <explicit
        name="internal_location"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="street"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_box"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="town"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="region"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="postal_code"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="country"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="facsimile_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telephone_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="electronic_mail_address"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="telex_number"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <where
        label="WR1"
        expression="EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number)">
      </where>
    </entity>

    <entity
      name="advanced_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* SELF.items | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP','CONFIG_CONTROL_DESIGN.FACETED_BREP','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)))= 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* SELF.items | SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) =1)) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) | NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb, 'CONFIG_CONTROL_DESIGN') | NOT (SIZEOF (QUERY(csf &lt;* csh.cfs_faces | NOT('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(csf)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (brv &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) | NOT (SIZEOF (QUERY (csh &lt;* brv\brep_with_voids.voids | csh\oriented_closed_shell.orientation)) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) | NOT ('CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0">
      </where>
    </entity>

    <entity
      name="advanced_face"
      supertypes="face_surface">
      <where
        label="WR1"
        expression="SIZEOF (['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE','CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE','CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF (face_geometry)) = 1">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (bnd &lt;* bounds | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP','CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF (bnd)) = 1))) = 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element)))) = 0))) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_start)) AND('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_end)))))= 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.POLYLINE','CONFIG_CONTROL_DESIGN.PCURVE','CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) | NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)))) = 0">
      </where>
      <where
        label="WR7"
        expression="(NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(face_geometry))) OR(SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.POLYLINE','CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1)">
      </where>
      <where
        label="WR8"
        expression="SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* bounds |'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (bnds.bound)) | NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (vlp_fbnds.bound\vertex_loop.loop_vertex)) AND('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))))) = 0">
      </where>
    </entity>

    <entity
      name="alternate_product_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="alternate">
        <typename
          name="product"/>
      </explicit>
      <explicit
        name="base">
        <typename
          name="product"/>
      </explicit>
      <explicit
        name="basis">
        <typename
          name="text"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="alternate"/>
        <unique.attribute
          attribute="base"/>
      </unique>
      <where
        label="WR1"
        expression="alternate :&lt;&gt;: base">
      </where>
    </entity>

    <entity
      name="application_context">
      <explicit
        name="application">
        <typename
          name="text"/>
      </explicit>
      <inverse
        name="context_elements"
        entity="application_context_element"
        attribute="frame_of_reference">
        <inverse.aggregate
          type="SET"
          lower="1"
          upper="?"/>
      </inverse>
    </entity>

    <entity
      name="application_context_element"
      super.expression="(ONEOF (product_context, product_definition_context, product_concept_context))">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="frame_of_reference">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="application_protocol_definition">
      <explicit
        name="status">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="application_interpreted_model_schema_name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="application_protocol_year">
        <typename
          name="year_number"/>
      </explicit>
      <explicit
        name="application">
        <typename
          name="application_context"/>
      </explicit>
    </entity>

    <entity
      name="approval">
      <explicit
        name="status">
        <typename
          name="approval_status"/>
      </explicit>
      <explicit
        name="level">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="approval_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_approval">
        <typename
          name="approval"/>
      </explicit>
    </entity>

    <entity
      name="approval_date_time">
      <explicit
        name="date_time">
        <typename
          name="date_time_select"/>
      </explicit>
      <explicit
        name="dated_approval">
        <typename
          name="approval"/>
      </explicit>
    </entity>

    <entity
      name="approval_person_organization">
      <explicit
        name="person_organization">
        <typename
          name="person_organization_select"/>
      </explicit>
      <explicit
        name="authorized_approval">
        <typename
          name="approval"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="approval_role"/>
      </explicit>
    </entity>

    <entity
      name="approval_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_approval">
        <typename
          name="approval"/>
      </explicit>
      <explicit
        name="related_approval">
        <typename
          name="approval"/>
      </explicit>
    </entity>

    <entity
      name="approval_role">
      <explicit
        name="role">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="approval_status">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="area_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity
      name="area_unit"
      supertypes="named_unit">
      <where
        label="WR1"
        expression="(SELF\named_unit.dimensions.length_exponent = 2) AND(SELF\named_unit.dimensions.mass_exponent = 0) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions. thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
      </where>
    </entity>

    <entity
      name="assembly_component_usage"
      super.expression="(ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence))"
      supertypes="product_definition_usage">
      <explicit
        name="reference_designator"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
    </entity>

    <entity
      name="assembly_component_usage_substitute">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="base">
        <typename
          name="assembly_component_usage"/>
      </explicit>
      <explicit
        name="substitute">
        <typename
          name="assembly_component_usage"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="base"/>
        <unique.attribute
          attribute="substitute"/>
      </unique>
      <where
        label="WR1"
        expression="base.relating_product_definition :=: substitute. relating_product_definition">
      </where>
      <where
        label="WR2"
        expression="base :&lt;&gt;: substitute">
      </where>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis),direction([0,0,1]))">
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\placement.location.dim = 3">
      </where>
      <where
        label="WR2"
        expression="(NOT EXISTS(axis)) OR (axis.dim = 3)">
      </where>
      <where
        label="WR3"
        expression="(NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3)">
      </where>
      <where
        label="WR4"
        expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction))) OR (cross_product(axis,ref_direction).magnitude &gt; 0)">
      </where>
    </entity>

    <entity
      name="b_spline_curve"
      super.expression="(ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve)"
      supertypes="bounded_curve">
      <explicit
        name="degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename
          name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(control_points_list,0, upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="cartesian_point"/>
      </derived>
      <where
        label="WR1"
        expression="('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="b_spline_curve_with_knots"
      supertypes="b_spline_curve">
      <explicit
        name="knot_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(degree,upper_index_on_knots, upper_index_on_control_points,knot_multiplicities,knots)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(knot_multiplicities) = upper_index_on_knots">
      </where>
    </entity>

    <entity
      name="b_spline_surface"
      super.expression="(ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface)"
      supertypes="bounded_surface">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="surface_form">
        <typename
          name="b_spline_surface_form"/>
      </explicit>
      <explicit
        name="u_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="v_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array(control_points_list,0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="WR1"
        expression="('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF)) OR('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="b_spline_surface_with_knots"
      supertypes="b_spline_surface">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities, u_knots)">
      </where>
      <where
        label="WR2"
        expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities, v_knots)">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(u_multiplicities) = knot_u_upper">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(v_multiplicities) = knot_v_upper">
      </where>
    </entity>

    <entity
      name="bezier_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="bezier_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="boundary_curve"
      supertypes="composite_curve_on_surface">
      <where
        label="WR1"
        expression="SELF\composite_curve.closed_curve">
      </where>
    </entity>

    <entity
      name="bounded_curve"
      super.expression="(ONEOF (polyline, b_spline_curve, trimmed_curve, composite_curve))"
      supertypes="curve">
    </entity>

    <entity
      name="bounded_surface"
      super.expression="(ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))"
      supertypes="surface">
    </entity>

    <entity
      name="brep_with_voids"
      supertypes="manifold_solid_brep">
      <explicit
        name="voids">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="oriented_closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="calendar_date"
      supertypes="date">
      <explicit
        name="day_component">
        <typename
          name="day_in_month_number"/>
      </explicit>
      <explicit
        name="month_component">
        <typename
          name="month_in_year_number"/>
      </explicit>
      <where
        label="WR1"
        expression="valid_calendar_date(SELF)">
      </where>
    </entity>

    <entity
      name="cartesian_point"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(cartesian_transformation_operator_3d)"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale,1)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="scl &gt; 0">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3, SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2, axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\cartesian_transformation_operator.dim = 3">
      </where>
    </entity>

    <entity
      name="cc_design_approval"
      supertypes="approval_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="approved_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_certification"
      supertypes="certification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="certified_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_contract"
      supertypes="contract_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="contracted_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_date_and_time_assignment"
      supertypes="date_and_time_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="date_time_item"/>
      </explicit>
      <where
        label="WR1"
        expression="cc_design_date_time_correlation(SELF)">
      </where>
    </entity>

    <entity
      name="cc_design_person_and_organization_assignment"
      supertypes="person_and_organization_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="person_organization_item"/>
      </explicit>
      <where
        label="WR1"
        expression="cc_design_person_and_organization_correlation(SELF)">
      </where>
    </entity>

    <entity
      name="cc_design_security_classification"
      supertypes="security_classification_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="classified_item"/>
      </explicit>
    </entity>

    <entity
      name="cc_design_specification_reference"
      supertypes="document_reference">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="specified_item"/>
      </explicit>
    </entity>

    <entity
      name="certification">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="certification_type"/>
      </explicit>
    </entity>

    <entity
      name="certification_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_certification">
        <typename
          name="certification"/>
      </explicit>
    </entity>

    <entity
      name="certification_type">
      <explicit
        name="description">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="change"
      supertypes="action_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="work_item"/>
      </explicit>
    </entity>

    <entity
      name="change_request"
      supertypes="action_request_assignment">
      <explicit
        name="items">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="change_request_item"/>
      </explicit>
    </entity>

    <entity
      name="circle"
      supertypes="conic">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="closed_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="composite_curve"
      supertypes="bounded_curve">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt; discontinuous">
        <builtintype
          type="LOGICAL"/>
      </derived>
      <where
        label="WR1"
        expression="((NOT closed_curve) AND(SIZEOF (QUERY (temp &lt;* segments | temp.transition = discontinuous)) = 1)) OR((closed_curve) AND(SIZEOF (QUERY (temp &lt;* segments | temp.transition = discontinuous)) = 0))">
      </where>
    </entity>

    <entity
      name="composite_curve_on_surface"
      super.expression="(boundary_curve)"
      supertypes="composite_curve">
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="0"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(basis_surface) &gt; 0">
      </where>
      <where
        label="WR2"
        expression="constraints_composite_curve_on_surface(SELF)">
      </where>
    </entity>

    <entity
      name="composite_curve_segment">
      <explicit
        name="transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve)">
      </where>
    </entity>

    <entity
      name="configuration_design">
      <explicit
        name="configuration">
        <typename
          name="configuration_item"/>
      </explicit>
      <explicit
        name="design">
        <typename
          name="product_definition_formation"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="configuration"/>
        <unique.attribute
          attribute="design"/>
      </unique>
    </entity>

    <entity
      name="configuration_effectivity"
      supertypes="product_definition_effectivity">
      <explicit
        name="configuration">
        <typename
          name="configuration_design"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="configuration"/>
        <unique.attribute
          attribute="usage"/>
        <unique.attribute
          attribute="id"/>
      </unique>
      <where
        label="WR1"
        expression="SELF\product_definition_effectivity.usage. relating_product_definition IN(USEDIN (SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +'PRODUCT_DEFINITION.FORMATION') + relatives_of_product_definitions (bag_to_set (USEDIN(SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +'PRODUCT_DEFINITION.FORMATION')), 'CONFIG_CONTROL_DESIGN.' +'PRODUCT_DEFINITION_USAGE'))">
      </where>
      <where
        label="WR2"
        expression="'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF\product_definition_effectivity.usage)">
      </where>
    </entity>

    <entity
      name="configuration_item">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="item_concept">
        <typename
          name="product_concept"/>
      </explicit>
      <explicit
        name="purpose"
        optional="YES">
        <typename
          name="label"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="id"/>
      </unique>
    </entity>

    <entity
      name="conic"
      super.expression="(ONEOF (circle, ellipse, hyperbola, parabola))"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
    </entity>

    <entity
      name="conical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="radius &gt;= 0">
      </where>
    </entity>

    <entity
      name="connected_edge_set"
      supertypes="topological_representation_item">
      <explicit
        name="ces_edges">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="edge"/>
      </explicit>
    </entity>

    <entity
      name="connected_face_set"
      super.expression="(ONEOF (closed_shell, open_shell))"
      supertypes="topological_representation_item">
      <explicit
        name="cfs_faces">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
      </explicit>
    </entity>

    <entity
      name="context_dependent_shape_representation">
      <explicit
        name="representation_relation">
        <typename
          name="shape_representation_relationship"/>
      </explicit>
      <explicit
        name="represented_product_relation">
        <typename
          name="product_definition_shape"/>
      </explicit>
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition)">
      </where>
    </entity>

    <entity
      name="context_dependent_unit"
      supertypes="named_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="contract">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="purpose">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="contract_type"/>
      </explicit>
    </entity>

    <entity
      name="contract_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_contract">
        <typename
          name="contract"/>
      </explicit>
    </entity>

    <entity
      name="contract_type">
      <explicit
        name="description">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="conversion_based_unit"
      supertypes="named_unit">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="conversion_factor">
        <typename
          name="measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="coordinated_universal_time_offset">
      <explicit
        name="hour_offset">
        <typename
          name="hour_in_day"/>
      </explicit>
      <explicit
        name="minute_offset"
        optional="YES">
        <typename
          name="minute_in_hour"/>
      </explicit>
      <explicit
        name="sense">
        <typename
          name="ahead_or_behind"/>
      </explicit>
    </entity>

    <entity
      name="curve"
      super.expression="(ONEOF (line, conic, pcurve, surface_curve, offset_curve_3d, curve_replica))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="curve_bounded_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="boundary_curve"/>
      </explicit>
      <explicit
        name="implicit_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="NOT (implicit_outer AND('CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(boundaries)))">
      </where>
      <where
        label="WR2"
        expression="(NOT implicit_outer) OR('CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN TYPEOF(basis_surface))">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (temp &lt;* boundaries |'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) &lt;= 1">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (temp &lt;* boundaries | temp\composite_curve_on_surface.basis_surface[1] :&lt;&gt;: SELF.basis_surface)) = 0">
      </where>
    </entity>

    <entity
      name="curve_replica"
      supertypes="curve">
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="WR1"
        expression="transformation.dim = parent_curve.dim">
      </where>
      <where
        label="WR2"
        expression="acyclic_curve_replica(SELF,parent_curve)">
      </where>
    </entity>

    <entity
      name="cylindrical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="date"
      super.expression="(ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date))">
      <explicit
        name="year_component">
        <typename
          name="year_number"/>
      </explicit>
    </entity>

    <entity
      name="date_and_time">
      <explicit
        name="date_component">
        <typename
          name="date"/>
      </explicit>
      <explicit
        name="time_component">
        <typename
          name="local_time"/>
      </explicit>
    </entity>

    <entity
      name="date_and_time_assignment"
      abstract.supertype="YES">
      <explicit
        name="assigned_date_and_time">
        <typename
          name="date_and_time"/>
      </explicit>
      <explicit
        name="role">
        <typename
          name="date_time_role"/>
      </explicit>
    </entity>

    <entity
      name="date_time_role">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="dated_effectivity"
      supertypes="effectivity">
      <explicit
        name="effectivity_start_date">
        <typename
          name="date_and_time"/>
      </explicit>
      <explicit
        name="effectivity_end_date"
        optional="YES">
        <typename
          name="date_and_time"/>
      </explicit>
    </entity>

    <entity
      name="definitional_representation"
      supertypes="representation">
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (SELF\representation.context_of_items)">
      </where>
    </entity>

    <entity
      name="degenerate_pcurve"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(reference_to_curve\representation.items) = 1">
      </where>
      <where
        label="WR2"
        expression="'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (reference_to_curve\representation.items[1])">
      </where>
      <where
        label="WR3"
        expression="reference_to_curve\representation.items[1]\ geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="degenerate_toroidal_surface"
      supertypes="toroidal_surface">
      <explicit
        name="select_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="wr1"
        expression="(major_radius &lt; minor_radius)">
      </where>
    </entity>

    <entity
      name="design_context"
      supertypes="product_definition_context">
      <where
        label="WR1"
        expression="SELF.life_cycle_stage = 'design'">
      </where>
    </entity>

    <entity
      name="design_make_from_relationship"
      supertypes="product_definition_relationship">
    </entity>

    <entity
      name="dimensional_exponents">
      <explicit
        name="length_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="mass_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="time_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="electric_current_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="thermodynamic_temperature_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="amount_of_substance_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="luminous_intensity_exponent">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="directed_action"
      supertypes="executed_action">
      <explicit
        name="directive">
        <typename
          name="action_directive"/>
      </explicit>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (tmp &lt;* direction_ratios | tmp &lt;&gt; 0)) &gt; 0">
      </where>
    </entity>

    <entity
      name="document">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="kind">
        <typename
          name="document_type"/>
      </explicit>
      <unique
        label="UR1">
        <unique.attribute
          attribute="id"/>
      </unique>
    </entity>

    <entity
      name="document_reference"
      abstract.supertype="YES">
      <explicit
        name="assigned_document">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="source">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="document_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_document">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="related_document">
        <typename
          name="document"/>
      </explicit>
    </entity>

    <entity
      name="document_type">
      <explicit
        name="product_data_type">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <entity
      name="document_usage_constraint">
      <explicit
        name="source">
        <typename
          name="document"/>
      </explicit>
      <explicit
        name="subject_element">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="subject_element_value">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="document_with_class"
      supertypes="document">
      <explicit
        name="class">
        <typename
          name="identifier"/>
      </explicit>
    </entity>

    <entity
      name="edge"
      super.expression="(ONEOF (edge_curve, oriented_edge))"
      supertypes="topological_representation_item">
      <explicit
        name="edge_start">
        <typename
          name="vertex"/>
      </explicit>
      <explicit
        name="edge_end">
        <typename
          name="vertex"/>
      </explicit>
    </entity>

    <entity
      name="edge_based_wireframe_model"
      supertypes="geometric_representation_item">
      <explicit
        name="ebwm_boundary">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="connected_edge_set"/>
      </explicit>
    </entity>

    <entity
      name="edge_based_wireframe_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt;= 1">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges | NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (edges)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (pline_edges &lt;* QUERY (edges &lt;* eb.ces_edges |'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) | NOT (SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points)&gt; 2))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges | NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (edges.edge_end))))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges | NOT (valid_wireframe_edge_curve(edges\edge_curve.edge_geometry, 'CONFIG_CONTROL_DESIGN')))) =0))) = 0))) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges | NOT((valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')) AND(valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR8"
        expression="SIZEOF (QUERY (ebwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary | NOT (SIZEOF (QUERY (con_edges &lt;* QUERY (edges &lt;* eb.ces_edges |'CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF (edges\edge_curve.edge_geometry)) | NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (con_edges\edge_curve.edge_geometry\conic.position)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR9"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) | NOT ('CONFIG_CONTROL_DESIGN.' +'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))= 0">
      </where>
    </entity>

    <entity
      name="edge_curve"
      supertypes="edge geometric_representation_item">
      <explicit
        name="edge_geometry">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="edge_loop"
      supertypes="loop path">
      <derived
        name="ne"
        expression="SIZEOF(SELF\path.edge_list)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].edge_end">
      </where>
    </entity>

    <entity
      name="effectivity"
      super.expression="(ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity))">
      <explicit
        name="id">
        <typename
          name="identifier"/>
      </explicit>
    </entity>

    <entity
      name="elementary_surface"
      super.expression="(ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))"
      supertypes="surface">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
    </entity>

    <entity
      name="ellipse"
      supertypes="conic">
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="evaluated_degenerate_pcurve"
      supertypes="degenerate_pcurve">
      <explicit
        name="equivalent_point">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="executed_action"
      supertypes="action">
    </entity>

    <entity
      name="face"
      super.expression="(ONEOF (face_surface, oriented_face))"
      supertypes="topological_representation_item">
      <explicit
        name="bounds">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face_bound"/>
      </explicit>
      <where
        label="WR1"
        expression="NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)))">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (temp &lt;* bounds |'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp))) &lt;= 1">
      </where>
    </entity>

    <entity
      name="face_bound"
      supertypes="topological_representation_item">
      <explicit
        name="bound">
        <typename
          name="loop"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="face_outer_bound"
      supertypes="face_bound">
    </entity>

    <entity
      name="face_surface"
      supertypes="face geometric_representation_item">
      <explicit
        name="face_geometry">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="faceted_brep"
      supertypes="manifold_solid_brep">
    </entity>

    <entity
      name="faceted_brep_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* items | NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* items | SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1)) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (fbrep &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) | NOT (SIZEOF (QUERY (csh &lt;* msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') | NOT (SIZEOF (QUERY (fcs &lt;* csh.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fcs)) AND(('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF(fcs\face_surface.face_geometry)) AND('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\plane.position.location))))))= 0))) = 0))) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (fbrep &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) | NOT (SIZEOF (QUERY (csh &lt;* msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') | NOT (SIZEOF (QUERY (fcs &lt;* csh.cfs_faces | NOT (SIZEOF (QUERY (bnds &lt;* fcs.bounds |'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1)))= 0))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (brv &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) | NOT (SIZEOF (QUERY (csh &lt;* brv\brep_with_voids.voids | csh\oriented_closed_shell.orientation)) = 0))) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) | NOT ('CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))= 0">
      </where>
    </entity>

    <entity
      name="functionally_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="geometric_curve_set"
      supertypes="geometric_set">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (temp &lt;* SELF\geometric_set.elements |'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(temp))) = 0">
      </where>
    </entity>

    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, vertex_point, poly_loop, solid_model, shell_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) | NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0">
      </where>
    </entity>

    <entity
      name="geometric_set"
      super.expression="(geometric_curve_set)"
      supertypes="geometric_representation_item">
      <explicit
        name="elements">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="geometric_set_select"/>
      </explicit>
    </entity>

    <entity
      name="geometrically_bounded_surface_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* items | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* items | SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (it)) | NOT ('CONFIG_CONTROL_DESIGN.' +'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))= 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (pnt &lt;* QUERY (gsel &lt;* gs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (gsel)) | NOT (gbsf_check_point(pnt, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cv &lt;* QUERY (gsel &lt;* gs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (gsel)) | NOT (gbsf_check_curve(cv, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (sf &lt;* QUERY (gsel &lt;* gs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF (gsel)) | NOT (gbsf_check_surface(sf, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0">
      </where>
    </entity>

    <entity
      name="geometrically_bounded_wireframe_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | SIZEOF(['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt;= 1">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (curv &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (elem)) | NOT (valid_geometrically_bounded_wf_curve(curv, 'CONFIG_CONTROL_DESIGN')))) = 0))) =0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (pnts &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (elem)) | NOT (valid_geometrically_bounded_wf_point(pnts, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cnc &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF (elem)) | NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\conic.position)))) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (pline &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(elem)) | NOT (SIZEOF (pline\polyline.points) &gt; 2))) = 0))) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) | NOT ('CONFIG_CONTROL_DESIGN.' +'GEOMETRICALLY_BOUNDED_WIREFRAME_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))= 0">
      </where>
    </entity>

    <entity
      name="global_uncertainty_assigned_context"
      supertypes="representation_context">
      <explicit
        name="uncertainty">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="uncertainty_measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="global_unit_assigned_context"
      supertypes="representation_context">
      <explicit
        name="units">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="unit"/>
      </explicit>
    </entity>

    <entity
      name="hyperbola"
      supertypes="conic">
      <explicit
        name="semi_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="intersection_curve"
      supertypes="surface_curve">
      <where
        label="WR1"
        expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
      </where>
      <where
        label="WR2"
        expression="associated_surface(SELF\surface_curve.associated_geometry[1])&lt;&gt; associated_surface(SELF\surface_curve.associated_geometry[2])">
      </where>
    </entity>

    <entity
      name="item_defined_transformation">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="transform_item_1">
        <typename
          name="representation_item"/>
      </explicit>
      <explicit
        name="transform_item_2">
        <typename
          name="representation_item"/>
      </explicit>
    </entity>

    <entity
      name="length_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity
      name="length_unit"
      supertypes="named_unit">
      <where
        label="WR1"
        expression="(SELF\named_unit.dimensions.length_exponent = 1) AND(SELF\named_unit.dimensions.mass_exponent = 0) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
      </where>
    </entity>

    <entity
      name="line"
      supertypes="curve">
      <explicit
        name="pnt">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename
          name="vector"/>
      </explicit>
      <where
        label="WR1"
        expression="dir.dim = pnt.dim">
      </where>
    </entity>

    <entity
      name="local_time">
      <explicit
        name="hour_component">
        <typename
          name="hour_in_day"/>
      </explicit>
      <explicit
        name="minute_component"
        optional="YES">
        <typename
          name="minute_in_hour"/>
      </explicit>
      <explicit
        name="second_component"
        optional="YES">
        <typename
          name="second_in_minute"/>
      </explicit>
      <explicit
        name="zone">
        <typename
          name="coordinated_universal_time_offset"/>
      </explicit>
      <where
        label="WR1"
        expression="valid_time (SELF)">
      </where>
    </entity>

    <entity
      name="loop"
      super.expression="(ONEOF (vertex_loop, edge_loop, poly_loop))"
      supertypes="topological_representation_item">
    </entity>

    <entity
      name="lot_effectivity"
      supertypes="effectivity">
      <explicit
        name="effectivity_lot_id">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="effectivity_lot_size">
        <typename
          name="measure_with_unit"/>
      </explicit>
    </entity>

    <entity
      name="manifold_solid_brep"
      supertypes="solid_model">
      <explicit
        name="outer">
        <typename
          name="closed_shell"/>
      </explicit>
    </entity>

    <entity
      name="manifold_surface_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (QUERY (it &lt;* items | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (it &lt;* items | SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL','CONFIG_CONTROL_DESIGN.MAPPED ITEM'] * TYPEOF (it)) = 1)) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.MAPPED ITEM' IN TYPEOF (it)) | NOT ('CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))= 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (sh &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.OPEN_SHELL','CONFIG_CONTROL_DESIGN.CLOSED_SHELL']* TYPEOF (sh)) = 1))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.FACE_SURFACE','CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF (fa)) = 1))) = 0)))= 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (f_sf &lt;* QUERY (fa &lt;* cfs.cfs_faces |'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fa)) | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (f_sf)) OR(SIZEOF (['CONFIG_CONTROL_DESIGN.OFFSET_SURFACE','CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'] * TYPEOF(f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(basis_surface_check(fa\face_surface.face_geometry,'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR8"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (bnds &lt;* fa.bounds | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP','CONFIG_CONTROL_DESIGN.VERTEX_LOOP']* TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR9"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items|'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element))))= 0))) = 0)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR10"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |'CONFIG_CONTROL_DESIGN.EDGE LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe_cv &lt;* QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element)) | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.CURVE_REPLICA','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D','CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry))= 1))) = 0))) = 0)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR11"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT (basis_curve_check (oe.edge_element\edge_curve.edge_geometry,'CONFIG_CONTROL_DESIGN')))) = 0))) = 0)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR12"
        expression="SIZEOF (QUERY(sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list| NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_start)) AND('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0">
      </where>
      <where
        label="WR13"
        expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (cfs &lt;* sbsm\shell_based_surface_model.sbsm_boundary | NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces | NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa)) OR(SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa. bounds |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) | NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list | NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT','CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE','CONFIG_CONTROL_DESIGN.POINT_ON_CURVE','CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1) AND(SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT','CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE','CONFIG_CONTROL_DESIGN.POINT_ON_CURVE','CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1)))) = 0))) = 0)))) = 0))) = 0))) = 0">
      </where>
    </entity>

    <entity
      name="mapped_item"
      supertypes="representation_item">
      <explicit
        name="mapping_source">
        <typename
          name="representation_map"/>
      </explicit>
      <explicit
        name="mapping_target">
        <typename
          name="representation_item"/>
      </explicit>
      <where
        label="WR1"
        expression="acyclic_mapped_representation(using_representations(SELF), [SELF])">
      </where>
    </entity>

    <entity
      name="mass_measure_with_unit"
      supertypes="measure_with_unit">
      <where
        label="WR1"
        expression="'CONFIG_CONTROL_DESIGN.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)">
      </where>
    </entity>

    <entity
      name="mass_unit"
      supertypes="named_unit">
      <where
        label="WR1"
        expression="(SELF\named_unit.dimensions.length_exponent = 0) AND(SELF\named_unit.dimensions.mass_exponent = 1) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
      </where>
    </entity>

    <entity
      name="measure_with_unit"
      super.expression="(ONEOF (length_measure_with_unit, mass_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit))">
      <explicit
        name="value_component">
        <typename
          name="measure_value"/>
      </explicit>
      <explicit
        name="unit_component">
        <typename
          name="unit"/>
      </explicit>
      <where
        label="WR1"
        expression="valid_units(SELF)">
      </where>
    </entity>

    <entity
      name="mechanical_context"
      supertypes="product_context">
      <where
        label="WR1"
        expression="SELF.discipline_type = 'mechanical'">
      </where>
    </entity>

    <entity
      name="named_unit"
      super.expression="(ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit))">
      <explicit
        name="dimensions">
        <typename
          name="dimensional_exponents"/>
      </explicit>
    </entity>

    <entity
      name="next_assembly_usage_occurrence"
      supertypes="assembly_component_usage">
    </entity>

    <entity
      name="offset_curve_3d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="ref_direction">
        <typename
          name="direction"/>
      </explicit>
      <where
        label="WR1"
        expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)">
      </where>
    </entity>

    <entity
      name="offset_surface"
      supertypes="surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="open_shell"
      supertypes="connected_face_set">
    </entity>

    <entity
      name="ordinal_date"
      supertypes="date">
      <explicit
        name="day_component">
        <typename
          name="day_in_year_number"/>
      </explicit>
      <where
        label="WR1"
        expression="(NOT leap_year(SELF.year_component) AND {1 &lt;= day_component &lt;= 365}) OR(leap_year(SELF.year_component) AND {1 &lt;= day_component &lt;= 366})">
      </where>
    </entity>

    <entity
      name="organization">
      <explicit
        name="id"
        optional="YES">
        <typename
          name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organization_relationship">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="relating_organization">
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="related_organization">
        <typename
          name="organization"/>
      </explicit>
    </entity>

    <entity
      name="organizational_address"
      supertypes="address">
      <explicit
        name="organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="organizational_project">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
      <explicit
        name="responsible_organizations">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="organization"/>
      </explicit>
    </entity>

    <entity
      name="oriented_closed_shell"
      supertypes="closed_shell">
      <explicit
        name="closed_shell_element">
        <typename
          name="closed_shell"/>
      </explicit>
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="cfs_faces"
        expression="conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces)">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="face"/>
        <redeclaration
          entity-ref="connected_face_set"/>
        </derived>
        <where
          label="WR1"
          expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element))">
        </where>
      </entity>

      <entity
        name="oriented_edge"
        supertypes="edge">
        <explicit
          name="edge_element">
          <typename
            name="edge"/>
        </explicit>
        <explicit
          name="orientation">
          <builtintype
            type="BOOLEAN"/>
        </explicit>
        <derived
          name="edge_start"
          expression="boolean_choose(SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end)">
          <typename
            name="vertex"/>
          <redeclaration
            entity-ref="edge"/>
          </derived>
          <derived
            name="edge_end"
            expression="boolean_choose(SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start)">
            <typename
              name="vertex"/>
            <redeclaration
              entity-ref="edge"/>
            </derived>
            <where
              label="WR1"
              expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element))">
            </where>
          </entity>

          <entity
            name="oriented_face"
            supertypes="face">
            <explicit
              name="face_element">
              <typename
                name="face"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <derived
              name="bounds"
              expression="conditional_reverse(SELF.orientation, SELF.face_element.bounds)">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="face_bound"/>
              <redeclaration
                entity-ref="face"/>
              </derived>
              <where
                label="WR1"
                expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF.face_element))">
              </where>
            </entity>

            <entity
              name="oriented_open_shell"
              supertypes="open_shell">
              <explicit
                name="open_shell_element">
                <typename
                  name="open_shell"/>
              </explicit>
              <explicit
                name="orientation">
                <builtintype
                  type="BOOLEAN"/>
              </explicit>
              <derived
                name="cfs_faces"
                expression="conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces)">
                <aggregate
                  type="SET"
                  lower="1"
                  upper="?"/>
                <typename
                  name="face"/>
                <redeclaration
                  entity-ref="connected_face_set"/>
                </derived>
                <where
                  label="WR1"
                  expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF (SELF.open_shell_element))">
                </where>
              </entity>

              <entity
                name="oriented_path"
                supertypes="path">
                <explicit
                  name="path_element">
                  <typename
                    name="path"/>
                </explicit>
                <explicit
                  name="orientation">
                  <builtintype
                    type="BOOLEAN"/>
                </explicit>
                <derived
                  name="edge_list"
                  expression="conditional_reverse(SELF.orientation, SELF.path_element.edge_list)">
                  <aggregate
                    type="LIST"
                    lower="1"
                    upper="?"
                    unique="YES"/>
                  <typename
                    name="oriented_edge"/>
                  <redeclaration
                    entity-ref="path"/>
                  </derived>
                  <where
                    label="WR1"
                    expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF (SELF.path_element))">
                  </where>
                </entity>

                <entity
                  name="outer_boundary_curve"
                  supertypes="boundary_curve">
                </entity>

                <entity
                  name="parabola"
                  supertypes="conic">
                  <explicit
                    name="focal_dist">
                    <typename
                      name="length_measure"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="focal_dist &lt;&gt; 0">
                  </where>
                </entity>

                <entity
                  name="parametric_representation_context"
                  supertypes="representation_context">
                </entity>

                <entity
                  name="path"
                  super.expression="(ONEOF (edge_loop, oriented_path))"
                  supertypes="topological_representation_item">
                  <explicit
                    name="edge_list">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"
                      unique="YES"/>
                    <typename
                      name="oriented_edge"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="path_head_to_tail (SELF)">
                  </where>
                </entity>

                <entity
                  name="pcurve"
                  supertypes="curve">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="reference_to_curve">
                    <typename
                      name="definitional_representation"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="SIZEOF (reference_to_curve\representation.items) = 1">
                  </where>
                  <where
                    label="WR2"
                    expression="'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(reference_to_curve\representation.items[1])">
                  </where>
                  <where
                    label="WR3"
                    expression="reference_to_curve\representation.items[1]\ geometric_representation_item.dim = 2">
                  </where>
                </entity>

                <entity
                  name="person">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="last_name"
                    optional="YES">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="first_name"
                    optional="YES">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="middle_names"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="prefix_titles"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="suffix_titles"
                    optional="YES">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="label"/>
                  </explicit>
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="id"/>
                  </unique>
                  <where
                    label="WR1"
                    expression="EXISTS (last_name) OR EXISTS (first_name)">
                  </where>
                </entity>

                <entity
                  name="person_and_organization">
                  <explicit
                    name="the_person">
                    <typename
                      name="person"/>
                  </explicit>
                  <explicit
                    name="the_organization">
                    <typename
                      name="organization"/>
                  </explicit>
                </entity>

                <entity
                  name="person_and_organization_assignment"
                  abstract.supertype="YES">
                  <explicit
                    name="assigned_person_and_organization">
                    <typename
                      name="person_and_organization"/>
                  </explicit>
                  <explicit
                    name="role">
                    <typename
                      name="person_and_organization_role"/>
                  </explicit>
                </entity>

                <entity
                  name="person_and_organization_role">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="personal_address"
                  supertypes="address">
                  <explicit
                    name="people">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="person"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                </entity>

                <entity
                  name="placement"
                  super.expression="(ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="location">
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="plane"
                  supertypes="elementary_surface">
                </entity>

                <entity
                  name="plane_angle_measure_with_unit"
                  supertypes="measure_with_unit">
                  <where
                    label="WR1"
                    expression="'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)">
                  </where>
                </entity>

                <entity
                  name="plane_angle_unit"
                  supertypes="named_unit">
                  <where
                    label="WR1"
                    expression="(SELF\named_unit.dimensions.length_exponent = 0) AND(SELF\named_unit.dimensions.mass_exponent = 0) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
                  </where>
                </entity>

                <entity
                  name="point"
                  super.expression="(ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve))"
                  supertypes="geometric_representation_item">
                </entity>

                <entity
                  name="point_on_curve"
                  supertypes="point">
                  <explicit
                    name="basis_curve">
                    <typename
                      name="curve"/>
                  </explicit>
                  <explicit
                    name="point_parameter">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                </entity>

                <entity
                  name="point_on_surface"
                  supertypes="point">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="point_parameter_u">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="point_parameter_v">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                </entity>

                <entity
                  name="point_replica"
                  supertypes="point">
                  <explicit
                    name="parent_pt">
                    <typename
                      name="point"/>
                  </explicit>
                  <explicit
                    name="transformation">
                    <typename
                      name="cartesian_transformation_operator"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="transformation.dim = parent_pt.dim">
                  </where>
                  <where
                    label="WR2"
                    expression="acyclic_point_replica(SELF,parent_pt)">
                  </where>
                </entity>

                <entity
                  name="poly_loop"
                  supertypes="loop geometric_representation_item">
                  <explicit
                    name="polygon">
                    <aggregate
                      type="LIST"
                      lower="3"
                      upper="?"
                      unique="YES"/>
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="polyline"
                  supertypes="bounded_curve">
                  <explicit
                    name="points">
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="?"/>
                    <typename
                      name="cartesian_point"/>
                  </explicit>
                </entity>

                <entity
                  name="product">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="frame_of_reference">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="product_context"/>
                  </explicit>
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="id"/>
                  </unique>
                </entity>

                <entity
                  name="product_category">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description"
                    optional="YES">
                    <typename
                      name="text"/>
                  </explicit>
                </entity>

                <entity
                  name="product_category_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="category">
                    <typename
                      name="product_category"/>
                  </explicit>
                  <explicit
                    name="sub_category">
                    <typename
                      name="product_category"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="acyclic_product_category_relationship(SELF,[SELF.sub_category])">
                  </where>
                </entity>

                <entity
                  name="product_concept">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="market_context">
                    <typename
                      name="product_concept_context"/>
                  </explicit>
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="id"/>
                  </unique>
                </entity>

                <entity
                  name="product_concept_context"
                  supertypes="application_context_element">
                  <explicit
                    name="market_segment_type">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_context"
                  supertypes="application_context_element">
                  <explicit
                    name="discipline_type">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="formation">
                    <typename
                      name="product_definition_formation"/>
                  </explicit>
                  <explicit
                    name="frame_of_reference">
                    <typename
                      name="product_definition_context"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_context"
                  supertypes="application_context_element">
                  <explicit
                    name="life_cycle_stage">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_effectivity"
                  supertypes="effectivity">
                  <explicit
                    name="usage">
                    <typename
                      name="product_definition_relationship"/>
                  </explicit>
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="usage"/>
                    <unique.attribute
                      attribute="id"/>
                  </unique>
                </entity>

                <entity
                  name="product_definition_formation">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="of_product">
                    <typename
                      name="product"/>
                  </explicit>
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="id"/>
                    <unique.attribute
                      attribute="of_product"/>
                  </unique>
                </entity>

                <entity
                  name="product_definition_formation_with_specified_source"
                  supertypes="product_definition_formation">
                  <explicit
                    name="make_or_buy">
                    <typename
                      name="source"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_relationship">
                  <explicit
                    name="id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="relating_product_definition">
                    <typename
                      name="product_definition"/>
                  </explicit>
                  <explicit
                    name="related_product_definition">
                    <typename
                      name="product_definition"/>
                  </explicit>
                </entity>

                <entity
                  name="product_definition_shape"
                  supertypes="property_definition">
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="definition"/>
                  </unique>
                  <where
                    label="WR1"
                    expression="'PRODUCT_PROPERTY_DEFINITION.CHARACTERIZED_PRODUCT_DEFINITION' IN TYPEOF(SELF\property_definition.definition)">
                  </where>
                </entity>

                <entity
                  name="product_definition_usage"
                  super.expression="(assembly_component_usage)"
                  supertypes="product_definition_relationship">
                  <unique
                    label="UR1">
                    <unique.attribute
                      attribute="id"/>
                    <unique.attribute
                      attribute="relating_product_definition"/>
                    <unique.attribute
                      attribute="related_product_definition"/>
                  </unique>
                  <where
                    label="WR1"
                    expression="acyclic_product_definition_relationship (SELF,[SELF\product_definition_relationship.related_product_definition],'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE.' +'RELATED_PRODUCT_DEFINITION')">
                  </where>
                </entity>

                <entity
                  name="product_definition_with_associated_documents"
                  supertypes="product_definition">
                  <explicit
                    name="documentation_ids">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="document"/>
                  </explicit>
                </entity>

                <entity
                  name="product_related_product_category"
                  supertypes="product_category">
                  <explicit
                    name="products">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="product"/>
                  </explicit>
                </entity>

                <entity
                  name="promissory_usage_occurrence"
                  supertypes="assembly_component_usage">
                </entity>

                <entity
                  name="property_definition">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="definition">
                    <typename
                      name="characterized_definition"/>
                  </explicit>
                </entity>

                <entity
                  name="property_definition_representation">
                  <explicit
                    name="definition">
                    <typename
                      name="property_definition"/>
                  </explicit>
                  <explicit
                    name="used_representation">
                    <typename
                      name="representation"/>
                  </explicit>
                </entity>

                <entity
                  name="quantified_assembly_component_usage"
                  supertypes="assembly_component_usage">
                  <explicit
                    name="quantity">
                    <typename
                      name="measure_with_unit"/>
                  </explicit>
                </entity>

                <entity
                  name="quasi_uniform_curve"
                  supertypes="b_spline_curve">
                </entity>

                <entity
                  name="quasi_uniform_surface"
                  supertypes="b_spline_surface">
                </entity>

                <entity
                  name="rational_b_spline_curve"
                  supertypes="b_spline_curve">
                  <explicit
                    name="weights_data">
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="?"/>
                    <builtintype
                      type="REAL"/>
                  </explicit>
                  <derived
                    name="weights"
                    expression="list_to_array(weights_data, 0, upper_index_on_control_points)">
                    <aggregate
                      type="ARRAY"
                      lower="0"
                      upper="upper_index_on_control_points"/>
                    <builtintype
                      type="REAL"/>
                  </derived>
                  <where
                    label="WR1"
                    expression="SIZEOF(weights_data) = SIZEOF (SELF\b_spline_curve.control_points_list)">
                  </where>
                  <where
                    label="WR2"
                    expression="curve_weights_positive (SELF)">
                  </where>
                </entity>

                <entity
                  name="rational_b_spline_surface"
                  supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>

                  <derived
                    name="weights"
                    expression="make_array_of_array(weights_data, 0, u_upper, 0, v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
                  </derived>
                  <where
                    label="WR1"
                    expression="(SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND(SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]))">
                  </where>
                  <where
                    label="WR2"
                    expression="surface_weights_positive (SELF)">
                  </where>
                </entity>

                <entity
                  name="rectangular_composite_surface"
                  supertypes="bounded_surface">
                  <explicit
                    name="segments">
                    <aggregate
                      type="LIST"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="LIST"/>
                  </explicit>
                  <derived
                    name="n_u"
                    expression="SIZEOF(segments)">
                    <builtintype
                      type="INTEGER"/>
                  </derived>
                  <derived
                    name="n_v"
                    expression="SIZEOF(segments[1])">
                    <builtintype
                      type="INTEGER"/>
                  </derived>
                  <where
                    label="WR1"
                    expression="[] = QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF(s))">
                  </where>
                  <where
                    label="WR2"
                    expression="constraints_rectangular_composite_surface(SELF)">
                  </where>
                </entity>

                <entity
                  name="rectangular_trimmed_surface"
                  supertypes="bounded_surface">
                  <explicit
                    name="basis_surface">
                    <typename
                      name="surface"/>
                  </explicit>
                  <explicit
                    name="u1">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="u2">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="v1">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="v2">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <explicit
                    name="usense">
                    <builtintype
                      type="BOOLEAN"/>
                  </explicit>
                  <explicit
                    name="vsense">
                    <builtintype
                      type="BOOLEAN"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="u1 &lt;&gt; u2">
                  </where>
                  <where
                    label="WR2"
                    expression="v1 &lt;&gt; v2">
                  </where>
                  <where
                    label="WR3"
                    expression="((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF (basis_surface)) AND(NOT ('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF (basis_surface)))) OR('CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF (basis_surface))) OR (usense = (u2 &gt; u1))">
                  </where>
                  <where
                    label="WR4"
                    expression="(('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN TYPEOF (basis_surface)) OR('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE' IN TYPEOF (basis_surface))) OR (vsense = (v2 &gt; v1))">
                  </where>
                </entity>

                <entity
                  name="reparametrised_composite_curve_segment"
                  supertypes="composite_curve_segment">
                  <explicit
                    name="param_length">
                    <typename
                      name="parameter_value"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="param_length &gt; 0">
                  </where>
                </entity>

                <entity
                  name="representation">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="items">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="representation_item"/>
                  </explicit>
                  <explicit
                    name="context_of_items">
                    <typename
                      name="representation_context"/>
                  </explicit>
                </entity>

                <entity
                  name="representation_context">
                  <explicit
                    name="context_identifier">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="context_type">
                    <typename
                      name="text"/>
                  </explicit>
                  <inverse
                    name="representations_in_context"
                    entity="representation"
                    attribute="context_of_items">
                    <inverse.aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                  </inverse>
                </entity>

                <entity
                  name="representation_item">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="SIZEOF (using_representations(SELF)) &gt; 0">
                  </where>
                </entity>

                <entity
                  name="representation_map">
                  <explicit
                    name="mapping_origin">
                    <typename
                      name="representation_item"/>
                  </explicit>
                  <explicit
                    name="mapped_representation">
                    <typename
                      name="representation"/>
                  </explicit>
                  <inverse
                    name="map_usage"
                    entity="mapped_item"
                    attribute="mapping_source">
                    <inverse.aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                  </inverse>
                  <where
                    label="WR1"
                    expression="item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items)">
                  </where>
                </entity>

                <entity
                  name="representation_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="rep_1">
                    <typename
                      name="representation"/>
                  </explicit>
                  <explicit
                    name="rep_2">
                    <typename
                      name="representation"/>
                  </explicit>
                </entity>

                <entity
                  name="representation_relationship_with_transformation"
                  supertypes="representation_relationship">
                  <explicit
                    name="transformation_operator">
                    <typename
                      name="transformation"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items">
                  </where>
                </entity>

                <entity
                  name="seam_curve"
                  supertypes="surface_curve">
                  <where
                    label="WR1"
                    expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
                  </where>
                  <where
                    label="WR2"
                    expression="associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2])">
                  </where>
                  <where
                    label="WR3"
                    expression="'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF (SELF\surface_curve.associated_geometry[1])">
                  </where>
                  <where
                    label="WR4"
                    expression="'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF (SELF\surface_curve.associated_geometry[2])">
                  </where>
                </entity>

                <entity
                  name="security_classification">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="purpose">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="security_level">
                    <typename
                      name="security_classification_level"/>
                  </explicit>
                </entity>

                <entity
                  name="security_classification_assignment"
                  abstract.supertype="YES">
                  <explicit
                    name="assigned_security_classification">
                    <typename
                      name="security_classification"/>
                  </explicit>
                </entity>

                <entity
                  name="security_classification_level">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                </entity>

                <entity
                  name="serial_numbered_effectivity"
                  supertypes="effectivity">
                  <explicit
                    name="effectivity_start_id">
                    <typename
                      name="identifier"/>
                  </explicit>
                  <explicit
                    name="effectivity_end_id"
                    optional="YES">
                    <typename
                      name="identifier"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_aspect">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="of_shape">
                    <typename
                      name="product_definition_shape"/>
                  </explicit>
                  <explicit
                    name="product_definitional">
                    <builtintype
                      type="LOGICAL"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_aspect_relationship">
                  <explicit
                    name="name">
                    <typename
                      name="label"/>
                  </explicit>
                  <explicit
                    name="description">
                    <typename
                      name="text"/>
                  </explicit>
                  <explicit
                    name="relating_shape_aspect">
                    <typename
                      name="shape_aspect"/>
                  </explicit>
                  <explicit
                    name="related_shape_aspect">
                    <typename
                      name="shape_aspect"/>
                  </explicit>
                </entity>

                <entity
                  name="shape_definition_representation"
                  supertypes="property_definition_representation">
                  <where
                    label="WR1"
                    expression="('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition)) OR('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition))">
                  </where>
                  <where
                    label="WR2"
                    expression="'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation)">
                  </where>
                </entity>

                <entity
                  name="shape_representation"
                  supertypes="representation">
                </entity>

                <entity
                  name="shape_representation_relationship"
                  supertypes="representation_relationship">
                  <where
                    label="WR1"
                    expression="'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN(TYPEOF (SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))">
                  </where>
                </entity>

                <entity
                  name="shell_based_surface_model"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="sbsm_boundary">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="shell"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="constraints_geometry_shell_based_surface_model(SELF)">
                  </where>
                </entity>

                <entity
                  name="shell_based_wireframe_model"
                  supertypes="geometric_representation_item">
                  <explicit
                    name="sbwm_boundary">
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="shell"/>
                  </explicit>
                  <where
                    label="WR1"
                    expression="constraints_geometry_shell_based_wireframe_model(SELF)">
                  </where>
                </entity>

                <entity
                  name="shell_based_wireframe_shape_representation"
                  supertypes="shape_representation">
                  <where
                    label="WR1"
                    expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL','CONFIG_CONTROL_DESIGN.MAPPED_ITEM','CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0">
                  </where>
                  <where
                    label="WR2"
                    expression="SIZEOF (QUERY (it &lt;* SELF\representation.items | SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL','CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt;= 1">
                  </where>
                  <where
                    label="WR3"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list | NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (el.edge_element)))) = 0))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR4"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (pline_el &lt;* QUERY (el &lt;* eloop\path.edge_list |'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(el.edge_element\edge_curve.edge_geometry)) | NOT (SIZEOF (pline_el.edge_element\edge_curve. edge_geometry\polyline.points) &gt; 2)))= 0))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR5"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list | NOT (valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry,'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR6"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list | NOT(('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR7"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list | NOT((valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')) AND(valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN'))))) = 0)))= 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR8"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) | NOT (SIZEOF (QUERY (con_edges &lt;* QUERY (el &lt;* eloop\path.edge_list |'CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) | NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (con_edges.edge_element\edge_curve.edge_geometry\ conic.position)))) = 0))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR9"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (vloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) | NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (vloop.loop_vertex)))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR10"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) | NOT (SIZEOF (QUERY (vloop &lt;* QUERY (wsb &lt;* ws\wire_shell.wire_shell_extent |'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) | NOT(valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry,'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0">
                  </where>
                  <where
                    label="WR11"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (vs &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) | NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex))))= 0))) = 0">
                  </where>
                  <where
                    label="WR12"
                    expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) | NOT (SIZEOF (QUERY (vs &lt;* QUERY (sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary |'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) | NOT (valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\ vertex_point.vertex_geometry, 'CONFIG_CONTROL_DESIGN'))))= 0))) = 0">
                  </where>
                  <where
                    label="WR13"
                    expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) | NOT ('CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))= 0">
                  </where>
                </entity>

                <entity
                  name="si_unit"
                  supertypes="named_unit">
                  <explicit
                    name="prefix"
                    optional="YES">
                    <typename
                      name="si_prefix"/>
                  </explicit>
                  <explicit
                    name="name">
                    <typename
                      name="si_unit_name"/>
                  </explicit>
                  <derived
                    name="dimensions"
                    expression="dimensions_for_si_unit(SELF.name)">
                    <typename
                      name="dimensional_exponents"/>
                    <redeclaration
                      entity-ref="named_unit"/>
                    </derived>
                  </entity>

                  <entity
                    name="specified_higher_usage_occurrence"
                    supertypes="assembly_component_usage">
                    <explicit
                      name="upper_usage">
                      <typename
                        name="assembly_component_usage"/>
                    </explicit>
                    <explicit
                      name="next_usage">
                      <typename
                        name="next_assembly_usage_occurrence"/>
                    </explicit>
                    <unique
                      label="UR1">
                      <unique.attribute
                        attribute="upper_usage"/>
                      <unique.attribute
                        attribute="next_usage"/>
                    </unique>
                    <where
                      label="WR1"
                      expression="SELF :&lt;&gt;: upper_usage">
                    </where>
                    <where
                      label="WR2"
                      expression="SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition">
                    </where>
                    <where
                      label="WR3"
                      expression="SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition">
                    </where>
                    <where
                      label="WR4"
                      expression="upper_usage.related_product_definition :=: next_usage.relating_product_definition">
                    </where>
                    <where
                      label="WR5"
                      expression="NOT ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN TYPEOF(upper_usage))">
                    </where>
                  </entity>

                  <entity
                    name="solid_angle_measure_with_unit"
                    supertypes="measure_with_unit">
                    <where
                      label="WR1"
                      expression="'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)">
                    </where>
                  </entity>

                  <entity
                    name="solid_angle_unit"
                    supertypes="named_unit">
                    <where
                      label="WR1"
                      expression="(SELF\named_unit.dimensions.length_exponent = 0) AND(SELF\named_unit.dimensions.mass_exponent = 0) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
                    </where>
                  </entity>

                  <entity
                    name="solid_model"
                    super.expression="(manifold_solid_brep)"
                    supertypes="geometric_representation_item">
                  </entity>

                  <entity
                    name="spherical_surface"
                    supertypes="elementary_surface">
                    <explicit
                      name="radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="start_request"
                    supertypes="action_request_assignment">
                    <explicit
                      name="items">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="start_request_item"/>
                    </explicit>
                  </entity>

                  <entity
                    name="start_work"
                    supertypes="action_assignment">
                    <explicit
                      name="items">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="work_item"/>
                    </explicit>
                  </entity>

                  <entity
                    name="supplied_part_relationship"
                    supertypes="product_definition_relationship">
                  </entity>

                  <entity
                    name="surface"
                    super.expression="(ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))"
                    supertypes="geometric_representation_item">
                  </entity>

                  <entity
                    name="surface_curve"
                    super.expression="(ONEOF (intersection_curve, seam_curve))"
                    supertypes="curve">
                    <explicit
                      name="curve_3d">
                      <typename
                        name="curve"/>
                    </explicit>
                    <explicit
                      name="associated_geometry">
                      <aggregate
                        type="LIST"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="pcurve_or_surface"/>
                    </explicit>
                    <explicit
                      name="master_representation">
                      <typename
                        name="preferred_surface_curve_representation"/>
                    </explicit>
                    <derived
                      name="basis_surface"
                      expression="get_basis_surface(SELF)">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="surface"/>
                    </derived>
                    <where
                      label="WR1"
                      expression="curve_3d.dim = 3">
                    </where>
                    <where
                      label="WR2"
                      expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation &lt;&gt; pcurve_s1)">
                    </where>
                    <where
                      label="WR3"
                      expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation &lt;&gt; pcurve_s2)">
                    </where>
                    <where
                      label="WR4"
                      expression="NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(curve_3d))">
                    </where>
                  </entity>

                  <entity
                    name="surface_of_linear_extrusion"
                    supertypes="swept_surface">
                    <explicit
                      name="extrusion_axis">
                      <typename
                        name="vector"/>
                    </explicit>
                  </entity>

                  <entity
                    name="surface_of_revolution"
                    supertypes="swept_surface">
                    <explicit
                      name="axis_position">
                      <typename
                        name="axis1_placement"/>
                    </explicit>
                    <derived
                      name="axis_line"
                      expression="line(axis_position.location, vector (axis_position.z, 1.0))">
                      <typename
                        name="line"/>
                    </derived>
                  </entity>

                  <entity
                    name="surface_patch">
                    <explicit
                      name="parent_surface">
                      <typename
                        name="bounded_surface"/>
                    </explicit>
                    <explicit
                      name="u_transition">
                      <typename
                        name="transition_code"/>
                    </explicit>
                    <explicit
                      name="v_transition">
                      <typename
                        name="transition_code"/>
                    </explicit>
                    <explicit
                      name="u_sense">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="v_sense">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <inverse
                      name="using_surfaces"
                      entity="rectangular_composite_surface"
                      attribute="segments">
                      <inverse.aggregate
                        type="BAG"
                        lower="1"
                        upper="?"/>
                    </inverse>
                    <where
                      label="WR1"
                      expression="NOT ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF (parent_surface))">
                    </where>
                  </entity>

                  <entity
                    name="surface_replica"
                    supertypes="surface">
                    <explicit
                      name="parent_surface">
                      <typename
                        name="surface"/>
                    </explicit>
                    <explicit
                      name="transformation">
                      <typename
                        name="cartesian_transformation_operator_3d"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="acyclic_surface_replica (SELF,parent_surface)">
                    </where>
                  </entity>

                  <entity
                    name="swept_surface"
                    super.expression="(ONEOF (surface_of_linear_extrusion, surface_of_revolution))"
                    supertypes="surface">
                    <explicit
                      name="swept_curve">
                      <typename
                        name="curve"/>
                    </explicit>
                  </entity>

                  <entity
                    name="topological_representation_item"
                    super.expression="(ONEOF (vertex, edge, face_bound, face, connected_edge_set, connected_face_set, vertex_shell, wire_shell, (loop ANDOR path)))"
                    supertypes="representation_item">
                  </entity>

                  <entity
                    name="toroidal_surface"
                    supertypes="elementary_surface">
                    <explicit
                      name="major_radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                    <explicit
                      name="minor_radius">
                      <typename
                        name="positive_length_measure"/>
                    </explicit>
                  </entity>

                  <entity
                    name="trimmed_curve"
                    supertypes="bounded_curve">
                    <explicit
                      name="basis_curve">
                      <typename
                        name="curve"/>
                    </explicit>
                    <explicit
                      name="trim_1">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="trimming_select"/>
                    </explicit>
                    <explicit
                      name="trim_2">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="2"/>
                      <typename
                        name="trimming_select"/>
                    </explicit>
                    <explicit
                      name="sense_agreement">
                      <builtintype
                        type="BOOLEAN"/>
                    </explicit>
                    <explicit
                      name="master_representation">
                      <typename
                        name="trimming_preference"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="(HIINDEX(trim_1) = 1) XOR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))">
                    </where>
                    <where
                      label="WR2"
                      expression="(HIINDEX(trim_2) = 1) XOR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))">
                    </where>
                  </entity>

                  <entity
                    name="uncertainty_measure_with_unit"
                    supertypes="measure_with_unit">
                    <explicit
                      name="name">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="description">
                      <typename
                        name="text"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="(NOT ('NUMBER' IN TYPEOF(SELF\measure_with_unit.value_component))) OR(SELF\measure_with_unit.value_component &gt;= 0)">
                    </where>
                  </entity>

                  <entity
                    name="uniform_curve"
                    supertypes="b_spline_curve">
                  </entity>

                  <entity
                    name="uniform_surface"
                    supertypes="b_spline_surface">
                  </entity>

                  <entity
                    name="vector"
                    supertypes="geometric_representation_item">
                    <explicit
                      name="orientation">
                      <typename
                        name="direction"/>
                    </explicit>
                    <explicit
                      name="magnitude">
                      <typename
                        name="length_measure"/>
                    </explicit>
                    <where
                      label="WR1"
                      expression="magnitude &gt;= 0">
                    </where>
                  </entity>

                  <entity
                    name="versioned_action_request">
                    <explicit
                      name="id">
                      <typename
                        name="identifier"/>
                    </explicit>
                    <explicit
                      name="version">
                      <typename
                        name="label"/>
                    </explicit>
                    <explicit
                      name="purpose">
                      <typename
                        name="text"/>
                    </explicit>
                    <explicit
                      name="description">
                      <typename
                        name="text"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex"
                    supertypes="topological_representation_item">
                  </entity>

                  <entity
                    name="vertex_loop"
                    supertypes="loop">
                    <explicit
                      name="loop_vertex">
                      <typename
                        name="vertex"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex_point"
                    supertypes="vertex geometric_representation_item">
                    <explicit
                      name="vertex_geometry">
                      <typename
                        name="point"/>
                    </explicit>
                  </entity>

                  <entity
                    name="vertex_shell"
                    supertypes="topological_representation_item">
                    <explicit
                      name="vertex_shell_extent">
                      <typename
                        name="vertex_loop"/>
                    </explicit>
                  </entity>

                  <entity
                    name="volume_measure_with_unit"
                    supertypes="measure_with_unit">
                    <where
                      label="WR1"
                      expression="'CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\ measure_with_unit.unit_component)">
                    </where>
                  </entity>

                  <entity
                    name="volume_unit"
                    supertypes="named_unit">
                    <where
                      label="WR1"
                      expression="(SELF\named_unit.dimensions.length_exponent = 3) AND(SELF\named_unit.dimensions.mass_exponent = 0) AND(SELF\named_unit.dimensions.time_exponent = 0) AND(SELF\named_unit.dimensions.electric_current_exponent = 0) AND(SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND(SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0)">
                    </where>
                  </entity>

                  <entity
                    name="week_of_year_and_day_date"
                    supertypes="date">
                    <explicit
                      name="week_component">
                      <typename
                        name="week_in_year_number"/>
                    </explicit>
                    <explicit
                      name="day_component"
                      optional="YES">
                      <typename
                        name="day_in_week_number"/>
                    </explicit>
                  </entity>

                  <entity
                    name="wire_shell"
                    supertypes="topological_representation_item">
                    <explicit
                      name="wire_shell_extent">
                      <aggregate
                        type="SET"
                        lower="1"
                        upper="?"/>
                      <typename
                        name="loop"/>
                    </explicit>
                    <where
                      label="wr1"
                      expression="NOT mixed_loop_type_set(wire_shell_extent)">
                    </where>
                  </entity>

                  <rule
                    name="application_context_requires_ap_definition"
                    appliesto="application_context application_protocol_definition">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ac &lt;* application_context | NOT (SIZEOF (QUERY (apd &lt;* application_protocol_definition |(ac :=: apd.application) AND(apd.application_interpreted_model_schema_name ='config_control_design'))) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="approval_requires_approval_date_time"
                    appliesto="approval approval_date_time">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (app &lt;* approval | NOT (SIZEOF (QUERY (adt &lt;* approval_date_time | app :=: adt.dated_approval)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="approval_requires_approval_person_organization"
                    appliesto="approval approval_person_organization">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (app &lt;* approval | NOT (SIZEOF (QUERY (apo &lt;* approval_person_organization | app :=: apo.authorized_approval)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="approvals_are_assigned"
                    appliesto="approval approval_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (app &lt;* approval | NOT (SIZEOF (QUERY (aa &lt;* approval_assignment | app :=: aa.assigned_approval)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="as_required_quantity"
                    appliesto="measure_with_unit">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (m &lt;* measure_with_unit |('CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF (m.value_component)) AND(NOT (m.value_component = 'as_required')))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="certification_requires_approval"
                    appliesto="certification cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (cert &lt;* certification | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | cert IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="certification_requires_date_time"
                    appliesto="certification cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (cert &lt;* certification | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment | cert IN ccdta.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="change_request_requires_approval"
                    appliesto="change_request cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (cr &lt;* change_request | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | cr IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="change_request_requires_date_time"
                    appliesto="change_request cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (cr &lt;* change_request | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment | cr IN ccdta.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="change_request_requires_person_organization"
                    appliesto="change_request cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (cr &lt;* change_request | NOT (SIZEOF (QUERY (ccpoa &lt;* cc_design_person_and_organization_assignment | cr IN ccpoa.items)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="change_requires_approval"
                    appliesto="change cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (chg &lt;* change | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | chg IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="change_requires_date_time"
                    appliesto="change cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (chg &lt;* change | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |(chg IN ccdta.items) AND (ccdta.role.name = 'start_date'))) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="compatible_dimension"
                    appliesto="cartesian_point direction representation_context geometric_representation_context">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (x &lt;* cartesian_point | SIZEOF (QUERY (y &lt;* geometric_representation_context |(item_in_context(x,y)) AND (HIINDEX (x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) = 0">
                    </where>
                    <where
                      label="WR2"
                      expression="SIZEOF (QUERY (x &lt;* direction | SIZEOF (QUERY (y &lt;* geometric_representation_context |(item_in_context(x,y)) AND (HIINDEX (x.direction_ratios) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) = 0">
                    </where>
                  </rule>

                  <rule
                    name="configuration_item_requires_approval"
                    appliesto="configuration_item cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ci &lt;* configuration_item | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | ci IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="configuration_item_requires_person_organization"
                    appliesto="configuration_item cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ci &lt;* configuration_item | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | ci IN ccdpoa.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="contract_requires_approval"
                    appliesto="contract cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (c &lt;* contract | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | c IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="contract_requires_person_organization"
                    appliesto="contract cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (c &lt;* contract | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | c IN ccdpoa.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="coordinated_assembly_and_shape"
                    appliesto="next_assembly_usage_occurrence">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (nauo &lt;* next_assembly_usage_occurrence | NOT assembly_shape_is_defined(nauo))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_action_directive"
                    appliesto="action_directive">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ad &lt;* action_directive | NOT (SIZEOF (USEDIN (ad, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_approval_status"
                    appliesto="approval_status">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ast &lt;* approval_status | NOT (SIZEOF (USEDIN (ast, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_certification_type"
                    appliesto="certification_type">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ct &lt;* certification_type | NOT (SIZEOF (USEDIN (ct, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_contract_type"
                    appliesto="contract_type">
                    <where
                      label="WR1"
                      expression="SIZEOF(QUERY (ct &lt;* contract_type | NOT (SIZEOF (USEDIN (ct, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_date"
                    appliesto="date">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dt &lt;* date | NOT (SIZEOF(USEDIN (dt, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_date_time_role"
                    appliesto="date_time_role">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dtr &lt;* date_time_role | NOT (SIZEOF (USEDIN (dtr, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_document_type"
                    appliesto="document_type">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dt &lt;* document_type | NOT (SIZEOF (USEDIN (dt, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_named_unit"
                    appliesto="named_unit">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (nu &lt;* named_unit | NOT (SIZEOF (USEDIN (nu, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_person_and_organization_role"
                    appliesto="person_and_organization_role">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (poar &lt;* person_and_organization_role | NOT (SIZEOF (USEDIN (poar, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_representation_item"
                    appliesto="representation_item">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ri &lt;* representation_item | NOT (SIZEOF (USEDIN (ri, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_security_classification_level"
                    appliesto="security_classification_level">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (scl &lt;* security_classification_level | NOT (SIZEOF (USEDIN (scl, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_shape_representation"
                    appliesto="shape_representation">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sr &lt;* shape_representation | NOT (SIZEOF(USEDIN(sr, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="design_context_for_property"
                    appliesto="product_definition">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pd &lt;* product_definition |(SIZEOF (USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +'PROPERTY_DEFINITION.DEFINITION') + QUERY (pdr &lt;* USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | SIZEOF (USEDIN (pdr, 'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' +'DEFINITION')) &gt;= 1)) &gt;= 1) AND(NOT ('CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF (pd.frame_of_reference))))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="document_to_product_definition"
                    appliesto="cc_design_specification_reference product_definition">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sp &lt;* cc_design_specification_reference | NOT (((('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +'RELATING_DOCUMENT' IN ROLESOF (sp\document_reference.assigned_document)) AND(SIZEOF (QUERY (it &lt;* sp.items | NOT('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF (it)))) = 0))) OR(NOT ('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +'RELATING_DOCUMENT' IN ROLESOF (sp\document_reference.assigned_document)))))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="effectivity_requires_approval"
                    appliesto="effectivity cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (eff &lt;* effectivity | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | eff IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="geometric_representation_item_3d"
                    appliesto="geometric_representation_item">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (gri &lt;* geometric_representation_item | NOT ((dimension_of (gri) = 3) OR(SIZEOF (bag_to_set (USEDIN (gri, '')) - bag_to_set (USEDIN (gri,'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION.ITEMS'))) = 0)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="dependent_instantiable_parametric_representation_context"
                    appliesto="parametric_representation_context">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (prc &lt;* parametric_representation_context | NOT (SIZEOF (USEDIN (prc, '')) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="global_unit_assignment"
                    appliesto="global_unit_assigned_context">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (guac &lt;* global_unit_assigned_context | NOT (SIZEOF (guac.units) = 3))) = 0">
                    </where>
                    <where
                      label="WR2"
                      expression="SIZEOF (QUERY (guac &lt;* global_unit_assigned_context | NOT ((SIZEOF (QUERY (u &lt;* guac.units |'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF (u))) = 1) AND(SIZEOF (QUERY (u &lt;* guac.units |'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF (u))) = 1) AND(SIZEOF (QUERY (u &lt;* guac.units |'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF (u))) = 1)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="no_shape_for_make_from"
                    appliesto="design_make_from_relationship">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dmfr &lt;* design_make_from_relationship | NOT (SIZEOF (QUERY (pd &lt;* USEDIN (dmfr, 'CONFIG_CONTROL_DESIGN.' +'PROPERTY_DEFINITION.DEFINITION') |'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =0))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="no_shape_for_supplied_part"
                    appliesto="supplied_part_relationship">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (spr &lt;* supplied_part_relationship | NOT (SIZEOF (QUERY (pd &lt;* USEDIN (spr, 'CONFIG_CONTROL_DESIGN.' +'PROPERTY_DEFINITION.DEFINITION') |'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =0))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="acu_requires_security_classification"
                    appliesto="assembly_component_usage cc_design_security_classification">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (acu &lt;* assembly_component_usage | NOT (SIZEOF (QUERY (ccdsc &lt;* cc_design_security_classification | acu IN ccdsc.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_concept_requires_configuration_item"
                    appliesto="product_concept configuration_item">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pc &lt;* product_concept | NOT (SIZEOF (QUERY (ci &lt;* configuration_item | pc :=: ci.item_concept)) &gt;=1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_definition_requires_approval"
                    appliesto="product_definition cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pd &lt;* product_definition | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | pd IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_definition_requires_date_time"
                    appliesto="product_definition cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pd &lt;* product_definition | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment | pd IN ccdta.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_definition_requires_person_organization"
                    appliesto="product_definition cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pd &lt;* product_definition | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | pd IN ccdpoa.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_requires_person_organization"
                    appliesto="product cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (prod &lt;* product | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | prod IN ccdpoa.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_requires_product_category"
                    appliesto="product product_related_product_category">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (prod &lt;* product | NOT (SIZEOF (QUERY (prpc &lt;* product_related_product_category |(prod IN prpc.products) AND(prpc.name IN ['assembly', 'inseparable_assembly', 'detail','customer_furnished_equipment']))) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_requires_version"
                    appliesto="product product_definition_formation">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (prod &lt;* product | NOT (SIZEOF (QUERY (pdf &lt;* product_definition_formation | prod :=: pdf.of_product)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_version_requires_approval"
                    appliesto="product_definition_formation cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | pdf IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="product_version_requires_person_organization"
                    appliesto="product_definition_formation cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment |(pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator'))) = 1))) = 0">
                    </where>
                    <where
                      label="WR2"
                      expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment |(pdf IN ccdpoa.items) AND(ccdpoa.role.name IN ['design_supplier', 'part_supplier']))) &gt;= 1)))= 0">
                    </where>
                  </rule>

                  <rule
                    name="product_version_requires_security_classification"
                    appliesto="product_definition_formation cc_design_security_classification">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation | NOT (SIZEOF (QUERY (ccdsc &lt;* cc_design_security_classification | pdf IN ccdsc.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_action_request_status"
                    appliesto="action_request_status">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ars &lt;* action_request_status | NOT (ars.status IN['proposed', 'in_work', 'issued', 'hold']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_approval_status"
                    appliesto="approval_status">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ast &lt;* approval_status | NOT (ast.name IN['approved', 'not_yet_approved', 'disapproved', 'withdrawn']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_certification_type"
                    appliesto="certification_type">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ct &lt;* certification_type | NOT (ct.description IN['design_supplier', 'part_supplier']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_contract_type"
                    appliesto="contract_type">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ct &lt;* contract_type | NOT (ct.description IN ['fixed_price', 'cost_plus']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_date_time_role"
                    appliesto="date_time_role">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dtr &lt;* date_time_role | NOT (dtr.name IN ['creation_date', 'request_date', 'release_date','start_date', 'contract_date', 'certification_date', 'sign_off_date','classification_date', 'declassification_date']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_document_type"
                    appliesto="document_type">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (dt &lt;* document_type | NOT (dt.product_data_type IN['material_specification', 'process_specification','design_specification', 'surface_finish_specification','cad_filename', 'drawing']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_person_organization_role"
                    appliesto="person_and_organization_role">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (por &lt;* person_and_organization_role | NOT (por.name IN ['request_recipient', 'initiator', 'part_supplier','design_supplier', 'configuration_manager', 'contractor','classification_officer', 'creator', 'design_owner']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_product_category_value"
                    appliesto="product_related_product_category">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (prpc &lt;* product_related_product_category | NOT (prpc.name IN ['assembly', 'detail','customer_furnished_equipment', 'inseparable_assembly', 'cast','coined', 'drawn', 'extruded', 'forged', 'formed', 'machined','molded', 'rolled', 'sheared'])))= 0">
                    </where>
                  </rule>

                  <rule
                    name="restrict_security_classification_level"
                    appliesto="security_classification_level">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (scl &lt;* security_classification_level | NOT (scl.name IN ['unclassified', 'classified', 'proprietary','confidential', 'secret', 'top_secret']))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="security_classification_optional_date_time"
                    appliesto="security_classification cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sc &lt;* security_classification | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |(sc IN ccdta.items) AND('declassification_date' = ccdta.role.name))) &lt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="security_classification_requires_approval"
                    appliesto="security_classification cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sc &lt;* security_classification | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | sc IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="security_classification_requires_date_time"
                    appliesto="security_classification cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sc &lt;* security_classification | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |(sc IN ccdta.items) AND('classification_date' = ccdta.role.name))) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="security_classification_requires_person_organization"
                    appliesto="security_classification cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sc &lt;* security_classification | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | sc IN ccdpoa.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="start_request_requires_approval"
                    appliesto="start_request cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sr &lt;* start_request | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | sr IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="start_request_requires_date_time"
                    appliesto="start_request cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sr &lt;* start_request | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment | sr IN ccdta.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="start_request_requires_person_organization"
                    appliesto="start_request cc_design_person_and_organization_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sr &lt;* start_request | NOT (SIZEOF (QUERY (ccdpoa &lt;* cc_design_person_and_organization_assignment | sr IN ccdpoa.items)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="start_work_requires_approval"
                    appliesto="start_work cc_design_approval">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sw &lt;* start_work | NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval | sw IN ccda.items)) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="start_work_requires_date_time"
                    appliesto="start_work cc_design_date_and_time_assignment">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sw &lt;* start_work | NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |(sw IN ccdta.items) AND (ccdta.role.name = 'start_date'))) = 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_action"
                    appliesto="action">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (act &lt;* action | NOT ('CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_effectivity"
                    appliesto="effectivity">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (eff &lt;* effectivity | NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY','CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY','CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF (eff)) = 1) AND('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN TYPEOF(eff)))))= 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_product_context"
                    appliesto="product_context">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pc &lt;* product_context | NOT ('CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_product_definition_formation"
                    appliesto="product_definition_formation">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation | NOT ('CONFIG_CONTROL_DESIGN.' +'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF(pdf)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_product_definition_usage"
                    appliesto="product_definition_usage">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (pdu &lt;* product_definition_usage | NOT ('CONFIG_CONTROL_DESIGN.' +'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdu)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_representation"
                    appliesto="representation">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (rep &lt;* representation | NOT ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep))))= 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_representation_context"
                    appliesto="representation_context">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (rep_cntxt &lt;* representation_context | NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(rep_cntxt)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="subtype_mandatory_shape_representation"
                    appliesto="shape_representation">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (sr &lt;* shape_representation | NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.' +'ADVANCED_BREP_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.' +'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION','CONFIG_CONTROL_DESIGN.' +'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] * TYPEOF (sr)) = 1) OR(SIZEOF (QUERY (it &lt;* sr\representation.items | NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (it))))= 0) OR(SIZEOF (QUERY (sdr &lt;* QUERY (pdr &lt;* USEDIN (sr,'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +'USED_REPRESENTATION') |'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF (pdr)) | NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHAPE_ASPECT','CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(sdr.definition)) = 1))) = 0)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="unique_version_change_order_rule"
                    appliesto="change">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (c &lt;* change | NOT (unique_version_change_order (c.assigned_action)))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="versioned_action_request_requires_solution"
                    appliesto="versioned_action_request action_request_solution">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ar &lt;* versioned_action_request | NOT (SIZEOF (QUERY (ars &lt;* action_request_solution | ar :=: ars.request)) &gt;= 1))) = 0">
                    </where>
                  </rule>

                  <rule
                    name="versioned_action_request_requires_status"
                    appliesto="versioned_action_request action_request_status">
                    <where
                      label="WR1"
                      expression="SIZEOF (QUERY (ar &lt;* versioned_action_request | NOT (SIZEOF (QUERY (ars &lt;* action_request_status | ar :=: ars.assigned_request)) = 1))) = 0">
                    </where>
                  </rule>

                  <function
                    name="acyclic_curve_replica">
                    <parameter
                      name="rep">
                      <typename
                        name="curve_replica"/>
                    </parameter>
                    <parameter
                      name="parent">
                      <typename
                        name="curve"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="acyclic_mapped_representation">
                    <parameter
                      name="parent_set">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="representation"/>
                    </parameter>
                    <parameter
                      name="children_set">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="representation_item"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
i : INTEGER;
x : SET OF representation_item;
y : SET OF representation_item;
END_LOCAL;
x := QUERY (z &lt;* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM'
IN TYPEOF(z)));
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF x[i]\mapped_item.mapping_source.mapped_representation IN
parent_set THEN
RETURN(FALSE);
END_IF;
IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
.mapping_source.mapped_representation,x[i]\mapped_item.
mapping_source.mapped_representation.items) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
x := children_set - x;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
y := QUERY (z &lt;* bag_to_set(USEDIN(x[i],'')) | (
'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)));
IF NOT acyclic_mapped_representation(parent_set,y) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="acyclic_point_replica">
                    <parameter
                      name="rep">
                      <typename
                        name="point_replica"/>
                    </parameter>
                    <parameter
                      name="parent">
                      <typename
                        name="point"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="acyclic_product_category_relationship">
                    <parameter
                      name="relation">
                      <typename
                        name="product_category_relationship"/>
                    </parameter>
                    <parameter
                      name="children">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="product_category"/>
                    </parameter>
                    <builtintype
                      type="LOGICAL"/>
                    <algorithm>
LOCAL
i : INTEGER;
x : SET OF product_category_relationship;
local_children : SET OF product_category;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(children) BY 1;
IF relation.category :=: children[i] THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' +
'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
local_children := children + relation.category;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF NOT acyclic_product_category_relationship(x[i],local_children)
THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="acyclic_product_definition_relationship">
                    <parameter
                      name="relation">
                      <typename
                        name="product_definition_relationship"/>
                    </parameter>
                    <parameter
                      name="relatives">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="product_definition"/>
                    </parameter>
                    <parameter
                      name="specific_relation">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="LOGICAL"/>
                    <algorithm>
LOCAL
i : INTEGER;
x : SET OF product_definition_relationship;
local_relatives : SET OF product_definition;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(relatives) BY 1;
IF relation.relating_product_definition :=: relatives[i] THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.relating_product_definition,
specific_relation));
local_relatives := relatives + relation.relating_product_definition;
IF SIZEOF(x) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(x) BY 1;
IF NOT acyclic_product_definition_relationship(x[i],
local_relatives,specific_relation) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_IF;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="acyclic_surface_replica">
                    <parameter
                      name="rep">
                      <typename
                        name="surface_replica"/>
                    </parameter>
                    <parameter
                      name="parent">
                      <typename
                        name="surface"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
THEN
RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
RETURN(FALSE);
ELSE
RETURN(acyclic_surface_replica(rep,parent\surface_replica.
parent_surface));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="assembly_shape_is_defined">
                    <parameter
                      name="assy">
                      <typename
                        name="next_assembly_usage_occurrence"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
sdr_set : SET OF shape_definition_representation := [];
srr_set : SET OF shape_representation_relationship := [];
END_LOCAL;
sdr_set := QUERY (pdr &lt;* bag_to_set (USEDIN
(assy.related_product_definition,
'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
'DEFINITION.DEFINITION')) |
'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
TYPEOF (pdr)) +
QUERY (pdr &lt;* bag_to_set (
USEDIN (assy.related_product_definition,
'CONFIG_CONTROL_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION.' +
'DEFINITION.RELATED_PRODUCT_DEFINITION')) |
'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
TYPEOF (pdr));
IF SIZEOF (sdr_set) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX (sdr_set);
srr_set := QUERY (rr &lt;* bag_to_set (
USEDIN (sdr_set[i]\
property_definition_representation.used_representation,
'CONFIG_CONTROL_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2')) |
'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION_RELATIONSHIP' IN
TYPEOF (rr));
IF SIZEOF (srr_set) &gt; 0 THEN
REPEAT j := 1 TO HIINDEX (srr_set);
IF SIZEOF (QUERY (pdr &lt;* bag_to_set (USEDIN
(srr_set[j]\representation_relationship.rep_1,
'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
'USED_REPRESENTATION')) |
'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
TYPEOF (pdr)) *
QUERY (pdr &lt;* bag_to_set (
USEDIN (assy.relating_product_definition,
'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
'USED_REPRESENTATION.DEFINITION')) |
'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION'
IN TYPEOF (pdr))) &gt;= 1 THEN
IF SIZEOF (QUERY (cdsr &lt;*
USEDIN (assy, 'CONFIG_CONTROL_DESIGN.' +
'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
'REPRESENTED_PRODUCT_RELATION') |
NOT ((cdsr.represented_product_relation.definition :=: assy) AND
(cdsr.representation_relation :=: srr_set[j])))) &gt; 0
THEN RETURN (FALSE);
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_REPEAT;
END_IF;
RETURN (TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="associated_surface">
                    <parameter
                      name="arg">
                      <typename
                        name="pcurve_or_surface"/>
                    </parameter>
                    <typename
                      name="surface"/>
                    <algorithm>
LOCAL
surf : surface;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
surf := arg.basis_surface;
ELSE
surf := arg;
END_IF;
RETURN(surf);
                    </algorithm>
                  </function>

                  <function
                    name="bag_to_set">
                    <parameter
                      name="the_bag">
                      <aggregate
                        type="BAG"/>
                      <builtintype
                        type="GENERIC"
                        typelabel="intype"/>
                    </parameter>
                    <aggregate
                      type="SET"/>
                    <builtintype
                      type="GENERIC"
                      typelabel="intype"/>
                    <algorithm>
LOCAL
the_set : SET OF GENERIC:intype := [];
i : INTEGER;
END_LOCAL;
IF SIZEOF (the_bag) &gt; 0 THEN
REPEAT i := 1 to HIINDEX (the_bag);
the_set := the_set + the_bag[i];
END_REPEAT;
END_IF;
RETURN (the_set);
                    </algorithm>
                  </function>

                  <function
                    name="base_axis">
                    <parameter
                      name="dim">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="axis1">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="axis2">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="axis3">
                      <typename
                        name="direction"/>
                    </parameter>
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="3"/>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
u : LIST [2:3] OF direction;
vec : direction;
factor : REAL;
END_LOCAL;
IF dim = 3 THEN
u[3] := NVL(normalise(axis3),direction([0,0,1]));
u[1] := first_proj_axis(u[3],axis1);
u[2] := second_proj_axis(u[3],u[1],axis2);
ELSE
u[3] := ?;
IF EXISTS(axis1) THEN
u[1] := normalise(axis1);
u[2] := orthogonal_complement(u[1]);
IF EXISTS(axis2) THEN
factor := dot_product(axis2,u[2]);
IF factor &lt; 0 THEN
u[2].direction_ratios[1] := -u[2].direction_ratios[1];
u[2].direction_ratios[2] := -u[2].direction_ratios[2];
END_IF;
END_IF;
ELSE
IF EXISTS(axis2) THEN
u[2] := normalise(axis2);
u[1] := orthogonal_complement(u[2]);
u[1].direction_ratios[1] := -u[1].direction_ratios[1];
u[1].direction_ratios[2] := -u[1].direction_ratios[2];
ELSE
u[1].direction_ratios[1] := 1;
u[1].direction_ratios[2] := 0;
u[2].direction_ratios[1] := 0;
u[2].direction_ratios[2] := 1;
END_IF;
END_IF;
END_IF;
RETURN(u);
                    </algorithm>
                  </function>

                  <function
                    name="basis_curve_check">
                    <parameter
                      name="cv">
                      <typename
                        name="curve"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
schema_name + '.CONIC',
schema_name + '.LINE',
schema_name + '.POLYLINE'] * TYPEOF (cv)) = 1 THEN
RETURN(TRUE);
ELSE
IF schema_name + '.CURVE_REPLICA' IN TYPEOF (cv) THEN
RETURN (basis_curve_check(cv\curve_replica.parent_curve, schema_name));
ELSE
IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF (cv) THEN
RETURN(basis_curve_check
(cv\offset_curve_3d.basis_curve, schema_name));
ELSE
IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN
IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
schema_name + '.CONIC',
schema_name + '.LINE',
schema_name + '.POLYLINE'] *
TYPEOF (cv\pcurve.reference_to_curve\representation.items[1]))
= 1 THEN
RETURN (basis_surface_check (cv\pcurve.basis_surface,
schema_name));
ELSE
IF schema_name + '.CURVE_REPLICA'
IN TYPEOF
(cv\pcurve.reference_to_curve\representation.items[1]) THEN
RETURN ((basis_curve_check
(cv\pcurve.reference_to_curve\representation.items[1],
schema_name)) AND
(basis_surface_check (cv\pcurve.basis_surface,
schema_name)));
END_IF;
END_IF;
ELSE
IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN
IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
schema_name + '.CONIC',
schema_name + '.LINE',
schema_name + '.POLYLINE'] *
TYPEOF (cv\surface_curve.curve_3d)) = 1 THEN
REPEAT i := 1 TO SIZEOF (cv\surface_curve.associated_geometry);
IF schema_name + '.SURFACE' IN
TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
IF NOT basis_surface_check
(cv\surface_curve.associated_geometry[i],
schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF schema_name + '.PCURVE' IN
TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
IF NOT basis_curve_check
(cv\surface_curve.associated_geometry[i],
schema_name) THEN RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
ELSE
IF schema_name + '.CURVE_REPLICA' IN TYPEOF
(cv\surface_curve.curve_3d) THEN
IF NOT (basis_curve_check
(cv\curve_replica.parent_curve, schema_name)) THEN
RETURN (FALSE);
END_IF;
ELSE
IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF
(cv\surface_curve.curve_3d) THEN
IF NOT (basis_curve_check
(cv\offset_curve_3d.basis_curve, schema_name)) THEN
RETURN (FALSE);
END_IF;
ELSE
REPEAT i := 1 TO SIZEOF
(cv\surface_curve.associated_geometry);
IF schema_name + '.SURFACE' IN
TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
IF NOT basis_surface_check
(cv\surface_curve.associated_geometry[i],
schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF schema_name + '.PCURVE' IN
TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
IF NOT basis_curve_check
(cv\surface_curve.associated_geometry[i],
schema_name) THEN
RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="basis_surface_check">
                    <parameter
                      name="surf">
                      <typename
                        name="surface"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF SIZEOF([schema_name + '.B_SPLINE_SURFACE',
schema_name + '.ELEMENTARY_SURFACE'] * TYPEOF(surf)) = 1 THEN
RETURN(TRUE);
ELSE
IF schema_name + '.SWEPT_SURFACE' IN TYPEOF (surf) THEN
RETURN (basis_curve_check
(surf\swept_surface.swept_curve, schema_name));
ELSE
IF schema_name + '.OFFSET_SURFACE' IN TYPEOF (surf) THEN
RETURN(basis_surface_check
(surf\offset_surface.basis_surface, schema_name));
ELSE
IF schema_name + '.SURFACE REPLICA' IN TYPEOF(surf) THEN
RETURN(basis_surface_check
(surf\surface_replica.parent_surface, schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="boolean_choose">
                    <parameter
                      name="b">
                      <builtintype
                        type="BOOLEAN"/>
                    </parameter>
                    <parameter
                      name="choice1">
                      <builtintype
                        type="GENERIC"/>
                    </parameter>
                    <parameter
                      name="choice2">
                      <builtintype
                        type="GENERIC"/>
                    </parameter>
                    <builtintype
                      type="GENERIC"/>
                    <algorithm>
IF b THEN
RETURN(choice1);
ELSE
RETURN(choice2);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="build_2axes">
                    <parameter
                      name="ref_direction">
                      <typename
                        name="direction"/>
                    </parameter>
                    <aggregate
                      type="LIST"
                      lower="2"
                      upper="2"/>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
u : LIST [2:2] OF direction;
END_LOCAL;
u[1] := NVL(normalise(ref_direction),direction([1,0]));
u[2] := orthogonal_complement(u[1]);
RETURN(u);
                    </algorithm>
                  </function>

                  <function
                    name="build_axes">
                    <parameter
                      name="axis">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="ref_direction">
                      <typename
                        name="direction"/>
                    </parameter>
                    <aggregate
                      type="LIST"
                      lower="3"
                      upper="3"/>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
u : LIST [3:3] OF direction;
END_LOCAL;
u[3] := NVL(normalise(axis),direction([0,0,1]));
u[1] := first_proj_axis(u[3],ref_direction);
u[2] := normalise(cross_product(u[3],u[1])).orientation;
RETURN(u);
                    </algorithm>
                  </function>

                  <function
                    name="cc_design_date_time_correlation">
                    <parameter
                      name="e">
                      <typename
                        name="cc_design_date_and_time_assignment"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
dt_role : STRING;
END_LOCAL;
dt_role := e\date_and_time_assignment.role.name;
CASE dt_role OF
'creation_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'PRODUCT_DEFINITION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'request_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF (
['CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' +
'CONFIG_CONTROL_DESIGN.START_REQUEST'] *
TYPEOF (x)) = 1))
THEN RETURN(FALSE);
END_IF;
'release_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF (
['CONFIG_CONTROL_DESIGN.CHANGE' +
'CONFIG_CONTROL_DESIGN.START_WORK'] *
TYPEOF (x)) = 1))
THEN RETURN(FALSE);
END_IF;
'start_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF (
['CONFIG_CONTROL_DESIGN.CHANGE' +
'CONFIG_CONTROL_DESIGN.START_WORK'] *
TYPEOF (x)) = 1))
THEN RETURN(FALSE);
END_IF;
'sign_off_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'APPROVAL_PERSON_ORGANIZATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'contract_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.CONTRACT'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'certification_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.CERTIFICATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'classification_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'SECURITY_CLASSIFICATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'declassification_date' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'SECURITY_CLASSIFICATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
OTHERWISE : RETURN(TRUE);
END_CASE;
RETURN (TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="cc_design_person_and_organization_correlation">
                    <parameter
                      name="e">
                      <typename
                        name="cc_design_person_and_organization_assignment"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
po_role : STRING;
END_LOCAL;
po_role := e\person_and_organization_assignment.role.name;
CASE po_role OF
'request_recipient' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF(['CONFIG_CONTROL_DESIGN.' +
'CHANGE_REQUEST',
'CONFIG_CONTROL_DESIGN.' +
'START_REQUEST'] *
TYPEOF (x)) = 1))
THEN RETURN(FALSE);
END_IF;
'initiator' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF(['CONFIG_CONTROL_DESIGN.' +
'CHANGE_REQUEST',
'CONFIG_CONTROL_DESIGN.' +
'START_REQUEST',
'CONFIG_CONTROL_DESIGN.' +
'START_WORK',
'CONFIG_CONTROL_DESIGN.' +
'CHANGE'] *
TYPEOF (x)) = 1))
THEN RETURN(FALSE);
END_IF;
'creator' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
SIZEOF (['CONFIG_CONTROL_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION',
'CONFIG_CONTROL_DESIGN.' +
'PRODUCT_DEFINITION'] *
TYPEOF (x)) = 1))
THEN RETURN (FALSE);
END_IF;
'part_supplier' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'design_supplier' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'design_owner' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.PRODUCT'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'configuration_manager' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'CONFIGURATION_ITEM'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'contractor' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.CONTRACT'
IN TYPEOF (x)))
THEN RETURN(FALSE);
END_IF;
'classification_officer' : IF SIZEOF (e.items) &lt;&gt;
SIZEOF (QUERY (x &lt;* e.items |
'CONFIG_CONTROL_DESIGN.' +
'SECURITY_CLASSIFICATION'
IN TYPEOF (x))) THEN
RETURN(FALSE);
END_IF;
OTHERWISE : RETURN(TRUE);
END_CASE;
RETURN (TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="conditional_reverse">
                    <parameter
                      name="p">
                      <builtintype
                        type="BOOLEAN"/>
                    </parameter>
                    <parameter
                      name="an_item">
                      <typename
                        name="reversible_topology"/>
                    </parameter>
                    <typename
                      name="reversible_topology"/>
                    <algorithm>
IF p THEN
RETURN(an_item);
ELSE
RETURN(topology_reversed(an_item));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="constraints_composite_curve_on_surface">
                    <parameter
                      name="c">
                      <typename
                        name="composite_curve_on_surface"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
REPEAT k := 1 TO n_segments BY 1;
IF ((NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve
.segments[k].parent_curve))) AND (NOT (
'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve
.segments[k].parent_curve)))) AND (NOT (
'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
composite_curve.segments[k].parent_curve))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="constraints_geometry_shell_based_surface_model">
                    <parameter
                      name="m">
                      <typename
                        name="shell_based_surface_model"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.
sbsm_boundary[j]))) AND (NOT (
'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j])))
THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="constraints_geometry_shell_based_wireframe_model">
                    <parameter
                      name="m">
                      <typename
                        name="shell_based_wireframe_model"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.
sbwm_boundary[j]))) AND (NOT (
'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j])))
THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="constraints_param_b_spline">
                    <parameter
                      name="degree">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="up_knots">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="up_cp">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="knot_mult">
                      <aggregate
                        type="LIST"/>
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="knots">
                      <aggregate
                        type="LIST"/>
                      <typename
                        name="parameter_value"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
k : INTEGER;
l : INTEGER;
sum : INTEGER;
result : BOOLEAN := TRUE;
END_LOCAL;
sum := knot_mult[1];
REPEAT i := 2 TO up_knots BY 1;
sum := sum + knot_mult[i];
END_REPEAT;
IF (((degree &lt; 1) OR (up_knots &lt; 2)) OR (up_cp &lt; degree)) OR (sum &lt;&gt; (
(degree + up_cp) + 2)) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[1];
IF (k &lt; 1) OR (k &gt; (degree + 1)) THEN
result := FALSE;
RETURN(result);
END_IF;
REPEAT i := 2 TO up_knots BY 1;
IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[i];
IF (i &lt; up_knots) AND (k &gt; degree) THEN
result := FALSE;
RETURN(result);
END_IF;
IF (i = up_knots) AND (k &gt; (degree + 1)) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="constraints_rectangular_composite_surface">
                    <parameter
                      name="s">
                      <typename
                        name="rectangular_composite_surface"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
REPEAT i := 1 TO s.n_u BY 1;
REPEAT j := 1 TO s.n_v BY 1;
IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
segments[i][j].parent_surface)) OR (
'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s
.segments[i][j].parent_surface))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u - 1 BY 1;
REPEAT j := 1 TO s.n_v BY 1;
IF s.segments[i][j].u_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u BY 1;
REPEAT j := 1 TO s.n_v - 1 BY 1;
IF s.segments[i][j].v_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="cross_product">
                    <parameter
                      name="arg1">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="arg2">
                      <typename
                        name="direction"/>
                    </parameter>
                    <typename
                      name="vector"/>
                    <algorithm>
LOCAL
v2 : LIST [3:3] OF REAL;
v1 : LIST [3:3] OF REAL;
mag : REAL;
res : direction;
result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (arg1.dim = 2)) OR ((NOT EXISTS(arg2)) OR (
arg2.dim = 2)) THEN
RETURN(?);
ELSE
BEGIN
v1 := normalise(arg1).direction_ratios;
v2 := normalise(arg2).direction_ratios;
res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
mag := 0;
REPEAT i := 1 TO 3 BY 1;
mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
result.orientation := res;
result.magnitude := SQRT(mag);
ELSE
result.orientation := arg1;
result.magnitude := 0;
END_IF;
RETURN(result);
END;
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="curve_weights_positive">
                    <parameter
                      name="b">
                      <typename
                        name="rational_b_spline_curve"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
IF b.weights[i] &lt;= 0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="derive_dimensional_exponents">
                    <parameter
                      name="x">
                      <typename
                        name="unit"/>
                    </parameter>
                    <typename
                      name="dimensional_exponents"/>
                    <algorithm>
LOCAL
result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
0);
END_LOCAL;
result := x.dimensions;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="dimension_of">
                    <parameter
                      name="item">
                      <typename
                        name="geometric_representation_item"/>
                    </parameter>
                    <typename
                      name="dimension_count"/>
                    <algorithm>
LOCAL
x : SET OF representation;
y : representation_context;
END_LOCAL;
x := using_representations(item);
IF SIZEOF(x) &gt; 0 THEN
y := x[1].context_of_items;
RETURN (y\geometric_representation_context.coordinate_space_dimension);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="dimensions_for_si_unit">
                    <parameter
                      name="n">
                      <typename
                        name="si_unit_name"/>
                    </parameter>
                    <typename
                      name="dimensional_exponents"/>
                    <algorithm>
CASE n OF
metre : RETURN(dimensional_exponents(1,0,0,0,0,0,0));
gram : RETURN(dimensional_exponents(0,1,0,0,0,0,0));
second : RETURN(dimensional_exponents(0,0,1,0,0,0,0));
ampere : RETURN(dimensional_exponents(0,0,0,1,0,0,0));
kelvin : RETURN(dimensional_exponents(0,0,0,0,1,0,0));
mole : RETURN(dimensional_exponents(0,0,0,0,0,1,0));
candela : RETURN(dimensional_exponents(0,0,0,0,0,0,1));
radian : RETURN(dimensional_exponents(0,0,0,0,0,0,0));
steradian : RETURN(dimensional_exponents(0,0,0,0,0,0,0));
hertz : RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
newton : RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
pascal : RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
joule : RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
watt : RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
coulomb : RETURN(dimensional_exponents(0,0,1,1,0,0,0));
volt : RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
farad : RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
ohm : RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
siemens : RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
weber : RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
tesla : RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
henry : RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
degree_celsius : RETURN(dimensional_exponents(0,0,0,0,1,0,0));
lumen : RETURN(dimensional_exponents(0,0,0,0,0,0,1));
lux : RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
becquerel : RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
gray : RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
sievert : RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
END_CASE;
                    </algorithm>
                  </function>

                  <function
                    name="dot_product">
                    <parameter
                      name="arg1">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="arg2">
                      <typename
                        name="direction"/>
                    </parameter>
                    <builtintype
                      type="REAL"/>
                    <algorithm>
LOCAL
ndim : INTEGER;
scalar : REAL;
vec1 : direction;
vec2 : direction;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
scalar := ?;
ELSE
IF arg1.dim &lt;&gt; arg2.dim THEN
scalar := ?;
ELSE
BEGIN
vec1 := normalise(arg1);
vec2 := normalise(arg2);
ndim := arg1.dim;
scalar := 0;
REPEAT i := 1 TO ndim BY 1;
scalar := scalar + (vec1.direction_ratios[i] * vec2.
direction_ratios[i]);
END_REPEAT;
END;
END_IF;
END_IF;
RETURN(scalar);
                    </algorithm>
                  </function>

                  <function
                    name="edge_reversed">
                    <parameter
                      name="an_edge">
                      <typename
                        name="edge"/>
                    </parameter>
                    <typename
                      name="edge"/>
                    <algorithm>
LOCAL
the_reverse : edge;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
the_reverse := oriented_edge(an_edge\oriented_edge.edge_element,NOT
an_edge\oriented_edge.orientation);
ELSE
the_reverse := oriented_edge(an_edge,FALSE);
END_IF;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="face_bound_reversed">
                    <parameter
                      name="a_face_bound">
                      <typename
                        name="face_bound"/>
                    </parameter>
                    <typename
                      name="face_bound"/>
                    <algorithm>
LOCAL
the_reverse : face_bound;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
THEN
the_reverse := face_bound(a_face_bound\face_bound.bound,
(NOT (a_face_bound\face_bound.orientation))) ||
face_outer_bound ();
ELSE
the_reverse := face_bound(a_face_bound.bound,NOT a_face_bound.
orientation);
END_IF;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="face_reversed">
                    <parameter
                      name="a_face">
                      <typename
                        name="face"/>
                    </parameter>
                    <typename
                      name="face"/>
                    <algorithm>
LOCAL
the_reverse : face;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
the_reverse := oriented_face(a_face\oriented_face.face_element,NOT
a_face\oriented_face.orientation);
ELSE
the_reverse := oriented_face(a_face,FALSE);
END_IF;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="first_proj_axis">
                    <parameter
                      name="z_axis">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="arg">
                      <typename
                        name="direction"/>
                    </parameter>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
x_vec : vector;
v : direction;
z : direction;
x_axis : direction;
END_LOCAL;
IF ((NOT EXISTS(z_axis)) OR (NOT EXISTS(arg))) OR (arg.dim &lt;&gt; 3) THEN
x_axis := ?;
ELSE
z_axis := normalise(z_axis);
IF NOT EXISTS(arg) THEN
IF z_axis &lt;&gt; direction([1,0,0]) THEN
v := direction([1,0,0]);
ELSE
v := direction([0,1,0]);
END_IF;
ELSE
IF cross_product(arg,z).magnitude = 0 THEN
RETURN(?);
ELSE
v := normalise(arg);
END_IF;
END_IF;
x_vec := scalar_times_vector(dot_product(v,z),z_axis);
x_axis := vector_difference(v,x_vec).orientation;
x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);
                    </algorithm>
                  </function>

                  <function
                    name="gbsf_check_curve">
                    <parameter
                      name="cv">
                      <typename
                        name="curve"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT (schema_name + '.CURVE' IN TYPEOF (cv)) THEN RETURN(TRUE);
END_IF;
IF SIZEOF ([schema_name + '.CIRCLE', schema_name + '.ELLIPSE']
* TYPEOF(cv)) = 1 THEN RETURN(TRUE);
ELSE
IF (schema_name + '.B_SPLINE_CURVE' IN TYPEOF(cv))
THEN RETURN(NOT (cv\b_spline_curve.self_intersect));
ELSE
IF schema_name + '.COMPOSITE_CURVE' IN TYPEOF(cv) THEN
RETURN (SIZEOF (QUERY (seg &lt;* cv\composite_curve.segments |
NOT (gbsf_check_curve(seg.parent_curve, schema_name)))) = 0);
ELSE
IF schema_name + '.CURVE_REPLICA' IN TYPEOF(cv) THEN
RETURN (gbsf_check_curve
(cv\curve_replica.parent_curve, schema_name));
ELSE
IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF(cv) THEN
RETURN ((gbsf_check_curve
(cv\offset_curve_3d.basis_curve, schema_name))
AND
(NOT cv\offset_curve_3d.self_intersect));
ELSE
IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN
RETURN
((gbsf_check_curve
(cv\pcurve.reference_to_curve\representation.items[1],
schema_name)) AND
(gbsf_check_surface
(cv\pcurve.basis_surface, schema_name)));
ELSE
IF schema_name + '.POLYLINE' IN TYPEOF(cv) THEN
IF (SIZEOF (cv\polyline.points) &gt;= 3) AND
(SIZEOF ((bag_to_set (USEDIN (cv,'')) -
bag_to_set (USEDIN (cv,
schema_name +
'.INTERSECTION_CURVE.CURVE_3D')))) = 0)
THEN RETURN (TRUE);
END_IF;
ELSE
IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN
IF gbsf_check_curve
(cv\surface_curve.curve_3d, schema_name) THEN
REPEAT i := 1 TO SIZEOF
(cv\surface_curve.associated_geometry);
IF schema_name + '.SURFACE' IN TYPEOF
(cv\surface_curve.associated_geometry[i]) THEN
IF NOT gbsf_check_surface
(cv\surface_curve.associated_geometry[i],
schema_name) THEN
RETURN(FALSE);
END_IF;
ELSE
IF schema_name + '.PCURVE' IN TYPEOF
(cv\surface_curve.associated_geometry[i]) THEN
IF NOT gbsf_check_curve
(cv\surface_curve.associated_geometry[i],
schema_name) THEN
RETURN(FALSE);
END_IF;
END_IF;
END_IF;
END_REPEAT;
RETURN(TRUE);
END_IF;
ELSE
IF (schema_name + '.TRIMMED_CURVE') IN TYPEOF (cv) THEN
IF SIZEOF ([schema_name + '.LINE',
schema_name + '.PARABOLA',
schema_name + '.HYPERBOLA'] *
TYPEOF (cv\trimmed_curve.basis_curve)) = 1
THEN RETURN (TRUE);
ELSE RETURN (gbsf_check_curve
(cv\trimmed_curve.basis_curve, schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="gbsf_check_point">
                    <parameter
                      name="pnt">
                      <typename
                        name="point"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT (schema_name + '.POINT' IN TYPEOF (pnt)) THEN RETURN(TRUE);
END_IF;
IF schema_name + '.CARTESIAN_POINT' IN TYPEOF (pnt) THEN
RETURN(TRUE);
ELSE
IF schema_name + '.POINT_ON_CURVE' IN TYPEOF (pnt) THEN
RETURN (gbsf_check_curve
(pnt\point_on_curve.basis_curve, schema_name));
ELSE
IF schema_name + '.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN
RETURN(gbsf_check_surface
(pnt\point_on_surface.basis_surface, schema_name));
ELSE
IF schema_name + '.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN
RETURN
((gbsf_check_curve
(pnt\degenerate_pcurve.reference_to_curve\representation.items[1],
schema_name))
AND (gbsf_check_surface
(pnt\degenerate_pcurve.basis_surface, schema_name)));
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="gbsf_check_surface">
                    <parameter
                      name="sf">
                      <typename
                        name="surface"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF NOT schema_name + '.SURFACE' IN TYPEOF (sf) THEN RETURN(TRUE);
END_IF;
IF schema_name + '.B_SPLINE_SURFACE' IN TYPEOF(sf) THEN
RETURN(NOT (sf\b_spline_surface.self_intersect));
ELSE
IF SIZEOF ([schema_name + '.SPHERICAL_SURFACE',
schema_name + '.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 3 THEN
RETURN(TRUE);
ELSE
IF schema_name + '.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN
IF SIZEOF ([schema_name + '.CONICAL_SURFACE',
schema_name + '.CYLINDRICAL_SURFACE',
schema_name + '.PLANE'] * TYPEOF
(sf\curve_bounded_surface.basis_surface)) = 1 THEN
RETURN(SIZEOF (QUERY (bcurve &lt;*
sf\curve_bounded_surface.boundaries |
NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);
ELSE
IF gbsf_check_surface
(sf\curve_bounded_surface.basis_surface, schema_name) THEN
RETURN(SIZEOF (QUERY (bcurve &lt;*
sf\curve_bounded_surface.boundaries |
NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);
END_IF;
END_IF;
ELSE
IF schema_name + '.OFFSET_SURFACE' IN TYPEOF(sf) THEN
RETURN ((gbsf_check_surface
(sf\offset_surface.basis_surface, schema_name))
AND
(NOT (sf\offset_surface.self_intersect)));
ELSE
IF schema_name + '.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
REPEAT i := 1 TO SIZEOF
(sf\rectangular_composite_surface.segments);
REPEAT j := 1 TO SIZEOF
(sf\rectangular_composite_surface.segments[i]);
IF NOT (gbsf_check_surface
(sf\rectangular_composite_surface.segments[i][j].
parent_surface, schema_name))
THEN RETURN (FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);
ELSE
IF schema_name + '.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) THEN
IF SIZEOF ([schema_name + '.CONICAL_SURFACE',
schema_name + '.CYLINDRICAL_SURFACE',
schema_name + '.PLANE'] * TYPEOF
(sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN
RETURN (TRUE);
ELSE
RETURN(gbsf_check_surface
(sf\rectangular_trimmed_surface.basis_surface,
schema_name));
END_IF;
ELSE
IF schema_name + '.SURFACE_REPLICA' IN TYPEOF (sf) THEN
RETURN (gbsf_check_surface
(sf\surface_replica.parent_surface, schema_name));
ELSE
IF schema_name + '.SWEPT_SURFACE' IN TYPEOF(sf) THEN
RETURN(gbsf_check_curve
(sf\swept_surface.swept_curve, schema_name));
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="get_basis_surface">
                    <parameter
                      name="c">
                      <typename
                        name="curve_on_surface"/>
                    </parameter>
                    <aggregate
                      type="SET"
                      lower="0"
                      upper="2"/>
                    <typename
                      name="surface"/>
                    <algorithm>
LOCAL
surfs : SET [0:2] OF surface;
n : INTEGER;
END_LOCAL;
surfs := [];
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
surfs := [c\pcurve.basis_surface];
ELSE
IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
n := SIZEOF(c\surface_curve.associated_geometry);
REPEAT i := 1 TO n BY 1;
surfs := surfs + associated_surface(c\surface_curve.
associated_geometry[i]);
END_REPEAT;
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
THEN
n := SIZEOF(c\composite_curve_on_surface.segments);
surfs := get_basis_surface(c\composite_curve_on_surface.
segments[1].parent_curve);
IF n &gt; 1 THEN
REPEAT i := 2 TO n BY 1;
surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
segments[i].parent_curve);
END_REPEAT;
END_IF;
END_IF;
RETURN(surfs);
                    </algorithm>
                  </function>

                  <function
                    name="item_in_context">
                    <parameter
                      name="item">
                      <typename
                        name="representation_item"/>
                    </parameter>
                    <parameter
                      name="cntxt">
                      <typename
                        name="representation_context"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
i : INTEGER;
y : BAG OF representation_item;
END_LOCAL;
IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') *
cntxt.representations_in_context) &gt; 0 THEN
RETURN(TRUE);
ELSE
y := QUERY (z &lt;* USEDIN(item,'') | (
'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)));
IF SIZEOF(y) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(y) BY 1;
IF item_in_context(y[i],cntxt) THEN
RETURN(TRUE);
END_IF;
END_REPEAT;
END_IF;
END_IF;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="leap_year">
                    <parameter
                      name="year">
                      <typename
                        name="year_number"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF (((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) =
0) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="list_face_loops">
                    <parameter
                      name="f">
                      <typename
                        name="face"/>
                    </parameter>
                    <aggregate
                      type="LIST"
                      lower="0"
                      upper="?"/>
                    <typename
                      name="loop"/>
                    <algorithm>
LOCAL
loops : LIST [0:?] OF loop := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
loops := loops + f.bounds[i].bound;
END_REPEAT;
RETURN(loops);
                    </algorithm>
                  </function>

                  <function
                    name="list_of_topology_reversed">
                    <parameter
                      name="a_list">
                      <typename
                        name="list_of_reversible_topology_item"/>
                    </parameter>
                    <typename
                      name="list_of_reversible_topology_item"/>
                    <algorithm>
LOCAL
the_reverse : list_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_list) BY 1;
the_reverse := topology_reversed(a_list[i]) + the_reverse;
END_REPEAT;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="list_to_array">
                    <parameter
                      name="lis">
                      <aggregate
                        type="LIST"
                        lower="0"
                        upper="?"/>
                      <builtintype
                        type="GENERIC"
                        typelabel="t"/>
                    </parameter>
                    <parameter
                      name="low">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="u">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <aggregate
                      type="ARRAY"
                      lower="low"
                      upper="u"/>
                    <builtintype
                      type="GENERIC"
                      typelabel="t"/>
                    <algorithm>
LOCAL
n : INTEGER;
res : ARRAY [low:u] OF GENERIC:t;
END_LOCAL;
n := SIZEOF(lis);
IF n &lt;&gt; ((u - low) + 1) THEN
RETURN(?);
ELSE
REPEAT i := 1 TO n BY 1;
res[(low + i) - 1] := lis[i];
END_REPEAT;
RETURN(res);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="list_to_set">
                    <parameter
                      name="l">
                      <aggregate
                        type="LIST"
                        lower="0"
                        upper="?"/>
                      <builtintype
                        type="GENERIC"
                        typelabel="t"/>
                    </parameter>
                    <aggregate
                      type="SET"/>
                    <builtintype
                      type="GENERIC"
                      typelabel="t"/>
                    <algorithm>
LOCAL
s : SET OF GENERIC:t := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(l) BY 1;
s := s + l[i];
END_REPEAT;
RETURN(s);
                    </algorithm>
                  </function>

                  <function
                    name="local_relatives_of_product_definitions">
                    <parameter
                      name="definition_set">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="product_definition"/>
                    </parameter>
                    <parameter
                      name="total_definitions">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="product_definition"/>
                    </parameter>
                    <parameter
                      name="relation_subtype">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <aggregate
                      type="SET"/>
                    <typename
                      name="product_definition"/>
                    <algorithm>
LOCAL
i : INTEGER;
local_def : SET OF product_definition := [];
local_pdr : SET OF product_definition_relationship := [];
local_total : SET OF product_definition := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
local_def := local_def + local_pdr[i].related_product_definition;
END_REPEAT;
IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
RETURN(local_def);
ELSE
local_total := total_definitions + local_def;
RETURN(local_def + local_relatives_of_product_definitions(local_def
- total_definitions,local_total,relation_subtype));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="make_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>

                    <parameter
                      name="low1">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="u1">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="low2">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
                    <parameter
                      name="u2">
                      <builtintype
                        type="INTEGER"/>
                    </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>


                    <algorithm>
LOCAL
n2 : INTEGER;
n1 : INTEGER;
res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
END_LOCAL;
n1 := SIZEOF(lis);
n2 := SIZEOF(lis[1]);
IF (n1 &lt;&gt; ((u1 - low1) + 1)) AND (n2 &lt;&gt; ((u2 - low2) + 1)) THEN
RETURN(?);
END_IF;
REPEAT i := 1 TO n1 BY 1;
IF SIZEOF(lis[i]) &lt;&gt; n2 THEN
RETURN(?);
END_IF;
END_REPEAT;
REPEAT i := 1 TO n1 BY 1;
resl[i] := list_to_array(lis[i],low2,u2);
END_REPEAT;
res := list_to_array(resl,low1,u1);
RETURN(res);
                    </algorithm>
                  </function>

                  <function
                    name="mixed_loop_type_set">
                    <parameter
                      name="l">
                      <aggregate
                        type="SET"
                        lower="0"
                        upper="?"/>
                      <typename
                        name="loop"/>
                    </parameter>
                    <builtintype
                      type="LOGICAL"/>
                    <algorithm>
LOCAL
i : INTEGER;
poly_loop_type : LOGICAL;
END_LOCAL;
IF SIZEOF(l) &lt;= 1 THEN
RETURN(FALSE);
END_IF;
poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
REPEAT i := 2 TO SIZEOF(l) BY 1;
IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt;
poly_loop_type THEN
RETURN(TRUE);
END_IF;
END_REPEAT;
RETURN(FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="msb_shells">
                    <parameter
                      name="brep">
                      <typename
                        name="manifold_solid_brep"/>
                    </parameter>
                    <parameter
                      name="schema_name">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <aggregate
                      type="SET"
                      lower="1"
                      upper="?"/>
                    <typename
                      name="closed_shell"/>
                    <algorithm>
IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
RETURN(brep\brep_with_voids.voids + brep.outer);
ELSE
RETURN([brep.outer]);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="normalise">
                    <parameter
                      name="arg">
                      <typename
                        name="vector_or_direction"/>
                    </parameter>
                    <typename
                      name="vector_or_direction"/>
                    <algorithm>
LOCAL
ndim : INTEGER;
v : direction;
vec : vector;
mag : REAL;
result : vector_or_direction;
END_LOCAL;
IF NOT EXISTS(arg) THEN
result := ?;
ELSE
ndim := arg.dim;
IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
BEGIN
vec := arg;
v := arg.orientation;
IF arg.magnitude = 0 THEN
RETURN(?);
ELSE
vec.magnitude := 1;
END_IF;
END;
ELSE
v := arg;
END_IF;
mag := 0;
REPEAT i := 1 TO ndim BY 1;
mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
mag := SQRT(mag);
REPEAT i := 1 TO ndim BY 1;
v.direction_ratios[i] := v.direction_ratios[i] / mag;
END_REPEAT;
IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
vec.orientation := v;
result := vec;
ELSE
result := v;
END_IF;
ELSE
RETURN(?);
END_IF;
END_IF;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="orthogonal_complement">
                    <parameter
                      name="vec">
                      <typename
                        name="direction"/>
                    </parameter>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
result : direction;
END_LOCAL;
IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN
RETURN(?);
ELSE
result.direction_ratios[1] := -vec.direction_ratios[2];
result.direction_ratios[2] := vec.direction_ratios[1];
RETURN(result);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="path_head_to_tail">
                    <parameter
                      name="a_path">
                      <typename
                        name="path"/>
                    </parameter>
                    <builtintype
                      type="LOGICAL"/>
                    <algorithm>
LOCAL
n : INTEGER;
p : LOGICAL := TRUE;
END_LOCAL;
n := SIZEOF(a_path.edge_list);
REPEAT i := 2 TO n BY 1;
p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
.edge_start);
END_REPEAT;
RETURN(p);
                    </algorithm>
                  </function>

                  <function
                    name="path_reversed">
                    <parameter
                      name="a_path">
                      <typename
                        name="path"/>
                    </parameter>
                    <typename
                      name="path"/>
                    <algorithm>
LOCAL
the_reverse : path;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
the_reverse := oriented_path(a_path\oriented_path.path_element,NOT
a_path\oriented_path.orientation);
ELSE
the_reverse := oriented_path(a_path,FALSE);
END_IF;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="relatives_of_product_definitions">
                    <parameter
                      name="definition_set">
                      <aggregate
                        type="SET"/>
                      <typename
                        name="product_definition"/>
                    </parameter>
                    <parameter
                      name="relation_subtype">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <aggregate
                      type="SET"/>
                    <typename
                      name="product_definition"/>
                    <algorithm>
FUNCTION local_relatives_of_product_definitions
(definition_set: SET OF product_definition;
total_definitions: SET OF product_definition;
relation_subtype: STRING): SET OF product_definition;
LOCAL
i : INTEGER;
local_def : SET OF product_definition := [];
local_pdr : SET OF product_definition_relationship := [];
local_total : SET OF product_definition := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
local_def := local_def + local_pdr[i].related_product_definition;
END_REPEAT;
IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
RETURN(local_def);
ELSE
local_total := total_definitions + local_def;
RETURN(local_def + local_relatives_of_product_definitions(
local_def - total_definitions,local_total,relation_subtype));
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="scalar_times_vector">
                    <parameter
                      name="scalar">
                      <builtintype
                        type="REAL"/>
                    </parameter>
                    <parameter
                      name="vec">
                      <typename
                        name="vector_or_direction"/>
                    </parameter>
                    <typename
                      name="vector"/>
                    <algorithm>
LOCAL
v : direction;
mag : REAL;
result : vector;
END_LOCAL;
IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
result := ?;
ELSE
IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
v := vec.orientation;
mag := scalar * vec.magnitude;
ELSE
v := vec;
mag := scalar;
END_IF;
IF mag &lt; 0 THEN
REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
v.direction_ratios[i] := -v.direction_ratios[i];
END_REPEAT;
mag := -mag;
END_IF;
result.orientation := normalise(v);
result.magnitude := mag;
END_IF;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="second_proj_axis">
                    <parameter
                      name="z_axis">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="x_axis">
                      <typename
                        name="direction"/>
                    </parameter>
                    <parameter
                      name="arg">
                      <typename
                        name="direction"/>
                    </parameter>
                    <typename
                      name="direction"/>
                    <algorithm>
LOCAL
temp : vector;
v : direction;
y_axis : vector;
END_LOCAL;
IF NOT EXISTS(arg) THEN
v := direction([0,1,0]);
ELSE
v := arg;
END_IF;
temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
y_axis := vector_difference(v,temp);
temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
y_axis := vector_difference(y_axis,temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);
                    </algorithm>
                  </function>

                  <function
                    name="set_of_topology_reversed">
                    <parameter
                      name="a_set">
                      <typename
                        name="set_of_reversible_topology_item"/>
                    </parameter>
                    <typename
                      name="set_of_reversible_topology_item"/>
                    <algorithm>
LOCAL
the_reverse : set_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_set) BY 1;
the_reverse := the_reverse + topology_reversed(a_set[i]);
END_REPEAT;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="shell_reversed">
                    <parameter
                      name="a_shell">
                      <typename
                        name="shell"/>
                    </parameter>
                    <typename
                      name="shell"/>
                    <algorithm>
LOCAL
the_reverse : shell;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
THEN
the_reverse := oriented_open_shell(a_shell\oriented_open_shell.
open_shell_element,NOT a_shell\oriented_open_shell.orientation);
ELSE
IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
the_reverse := oriented_open_shell(a_shell,FALSE);
ELSE
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
THEN
the_reverse := oriented_closed_shell(a_shell\
oriented_closed_shell.closed_shell_element,NOT a_shell\
oriented_closed_shell.orientation);
ELSE
IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
the_reverse := oriented_closed_shell(a_shell,FALSE);
ELSE
the_reverse := ?;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN(the_reverse);
                    </algorithm>
                  </function>

                  <function
                    name="surface_weights_positive">
                    <parameter
                      name="b">
                      <typename
                        name="rational_b_spline_surface"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper BY 1;
REPEAT j := 0 TO b.v_upper BY 1;
IF b.weights[i][j] &lt;= 0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(result);
                    </algorithm>
                  </function>

                  <function
                    name="topology_reversed">
                    <parameter
                      name="an_item">
                      <typename
                        name="reversible_topology"/>
                    </parameter>
                    <typename
                      name="reversible_topology"/>
                    <algorithm>
IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
RETURN(edge_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
RETURN(path_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
RETURN(face_bound_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
RETURN(face_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
RETURN(shell_reversed(an_item));
END_IF;
IF 'SET' IN TYPEOF(an_item) THEN
RETURN(set_of_topology_reversed(an_item));
END_IF;
IF 'LIST' IN TYPEOF(an_item) THEN
RETURN(list_of_topology_reversed(an_item));
END_IF;
RETURN(?);
                    </algorithm>
                  </function>

                  <function
                    name="unique_version_change_order">
                    <parameter
                      name="c">
                      <typename
                        name="action"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
LOCAL
ords : action_directive := c\directed_action.directive;
assign : SET OF change_request := [];
versions : SET OF product_definition_formation := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(ords.requests);
assign := assign + QUERY (ara &lt;* bag_to_set (USEDIN (ords.requests[i],
'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' +
'ASSIGNED_ACTION_REQUEST')) |
'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF (ara));
END_REPEAT;
REPEAT k := 1 TO SIZEOF(assign);
versions := versions + assign[k].items;
END_REPEAT;
RETURN (SIZEOF (QUERY (vers &lt;* versions |
NOT (SIZEOF (QUERY (other_vers &lt;* versions - vers |
vers.of_product :=: other_vers.of_product)) = 0))) = 0);
                    </algorithm>
                  </function>

                  <function
                    name="using_representations">
                    <parameter
                      name="item">
                      <typename
                        name="representation_item"/>
                    </parameter>
                    <aggregate
                      type="SET"/>
                    <typename
                      name="representation"/>
                    <algorithm>
LOCAL
results : SET OF representation;
result_bag : BAG OF representation;
intermediate_items : SET OF representation_item;
i : INTEGER;
END_LOCAL;
result_bag := USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
IF SIZEOF(result_bag) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(result_bag);
results := results + result_bag[i];
END_REPEAT;
END_IF;
intermediate_items := QUERY(z &lt;* bag_to_set(USEDIN(item , '')) |
'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));
IF SIZEOF(intermediate_items) &gt; 0 THEN
REPEAT i := 1 TO HIINDEX(intermediate_items);
results := results + using_representations(intermediate_items[i]);
END_REPEAT;
END_IF;
RETURN (results);
                    </algorithm>
                  </function>

                  <function
                    name="valid_calendar_date">
                    <parameter
                      name="date">
                      <typename
                        name="calendar_date"/>
                    </parameter>
                    <builtintype
                      type="LOGICAL"/>
                    <algorithm>
IF NOT ((1 &lt;= date.day_component) AND (date.day_component &lt;= 31))
THEN
RETURN(FALSE);
END_IF;
CASE date.month_component OF
4 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
6 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
9 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
11: RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
2 :
BEGIN
IF leap_year(date.year_component) THEN
RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 29));
ELSE
RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 28));
END_IF;
END;
OTHERWISE : RETURN(TRUE);
END_CASE;
                    </algorithm>
                  </function>

                  <function
                    name="valid_geometrically_bounded_wf_curve">
                    <parameter
                      name="crv">
                      <typename
                        name="curve"/>
                    </parameter>
                    <parameter
                      name="schma">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF SIZEOF ([schma + '.POLYLINE',
schma + '.B_SPLINE_CURVE',
schma + '.ELLIPSE',
schma + '.CIRCLE'] * TYPEOF (crv)) = 1
THEN RETURN (TRUE);
ELSE
IF (schma + '.TRIMMED_CURVE') IN TYPEOF (crv) THEN
IF SIZEOF ([schma + '.LINE',
schma + '.PARABOLA',
schma + '.HYPERBOLA'] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1
THEN RETURN (TRUE);
ELSE RETURN (valid_geometrically_bounded_wf_curve
(crv\trimmed_curve.basis_curve, schma));
END_IF;
ELSE
IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
THEN RETURN (valid_geometrically_bounded_wf_curve
(crv\offset_curve_3d.basis_curve, schma));
ELSE
IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv) THEN
RETURN (valid_geometrically_bounded_wf_curve
(crv\curve_replica.parent_curve, schma));
ELSE
IF (schma + '.COMPOSITE_CURVE') IN TYPEOF (crv) THEN
RETURN (SIZEOF (QUERY (ccs &lt;* crv\composite_curve.segments |
NOT (valid_geometrically_bounded_wf_curve
(ccs.parent_curve, schma))))
= 0);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="valid_geometrically_bounded_wf_point">
                    <parameter
                      name="pnt">
                      <typename
                        name="point"/>
                    </parameter>
                    <parameter
                      name="schma">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF (schma + '.CARTESIAN_POINT') IN TYPEOF (pnt)
THEN RETURN (TRUE);
ELSE
IF (schma + '.POINT_ON_CURVE') IN TYPEOF (pnt)
THEN RETURN (valid_geometrically_bounded_wf_curve
(pnt\point_on_curve.basis_curve, schma));
ELSE
IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
THEN RETURN (valid_geometrically_bounded_wf_point
(pnt\point_replica.parent_pt, schma));
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="valid_time">
                    <parameter
                      name="time">
                      <typename
                        name="local_time"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF EXISTS(time.second_component) THEN
RETURN(EXISTS(time.minute_component));
ELSE
RETURN(TRUE);
END_IF;
                    </algorithm>
                  </function>

                  <function
                    name="valid_units">
                    <parameter
                      name="m">
                      <typename
                        name="measure_with_unit"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(1,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,1,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,1,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,1,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN
TYPEOF(m.value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,1,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,1,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,1) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(2,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(3,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(1,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
value_component) THEN
IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
dimensional_exponents(0,0,0,0,0,0,0) THEN
RETURN(FALSE);
END_IF;
END_IF;
RETURN(TRUE);
                    </algorithm>
                  </function>

                  <function
                    name="valid_wireframe_edge_curve">
                    <parameter
                      name="crv">
                      <typename
                        name="curve"/>
                    </parameter>
                    <parameter
                      name="schma">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF SIZEOF ([schma + '.LINE',
schma + '.CIRCLE',
schma + '.ELLIPSE',
schma + '.PARABOLA',
schma + '.HYPERBOLA',
schma + '.B_SPLINE_CURVE',
schma + '.POLYLINE'] * TYPEOF (crv)) = 1
THEN RETURN (TRUE);
ELSE
IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv)
THEN RETURN
(valid_wireframe_edge_curve (crv\curve_replica.parent_curve, schma));
ELSE
IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
THEN RETURN
(valid_wireframe_edge_curve (crv\offset_curve_3d.basis_curve, schma));
END_IF;
END_IF;
END_IF;
RETURN (FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="valid_wireframe_vertex_point">
                    <parameter
                      name="pnt">
                      <typename
                        name="point"/>
                    </parameter>
                    <parameter
                      name="schma">
                      <builtintype
                        type="STRING"/>
                    </parameter>
                    <builtintype
                      type="BOOLEAN"/>
                    <algorithm>
IF (schma + '.CARTESIAN_POINT' IN TYPEOF (pnt))
THEN RETURN (TRUE);
ELSE
IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
THEN RETURN (valid_wireframe_vertex_point
(pnt\point_replica.parent_pt, schma));
END_IF;
END_IF;
RETURN (FALSE);
                    </algorithm>
                  </function>

                  <function
                    name="vector_difference">
                    <parameter
                      name="arg1">
                      <typename
                        name="vector_or_direction"/>
                    </parameter>
                    <parameter
                      name="arg2">
                      <typename
                        name="vector_or_direction"/>
                    </parameter>
                    <typename
                      name="vector"/>
                    <algorithm>
LOCAL
ndim : INTEGER;
mag2 : REAL;
mag1 : REAL;
mag : REAL;
res : direction;
vec1 : direction;
vec2 : direction;
result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
result := ?;
ELSE
BEGIN
IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1;
vec1 := arg1;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1;
vec2 := arg2;
END_IF;
vec1 := normalise(vec1);
vec2 := normalise(vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0;
REPEAT i := 1 TO ndim BY 1;
res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
mag2 * vec2.direction_ratios[i]);
mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
END_REPEAT;
IF mag &gt; 0 THEN
result.magnitude := SQRT(mag);
result.orientation := res;
ELSE
result.magnitude := 0;
result.orientation := vec1;
END_IF;
END;
END_IF;
RETURN(result);
                    </algorithm>
                  </function>

                </schema>
              </express>
