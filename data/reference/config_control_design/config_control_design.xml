<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2005-02-01T11:57:33" rcs.revision="1.0" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="config_control_design schema_instance"/>
   <schema name="config_control_design">
      <type name="ahead_or_behind">
         <enumeration items="ahead behind"/>
      </type>
      <type name="approved_item">
         <select selectitems="product_definition_formation product_definition configuration_effectivity configuration_item security_classification change_request change start_request start_work certification contract"/>
      </type>
      <type name="area_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="elliptic_arc polyline_form parabolic_arc circular_arc unspecified hyperbolic_arc"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="surf_of_linear_extrusion plane_surf generalised_cone toroidal_surf conical_surf spherical_surf unspecified ruled_surf surf_of_revolution cylindrical_surf quadric_surf"/>
      </type>
      <type name="boolean_operand">
         <select selectitems="solid_model"/>
      </type>
      <type name="certified_item">
         <select selectitems="supplied_part_relationship"/>
      </type>
      <type name="change_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="characterized_definition">
         <select selectitems="characterized_product_definition shape_definition"/>
      </type>
      <type name="characterized_product_definition">
         <select selectitems="product_definition product_definition_relationship"/>
      </type>
      <type name="classified_item">
         <select selectitems="product_definition_formation assembly_component_usage"/>
      </type>
      <type name="context_dependent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="contracted_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="count_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="date_time_item">
         <select selectitems="product_definition change_request start_request change start_work approval_person_organization contract security_classification certification"/>
      </type>
      <type name="date_time_select">
         <select selectitems="date_and_time"/>
      </type>
      <type name="day_in_month_number">
         <builtintype type="INTEGER"/>
      </type>
      <type name="day_in_week_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="(1 &lt;= SELF) AND (SELF &lt;= 7)"/>
      </type>
      <type name="day_in_year_number">
         <builtintype type="INTEGER"/>
      </type>
      <type name="descriptive_measure">
         <builtintype type="STRING"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="SELF &gt; 0"/>
      </type>
      <type name="geometric_set_select">
         <select selectitems="point curve surface"/>
      </type>
      <type name="hour_in_day">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="(0 &lt;= SELF) AND (SELF &lt; 24)"/>
      </type>
      <type name="identifier">
         <builtintype type="STRING"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>
      <type name="label">
         <builtintype type="STRING"/>
      </type>
      <type name="length_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="list_of_reversible_topology_item">
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="mass_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="measure_value">
         <select selectitems="area_measure context_dependent_measure count_measure descriptive_measure length_measure mass_measure plane_angle_measure parameter_value positive_length_measure positive_plane_angle_measure solid_angle_measure volume_measure"/>
      </type>
      <type name="minute_in_hour">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="(0 &lt;= SELF) AND (SELF &lt;= 59)"/>
      </type>
      <type name="month_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="(1 &lt;= SELF) AND (SELF &lt;= 12)"/>
      </type>
      <type name="parameter_value">
         <builtintype type="REAL"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="person_organization_item">
         <select selectitems="change start_work change_request start_request configuration_item product product_definition_formation product_definition contract security_classification"/>
      </type>
      <type name="person_organization_select">
         <select selectitems="person_and_organization"/>
      </type>
      <type name="plane_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="positive_length_measure">
         <typename name="length_measure"/>
         <where label="WR1" expression="SELF &gt; 0"/>
      </type>
      <type name="positive_plane_angle_measure">
         <typename name="plane_angle_measure"/>
         <where label="WR1" expression="SELF &gt; 0"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="pcurve_s2 pcurve_s1 curve_3d"/>
      </type>
      <type name="reversible_topology">
         <select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item"/>
      </type>
      <type name="reversible_topology_item">
         <select selectitems="edge path face face_bound closed_shell open_shell"/>
      </type>
      <type name="second_in_minute">
         <builtintype type="REAL"/>
         <where label="WR1" expression="(0 &lt;= SELF) AND (SELF &lt; 60)"/>
      </type>
      <type name="set_of_reversible_topology_item">
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="shape_definition">
         <select selectitems="product_definition_shape shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="shell">
         <select selectitems="open_shell closed_shell vertex_shell wire_shell"/>
      </type>
      <type name="si_prefix">
         <enumeration items="exa pico mega femto atto centi nano hecto micro tera giga milli peta deci kilo deca"/>
      </type>
      <type name="si_unit_name">
         <enumeration items="hertz degree_celsius siemens sievert lux watt ohm second becquerel pascal henry tesla volt joule kelvin ampere gram steradian mole lumen gray candela farad radian newton metre weber coulomb"/>
      </type>
      <type name="solid_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="source">
         <enumeration items="bought not_known made"/>
      </type>
      <type name="specified_item">
         <select selectitems="product_definition shape_aspect"/>
      </type>
      <type name="start_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="supported_item">
         <select selectitems="action_directive action action_method"/>
      </type>
      <type name="surface_model">
         <select selectitems="shell_based_surface_model"/>
      </type>
      <type name="text">
         <builtintype type="STRING"/>
      </type>
      <type name="transformation">
         <select selectitems="item_defined_transformation functionally_defined_transformation"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous cont_same_gradient_same_curvature cont_same_gradient continuous"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="parameter unspecified cartesian"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="unit">
         <select selectitems="named_unit"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      <type name="volume_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="week_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="(1 &lt;= SELF) AND (SELF &lt;= 53)"/>
      </type>
      <type name="wireframe_model">
         <select selectitems="shell_based_wireframe_model edge_based_wireframe_model"/>
      </type>
      <type name="work_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="year_number">
         <builtintype type="INTEGER"/>
      </type>
      <entity name="action">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="chosen_method">
            <typename name="action_method"/>
         </explicit>
      </entity>
      <entity name="action_assignment" abstract.supertype="YES">
         <explicit name="assigned_action">
            <typename name="action"/>
         </explicit>
      </entity>
      <entity name="action_directive">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="analysis">
            <typename name="text"/>
         </explicit>
         <explicit name="comment">
            <typename name="text"/>
         </explicit>
         <explicit name="requests">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_method">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="consequence">
            <typename name="text"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_request_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_request_solution">
         <explicit name="method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_request_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_action">
            <typename name="executed_action"/>
         </explicit>
      </entity>
      <entity name="address">
         <explicit name="internal_location" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_box" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="town" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="region" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_code" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="country" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="facsimile_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telephone_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="electronic_mail_address" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telex_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="EXISTS(internal_location)       OR&#10;       EXISTS(street_number)           OR&#10;       EXISTS(street)                  OR&#10;       EXISTS(postal_box)              OR&#10;       EXISTS(town)                    OR&#10;       EXISTS(region)                  OR&#10;       EXISTS(postal_code)             OR&#10;       EXISTS(country)                 OR&#10;       EXISTS(facsimile_number)        OR&#10;       EXISTS(telephone_number)        OR&#10;       EXISTS(electronic_mail_address) OR&#10;       EXISTS(telex_number)"/>
      </entity>
      <entity name="advanced_brep_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;        NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',&#10;        'CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)))&#10;        = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;        SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) =1 )) &gt; 0"/>
         <where label="WR3" expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;        NOT (SIZEOF (QUERY (csh &lt;*&#10;        msb_shells(msb, 'CONFIG_CONTROL_DESIGN') |&#10;        NOT (SIZEOF (QUERY(csf &lt;* csh.cfs_faces |&#10;        NOT('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(csf)))) = 0&#10;        ))) = 0))) = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* items |&#10;        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;        'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN&#10;        TYPEOF (msb\manifold_solid_brep.outer))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (brv &lt;* QUERY (it &lt;* items |&#10;        'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) |&#10;        NOT (SIZEOF (QUERY (csh &lt;* brv\brep_with_voids.voids |&#10;        csh\oriented_closed_shell.orientation)) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (mi &lt;*  QUERY (it &lt;* items |&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) |&#10;        NOT ('CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN&#10;        TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0"/>
      </entity>
      <entity name="advanced_face" supertypes="face_surface">
         <where label="WR1" expression="SIZEOF (['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',&#10;       'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',&#10;       'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] *&#10;       TYPEOF (face_geometry)) = 1"/>
         <where label="WR2" expression="SIZEOF (QUERY (bnd &lt;* bounds |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP',&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF (bnd)) = 1))) = 0"/>
         <where label="WR3" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN&#10;       TYPEOF (oe.edge_element)))) = 0))) = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_start))&#10;       AND&#10;       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_end)))))&#10;       = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.LINE',&#10;       'CONFIG_CONTROL_DESIGN.CONIC',&#10;       'CONFIG_CONTROL_DESIGN.POLYLINE',&#10;       'CONFIG_CONTROL_DESIGN.PCURVE',&#10;       'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] *&#10;       TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN&#10;       TYPEOF (elp_fbnds.bound)))) = 0"/>
         <where label="WR7" expression="(NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN&#10;       TYPEOF(face_geometry)))&#10;       OR&#10;       (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',&#10;       'CONFIG_CONTROL_DESIGN.CONIC',&#10;       'CONFIG_CONTROL_DESIGN.POLYLINE',&#10;       'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] *&#10;       TYPEOF (face_geometry\swept_surface.swept_curve)) = 1)"/>
         <where label="WR8" expression="SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;       TYPEOF (vlp_fbnds.bound\vertex_loop.loop_vertex)) AND&#10;       ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN&#10;       TYPEOF&#10;       (vlp_fbnds.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry)&#10;       )))) = 0"/>
      </entity>
      <entity name="alternate_product_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="alternate">
            <typename name="product"/>
         </explicit>
         <explicit name="base">
            <typename name="product"/>
         </explicit>
         <explicit name="basis">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="alternate_product_relationship" attribute="alternate"/>
            <unique.attribute entity-ref="alternate_product_relationship" attribute="base"/>
         </unique>
         <where label="WR1" expression="alternate :&lt;&gt;: base"/>
      </entity>
      <entity name="application_context">
         <explicit name="application">
            <typename name="text"/>
         </explicit>
         <inverse name="context_elements" entity="application_context_element" attribute="frame_of_reference">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="application_context_element" super.expression="ONEOF (product_context, product_definition_context, product_concept_context)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_protocol_definition">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="application_interpreted_model_schema_name">
            <typename name="label"/>
         </explicit>
         <explicit name="application_protocol_year">
            <typename name="year_number"/>
         </explicit>
         <explicit name="application">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="approval">
         <explicit name="status">
            <typename name="approval_status"/>
         </explicit>
         <explicit name="level">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_assignment" abstract.supertype="YES">
         <explicit name="assigned_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_date_time">
         <explicit name="date_time">
            <typename name="date_time_select"/>
         </explicit>
         <explicit name="dated_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_person_organization">
         <explicit name="person_organization">
            <typename name="person_organization_select"/>
         </explicit>
         <explicit name="authorized_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="role">
            <typename name="approval_role"/>
         </explicit>
      </entity>
      <entity name="approval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="related_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_role">
         <explicit name="role">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_status">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="area_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.AREA_UNIT' IN&#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="area_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 2) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.&#10;       thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="assembly_component_usage" supertypes="product_definition_usage" super.expression="ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence)">
         <explicit name="reference_designator" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="assembly_component_usage_substitute">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="base">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="substitute">
            <typename name="assembly_component_usage"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="assembly_component_usage_substitute" attribute="base"/>
            <unique.attribute entity-ref="assembly_component_usage_substitute" attribute="substitute"/>
         </unique>
         <where label="WR1" expression="base.relating_product_definition :=: substitute.&#10;       relating_product_definition"/>
         <where label="WR2" expression="base :&lt;&gt;: substitute"/>
      </entity>
      <entity name="axis1_placement" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="z" expression="NVL(normalise(axis),direction([0,0,1]))">
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="axis2_placement_2d" supertypes="placement">
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_2axes(ref_direction)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="axis2_placement_3d" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_axes(axis,ref_direction)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\placement.location.dim = 3"/>
         <where label="WR2" expression="(NOT EXISTS(axis)) OR (axis.dim = 3)"/>
         <where label="WR3" expression="(NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3)"/>
         <where label="WR4" expression="((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction))) OR (&#10;       cross_product(axis,ref_direction).magnitude &gt; 0)"/>
      </entity>
      <entity name="b_spline_curve" supertypes="bounded_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve">
         <explicit name="degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="curve_form">
            <typename name="b_spline_curve_form"/>
         </explicit>
         <explicit name="closed_curve">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="upper_index_on_control_points" expression="SIZEOF(&#10;                                  control_points_list) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="list_to_array(&#10;                                  control_points_list,0,&#10;                                  upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="WR1" expression="('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
         <explicit name="knot_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="upper_index_on_knots" expression="SIZEOF(knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(degree,upper_index_on_knots,&#10;       upper_index_on_control_points,knot_multiplicities,knots)"/>
         <where label="WR2" expression="SIZEOF(knot_multiplicities) = upper_index_on_knots"/>
      </entity>
      <entity name="b_spline_surface" supertypes="bounded_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="surface_form">
            <typename name="b_spline_surface_form"/>
         </explicit>
         <explicit name="u_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="v_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="u_upper" expression="SIZEOF(control_points_list) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="v_upper" expression="SIZEOF(control_points_list[1]) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="make_array_of_array(&#10;                      control_points_list,0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="WR1" expression="('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF)) OR&#10;       ('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
         <explicit name="u_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="knot_u_upper" expression="SIZEOF(u_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_v_upper" expression="SIZEOF(v_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;       knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,&#10;       u_knots)"/>
         <where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;       knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,&#10;       v_knots)"/>
         <where label="WR3" expression="SIZEOF(u_multiplicities) = knot_u_upper"/>
         <where label="WR4" expression="SIZEOF(v_multiplicities) = knot_v_upper"/>
      </entity>
      <entity name="bezier_curve" supertypes="b_spline_curve"/>
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
         <where label="WR1" expression="SELF\composite_curve.closed_curve"/>
      </entity>
      <entity name="bounded_curve" supertypes="curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, composite_curve)"/>
      <entity name="bounded_surface" supertypes="surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)"/>
      <entity name="brep_with_voids" supertypes="manifold_solid_brep">
         <explicit name="voids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="oriented_closed_shell"/>
         </explicit>
      </entity>
      <entity name="calendar_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_month_number"/>
         </explicit>
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
         <where label="WR1" expression="valid_calendar_date(SELF)"/>
      </entity>
      <entity name="cartesian_point" supertypes="point">
         <explicit name="coordinates">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="cartesian_transformation_operator" supertypes="geometric_representation_item functionally_defined_transformation" super.expression="cartesian_transformation_operator_3d">
         <explicit name="axis1" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="axis2" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="local_origin">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="scale" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived name="scl" expression="NVL(scale,1)">
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="scl &gt; 0"/>
      </entity>
      <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
         <explicit name="axis3" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="u" expression="base_axis(3,&#10;      SELF\cartesian_transformation_operator.axis1,&#10;      SELF\cartesian_transformation_operator.axis2, axis3)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\cartesian_transformation_operator.dim = 3"/>
      </entity>
      <entity name="cc_design_approval" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="approved_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_certification" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="certified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_contract" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="contracted_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_time_item"/>
         </explicit>
         <where label="WR1" expression="cc_design_date_time_correlation(SELF)"/>
      </entity>
      <entity name="cc_design_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person_organization_item"/>
         </explicit>
         <where label="WR1" expression="cc_design_person_and_organization_correlation(SELF)"/>
      </entity>
      <entity name="cc_design_security_classification" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="classified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_specification_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="specified_item"/>
         </explicit>
      </entity>
      <entity name="certification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="certification_type"/>
         </explicit>
      </entity>
      <entity name="certification_assignment" abstract.supertype="YES">
         <explicit name="assigned_certification">
            <typename name="certification"/>
         </explicit>
      </entity>
      <entity name="certification_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="change" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="change_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="change_request_item"/>
         </explicit>
      </entity>
      <entity name="circle" supertypes="conic">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="closed_shell" supertypes="connected_face_set"/>
      <entity name="composite_curve" supertypes="bounded_curve">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="composite_curve_segment"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="n_segments" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="closed_curve" expression="segments[n_segments].transition &lt;&gt;&#10;                    discontinuous">
            <builtintype type="LOGICAL"/>
         </derived>
         <where label="WR1" expression="((NOT closed_curve) AND&#10;       (SIZEOF (QUERY (temp &lt;* segments |&#10;       temp.transition = discontinuous)) = 1)) OR&#10;       ((closed_curve) AND&#10;       (SIZEOF (QUERY (temp &lt;* segments |&#10;       temp.transition = discontinuous)) = 0))"/>
      </entity>
      <entity name="composite_curve_on_surface" supertypes="composite_curve" super.expression="boundary_curve">
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="0" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="SIZEOF(basis_surface) &gt; 0"/>
         <where label="WR2" expression="constraints_composite_curve_on_surface(SELF)"/>
      </entity>
      <entity name="composite_curve_segment">
         <explicit name="transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <inverse name="using_curves" entity="composite_curve" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve)"/>
      </entity>
      <entity name="configuration_design">
         <explicit name="configuration">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="design">
            <typename name="product_definition_formation"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="configuration_design" attribute="configuration"/>
            <unique.attribute entity-ref="configuration_design" attribute="design"/>
         </unique>
      </entity>
      <entity name="configuration_effectivity" supertypes="product_definition_effectivity">
         <explicit name="configuration">
            <typename name="configuration_design"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="configuration_effectivity" attribute="configuration"/>
            <unique.attribute entity-ref="configuration_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="configuration_effectivity" attribute="id"/>
         </unique>
         <where label="WR1" expression="SELF\product_definition_effectivity.usage.&#10;       relating_product_definition IN&#10;       (USEDIN (SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PRODUCT_DEFINITION.FORMATION') +&#10;       relatives_of_product_definitions (bag_to_set (USEDIN&#10;       (SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PRODUCT_DEFINITION.FORMATION')), 'CONFIG_CONTROL_DESIGN.' +&#10;       'PRODUCT_DEFINITION_USAGE'))"/>
         <where label="WR2" expression="'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN&#10;       TYPEOF(SELF\product_definition_effectivity.usage)"/>
      </entity>
      <entity name="configuration_item">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="item_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="purpose" optional="YES">
            <typename name="label"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="configuration_item" attribute="id"/>
         </unique>
      </entity>
      <entity name="conic" supertypes="curve" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="conical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0"/>
      </entity>
      <entity name="connected_edge_set" supertypes="topological_representation_item">
         <explicit name="ces_edges">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="connected_face_set" supertypes="topological_representation_item" super.expression="ONEOF (closed_shell, open_shell)">
         <explicit name="cfs_faces">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
         </explicit>
      </entity>
      <entity name="context_dependent_shape_representation">
         <explicit name="representation_relation">
            <typename name="shape_representation_relationship"/>
         </explicit>
         <explicit name="represented_product_relation">
            <typename name="product_definition_shape"/>
         </explicit>
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN&#10;       TYPEOF(SELF.represented_product_relation.definition)"/>
      </entity>
      <entity name="context_dependent_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="contract">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="contract_type"/>
         </explicit>
      </entity>
      <entity name="contract_assignment" abstract.supertype="YES">
         <explicit name="assigned_contract">
            <typename name="contract"/>
         </explicit>
      </entity>
      <entity name="contract_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="conversion_based_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="conversion_factor">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="coordinated_universal_time_offset">
         <explicit name="hour_offset">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_offset" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="sense">
            <typename name="ahead_or_behind"/>
         </explicit>
      </entity>
      <entity name="curve" supertypes="geometric_representation_item" super.expression="ONEOF (line, conic, pcurve, surface_curve, offset_curve_3d, curve_replica)"/>
      <entity name="curve_bounded_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="boundary_curve"/>
         </explicit>
         <explicit name="implicit_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="NOT (implicit_outer AND&#10;       ('CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(boundaries)))"/>
         <where label="WR2" expression="(NOT implicit_outer) OR&#10;       ('CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN TYPEOF(basis_surface))"/>
         <where label="WR3" expression="SIZEOF (QUERY (temp &lt;* boundaries |&#10;       'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) &lt;= 1"/>
         <where label="WR4" expression="SIZEOF (QUERY (temp &lt;* boundaries |&#10;       temp\composite_curve_on_surface.basis_surface[1] :&lt;&gt;: &#10;       SELF.basis_surface)) = 0"/>
      </entity>
      <entity name="curve_replica" supertypes="curve">
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_curve.dim"/>
         <where label="WR2" expression="acyclic_curve_replica(SELF,parent_curve)"/>
      </entity>
      <entity name="cylindrical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="date" super.expression="ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date)">
         <explicit name="year_component">
            <typename name="year_number"/>
         </explicit>
      </entity>
      <entity name="date_and_time">
         <explicit name="date_component">
            <typename name="date"/>
         </explicit>
         <explicit name="time_component">
            <typename name="local_time"/>
         </explicit>
      </entity>
      <entity name="date_and_time_assignment" abstract.supertype="YES">
         <explicit name="assigned_date_and_time">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="role">
            <typename name="date_time_role"/>
         </explicit>
      </entity>
      <entity name="date_time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="dated_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_date">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="effectivity_end_date" optional="YES">
            <typename name="date_and_time"/>
         </explicit>
      </entity>
      <entity name="definitional_representation" supertypes="representation">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;       TYPEOF (SELF\representation.context_of_items)"/>
      </entity>
      <entity name="degenerate_pcurve" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(reference_to_curve\representation.items) = 1"/>
         <where label="WR2" expression="'CONFIG_CONTROL_DESIGN.CURVE' IN&#10;       TYPEOF (reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.items[1]\&#10;       geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
         <explicit name="select_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="wr1" expression="(major_radius &lt; minor_radius)"/>
      </entity>
      <entity name="design_context" supertypes="product_definition_context">
         <where label="WR1" expression="SELF.life_cycle_stage = 'design'"/>
      </entity>
      <entity name="design_make_from_relationship" supertypes="product_definition_relationship"/>
      <entity name="dimensional_exponents">
         <explicit name="length_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="mass_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="time_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="electric_current_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="thermodynamic_temperature_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="amount_of_substance_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="luminous_intensity_exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="directed_action" supertypes="executed_action">
         <explicit name="directive">
            <typename name="action_directive"/>
         </explicit>
      </entity>
      <entity name="direction" supertypes="geometric_representation_item">
         <explicit name="direction_ratios">
            <aggregate type="LIST" lower="2" upper="3"/>
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (QUERY (tmp &lt;* direction_ratios | tmp &lt;&gt; 0)) &gt; 0"/>
      </entity>
      <entity name="document">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="document_type"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="document" attribute="id"/>
         </unique>
      </entity>
      <entity name="document_reference" abstract.supertype="YES">
         <explicit name="assigned_document">
            <typename name="document"/>
         </explicit>
         <explicit name="source">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_type">
         <explicit name="product_data_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint">
         <explicit name="source">
            <typename name="document"/>
         </explicit>
         <explicit name="subject_element">
            <typename name="label"/>
         </explicit>
         <explicit name="subject_element_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="document_with_class" supertypes="document">
         <explicit name="class">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="edge" supertypes="topological_representation_item" super.expression="ONEOF (edge_curve, oriented_edge)">
         <explicit name="edge_start">
            <typename name="vertex"/>
         </explicit>
         <explicit name="edge_end">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="ebwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="connected_edge_set"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;        NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1&#10;        ))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;        SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1&#10;        )) &gt;= 1"/>
         <where label="WR3" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges |&#10;        NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (edges)))) = 0&#10;        ))) = 0))) = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (pline_edges &lt;* QUERY (edges &lt;* eb.ces_edges |&#10;        'CONFIG_CONTROL_DESIGN.POLYLINE' IN&#10;        TYPEOF (edges\edge_curve.edge_geometry)) |&#10;        NOT (SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points)&#10;        &gt; 2))) = 0))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges |&#10;        NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;        TYPEOF (edges.edge_start)) AND&#10;        ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;        TYPEOF (edges.edge_end))))) = 0))) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges |&#10;        NOT (valid_wireframe_edge_curve&#10;        (edges\edge_curve.edge_geometry, 'CONFIG_CONTROL_DESIGN')))) =&#10;        0))) = 0))) = 0"/>
         <where label="WR7" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (edges &lt;* eb.ces_edges |&#10;        NOT((valid_wireframe_vertex_point&#10;        (edges.edge_start\vertex_point.vertex_geometry,&#10;        'CONFIG_CONTROL_DESIGN')) AND&#10;        (valid_wireframe_vertex_point&#10;        (edges.edge_end\vertex_point.vertex_geometry,&#10;        'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0"/>
         <where label="WR8" expression="SIZEOF (QUERY (ebwm &lt;*&#10;        QUERY (it &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (eb &lt;*&#10;        ebwm\edge_based_wireframe_model.ebwm_boundary |&#10;        NOT (SIZEOF (QUERY (con_edges &lt;* QUERY (edges &lt;* eb.ces_edges |&#10;        'CONFIG_CONTROL_DESIGN.CONIC' IN&#10;        TYPEOF (edges\edge_curve.edge_geometry)) |&#10;        NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN&#10;        TYPEOF (con_edges\edge_curve.edge_geometry\conic.position)))) = 0&#10;        ))) = 0))) = 0"/>
         <where label="WR9" expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |&#10;        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |&#10;        NOT ('CONFIG_CONTROL_DESIGN.' +&#10;        'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION'&#10;        IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))&#10;        = 0"/>
      </entity>
      <entity name="edge_curve" supertypes="edge geometric_representation_item">
         <explicit name="edge_geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="edge_loop" supertypes="loop path">
         <derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="SELF\path.edge_list[1].edge_start :=:&#10;       SELF\path.edge_list[ne].edge_end"/>
      </entity>
      <entity name="effectivity" super.expression="ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="elementary_surface" supertypes="surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="ellipse" supertypes="conic">
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
         <explicit name="equivalent_point">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="executed_action" supertypes="action"/>
      <entity name="face" supertypes="topological_representation_item" super.expression="ONEOF (face_surface, oriented_face)">
         <explicit name="bounds">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
         </explicit>
         <where label="WR1" expression="NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)))"/>
         <where label="WR2" expression="SIZEOF (QUERY (temp &lt;* bounds |&#10;       'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp))) &lt;= 1"/>
      </entity>
      <entity name="face_bound" supertypes="topological_representation_item">
         <explicit name="bound">
            <typename name="loop"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="face_outer_bound" supertypes="face_bound"/>
      <entity name="face_surface" supertypes="face geometric_representation_item">
         <explicit name="face_geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="faceted_brep" supertypes="manifold_solid_brep"/>
      <entity name="faceted_brep_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* items |&#10;       NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* items |&#10;       SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1)) &gt; 0"/>
         <where label="WR3" expression="SIZEOF (QUERY (fbrep &lt;* QUERY ( it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) |&#10;       NOT (SIZEOF (QUERY (csh &lt;*&#10;       msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') |&#10;       NOT (SIZEOF (QUERY (fcs &lt;* csh.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fcs))&#10;       AND&#10;       (('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF&#10;       (fcs\face_surface.face_geometry))&#10;       AND&#10;       ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN&#10;       TYPEOF (fcs\face_surface.face_geometry\plane.position.location))))))&#10;       = 0))) = 0))) = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (fbrep &lt;* QUERY ( it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) |&#10;       NOT (SIZEOF (QUERY (csh &lt;*&#10;       msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') |&#10;       NOT (SIZEOF (QUERY (fcs &lt;* csh.cfs_faces |&#10;       NOT (SIZEOF (QUERY (bnds &lt;* fcs.bounds |&#10;       'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1)))&#10;       = 0))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;       'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN&#10;       TYPEOF (msb\manifold_solid_brep.outer))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (brv &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) |&#10;       NOT (SIZEOF (QUERY (csh &lt;* brv\brep_with_voids.voids |&#10;       csh\oriented_closed_shell.orientation)) = 0))) = 0"/>
         <where label="WR7" expression="SIZEOF (QUERY (mi &lt;*  QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN&#10;       TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))&#10;       = 0"/>
      </entity>
      <entity name="functionally_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="geometric_curve_set" supertypes="geometric_set">
         <where label="WR1" expression="SIZEOF (QUERY (temp &lt;* SELF\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(temp))) = 0"/>
      </entity>
      <entity name="geometric_representation_context" supertypes="representation_context">
         <explicit name="coordinate_space_dimension">
            <typename name="dimension_count"/>
         </explicit>
      </entity>
      <entity name="geometric_representation_item" supertypes="representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, vertex_point, poly_loop, solid_model, shell_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set)">
         <derived name="dim" expression="dimension_of(SELF)">
            <typename name="dimension_count"/>
         </derived>
         <where label="WR1" expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;       TYPEOF (using_rep.context_of_items)))) = 0"/>
      </entity>
      <entity name="geometric_set" supertypes="geometric_representation_item" super.expression="geometric_curve_set">
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_set_select"/>
         </explicit>
      </entity>
      <entity name="geometrically_bounded_surface_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* items |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* items |&#10;       SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt; 0"/>
         <where label="WR3" expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (it)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.' +&#10;       'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))&#10;       = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (pnt &lt;* QUERY (gsel &lt;*&#10;       gs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (gsel)) |&#10;       NOT (gbsf_check_point(pnt, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cv &lt;* QUERY (gsel &lt;*&#10;       gs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (gsel)) |&#10;       NOT (gbsf_check_curve(cv, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (gs &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (sf &lt;* QUERY (gsel &lt;*&#10;       gs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF (gsel)) |&#10;       NOT (gbsf_check_surface(sf, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0"/>
      </entity>
      <entity name="geometrically_bounded_wireframe_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;       SIZEOF(['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1&#10;       )) &gt;= 1"/>
         <where label="WR3" expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (curv &lt;* QUERY (elem &lt;* gcs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (elem)) |&#10;       NOT (valid_geometrically_bounded_wf_curve &#10;       (curv, 'CONFIG_CONTROL_DESIGN')))) = 0))) =0"/>
         <where label="WR4" expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (pnts &lt;* QUERY (elem &lt;*&#10;       gcs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (elem)) |&#10;       NOT (valid_geometrically_bounded_wf_point&#10;       (pnts, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cnc &lt;* QUERY (elem &lt;*&#10;       gcs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF (elem)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF&#10;       (cnc\conic.position)))) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (gcs &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (pline &lt;* QUERY (elem &lt;*&#10;       gcs\geometric_set.elements |&#10;       'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(elem)) |&#10;       NOT (SIZEOF (pline\polyline.points) &gt; 2))) = 0))) = 0"/>
         <where label="WR7" expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.' +&#10;       'GEOMETRICALLY_BOUNDED_WIREFRAME_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))&#10;       = 0"/>
      </entity>
      <entity name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="global_unit_assigned_context" supertypes="representation_context">
         <explicit name="units">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="hyperbola" supertypes="conic">
         <explicit name="semi_axis">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_imag_axis">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="intersection_curve" supertypes="surface_curve">
         <where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2"/>
         <where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1])&#10;       &lt;&gt; associated_surface(SELF\surface_curve.associated_geometry[2])"/>
      </entity>
      <entity name="item_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="length_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN&#10;       TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="length_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 1) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="line" supertypes="curve">
         <explicit name="pnt">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="dir">
            <typename name="vector"/>
         </explicit>
         <where label="WR1" expression="dir.dim = pnt.dim"/>
      </entity>
      <entity name="local_time">
         <explicit name="hour_component">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_component" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="second_component" optional="YES">
            <typename name="second_in_minute"/>
         </explicit>
         <explicit name="zone">
            <typename name="coordinated_universal_time_offset"/>
         </explicit>
         <where label="WR1" expression="valid_time (SELF)"/>
      </entity>
      <entity name="loop" supertypes="topological_representation_item" super.expression="ONEOF (vertex_loop, edge_loop, poly_loop)"/>
      <entity name="lot_effectivity" supertypes="effectivity">
         <explicit name="effectivity_lot_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_lot_size">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="manifold_solid_brep" supertypes="solid_model">
         <explicit name="outer">
            <typename name="closed_shell"/>
         </explicit>
      </entity>
      <entity name="manifold_surface_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* items |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* items |&#10;       SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED ITEM'] * TYPEOF (it)) = 1)) &gt; 0"/>
         <where label="WR3" expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.MAPPED ITEM' IN TYPEOF (it)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))&#10;       = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (sh &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.OPEN_SHELL',&#10;       'CONFIG_CONTROL_DESIGN.CLOSED_SHELL']&#10;       * TYPEOF (sh)) = 1))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.FACE_SURFACE',&#10;       'CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF (fa)) = 1))) = 0)))&#10;       = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (f_sf &lt;* QUERY (fa &lt;* cfs.cfs_faces |&#10;       'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fa)) |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (f_sf))&#10;       OR&#10;       (SIZEOF (['CONFIG_CONTROL_DESIGN.OFFSET_SURFACE',&#10;       'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'] * TYPEOF&#10;       (f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0"/>
         <where label="WR7" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (basis_surface_check(fa\face_surface.face_geometry,   &#10;       'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0"/>
         <where label="WR8" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (bnds &lt;* fa.bounds |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP',&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP']&#10;       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0"/>
         <where label="WR9" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items|&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element))))&#10;       = 0))) = 0)))) = 0))) = 0))) = 0"/>
         <where label="WR10" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe_cv &lt;* QUERY (oe &lt;* &#10;       elp_fbnds.bound\path.edge_list |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |&#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.CURVE_REPLICA',&#10;       'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D',&#10;       'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * &#10;       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) &#10;       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0"/>
         <where label="WR11" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT (basis_curve_check (oe.edge_element\edge_curve.edge_geometry,&#10;       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0)))) = 0))) = 0))) = 0"/>
         <where label="WR12" expression="SIZEOF (QUERY(sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list|&#10;       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF&#10;       (oe.edge_element.edge_start))&#10;       AND&#10;       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;       TYPEOF (oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0"/>
         <where label="WR13" expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa. bounds |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',&#10;       'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',&#10;       'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',&#10;       'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)&#10;       AND&#10;       (SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',&#10;       'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',&#10;       'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',&#10;       'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1&#10;       )))) = 0))) = 0)))) = 0))) = 0))) = 0"/>
      </entity>
      <entity name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="representation_item"/>
         </explicit>
         <where label="WR1" expression="acyclic_mapped_representation(using_representations(SELF), [SELF])"/>
      </entity>
      <entity name="mass_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.MASS_UNIT' IN&#10;       TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="mass_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 1) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="measure_with_unit" super.expression="ONEOF (length_measure_with_unit, mass_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit)">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <explicit name="unit_component">
            <typename name="unit"/>
         </explicit>
         <where label="WR1" expression="valid_units(SELF)"/>
      </entity>
      <entity name="mechanical_context" supertypes="product_context">
         <where label="WR1" expression="SELF.discipline_type = 'mechanical'"/>
      </entity>
      <entity name="named_unit" super.expression="ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit)">
         <explicit name="dimensions">
            <typename name="dimensional_exponents"/>
         </explicit>
      </entity>
      <entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="offset_curve_3d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="ref_direction">
            <typename name="direction"/>
         </explicit>
         <where label="WR1" expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)"/>
      </entity>
      <entity name="offset_surface" supertypes="surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="open_shell" supertypes="connected_face_set"/>
      <entity name="ordinal_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_year_number"/>
         </explicit>
         <where label="WR1" expression="(NOT leap_year(SELF.year_component) AND {1 &lt;= day_component &lt;= 365})&#10;       OR&#10;       (leap_year(SELF.year_component) AND {1 &lt;= day_component &lt;= 366})"/>
      </entity>
      <entity name="organization">
         <explicit name="id" optional="YES">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organization_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="related_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="organizational_address" supertypes="address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_project">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="responsible_organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="oriented_closed_shell" supertypes="closed_shell">
         <explicit name="closed_shell_element">
            <typename name="closed_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.orientation,&#10;                                      SELF.closed_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN&#10;       TYPEOF(SELF.closed_shell_element))"/>
      </entity>
      <entity name="oriented_edge" supertypes="edge">
         <explicit name="edge_element">
            <typename name="edge"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_start" expression="boolean_choose(SELF.orientation,&#10;                         SELF.edge_element.edge_start,&#10;                         SELF.edge_element.edge_end)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <derived name="edge_end" expression="boolean_choose(SELF.orientation,&#10;                         SELF.edge_element.edge_end,&#10;                         SELF.edge_element.edge_start)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN&#10;       TYPEOF (SELF.edge_element))"/>
      </entity>
      <entity name="oriented_face" supertypes="face">
         <explicit name="face_element">
            <typename name="face"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="bounds" expression="conditional_reverse&#10;                     (SELF.orientation, SELF.face_element.bounds)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
            <redeclaration entity-ref="face"/>
         </derived>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN&#10;       TYPEOF(SELF.face_element))"/>
      </entity>
      <entity name="oriented_open_shell" supertypes="open_shell">
         <explicit name="open_shell_element">
            <typename name="open_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.orientation,&#10;                                      SELF.open_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN&#10;       TYPEOF (SELF.open_shell_element))"/>
      </entity>
      <entity name="oriented_path" supertypes="path">
         <explicit name="path_element">
            <typename name="path"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_list" expression="conditional_reverse(SELF.orientation,&#10;                        SELF.path_element.edge_list)">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
            <redeclaration entity-ref="path"/>
         </derived>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN&#10;       TYPEOF (SELF.path_element))"/>
      </entity>
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
      <entity name="parabola" supertypes="conic">
         <explicit name="focal_dist">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="focal_dist &lt;&gt; 0"/>
      </entity>
      <entity name="parametric_representation_context" supertypes="representation_context"/>
      <entity name="path" supertypes="topological_representation_item" super.expression="ONEOF (edge_loop, oriented_path)">
         <explicit name="edge_list">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
         </explicit>
         <where label="WR1" expression="path_head_to_tail (SELF)"/>
      </entity>
      <entity name="pcurve" supertypes="curve">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (reference_to_curve\representation.items) = 1"/>
         <where label="WR2" expression="'CONFIG_CONTROL_DESIGN.CURVE' IN&#10;       TYPEOF(reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.items[1]\&#10;       geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="person">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="last_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="first_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="middle_names" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="prefix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="suffix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="person" attribute="id"/>
         </unique>
         <where label="WR1" expression="EXISTS (last_name) OR EXISTS (first_name)"/>
      </entity>
      <entity name="person_and_organization">
         <explicit name="the_person">
            <typename name="person"/>
         </explicit>
         <explicit name="the_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_person_and_organization">
            <typename name="person_and_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="person_and_organization_role"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="personal_address" supertypes="address">
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="placement" supertypes="geometric_representation_item" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)">
         <explicit name="location">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="plane" supertypes="elementary_surface"/>
      <entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN&#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="plane_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="point" supertypes="geometric_representation_item" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve)"/>
      <entity name="point_on_curve" supertypes="point">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="point_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_surface" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_replica" supertypes="point">
         <explicit name="parent_pt">
            <typename name="point"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_pt.dim"/>
         <where label="WR2" expression="acyclic_point_replica(SELF,parent_pt)"/>
      </entity>
      <entity name="poly_loop" supertypes="loop geometric_representation_item">
         <explicit name="polygon">
            <aggregate type="LIST" unique="YES" lower="3" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="polyline" supertypes="bounded_curve">
         <explicit name="points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="product">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="product" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_category">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_category_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="category">
            <typename name="product_category"/>
         </explicit>
         <explicit name="sub_category">
            <typename name="product_category"/>
         </explicit>
         <where label="WR1" expression="acyclic_product_category_relationship(SELF,[SELF.sub_category])"/>
      </entity>
      <entity name="product_concept">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="market_context">
            <typename name="product_concept_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="product_concept" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_concept_context" supertypes="application_context_element">
         <explicit name="market_segment_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_context" supertypes="application_context_element">
         <explicit name="discipline_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
      </entity>
      <entity name="product_definition_context" supertypes="application_context_element">
         <explicit name="life_cycle_stage">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage">
            <typename name="product_definition_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="product_definition_effectivity" attribute="id"/>
         </unique>
      </entity>
      <entity name="product_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product">
            <typename name="product"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_formation" attribute="id"/>
            <unique.attribute entity-ref="product_definition_formation" attribute="of_product"/>
         </unique>
      </entity>
      <entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity name="product_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="product_definition_shape" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_shape" attribute="definition"/>
         </unique>
         <where label="WR1" expression="'PRODUCT_PROPERTY_DEFINITION.CHARACTERIZED_PRODUCT_DEFINITION'&#10;       IN TYPEOF(SELF\property_definition.definition)"/>
      </entity>
      <entity name="product_definition_usage" supertypes="product_definition_relationship" super.expression="assembly_component_usage">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_usage" attribute="id"/>
            <unique.attribute entity-ref="product_definition_usage" attribute="relating_product_definition"/>
            <unique.attribute entity-ref="product_definition_usage" attribute="related_product_definition"/>
         </unique>
         <where label="WR1" expression="acyclic_product_definition_relationship (SELF,&#10;       [SELF\product_definition_relationship.related_product_definition],&#10;       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE.' +&#10;       'RELATED_PRODUCT_DEFINITION')"/>
      </entity>
      <entity name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="product_related_product_category" supertypes="product_category">
         <explicit name="products">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="promissory_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="property_definition">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_definition"/>
         </explicit>
      </entity>
      <entity name="property_definition_representation">
         <explicit name="definition">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="list_to_array(weights_data, 0, upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="SIZEOF(weights_data) =&#10;       SIZEOF (SELF\b_spline_curve.control_points_list)"/>
         <where label="WR2" expression="curve_weights_positive (SELF)"/>
      </entity>
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="make_array_of_array(weights_data, 0, u_upper, 0, v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(weights_data) =&#10;       SIZEOF(SELF\b_spline_surface.control_points_list)) AND&#10;       (SIZEOF(weights_data[1]) =&#10;       SIZEOF(SELF\b_spline_surface.control_points_list[1]))"/>
         <where label="WR2" expression="surface_weights_positive (SELF)"/>
      </entity>
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="surface_patch"/>
         </explicit>
         <derived name="n_u" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="n_v" expression="SIZEOF(segments[1])">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="[] = QUERY ( s &lt;* segments | n_v &lt;&gt; SIZEOF(s))"/>
         <where label="WR2" expression="constraints_rectangular_composite_surface(SELF)"/>
      </entity>
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="usense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vsense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="u1 &lt;&gt; u2"/>
         <where label="WR2" expression="v1 &lt;&gt; v2"/>
         <where label="WR3" expression="((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN&#10;       TYPEOF (basis_surface)) AND&#10;       (NOT ('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF (basis_surface)))) OR&#10;       ('CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN&#10;       TYPEOF (basis_surface))) OR (usense = (u2 &gt; u1))"/>
         <where label="WR4" expression="(('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN&#10;       TYPEOF (basis_surface)) OR&#10;       ('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'&#10;       IN TYPEOF (basis_surface))) OR (vsense = (v2 &gt; v1))"/>
      </entity>
      <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
         <explicit name="param_length">
            <typename name="parameter_value"/>
         </explicit>
         <where label="WR1" expression="param_length &gt; 0"/>
      </entity>
      <entity name="representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="representation_context"/>
         </explicit>
      </entity>
      <entity name="representation_context">
         <explicit name="context_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type">
            <typename name="text"/>
         </explicit>
         <inverse name="representations_in_context" entity="representation" attribute="context_of_items">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="representation_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (using_representations(SELF)) &gt; 0"/>
      </entity>
      <entity name="representation_map">
         <explicit name="mapping_origin">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation">
            <typename name="representation"/>
         </explicit>
         <inverse name="map_usage" entity="mapped_item" attribute="mapping_source">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="item_in_context(SELF.mapping_origin,&#10;       SELF.mapped_representation.context_of_items)"/>
      </entity>
      <entity name="representation_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1">
            <typename name="representation"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator">
            <typename name="transformation"/>
         </explicit>
         <where label="WR1" expression="SELF\representation_relationship.rep_1.context_of_items :&lt;&gt;:&#10;       SELF\representation_relationship.rep_2.context_of_items"/>
      </entity>
      <entity name="seam_curve" supertypes="surface_curve">
         <where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2"/>
         <where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1]) =&#10;       associated_surface(SELF\surface_curve.associated_geometry[2])"/>
         <where label="WR3" expression="'CONFIG_CONTROL_DESIGN.PCURVE' IN&#10;       TYPEOF (SELF\surface_curve.associated_geometry[1])"/>
         <where label="WR4" expression="'CONFIG_CONTROL_DESIGN.PCURVE' IN&#10;       TYPEOF (SELF\surface_curve.associated_geometry[2])"/>
      </entity>
      <entity name="security_classification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="security_level">
            <typename name="security_classification_level"/>
         </explicit>
      </entity>
      <entity name="security_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_security_classification">
            <typename name="security_classification"/>
         </explicit>
      </entity>
      <entity name="security_classification_level">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="serial_numbered_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_end_id" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="shape_aspect">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="of_shape">
            <typename name="product_definition_shape"/>
         </explicit>
         <explicit name="product_definitional">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="shape_aspect_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="shape_definition_representation" supertypes="property_definition_representation">
         <where label="WR1" expression="('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN&#10;       TYPEOF(SELF.definition.definition)) OR&#10;       ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN&#10;       TYPEOF(SELF.definition))"/>
         <where label="WR2" expression="'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN&#10;       TYPEOF(SELF.used_representation)"/>
      </entity>
      <entity name="shape_representation" supertypes="representation"/>
      <entity name="shape_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN&#10;       (TYPEOF (SELF\representation_relationship.rep_1) +&#10;       TYPEOF(SELF\representation_relationship.rep_2))"/>
      </entity>
      <entity name="shell_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="sbsm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="WR1" expression="constraints_geometry_shell_based_surface_model(SELF)"/>
      </entity>
      <entity name="shell_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="sbwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="WR1" expression="constraints_geometry_shell_based_wireframe_model(SELF)"/>
      </entity>
      <entity name="shell_based_wireframe_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;       NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',&#10;       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1&#10;       ))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (it &lt;* SELF\representation.items |&#10;       SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt;= 1"/>
         <where label="WR3" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list |&#10;       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN&#10;       TYPEOF (el.edge_element)))) = 0))) = 0))) = 0))) = 0"/>
         <where label="WR4" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (pline_el &lt;* QUERY (el &lt;* eloop\path.edge_list |&#10;       'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF&#10;       (el.edge_element\edge_curve.edge_geometry)) |&#10;       NOT (SIZEOF (pline_el.edge_element\edge_curve.&#10;       edge_geometry\polyline.points) &gt; 2))) &#10;       = 0))) = 0))) = 0))) = 0"/>
         <where label="WR5" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list |&#10;       NOT (valid_wireframe_edge_curve&#10;       (el.edge_element\edge_curve.edge_geometry,&#10;       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0))) = 0"/>
         <where label="WR6" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list |&#10;       NOT(('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN &#10;       TYPEOF (el.edge_element.edge_start))&#10;       AND&#10;       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN &#10;       TYPEOF (el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0"/>
         <where label="WR7" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (el &lt;* eloop\path.edge_list |&#10;       NOT((valid_wireframe_vertex_point&#10;       (el.edge_element.edge_start\vertex_point.vertex_geometry, &#10;       'CONFIG_CONTROL_DESIGN'))&#10;       AND&#10;       (valid_wireframe_vertex_point&#10;       (el.edge_element.edge_end\vertex_point.vertex_geometry, &#10;       'CONFIG_CONTROL_DESIGN'))))) = 0)))&#10;       = 0))) = 0))) = 0"/>
         <where label="WR8" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (eloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |&#10;       NOT (SIZEOF (QUERY (con_edges &lt;* QUERY (el &lt;* eloop\path.edge_list |&#10;       'CONFIG_CONTROL_DESIGN.CONIC' IN &#10;       TYPEOF (el.edge_element\edge_curve.edge_geometry)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN&#10;       TYPEOF (con_edges.edge_element\edge_curve.edge_geometry\&#10;       conic.position)))) = 0))) = 0))) = 0))) = 0"/>
         <where label="WR9" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (vloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;       TYPEOF (vloop.loop_vertex)))) = 0))) = 0))) = 0"/>
         <where label="WR10" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (ws &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |&#10;       NOT (SIZEOF (QUERY (vloop &lt;* QUERY (wsb &lt;* &#10;       ws\wire_shell.wire_shell_extent |&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) |&#10;       NOT(valid_wireframe_vertex_point&#10;       (vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry, &#10;       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0"/>
         <where label="WR11" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (vs &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN&#10;       TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex))))&#10;       = 0))) = 0"/>
         <where label="WR12" expression="SIZEOF (QUERY (sbwm &lt;* QUERY (it &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (vs &lt;* QUERY (sb &lt;*&#10;       sbwm\shell_based_wireframe_model.sbwm_boundary |&#10;       'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) |&#10;       NOT (valid_wireframe_vertex_point&#10;       (vs\vertex_shell.vertex_shell_extent.loop_vertex\&#10;       vertex_point.vertex_geometry,  'CONFIG_CONTROL_DESIGN'))))&#10;       = 0))) = 0"/>
         <where label="WR13" expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF\representation.items |&#10;       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |&#10;       NOT ('CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))&#10;       = 0"/>
      </entity>
      <entity name="si_unit" supertypes="named_unit">
         <explicit name="prefix" optional="YES">
            <typename name="si_prefix"/>
         </explicit>
         <explicit name="name">
            <typename name="si_unit_name"/>
         </explicit>
         <derived name="dimensions" expression="dimensions_for_si_unit(SELF.name)">
            <typename name="dimensional_exponents"/>
            <redeclaration entity-ref="named_unit"/>
         </derived>
      </entity>
      <entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN&#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="solid_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="solid_model" supertypes="geometric_representation_item" super.expression="manifold_solid_brep"/>
      <entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
         <explicit name="upper_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="next_usage">
            <typename name="next_assembly_usage_occurrence"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="specified_higher_usage_occurrence" attribute="upper_usage"/>
            <unique.attribute entity-ref="specified_higher_usage_occurrence" attribute="next_usage"/>
         </unique>
         <where label="WR1" expression="SELF :&lt;&gt;: upper_usage"/>
         <where label="WR2" expression="SELF\product_definition_relationship.relating_product_definition :=:&#10;       upper_usage.relating_product_definition"/>
         <where label="WR3" expression="SELF\product_definition_relationship.related_product_definition :=:&#10;       next_usage.related_product_definition"/>
         <where label="WR4" expression="upper_usage.related_product_definition :=:&#10;       next_usage.relating_product_definition"/>
         <where label="WR5" expression="NOT ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN&#10;       TYPEOF(upper_usage))"/>
      </entity>
      <entity name="spherical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="start_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="start_request_item"/>
         </explicit>
      </entity>
      <entity name="start_work" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="supplied_part_relationship" supertypes="product_definition_relationship"/>
      <entity name="surface" supertypes="geometric_representation_item" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)"/>
      <entity name="surface_curve" supertypes="curve" super.expression="ONEOF (intersection_curve, seam_curve)">
         <explicit name="curve_3d">
            <typename name="curve"/>
         </explicit>
         <explicit name="associated_geometry">
            <aggregate type="LIST" lower="1" upper="2"/>
            <typename name="pcurve_or_surface"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="preferred_surface_curve_representation"/>
         </explicit>
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="curve_3d.dim = 3"/>
         <where label="WR2" expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[1]))&#10;       OR (master_representation &lt;&gt; pcurve_s1)"/>
         <where label="WR3" expression="('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[2]))&#10;       OR (master_representation &lt;&gt; pcurve_s2)"/>
         <where label="WR4" expression="NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(curve_3d))"/>
      </entity>
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
         <explicit name="extrusion_axis">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="surface_of_revolution" supertypes="swept_surface">
         <explicit name="axis_position">
            <typename name="axis1_placement"/>
         </explicit>
         <derived name="axis_line" expression="line(axis_position.location,&#10;                           vector (axis_position.z, 1.0))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="surface_patch">
         <explicit name="parent_surface">
            <typename name="bounded_surface"/>
         </explicit>
         <explicit name="u_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="v_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="u_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="v_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <inverse name="using_surfaces" entity="rectangular_composite_surface" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="NOT ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN&#10;       TYPEOF (parent_surface))"/>
      </entity>
      <entity name="surface_replica" supertypes="surface">
         <explicit name="parent_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where label="WR1" expression="acyclic_surface_replica (SELF,parent_surface)"/>
      </entity>
      <entity name="swept_surface" supertypes="surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution)">
         <explicit name="swept_curve">
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="topological_representation_item" supertypes="representation_item" super.expression="ONEOF (vertex, edge, face_bound, face, connected_edge_set, connected_face_set, vertex_shell, wire_shell, (loop ANDOR path))"/>
      <entity name="toroidal_surface" supertypes="elementary_surface">
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="trimmed_curve" supertypes="bounded_curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="trim_1">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="trim_2">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="sense_agreement">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="trimming_preference"/>
         </explicit>
         <where label="WR1" expression="(HIINDEX(trim_1) = 1) XOR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))"/>
         <where label="WR2" expression="(HIINDEX(trim_2) = 1) XOR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))"/>
      </entity>
      <entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where label="WR1" expression="(NOT ('NUMBER' IN TYPEOF&#10;       (SELF\measure_with_unit.value_component))) OR&#10;       (SELF\measure_with_unit.value_component &gt;= 0)"/>
      </entity>
      <entity name="uniform_curve" supertypes="b_spline_curve"/>
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
      <entity name="vector" supertypes="geometric_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="magnitude &gt;= 0"/>
      </entity>
      <entity name="versioned_action_request">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="version">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="vertex" supertypes="topological_representation_item"/>
      <entity name="vertex_loop" supertypes="loop">
         <explicit name="loop_vertex">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="vertex_point" supertypes="vertex geometric_representation_item">
         <explicit name="vertex_geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="vertex_shell" supertypes="topological_representation_item">
         <explicit name="vertex_shell_extent">
            <typename name="vertex_loop"/>
         </explicit>
      </entity>
      <entity name="volume_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\&#10;       measure_with_unit.unit_component)"/>
      </entity>
      <entity name="volume_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 3) AND&#10;       (SELF\named_unit.dimensions.mass_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.time_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND&#10;       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0)"/>
      </entity>
      <entity name="week_of_year_and_day_date" supertypes="date">
         <explicit name="week_component">
            <typename name="week_in_year_number"/>
         </explicit>
         <explicit name="day_component" optional="YES">
            <typename name="day_in_week_number"/>
         </explicit>
      </entity>
      <entity name="wire_shell" supertypes="topological_representation_item">
         <explicit name="wire_shell_extent">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="loop"/>
         </explicit>
         <where label="wr1" expression="NOT mixed_loop_type_set(wire_shell_extent)"/>
      </entity>
      <rule name="acu_requires_security_classification" appliesto="assembly_component_usage cc_design_security_classification">
         <where label="WR1" expression="SIZEOF (QUERY (acu &lt;* assembly_component_usage |&#10;       NOT (SIZEOF (QUERY (ccdsc &lt;* cc_design_security_classification |&#10;       acu IN ccdsc.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="application_context_requires_ap_definition" appliesto="application_context application_protocol_definition">
         <where label="WR1" expression="SIZEOF (QUERY (ac &lt;* application_context |&#10;       NOT (SIZEOF (QUERY (apd &lt;* application_protocol_definition |&#10;       (ac :=: apd.application)&#10;       AND&#10;       (apd.application_interpreted_model_schema_name =&#10;       'config_control_design'))) = 1 ))) = 0"/>
      </rule>
      <rule name="approval_requires_approval_date_time" appliesto="approval approval_date_time">
         <where label="WR1" expression="SIZEOF (QUERY ( app &lt;* approval |&#10;       NOT (SIZEOF (QUERY (adt &lt;* approval_date_time |&#10;       app :=: adt.dated_approval)) = 1))) = 0"/>
      </rule>
      <rule name="approval_requires_approval_person_organization" appliesto="approval approval_person_organization">
         <where label="WR1" expression="SIZEOF (QUERY (app &lt;* approval |&#10;       NOT (SIZEOF (QUERY (apo &lt;* approval_person_organization |&#10;       app :=: apo.authorized_approval)) &gt;= 1))) = 0"/>
      </rule>
      <rule name="approvals_are_assigned" appliesto="approval approval_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (app &lt;* approval |&#10;       NOT (SIZEOF (QUERY (aa &lt;* approval_assignment |&#10;       app :=: aa.assigned_approval )) &gt;= 1 ))) = 0"/>
      </rule>
      <rule name="as_required_quantity" appliesto="measure_with_unit">
         <where label="WR1" expression="SIZEOF (QUERY (m &lt;* measure_with_unit |&#10;       ('CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN&#10;       TYPEOF (m.value_component)) AND&#10;       (NOT (m.value_component = 'as_required')))) = 0"/>
      </rule>
      <rule name="certification_requires_approval" appliesto="certification cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (cert &lt;* certification |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       cert IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="certification_requires_date_time" appliesto="certification cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (cert &lt;* certification |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       cert IN ccdta.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="change_request_requires_approval" appliesto="change_request cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (cr &lt;* change_request |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       cr IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="change_request_requires_date_time" appliesto="change_request cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (cr &lt;* change_request |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       cr IN ccdta.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="change_request_requires_person_organization" appliesto="change_request cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (cr &lt;* change_request |&#10;       NOT (SIZEOF (QUERY (ccpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       cr IN ccpoa.items )) &gt;= 1 ))) = 0"/>
      </rule>
      <rule name="change_requires_approval" appliesto="change cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (chg &lt;* change |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       chg IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="change_requires_date_time" appliesto="change cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (chg &lt;* change |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       (chg IN ccdta.items)&#10;       AND (ccdta.role.name = 'start_date'))) = 1 ))) = 0"/>
      </rule>
      <rule name="compatible_dimension" appliesto="cartesian_point direction representation_context geometric_representation_context">
         <where label="WR1" expression="SIZEOF (QUERY (x &lt;* cartesian_point |&#10;     SIZEOF (QUERY (y &lt;* geometric_representation_context |&#10;     (item_in_context(x,y)) AND (HIINDEX (x.coordinates) &lt;&gt;&#10;     y.coordinate_space_dimension))) &gt;  0)) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (x &lt;* direction |&#10;     SIZEOF (QUERY (y &lt;* geometric_representation_context |&#10;     (item_in_context(x,y)) AND (HIINDEX (x.direction_ratios) &lt;&gt;&#10;     y.coordinate_space_dimension))) &gt; 0)) = 0"/>
      </rule>
      <rule name="configuration_item_requires_approval" appliesto="configuration_item cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (ci &lt;* configuration_item |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       ci IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="configuration_item_requires_person_organization" appliesto="configuration_item cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (ci &lt;* configuration_item |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       ci IN ccdpoa.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="contract_requires_approval" appliesto="contract cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (c &lt;* contract |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       c IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="contract_requires_person_organization" appliesto="contract cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (c &lt;* contract |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       c IN ccdpoa.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="coordinated_assembly_and_shape" appliesto="next_assembly_usage_occurrence">
         <where label="WR1" expression="SIZEOF (QUERY (nauo &lt;* next_assembly_usage_occurrence |&#10;       NOT assembly_shape_is_defined(nauo))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_action_directive" appliesto="action_directive">
         <where label="WR1" expression="SIZEOF (QUERY (ad &lt;* action_directive |&#10;       NOT (SIZEOF (USEDIN (ad, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_approval_status" appliesto="approval_status">
         <where label="WR1" expression="SIZEOF (QUERY (ast &lt;* approval_status |&#10;     NOT (SIZEOF (USEDIN (ast, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_certification_type" appliesto="certification_type">
         <where label="WR1" expression="SIZEOF (QUERY (ct &lt;* certification_type |&#10;       NOT (SIZEOF (USEDIN (ct, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_contract_type" appliesto="contract_type">
         <where label="WR1" expression="SIZEOF(QUERY ( ct &lt;* contract_type |&#10;       NOT (SIZEOF (USEDIN (ct, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_date" appliesto="date">
         <where label="WR1" expression="SIZEOF (QUERY (dt &lt;* date |&#10;       NOT (SIZEOF(USEDIN (dt, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_date_time_role" appliesto="date_time_role">
         <where label="WR1" expression="SIZEOF (QUERY (dtr &lt;* date_time_role |&#10;       NOT (SIZEOF (USEDIN (dtr, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_document_type" appliesto="document_type">
         <where label="WR1" expression="SIZEOF (QUERY (dt &lt;* document_type |&#10;       NOT (SIZEOF (USEDIN (dt, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_named_unit" appliesto="named_unit">
         <where label="WR1" expression="SIZEOF (QUERY (nu &lt;* named_unit |&#10;       NOT (SIZEOF (USEDIN (nu, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_parametric_representation_context" appliesto="parametric_representation_context">
         <where label="WR1" expression="SIZEOF (QUERY (prc &lt;* parametric_representation_context |&#10;       NOT (SIZEOF (USEDIN (prc, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_person_and_organization_role" appliesto="person_and_organization_role">
         <where label="WR1" expression="SIZEOF (QUERY (poar &lt;* person_and_organization_role |&#10;       NOT (SIZEOF (USEDIN (poar, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_representation_item" appliesto="representation_item">
         <where label="WR1" expression="SIZEOF (QUERY (ri &lt;* representation_item |&#10;       NOT (SIZEOF (USEDIN (ri, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_security_classification_level" appliesto="security_classification_level">
         <where label="WR1" expression="SIZEOF (QUERY (scl &lt;* security_classification_level |&#10;       NOT (SIZEOF (USEDIN (scl, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="dependent_instantiable_shape_representation" appliesto="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (sr &lt;* shape_representation |&#10;       NOT (SIZEOF(USEDIN(sr, '')) &gt;= 1))) = 0"/>
      </rule>
      <rule name="design_context_for_property" appliesto="product_definition">
         <where label="WR1" expression="SIZEOF (QUERY (pd &lt;* product_definition |&#10;       (SIZEOF (USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PROPERTY_DEFINITION.DEFINITION') +&#10;       QUERY (pdr &lt;* USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |&#10;       SIZEOF (USEDIN (pdr, 'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' +&#10;       'DEFINITION')) &gt;= 1)) &gt;= 1) AND&#10;       (NOT ('CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN&#10;       TYPEOF (pd.frame_of_reference))))) = 0"/>
      </rule>
      <rule name="document_to_product_definition" appliesto="cc_design_specification_reference product_definition">
         <where label="WR1" expression="SIZEOF (QUERY (sp &lt;* cc_design_specification_reference |&#10;       NOT (((('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +&#10;       'RELATING_DOCUMENT' IN&#10;       ROLESOF (sp\document_reference.assigned_document)) AND&#10;       (SIZEOF (QUERY (it &lt;* sp.items |&#10;       NOT('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN&#10;       TYPEOF (it)))) = 0)))&#10;       OR&#10;       (NOT ('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +&#10;       'RELATING_DOCUMENT' IN&#10;       ROLESOF (sp\document_reference.assigned_document)))))) = 0"/>
      </rule>
      <rule name="effectivity_requires_approval" appliesto="effectivity cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (eff &lt;* effectivity |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       eff IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="geometric_representation_item_3d" appliesto="geometric_representation_item">
         <where label="WR1" expression="SIZEOF (QUERY (gri &lt;* geometric_representation_item |&#10;       NOT ((dimension_of (gri) = 3) OR&#10;       (SIZEOF (bag_to_set (USEDIN (gri, '')) - bag_to_set (USEDIN (gri,&#10;       'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION.ITEMS'))) = 0)&#10;       ))) = 0"/>
      </rule>
      <rule name="global_unit_assignment" appliesto="global_unit_assigned_context">
         <where label="WR1" expression="SIZEOF (QUERY (guac &lt;* global_unit_assigned_context |&#10;       NOT (SIZEOF (guac.units) = 3))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (guac &lt;* global_unit_assigned_context |&#10;       NOT ((SIZEOF (QUERY (u &lt;* guac.units |&#10;       'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF (u))) = 1) AND&#10;       (SIZEOF (QUERY (u &lt;* guac.units |&#10;       'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF (u))) = 1) AND&#10;       (SIZEOF (QUERY (u &lt;* guac.units |&#10;       'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF (u))) = 1&#10;       )))) = 0"/>
      </rule>
      <rule name="no_shape_for_make_from" appliesto="design_make_from_relationship">
         <where label="WR1" expression="SIZEOF (QUERY (dmfr &lt;* design_make_from_relationship |&#10;       NOT (SIZEOF (QUERY (pd &lt;* USEDIN (dmfr, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PROPERTY_DEFINITION.DEFINITION') |&#10;       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =&#10;       0))) = 0"/>
      </rule>
      <rule name="no_shape_for_supplied_part" appliesto="supplied_part_relationship">
         <where label="WR1" expression="SIZEOF (QUERY (spr &lt;* supplied_part_relationship |&#10;       NOT (SIZEOF (QUERY (pd &lt;* USEDIN (spr, 'CONFIG_CONTROL_DESIGN.' +&#10;       'PROPERTY_DEFINITION.DEFINITION') |&#10;       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =&#10;       0))) = 0"/>
      </rule>
      <rule name="product_concept_requires_configuration_item" appliesto="product_concept configuration_item">
         <where label="WR1" expression="SIZEOF (QUERY (pc &lt;* product_concept |&#10;       NOT (SIZEOF (QUERY (ci &lt;* configuration_item |&#10;       pc :=: ci.item_concept)) &gt;=1 ))) = 0"/>
      </rule>
      <rule name="product_definition_requires_approval" appliesto="product_definition cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (pd &lt;* product_definition |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       pd IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="product_definition_requires_date_time" appliesto="product_definition cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (pd &lt;* product_definition |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       pd IN ccdta.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="product_definition_requires_person_organization" appliesto="product_definition cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (pd &lt;* product_definition |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       pd IN ccdpoa.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="product_requires_person_organization" appliesto="product cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (prod &lt;* product |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       prod IN ccdpoa.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="product_requires_product_category" appliesto="product product_related_product_category">
         <where label="WR1" expression="SIZEOF (QUERY (prod &lt;* product |&#10;       NOT (SIZEOF (QUERY (prpc &lt;* product_related_product_category |&#10;       (prod IN prpc.products) AND&#10;       (prpc.name IN ['assembly', 'inseparable_assembly', 'detail',&#10;       'customer_furnished_equipment']))) = 1))) = 0"/>
      </rule>
      <rule name="product_requires_version" appliesto="product product_definition_formation">
         <where label="WR1" expression="SIZEOF (QUERY (prod &lt;* product |&#10;       NOT (SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       prod :=: pdf.of_product )) &gt;= 1 ))) = 0"/>
      </rule>
      <rule name="product_version_requires_approval" appliesto="product_definition_formation cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       pdf IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="product_version_requires_person_organization" appliesto="product_definition_formation cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       (pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator'))) = 1 ))) = 0"/>
         <where label="WR2" expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       (pdf IN ccdpoa.items) AND&#10;       (ccdpoa.role.name IN ['design_supplier', 'part_supplier']))) &gt;= 1)))&#10;       = 0"/>
      </rule>
      <rule name="product_version_requires_security_classification" appliesto="product_definition_formation cc_design_security_classification">
         <where label="WR1" expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       NOT (SIZEOF (QUERY (ccdsc &lt;* cc_design_security_classification |&#10;       pdf IN ccdsc.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="restrict_action_request_status" appliesto="action_request_status">
         <where label="WR1" expression="SIZEOF (QUERY (ars &lt;* action_request_status |&#10;       NOT (ars.status IN&#10;       ['proposed', 'in_work', 'issued', 'hold']))) = 0"/>
      </rule>
      <rule name="restrict_approval_status" appliesto="approval_status">
         <where label="WR1" expression="SIZEOF (QUERY (ast &lt;* approval_status |&#10;       NOT (ast.name IN&#10;       ['approved', 'not_yet_approved', 'disapproved', 'withdrawn']))) = 0"/>
      </rule>
      <rule name="restrict_certification_type" appliesto="certification_type">
         <where label="WR1" expression="SIZEOF (QUERY (ct &lt;* certification_type |&#10;       NOT (ct.description IN&#10;       ['design_supplier', 'part_supplier']))) = 0"/>
      </rule>
      <rule name="restrict_contract_type" appliesto="contract_type">
         <where label="WR1" expression="SIZEOF (QUERY (ct &lt;* contract_type |&#10;       NOT (ct.description IN ['fixed_price', 'cost_plus']))) = 0"/>
      </rule>
      <rule name="restrict_date_time_role" appliesto="date_time_role">
         <where label="WR1" expression="SIZEOF (QUERY (dtr &lt;* date_time_role |&#10;       NOT (dtr.name IN ['creation_date', 'request_date', 'release_date',&#10;       'start_date', 'contract_date', 'certification_date', 'sign_off_date',&#10;       'classification_date', 'declassification_date']))) = 0"/>
      </rule>
      <rule name="restrict_document_type" appliesto="document_type">
         <where label="WR1" expression="SIZEOF (QUERY (dt &lt;* document_type |&#10;       NOT (dt.product_data_type IN&#10;       ['material_specification', 'process_specification',&#10;       'design_specification', 'surface_finish_specification',&#10;       'cad_filename', 'drawing']))) = 0"/>
      </rule>
      <rule name="restrict_person_organization_role" appliesto="person_and_organization_role">
         <where label="WR1" expression="SIZEOF (QUERY (por &lt;* person_and_organization_role |&#10;       NOT (por.name IN ['request_recipient', 'initiator', 'part_supplier',&#10;       'design_supplier', 'configuration_manager', 'contractor',&#10;       'classification_officer', 'creator', 'design_owner']))) = 0"/>
      </rule>
      <rule name="restrict_product_category_value" appliesto="product_related_product_category">
         <where label="WR1" expression="SIZEOF (QUERY (prpc &lt;* product_related_product_category |&#10;       NOT (prpc.name IN ['assembly', 'detail', &#10;       'customer_furnished_equipment', 'inseparable_assembly', 'cast',&#10;       'coined', 'drawn', 'extruded', 'forged', 'formed', 'machined',&#10;       'molded', 'rolled', 'sheared'])))&#10;       = 0"/>
      </rule>
      <rule name="restrict_security_classification_level" appliesto="security_classification_level">
         <where label="WR1" expression="SIZEOF (QUERY (scl &lt;* security_classification_level |&#10;       NOT (scl.name IN ['unclassified', 'classified', 'proprietary',&#10;       'confidential', 'secret', 'top_secret']))) = 0"/>
      </rule>
      <rule name="security_classification_optional_date_time" appliesto="security_classification cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sc &lt;* security_classification |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       (sc IN ccdta.items) AND&#10;       ('declassification_date' = ccdta.role.name))) &lt;= 1 ))) = 0"/>
      </rule>
      <rule name="security_classification_requires_approval" appliesto="security_classification cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (sc &lt;* security_classification |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       sc IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="security_classification_requires_date_time" appliesto="security_classification cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sc &lt;* security_classification |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       (sc IN ccdta.items) AND&#10;       ('classification_date' = ccdta.role.name))) = 1 ))) = 0"/>
      </rule>
      <rule name="security_classification_requires_person_organization" appliesto="security_classification cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sc &lt;* security_classification |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       sc IN ccdpoa.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="start_request_requires_approval" appliesto="start_request cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (sr &lt;* start_request |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       sr IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="start_request_requires_date_time" appliesto="start_request cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sr &lt;* start_request |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       sr IN ccdta.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="start_request_requires_person_organization" appliesto="start_request cc_design_person_and_organization_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sr &lt;* start_request |&#10;       NOT (SIZEOF (QUERY (ccdpoa &lt;*&#10;       cc_design_person_and_organization_assignment |&#10;       sr IN ccdpoa.items )) &gt;= 1 ))) = 0"/>
      </rule>
      <rule name="start_work_requires_approval" appliesto="start_work cc_design_approval">
         <where label="WR1" expression="SIZEOF (QUERY (sw &lt;* start_work |&#10;       NOT (SIZEOF (QUERY (ccda &lt;* cc_design_approval |&#10;       sw IN ccda.items )) = 1 ))) = 0"/>
      </rule>
      <rule name="start_work_requires_date_time" appliesto="start_work cc_design_date_and_time_assignment">
         <where label="WR1" expression="SIZEOF (QUERY (sw &lt;* start_work |&#10;       NOT (SIZEOF (QUERY (ccdta &lt;* cc_design_date_and_time_assignment |&#10;       (sw IN ccdta.items) &#10;       AND (ccdta.role.name = 'start_date'))) = 1 ))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_action" appliesto="action">
         <where label="WR1" expression="SIZEOF (QUERY (act &lt;* action |&#10;       NOT ('CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_effectivity" appliesto="effectivity">
         <where label="WR1" expression="SIZEOF (QUERY (eff &lt;* effectivity |&#10;       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',&#10;       'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',&#10;       'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] *&#10;       TYPEOF (eff)) = 1) AND&#10;       ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN TYPEOF(eff)))))&#10;       = 0"/>
      </rule>
      <rule name="subtype_mandatory_product_context" appliesto="product_context">
         <where label="WR1" expression="SIZEOF (QUERY (pc &lt;* product_context |&#10;       NOT ('CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_product_definition_formation" appliesto="product_definition_formation">
         <where label="WR1" expression="SIZEOF (QUERY (pdf &lt;* product_definition_formation |&#10;       NOT ('CONFIG_CONTROL_DESIGN.' +&#10;       'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN&#10;       TYPEOF(pdf)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_product_definition_usage" appliesto="product_definition_usage">
         <where label="WR1" expression="SIZEOF (QUERY (pdu &lt;* product_definition_usage |&#10;       NOT ('CONFIG_CONTROL_DESIGN.' +&#10;       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdu)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_representation" appliesto="representation">
         <where label="WR1" expression="SIZEOF (QUERY (rep &lt;* representation |&#10;       NOT ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep))))&#10;       = 0"/>
      </rule>
      <rule name="subtype_mandatory_representation_context" appliesto="representation_context">
         <where label="WR1" expression="SIZEOF (QUERY (rep_cntxt &lt;* representation_context |&#10;       NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;       TYPEOF(rep_cntxt)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_shape_representation" appliesto="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (sr &lt;* shape_representation |&#10;       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.' +&#10;       'ADVANCED_BREP_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.' +&#10;       'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',&#10;       'CONFIG_CONTROL_DESIGN.' +&#10;       'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] *&#10;       TYPEOF (sr)) = 1) OR&#10;       (SIZEOF (QUERY (it &lt;* sr\representation.items |&#10;       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (it))))&#10;       = 0) OR&#10;       (SIZEOF (QUERY (sdr &lt;* QUERY (pdr &lt;* USEDIN (sr,&#10;       'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +&#10;       'USED_REPRESENTATION') |&#10;       'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN&#10;       TYPEOF (pdr)) | &#10;       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',&#10;       'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF&#10;       (sdr.definition)) = 1))) = 0)))) = 0"/>
      </rule>
      <rule name="unique_version_change_order_rule" appliesto="change">
         <where label="WR1" expression="SIZEOF (QUERY (c &lt;* change |&#10;       NOT (unique_version_change_order (c.assigned_action)))) = 0"/>
      </rule>
      <rule name="versioned_action_request_requires_solution" appliesto="versioned_action_request action_request_solution">
         <where label="WR1" expression="SIZEOF (QUERY (ar &lt;* versioned_action_request |&#10;       NOT (SIZEOF (QUERY (ars &lt;* action_request_solution |&#10;       ar :=: ars.request)) &gt;= 1))) = 0"/>
      </rule>
      <rule name="versioned_action_request_requires_status" appliesto="versioned_action_request action_request_status">
         <where label="WR1" expression="SIZEOF (QUERY (ar &lt;* versioned_action_request |&#10;       NOT (SIZEOF (QUERY (ars &lt;* action_request_status |&#10;       ar :=: ars.assigned_request)) = 1))) = 0"/>
      </rule>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
END_IF;</algorithm>
      </function>
      <function name="acyclic_mapped_representation">
         <parameter name="parent_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="children_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  i : INTEGER;
  x : SET OF representation_item;
  y : SET OF representation_item;
END_LOCAL;
x := QUERY ( z &lt;* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM'
    IN TYPEOF(z)) );
IF SIZEOF(x) &gt; 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF x[i]\mapped_item.mapping_source.mapped_representation IN
        parent_set THEN
      RETURN(FALSE);
    END_IF;
    IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
        .mapping_source.mapped_representation,x[i]\mapped_item.
        mapping_source.mapped_representation.items) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
x := children_set - x;
IF SIZEOF(x) &gt; 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    y := QUERY ( z &lt;* bag_to_set(USEDIN(x[i],'')) | (
        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
    IF NOT acyclic_mapped_representation(parent_set,y) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
END_IF;</algorithm>
      </function>
      <function name="acyclic_product_category_relationship">
         <parameter name="relation">
            <typename name="product_category_relationship"/>
         </parameter>
         <parameter name="children">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_category"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
  i              : INTEGER;
  x              : SET OF product_category_relationship;
  local_children : SET OF product_category;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(children) BY 1;
  IF relation.category :=: children[i] THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' +
    'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
local_children := children + relation.category;
IF SIZEOF(x) &gt; 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF NOT acyclic_product_category_relationship(x[i],local_children)
         THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
  i               : INTEGER;
  x               : SET OF product_definition_relationship;
  local_relatives : SET OF product_definition;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(relatives) BY 1;
  IF relation.relating_product_definition :=: relatives[i] THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.relating_product_definition,
    specific_relation));
local_relatives := relatives + relation.relating_product_definition;
IF SIZEOF(x) &gt; 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF NOT acyclic_product_definition_relationship(x[i],
        local_relatives,specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
     THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_surface_replica(rep,parent\surface_replica.
      parent_surface));
END_IF;</algorithm>
      </function>
      <function name="assembly_shape_is_defined">
         <parameter name="assy">
            <typename name="next_assembly_usage_occurrence"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
        sdr_set : SET OF shape_definition_representation := [];
        srr_set : SET OF shape_representation_relationship := [];
  END_LOCAL;

  -- Gather all instances of shape_definition_representation where the
  -- component part has a representation defined for it.

  sdr_set := QUERY (pdr &lt;* bag_to_set (USEDIN
             (assy.related_product_definition,
             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
             'DEFINITION.DEFINITION')) |
             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF (pdr)) +
             QUERY (pdr &lt;* bag_to_set (
             USEDIN (assy.related_product_definition,
             'CONFIG_CONTROL_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION.' +
             'DEFINITION.RELATED_PRODUCT_DEFINITION')) |
             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF (pdr));

  -- If there is a representation defined for the component part

  IF SIZEOF (sdr_set) &gt; 0 THEN

    -- For each representation of the shape of the component part gather all
    -- instances of shape_representation_relationship where the
    -- representation of component part is related to another 
    -- representation.

    REPEAT i := 1 TO HIINDEX (sdr_set);
      srr_set := QUERY (rr &lt;* bag_to_set (
                 USEDIN (sdr_set[i]\
                 property_definition_representation.used_representation,
                 'CONFIG_CONTROL_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2')) |
                 'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION_RELATIONSHIP' IN
                 TYPEOF (rr));

      -- If there is a shape_representation_relationship where the component
      -- part's shape_representation is related to another shape_-
      -- representation.

      IF SIZEOF (srr_set) &gt; 0 THEN

        -- For each shape_representation_relationship in that set

        REPEAT j := 1 TO HIINDEX (srr_set);

          -- If the other shape_representation in the shape_representation_-
          -- relationship is the  shape_representation of the assembly
          -- product_definition in at least one instance.

          IF SIZEOF (QUERY (pdr &lt;* bag_to_set (USEDIN
            (srr_set[j]\representation_relationship.rep_1,
            'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
            'USED_REPRESENTATION')) |
            'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
            TYPEOF (pdr)) *
            QUERY (pdr &lt;* bag_to_set (
            USEDIN (assy.relating_product_definition,
            'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
            'USED_REPRESENTATION.DEFINITION')) |
            'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION'
            IN TYPEOF (pdr))) &gt;= 1 THEN

            -- If the shape_representation_relationship and the product_-
            -- definition_relationship of each occurrence of the component
            -- and assembly relationship is not given via the
            -- context_dependent_shape_representation then return FALSE


            IF SIZEOF (QUERY (cdsr &lt;*
              USEDIN (assy, 'CONFIG_CONTROL_DESIGN.' +
              'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
              'REPRESENTED_PRODUCT_RELATION') |
              NOT ((cdsr.represented_product_relation.definition :=: assy) AND
              (cdsr.representation_relation :=: srr_set[j])))) &gt; 0
              THEN RETURN (FALSE);
            END_IF;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;

  -- If the shape of the component is not specified or there are no
  -- violations then return TRUE

  RETURN (TRUE);</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
  surf : surface;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
  surf := arg.basis_surface;
ELSE
  surf := arg;
END_IF;
RETURN(surf);</algorithm>
      </function>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate type="BAG" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
    the_set : SET OF GENERIC:intype := [];
    i       : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) &gt; 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
  u      : LIST [2:3] OF direction;
  vec    : direction;
  factor : REAL;
END_LOCAL;
IF dim = 3 THEN
  u[3] := NVL(normalise(axis3),direction([0,0,1]));
  u[1] := first_proj_axis(u[3],axis1);
  u[2] := second_proj_axis(u[3],u[1],axis2);
ELSE
  u[3] := ?;
  IF EXISTS(axis1) THEN
    u[1] := normalise(axis1);
    u[2] := orthogonal_complement(u[1]);
    IF EXISTS(axis2) THEN
      factor := dot_product(axis2,u[2]);
      IF factor &lt; 0 THEN
        u[2].direction_ratios[1] := -u[2].direction_ratios[1];
        u[2].direction_ratios[2] := -u[2].direction_ratios[2];
      END_IF;
    END_IF;
  ELSE
    IF EXISTS(axis2) THEN
      u[2] := normalise(axis2);
      u[1] := orthogonal_complement(u[2]);
      u[1].direction_ratios[1] := -u[1].direction_ratios[1];
      u[1].direction_ratios[2] := -u[1].direction_ratios[2];
    ELSE
      u[1].direction_ratios[1] := 1;
      u[1].direction_ratios[2] := 0;
      u[2].direction_ratios[1] := 0;
      u[2].direction_ratios[2] := 1;
    END_IF;
  END_IF;
END_IF;
RETURN(u);</algorithm>
      </function>
      <function name="basis_curve_check">
         <parameter name="cv">
            <typename name="curve"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
    schema_name + '.CONIC',
    schema_name + '.LINE',
    schema_name + '.POLYLINE'] * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    -- check in case curve_replica is the type of the input curve

    IF schema_name + '.CURVE_REPLICA' IN TYPEOF (cv) THEN
      RETURN (basis_curve_check(cv\curve_replica.parent_curve, schema_name));
    ELSE

      --check in case offset_curve_3d is the type of the input curve

      IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF (cv) THEN
        RETURN(basis_curve_check
        (cv\offset_curve_3d.basis_curve, schema_name));
      ELSE

          -- check in case pcurve is the type of the input curve

        IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN
          IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
            schema_name + '.CONIC',
            schema_name + '.LINE',
            schema_name + '.POLYLINE'] *
            TYPEOF (cv\pcurve.reference_to_curve\representation.items[1]))
            = 1 THEN
            RETURN (basis_surface_check (cv\pcurve.basis_surface,
            schema_name));
          ELSE
            IF schema_name + '.CURVE_REPLICA'
              IN TYPEOF
              (cv\pcurve.reference_to_curve\representation.items[1]) THEN
              RETURN ((basis_curve_check
              (cv\pcurve.reference_to_curve\representation.items[1],
              schema_name)) AND
              (basis_surface_check (cv\pcurve.basis_surface,
              schema_name)));
            END_IF;
          END_IF;
          ELSE

          --check in case surface_curve is the type of the input curve

          IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN
            IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
              schema_name + '.CONIC',
              schema_name + '.LINE',
              schema_name + '.POLYLINE'] *
              TYPEOF (cv\surface_curve.curve_3d)) = 1 THEN

              REPEAT i := 1 TO SIZEOF (cv\surface_curve.associated_geometry);


                -- do for one or two associated_geometrys:

                IF schema_name + '.SURFACE' IN
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                  IF NOT basis_surface_check
                    (cv\surface_curve.associated_geometry[i],
                    schema_name) THEN
                    RETURN(FALSE);
                  END_IF;
                ELSE
                  IF schema_name + '.PCURVE' IN
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                    IF NOT basis_curve_check
                      (cv\surface_curve.associated_geometry[i],
                      schema_name) THEN RETURN(FALSE);
                    END_IF;
                  END_IF;
                END_IF;
              END_REPEAT;
            ELSE
              IF schema_name + '.CURVE_REPLICA' IN TYPEOF
                (cv\surface_curve.curve_3d) THEN
                IF NOT (basis_curve_check
                  (cv\curve_replica.parent_curve, schema_name)) THEN
                  RETURN (FALSE);
                END_IF;
              ELSE
                IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF
                  (cv\surface_curve.curve_3d) THEN
                  IF NOT (basis_curve_check
                    (cv\offset_curve_3d.basis_curve, schema_name)) THEN
                    RETURN (FALSE);
                  END_IF;
                ELSE
                  REPEAT i := 1 TO SIZEOF
                  (cv\surface_curve.associated_geometry);

                    -- do for one or two associated_geometrys:

                    IF schema_name + '.SURFACE' IN
                      TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                      IF NOT basis_surface_check
                        (cv\surface_curve.associated_geometry[i],
                        schema_name) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF schema_name + '.PCURVE' IN
                        TYPEOF (cv\surface_curve.associated_geometry[i]) THEN

                        IF NOT basis_curve_check
                          (cv\surface_curve.associated_geometry[i],
                          schema_name) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="basis_surface_check">
         <parameter name="surf">
            <typename name="surface"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF([schema_name + '.B_SPLINE_SURFACE',
    schema_name + '.ELEMENTARY_SURFACE'] * TYPEOF(surf)) = 1 THEN
    RETURN(TRUE);
  ELSE
    IF schema_name + '.SWEPT_SURFACE' IN TYPEOF (surf) THEN
      RETURN (basis_curve_check
      (surf\swept_surface.swept_curve, schema_name));
    ELSE

      -- check in case offset_surface is the type of the input surface

      IF schema_name + '.OFFSET_SURFACE' IN TYPEOF (surf) THEN
        RETURN(basis_surface_check
        (surf\offset_surface.basis_surface, schema_name));
      ELSE

        -- check in case surface_replica is the type of the input surface

        IF schema_name + '.SURFACE REPLICA' IN TYPEOF(surf) THEN
          RETURN(basis_surface_check
          (surf\surface_replica.parent_surface, schema_name));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);</algorithm>
      </function>
      <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
  RETURN(choice1);
ELSE
  RETURN(choice2);
END_IF;</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
  u : LIST [2:2] OF direction;
END_LOCAL;
u[1] := NVL(normalise(ref_direction),direction([1,0]));
u[2] := orthogonal_complement(u[1]);
RETURN(u);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="3" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
  u : LIST [3:3] OF direction;
END_LOCAL;
u[3] := NVL(normalise(axis),direction([0,0,1]));
u[1] := first_proj_axis(u[3],ref_direction);
u[2] := normalise(cross_product(u[3],u[1])).orientation;
RETURN(u);</algorithm>
      </function>
      <function name="cc_design_date_time_correlation">
         <parameter name="e">
            <typename name="cc_design_date_and_time_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    dt_role : STRING;
  END_LOCAL;
    dt_role := e\date_and_time_assignment.role.name;
  CASE dt_role OF
    'creation_date'         : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'PRODUCT_DEFINITION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'request_date'         : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' +
                                'CONFIG_CONTROL_DESIGN.START_REQUEST'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'release_date'         : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE' +
                                'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start_date'          : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE' +
                                'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign_off_date'         : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract_date'         : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification_date'    : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification_date'   : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification_date' : IF SIZEOF (e.items) &lt;&gt;
                                SIZEOF (QUERY (x &lt;* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="cc_design_person_and_organization_correlation">
         <parameter name="e">
            <typename name="cc_design_person_and_organization_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    po_role : STRING;
  END_LOCAL;
    po_role := e\person_and_organization_assignment.role.name;
  CASE po_role OF
    'request_recipient'      : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_REQUEST'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
    'initiator'              : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_WORK',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
    'creator'                : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF (['CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN (FALSE);
                               END_IF;
    'part_supplier'          : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'design_supplier'        : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'design_owner'           : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.PRODUCT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'configuration_manager'  : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'CONFIGURATION_ITEM'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'contractor'             : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.CONTRACT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'classification_officer' : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'SECURITY_CLASSIFICATION'
                                 IN TYPEOF (x))) THEN
                                 RETURN(FALSE);
                               END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="conditional_reverse">
         <parameter name="p">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF p THEN
  RETURN(an_item);
ELSE
  RETURN(topology_reversed(an_item));
END_IF;</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
REPEAT k := 1 TO n_segments BY 1;
  IF ((NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve
      .segments[k].parent_curve))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve
      .segments[k].parent_curve)))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
      composite_curve.segments[k].parent_curve))) THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_surface_model">
         <parameter name="m">
            <typename name="shell_based_surface_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
  IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.
      sbsm_boundary[j]))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j])))
       THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_wireframe_model">
         <parameter name="m">
            <typename name="shell_based_wireframe_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
  IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.
      sbwm_boundary[j]))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j])))
       THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  k      : INTEGER;
  l      : INTEGER;
  sum    : INTEGER;
  result : BOOLEAN := TRUE;
END_LOCAL;
sum := knot_mult[1];
REPEAT i := 2 TO up_knots BY 1;
  sum := sum + knot_mult[i];
END_REPEAT;
IF (((degree &lt; 1) OR (up_knots &lt; 2)) OR (up_cp &lt; degree)) OR (sum &lt;&gt; (
    (degree + up_cp) + 2)) THEN
  result := FALSE;
  RETURN(result);
END_IF;
k := knot_mult[1];
IF (k &lt; 1) OR (k &gt; (degree + 1)) THEN
  result := FALSE;
  RETURN(result);
END_IF;
REPEAT i := 2 TO up_knots BY 1;
  IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i - 1]) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  k := knot_mult[i];
  IF (i &lt; up_knots) AND (k &gt; degree) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  IF (i = up_knots) AND (k &gt; (degree + 1)) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u BY 1;
  REPEAT j := 1 TO s.n_v BY 1;
    IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
        segments[i][j].parent_surface)) OR (
        'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s
        .segments[i][j].parent_surface))) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u - 1 BY 1;
  REPEAT j := 1 TO s.n_v BY 1;
    IF s.segments[i][j].u_transition = discontinuous THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u BY 1;
  REPEAT j := 1 TO s.n_v - 1 BY 1;
    IF s.segments[i][j].v_transition = discontinuous THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
  v2     : LIST [3:3] OF REAL;
  v1     : LIST [3:3] OF REAL;
  mag    : REAL;
  res    : direction;
  result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (arg1.dim = 2)) OR ((NOT EXISTS(arg2)) OR (
    arg2.dim = 2)) THEN
  RETURN(?);
ELSE
  BEGIN
    v1 := normalise(arg1).direction_ratios;
    v2 := normalise(arg2).direction_ratios;
    res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
    res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
    res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
    mag := 0;
    REPEAT i := 1 TO 3 BY 1;
      mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
    END_REPEAT;
    IF mag &gt; 0 THEN
      result.orientation := res;
      result.magnitude := SQRT(mag);
    ELSE
      result.orientation := arg1;
      result.magnitude := 0;
    END_IF;
    RETURN(result);
  END;
END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
  IF b.weights[i] &lt;= 0 THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);</algorithm>
      </function>
      <function name="derive_dimensional_exponents">
         <parameter name="x">
            <typename name="unit"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>LOCAL
  result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
            0);
END_LOCAL;
  result := x.dimensions;
RETURN(result);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
    x : SET OF representation;
    y : representation_context;
  END_LOCAL;

  -- Find the set of representation in which the item is used.

  x := using_representations(item);

  -- If there is such a representation, then determine the dimension_count
  -- of the associated geometric_representation_context - note that the
  -- RULE compatible_dimension ensures that the context_of_items is of type
  -- geometric_representation_context and has the same dimension_count for
  -- all values of x.

  IF SIZEOF(x) &gt; 0 THEN
    y := x[1].context_of_items;
    RETURN (y\geometric_representation_context.coordinate_space_dimension);
  END_IF;</algorithm>
      </function>
      <function name="dimensions_for_si_unit">
         <parameter name="n">
            <typename name="si_unit_name"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>CASE n OF
  metre           :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
  gram            :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
  second          :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
  ampere          :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
  kelvin          :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
  mole            :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
  candela         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
  radian          :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
  steradian       :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
  hertz           :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
  newton          :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
  pascal          :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
  joule           :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
  watt            :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
  coulomb         :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
  volt            :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
  farad           :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
  ohm             :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
  siemens         :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
  weber           :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
  tesla           :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
  henry           :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
  degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
  lumen           :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
  lux             :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
  becquerel       :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
  gray            :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
  sievert         :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
  END_CASE;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
  ndim   : INTEGER;
  scalar : REAL;
  vec1   : direction;
  vec2   : direction;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
  scalar := ?;
ELSE
  IF arg1.dim &lt;&gt; arg2.dim THEN
    scalar := ?;
  ELSE
    BEGIN
      vec1 := normalise(arg1);
      vec2 := normalise(arg2);
      ndim := arg1.dim;
      scalar := 0;
      REPEAT i := 1 TO ndim BY 1;
        scalar := scalar + (vec1.direction_ratios[i] * vec2.
            direction_ratios[i]);
      END_REPEAT;
    END;
  END_IF;
END_IF;
RETURN(scalar);</algorithm>
      </function>
      <function name="edge_reversed">
         <parameter name="an_edge">
            <typename name="edge"/>
         </parameter>
         <typename name="edge"/>
         <algorithm>LOCAL
  the_reverse : edge;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
  the_reverse := oriented_edge(an_edge\oriented_edge.edge_element,NOT
      an_edge\oriented_edge.orientation);
ELSE
  the_reverse := oriented_edge(an_edge,FALSE);
END_IF;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_bound_reversed">
         <parameter name="a_face_bound">
            <typename name="face_bound"/>
         </parameter>
         <typename name="face_bound"/>
         <algorithm>LOCAL
  the_reverse : face_bound;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
     THEN
  the_reverse := face_bound(a_face_bound\face_bound.bound,
                   (NOT (a_face_bound\face_bound.orientation)) ) ||
                   face_outer_bound ();
ELSE
  the_reverse := face_bound(a_face_bound.bound,NOT a_face_bound.
      orientation);
END_IF;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_reversed">
         <parameter name="a_face">
            <typename name="face"/>
         </parameter>
         <typename name="face"/>
         <algorithm>LOCAL
  the_reverse : face;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
  the_reverse := oriented_face(a_face\oriented_face.face_element,NOT
      a_face\oriented_face.orientation);
ELSE
  the_reverse := oriented_face(a_face,FALSE);
END_IF;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
  x_vec  : vector;
  v      : direction;
  z      : direction;
  x_axis : direction;
END_LOCAL;
IF ((NOT EXISTS(z_axis)) OR (NOT EXISTS(arg))) OR (arg.dim &lt;&gt; 3) THEN
  x_axis := ?;
ELSE
  z_axis := normalise(z_axis);
  IF NOT EXISTS(arg) THEN
    IF z_axis &lt;&gt; direction([1,0,0]) THEN
      v := direction([1,0,0]);
    ELSE
      v := direction([0,1,0]);
    END_IF;
  ELSE
    IF cross_product(arg,z).magnitude = 0 THEN
      RETURN(?);
    ELSE
      v := normalise(arg);
    END_IF;
  END_IF;
  x_vec := scalar_times_vector(dot_product(v,z),z_axis);
  x_axis := vector_difference(v,x_vec).orientation;
  x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);</algorithm>
      </function>
      <function name="gbsf_check_curve">
         <parameter name="cv">
            <typename name="curve"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (schema_name + '.CURVE' IN TYPEOF (cv)) THEN RETURN(TRUE);  
  END_IF;  
 
  -- let those types pass that do not have any further references  
  -- respectively rules to be applied  
 
  IF SIZEOF ([schema_name + '.CIRCLE', schema_name + '.ELLIPSE']  
    * TYPEOF(cv)) = 1 THEN RETURN(TRUE);  
  ELSE  
 
    -- the b_spline_curve shall not self intersect  
 
    IF (schema_name + '.B_SPLINE_CURVE' IN TYPEOF(cv))  
      THEN RETURN(NOT (cv\b_spline_curve.self_intersect)); 
    ELSE  
 
      -- if the curve is a composite_curve, all of its segments shall be valid

      IF schema_name + '.COMPOSITE_CURVE' IN TYPEOF(cv) THEN  
        RETURN (SIZEOF (QUERY (seg &lt;* cv\composite_curve.segments |
        NOT (gbsf_check_curve(seg.parent_curve, schema_name)))) = 0); 
      ELSE  
 
        -- the curve_replica references other curves that need to be checked  
        IF schema_name + '.CURVE_REPLICA' IN TYPEOF(cv) THEN  
          RETURN (gbsf_check_curve  
          (cv\curve_replica.parent_curve, schema_name)); 
        ELSE 
 
     -- offset_curve_3d references a curve and shall not self intersect

          IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF(cv) THEN  
            RETURN ((gbsf_check_curve
            (cv\offset_curve_3d.basis_curve, schema_name))  
            AND  
            (NOT cv\offset_curve_3d.self_intersect));  
          ELSE  
 
         -- pcurve references a curve - indirectly, and a basis_surface 
 
            IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN  
              RETURN
              ((gbsf_check_curve 
              (cv\pcurve.reference_to_curve\representation.items[1],  
              schema_name)) AND  
              (gbsf_check_surface 
              (cv\pcurve.basis_surface, schema_name)));  
            ELSE  
 
              -- polyline shall have at least 3 points and shall only  
              -- be used to represent an intersection_curve  
 
              IF schema_name + '.POLYLINE' IN TYPEOF(cv) THEN  
                IF (SIZEOF (cv\polyline.points) &gt;= 3)  AND 
                  (SIZEOF ((bag_to_set (USEDIN (cv,'')) - 
                  bag_to_set (USEDIN (cv,  
                  schema_name +  
                  '.INTERSECTION_CURVE.CURVE_3D')))) = 0) 
                  THEN RETURN (TRUE);  
                END_IF;  
              ELSE  
 
                -- surface_curve references a curve_3d and one or two  
                -- pcurves or one or two surface_curves or one of each  
 
                IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN  
 
                  -- if the curve reference is correct, check also the rest 

                  IF gbsf_check_curve  
                  (cv\surface_curve.curve_3d, schema_name) THEN  
                    REPEAT i := 1 TO SIZEOF 
                    (cv\surface_curve.associated_geometry);  
 
                    -- do for one or two associated_geometrys:  
 
                    IF schema_name + '.SURFACE' IN TYPEOF
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT gbsf_check_surface
                        (cv\surface_curve.associated_geometry[i],    
                        schema_name) THEN  
                        RETURN(FALSE);  
                      END_IF;  
                    ELSE 
                      IF schema_name + '.PCURVE' IN TYPEOF  
                        (cv\surface_curve.associated_geometry[i]) THEN  
                        IF NOT gbsf_check_curve 
                          (cv\surface_curve.associated_geometry[i],    
                          schema_name) THEN  
                          RETURN(FALSE);  
                        END_IF;  
                      END_IF;  
                    END_IF;  
                  END_REPEAT;  
                  RETURN(TRUE);  
                END_IF;  
              ELSE  
 
                -- if the curve is a trimmed_curve  
                                                         
                IF (schema_name + '.TRIMMED_CURVE') IN TYPEOF (cv) THEN  
   
                -- if a line, parabola or hyperbola is being trimmed,  
                -- then valid  
 
                  IF SIZEOF ([schema_name + '.LINE', 
                  schema_name + '.PARABOLA', 
                  schema_name + '.HYPERBOLA'] *
                  TYPEOF (cv\trimmed_curve.basis_curve)) = 1 
                  THEN RETURN (TRUE); 

                    -- otherwise, recursively check the basis curve  
   
                    ELSE RETURN (gbsf_check_curve 
                      (cv\trimmed_curve.basis_curve, schema_name));
                    END_IF; 
                  END_IF;  
                END_IF;  
              END_IF;  
            END_IF;  
          END_IF;   
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);</algorithm>
      </function>
      <function name="gbsf_check_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (schema_name + '.POINT' IN TYPEOF (pnt)) THEN RETURN(TRUE);
  END_IF;

  IF schema_name + '.CARTESIAN_POINT' IN TYPEOF (pnt) THEN
    RETURN(TRUE);
  ELSE

  -- a point_on_curve needs to be checked for the validity of its curve;
  -- further references down the tree are taken care of by the function
  -- gbsf_check_curve

    IF schema_name + '.POINT_ON_CURVE' IN TYPEOF (pnt) THEN
      RETURN (gbsf_check_curve
      (pnt\point_on_curve.basis_curve, schema_name));
    ELSE

    -- a point_on_surface needs to be checked for the validity of its 
    -- surface further references down the tree are taken care of by 
    -- the function gbsf_check_surface

      IF schema_name + '.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN
        RETURN(gbsf_check_surface
        (pnt\point_on_surface.basis_surface, schema_name));
      ELSE

      -- a degenerate_pcurve needs to be checked for the validity of its
      -- defining geometry further references down the tree are taken care
      -- of by the functions gbsf_check_curve and gbsf_check_surface;
      -- both shall return true to get a valid point

        IF schema_name + '.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN
          RETURN
          ((gbsf_check_curve
          (pnt\degenerate_pcurve.reference_to_curve\representation.items[1],
          schema_name))
          AND (gbsf_check_surface
          (pnt\degenerate_pcurve.basis_surface, schema_name)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);</algorithm>
      </function>
      <function name="gbsf_check_surface">
         <parameter name="sf">
            <typename name="surface"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT schema_name + '.SURFACE' IN TYPEOF (sf) THEN RETURN(TRUE);  
  END_IF;  
 
  -- b_spline_surface has a self_intersect attribute that shall be false  
 
  IF schema_name + '.B_SPLINE_SURFACE' IN TYPEOF(sf) THEN  
    RETURN(NOT (sf\b_spline_surface.self_intersect));
  ELSE  
 
    -- basis surface types return true 
 
    IF SIZEOF ([schema_name + '.SPHERICAL_SURFACE',  
      schema_name + '.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 3 THEN
      RETURN(TRUE);  
    ELSE  
  
      IF schema_name + '.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN  
 
      -- if there is a simple basis_surface, check the curves  
 
        IF SIZEOF ([schema_name + '.CONICAL_SURFACE',  
          schema_name + '.CYLINDRICAL_SURFACE',  
          schema_name + '.PLANE'] * TYPEOF
     (sf\curve_bounded_surface.basis_surface)) = 1 THEN   
          RETURN(SIZEOF (QUERY (bcurve &lt;*  
          sf\curve_bounded_surface.boundaries |
          NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);
        ELSE  
 
        -- recursively check the basis_surface and then the curves 
 
          IF gbsf_check_surface
          (sf\curve_bounded_surface.basis_surface, schema_name) THEN  
            RETURN(SIZEOF (QUERY (bcurve &lt;*
            sf\curve_bounded_surface.boundaries | 
            NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);
          END_IF;  
        END_IF;  
      ELSE  
 
        -- offset_surface references a surface and shall not self_intersect 
 
        IF schema_name + '.OFFSET_SURFACE' IN TYPEOF(sf) THEN              
          RETURN ((gbsf_check_surface 
          (sf\offset_surface.basis_surface, schema_name))
          AND  
          (NOT (sf\offset_surface.self_intersect)));  
        ELSE  
 
          -- rectangular_composite_surface references a matrix of surfaces  
 
       IF schema_name + '.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
            REPEAT i := 1 TO SIZEOF
              (sf\rectangular_composite_surface.segments);  
              REPEAT j := 1 TO SIZEOF
                (sf\rectangular_composite_surface.segments[i]);  
                IF NOT (gbsf_check_surface
                  (sf\rectangular_composite_surface.segments[i][j].
                  parent_surface, schema_name))
                  THEN RETURN (FALSE);  
                END_IF;  
              END_REPEAT;  
            END_REPEAT;  
            RETURN(TRUE);  
          ELSE  
 
            -- rectangular_trimmed_surface has a basis_surface  
 
         IF schema_name + '.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) THEN

              IF  SIZEOF ([schema_name + '.CONICAL_SURFACE',  
                schema_name + '.CYLINDRICAL_SURFACE',  
                schema_name + '.PLANE'] * TYPEOF
                (sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN 
                RETURN (TRUE); 
              ELSE 
                RETURN(gbsf_check_surface
                (sf\rectangular_trimmed_surface.basis_surface,                 
 schema_name)); 
              END_IF;  
            ELSE  
 
              -- parent_surfaces need to be checked for their validity 
  
              IF schema_name + '.SURFACE_REPLICA' IN TYPEOF (sf) THEN 
                RETURN (gbsf_check_surface 
                (sf\surface_replica.parent_surface, schema_name)); 
              ELSE  
 
                -- and the swept_surface must have a valid swept_curve  

                IF schema_name + '.SWEPT_SURFACE' IN TYPEOF(sf) THEN  
                  RETURN(gbsf_check_curve 
                  (sf\swept_surface.swept_curve, schema_name)); 
                END_IF;    
              END_IF;    
            END_IF;     
          END_IF;  
        END_IF;  
      END_IF;  
    END_IF;  
  END_IF;  
  RETURN(FALSE);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
  surfs : SET [0:2] OF surface;
  n     : INTEGER;
END_LOCAL;
surfs := [];
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
  surfs := [c\pcurve.basis_surface];
ELSE
  IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
    n := SIZEOF(c\surface_curve.associated_geometry);
    REPEAT i := 1 TO n BY 1;
      surfs := surfs + associated_surface(c\surface_curve.
          associated_geometry[i]);
    END_REPEAT;
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
     THEN
  n := SIZEOF(c\composite_curve_on_surface.segments);
  surfs := get_basis_surface(c\composite_curve_on_surface.
           segments[1].parent_curve);
  IF n &gt; 1 THEN
    REPEAT i := 2 TO n BY 1;
      surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
               segments[i].parent_curve);
    END_REPEAT;
  END_IF;
END_IF;
RETURN(surfs);</algorithm>
      </function>
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  i : INTEGER;
  y : BAG OF representation_item;
END_LOCAL;
IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') *
    cntxt.representations_in_context) &gt; 0 THEN
  RETURN(TRUE);
ELSE
  y := QUERY ( z &lt;* USEDIN(item,'') | (
      'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
  IF SIZEOF(y) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(y) BY 1;
      IF item_in_context(y[i],cntxt) THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
  END_IF;
END_IF;
RETURN(FALSE);</algorithm>
      </function>
      <function name="leap_year">
         <parameter name="year">
            <typename name="year_number"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) =
     0) THEN
  RETURN(TRUE);
ELSE
  RETURN(FALSE);
END_IF;</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
  loops : LIST [0:?] OF loop := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
  loops := loops + f.bounds[i].bound;
END_REPEAT;
RETURN(loops);</algorithm>
      </function>
      <function name="list_of_topology_reversed">
         <parameter name="a_list">
            <typename name="list_of_reversible_topology_item"/>
         </parameter>
         <typename name="list_of_reversible_topology_item"/>
         <algorithm>LOCAL
  the_reverse : list_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_list) BY 1;
  the_reverse := topology_reversed(a_list[i]) + the_reverse;
END_REPEAT;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
  n   : INTEGER;
  res : ARRAY [low:u] OF GENERIC:t;
END_LOCAL;
n := SIZEOF(lis);
IF n &lt;&gt; ((u - low) + 1) THEN
  RETURN(?);
ELSE
  REPEAT i := 1 TO n BY 1;
    res[(low + i) - 1] := lis[i];
  END_REPEAT;
  RETURN(res);
END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
  s : SET OF GENERIC:t := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(l) BY 1;
  s := s + l[i];
END_REPEAT;
RETURN(s);</algorithm>
      </function>
      <function name="local_relatives_of_product_definitions">
         <parameter name="definition_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="total_definitions">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="relation_subtype">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>LOCAL
  i           : INTEGER;
  local_def   : SET OF product_definition := [];
  local_pdr   : SET OF product_definition_relationship := [];
  local_total : SET OF product_definition := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
  local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
      relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
  local_def := local_def + local_pdr[i].related_product_definition;
END_REPEAT;
IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
  RETURN(local_def);
ELSE
  local_total := total_definitions + local_def;
  RETURN(local_def + local_relatives_of_product_definitions(local_def
      - total_definitions,local_total,relation_subtype));
END_IF;</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
  n2   : INTEGER;
  n1   : INTEGER;
  res  : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
  resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
END_LOCAL;
n1 := SIZEOF(lis);
n2 := SIZEOF(lis[1]);
IF (n1 &lt;&gt; ((u1 - low1) + 1)) AND (n2 &lt;&gt; ((u2 - low2) + 1)) THEN
  RETURN(?);
END_IF;
REPEAT i := 1 TO n1 BY 1;
  IF SIZEOF(lis[i]) &lt;&gt; n2 THEN
    RETURN(?);
  END_IF;
END_REPEAT;
REPEAT i := 1 TO n1 BY 1;
  resl[i] := list_to_array(lis[i],low2,u2);
END_REPEAT;
res := list_to_array(resl,low1,u1);
RETURN(res);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
  i              : INTEGER;
  poly_loop_type : LOGICAL;
END_LOCAL;
IF SIZEOF(l) &lt;= 1 THEN
  RETURN(FALSE);
END_IF;
poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
REPEAT i := 2 TO SIZEOF(l) BY 1;
  IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt;
      poly_loop_type THEN
    RETURN(TRUE);
  END_IF;
END_REPEAT;
RETURN(FALSE);</algorithm>
      </function>
      <function name="msb_shells">
         <parameter name="brep">
            <typename name="manifold_solid_brep"/>
         </parameter>
         <parameter name="schema_name">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="1" upper="?"/>
         <typename name="closed_shell"/>
         <algorithm>IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
  RETURN(brep\brep_with_voids.voids + brep.outer);
ELSE
  RETURN([brep.outer]);
END_IF;</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
  ndim   : INTEGER;
  v      : direction;
  vec    : vector;
  mag    : REAL;
  result : vector_or_direction;
END_LOCAL;
IF NOT EXISTS(arg) THEN
  result := ?;
ELSE
  ndim := arg.dim;
  IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
    BEGIN
      vec := arg;
      v := arg.orientation;
      IF arg.magnitude = 0 THEN
        RETURN(?);
      ELSE
        vec.magnitude := 1;
      END_IF;
    END;
  ELSE
    v := arg;
  END_IF;
  mag := 0;
  REPEAT i := 1 TO ndim BY 1;
    mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
  END_REPEAT;
  IF mag &gt; 0 THEN
    mag := SQRT(mag);
    REPEAT i := 1 TO ndim BY 1;
      v.direction_ratios[i] := v.direction_ratios[i] / mag;
    END_REPEAT;
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
      vec.orientation := v;
      result := vec;
    ELSE
      result := v;
    END_IF;
  ELSE
    RETURN(?);
  END_IF;
END_IF;
RETURN(result);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
  result : direction;
END_LOCAL;
IF (vec.dim &lt;&gt; 2) OR (NOT EXISTS(vec)) THEN
  RETURN(?);
ELSE
  result.direction_ratios[1] := -vec.direction_ratios[2];
  result.direction_ratios[2] := vec.direction_ratios[1];
  RETURN(result);
END_IF;</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
  n : INTEGER;
  p : LOGICAL := TRUE;
END_LOCAL;
n := SIZEOF(a_path.edge_list);
REPEAT i := 2 TO n BY 1;
  p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
      .edge_start);
END_REPEAT;
RETURN(p);</algorithm>
      </function>
      <function name="path_reversed">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <typename name="path"/>
         <algorithm>LOCAL
  the_reverse : path;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
  the_reverse := oriented_path(a_path\oriented_path.path_element,NOT
      a_path\oriented_path.orientation);
ELSE
  the_reverse := oriented_path(a_path,FALSE);
END_IF;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="relatives_of_product_definitions">
         <parameter name="definition_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="relation_subtype">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>RETURN(local_relatives_of_product_definitions(definition_set,
    definition_set,relation_subtype));</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
  v      : direction;
  mag    : REAL;
  result : vector;
END_LOCAL;
IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
  result := ?;
ELSE
  IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
    v := vec.orientation;
    mag := scalar * vec.magnitude;
  ELSE
    v := vec;
    mag := scalar;
  END_IF;
  IF mag &lt; 0 THEN
    REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
      v.direction_ratios[i] := -v.direction_ratios[i];
    END_REPEAT;
    mag := -mag;
  END_IF;
  result.orientation := normalise(v);
  result.magnitude := mag;
END_IF;
RETURN(result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
  temp   : vector;
  v      : direction;
  y_axis : vector;
END_LOCAL;
IF NOT EXISTS(arg) THEN
  v := direction([0,1,0]);
ELSE
  v := arg;
END_IF;
temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
y_axis := vector_difference(v,temp);
temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
y_axis := vector_difference(y_axis,temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="set_of_topology_reversed">
         <parameter name="a_set">
            <typename name="set_of_reversible_topology_item"/>
         </parameter>
         <typename name="set_of_reversible_topology_item"/>
         <algorithm>LOCAL
  the_reverse : set_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_set) BY 1;
  the_reverse := the_reverse + topology_reversed(a_set[i]);
END_REPEAT;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="shell_reversed">
         <parameter name="a_shell">
            <typename name="shell"/>
         </parameter>
         <typename name="shell"/>
         <algorithm>LOCAL
  the_reverse : shell;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
     THEN
  the_reverse := oriented_open_shell(a_shell\oriented_open_shell.
      open_shell_element,NOT a_shell\oriented_open_shell.orientation);
ELSE
  IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
    the_reverse := oriented_open_shell(a_shell,FALSE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := oriented_closed_shell(a_shell\
          oriented_closed_shell.closed_shell_element,NOT a_shell\
          oriented_closed_shell.orientation);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        the_reverse := oriented_closed_shell(a_shell,FALSE);
      ELSE
        the_reverse := ?;
      END_IF;
    END_IF;
  END_IF;
END_IF;
RETURN(the_reverse);</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper BY 1;
  REPEAT j := 0 TO b.v_upper BY 1;
    IF b.weights[i][j] &lt;= 0 THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
END_REPEAT;
RETURN(result);</algorithm>
      </function>
      <function name="topology_reversed">
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
  RETURN(edge_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
  RETURN(path_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
  RETURN(face_bound_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
  RETURN(face_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
  RETURN(shell_reversed(an_item));
END_IF;
IF 'SET' IN TYPEOF(an_item) THEN
  RETURN(set_of_topology_reversed(an_item));
END_IF;
IF 'LIST' IN TYPEOF(an_item) THEN
  RETURN(list_of_topology_reversed(an_item));
END_IF;
RETURN(?);</algorithm>
      </function>
      <function name="unique_version_change_order">
         <parameter name="c">
            <typename name="action"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    ords       : action_directive := c\directed_action.directive;
    assign     : SET OF change_request := [];
    versions   : SET OF product_definition_formation := [];
  END_LOCAL;

  -- build the set of change_requests that are the assigned
  -- versioned_action_requests incorporated by the action_directive
  REPEAT i := 1 TO SIZEOF(ords.requests);
  assign := assign + QUERY (ara &lt;* bag_to_set (USEDIN (ords.requests[i],
            'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' +
            'ASSIGNED_ACTION_REQUEST')) |
            'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF (ara));
  END_REPEAT;

  -- gather the product_definition_formations that are referenced by the
  -- change_requests

  REPEAT k := 1 TO SIZEOF(assign);
    versions := versions + assign[k].items;
  END_REPEAT;

  -- check that no product_definition_formation reference the same
  -- instance of product

  RETURN (SIZEOF (QUERY (vers &lt;* versions |
          NOT (SIZEOF (QUERY (other_vers &lt;* versions - vers |
          vers.of_product :=: other_vers.of_product)) = 0))) = 0);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF representation_item;
    i                  : INTEGER;
  END_LOCAL;

  -- Find the representations in which the item is used and add to the
  -- results set.

  result_bag := USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');

  IF SIZEOF(result_bag) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;

  -- Find the set of representation_items in which item is used.

  intermediate_items := QUERY(z &lt;* bag_to_set( USEDIN(item , '')) |
    'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));

  -- If the set of intermediate items is not empty;

  IF SIZEOF(intermediate_items) &gt; 0 THEN

    -- For each element in the set, recursively add the
    -- using_representations of that element.

    REPEAT i := 1 TO HIINDEX(intermediate_items);
      results := results + using_representations(intermediate_items[i]);
    END_REPEAT;
  END_IF;

  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening 
  -- representation_items).

  RETURN (results);</algorithm>
      </function>
      <function name="valid_calendar_date">
         <parameter name="date">
            <typename name="calendar_date"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF NOT ((1 &lt;= date.day_component) AND (date.day_component &lt;= 31))
  THEN
    RETURN(FALSE);
  END_IF;
  CASE date.month_component OF
    4 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
    6 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
    9 : RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
    11: RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 30));
    2 :      
    BEGIN
      IF leap_year(date.year_component) THEN
        RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 29));
      ELSE
        RETURN((1 &lt;= date.day_component) AND (date.day_component &lt;= 28));
      END_IF;
    END;
    OTHERWISE : RETURN(TRUE);
  END_CASE;</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <parameter name="schma">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF ([schma + '.POLYLINE',
    schma + '.B_SPLINE_CURVE',
    schma + '.ELLIPSE',
    schma + '.CIRCLE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE

    -- if the curve is a trimmed_curve

    IF (schma + '.TRIMMED_CURVE') IN TYPEOF (crv) THEN

      -- if a line, parabola or hyperbola is being trimmed, then valid

      IF SIZEOF ([schma + '.LINE',
        schma + '.PARABOLA',
        schma + '.HYPERBOLA'] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);

        -- otherwise, recursively check the basis_curve

        ELSE RETURN (valid_geometrically_bounded_wf_curve
        (crv\trimmed_curve.basis_curve, schma));
      END_IF;
    ELSE

      -- recursively check the offset_curves basis curve

      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN (valid_geometrically_bounded_wf_curve
        (crv\offset_curve_3d.basis_curve, schma));
      ELSE

        -- recursively check the curve_replicas parent curve

        IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv) THEN
          RETURN (valid_geometrically_bounded_wf_curve
          (crv\curve_replica.parent_curve, schma));
        ELSE

          -- recursively check the composite_curves segments

          IF (schma + '.COMPOSITE_CURVE') IN TYPEOF (crv) THEN
            RETURN (SIZEOF (QUERY (ccs &lt;* crv\composite_curve.segments |
            NOT (valid_geometrically_bounded_wf_curve
            (ccs.parent_curve, schma))))
            = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <parameter name="schma">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (schma + '.CARTESIAN_POINT') IN TYPEOF (pnt)
    THEN RETURN (TRUE);
  ELSE

    -- if the input type is a point_on_curve then check for a valid
    -- geometrically bounded curve type as the basis

    IF (schma + '.POINT_ON_CURVE') IN TYPEOF (pnt)
      THEN RETURN (valid_geometrically_bounded_wf_curve
      (pnt\point_on_curve.basis_curve, schma));
    ELSE

      -- if the input type is a point_replica check for a valid parent point

      IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
        THEN RETURN (valid_geometrically_bounded_wf_point
        (pnt\point_replica.parent_pt, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_time">
         <parameter name="time">
            <typename name="local_time"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(time.second_component) THEN
  RETURN(EXISTS(time.minute_component));
ELSE
  RETURN(TRUE);
END_IF;</algorithm>
      </function>
      <function name="valid_units">
         <parameter name="m">
            <typename name="measure_with_unit"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(1,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,1,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,1,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,1,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN
    TYPEOF(m.value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,1,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,1,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,0,1) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(2,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(3,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(1,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) &lt;&gt;
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
RETURN(TRUE);</algorithm>
      </function>
      <function name="valid_wireframe_edge_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <parameter name="schma">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF ([schma + '.LINE',
    schma + '.CIRCLE',
    schma + '.ELLIPSE',
    schma + '.PARABOLA',
    schma + '.HYPERBOLA',
    schma + '.B_SPLINE_CURVE',
    schma + '.POLYLINE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE

   -- recursively check for valid parent curves for curve_replica

    IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv)
      THEN RETURN
      (valid_wireframe_edge_curve (crv\curve_replica.parent_curve, schma));
    ELSE

      -- recursively check for valid basis curves for offset_curve

      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN
        (valid_wireframe_edge_curve (crv\offset_curve_3d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_wireframe_vertex_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <parameter name="schma">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (schma + '.CARTESIAN_POINT' IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE

    -- recursively check for valid basic point type as parents for a
    -- point_replica

    IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
      THEN RETURN (valid_wireframe_vertex_point
      (pnt\point_replica.parent_pt, schma));
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
  ndim   : INTEGER;
  mag2   : REAL;
  mag1   : REAL;
  mag    : REAL;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
     THEN
  result := ?;
ELSE
  BEGIN
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
      mag1 := arg1.magnitude;
      vec1 := arg1.orientation;
    ELSE
      mag1 := 1;
      vec1 := arg1;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
      mag2 := arg2.magnitude;
      vec2 := arg2.orientation;
    ELSE
      mag2 := 1;
      vec2 := arg2;
    END_IF;
    vec1 := normalise(vec1);
    vec2 := normalise(vec2);
    ndim := SIZEOF(vec1.direction_ratios);
    mag := 0;
    REPEAT i := 1 TO ndim BY 1;
      res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
          mag2 * vec2.direction_ratios[i]);
      mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
    END_REPEAT;
    IF mag &gt; 0 THEN
      result.magnitude := SQRT(mag);
      result.orientation := res;
    ELSE
      result.magnitude := 0;
      result.orientation := vec1;
    END_IF;
  END;
END_IF;
RETURN(result);</algorithm>
      </function>
   </schema>
</express>
