<?xml version="1.0"?>
<!-- $Id: express2xml.js,v 1.9 2002/02/25 12:10:19 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.9"
    source="aic_geometrically_bounded_surface.exp"/>

  <schema name="aic_geometrically_bounded_surface">
    <interface
      kind="reference"
      schema="support_resource_schema">
      <interfaced.item
        name="bag_to_set"/>
    </interface>

    <interface
      kind="use"
      schema="geometric_model_schema">
      <interfaced.item
        name="geometric_set"/>
    </interface>

    <interface
      kind="use"
      schema="geometry_schema">
      <interfaced.item
        name="axis1_placement"/>
      <interfaced.item
        name="axis2_placement_2d"/>
      <interfaced.item
        name="axis2_placement_3d"/>
      <interfaced.item
        name="b_spline_curve"/>
      <interfaced.item
        name="b_spline_curve_with_knots"/>
      <interfaced.item
        name="b_spline_surface"/>
      <interfaced.item
        name="b_spline_surface_with_knots"/>
      <interfaced.item
        name="bezier_curve"/>
      <interfaced.item
        name="bezier_surface"/>
      <interfaced.item
        name="boundary_curve"/>
      <interfaced.item
        name="bounded_pcurve"/>
      <interfaced.item
        name="bounded_surface_curve"/>
      <interfaced.item
        name="cartesian_point"/>
      <interfaced.item
        name="cartesian_transformation_operator_3d"/>
      <interfaced.item
        name="circle"/>
      <interfaced.item
        name="composite_curve"/>
      <interfaced.item
        name="composite_curve_on_surface"/>
      <interfaced.item
        name="composite_curve_segment"/>
      <interfaced.item
        name="conical_surface"/>
      <interfaced.item
        name="curve"/>
      <interfaced.item
        name="curve_bounded_surface"/>
      <interfaced.item
        name="curve_replica"/>
      <interfaced.item
        name="cylindrical_surface"/>
      <interfaced.item
        name="degenerate_pcurve"/>
      <interfaced.item
        name="degenerate_toroidal_surface"/>
      <interfaced.item
        name="direction"/>
      <interfaced.item
        name="ellipse"/>
      <interfaced.item
        name="evaluated_degenerate_pcurve"/>
      <interfaced.item
        name="geometric_representation_context"/>
      <interfaced.item
        name="hyperbola"/>
      <interfaced.item
        name="intersection_curve"/>
      <interfaced.item
        name="line"/>
      <interfaced.item
        name="offset_curve_3d"/>
      <interfaced.item
        name="offset_surface"/>
      <interfaced.item
        name="outer_boundary_curve"/>
      <interfaced.item
        name="parabola"/>
      <interfaced.item
        name="pcurve"/>
      <interfaced.item
        name="plane"/>
      <interfaced.item
        name="point"/>
      <interfaced.item
        name="point_on_curve"/>
      <interfaced.item
        name="point_on_surface"/>
      <interfaced.item
        name="polyline"/>
      <interfaced.item
        name="quasi_uniform_curve"/>
      <interfaced.item
        name="quasi_uniform_surface"/>
      <interfaced.item
        name="rational_b_spline_curve"/>
      <interfaced.item
        name="rational_b_spline_surface"/>
      <interfaced.item
        name="rectangular_composite_surface"/>
      <interfaced.item
        name="rectangular_trimmed_surface"/>
      <interfaced.item
        name="reparametrised_composite_curve_segment"/>
      <interfaced.item
        name="seam_curve"/>
      <interfaced.item
        name="spherical_surface"/>
      <interfaced.item
        name="surface"/>
      <interfaced.item
        name="surface_curve"/>
      <interfaced.item
        name="surface_of_linear_extrusion"/>
      <interfaced.item
        name="surface_of_revolution"/>
      <interfaced.item
        name="surface_patch"/>
      <interfaced.item
        name="surface_replica"/>
      <interfaced.item
        name="swept_surface"/>
      <interfaced.item
        name="toroidal_surface"/>
      <interfaced.item
        name="trimmed_curve"/>
      <interfaced.item
        name="uniform_curve"/>
      <interfaced.item
        name="uniform_surface"/>
      <interfaced.item
        name="vector"/>
    </interface>

    <interface
      kind="use"
      schema="product_property_representation_schema">
      <interfaced.item
        name="shape_representation"/>
    </interface>

    <interface
      kind="use"
      schema="representation_schema">
      <interfaced.item
        name="definitional_representation"/>
      <interfaced.item
        name="mapped_item"/>
      <interfaced.item
        name="parametric_representation_context"/>
      <interfaced.item
        name="representation"/>
      <interfaced.item
        name="representation_map"/>
    </interface>

    <entity
      name="geometrically_bounded_surface_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="SIZEOF (  QUERY ( it &lt;* SELF.items| NOT ( SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (  QUERY ( it &lt;* SELF.items| ( SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (  QUERY ( mi &lt;*  QUERY ( it &lt;* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) )| NOT (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) AND ( SIZEOF (  QUERY ( mr_it &lt;* mi\mapped_item.mapping_source.mapped_representation.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (mr_it)) )) &gt; 0)) )) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF (  QUERY ( gs &lt;*  QUERY ( it &lt;* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) )| NOT ( SIZEOF (  QUERY ( pnt &lt;*  QUERY ( gsel &lt;* gs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT' IN TYPEOF (gsel)) )| NOT gbsf_check_point(pnt) )) = 0) )) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF (  QUERY ( gs &lt;*  QUERY ( it &lt;* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) )| NOT ( SIZEOF (  QUERY ( cv &lt;*  QUERY ( gsel &lt;* gs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE' IN TYPEOF (gsel)) )| NOT gbsf_check_curve(cv) )) = 0) )) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF (  QUERY ( gs &lt;*  QUERY ( it &lt;* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) )| NOT ( SIZEOF (  QUERY ( sf &lt;*  QUERY ( gsel &lt;* gs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF (gsel)) )| NOT gbsf_check_surface(sf) )) = 0) )) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF (  QUERY ( gs &lt;*  QUERY ( it &lt;* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF (it)) )| ( SIZEOF (  QUERY ( gsel &lt;* gs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF (gsel)) )) &gt; 0) )) &gt; 0">
      </where>
    </entity>

    <function
      name="gbsf_check_point">
      <parameter
        name="pnt">
        <typename
          name="point"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN 
 RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN 
 RETURN (gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1]) AND gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="gbsf_check_curve">
      <parameter
        name="cv">
        <typename
          name="curve"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.BOUNDED_CURVE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONIC', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.LINE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D' ] * TYPEOF (cv)) &gt; 1 THEN 
 RETURN (FALSE);
 ELSE 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CIRCLE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.ELLIPSE' ] * TYPEOF (cv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' IN TYPEOF (cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN) THEN 
 RETURN (TRUE);
 ELSE 
 IF ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.COMPOSITE_CURVE' IN TYPEOF (cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN) THEN 
 RETURN ( SIZEOF ( 
QUERY ( seg &lt;* cv\composite_curve.segments| NOT gbsf_check_curve(seg.parent_curve) )) = 0);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA' IN TYPEOF (cv) THEN 
 RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
 ELSE 
 IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D' IN TYPEOF (cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN))) AND NOT ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (cv.basis_curve)) THEN 
 RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (cv) THEN 
 RETURN (gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1]) AND gbsf_check_surface(cv\pcurve.basis_surface));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (cv) THEN 
 IF SIZEOF (cv\polyline.points) &gt;= 3 THEN 
 RETURN (TRUE);
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (cv) THEN 
 IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN 
 REPEAT i := 1 TO SIZEOF (cv\surface_curve.associated_geometry);
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF (cv\surface_curve.associated_geometry[i]) THEN 
 IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN 
 RETURN (FALSE);
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (cv\surface_curve.associated_geometry[i]) THEN 
 IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN 
 RETURN (FALSE);
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 RETURN (TRUE);
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TRIMMED_CURVE' IN TYPEOF (cv) THEN 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.LINE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PARABOLA', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.HYPERBOLA' ] * TYPEOF (cv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (gbsf_check_curve(cv\trimmed_curve.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="gbsf_check_surface">
      <parameter
        name="sf">
        <typename
          name="surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
 IF ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE' IN TYPEOF (sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN) THEN 
 RETURN (TRUE);
 ELSE 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SPHERICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TOROIDAL_SURFACE' ] * TYPEOF (sf)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_BOUNDED_SURFACE' IN TYPEOF (sf) THEN 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CYLINDRICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PLANE' ] * TYPEOF (sf\curve_bounded_surface.basis_surface)) = 1 THEN 
 RETURN ( SIZEOF ( 
QUERY ( bcurve &lt;* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve) )) = 0);
 ELSE 
 IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface) THEN 
 RETURN ( SIZEOF ( 
QUERY ( bcurve &lt;* sf\curve_bounded_surface.boundaries| NOT gbsf_check_curve(bcurve) )) = 0);
 END_IF ;
 END_IF ;
 ELSE 
 IF ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_SURFACE' IN TYPEOF (sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN) THEN 
 RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF (sf) THEN 
 REPEAT i := 1 TO SIZEOF (sf\rectangular_composite_surface.segments);
 REPEAT j := 1 TO SIZEOF (sf\rectangular_composite_surface.segments[i]);
 IF NOT gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface) THEN 
 RETURN (FALSE);
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF (sf) THEN 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CYLINDRICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PLANE' ] * TYPEOF (sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (gbsf_check_surface(sf\rectangular_trimmed_surface.basis_surface));
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_REPLICA' IN TYPEOF (sf) THEN 
 RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (sf) THEN 
 RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
      </algorithm>

    </function>

  </schema>

</express>
