<!-- $Id: aic_geometrically_bounded_surface.xml,v 1.4 2002/07/14 16:43:43 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>

<express
  language_version="2"
  rcs.date="$Date: 2003/04/23 23:45:07 $"
  rcs.revision="$Revision: 1.8 $"
  description.file="mim_descriptions.xml">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.9"
    source="../data/modules/date_time/mim.exp"/>


<schema name="aic_geometrically_bounded_surface">
    <interface
      kind="reference"
      schema="support_resource_schema">
      <interfaced.item
        name="bag_to_set"/>
    </interface>
    <interface
      kind="use"
      schema="geometric_model_schema">
      <interfaced.item
        name="geometric_set"/>
    </interface>
    <interface
      kind="use"
      schema="geometry_schema">
      <interfaced.item
        name="axis1_placement"/>
      <interfaced.item
        name="axis2_placement_2d"/>
      <interfaced.item
        name="axis2_placement_3d"/>
      <interfaced.item
        name="b_spline_curve"/>
      <interfaced.item
        name="b_spline_curve_with_knots"/>
      <interfaced.item
        name="b_spline_surface"/>
      <interfaced.item
        name="b_spline_surface_with_knots"/>
      <interfaced.item
        name="bezier_curve"/>
      <interfaced.item
        name="bezier_surface"/>
      <interfaced.item
        name="boundary_curve"/>
      <interfaced.item
        name="bounded_pcurve"/>
      <interfaced.item
        name="bounded_surface_curve"/>
      <interfaced.item
        name="cartesian_point"/>
      <interfaced.item
        name="cartesian_transformation_operator_3d"/>
      <interfaced.item
        name="circle"/>
      <interfaced.item
        name="composite_curve"/>
      <interfaced.item
        name="composite_curve_on_surface"/>
      <interfaced.item
        name="composite_curve_segment"/>
      <interfaced.item
        name="conical_surface"/>
      <interfaced.item
        name="curve"/>
      <interfaced.item
        name="curve_bounded_surface"/>
      <interfaced.item
        name="curve_replica"/>
      <interfaced.item
        name="cylindrical_surface"/>
      <interfaced.item
        name="degenerate_pcurve"/>
      <interfaced.item
        name="degenerate_toroidal_surface"/>
      <interfaced.item
        name="direction"/>
      <interfaced.item
        name="ellipse"/>
      <interfaced.item
        name="evaluated_degenerate_pcurve"/>
      <interfaced.item
        name="geometric_representation_context"/>
      <interfaced.item
        name="hyperbola"/>
      <interfaced.item
        name="intersection_curve"/>
      <interfaced.item
        name="line"/>
      <interfaced.item
        name="offset_curve_3d"/>
      <interfaced.item
        name="offset_surface"/>
      <interfaced.item
        name="outer_boundary_curve"/>
      <interfaced.item
        name="parabola"/>
      <interfaced.item
        name="pcurve"/>
      <interfaced.item
        name="plane"/>
      <interfaced.item
        name="point"/>
      <interfaced.item
        name="point_on_curve"/>
      <interfaced.item
        name="point_on_surface"/>
      <interfaced.item
        name="polyline"/>
      <interfaced.item
        name="quasi_uniform_curve"/>
      <interfaced.item
        name="quasi_uniform_surface"/>
      <interfaced.item
        name="rational_b_spline_curve"/>
      <interfaced.item
        name="rational_b_spline_surface"/>
      <interfaced.item
        name="rectangular_composite_surface"/>
      <interfaced.item
        name="rectangular_trimmed_surface"/>
      <interfaced.item
        name="reparametrised_composite_curve_segment"/>
      <interfaced.item
        name="seam_curve"/>
      <interfaced.item
        name="spherical_surface"/>
      <interfaced.item
        name="surface"/>
      <interfaced.item
        name="surface_curve"/>
      <interfaced.item
        name="surface_of_linear_extrusion"/>
      <interfaced.item
        name="surface_of_revolution"/>
      <interfaced.item
        name="surface_patch"/>
      <interfaced.item
        name="surface_replica"/>
      <interfaced.item
        name="swept_surface"/>
      <interfaced.item
        name="toroidal_surface"/>
      <interfaced.item
        name="trimmed_curve"/>
      <interfaced.item
        name="uniform_curve"/>
      <interfaced.item
        name="uniform_surface"/>
      <interfaced.item
        name="vector"/>
    </interface>
    <interface
      kind="use"
      schema="product_property_representation_schema">
      <interfaced.item
        name="shape_representation"/>
    </interface>
    <interface
      kind="use"
      schema="representation_schema">
      <interfaced.item
        name="definitional_representation"/>
      <interfaced.item
        name="mapped_item"/>
      <interfaced.item
        name="parametric_representation_context"/>
      <interfaced.item
        name="representation"/>
      <interfaced.item
        name="representation_item"/>
      <interfaced.item
        name="representation_map"/>
    </interface>
    <entity name="geometrically_bounded_surface_shape_representation"
      supertypes="shape_representation"
    >
      <where
        label="WR1"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | NOT (SIZEOF([&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D&apos;] * TYPEOF(it)) = 1))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(QUERY(it &lt;* SELF.items | SIZEOF([&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM&apos;] * TYPEOF(it)) = 1)) &gt; 0">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(QUERY(mi &lt;* QUERY(it &lt;* SELF.items | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM&apos; IN TYPEOF(it)) | NOT ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.&apos; + &apos;GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION&apos; IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it &lt;* mi\mapped_item.mapping_source.mapped_representation.items | (&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos; IN TYPEOF(mr_it)))) &gt; 0)))) = 0">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos; IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT&apos; IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0">
      </where>
      <where
        label="WR5"
        expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos; IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE&apos; IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0">
      </where>
      <where
        label="WR6"
        expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos; IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE&apos; IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0">
      </where>
      <where
        label="WR7"
        expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET&apos; IN TYPEOF(it)) | SIZEOF(QUERY(gsel &lt;* gs\geometric_set.elements | &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE&apos; IN TYPEOF(gsel))) &gt; 0)) &gt; 0">
      </where>
    </entity>

	<function name="gbsf_check_point">
      <parameter name="pnt">
        <typename name="point"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CARTESIAN_POINT&apos; IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_CURVE&apos; IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_SURFACE&apos; IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.DEGENERATE_PCURVE&apos; IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="gbsf_check_curve">
      <parameter name="cv">
        <typename name="representation_item"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF SIZEOF([&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.BOUNDED_CURVE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONIC&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.LINE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D&apos;] * TYPEOF(cv)) &gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF([&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CIRCLE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.ELLIPSE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.TRIMMED_CURVE&apos;] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE&apos; IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.COMPOSITE_CURVE&apos; IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg &lt;* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA&apos; IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D&apos; IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE&apos; IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE&apos; IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE&apos; IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) &gt;= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_CURVE&apos; IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE&apos; IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE&apos; IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

    <function name="gbsf_check_surface">
      <parameter name="sf">
        <typename name="surface"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  IF ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE&apos; IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF([&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SPHERICAL_SURFACE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.TOROIDAL_SURFACE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_BOUNDED_SURFACE&apos;, &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_TRIMMED_SURFACE&apos;] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF ((&apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_SURFACE&apos; IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_COMPOSITE_SURFACE&apos; IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_REPLICA&apos; IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF &apos;AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_OF_REVOLUTION&apos; IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>
    </function>

  </schema>
</express>