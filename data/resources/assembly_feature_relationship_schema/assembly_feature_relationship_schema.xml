<?xml version='1.0' encoding='UTF-8'?>
<!-- $Id: assembly_feature_relationship_schema.xml,v 1.1 2004/06/08 18:46:14 thendrix Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  reference="ISO 10303-109"
  rcs.date="$Date: 2004/06/08 18:46:14 $"
  rcs.revision="$Revision: 1.1 $">

  <application
    name="express2xml2.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.36"
    source="../data/resources/assembly_feature_relationship_schema/assembly_feature_relationship_schema.exp"/>

  <schema name="assembly_feature_relationship_schema">

    <interface
      kind="reference"
      schema="assembly_constraint_schema">
    </interface>
    <interface
      kind="reference"
      schema="geometry_schema">
    </interface>
    <interface
      kind="reference"
      schema="kinematic_motion_representation_schema">
    </interface>
    <interface
      kind="reference"
      schema="kinematic_structure_schema">
    </interface>
    <interface
      kind="reference"
      schema="product_definition_schema">
    </interface>
    <interface
      kind="reference"
      schema="product_property_definition_schema">
    </interface>
    <interface
      kind="reference"
      schema="product_property_representation_schema">
    </interface>
    <interface
      kind="reference"
      schema="product_structure_schema">
    </interface>
    <interface
      kind="reference"
      schema="representation_schema">
    </interface>
    <interface
      kind="reference"
      schema="support_resource_schema">
    </interface>
    <type name="representing_relationship">
      <select
        selectitems="binary_assembly_constraint constrained_kinematic_motion_representation free_kinematic_motion_representation">
      </select>
    </type>

    <entity
      name="shape_aspect_relationship_representation_association">
      <explicit
        name="represented_shape_aspect_relationship">
        <typename
          name="shape_aspect_relationship"/>
      </explicit>
      <explicit
        name="representing_representation_relationship">
        <typename
          name="representation_relationship"/>
      </explicit>
      <where
        label="WR1"
        expression="('REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(representing_representation_relationship\ representation_relationship.rep_1)) AND('REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(representing_representation_relationship\ representation_relationship.rep_2))">
      </where>
      <where
        label="WR2"
        expression="(represented_shape_aspect_relationship.relating_shape_aspect IN using_shape_aspect_of_shape_representation(representing_representation_relationship.rep_1\shape_representation)) AND(represented_shape_aspect_relationship.related_shape_aspect IN using_shape_aspect_of_shape_representation(representing_representation_relationship.rep_2\shape_representation))">
      </where>
      <where
        label="WR3"
        expression="((find_representative_shape_representation_of_product_definition(using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.relating_shape_aspect)). context_of_items) :=:(find_representative_shape_representation_of_shape_aspect(represented_shape_aspect_relationship.relating_shape_aspect). context_of_items)) AND((find_representative_shape_representation_of_product_definition(using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.related_shape_aspect)). context_of_items) :=:(find_representative_shape_representation_of_shape_aspect(represented_shape_aspect_relationship.related_shape_aspect). context_of_items))">
      </where>
      <where
        label="WR4"
        expression="using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.relating_shape_aspect) :&lt;&gt;: using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.related_shape_aspect)">
      </where>
      <where
        label="WR5"
        expression="find_assembly_root ([using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.relating_shape_aspect)]) :=: find_assembly_root ([using_product_definition_of_shape_aspect(represented_shape_aspect_relationship.related_shape_aspect)])">
      </where>
    </entity>

    <entity
      name="representative_shape_representation"
      supertypes="shape_representation">
      <where
        label="WR1"
        expression="unique_in_product_definition (SELF) OR unique_in_shape_aspect (SELF)">
      </where>
    </entity>

    <entity
      name="free_kinematic_motion_representation"
      supertypes="representation_relationship_with_transformation">
      <explicit
        name="rep_1">
        <typename
          name="representative_shape_representation"/>
        <redeclaration
          entity-ref="representation_relationship"/>
        </explicit>
        <explicit
          name="rep_2">
          <typename
            name="representative_shape_representation"/>
          <redeclaration
            entity-ref="representation_relationship"/>
          </explicit>
          <explicit
            name="motion">
            <typename
              name="kinematic_path"/>
          </explicit>
          <where
            label="WR1"
            expression="'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator)">
          </where>
          <where
            label="WR2"
            expression="('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1)) AND('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2))">
          </where>
          <where
            label="WR3"
            expression="((dimension_of(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation. transform_item_1\geometric_representation_item) = 3) AND(dimension_of(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation. transform_item_2\geometric_representation_item) = 3))">
          </where>
          <where
            label="WR4"
            expression="(SELF\representation_relationship.rep_1 IN(using_representations(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1) + using_representation_with_mapping(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1))) AND(SELF\representation_relationship.rep_2 IN(using_representations(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2) + using_representation_with_mapping(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2)))">
          </where>
        </entity>

        <entity
          name="constrained_kinematic_motion_representation"
          supertypes="representation_relationship_with_transformation">
          <explicit
            name="rep_1">
            <typename
              name="representative_shape_representation"/>
            <redeclaration
              entity-ref="representation_relationship"/>
            </explicit>
            <explicit
              name="rep_2">
              <typename
                name="representative_shape_representation"/>
              <redeclaration
                entity-ref="representation_relationship"/>
              </explicit>
              <where
                label="WR1"
                expression="('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1)) AND('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2))">
              </where>
              <where
                label="WR2"
                expression="((dimension_of(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation. transform_item_1\geometric_representation_item) = 3) AND(dimension_of(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation. transform_item_2\geometric_representation_item) = 3))">
              </where>
              <where
                label="WR3"
                expression="(SELF\representation_relationship.rep_1 IN(using_representations(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1) + using_representation_with_mapping(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_1))) AND(SELF\representation_relationship.rep_2 IN(using_representations(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2) + using_representation_with_mapping(SELF\representation_relationship_with_transformation. transformation_operator\item_defined_transformation.transform_item_2)))">
              </where>
              <where
                label="WR4"
                expression="'KINEMATIC_PAIR' IN TYPEOF(SELF\representation_relationship_with_transformation. transformation_operator)">
              </where>
            </entity>

            <function
              name="assembly_root">
              <parameter
                name="item">
                <typename
                  name="product_definition"/>
              </parameter>
              <builtintype
                type="BOOLEAN"/>
              <algorithm>
IF (SIZEOF(USEDIN (item,
'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.' +
'RELATED_PRODUCT_DEFINITION')) = 0) THEN RETURN(TRUE);
ELSE RETURN (FALSE);
END_IF;
              </algorithm>
            </function>

            <function
              name="find_assembly_root">
              <parameter
                name="constituent">
                <aggregate
                  type="SET"/>
                <typename
                  name="product_definition"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="product_definition"/>
              <algorithm>
LOCAL
local_relation: SET OF assembly_component_usage := [];
local_relation2: BAG OF assembly_component_usage := [];
local_parent: SET OF product_definition := [];
root : SET OF product_definition;
i : INTEGER := 0;
j : INTEGER := 0;
END_LOCAL;
IF ((SIZEOF (constituent) = 1) AND assembly_root (constituent[1]))
THEN RETURN ([constituent [1]]);
ELSE IF (SIZEOF (constituent) = 0) THEN RETURN ([]);
ELSE
REPEAT j:= 1 TO HIINDEX(constituent);
local_relation2 := local_relation2 + (USEDIN (constituent[j],
'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.'
+'RELATED_PRODUCT_DEFINITION'));
END_REPEAT;
local_relation := bag_to_set (local_relation2);
IF (SIZEOF(local_relation) = 0) THEN
IF (SIZEOF(constituent) = 1) THEN RETURN ([constituent[1]]);
ELSE RETURN ([]);
END_IF;
ELSE
REPEAT i :=1 TO HIINDEX(local_relation);
REPEAT j := 1 TO HIINDEX(constituent);
IF (local_relation[i].relating_product_definition &lt;&gt;
constituent[j]) THEN
local_parent := local_parent +
local_relation[i].relating_product_definition;
END_IF;
END_REPEAT;
END_REPEAT;
IF ((SIZEOF (local_parent) = 1) AND
assembly_root (local_parent[1]))
THEN RETURN ([local_parent[1]]);
ELSE IF (SIZEOF (local_parent) = 0) THEN RETURN ([]);
ELSE
root := find_assembly_root(local_parent);
IF (SIZEOF (root) =1) THEN RETURN (root);
ELSE IF (SIZEOF (root) = 0) THEN RETURN ([]);
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
END_IF;
              </algorithm>
            </function>

            <function
              name="find_shape_representation_of_product_definition">
              <parameter
                name="item">
                <typename
                  name="product_definition"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="shape_representation"/>
              <algorithm>
LOCAL
local_p_d_s: SET OF product_definition_shape := [];
local_p_d_s2: BAG OF product_definition_shape := [];
local_s_d_r: SET OF shape_definition_representation := [];
local_s_d_r2: BAG OF shape_definition_representation := [];
local_s_r: SET OF shape_representation := [];
i : INTEGER;
END_LOCAL;
local_p_d_s2 := local_p_d_s2 + (USEDIN (item,
'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE.DEFINITION'));
local_p_d_s := bag_to_set(local_p_d_s2);
REPEAT i := 1 to HIINDEX (local_p_d_s);
local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d_s[i],
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
'SHAPE_DEFINITION_REPRESENTATION.DEFINITION'));
END_REPEAT;
local_s_d_r := bag_to_set (local_s_d_r2);
REPEAT i := 1 to HIINDEX (local_s_d_r);
IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION'
IN TYPEOF (local_s_d_r[i]\property_definition_representation.
used_representation\shape_representation)) THEN
local_s_r := local_s_r +
local_s_d_r[i]\property_definition_representation.
used_representation\shape_representation;
END_IF;
END_REPEAT;
RETURN (local_s_r);
              </algorithm>
            </function>

            <function
              name="find_shape_representation_of_shape_aspect">
              <parameter
                name="item">
                <typename
                  name="shape_aspect"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="shape_representation"/>
              <algorithm>
LOCAL
local_p_d: SET OF property_definition:= [];
local_s_d_r: SET OF shape_definition_representation := [];
local_s_d_r2: BAG OF shape_definition_representation := [];
local_s_r: SET OF shape_representation := [];
i : INTEGER;
END_LOCAL;
local_p_d := bag_to_set (USEDIN (item,
'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
REPEAT i := 1 to HIINDEX (local_p_d);
local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d[i],
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
'SHAPE_DEFINITION_REPRESENTATION.DEFINITION'));
END_REPEAT;
local_s_d_r := bag_to_set (local_s_d_r2);
REPEAT i := 1 to HIINDEX (local_s_d_r);
IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION'
IN TYPEOF
(local_s_d_r[i].used_representation\shape_representation)) THEN
local_s_r := local_s_r +
local_s_d_r[i]\property_definition_representation.
used_representation\shape_representation;
END_IF;
END_REPEAT;
RETURN (local_s_r);
              </algorithm>
            </function>

            <function
              name="find_representative_shape_representation_of_product_definition">
              <parameter
                name="item">
                <typename
                  name="product_definition"/>
              </parameter>
              <typename
                name="shape_representation"/>
              <algorithm>
LOCAL
local_s_r: SET OF shape_representation := [];
END_LOCAL;
local_s_r := QUERY
(z &lt;* find_shape_representation_of_product_definition (item)|
'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]);
ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;
              </algorithm>
            </function>

            <function
              name="find_representative_shape_representation_of_shape_aspect">
              <parameter
                name="item">
                <typename
                  name="shape_aspect"/>
              </parameter>
              <typename
                name="shape_representation"/>
              <algorithm>
LOCAL
local_s_r: SET OF shape_representation := [];
END_LOCAL;
local_s_r := QUERY (z &lt;* find_shape_representation_of_shape_aspect (item)|
'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]);
ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;
              </algorithm>
            </function>

            <function
              name="unique_in_product_definition">
              <parameter
                name="item">
                <typename
                  name="representative_shape_representation"/>
              </parameter>
              <builtintype
                type="BOOLEAN"/>
              <algorithm>
LOCAL
local_p_d: SET OF product_definition := [];
local_s_r: SET OF shape_representation := [];
i : INTEGER;
j : INTEGER;
END_LOCAL;
local_p_d := using_product_definition_of_shape_representation (item);
IF (SIZEOF (local_p_d) = 0) THEN RETURN (FALSE);
ELSE
REPEAT i := 1 to HIINDEX (local_p_d);
local_s_r := find_shape_representation_of_product_definition
(local_p_d[i]);
REPEAT j := 1 to HIINDEX (local_s_r);
IF (('REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF (local_s_r[j]))
AND (local_s_r[j] :&lt;&gt;: item)) THEN RETURN (FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
END_IF;
RETURN (TRUE);
              </algorithm>
            </function>

            <function
              name="unique_in_shape_aspect">
              <parameter
                name="item">
                <typename
                  name="representative_shape_representation"/>
              </parameter>
              <builtintype
                type="BOOLEAN"/>
              <algorithm>
LOCAL
local_s_a: SET OF shape_aspect := [];
local_s_r: SET OF shape_representation := [];
i : INTEGER;
j : INTEGER;
END_LOCAL;
local_s_a := using_shape_aspect_of_shape_representation (item);
IF (SIZEOF (local_s_a) = 0) THEN RETURN (FALSE);
ELSE
REPEAT i := 1 to HIINDEX (local_s_a);
local_s_r := find_shape_representation_of_shape_aspect
(local_s_a[i]);
REPEAT j := 1 to HIINDEX (local_s_r);
IF ((' REPRESENTATIVE_SHAPE_REPRESENTATION ' IN TYPEOF (local_s_r[j]))
AND (local_s_r[j] :&lt;&gt;: item)) THEN RETURN (FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
END_IF;
RETURN (TRUE);
              </algorithm>
            </function>

            <function
              name="using_product_definition_of_shape_aspect">
              <parameter
                name="item">
                <typename
                  name="shape_aspect"/>
              </parameter>
              <typename
                name="product_definition"/>
              <algorithm>
IF ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
(item.of_shape\property_definition.definition)) THEN
RETURN (item.of_shape\property_definition.definition\product_definition);
END_IF;
              </algorithm>
            </function>

            <function
              name="using_product_definition_of_shape_representation">
              <parameter
                name="item">
                <typename
                  name="shape_representation"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="product_definition"/>
              <algorithm>
LOCAL
local_s_d_r: SET OF shape_definition_representation := [];
local_p_d_s: SET OF product_definition_shape := [];
local_p_d: SET OF product_definition := [];
i : INTEGER;
END_LOCAL;
local_s_d_r := local_s_d_r + bag_to_set (USEDIN (item,
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
'SHAPE_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
REPEAT i := 1 TO HIINDEX (local_s_d_r);
IF (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
TYPEOF (local_s_d_r[i]\property_definition_representation.definition))
AND
('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
(local_s_d_r[i]\property_definition_representation.
definition\property_definition.definition)))
THEN local_p_d := local_p_d +
local_s_d_r[i]\property_definition_representation.
definition\property_definition.definition;
ELSE IF (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION' IN
TYPEOF (local_s_d_r[i]\property_definition_representation.definition))
AND
('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
(local_s_d_r[i]\property_definition_representation.
definition\property_definition.definition)))
THEN local_p_d := local_p_d +
local_s_d_r[i]\property_definition_representation.
definition\property_definition.definition;
END_IF;
END_IF;
END_REPEAT;
RETURN (local_p_d);
              </algorithm>
            </function>

            <function
              name="using_shape_aspect_of_shape_representation">
              <parameter
                name="item">
                <typename
                  name="shape_representation"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="shape_aspect"/>
              <algorithm>
LOCAL
local_s_d_r: SET OF shape_definition_representation := [];
local_s_d_r2: BAG OF shape_definition_representation := [];
local_s_a: SET OF shape_aspect := [];
i : INTEGER;
END_LOCAL;
local_s_d_r2 := local_s_d_r2 + (USEDIN (item,
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
'SHAPE_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
local_s_d_r := bag_to_set (local_s_d_r2);
REPEAT i := 1 TO HIINDEX (local_s_d_r);
IF ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF
(local_s_d_r[i]\property_definition_representation.definition))
THEN local_s_a := local_s_a + local_s_d_r[i]\
property_definition_representation.definition;
END_IF;
END_REPEAT;
RETURN (local_s_a);
              </algorithm>
            </function>

            <function
              name="using_representation_with_mapping">
              <parameter
                name="item">
                <typename
                  name="representation_item"/>
              </parameter>
              <aggregate
                type="SET"/>
              <typename
                name="representation"/>
              <algorithm>
LOCAL
results: SET OF representation := [];
local_results : SET OF representation := [];
local_representation_map : SET OF representation_map := [];
intermediate_items : SET OF representation_item := [];
i : INTEGER;
j : INTEGER;
END_LOCAL;
local_results := QUERY (z &lt;* using_representations (item)|
SIZEOF (USEDIN (z, 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.' +
'MAPPED_REPRESENTATION')) &gt; 0);
IF (SIZEOF (local_results) = 0) THEN RETURN ([]);
ELSE
REPEAT i := 1 TO HIINDEX(local_results);
local_representation_map := local_representation_map +
bag_to_set (USEDIN (local_results[i],
'REPREZENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_representation_map);
intermediate_items := intermediate_items +
bag_to_set (USEDIN (local_representation_map[i],
'REPREZENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
END_REPEAT;
REPEAT j := 1 to HIINDEX(intermediate_items);
results := results + bag_to_set (using_representation_with_mapping
(intermediate_items[j]));
END_REPEAT;
END_IF;
RETURN (results);
              </algorithm>
            </function>

          </schema>
        </express>
