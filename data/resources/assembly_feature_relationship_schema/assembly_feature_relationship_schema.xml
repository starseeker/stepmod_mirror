<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express
  SYSTEM "../../../dtd/express.dtd">
<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-109">
   <application name="JSDAI" owner="LKSoft" source="assembly_feature_relationship_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="assembly_feature_relationship_schema">
      <interface kind="reference" schema="assembly_constraint_schema"/>
      <interface kind="reference" schema="geometry_schema"/>
      <interface kind="reference" schema="kinematic_motion_representation_schema"/>
      <interface kind="reference" schema="kinematic_structure_schema"/>
      <interface kind="reference" schema="product_definition_schema"/>
      <interface kind="reference" schema="product_property_definition_schema"/>
      <interface kind="reference" schema="product_property_representation_schema"/>
      <interface kind="reference" schema="product_structure_schema"/>
      <interface kind="reference" schema="representation_schema"/>
      <interface kind="reference" schema="support_resource_schema"/>
      <interface kind="reference" schema="shape_data_quality_inspection_result_schema"/>
      <type name="representing_relationship">
         <select selectitems="binary_assembly_constraint constrained_kinematic_motion_representation free_kinematic_motion_representation"/>
      </type>
      <entity name="constrained_kinematic_motion_representation" supertypes="representation_relationship_with_transformation">
         <explicit name="rep_1">
            <typename name="representative_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representative_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where expression="('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_1)) AND&#xA;     ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_2))" label="WR1"/>
         <where expression="((dimension_of&#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.&#xA;     transform_item_1\geometric_representation_item) = 3 ) AND&#xA;     (dimension_of &#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.&#xA;     transform_item_2\geometric_representation_item) = 3 ))" label="WR2"/>
         <where expression="(SELF\representation_relationship.rep_1 IN &#xA;     (using_representations &#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_1) +&#xA;     using_representation_with_mapping &#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_1))) AND&#xA;     (SELF\representation_relationship.rep_2 IN &#xA;     (using_representations &#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_2) +&#xA;     using_representation_with_mapping &#xA;     (SELF\representation_relationship_with_transformation.&#xA;     transformation_operator\item_defined_transformation.transform_item_2)))" label="WR3"/>
         <where expression="'KINEMATIC_PAIR' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator)" label="WR4"/>
      </entity>
      <entity name="free_kinematic_motion_representation" supertypes="representation_relationship_with_transformation">
         <explicit name="rep_1">
            <typename name="representative_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representative_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="motion">
            <typename name="kinematic_path"/>
         </explicit>
         <where expression="'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator)" label="WR1"/>
         <where expression="('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_1)) AND&#xA;     ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF&#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_2))" label="WR2"/>
         <where expression="((dimension_of&#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.&#xA;      transform_item_1\geometric_representation_item) = 3 ) AND&#xA;     (dimension_of &#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.&#xA;      transform_item_2\geometric_representation_item) = 3 ))" label="WR3"/>
         <where expression="(SELF\representation_relationship.rep_1 IN &#xA;     (using_representations &#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_1) +&#xA;      using_representation_with_mapping &#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_1))) AND&#xA;     (SELF\representation_relationship.rep_2 IN &#xA;     (using_representations &#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_2) +&#xA;      using_representation_with_mapping &#xA;     (SELF\representation_relationship_with_transformation.&#xA;      transformation_operator\item_defined_transformation.transform_item_2)))" label="WR4"/>
      </entity>
      <entity name="representative_shape_representation" supertypes="shape_representation">
         <where expression="unique_in_product_definition (SELF) OR unique_in_shape_aspect (SELF)" label="WR1"/>
      </entity>
      <entity name="shape_aspect_relationship_representation_association">
         <explicit name="represented_shape_aspect_relationship">
            <typename name="shape_aspect_relationship"/>
         </explicit>
         <explicit name="representing_representation_relationship">
            <typename name="representation_relationship"/>
         </explicit>
         <where expression="('REPRESENTATIVE_SHAPE_REPRESENTATION' IN &#xA;      TYPEOF(representing_representation_relationship\&#xA;      representation_relationship.rep_1)) AND&#xA;     ('REPRESENTATIVE_SHAPE_REPRESENTATION' IN &#xA;      TYPEOF(representing_representation_relationship\&#xA;      representation_relationship.rep_2))" label="WR1"/>
         <where expression="(represented_shape_aspect_relationship.relating_shape_aspect IN &#xA;      using_shape_aspect_of_shape_representation &#xA;      (representing_representation_relationship.rep_1)) AND&#xA;     (represented_shape_aspect_relationship.related_shape_aspect IN &#xA;      using_shape_aspect_of_shape_representation &#xA;      (representing_representation_relationship.rep_2))" label="WR2"/>
         <where expression="((find_representative_shape_representation_of_product_definition &#xA;     (using_product_definition_of_shape_aspect&#xA;     (represented_shape_aspect_relationship.relating_shape_aspect)).&#xA;      context_of_items) :=:&#xA;     (find_representative_shape_representation_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.relating_shape_aspect).&#xA;      context_of_items)) AND&#xA;     ((find_representative_shape_representation_of_product_definition &#xA;     (using_product_definition_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.related_shape_aspect)).&#xA;      context_of_items) :=:&#xA;     (find_representative_shape_representation_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.related_shape_aspect).&#xA;      context_of_items))" label="WR3"/>
         <where expression="using_product_definition_of_shape_aspect&#xA;     (represented_shape_aspect_relationship.relating_shape_aspect) :&lt;&gt;: &#xA;     using_product_definition_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.related_shape_aspect)" label="WR4"/>
         <where expression="find_assembly_root ([using_product_definition_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.relating_shape_aspect)]) :=: &#xA;     find_assembly_root ([using_product_definition_of_shape_aspect &#xA;     (represented_shape_aspect_relationship.related_shape_aspect)])" label="WR5"/>
      </entity>
      <function name="assembly_root">
         <parameter name="item">
            <typename name="product_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (SIZEOF(USEDIN (item, 
   'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.' + 
   'RELATED_PRODUCT_DEFINITION')) = 0) THEN RETURN(TRUE);
ELSE RETURN (FALSE);
END_IF;</algorithm>
      </function>
      <function name="find_assembly_root">
         <parameter name="constituent">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>LOCAL
  local_relation: SET OF assembly_component_usage := [];
  local_relation2: BAG OF assembly_component_usage := [];
  local_parent: SET OF product_definition := [];
  root : SET OF product_definition;
  i : INTEGER := 0;
  j : INTEGER := 0;
END_LOCAL;

-- Is constituent root ? --
IF ((SIZEOF (constituent) = 1) AND assembly_root (constituent[1]))
  THEN RETURN ([constituent [1]]);
-- ERROR constituent is vacant --
  ELSE IF (SIZEOF (constituent) = 0 ) THEN RETURN ([]);

-- extraction of related assembly_component_relationships --
    ELSE
      REPEAT j:= 1 TO HIINDEX(constituent);
        local_relation2 := local_relation2 + (USEDIN (constituent[j], 
                    'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.' 
                    +'RELATED_PRODUCT_DEFINITION'));
      END_REPEAT;
      local_relation := bag_to_set (local_relation2);
      IF (SIZEOF(local_relation) = 0) THEN
        IF (SIZEOF(constituent) = 1) THEN RETURN ([constituent[1]]);
          ELSE RETURN ([]);
        END_IF;
      ELSE
-- extraction of a set of parents --
        REPEAT i :=1 TO HIINDEX(local_relation);
          REPEAT j := 1 TO HIINDEX(constituent);
          IF (local_relation[i].relating_product_definition &lt;&gt; 
              constituent[j]) THEN
            local_parent := local_parent + 
                            local_relation[i].relating_product_definition;
          END_IF;
          END_REPEAT;
        END_REPEAT;
        IF ((SIZEOF (local_parent) = 1 ) AND 
             assembly_root (local_parent[1])) 
          THEN RETURN ([local_parent[1]]); 
          ELSE IF (SIZEOF (local_parent) = 0) THEN RETURN ([]);
-- try again --
            ELSE 
              root := find_assembly_root(local_parent);
              IF (SIZEOF (root) =1) THEN RETURN (root);
                ELSE IF (SIZEOF (root) = 0) THEN RETURN ([]);
                END_IF;
              END_IF;
          END_IF;
        END_IF;
      END_IF;
  END_IF;
END_IF;</algorithm>
      </function>
      <function name="find_representative_shape_representation_of_product_definition">
         <parameter name="item">
            <typename name="product_definition"/>
         </parameter>
         <typename name="shape_representation"/>
         <algorithm>LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the product_definition
  local_s_r := QUERY 
    ( z &lt;* find_shape_representation_of_product_definition (item)|
      'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]); 
   ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;</algorithm>
      </function>
      <function name="find_representative_shape_representation_of_shape_aspect">
         <parameter name="item">
            <typename name="shape_aspect"/>
         </parameter>
         <typename name="shape_representation"/>
         <algorithm>LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the shape_aspect
  local_s_r := QUERY ( z &lt;* find_shape_representation_of_shape_aspect (item)|
               'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]); 
   ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;</algorithm>
      </function>
      <function name="find_shape_representation_of_product_definition">
         <parameter name="item">
            <typename name="product_definition"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="shape_representation"/>
         <algorithm>LOCAL
  local_p_d_s: SET OF product_definition_shape := [];
  local_p_d_s2: BAG OF product_definition_shape := [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find product_definition_shape representing the product_definiton
  local_p_d_s2 := local_p_d_s2 + (USEDIN (item, 
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE.DEFINITION'));
  local_p_d_s := bag_to_set(local_p_d_s2);
-- find shape_definition_representations refereing to the local_p_d_s
  REPEAT i := 1 to HIINDEX (local_p_d_s);
    local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d_s[i], 
                   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                   'SHAPE_DEFINITION_REPRESENTATION.DEFINITION')); 
  END_REPEAT;
  local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' 
        IN TYPEOF (local_s_d_r[i].used_representation)) THEN
        local_s_r := local_s_r + local_s_d_r[i].used_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);</algorithm>
      </function>
      <function name="find_shape_representation_of_shape_aspect">
         <parameter name="item">
            <typename name="shape_aspect"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="shape_representation"/>
         <algorithm>LOCAL
  local_p_d: SET OF property_definition:= [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find property_definition representing the shape_aspect
  local_p_d := bag_to_set (USEDIN (item, 
   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
-- find shape_definition_representations refereing to the local_p_d
  REPEAT i := 1 to HIINDEX (local_p_d);
    local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d[i], 
                   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                   'SHAPE_DEFINITION_REPRESENTATION.DEFINITION')); 
  END_REPEAT;
    local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION'
        IN TYPEOF (local_s_d_r[i].used_representation)) THEN
        local_s_r := local_s_r + local_s_d_r[i].used_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);</algorithm>
      </function>
      <function name="unique_in_product_definition">
         <parameter name="item">
            <typename name="representative_shape_representation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  local_p_d: SET OF product_definition := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find product_definitions represented by the input 
-- representative_shape_representation
  local_p_d := using_product_definition_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_p_d) &lt;&gt; 1) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the product_definitions
    REPEAT i := 1 to HIINDEX (local_p_d);
      local_s_r := find_shape_representation_of_product_definition 
                   (local_p_d[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF (('REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF (local_s_r[j])) 
             AND (local_s_r[j] :&lt;&gt;: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="unique_in_shape_aspect">
         <parameter name="item">
            <typename name="representative_shape_representation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  local_s_a: SET OF shape_aspect := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find shape_aspects represented by the input 
-- representative_shape_representation
  local_s_a := using_shape_aspect_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_s_a) &lt;&gt; 1) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the shape_aspect
    REPEAT i := 1 to HIINDEX (local_s_a);
      local_s_r := find_shape_representation_of_shape_aspect 
                   (local_s_a[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF ((' REPRESENTATIVE_SHAPE_REPRESENTATION ' IN TYPEOF (local_s_r[j])) 
           AND (local_s_r[j] :&lt;&gt;: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="using_product_definition_of_shape_aspect">
         <parameter name="item">
            <typename name="shape_aspect"/>
         </parameter>
         <typename name="product_definition"/>
         <algorithm>IF ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF 
    (item.of_shape.definition)) THEN
    RETURN (item.of_shape.definition);
END_IF;</algorithm>
      </function>
      <function name="using_representation_with_mapping">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL 
  results: SET OF representation := [];
  local_results : SET OF representation := [];
  local_representation_map : SET OF representation_map := [];
  intermediate_items : SET OF representation_item := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find the representations in which the item is used
-- and which is referenced from the representation_map
   local_results := QUERY (z &lt;* using_representations (item)|
           SIZEOF (USEDIN (z, 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.' +
                              'MAPPED_REPRESENTATION')) &gt; 0 );
  IF (SIZEOF (local_results) = 0) THEN RETURN ([]);
  ELSE 
-- find the set of representation_map in which the local_results are used
  REPEAT i := 1 TO HIINDEX(local_results);
  local_representation_map := local_representation_map +
      bag_to_set (USEDIN (local_results[i], 
                 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
-- find the set of mapped_item
  REPEAT i := 1 TO HIINDEX(local_representation_map);
  intermediate_items := intermediate_items + 
          bag_to_set (USEDIN (local_representation_map[i], 
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
  END_REPEAT;
-- repeat same manner
  REPEAT j := 1 to HIINDEX(intermediate_items);
        results := results + bag_to_set (using_representation_with_mapping 
                             (intermediate_items[j]));
    END_REPEAT;
  END_IF;
  RETURN (results);</algorithm>
      </function>
      <function name="using_shape_aspect_of_shape_representation">
         <parameter name="item">
            <typename name="shape_representation"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="shape_aspect"/>
         <algorithm>LOCAL
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_a: SET OF shape_aspect := [];
  i : INTEGER;
END_LOCAL;
-- find shape_definition_representations 
  local_s_d_r2  := local_s_d_r2 + (USEDIN (item, 
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
  'SHAPE_DEFINITION_REPRESENTATION.USED_REPRESENTATION')); 
  local_s_d_r := bag_to_set (local_s_d_r2);
-- find shape_aspects
REPEAT i := 1 TO HIINDEX (local_s_d_r);
   IF ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF 
      (local_s_d_r[i].definition))
   THEN local_s_a := local_s_a + local_s_d_r[i].definition;
   END_IF;
END_REPEAT;
RETURN (local_s_a);</algorithm>
      </function>
   </schema>
</express>