<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date: 2012/07/31 13:43:35 $" rcs.revision="$Revision: 1.12 $" reference="ISO 10303-42">
   <application name="JSDAI" owner="LKSoft" source="geometry_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="geometry_schema">
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="definitional_representation"/>
         <interfaced.item name="founded_item"/>
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_in_context"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_context"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="using_representations"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="global_unit_assigned_context"/>
         <interfaced.item name="length_measure"/>
         <interfaced.item name="parameter_value"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="plane_angle_unit"/>
         <interfaced.item name="positive_length_measure"/>
         <interfaced.item name="positive_plane_angle_measure"/>
      </interface>
      <interface kind="reference" schema="topology_schema">
         <interfaced.item name="edge_curve"/>
         <interfaced.item name="face_surface"/>
         <interfaced.item name="poly_loop"/>
         <interfaced.item name="vertex_point"/>
         <interfaced.item name="volume_with_faces"/>  
      </interface>
      <interface kind="reference" schema="geometric_model_schema">
         <interfaced.item name="block"/>
         <interfaced.item name="boolean_result"/>
         <interfaced.item name="cyclide_segment_solid"/>
         <interfaced.item name="eccentric_cone"/>
         <interfaced.item name="edge_based_wireframe_model"/>
         <interfaced.item name="ellipsoid"/>
         <interfaced.item name="face_based_surface_model"/>
         <interfaced.item name="faceted_primitive"/>
         <interfaced.item name="geometric_set"/>
         <interfaced.item name="half_space_solid"/>
         <interfaced.item name="primitive_2d"/>
         <interfaced.item name="rectangular_pyramid"/>
         <interfaced.item name="right_angular_wedge"/>
         <interfaced.item name="right_circular_cone"/>
         <interfaced.item name="right_circular_cylinder"/>
         <interfaced.item name="shell_based_surface_model"/>
         <interfaced.item name="shell_based_wireframe_model"/>
         <interfaced.item name="solid_model"/>
         <interfaced.item name="sphere"/>
         <interfaced.item name="tessellated_item"/>
         <interfaced.item name="torus"/>
      </interface>
         <interface kind="reference" schema="scan_data_3d_shape_model_schema">
         <interfaced.item name="scanned_data_item"/>
      </interface>
     <constant expression="representation_item('')||&#10;                                   geometric_representation_item()" name="dummy_gri">
         <typename name="geometric_representation_item"/>
      </constant>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt; 0" label="WR1"/>
      </type>
      <type name="extent_enumeration">
         <enumeration items="invalid zero finite_non_zero infinite"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>  
      <type name="linearly_independent_enum">
               <enumeration items="independent not_independent not_tested"/>
      </type> 
      <type name="locally_refined_spline_type_enum">
         <enumeration items="analysis_suitable_t_spline hierarchical_b_spline lr_b_spline semi_standard_t_spline standard_t_spline"/>
      </type>  
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="spline_knot_values">
               <aggregate lower="2" type="LIST" upper="?"/>
                        <builtintype type="REAL"/>
               <where expression="increasing_values_in_list(SELF)" label="WR1"/>
      </type>
      <type name="surface_boundary">
         <select selectitems="boundary_curve degenerate_pcurve"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      
      <entity name="geometric_representation_context" supertypes="representation_context">
                       <explicit name="coordinate_space_dimension">
                          <typename name="dimension_count"/>
                       </explicit>
              </entity>
                  <entity name="geometric_representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set, tessellated_item, volume_with_faces, scanned_data_item)" supertypes="representation_item">
                       <derived expression="dimension_of(SELF)" name="dim">
                          <typename name="dimension_count"/>
                       </derived>
                       <where expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |&#10;      NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;      TYPEOF (using_rep.context_of_items)))) = 0" label="WR1"/>
              </entity>
                <entity name="point" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve)" supertypes="geometric_representation_item"/>
      	   <entity name="cartesian_point" super.expression="ONEOF (cylindrical_point, polar_point, spherical_point)" supertypes="point">
      	               <explicit name="coordinates">
      	                  <aggregate lower="1" type="LIST" upper="3"/>
      	                  <typename name="length_measure"/>
      	               </explicit>
	            </entity>
       <entity name="cylindrical_point" supertypes="cartesian_point">
                     <explicit name="r">
                        <typename name="length_measure"/>
                     </explicit>
                     <explicit name="theta">
                        <typename name="plane_angle_measure"/>
                     </explicit>
                     <explicit name="z">
                        <typename name="length_measure"/>
                     </explicit>
                     <derived expression="[r*cos(theta), r*sin(theta), z]" name="coordinates">
                        <aggregate lower="1" type="LIST" upper="3"/>
                        <typename name="length_measure"/>
                        <redeclaration entity-ref="cartesian_point"/>
                     </derived>
                     <where expression="r &gt;= 0.0" label="WR1"/>
                     <where  label="IP1"/>
               </entity>
         
         <entity name="spherical_point" supertypes="cartesian_point">
                    <explicit name="r">
                       <typename name="length_measure"/>
                    </explicit>
                    <explicit name="theta">
                       <typename name="plane_angle_measure"/>
                    </explicit>
                    <explicit name="phi">
                       <typename name="plane_angle_measure"/>
                    </explicit>
                    <derived expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]" name="coordinates">
                       <aggregate lower="1" type="LIST" upper="3"/>
                       <typename name="length_measure"/>
                       <redeclaration entity-ref="cartesian_point"/>
                    </derived>
                    <where expression="r &gt;= 0.0" label="WR1"/>
                    <where  label="IP1"/>
                    <where  label="IP2"/>
              </entity>
              
       <entity name="polar_point" supertypes="cartesian_point">
                 <explicit name="r">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="theta">
                    <typename name="plane_angle_measure"/>
                 </explicit>
                 <derived expression="[r*cos(theta), r*sin(theta)]" name="coordinates">
                    <aggregate lower="1" type="LIST" upper="3"/>
                    <typename name="length_measure"/>
                    <redeclaration entity-ref="cartesian_point"/>
                 </derived>
                 <where expression="r &gt;= 0.0" label="WR1"/>
                <where  label="IP1"/>
            </entity>
             
       <entity name="point_on_curve" supertypes="point">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="point_parameter">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where  label="IP1"/>
            </entity>
              
            <entity name="point_on_surface" supertypes="point">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="point_parameter_u">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="point_parameter_v">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where  label="IP1"/>
            </entity>
        
        <entity name="point_in_volume" supertypes="point">
                   <explicit name="basis_volume">
                      <typename name="volume"/>
                   </explicit>
                   <explicit name="point_parameter_u">
                      <typename name="parameter_value"/>
                   </explicit>
                   <explicit name="point_parameter_v">
                      <typename name="parameter_value"/>
                   </explicit>
                   <explicit name="point_parameter_w">
                      <typename name="parameter_value"/>
                   </explicit>
                  <where  label="IP1"/>
             </entity>
              
        <entity name="point_replica" supertypes="point">
                 <explicit name="parent_pt">
                    <typename name="point"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator"/>
                 </explicit>
                 <where expression="transformation.dim = parent_pt.dim" label="WR1"/>
                 <where expression="acyclic_point_replica (SELF,parent_pt)" label="WR2"/>
              </entity>
              
      <entity name="degenerate_pcurve" supertypes="point">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="reference_to_curve">
                    <typename name="definitional_representation"/>
                 </explicit>
                 <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
                 <where expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
                 <where expression="reference_to_curve\representation.&#10;                   items[1]\geometric_representation_item.dim =2" label="WR3"/>
                 <where  label="IP1"/>
              </entity>           
      
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
                 <explicit name="equivalent_point">
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
       <entity name="direction" supertypes="geometric_representation_item">
                 <explicit name="direction_ratios">
                    <aggregate lower="2" type="LIST" upper="3"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <where expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0" label="WR1"/>
              </entity>
              
             <entity name="vector" supertypes="geometric_representation_item">
                 <explicit name="orientation">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="magnitude">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="magnitude &gt;= 0.0" label="WR1"/>
              </entity>
          
      <entity name="placement" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)" supertypes="geometric_representation_item">
                 <explicit name="location">
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
      <entity name="axis1_placement" supertypes="placement">
                 <explicit name="axis" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="NVL(normalise(axis), dummy_gri ||&#10;                                 direction([0.0,0.0,1.0]))" name="z">
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim  = 3" label="WR1"/>
              </entity>
              
      <entity name="axis2_placement_2d" supertypes="placement">
                 <explicit name="ref_direction" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="build_2axes(ref_direction)" name="p">
                    <aggregate lower="2" type="LIST" upper="2"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
              </entity>
              
        <entity name="axis2_placement_3d" supertypes="placement">
                 <explicit name="axis" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="ref_direction" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="build_axes(axis,ref_direction)" name="p">
                    <aggregate lower="3" type="LIST" upper="3"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\placement.location.dim = 3" label="WR1"/>
                 <where expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)" label="WR2"/>
                 <where expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)" label="WR3"/>
                 <where expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR&#10;          (cross_product(axis,ref_direction).magnitude &gt; 0.0)" label="WR4"/>
              </entity> 
              
         <entity name="cartesian_transformation_operator" super.expression="ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d)" supertypes="geometric_representation_item functionally_defined_transformation">
                 <explicit name="axis1" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="axis2" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="local_origin">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="scale" optional="YES">
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="NVL(scale, 1.0)" name="scl">
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="scl &gt; 0.0" label="WR1"/>
              </entity>
           
        <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
                 <explicit name="axis3" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,&#10;                        SELF\cartesian_transformation_operator.axis2,axis3)" name="u">
                    <aggregate lower="3" type="LIST" upper="3"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
              </entity> 
              
          <entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
                 <derived expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,&#10;                   SELF\cartesian_transformation_operator.axis2,?)" name="u">
                    <aggregate lower="2" type="LIST" upper="2"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
              </entity> 
              
      <entity name="curve" super.expression="ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica)" supertypes="geometric_representation_item">
                   <where  label="IP1"/>
                  <where  label="IP2"/>
          </entity>
       <entity name="line" supertypes="curve">
                 <explicit name="pnt">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="dir">
                    <typename name="vector"/>
                 </explicit>
                 <where expression="dir.dim  = pnt.dim" label="WR1"/>
              </entity>
       
       <entity name="conic" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)" supertypes="curve">
                  <explicit name="position">
                     <typename name="axis2_placement"/>
                  </explicit>
              </entity>
              
       <entity name="circle" supertypes="conic">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="ellipse" supertypes="conic">
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="hyperbola" supertypes="conic">
                 <explicit name="semi_axis">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_imag_axis">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="parabola" supertypes="conic">
                 <explicit name="focal_dist">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="focal_dist &lt;&gt; 0.0" label="WR1"/>
              </entity>
              
        <entity name="clothoid" supertypes="curve">
                 <explicit name="position">
                    <typename name="axis2_placement"/>
                 </explicit>
                 <explicit name="clothoid_constant">
                    <typename name="length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="circular_involute" supertypes="curve">
                 <explicit name="position">
                    <typename name="axis2_placement"/>
                 </explicit>
                 <explicit name="base_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="bounded_curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve locally_refined_spline_curve)" supertypes="curve">
                        <where  label="IP1"/>
      	          <where  label="IP2"/>
          </entity>
             
      <entity name="polyline" supertypes="bounded_curve">
                 <explicit name="points">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
       <entity name="b_spline_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve" supertypes="bounded_curve">
                 <explicit name="degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="curve_form">
                    <typename name="b_spline_curve_form"/>
                 </explicit>
                 <explicit name="closed_curve">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="(SIZEOF(control_points_list) - 1)" name="upper_index_on_control_points">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="list_to_array(control_points_list,0,&#10;                                             upper_index_on_control_points)" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="upper_index_on_control_points"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))" label="WR1"/>
              </entity>
              
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
                 <explicit name="knot_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="knot_spec">
                    <typename name="knot_type"/>
                 </explicit>
                 <derived expression="SIZEOF(knots)" name="upper_index_on_knots">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(degree, upper_index_on_knots,&#10;                               upper_index_on_control_points,&#10;                               knot_multiplicities, knots)" label="WR1"/>
                 <where expression="SIZEOF(knot_multiplicities) = upper_index_on_knots" label="WR2"/>
              </entity>
              
       <entity name="uniform_curve" supertypes="b_spline_curve"/>
                     
             <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      
         <entity name="bezier_curve" supertypes="b_spline_curve"/>
          
       <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="list_to_array(weights_data,0,&#10;                                      upper_index_on_control_points)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="upper_index_on_control_points"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.&#10;                                           control_points_list)" label="WR1"/>
                 <where expression="curve_weights_positive(SELF)" label="WR2"/>
              </entity>
     
    <entity name="local_b_spline" supertypes="representation_item">
                     <explicit name="degree">
                         <builtintype type="REAL"/>
                     </explicit>
                     <explicit name="knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                      <explicit name="multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit> 
                      <where expression="degree &gt; 0" label="WR1"/>
                     <where expression="SIZEOF(knots) = SIZEOF(multiplicities)" label="WR2"/>
                     <where expression="constraints_param_local_b_spline(degree, knots, multiplicities)" label="WR3"/>
                  </entity>
   
   <entity name="locally_refined_spline_curve" supertypes="bounded_curve">
                       <explicit name="b_splines">
		                         <aggregate lower="2" type="LIST" upper="?"/>
		                        <typename name="local_b_spline"/>
		     </explicit>                    
                    <explicit name="knot_values">
                         <typename name="spline_knot_values"/>
                 </explicit>
                 <explicit name="control_points_list">
		                     <aggregate lower="2" type="LIST" upper="?"/>
		                     <typename name="cartesian_point"/>
		      </explicit>
		      <explicit name="scaling_factors">
		                     <aggregate lower="2" type="LIST" upper="?"/>
		                     <builtintype type="REAL"/>
		                  </explicit>            
		                   <explicit name="closed_curve">
		                     <builtintype type="LOGICAL"/>
		                  </explicit>
		                  <explicit name="locally_refined_spline_type">
		                     <typename name="locally_refined_spline_type_enum"/>
		                  </explicit>
		                  <explicit name="self_intersect">
		                     <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="domain">
		 		                     <aggregate lower="2" type="LIST" upper="?"/>
		 		                     <builtintype type="REAL"/>
		                  </explicit>    
                      <where expression="SIZEOF(b_splines) = SIZEOF(control_points)" label="WR1"/>
                     <where expression="SIZEOF(scaling_factors) = SIZEOF(control_points)" label="WR2"/>
                   </entity>  
   
     <entity name="rational_locally_refined_spline_curve" supertypes="locally_refined_spline_curve">
                            <explicit name="weights_data">
     		                         <aggregate lower="2" type="LIST" upper="?"/>
     		                         <builtintype type="REAL"/>
                        </explicit>
     		       
                           <where expression="SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_curve.
       control_points_list)" label="WR1"/>
                          <where expression="weights_positive(SELF.weights_data_list)" label="WR2"/>
                   </entity>  
  
        <entity name="trimmed_curve" supertypes="bounded_curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="trim_1">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="trimming_select"/>
                 </explicit>
                 <explicit name="trim_2">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="trimming_select"/>
                 </explicit>
                 <explicit name="sense_agreement">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="master_representation">
                    <typename name="trimming_preference"/>
                 </explicit>
                 <where expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))" label="WR1"/>
                 <where expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))" label="WR2"/>
                    <where  label="IP1"/>
                    <where  label="IP2"/>
                    <where  label="IP3"/>
                    <where  label="IP4"/>
                    <where  label="IP5"/>
        </entity>
           
              <entity name="composite_curve" supertypes="bounded_curve">
                 <explicit name="segments">
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <typename name="composite_curve_segment"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="SIZEOF(segments)" name="n_segments">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="segments[n_segments].transition &lt;&gt; discontinuous" name="closed_curve">
                    <builtintype type="LOGICAL"/>
                 </derived>
                 <where expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |&#10;                temp.transition = discontinuous)) = 1)) OR&#10;            ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | &#10;                temp.transition = discontinuous)) = 0))" label="WR1"/>
              </entity>
              
              <entity name="composite_curve_segment" supertypes="founded_item">
                 <explicit name="transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="same_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="parent_curve">
                    <typename name="curve"/>
                 </explicit>
                 <inverse attribute="segments" entity="composite_curve" name="using_curves">
                    <inverse.aggregate lower="1" type="BAG" upper="?"/>
                 </inverse>
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))" label="WR1"/>
              </entity>
                    
       <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
                 <explicit name="param_length">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where expression="param_length &gt; 0.0" label="WR1"/>
              </entity>
              
         <entity name="pcurve" supertypes="curve">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="reference_to_curve">
                    <typename name="definitional_representation"/>
                 </explicit>
                 <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
                 <where expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
                 <where expression="reference_to_curve\representation.items[1]\&#10;                               geometric_representation_item.dim =2" label="WR3"/>
              </entity>
              
       <entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN&#10;                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]))" label="WR1"/>
              </entity>
              
        <entity name="surface_curve" super.expression="ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve" supertypes="curve">
                 <explicit name="curve_3d">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="associated_geometry">
                    <aggregate lower="1" type="LIST" upper="2"/>
                    <typename name="pcurve_or_surface"/>
                 </explicit>
                 <explicit name="master_representation">
                    <typename name="preferred_surface_curve_representation"/>
                 </explicit>
                 <derived expression="get_basis_surface(SELF)" name="basis_surface">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="surface"/>
                 </derived>
                 <where expression="curve_3d.dim = 3" label="WR1"/>
                 <where expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR&#10;                        (master_representation &lt;&gt; pcurve_s1)" label="WR2"/>
                 <where expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR&#10;                        (master_representation &lt;&gt; pcurve_s2)" label="WR3"/>
                 <where expression="NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d))" label="WR4"/>
                   <where  label="IP1"/>
                   <where  label="IP2"/>
            </entity>      
                     
        <entity name="intersection_curve" supertypes="surface_curve">
                 <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
                 <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) &lt;&gt;&#10;             associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
              </entity>
              
       <entity name="seam_curve" supertypes="surface_curve">
                 <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
                 <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) =&#10;           associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
                 <where expression="'GEOMETRY_SCHEMA.PCURVE' IN&#10;           TYPEOF(SELF\surface_curve.associated_geometry[1])" label="WR3"/>
                 <where expression="'GEOMETRY_SCHEMA.PCURVE' IN&#10;            TYPEOF(SELF\surface_curve.associated_geometry[2])" label="WR4"/>
              </entity>
              
      <entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN&#10;             TYPEOF(SELF\surface_curve.curve_3d))" label="WR1"/>
              </entity>
              
      <entity name="composite_curve_on_surface" super.expression="boundary_curve" supertypes="composite_curve">
                 <derived expression="get_basis_surface(SELF)" name="basis_surface">
                    <aggregate lower="0" type="SET" upper="2"/>
                    <typename name="surface"/>
                 </derived>
                 <where expression="SIZEOF(basis_surface) &gt; 0" label="WR1"/>
                 <where expression="constraints_composite_curve_on_surface(SELF)" label="WR2"/>
                  <where  label="IP1"/>
            </entity>
              
      <entity name="offset_curve_2d" supertypes="curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <where expression="basis_curve.dim = 2" label="WR1"/>
              </entity>
             
        <entity name="offset_curve_3d" supertypes="curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="ref_direction">
                    <typename name="direction"/>
                 </explicit>
                 <where expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)" label="WR1"/>
                   <where  label="IP1"/>
            </entity>
              
       <entity name="curve_replica" supertypes="curve">
                 <explicit name="parent_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator"/>
                 </explicit>
                 <where expression="transformation.dim = parent_curve.dim" label="WR1"/>
                 <where expression="acyclic_curve_replica (SELF, parent_curve)" label="WR2"/>
              </entity>       
       
       <entity name="surface" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)" supertypes="geometric_representation_item">
                <where  label="IP1"/>
                <where  label="IP2"/>
            </entity>
       
       <entity name="elementary_surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)" supertypes="surface">
                  <explicit name="position">
                     <typename name="axis2_placement_3d"/>
                  </explicit>
              </entity>
              
       <entity name="plane" supertypes="elementary_surface"/>
                    
      <entity name="cylindrical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="conical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="semi_angle">
                    <typename name="plane_angle_measure"/>
                 </explicit>
                 <where expression="radius &gt;= 0.0" label="WR1"/>
              </entity>
          
      <entity name="spherical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
          
       <entity name="toroidal_surface" supertypes="elementary_surface">
                 <explicit name="major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
          
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
                 <explicit name="select_outer">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="major_radius &lt;   minor_radius" label="WR1"/>
              </entity>
          
       <entity name="dupin_cyclide_surface" supertypes="elementary_surface">
                 <explicit name="generalised_major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="generalised_minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="skewness">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="skewness &gt;= 0.0" label="WR1"/>
              </entity>
          
       <entity name="swept_surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface)" supertypes="surface">
                 <explicit name="swept_curve">
                    <typename name="curve"/>
                 </explicit>
              </entity>
          
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
                 <explicit name="extrusion_axis">
                    <typename name="vector"/>
                 </explicit>
                    <where  label="IP1"/>
            </entity>
              
       <entity name="surface_of_revolution" supertypes="swept_surface">
                 <explicit name="axis_position">
                    <typename name="axis1_placement"/>
                 </explicit>
                 <derived expression="representation_item('')||&#10;                     geometric_representation_item()|| curve()||&#10;                     line(axis_position.location, representation_item('')||&#10;                     geometric_representation_item()||&#10;                     vector(axis_position.z, 1.0))" name="axis_line">
                    <typename name="line"/>
                 </derived>
                  <where  label="IP1"/>
                  <where  label="IP2"/>
           </entity>
              
      <entity name="surface_curve_swept_surface" supertypes="swept_surface">
                 <explicit name="directrix">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="reference_surface">
                    <typename name="surface"/>
                 </explicit>
                 <where expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR&#10;          (reference_surface IN (directrix\surface_curve.basis_surface))" label="WR1"/>
                  <where  label="IP1"/>
                  <where  label="IP2"/>
            </entity>
              
      <entity name="fixed_reference_swept_surface" supertypes="swept_surface">
                 <explicit name="directrix">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="fixed_reference">
                    <typename name="direction"/>
                 </explicit>
                 <where  label="IP1"/>
                 <where  label="IP2"/>
             </entity>
              
      <entity name="bounded_surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface locally_refined_spline_surface)" supertypes="surface">
                  <where  label="IP1"/>
                 <where  label="IP2"/>
             </entity>
             
      <entity name="b_spline_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface" supertypes="bounded_surface">
                 <explicit name="u_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="surface_form">
                    <typename name="b_spline_surface_form"/>
                 </explicit>
                 <explicit name="u_closed">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="v_closed">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="SIZEOF(control_points_list) - 1" name="u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1]) - 1" name="v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="make_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper)" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))" label="WR1"/>
              </entity>
              
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
                 <explicit name="u_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="u_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="knot_spec">
                    <typename name="knot_type"/>
                 </explicit>
                 <derived expression="SIZEOF(u_knots)" name="knot_u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(v_knots)" name="knot_v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;                   knot_u_upper, SELF\b_spline_surface.u_upper,&#10;                               u_multiplicities, u_knots)" label="WR1"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;                   knot_v_upper, SELF\b_spline_surface.v_upper,&#10;                               v_multiplicities, v_knots)" label="WR2"/>
                 <where expression="SIZEOF(u_multiplicities) = knot_u_upper" label="WR3"/>
                 <where expression="SIZEOF(v_multiplicities) = knot_v_upper" label="WR4"/>
              </entity>
              
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
             
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
            
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="(SIZEOF(weights_data) =&#10;                     SIZEOF(SELF\b_spline_surface.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))" label="WR1"/>
                 <where expression="surface_weights_positive(SELF)" label="WR2"/>
              </entity>
              
       <entity name="locally_refined_spline_surface" supertypes="bounded_surface">
                             <explicit name="u_b_splines">
      		                         <aggregate lower="4" type="LIST" upper="?"/>
      		                        <typename name="local_b_spline"/>
      		      </explicit>                   
                               <explicit name="v_b_splines">
      		                         <aggregate lower="4" type="LIST" upper="?"/>
      		                        <typename name="local_b_spline"/>
      		      </explicit>    
                        <explicit name="u_knots">
                               <typename name="spline_knot_values"/>
                       </explicit>
                       <explicit name="v_knots">
		                                      <typename name="spline_knot_values"/>
                       </explicit>
                       <explicit name="control_points_list">
      		                     <aggregate lower="4" type="LIST" upper="?"/>
      		                     <typename name="cartesian_point"/>
      		      </explicit>
      		      <explicit name="scaling_factors">
      		                     <aggregate lower="4" type="LIST" upper="?"/>
      		                     <builtintype type="REAL"/>
      		                  </explicit>            
      		         <explicit name="linearly_independent">
			      		                     <typename name="linearly_independent_enum"/>
      		                  </explicit>
      		        <explicit name="locally_refined_spline_type">
      		                     <typename name="locally_refined_spline_type_enum"/>
      		                  </explicit>
      		                             <explicit name="self_intersect">
				      	                     <builtintype type="LOGICAL"/>
                                 </explicit>
                                 <explicit name="u_closed">
      		                    <builtintype type="LOGICAL"/>
      		                  </explicit>
      		                  <explicit name="v_closed">
				        		                     <builtintype type="LOGICAL"/>
				        		                  </explicit>
      		        
                       <explicit name="domain">
      		 		                     <aggregate lower="2" type="LIST" upper="2"/>
                    <aggregate lower="2" type="LIST" upper="2"/>
      		 		                     <builtintype type="REAL"/>
      		                  </explicit>    
                            <where expression="SIZEOF(u_b_splines) = SIZEOF(control_points_list)" label="WR1"/>
                            <where expression="SIZEOF(v_b_splines) = SIZEOF(control_points_list)" label="WR2"/>
                            <where expression="SIZEOF(scaling_factors) = SIZEOF(control_points_list)" label="WR3"/>
                           <where expression="constraints_scaling(scaling_factors)" label="WR4"/>
                     </entity>  
                   
           <entity name="rational_locally_refined_spline_surface" supertypes="locally_refined_spline_surface">
                                  <explicit name="weights_data">
           		                         <aggregate lower="4" type="LIST" upper="?"/>
           		                         <builtintype type="REAL"/>
                              </explicit>
           		      
                                 <where expression="SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_surface.
	 control_points)" label="WR1"/>
                                <where expression="weights_positive(SELF.weights_data)" label="WR2"/>
                   </entity>  
      
      
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="u1">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="u2">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v1">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v2">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="usense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="vsense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="u1 &lt;&gt; u2" label="WR1"/>
                 <where expression="v1 &lt;&gt; v2" label="WR2"/>
                 <where expression="(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))&#10;       AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR&#10;      ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))&#10;          OR (usense = (u2 &gt; u1))" label="WR3"/>
                 <where expression="(('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))&#10;          OR&#10;         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))&#10;          OR (vsense = (v2 &gt; v1))" label="WR4"/>
                   <where  label="IP1"/>
             </entity>
              
       <entity name="curve_bounded_surface" supertypes="bounded_surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="boundaries">
                    <aggregate lower="1" type="SET" upper="?"/>
                    <typename name="boundary_curve"/>
                 </explicit>
                 <explicit name="implicit_outer">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="(NOT implicit_outer) OR&#10;         (SIZEOF (QUERY (temp &lt;* boundaries |&#10;           'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)" label="WR1"/>
                 <where expression="(NOT(implicit_outer)) OR&#10;                ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface))" label="WR2"/>
                 <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;                  'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN&#10;                                         TYPEOF(temp))) &lt;= 1" label="WR3"/>
                 <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;            (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;&#10;                                         SELF.basis_surface))) = 0" label="WR4"/>
                   <where  label="IP1"/>
                   <where  label="IP2"/>
                   <where  label="IP3"/>
              </entity>
              
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
                 <where expression="SELF\composite_curve.closed_curve" label="WR1"/>
              </entity>
              
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
              
              
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
                 <explicit name="segments">
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <typename name="surface_patch"/>
                 </explicit>
                 <derived expression="SIZEOF(segments)" name="n_u">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(segments[1])" name="n_v">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0" label="WR1"/>
                 <where expression="constraints_rectangular_composite_surface(SELF)" label="WR2"/>
                   <where  label="IP1"/>
             </entity>
              
      <entity name="surface_patch" supertypes="founded_item">
                 <explicit name="parent_surface">
                    <typename name="bounded_surface"/>
                 </explicit>
                 <explicit name="u_transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="v_transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="u_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="v_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <inverse attribute="segments" entity="rectangular_composite_surface" name="using_surfaces">
                    <inverse.aggregate lower="1" type="BAG" upper="?"/>
                 </inverse>
                 <where expression="(NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' &#10;                 IN TYPEOF(parent_surface)))" label="WR1"/>
              </entity>
              
      <entity name="offset_surface" supertypes="surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
              </entity>
              
       <entity name="oriented_surface" supertypes="surface">
                 <explicit name="orientation">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
              </entity>
              
      <entity name="surface_replica" supertypes="surface">
                 <explicit name="parent_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator_3d"/>
                 </explicit>
                 <where expression="acyclic_surface_replica(SELF, parent_surface)" label="WR1"/>
              </entity>
              
      <entity name="volume" super.expression="ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume locally_refined_spline_volume)" supertypes="geometric_representation_item">
                 <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
              </entity>
              
      <entity name="block_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="x">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="y">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="z">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="wedge_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="x">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="y">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="z">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="ltx">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="((0.0 &lt;= ltx) AND (ltx &lt; x))" label="WR1"/>
              </entity>
              
      <entity name="pyramid_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="xlength">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="ylength">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="tetrahedron_volume" supertypes="volume">
                 <explicit name="point_1">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_2">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_3">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_4">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <where expression="point_1.dim = 3" label="WR1"/>
                 <where expression="above_plane(point_1, point_2, point_3, point_4) &lt;&gt; 0.0" label="WR2"/>
              </entity>
              
       <entity name="hexahedron_volume" supertypes="volume">
                 <explicit name="points">
                    <aggregate lower="8" type="LIST" upper="8"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <where expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0" label="WR1"/>
                 <where expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0" label="WR2"/>
                 <where expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0" label="WR3"/>
                 <where expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0" label="WR4"/>
                 <where expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0" label="WR5"/>
                 <where expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0" label="WR6"/>
                 <where expression="same_side([points[1], points[2], points[3]],&#10;                     [points[5], points[6], points[7], points[8]])" label="WR7"/>
                 <where expression="same_side([points[1], points[4], points[8]],&#10;                     [points[3], points[7], points[6], points[2]])" label="WR8"/>
                 <where expression="same_side([points[1], points[2], points[5]],&#10;                      [points[3], points[7], points[8], points[4]])" label="WR9"/>
                 <where expression="same_side([points[5], points[6], points[7]],&#10;                     [points[1], points[2], points[3], points[4]])" label="WR10"/>
                 <where expression="same_side([points[3], points[7], points[6]],&#10;                     [points[1], points[4], points[8], points[5]])" label="WR11"/>
                 <where expression="same_side([points[3], points[7], points[8]],&#10;                      [points[1], points[5], points[6], points[2]])" label="WR12"/>
                 <where expression="points[1].dim = 3" label="WR13"/>
              </entity>
              
      <entity name="spherical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="cylindrical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="eccentric_conical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="x_offset">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="y_offset">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="ratio">
                    <builtintype type="REAL"/>
                 </explicit>
                 <where expression="ratio &gt;= 0.0" label="WR1"/>
              </entity>
              
      <entity name="toroidal_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <where expression="minor_radius &lt; major_radius" label="WR1"/>
              </entity>
              
      <entity name="ellipsoid_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_3">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="b_spline_volume" super.expression="ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume" supertypes="volume">
                 <explicit name="u_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="w_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <derived expression="SIZEOF(control_points_list) - 1" name="u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1]) - 1" name="v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1][1]) - 1" name="w_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="make_array_of_array_of_array (control_points_list,&#10;                                              0,u_upper,0,v_upper,&#10;                                              0,w_upper )" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="w_upper"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF))" label="WR1"/>
              </entity>
              
       <entity name="b_spline_volume_with_knots" supertypes="b_spline_volume">
                 <explicit name="u_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="w_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="u_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="w_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <derived expression="SIZEOF(u_knots)" name="knot_u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(v_knots)" name="knot_v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(w_knots)" name="knot_w_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.u_degree,&#10;                   knot_u_upper, SELF\b_spline_volume.u_upper,&#10;                               u_multiplicities, u_knots)" label="WR1"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.v_degree,&#10;                   knot_v_upper, SELF\b_spline_volume.v_upper,&#10;                               v_multiplicities, v_knots)" label="WR2"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.w_degree,&#10;                   knot_w_upper, SELF\b_spline_volume.w_upper,&#10;                               w_multiplicities, w_knots)" label="WR3"/>
                 <where expression="SIZEOF(u_multiplicities) = knot_u_upper" label="WR4"/>
                 <where expression="SIZEOF(v_multiplicities) = knot_v_upper" label="WR5"/>
                 <where expression="SIZEOF(w_multiplicities) = knot_w_upper" label="WR6"/>
              </entity> 
              
       <entity name="bezier_volume" supertypes="b_spline_volume"/>
              
      <entity name="uniform_volume" supertypes="b_spline_volume"/>
              
      <entity name="quasi_uniform_volume" supertypes="b_spline_volume"/>
              
       <entity name="rational_b_spline_volume" supertypes="b_spline_volume">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="make_array_of_array_of_array&#10;                             (weights_data,0,u_upper,0,v_upper,0,w_upper)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="w_upper"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="(SIZEOF(weights_data) =&#10;                         SIZEOF(SELF\b_spline_volume.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))&#10;            AND (SIZEOF(weights_data[1][1]) =&#10;                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))" label="WR1"/>
                 <where expression="volume_weights_positive(SELF)" label="WR2"/>
              </entity>
      
      <entity name="locally_refined_spline_volume" supertypes="volume">
                                   <explicit name="u_b_splines">
            		                         <aggregate lower="8" type="LIST" upper="?"/>
            		                      <typename name="local_b_spline"/>
                                    </explicit> 
                                     <explicit name="v_b_splines">
            		                         <aggregate lower="8" type="LIST" upper="?"/>
            		         <typename name="local_b_spline"/>
            		      </explicit>    
                              <explicit name="w_b_splines">
			                        <aggregate lower="8" type="LIST" upper="?"/>
            		          <typename name="local_b_spline"/> 
            		     </explicit>  
                              <explicit name="u_knots">
                                     <typename name="spline_knot_values"/>
                             </explicit>
                             <explicit name="v_knots">
      		                                      <typename name="spline_knot_values"/>
                             </explicit>
                             <explicit name="v_knots">
			                      <typename name="spline_knot_values"/>
                             </explicit>
                             <explicit name="control_points_list">
            		                     <aggregate lower="8" type="LIST" upper="?"/>
            		                     <typename name="cartesian_point"/>
            		      </explicit>
            		      <explicit name="scaling_factors">
            		                     <aggregate lower="8" type="LIST" upper="?"/>
            		                     <builtintype type="REAL"/>
            		                  </explicit>            
            		         <explicit name="linearly_independent">
      			      		                     <typename name="linearly_independent_enum"/>
            		                  </explicit>
            		        <explicit name="locally_refined_spline_type">
            		                     <typename name="locally_refined_spline_type_enum"/>
            		               </explicit> 
                             <explicit name="domain">
            		 		                     <aggregate lower="3" type="LIST" upper="3"/>
                          <aggregate lower="2" type="LIST" upper="2"/>
            		 		                     <builtintype type="REAL"/>
            		                  </explicit>    
                                  <where expression="SIZEOF(u_b_splines) = SIZEOF(control_points_list)" label="WR1"/>
                                  <where expression="SIZEOF(v_b_splines) = SIZEOF(control_points_list)" label="WR2"/>
                                  <where expression="SIZEOF(w_b_splines) = SIZEOF(control_points_list)" label="WR3"/>
                                  <where expression="SIZEOF(scaling_factors) = SIZEOF(control_points_list)" label="WR4"/>
                                 <where expression="constraints_scaling(SELF.scaling_factors)" label="WR5"/>
                           </entity>  
                            
                 <entity name="rational_locally_refined_spline_volume" supertypes="locally_refined_spline_volume">
                                        <explicit name="weights_data">
                 		                         <aggregate lower="8" type="LIST" upper="?"/>
                 		                         <builtintype type="REAL"/>
                                    </explicit>
                 		      
                                       <where expression="SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_surface.
      	 control_points_list)" label="WR1"/>
                                      <where expression="weights_positive(SELF.weights_data)" label="WR2"/>
                   </entity>  
      
      
      <rule appliesto="cartesian_point direction geometric_representation_context" name="compatible_dimension">
         <where expression="check_geometric_dimension(cartesian_point, direction, geometric_representation_context);" label="WR1"/>
      </rule>
      
     
      
   
      
     
   
   <function name="above_plane">
         <parameter name="p1">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p2">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p3">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p4">
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim &lt;&gt; 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);</algorithm>
      </function>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor &lt; 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="3" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);</algorithm>
      </function>
    
             <function name="check_geometric_dimension">
                  <parameter name="capt">
                    <aggregate lower="0" type="SET" upper="?"/> 
                     <typename name="cartesian_point"/>
                  </parameter>
                  <parameter name="dir">
                    <aggregate lower="0" type="SET" upper="?"/> 
                     <typename name="direction"/>
                  </parameter>
                  <parameter name="grc">
                    <aggregate lower="0" type="SET" upper="?"/> 
                     <typename name="geometric_representation_context"/>
                   </parameter> 
                    <builtintype type="BOOLEAN"/>
              
             <algorithm>
         (* Determine whether there are mixed dimensions in the contexts.
            If not, only one check of dimensionality is needed per instance of CAPT/DIR
            against this dimension value, not checks against each representation that it
            is referenced by.
            Find for all CAPT and DIR all representations that they are referenced by.
            Return FALSE for the first CAPT or DIR that is not referenced (founded).
            Ensure that the dimensions of all representations are identical to the CAPT/DIR
            dimension. Return FALSE at the first mismatch.
          *)
         LOCAL
           globaldim    : INTEGER := 0; (* means mixed dimensionality *)
           reps         : SET [0:?] OF representation := [];
           result       : BOOLEAN := TRUE; (* means no error *)
         END_LOCAL;
         
         IF (SIZEOF(grc) = 0) THEN
           RETURN(FALSE);
         END_IF;
         
         globaldim:= geometric_dimensionalities_in_contexts(grc);
         
         IF (globaldim &gt; 0) then
         (* Same dimension for all contexts; only one check needed. *)
           IF (SIZEOF(capt) &gt; 0) THEN
             REPEAT i := 1 TO HIINDEX(capt);
               IF (HIINDEX(capt[i].coordinates) &lt; &gt; globaldim) THEN
                 RETURN(FALSE);
               END_IF;
             END_REPEAT;
           END_IF;
           IF (SIZEOF(dir) &gt; 0) THEN
             REPEAT i := 1 TO HIINDEX(dir);
               IF  (HIINDEX(dir[i].direction_ratios) &lt; &gt; globaldim) THEN
                 RETURN(FALSE);
               END_IF;
             END_REPEAT;
           END_IF;
           RETURN(result);
         ELSE
         (*  globaldim=0, mixed dimensions for contexts; check needed for context of each representation in which gri is used. *)
           IF (SIZEOF(capt) &gt; 0) THEN
             REPEAT i := 1 TO HIINDEX(capt);
               reps := using_representations(capt[i]);
               IF (SIZEOF(reps) &gt; 0) THEN
                 REPEAT j := 1 TO HIINDEX(reps);
                   IF (HIINDEX(capt[i].coordinates) &lt; &gt; reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension) THEN
                     RETURN(FALSE);
                   END_IF;
                 END_REPEAT;
               ELSE (* zero reps *)
                 RETURN(FALSE);
               END_IF;
             END_REPEAT;
           END_IF;
           IF (SIZEOF(dir) &gt; 0) THEN
             REPEAT i := 1 TO HIINDEX(dir);
             (*  globaldim=0, Mixed dimensions for  contexts, check needed for context of each representation in which gri is used *)
               reps := using_representations(dir[i]);
               IF (SIZEOF(reps) &gt; 0) THEN
                 REPEAT j := 1 TO HIINDEX(reps);
                   IF (HIINDEX(dir[i].direction_ratios) &lt; &gt; reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension) THEN
                     RETURN(FALSE);
                   END_IF;
                 END_REPEAT;
               ELSE (* zero reps *)
                 RETURN(FALSE);
               END_IF;
             END_REPEAT;
           END_IF;
         END_IF;
         
    RETURN(result);
    </algorithm>
      </function> 
    
    
    <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
     
   
     
     <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
         (sum &lt;&gt; (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k &lt; 1) OR (k &gt; degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i &lt; up_knots) AND (k &gt; degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k &gt; degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      

<function name="constraints_param_local_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
             <parameter name="knot_mult">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
 <algorithm>  
LOCAL
  result : BOOLEAN := TRUE;
  k, up_knots, sum : INTEGER;
END_LOCAL;
(* Find sum of knot multiplicities. *)
  up_knots := SIZEOF(knots);
  sum := knot_mult[1];
REPEAT i := 2 TO up_knots;
  sum := sum + knot_mult[i];
END_REPEAT;
(* Check limits holding for all B-spline parametrisations *)
IF (degree &lt; 1) OR (up_knots &lt; 2) OR 
(sum &lt; &gt; (degree + 2)) THEN
  result := FALSE;
RETURN(result);
END_IF;
k := knot_mult[1];
IF (k &lt; 1) OR (k &gt; degree + 1) THEN
  result := FALSE;
  RETURN(result);
END_IF;
(* first pointer shall be 1 or more *)
IF (knots[1] &lt; 1) THEN
 result :=  FALSE;
END_IF;
REPEAT i := 2 TO up_knots;
 IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
 result := FALSE;
 RETURN(result);
END_IF;
k := knot_mult[i];
IF (i &lt; up_knots) AND (k &gt; degree) THEN
 result := FALSE;
 RETURN(result);
END_IF;
IF (i = up_knots) AND (k &gt; degree + 1) THEN
 result := FALSE;
 RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);
</algorithm>
      </function>  
      
      
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag &gt; 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;</algorithm>
      </function>
      
      <function name="constraints_scaling">
                     <parameter name="factors">
                        <aggregate  type="LIST" />
      		              <builtintype type="REAL"/>
               </parameter>
                     <builtintype type="BOOLEAN"/>
                     <algorithm>
                  LOCAL
                     result : BOOLEAN := TRUE;
                 END_LOCAL;
                 REPEAT i := 1 TO SIZEOF(factors);
                  IF IF NOT({0.0 &lt; factors[i] &lt;= 1.0}) THEN
                    result := FALSE;
                    RETURN(result);
                  END_IF;
                END_REPEAT;
            RETURN(result);
            </algorithm>
            </function>
      
      
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="default_b_spline_curve_weights">
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="up_cp"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([1:up_cp + 1]);</algorithm>
      </function>
      <function name="default_b_spline_knot_mult">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="?"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);</algorithm>
      </function>
      <function name="default_b_spline_knots">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="?"/>
         <typename name="parameter_value"/>
         <algorithm>LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);</algorithm>
      </function>
      <function name="default_b_spline_surface_weights">
         <parameter name="u_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="v_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="u_upper"/>
         <aggregate lower="0" type="ARRAY" upper="v_upper"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([[1:v_upper + 1]:u_upper +1]);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
    IF (SIZEOF(x) &gt; 0) THEN
       y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
    ELSE
      RETURN(?);
    -- mark error by returning indeterminate result
   END_IF;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim &lt;&gt; arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
          (z.direction_ratios &lt;&gt; [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim &lt;&gt; 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);</algorithm>
   </function>
  
   <function name="geometric_dimensionalities_in_contexts">
                <parameter name="grcs">
                  <aggregate lower="1" type="SET" upper="?"/> 
                   <typename name="geometric_representation_context"/>
                 </parameter>
                 <builtintype type="INTEGER"/>
    <algorithm>            
    (* There may be three types of geometric dimensionality: 1d, 2d or 3d.
     This function determines how many of those are in the input set.
     If there is one type only, the number 1, 2 or 3 is returned depending on the type of dimensionality.
     Otherwise, the number 0 is returned.
   *)
  LOCAL
    grcs_1d : INTEGER := 0;
    grcs_2d : INTEGER := 0;
    grcs_3d : INTEGER := 0;
  END_LOCAL;
  
  IF (SIZEOF(grcs) = 1) THEN
    (* only one geometric_context, will be one type of dimension anyway *)
    RETURN(grcs[1]\geometric_representation_context.coordinate_space_dimension);
  ELSE
    REPEAT i := 1 TO HIINDEX(grcs);
      IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 1) THEN
        grcs_1d := grcs_1d + 1;
      ELSE
        IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 2) THEN
          grcs_2d := grcs_2d + 1;
        ELSE
          IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 3) THEN
            grcs_3d := grcs_3d + 1;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  
  IF (grcs_1d + grcs_2d = 0) THEN
    RETURN(3);
  ELSE
    IF (grcs_1d + grcs_3d = 0) THEN
      RETURN(2);
    ELSE
      IF (grcs_2d + grcs_3d = 0) THEN
        RETURN(1);
      ELSE
        RETURN(0); (* multiple dimensions *)
      END_IF;
    END_IF;
  END_IF;
  </algorithm>
      </function>     
    
   <function name="increasing_values_in_list">
         <parameter name="values">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>   
      LOCAL
      result : BOOLEAN := TRUE;
      limit : INTEGER := SIZEOF(values);
      END_LOCAL;
      REPEAT i := 2 TO limit;
       IF values[i] &lt;= values[i-1] THEN
         result := FALSE;
       END_IF;
      END_REPEAT;
    RETURN(result);
     </algorithm>
   </function> 
      
      
      
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low" type="ARRAY" upper="u"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n &lt;&gt; (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low1" type="ARRAY" upper="u1"/>
         <aggregate lower="low2" type="ARRAY" upper="u2"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);</algorithm>
      </function>
      <function name="make_array_of_array_of_array">
         <parameter name="lis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low3">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u3">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low1" type="ARRAY" upper="u1"/>
         <aggregate lower="low2" type="ARRAY" upper="u2"/>
         <aggregate lower="low3" type="ARRAY" upper="u3"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      v      : direction := dummy_gri || direction ([1.0,0.0,0.0]);
      result : vector_or_direction;
      vec    : vector := dummy_gri || vector (v, 1.0);
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg\vector.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag &gt; 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;</algorithm>
      </function>
      <function name="same_side">
         <parameter name="plane_pts">
            <aggregate lower="3" type="LIST" upper="3"/>
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="test_points">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 &lt;= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec\vector.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag &lt; 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] &lt;= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1\vector.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2\vector.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag &gt; 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="vector_sum">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1\vector.magnitude;
         vec1 := arg1\vector.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2\vector.magnitude;
         vec2 := arg2\vector.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag &gt; 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);</algorithm>
      </function>
      <function name="volume_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_volume"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] &lt;= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);</algorithm>
      </function>
      
      <function name="weights_positive">
               <parameter name="weights">
                  <aggregate  type="LIST" />
		              <builtintype type="REAL"/>
         </parameter>
               <builtintype type="BOOLEAN"/>
               <algorithm>
            LOCAL
               result : BOOLEAN := TRUE;
           END_LOCAL;
           REPEAT i := 1 TO SIZEOF(weights);
            IF weights[i] &lt;= 0.0 THEN
              result := FALSE;
              RETURN(result);
            END_IF;
          END_REPEAT;
      RETURN(result);
      </algorithm>
      </function>
        
   </schema>
</express>