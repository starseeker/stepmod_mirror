<?xml version='1.0' encoding='UTF-8'?>
<!-- $Id: express2xml.js,v 1.32 2003/05/02 07:56:57 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  reference="ISO 10303-42"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.32"
    source="../data/resources/geometry_schema/geometry_schema.exp"/>

  <schema name="geometry_schema">

    <interface
      kind="reference"
      schema="representation_schema">
      <interfaced.item
        name="definitional_representation"/>
      <interfaced.item
        name="founded_item"/>
      <interfaced.item
        name="functionally_defined_transformation"/>
      <interfaced.item
        name="item_in_context"/>
      <interfaced.item
        name="representation"/>
      <interfaced.item
        name="representation_item"/>
      <interfaced.item
        name="representation_context"/>
      <interfaced.item
        name="using_representations"/>
    </interface>
    <interface
      kind="reference"
      schema="measure_schema">
      <interfaced.item
        name="global_unit_assigned_context"/>
      <interfaced.item
        name="length_measure"/>
      <interfaced.item
        name="parameter_value"/>
      <interfaced.item
        name="plane_angle_measure"/>
      <interfaced.item
        name="plane_angle_unit"/>
      <interfaced.item
        name="positive_length_measure"/>
      <interfaced.item
        name="positive_plane_angle_measure"/>
    </interface>
    <interface
      kind="reference"
      schema="topology_schema">
      <interfaced.item
        name="edge_curve"/>
      <interfaced.item
        name="face_surface"/>
      <interfaced.item
        name="poly_loop"/>
      <interfaced.item
        name="vertex_point"/>
    </interface>
    <interface
      kind="reference"
      schema="geometric_model_schema">
      <interfaced.item
        name="block"/>
      <interfaced.item
        name="boolean_result"/>
      <interfaced.item
        name="cyclide_segment_solid"/>
      <interfaced.item
        name="eccentric_cone"/>
      <interfaced.item
        name="edge_based_wireframe_model"/>
      <interfaced.item
        name="ellipsoid"/>
      <interfaced.item
        name="face_based_surface_model"/>
      <interfaced.item
        name="faceted_primitive"/>
      <interfaced.item
        name="geometric_set"/>
      <interfaced.item
        name="half_space_solid"/>
      <interfaced.item
        name="half_space_2d"/>
      <interfaced.item
        name="primitive_2d"/>
      <interfaced.item
        name="rectangular_pyramid"/>
      <interfaced.item
        name="right_angular_wedge"/>
      <interfaced.item
        name="right_circular_cone"/>
      <interfaced.item
        name="right_circular_cylinder"/>
      <interfaced.item
        name="shell_based_surface_model"/>
      <interfaced.item
        name="shell_based_wireframe_model"/>
      <interfaced.item
        name="solid_model"/>
      <interfaced.item
        name="sphere"/>
      <interfaced.item
        name="torus"/>
    </interface>
    <constant name="dummy_gri"
      expression="representation_item('')|| geometric_representation_item()">
      <typename
        name="geometric_representation_item"/>
    </constant>

    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>
    </type>

    <type name="b_spline_curve_form">
      <enumeration
        items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified">
      </enumeration>
    </type>

    <type name="b_spline_surface_form">
      <enumeration
        items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified">
      </enumeration>
    </type>

    <type name="curve_on_surface">
      <select
        selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>
    </type>

    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>
      <where
        label="WR1"
        expression="SELF &gt; 0">
      </where>
    </type>

    <type name="extent_enumeration">
      <enumeration
        items="invalid zero finite_non_zero infinite">
      </enumeration>
    </type>

    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified">
      </enumeration>
    </type>

    <type name="pcurve_or_surface">
      <select
        selectitems="pcurve surface">
      </select>
    </type>

    <type name="preferred_surface_curve_representation">
      <enumeration
        items="curve_3d pcurve_s1 pcurve_s2">
      </enumeration>
    </type>

    <type name="surface_boundary">
      <select
        selectitems="boundary_curve degenerate_pcurve">
      </select>
    </type>

    <type name="transition_code">
      <enumeration
        items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature">
      </enumeration>
    </type>

    <type name="trimming_preference">
      <enumeration
        items="cartesian parameter unspecified">
      </enumeration>
    </type>

    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value">
      </select>
    </type>

    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>
    </type>

    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]))">
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="placement.location.dim = 3">
      </where>
      <where
        label="WR2"
        expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)">
      </where>
      <where
        label="WR3"
        expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)">
      </where>
      <where
        label="WR4"
        expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR (cross_product(axis,ref_direction).magnitude &gt; 0.0)">
      </where>
    </entity>

    <entity
      name="b_spline_curve"
      super.expression="(ONEOF(uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve)"
      supertypes="bounded_curve">
      <explicit
        name="degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename
          name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="(SIZEOF(control_points_list) - 1)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(control_points_list,0, upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="cartesian_point"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))">
      </where>
    </entity>

    <entity
      name="b_spline_curve_with_knots"
      supertypes="b_spline_curve">
      <explicit
        name="knot_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(knot_multiplicities) = upper_index_on_knots">
      </where>
    </entity>

    <entity
      name="b_spline_surface"
      super.expression="(ONEOF(b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface)"
      supertypes="bounded_surface">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="surface_form">
        <typename
          name="b_spline_surface_form"/>
      </explicit>
      <explicit
        name="u_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="v_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array(control_points_list, 0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="b_spline_surface_with_knots"
      supertypes="b_spline_surface">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots)">
      </where>
      <where
        label="WR2"
        expression="constraints_param_b_spline(b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots)">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(u_multiplicities) = knot_u_upper">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(v_multiplicities) = knot_v_upper">
      </where>
    </entity>

    <entity
      name="b_spline_volume"
      super.expression="(ONEOF(b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume,bezier_volume) ANDOR rational_b_spline_volume)"
      supertypes="volume">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="w_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="w_upper"
        expression="SIZEOF(control_points_list[1][1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array_of_array (control_points_list, 0,u_upper,0,v_upper, 0,w_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="b_spline_volume_with_knots"
      supertypes="b_spline_volume">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="w_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="w_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_w_upper"
        expression="SIZEOF(w_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper, u_multiplicities, u_knots)">
      </where>
      <where
        label="WR2"
        expression="constraints_param_b_spline(b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper, v_multiplicities, v_knots)">
      </where>
      <where
        label="WR3"
        expression="constraints_param_b_spline(b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper, w_multiplicities, w_knots)">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(u_multiplicities) = knot_u_upper">
      </where>
      <where
        label="WR5"
        expression="SIZEOF(v_multiplicities) = knot_v_upper">
      </where>
      <where
        label="WR6"
        expression="SIZEOF(w_multiplicities) = knot_w_upper">
      </where>
    </entity>

    <entity
      name="bezier_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="bezier_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="bezier_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="block_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="boundary_curve"
      supertypes="composite_curve_on_surface">
      <where
        label="WR1"
        expression="composite_curve.closed_curve">
      </where>
    </entity>

    <entity
      name="bounded_curve"
      super.expression="(ONEOF(polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))"
      supertypes="curve">
    </entity>

    <entity
      name="bounded_pcurve"
      supertypes="pcurve bounded_curve">
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(pcurve.reference_to_curve.items[1]))">
      </where>
    </entity>

    <entity
      name="bounded_surface"
      super.expression="(ONEOF(b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))"
      supertypes="surface">
    </entity>

    <entity
      name="bounded_surface_curve"
      supertypes="surface_curve bounded_curve">
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(surface_curve.curve_3d))">
      </where>
    </entity>

    <entity
      name="cartesian_point"
      super.expression="(ONEOF(cylindrical_point, polar_point, spherical_point))"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(ONEOF(cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale, 1.0)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="scl &gt; 0.0">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_2d"
      supertypes="cartesian_transformation_operator">
      <derived
        name="u"
        expression="base_axis(2,cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,?)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3,cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="circle"
      supertypes="conic">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="circular_involute"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
      <explicit
        name="base_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="clothoid"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
      <explicit
        name="clothoid_constant">
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="composite_curve"
      supertypes="bounded_curve">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt; discontinuous">
        <builtintype
          type="LOGICAL"/>
      </derived>
      <where
        label="WR1"
        expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 1)) OR ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | temp.transition = discontinuous)) = 0))">
      </where>
    </entity>

    <entity
      name="composite_curve_on_surface"
      super.expression="(boundary_curve)"
      supertypes="composite_curve">
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="0"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(basis_surface) &gt; 0">
      </where>
      <where
        label="WR2"
        expression="constraints_composite_curve_on_surface(SELF)">
      </where>
    </entity>

    <entity
      name="composite_curve_segment"
      supertypes="founded_item">
      <explicit
        name="transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))">
      </where>
    </entity>

    <entity
      name="conic"
      super.expression="(ONEOF(circle, ellipse, hyperbola, parabola))"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
    </entity>

    <entity
      name="conical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="radius &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="curve"
      super.expression="(ONEOF(line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="curve_bounded_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="boundary_curve"/>
      </explicit>
      <explicit
        name="implicit_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="(NOT implicit_outer) OR (SIZEOF (QUERY (temp &lt;* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)">
      </where>
      <where
        label="WR2"
        expression="(NOT(implicit_outer)) OR ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface))">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(QUERY(temp &lt;* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) &lt;= 1">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(QUERY(temp &lt;* boundaries | (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt; SELF.basis_surface))) = 0">
      </where>
    </entity>

    <entity
      name="curve_replica"
      supertypes="curve">
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="WR1"
        expression="transformation.dim = parent_curve.dim">
      </where>
      <where
        label="WR2"
        expression="acyclic_curve_replica (SELF, parent_curve)">
      </where>
    </entity>

    <entity
      name="cylindrical_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="length_measure"/>
      </explicit>
      <derived
        name="cartesian_point.coordinates"
        expression="[r*cos(theta), r*sin(theta), z]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="cylindrical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cylindrical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="degenerate_pcurve"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(reference_to_curve\representation.items) = 1">
      </where>
      <where
        label="WR2"
        expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1])">
      </where>
      <where
        label="WR3"
        expression="reference_to_curve\representation. items[1]\geometric_representation_item.dim =2">
      </where>
    </entity>

    <entity
      name="degenerate_toroidal_surface"
      supertypes="toroidal_surface">
      <explicit
        name="select_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="major_radius &lt; minor_radius">
      </where>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0">
      </where>
    </entity>

    <entity
      name="dupin_cyclide_surface"
      supertypes="elementary_surface">
      <explicit
        name="generalised_major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="generalised_minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="skewness">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="skewness &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="eccentric_conical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="x_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="y_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="ratio">
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="ratio &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="elementary_surface"
      super.expression="(ONEOF(plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))"
      supertypes="surface">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
    </entity>

    <entity
      name="ellipse"
      supertypes="conic">
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="ellipsoid_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_3">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="evaluated_degenerate_pcurve"
      supertypes="degenerate_pcurve">
      <explicit
        name="equivalent_point">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="fixed_reference_swept_surface"
      supertypes="swept_surface">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="fixed_reference">
        <typename
          name="direction"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF(point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, half_space_2d, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0">
      </where>
    </entity>

    <entity
      name="line"
      supertypes="curve">
      <explicit
        name="pnt">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename
          name="vector"/>
      </explicit>
      <where
        label="WR1"
        expression="dir.dim = pnt.dim">
      </where>
    </entity>

    <entity
      name="hexahedron_volume"
      supertypes="volume">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="8"
          upper="8"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <where
        label="WR1"
        expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0">
      </where>
      <where
        label="WR2"
        expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0">
      </where>
      <where
        label="WR3"
        expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0">
      </where>
      <where
        label="WR4"
        expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0">
      </where>
      <where
        label="WR5"
        expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0">
      </where>
      <where
        label="WR6"
        expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0">
      </where>
      <where
        label="WR7"
        expression="same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]])">
      </where>
      <where
        label="WR8"
        expression="same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]])">
      </where>
      <where
        label="WR9"
        expression="same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]])">
      </where>
      <where
        label="WR10"
        expression="same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]])">
      </where>
      <where
        label="WR11"
        expression="same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]])">
      </where>
      <where
        label="WR12"
        expression="same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]])">
      </where>
      <where
        label="WR13"
        expression="points[1].dim = 3">
      </where>
    </entity>

    <entity
      name="hyperbola"
      supertypes="conic">
      <explicit
        name="semi_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="intersection_curve"
      supertypes="surface_curve">
      <where
        label="WR1"
        expression="SIZEOF(surface_curve.associated_geometry) = 2">
      </where>
      <where
        label="WR2"
        expression="associated_surface(surface_curve.associated_geometry[1]) &lt;&gt; associated_surface(SELF\surface_curve.associated_geometry[2])">
      </where>
    </entity>

    <entity
      name="offset_curve_2d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <where
        label="WR1"
        expression="basis_curve.dim = 2">
      </where>
    </entity>

    <entity
      name="offset_curve_3d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="ref_direction">
        <typename
          name="direction"/>
      </explicit>
      <where
        label="WR1"
        expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)">
      </where>
    </entity>

    <entity
      name="offset_surface"
      supertypes="surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="oriented_surface"
      supertypes="surface">
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="outer_boundary_curve"
      supertypes="boundary_curve">
    </entity>

    <entity
      name="parabola"
      supertypes="conic">
      <explicit
        name="focal_dist">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="focal_dist &lt;&gt; 0.0">
      </where>
    </entity>

    <entity
      name="pcurve"
      supertypes="curve">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(reference_to_curve\representation.items) = 1">
      </where>
      <where
        label="WR2"
        expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1])">
      </where>
      <where
        label="WR3"
        expression="reference_to_curve\representation.items[1]\ geometric_representation_item.dim =2">
      </where>
    </entity>

    <entity
      name="placement"
      super.expression="(ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))"
      supertypes="geometric_representation_item">
      <explicit
        name="location">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="plane"
      supertypes="elementary_surface">
    </entity>

    <entity
      name="polar_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="cartesian_point.coordinates"
        expression="[r*cos(theta), r*sin(theta)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="point"
      super.expression="(ONEOF(cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="point_in_volume"
      supertypes="point">
      <explicit
        name="basis_volume">
        <typename
          name="volume"/>
      </explicit>
      <explicit
        name="point_parameter_u">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_v">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_w">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_on_curve"
      supertypes="point">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="point_parameter">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_on_surface"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="point_parameter_u">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_v">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_replica"
      supertypes="point">
      <explicit
        name="parent_pt">
        <typename
          name="point"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="WR1"
        expression="transformation.dim = parent_pt.dim">
      </where>
      <where
        label="WR2"
        expression="acyclic_point_replica (SELF,parent_pt)">
      </where>
    </entity>

    <entity
      name="polyline"
      supertypes="bounded_curve">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="pyramid_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="xlength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ylength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="quasi_uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="quasi_uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="quasi_uniform_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="rational_b_spline_curve"
      supertypes="b_spline_curve">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="weights"
        expression="list_to_array(weights_data,0, upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(weights_data) = SIZEOF(b_spline_curve. control_points_list)">
      </where>
      <where
        label="WR2"
        expression="curve_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rational_b_spline_surface"
      supertypes="b_spline_surface">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="weights"
        expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="(SIZEOF(weights_data) = SIZEOF(b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]))">
      </where>
      <where
        label="WR2"
        expression="surface_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rational_b_spline_volume"
      supertypes="b_spline_volume">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="weights"
        expression="make_array_of_array_of_array (weights_data,0,u_upper,0,v_upper,0,w_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="(SIZEOF(weights_data) = SIZEOF(b_spline_volume.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))">
      </where>
      <where
        label="WR2"
        expression="volume_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rectangular_composite_surface"
      supertypes="bounded_surface">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <derived
        name="n_u"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="n_v"
        expression="SIZEOF(segments[1])">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0">
      </where>
      <where
        label="WR2"
        expression="constraints_rectangular_composite_surface(SELF)">
      </where>
    </entity>

    <entity
      name="rectangular_trimmed_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="u1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="u2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="usense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="vsense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="u1 &lt;&gt; u2">
      </where>
      <where
        label="WR2"
        expression="v1 &lt;&gt; v2">
      </where>
      <where
        label="WR3"
        expression="(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 &gt; u1))">
      </where>
      <where
        label="WR4"
        expression="(('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 &gt; v1))">
      </where>
    </entity>

    <entity
      name="reparametrised_composite_curve_segment"
      supertypes="composite_curve_segment">
      <explicit
        name="param_length">
        <typename
          name="parameter_value"/>
      </explicit>
      <where
        label="WR1"
        expression="param_length &gt; 0.0">
      </where>
    </entity>

    <entity
      name="seam_curve"
      supertypes="surface_curve">
      <where
        label="WR1"
        expression="SIZEOF(surface_curve.associated_geometry) = 2">
      </where>
      <where
        label="WR2"
        expression="associated_surface(surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2])">
      </where>
      <where
        label="WR3"
        expression="'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(surface_curve.associated_geometry[1])">
      </where>
      <where
        label="WR4"
        expression="'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(surface_curve.associated_geometry[2])">
      </where>
    </entity>

    <entity
      name="spherical_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="phi">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="cartesian_point.coordinates"
        expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="spherical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="spherical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="surface"
      super.expression="(ONEOF(elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="surface_curve"
      super.expression="(ONEOF(intersection_curve, seam_curve) ANDOR bounded_surface_curve)"
      supertypes="curve">
      <explicit
        name="curve_3d">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="associated_geometry">
        <aggregate
          type="LIST"
          lower="1"
          upper="2"/>
        <typename
          name="pcurve_or_surface"/>
      </explicit>
      <explicit
        name="master_representation">
        <typename
          name="preferred_surface_curve_representation"/>
      </explicit>
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="WR1"
        expression="curve_3d.dim = 3">
      </where>
      <where
        label="WR2"
        expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation &lt;&gt; pcurve_s1)">
      </where>
      <where
        label="WR3"
        expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation &lt;&gt; pcurve_s2)">
      </where>
      <where
        label="WR4"
        expression="NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d))">
      </where>
    </entity>

    <entity
      name="surface_curve_swept_surface"
      supertypes="swept_surface">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="reference_surface">
        <typename
          name="surface"/>
      </explicit>
      <where
        label="WR1"
        expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface))">
      </where>
    </entity>

    <entity
      name="surface_of_linear_extrusion"
      supertypes="swept_surface">
      <explicit
        name="extrusion_axis">
        <typename
          name="vector"/>
      </explicit>
    </entity>

    <entity
      name="surface_of_revolution"
      supertypes="swept_surface">
      <explicit
        name="axis_position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <derived
        name="axis_line"
        expression="representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0))">
        <typename
          name="line"/>
      </derived>
    </entity>

    <entity
      name="surface_patch"
      supertypes="founded_item">
      <explicit
        name="parent_surface">
        <typename
          name="bounded_surface"/>
      </explicit>
      <explicit
        name="u_transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="v_transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="u_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="v_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <inverse
        name="using_surfaces"
        entity="rectangular_composite_surface"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="WR1"
        expression="(NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)))">
      </where>
    </entity>

    <entity
      name="surface_replica"
      supertypes="surface">
      <explicit
        name="parent_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator_3d"/>
      </explicit>
      <where
        label="WR1"
        expression="acyclic_surface_replica(SELF, parent_surface)">
      </where>
    </entity>

    <entity
      name="swept_surface"
      super.expression="(ONEOF(surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface))"
      supertypes="surface">
      <explicit
        name="swept_curve">
        <typename
          name="curve"/>
      </explicit>
    </entity>

    <entity
      name="tetrahedron_volume"
      supertypes="volume">
      <explicit
        name="point_1">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="point_2">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="point_3">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="point_4">
        <typename
          name="cartesian_point"/>
      </explicit>
      <where
        label="WR1"
        expression="point_1.dim = 3">
      </where>
      <where
        label="WR2"
        expression="above_plane(point_1, point_2, point_3, point_4) &lt;&gt; 0.0">
      </where>
    </entity>

    <entity
      name="toroidal_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="minor_radius &lt; major_radius">
      </where>
    </entity>

    <entity
      name="trimmed_curve"
      supertypes="bounded_curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="trim_1">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="trimming_select"/>
      </explicit>
      <explicit
        name="trim_2">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="trimming_select"/>
      </explicit>
      <explicit
        name="sense_agreement">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="master_representation">
        <typename
          name="trimming_preference"/>
      </explicit>
      <where
        label="WR1"
        expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))">
      </where>
      <where
        label="WR2"
        expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))">
      </where>
    </entity>

    <entity
      name="toroidal_surface"
      supertypes="elementary_surface">
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="uniform_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="vector"
      supertypes="geometric_representation_item">
      <explicit
        name="orientation">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="magnitude">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="magnitude &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="volume"
      super.expression="(ONEOF(block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume))"
      supertypes="geometric_representation_item">
      <where
        label="WR1"
        expression="geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="wedge_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ltx">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="((0.0 &lt;= ltx) AND (ltx &lt; x))">
      </where>
    </entity>

    <rule
      name="compatible_dimension"
      appliesto="cartesian_point direction representation_context geometric_representation_context">
      <algorithm>
      </algorithm>
<!-- ensure that the count of coordinates of each cartesian_point -->
<!-- matches the coordinate_space_dimension of each geometric_context in -->
<!-- which it is geometrically founded -->
      <where
        label="WR1"
        expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY (y &lt;* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) =0">
      </where>
<!-- ensure that the count of direction_ratios of each direction -->
<!-- matches the coordinate_space_dimension of each geometric_context in -->
<!-- which it is geometrically founded -->
      <where
        label="WR2"
        expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF(QUERY (y &lt;* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension))) &gt; 0)) = 0">
      </where>
    </rule>

    <function
      name="above_plane">
      <parameter
        name="p1">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p2">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p3">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p4">
        <typename
          name="cartesian_point"/>
      </parameter>
      <builtintype
        type="REAL"/>
      <algorithm>
LOCAL
dir2, dir3, dir4 : direction :=
dummy_gri || direction([1.0, 0.0, 0.0]);
val, mag : REAL;
END_LOCAL;

IF (p1.dim &lt;&gt; 3) THEN
RETURN(?);
END_IF;
REPEAT i := 1 TO 3;
dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
END_REPEAT;
mag := sqrt(mag);
val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
RETURN(val);      </algorithm>
    </function>

    <function
      name="acyclic_curve_replica">
      <parameter
        name="rep">
        <typename
          name="curve_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="curve"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
(* Return TRUE if the parent is not of type curve_replica *)
IF (parent :=: rep) THEN
RETURN (FALSE);
(* Return FALSE if the parent is the same curve_replica, otherwise,
call function again with the parents own parent_curve. *)
ELSE
RETURN(acyclic_curve_replica(rep,
parent\curve_replica.parent_curve));
END_IF;      </algorithm>
    </function>

    <function
      name="acyclic_point_replica">
      <parameter
        name="rep">
        <typename
          name="point_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="point"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
(* Return TRUE if the parent is not of type point_replica *)
IF (parent :=: rep) THEN
RETURN (FALSE);
(* Return FALSE if the parent is the same point_replica, otherwise,
call function again with the parents own parent_pt. *)
ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
END_IF;      </algorithm>
    </function>

    <function
      name="acyclic_surface_replica">
      <parameter
        name="rep">
        <typename
          name="surface_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
RETURN (TRUE);
END_IF;
(* Return TRUE if the parent is not of type surface_replica *)
IF (parent :=: rep) THEN
RETURN (FALSE);
(* Return FALSE if the parent is the same surface_replica, otherwise,
call function again with the parents own parent_surface. *)
ELSE RETURN(acyclic_surface_replica(rep,
parent\surface_replica.parent_surface));
END_IF;      </algorithm>
    </function>

    <function
      name="associated_surface">
      <parameter
        name="arg">
        <typename
          name="pcurve_or_surface"/>
      </parameter>
      <typename
        name="surface"/>
      <algorithm>
LOCAL
surf : surface;
END_LOCAL;

IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
surf := arg.basis_surface;
ELSE
surf := arg;
END_IF;
RETURN(surf);      </algorithm>
    </function>

    <function
      name="base_axis">
      <parameter
        name="dim">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="axis1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis2">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis3">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
u : LIST [2:3] OF direction;
factor : REAL;
d1, d2 : direction;
END_LOCAL;

IF (dim = 3) THEN
d1 := NVL(normalise(axis3), dummy_gri || direction([0.0,0.0,1.0]));
d2 := first_proj_axis(d1,axis1);
u := [d2, second_proj_axis(d1,d2,axis2), d1];
ELSE
IF EXISTS(axis1) THEN
d1 := normalise(axis1);
u := [d1, orthogonal_complement(d1)];
IF EXISTS(axis2) THEN
factor := dot_product(axis2,u[2]);
IF (factor &lt; 0.0) THEN
u[2].direction_ratios[1] := -u[2].direction_ratios[1];
u[2].direction_ratios[2] := -u[2].direction_ratios[2];
END_IF;
END_IF;
ELSE
IF EXISTS(axis2) THEN
d1 := normalise(axis2);
u := [orthogonal_complement(d1), d1];
u[1].direction_ratios[1] := -u[1].direction_ratios[1];
u[1].direction_ratios[2] := -u[1].direction_ratios[2];
ELSE
u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
direction([0.0, 1.0])];
END_IF;
END_IF;
END_IF;
RETURN(u);      </algorithm>
    </function>

    <function
      name="build_2axes">
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="2"/>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
d : direction := NVL(normalise(ref_direction),
dummy_gri || direction([1.0,0.0]));
END_LOCAL;

RETURN([d, orthogonal_complement(d)]);      </algorithm>
    </function>

    <function
      name="build_axes">
      <parameter
        name="axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="3"
        upper="3"/>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
d1, d2 : direction;
END_LOCAL;
d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
d2 := first_proj_axis(d1, ref_direction);
RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);      </algorithm>
    </function>

    <function
      name="constraints_composite_curve_on_surface">
      <parameter
        name="c">
        <typename
          name="composite_curve_on_surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;

REPEAT k := 1 TO n_segments;
IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
(NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
(NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
RETURN (FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);      </algorithm>
    </function>

    <function
      name="constraints_param_b_spline">
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_cp">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="knot_mult">
        <aggregate
          type="LIST"/>
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="knots">
        <aggregate
          type="LIST"/>
        <typename
          name="parameter_value"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
k, sum : INTEGER;
END_LOCAL;

(* Find sum of knot multiplicities. *)
sum := knot_mult[1];

REPEAT i := 2 TO up_knots;
sum := sum + knot_mult[i];
END_REPEAT;

(* Check limits holding for all B-spline parametrisations *)
IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
(sum &lt;&gt; (degree + up_cp + 2)) THEN
result := FALSE;
RETURN(result);
END_IF;

k := knot_mult[1];

IF (k &lt; 1) OR (k &gt; degree + 1) THEN
result := FALSE;
RETURN(result);
END_IF;

REPEAT i := 2 TO up_knots;
IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
result := FALSE;
RETURN(result);
END_IF;

k := knot_mult[i];

IF (i &lt; up_knots) AND (k &gt; degree) THEN
result := FALSE;
RETURN(result);
END_IF;

IF (i = up_knots) AND (k &gt; degree + 1) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);      </algorithm>
    </function>

    <function
      name="constraints_rectangular_composite_surface">
      <parameter
        name="s">
        <typename
          name="rectangular_composite_surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
(* Check the surface types *)
REPEAT i := 1 TO s.n_u;
REPEAT j := 1 TO s.n_v;
IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
(s.segments[i][j].parent_surface)) OR
('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
(s.segments[i][j].parent_surface))) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;

(* Check the transition codes, omitting the last row or column *)
REPEAT i := 1 TO s.n_u-1;
REPEAT j := 1 TO s.n_v;
IF s.segments[i][j].u_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;

REPEAT i := 1 TO s.n_u;
REPEAT j := 1 TO s.n_v-1;
IF s.segments[i][j].v_transition = discontinuous THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(TRUE);      </algorithm>
    </function>

    <function
      name="cross_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>
LOCAL
mag : REAL;
res : direction;
v1,v2 : LIST[3:3] OF REAL;
result : vector;
END_LOCAL;

IF (NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
(NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
RETURN(?);
ELSE
BEGIN
v1 := normalise(arg1).direction_ratios;
v2 := normalise(arg2).direction_ratios;
res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
(v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
mag := 0.0;
REPEAT i := 1 TO 3;
mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(arg1, 0.0);
END_IF;
RETURN(result);
END;
END_IF;      </algorithm>
    </function>

    <function
      name="curve_weights_positive">
      <parameter
        name="b">
        <typename
          name="rational_b_spline_curve"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 0 TO b.upper_index_on_control_points;
IF b.weights[i] &lt;= 0.0 THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
RETURN(result);      </algorithm>
    </function>

    <function
      name="default_b_spline_curve_weights">
      <parameter
        name="up_cp">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"
        lower="0"
        upper="up_cp"/>
      <builtintype
        type="REAL"/>
      <algorithm>
RETURN([1:up_cp + 1]);      </algorithm>
    </function>

    <function
      name="default_b_spline_surface_weights">
      <parameter
        name="u_upper">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="v_upper">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"
        lower="0"
        upper="u_upper"/>
      <builtintype
        type="REAL"/>
      <algorithm>
RETURN([[1:v_upper + 1]:u_upper +1]);      </algorithm>
    </function>

    <function
      name="default_b_spline_knot_mult">
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="uniform">
        <typename
          name="knot_type"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="?"/>
      <builtintype
        type="INTEGER"/>
      <algorithm>
LOCAL
knot_mult : LIST [1:up_knots] OF INTEGER;
END_LOCAL;

IF uniform = uniform_knots THEN
knot_mult := [1:up_knots];
ELSE
IF uniform = quasi_uniform_knots THEN
knot_mult := [1:up_knots];
knot_mult[1] := degree + 1;
knot_mult[up_knots] := degree + 1;
ELSE
IF uniform = piecewise_bezier_knots THEN
knot_mult := [degree:up_knots];
knot_mult[1] := degree + 1;
knot_mult[up_knots] := degree + 1;
ELSE
knot_mult := [0:up_knots];
END_IF;
END_IF;
END_IF;
RETURN(knot_mult);      </algorithm>
    </function>

    <function
      name="default_b_spline_knots">
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="uniform">
        <typename
          name="knot_type"/>
      </parameter>
      <aggregate
        type="LIST"
        lower="2"
        upper="?"/>
      <typename
        name="parameter_value"/>
      <algorithm>
LOCAL
knots : LIST [1:up_knots] OF parameter_value := [0:up_knots];
ishift : INTEGER := 1;
END_LOCAL;

IF (uniform = uniform_knots) THEN
ishift := degree + 1;
END_if;
IF (uniform = uniform_knots) OR
(uniform = quasi_uniform_knots) OR
(uniform = piecewise_bezier_knots) THEN

REPEAT i := 1 TO up_knots;
knots[i] := i - ishift;
END_REPEAT;
END_IF;
RETURN(knots);      </algorithm>
    </function>

    <function
      name="dimension_of">
      <parameter
        name="item">
        <typename
          name="geometric_representation_item"/>
      </parameter>
      <typename
        name="dimension_count"/>
      <algorithm>
LOCAL
x : SET OF representation;
y : representation_context;
dim : dimension_count;
END_LOCAL;
(* For cartesian_point, direction, or vector dimension is determined by *)
(* counting components. *)
IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
dim := SIZEOF(item\cartesian_point.coordinates);
RETURN(dim);
END_IF;
IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
dim := SIZEOF(item\direction.direction_ratios);
RETURN(dim);
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
RETURN(dim);
END_IF;
(* For all other types of geometric_representation_item dim is obtained *)
(* via context. *)
(* Find the set of representation in which the item is used. *)

x := using_representations(item);

(* Determines the dimension_count of the *)
(* geometric_representation_context. Note that the *)
(* RULE compatible_dimension ensures that the context_of_items *)
(* is of type geometric_representation_context and has *)
(* the same dimension_count for all values of x. *)
(* The SET x is non-empty since this is required by WR1 of *)
(* representation_item. *)
y := x[1].context_of_items;
dim := y\geometric_representation_context.coordinate_space_dimension;
RETURN (dim);      </algorithm>
    </function>

    <function
      name="dot_product">
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <builtintype
        type="REAL"/>
      <algorithm>
LOCAL
scalar : REAL;
vec1, vec2: direction;
ndim : INTEGER;
END_LOCAL;

IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
scalar := ?;
(* When function is called with invalid data an indeterminate result
is returned *)
ELSE
IF (arg1.dim &lt;&gt; arg2.dim) THEN
scalar := ?;
(* When function is called with invalid data an indeterminate result
is returned *)
ELSE
BEGIN
vec1 := normalise(arg1);
vec2 := normalise(arg2);
ndim := arg1.dim;
scalar := 0.0;
REPEAT i := 1 TO ndim;
scalar := scalar +
vec1.direction_ratios[i]*vec2.direction_ratios[i];
END_REPEAT;
END;
END_IF;
END_IF;
RETURN (scalar);      </algorithm>
    </function>

    <function
      name="first_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
x_axis : direction;
v : direction;
z : direction;
x_vec : vector;
END_LOCAL;

IF (NOT EXISTS(z_axis)) THEN
RETURN (?) ;
ELSE
z := normalise(z_axis);
IF NOT EXISTS(arg) THEN
IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
(z.direction_ratios &lt;&gt; [-1.0,0.0,0.0])) THEN
v := dummy_gri || direction([1.0,0.0,0.0]);
ELSE
v := dummy_gri || direction([0.0,1.0,0.0]);
END_IF;
ELSE
IF (arg.dim &lt;&gt; 3) THEN
RETURN (?) ;
END_IF;
IF ((cross_product(arg,z).magnitude) = 0.0) THEN
RETURN (?);
ELSE
v := normalise(arg);
END_IF;
END_IF;
x_vec := scalar_times_vector(dot_product(v, z), z);
x_axis := vector_difference(v, x_vec).orientation;
x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);      </algorithm>
    </function>

    <function
      name="get_basis_surface">
      <parameter
        name="c">
        <typename
          name="curve_on_surface"/>
      </parameter>
      <aggregate
        type="SET"
        lower="0"
        upper="2"/>
      <typename
        name="surface"/>
      <algorithm>
LOCAL
surfs : SET[0:2] OF surface;
n : INTEGER;
END_LOCAL;
surfs := [];
IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
surfs := [c\pcurve.basis_surface];
ELSE
IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
n := SIZEOF(c\surface_curve.associated_geometry);
REPEAT i := 1 TO n;
surfs := surfs +
associated_surface(c\surface_curve.associated_geometry[i]);
END_REPEAT;
END_IF;
END_IF;
IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
(* For a composite_curve_on_surface the basis_surface is the intersection
of the basis_surfaces of all the segments. *)
n := SIZEOF(c\composite_curve.segments);
surfs := get_basis_surface(
c\composite_curve.segments[1].parent_curve);
IF n &gt; 1 THEN
REPEAT i := 2 TO n;
surfs := surfs * get_basis_surface(
c\composite_curve.segments[i].parent_curve);
END_REPEAT;
END_IF;

END_IF;
RETURN(surfs);      </algorithm>
    </function>

    <function
      name="list_to_array">
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="0"
          upper="?"/>
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="low">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"
        lower="low"
        upper="u"/>
      <builtintype
        type="GENERIC"/>
      <algorithm>
LOCAL
n : INTEGER;
res : ARRAY [low:u] OF GENERIC : T;
END_LOCAL;

n := SIZEOF(lis);
IF (n &lt;&gt; (u-low +1)) THEN
RETURN(?);
ELSE
res := [lis[1] : n];
REPEAT i := 2 TO n;
res[low+i-1] := lis[i];
END_REPEAT;
RETURN(res);
END_IF;      </algorithm>
    </function>

    <function
      name="make_array_of_array">
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="low1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"
        lower="low1"
        upper="u1"/>
      <builtintype
        type="GENERIC"/>
      <algorithm>
LOCAL
res : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
END_LOCAL;

(* Check input dimensions for consistency *)
IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
RETURN (?);
END_IF;
IF (u2 - low2 + 1) &lt;&gt; SIZEOF(lis[1]) THEN
RETURN (?) ;
END_IF;
(* Initialise res with values from lis[1] *)
res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
REPEAT i := 2 TO HIINDEX(lis);
IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
RETURN (?);
END_IF;
res[low1+i-1] := list_to_array(lis[i], low2, u2);
END_REPEAT;

RETURN (res);      </algorithm>
    </function>

    <function
      name="make_array_of_array_of_array">
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="low1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low3">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u3">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <aggregate
        type="ARRAY"
        lower="low1"
        upper="u1"/>
      <builtintype
        type="GENERIC"/>
      <algorithm>
LOCAL
res : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
ARRAY[low3:u3] OF GENERIC : T;
END_LOCAL;

(* Check input dimensions for consistency *)
IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
RETURN (?);
END_IF;
IF (u2-low2+1) &lt;&gt; SIZEOF(lis[1]) THEN
RETURN (?);
END_IF;
(* Initialise res with values from lis[1] *)
res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
REPEAT i := 2 TO HIINDEX(lis);
IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
RETURN (?);
END_IF;
res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
END_REPEAT;
RETURN (res);      </algorithm>
    </function>

    <function
      name="normalise">
      <parameter
        name="arg">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector_or_direction"/>
      <algorithm>
LOCAL
ndim : INTEGER;
v : direction;
result : vector_or_direction;
vec : vector;
mag : REAL;
END_LOCAL;

IF NOT EXISTS (arg) THEN
result := ?;
(* When function is called with invalid data a NULL result is returned *)
ELSE
ndim := arg.dim;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
BEGIN
v := dummy_gri || direction(arg.orientation.direction_ratios);
IF arg.magnitude = 0.0 THEN
RETURN(?);
ELSE
vec := dummy_gri || vector (v, 1.0);
END_IF;
END;
ELSE
v := dummy_gri || direction (arg.direction_ratios);
END_IF;
mag := 0.0;
REPEAT i := 1 TO ndim;
mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
END_REPEAT;
IF mag &gt; 0.0 THEN
mag := SQRT(mag);
REPEAT i := 1 TO ndim;
v.direction_ratios[i] := v.direction_ratios[i]/mag;
END_REPEAT;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
vec.orientation := v;
result := vec;
ELSE
result := v;
END_IF;
ELSE
RETURN(?);
END_IF;
END_IF;
RETURN (result);      </algorithm>
    </function>

    <function
      name="orthogonal_complement">
      <parameter
        name="vec">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
result : direction ;
END_LOCAL;

IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
RETURN(?);
ELSE
result := dummy_gri || direction([-vec.direction_ratios[2],
vec.direction_ratios[1]]);
RETURN(result);
END_IF;      </algorithm>
    </function>

    <function
      name="same_side">
      <parameter
        name="plane_pts">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="test_points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
val1, val2 : REAL;
n : INTEGER;
END_LOCAL;

IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
RETURN(?);
END_IF;
n := SIZEOF(test_points);
val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
test_points[1]);
REPEAT i := 2 TO n;
val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
test_points[i]);
IF (val1*val2 &lt;= 0.0) THEN
RETURN(FALSE);
END_IF;
END_REPEAT;
RETURN(TRUE);      </algorithm>
    </function>

    <function
      name="scalar_times_vector">
      <parameter
        name="scalar">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="vec">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>
LOCAL
v : direction;
mag : REAL;
result : vector;
END_LOCAL;

IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
RETURN (?) ;
ELSE
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
v := dummy_gri || direction(vec.orientation.direction_ratios);
mag := scalar * vec.magnitude;
ELSE
v := dummy_gri || direction(vec.direction_ratios);
mag := scalar;
END_IF;
IF (mag &lt; 0.0) THEN
REPEAT i := 1 TO SIZEOF(v.direction_ratios);
v.direction_ratios[i] := -v.direction_ratios[i];
END_REPEAT;
mag := -mag;
END_IF;
result := dummy_gri || vector(normalise(v), mag);
END_IF;
RETURN (result);      </algorithm>
    </function>

    <function
      name="second_proj_axis">
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="x_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <typename
        name="direction"/>
      <algorithm>
LOCAL
y_axis : vector;
v : direction;
temp : vector;
END_LOCAL;

IF NOT EXISTS(arg) THEN
v := dummy_gri || direction([0.0,1.0,0.0]);
ELSE
v := arg;
END_IF;

temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
y_axis := vector_difference(v, temp);
temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
y_axis := vector_difference(y_axis, temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);      </algorithm>
    </function>

    <function
      name="surface_weights_positive">
      <parameter
        name="b">
        <typename
          name="rational_b_spline_surface"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 0 TO b.u_upper;
REPEAT j := 0 TO b.v_upper;
IF (b.weights[i][j] &lt;= 0.0) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
RETURN(result);      </algorithm>
    </function>

    <function
      name="vector_difference">
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>
LOCAL
result : vector;
res, vec1, vec2 : direction;
mag, mag1, mag2 : REAL;
ndim : INTEGER;
END_LOCAL;

IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
RETURN (?) ;
ELSE
BEGIN
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1.0;
vec1 := arg1;
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1.0;
vec2 := arg2;
END_IF;
vec1 := normalise (vec1);
vec2 := normalise (vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0.0;
res := dummy_gri || direction(vec1.direction_ratios);
REPEAT i := 1 TO ndim;
res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
mag2*vec2.direction_ratios[i];
mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(vec1, 0.0);
END_IF;
END;
END_IF;
RETURN (result);      </algorithm>
    </function>

    <function
      name="vector_sum">
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <typename
        name="vector"/>
      <algorithm>
LOCAL
result : vector;
res, vec1, vec2 : direction;
mag, mag1, mag2 : REAL;
ndim : INTEGER;
END_LOCAL;

IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
THEN
RETURN (?) ;

ELSE
BEGIN
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
mag1 := arg1.magnitude;
vec1 := arg1.orientation;
ELSE
mag1 := 1.0;
vec1 := arg1;
END_IF;
IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
mag2 := arg2.magnitude;
vec2 := arg2.orientation;
ELSE
mag2 := 1.0;
vec2 := arg2;
END_IF;
vec1 := normalise (vec1);
vec2 := normalise (vec2);
ndim := SIZEOF(vec1.direction_ratios);
mag := 0.0;
res := dummy_gri || direction(vec1.direction_ratios);
REPEAT i := 1 TO ndim;
res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
mag2*vec2.direction_ratios[i];
mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
END_REPEAT;
IF (mag &gt; 0.0) THEN
result := dummy_gri || vector(res, SQRT(mag));
ELSE
result := dummy_gri || vector(vec1, 0.0);
END_IF;
END;
END_IF;
RETURN (result);      </algorithm>
    </function>

    <function
      name="volume_weights_positive">
      <parameter
        name="b">
        <typename
          name="rational_b_spline_volume"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
LOCAL
result : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 0 TO b.u_upper;
REPEAT j := 0 TO b.v_upper;
REPEAT k := 0 TO b.w_upper;
IF (b.weights[i][j][k] &lt;= 0.0) THEN
result := FALSE;
RETURN(result);
END_IF;
END_REPEAT;
END_REPEAT;
END_REPEAT;
RETURN(result);      </algorithm>
    </function>

  </schema>
</express>
