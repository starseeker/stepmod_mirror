<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date: 2012/07/31 13:43:35 $" rcs.revision="$Revision: 1.12 $" reference="ISO 10303-42">
   <application name="JSDAI" owner="LKSoft" source="geometry_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="geometry_schema">
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="definitional_representation"/>
         <interfaced.item name="founded_item"/>
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_in_context"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_context"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="using_representations"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="global_unit_assigned_context"/>
         <interfaced.item name="length_measure"/>
         <interfaced.item name="parameter_value"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="plane_angle_unit"/>
         <interfaced.item name="positive_length_measure"/>
         <interfaced.item name="positive_plane_angle_measure"/>
      </interface>
      <interface kind="reference" schema="topology_schema">
         <interfaced.item name="edge_curve"/>
         <interfaced.item name="face_surface"/>
         <interfaced.item name="poly_loop"/>
         <interfaced.item name="vertex_point"/>
      </interface>
      <interface kind="reference" schema="geometric_model_schema">
         <interfaced.item name="block"/>
         <interfaced.item name="boolean_result"/>
         <interfaced.item name="cyclide_segment_solid"/>
         <interfaced.item name="eccentric_cone"/>
         <interfaced.item name="edge_based_wireframe_model"/>
         <interfaced.item name="ellipsoid"/>
         <interfaced.item name="face_based_surface_model"/>
         <interfaced.item name="faceted_primitive"/>
         <interfaced.item name="geometric_set"/>
         <interfaced.item name="half_space_solid"/>
         <interfaced.item name="primitive_2d"/>
         <interfaced.item name="rectangular_pyramid"/>
         <interfaced.item name="right_angular_wedge"/>
         <interfaced.item name="right_circular_cone"/>
         <interfaced.item name="right_circular_cylinder"/>
         <interfaced.item name="shell_based_surface_model"/>
         <interfaced.item name="shell_based_wireframe_model"/>
         <interfaced.item name="solid_model"/>
         <interfaced.item name="sphere"/>
         <interfaced.item name="tessellated_item"/>
         <interfaced.item name="torus"/>
      </interface>
      <constant expression="representation_item('')||&#10;                                   geometric_representation_item()" name="dummy_gri">
         <typename name="geometric_representation_item"/>
      </constant>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt; 0" label="WR1"/>
      </type>
      <type name="extent_enumeration">
         <enumeration items="invalid zero finite_non_zero infinite"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="surface_boundary">
         <select selectitems="boundary_curve degenerate_pcurve"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      
      <entity name="geometric_representation_context" supertypes="representation_context">
                       <explicit name="coordinate_space_dimension">
                          <typename name="dimension_count"/>
                       </explicit>
              </entity>
                  <entity name="geometric_representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set, tessellated_item)" supertypes="representation_item">
                       <derived expression="dimension_of(SELF)" name="dim">
                          <typename name="dimension_count"/>
                       </derived>
                       <where expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |&#10;      NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;      TYPEOF (using_rep.context_of_items)))) = 0" label="WR1"/>
              </entity>
                <entity name="point" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve)" supertypes="geometric_representation_item"/>
      	   <entity name="cartesian_point" super.expression="ONEOF (cylindrical_point, polar_point, spherical_point)" supertypes="point">
      	               <explicit name="coordinates">
      	                  <aggregate lower="1" type="LIST" upper="3"/>
      	                  <typename name="length_measure"/>
      	               </explicit>
	            </entity>
       <entity name="cylindrical_point" supertypes="cartesian_point">
                     <explicit name="r">
                        <typename name="length_measure"/>
                     </explicit>
                     <explicit name="theta">
                        <typename name="plane_angle_measure"/>
                     </explicit>
                     <explicit name="z">
                        <typename name="length_measure"/>
                     </explicit>
                     <derived expression="[r*cos(theta), r*sin(theta), z]" name="coordinates">
                        <aggregate lower="1" type="LIST" upper="3"/>
                        <typename name="length_measure"/>
                        <redeclaration entity-ref="cartesian_point"/>
                     </derived>
                     <where expression="r &gt;= 0.0" label="WR1"/>
                     <where  label="IP1"/>
               </entity>
         
         <entity name="spherical_point" supertypes="cartesian_point">
                    <explicit name="r">
                       <typename name="length_measure"/>
                    </explicit>
                    <explicit name="theta">
                       <typename name="plane_angle_measure"/>
                    </explicit>
                    <explicit name="phi">
                       <typename name="plane_angle_measure"/>
                    </explicit>
                    <derived expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]" name="coordinates">
                       <aggregate lower="1" type="LIST" upper="3"/>
                       <typename name="length_measure"/>
                       <redeclaration entity-ref="cartesian_point"/>
                    </derived>
                    <where expression="r &gt;= 0.0" label="WR1"/>
                    <where  label="IP1"/>
                    <where  label="IP2"/>
              </entity>
              
       <entity name="polar_point" supertypes="cartesian_point">
                 <explicit name="r">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="theta">
                    <typename name="plane_angle_measure"/>
                 </explicit>
                 <derived expression="[r*cos(theta), r*sin(theta)]" name="coordinates">
                    <aggregate lower="1" type="LIST" upper="3"/>
                    <typename name="length_measure"/>
                    <redeclaration entity-ref="cartesian_point"/>
                 </derived>
                 <where expression="r &gt;= 0.0" label="WR1"/>
                <where  label="IP1"/>
            </entity>
             
       <entity name="point_on_curve" supertypes="point">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="point_parameter">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where  label="IP1"/>
            </entity>
              
            <entity name="point_on_surface" supertypes="point">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="point_parameter_u">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="point_parameter_v">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where  label="IP1"/>
            </entity>
        
        <entity name="point_in_volume" supertypes="point">
                   <explicit name="basis_volume">
                      <typename name="volume"/>
                   </explicit>
                   <explicit name="point_parameter_u">
                      <typename name="parameter_value"/>
                   </explicit>
                   <explicit name="point_parameter_v">
                      <typename name="parameter_value"/>
                   </explicit>
                   <explicit name="point_parameter_w">
                      <typename name="parameter_value"/>
                   </explicit>
                  <where  label="IP1"/>
             </entity>
              
        <entity name="point_replica" supertypes="point">
                 <explicit name="parent_pt">
                    <typename name="point"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator"/>
                 </explicit>
                 <where expression="transformation.dim = parent_pt.dim" label="WR1"/>
                 <where expression="acyclic_point_replica (SELF,parent_pt)" label="WR2"/>
              </entity>
              
      <entity name="degenerate_pcurve" supertypes="point">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="reference_to_curve">
                    <typename name="definitional_representation"/>
                 </explicit>
                 <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
                 <where expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
                 <where expression="reference_to_curve\representation.&#10;                   items[1]\geometric_representation_item.dim =2" label="WR3"/>
                 <where  label="IP1"/>
              </entity>           
      
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
                 <explicit name="equivalent_point">
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
       <entity name="direction" supertypes="geometric_representation_item">
                 <explicit name="direction_ratios">
                    <aggregate lower="2" type="LIST" upper="3"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <where expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0" label="WR1"/>
              </entity>
              
             <entity name="vector" supertypes="geometric_representation_item">
                 <explicit name="orientation">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="magnitude">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="magnitude &gt;= 0.0" label="WR1"/>
              </entity>
          
      <entity name="placement" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)" supertypes="geometric_representation_item">
                 <explicit name="location">
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
      <entity name="axis1_placement" supertypes="placement">
                 <explicit name="axis" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="NVL(normalise(axis), dummy_gri ||&#10;                                 direction([0.0,0.0,1.0]))" name="z">
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim  = 3" label="WR1"/>
              </entity>
              
      <entity name="axis2_placement_2d" supertypes="placement">
                 <explicit name="ref_direction" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="build_2axes(ref_direction)" name="p">
                    <aggregate lower="2" type="LIST" upper="2"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
              </entity>
              
        <entity name="axis2_placement_3d" supertypes="placement">
                 <explicit name="axis" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="ref_direction" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="build_axes(axis,ref_direction)" name="p">
                    <aggregate lower="3" type="LIST" upper="3"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\placement.location.dim = 3" label="WR1"/>
                 <where expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)" label="WR2"/>
                 <where expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)" label="WR3"/>
                 <where expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR&#10;          (cross_product(axis,ref_direction).magnitude &gt; 0.0)" label="WR4"/>
              </entity> 
              
         <entity name="cartesian_transformation_operator" super.expression="ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d)" supertypes="geometric_representation_item functionally_defined_transformation">
                 <explicit name="axis1" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="axis2" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <explicit name="local_origin">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="scale" optional="YES">
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="NVL(scale, 1.0)" name="scl">
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="scl &gt; 0.0" label="WR1"/>
              </entity>
           
        <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
                 <explicit name="axis3" optional="YES">
                    <typename name="direction"/>
                 </explicit>
                 <derived expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,&#10;                        SELF\cartesian_transformation_operator.axis2,axis3)" name="u">
                    <aggregate lower="3" type="LIST" upper="3"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
              </entity> 
              
          <entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
                 <derived expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,&#10;                   SELF\cartesian_transformation_operator.axis2,?)" name="u">
                    <aggregate lower="2" type="LIST" upper="2"/>
                    <typename name="direction"/>
                 </derived>
                 <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
              </entity> 
              
      <entity name="curve" super.expression="ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica)" supertypes="geometric_representation_item">
                   <where  label="IP1"/>
                  <where  label="IP2"/>
          </entity>
       <entity name="line" supertypes="curve">
                 <explicit name="pnt">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="dir">
                    <typename name="vector"/>
                 </explicit>
                 <where expression="dir.dim  = pnt.dim" label="WR1"/>
              </entity>
       
       <entity name="conic" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)" supertypes="curve">
                  <explicit name="position">
                     <typename name="axis2_placement"/>
                  </explicit>
              </entity>
              
       <entity name="circle" supertypes="conic">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="ellipse" supertypes="conic">
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="hyperbola" supertypes="conic">
                 <explicit name="semi_axis">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_imag_axis">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="parabola" supertypes="conic">
                 <explicit name="focal_dist">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="focal_dist &lt;&gt; 0.0" label="WR1"/>
              </entity>
              
        <entity name="clothoid" supertypes="curve">
                 <explicit name="position">
                    <typename name="axis2_placement"/>
                 </explicit>
                 <explicit name="clothoid_constant">
                    <typename name="length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="circular_involute" supertypes="curve">
                 <explicit name="position">
                    <typename name="axis2_placement"/>
                 </explicit>
                 <explicit name="base_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="bounded_curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve)" supertypes="curve">
                        <where  label="IP1"/>
      	          <where  label="IP2"/>
          </entity>
             
      <entity name="polyline" supertypes="bounded_curve">
                 <explicit name="points">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
              </entity>
              
       <entity name="b_spline_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve" supertypes="bounded_curve">
                 <explicit name="degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="curve_form">
                    <typename name="b_spline_curve_form"/>
                 </explicit>
                 <explicit name="closed_curve">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="(SIZEOF(control_points_list) - 1)" name="upper_index_on_control_points">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="list_to_array(control_points_list,0,&#10;                                             upper_index_on_control_points)" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="upper_index_on_control_points"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))" label="WR1"/>
              </entity>
              
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
                 <explicit name="knot_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="knot_spec">
                    <typename name="knot_type"/>
                 </explicit>
                 <derived expression="SIZEOF(knots)" name="upper_index_on_knots">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(degree, upper_index_on_knots,&#10;                               upper_index_on_control_points,&#10;                               knot_multiplicities, knots)" label="WR1"/>
                 <where expression="SIZEOF(knot_multiplicities) = upper_index_on_knots" label="WR2"/>
              </entity>
              
       <entity name="uniform_curve" supertypes="b_spline_curve"/>
                     
             <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      
         <entity name="bezier_curve" supertypes="b_spline_curve"/>
          
       <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="list_to_array(weights_data,0,&#10;                                      upper_index_on_control_points)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="upper_index_on_control_points"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.&#10;                                           control_points_list)" label="WR1"/>
                 <where expression="curve_weights_positive(SELF)" label="WR2"/>
              </entity>
           
        <entity name="trimmed_curve" supertypes="bounded_curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="trim_1">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="trimming_select"/>
                 </explicit>
                 <explicit name="trim_2">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="trimming_select"/>
                 </explicit>
                 <explicit name="sense_agreement">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="master_representation">
                    <typename name="trimming_preference"/>
                 </explicit>
                 <where expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))" label="WR1"/>
                 <where expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))" label="WR2"/>
                    <where  label="IP1"/>
                    <where  label="IP2"/>
                    <where  label="IP3"/>
                    <where  label="IP4"/>
                    <where  label="IP5"/>
        </entity>
           
              <entity name="composite_curve" supertypes="bounded_curve">
                 <explicit name="segments">
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <typename name="composite_curve_segment"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="SIZEOF(segments)" name="n_segments">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="segments[n_segments].transition &lt;&gt; discontinuous" name="closed_curve">
                    <builtintype type="LOGICAL"/>
                 </derived>
                 <where expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |&#10;                temp.transition = discontinuous)) = 1)) OR&#10;            ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | &#10;                temp.transition = discontinuous)) = 0))" label="WR1"/>
              </entity>
              
              <entity name="composite_curve_segment" supertypes="founded_item">
                 <explicit name="transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="same_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="parent_curve">
                    <typename name="curve"/>
                 </explicit>
                 <inverse attribute="segments" entity="composite_curve" name="using_curves">
                    <inverse.aggregate lower="1" type="BAG" upper="?"/>
                 </inverse>
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))" label="WR1"/>
              </entity>
                    
       <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
                 <explicit name="param_length">
                    <typename name="parameter_value"/>
                 </explicit>
                 <where expression="param_length &gt; 0.0" label="WR1"/>
              </entity>
              
         <entity name="pcurve" supertypes="curve">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="reference_to_curve">
                    <typename name="definitional_representation"/>
                 </explicit>
                 <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
                 <where expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
                 <where expression="reference_to_curve\representation.items[1]\&#10;                               geometric_representation_item.dim =2" label="WR3"/>
              </entity>
              
       <entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN&#10;                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]))" label="WR1"/>
              </entity>
              
        <entity name="surface_curve" super.expression="ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve" supertypes="curve">
                 <explicit name="curve_3d">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="associated_geometry">
                    <aggregate lower="1" type="LIST" upper="2"/>
                    <typename name="pcurve_or_surface"/>
                 </explicit>
                 <explicit name="master_representation">
                    <typename name="preferred_surface_curve_representation"/>
                 </explicit>
                 <derived expression="get_basis_surface(SELF)" name="basis_surface">
                    <aggregate lower="1" type="SET" upper="2"/>
                    <typename name="surface"/>
                 </derived>
                 <where expression="curve_3d.dim = 3" label="WR1"/>
                 <where expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR&#10;                        (master_representation &lt;&gt; pcurve_s1)" label="WR2"/>
                 <where expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR&#10;                        (master_representation &lt;&gt; pcurve_s2)" label="WR3"/>
                 <where expression="NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d))" label="WR4"/>
                   <where  label="IP1"/>
                   <where  label="IP2"/>
            </entity>      
                     
        <entity name="intersection_curve" supertypes="surface_curve">
                 <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
                 <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) &lt;&gt;&#10;             associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
              </entity>
              
       <entity name="seam_curve" supertypes="surface_curve">
                 <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
                 <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) =&#10;           associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
                 <where expression="'GEOMETRY_SCHEMA.PCURVE' IN&#10;           TYPEOF(SELF\surface_curve.associated_geometry[1])" label="WR3"/>
                 <where expression="'GEOMETRY_SCHEMA.PCURVE' IN&#10;            TYPEOF(SELF\surface_curve.associated_geometry[2])" label="WR4"/>
              </entity>
              
      <entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
                 <where expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN&#10;             TYPEOF(SELF\surface_curve.curve_3d))" label="WR1"/>
              </entity>
              
      <entity name="composite_curve_on_surface" super.expression="boundary_curve" supertypes="composite_curve">
                 <derived expression="get_basis_surface(SELF)" name="basis_surface">
                    <aggregate lower="0" type="SET" upper="2"/>
                    <typename name="surface"/>
                 </derived>
                 <where expression="SIZEOF(basis_surface) &gt; 0" label="WR1"/>
                 <where expression="constraints_composite_curve_on_surface(SELF)" label="WR2"/>
                  <where  label="IP1"/>
            </entity>
              
      <entity name="offset_curve_2d" supertypes="curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <where expression="basis_curve.dim = 2" label="WR1"/>
              </entity>
             
        <entity name="offset_curve_3d" supertypes="curve">
                 <explicit name="basis_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="ref_direction">
                    <typename name="direction"/>
                 </explicit>
                 <where expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)" label="WR1"/>
                   <where  label="IP1"/>
            </entity>
              
       <entity name="curve_replica" supertypes="curve">
                 <explicit name="parent_curve">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator"/>
                 </explicit>
                 <where expression="transformation.dim = parent_curve.dim" label="WR1"/>
                 <where expression="acyclic_curve_replica (SELF, parent_curve)" label="WR2"/>
              </entity>       
       
       <entity name="surface" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)" supertypes="geometric_representation_item">
                <where  label="IP1"/>
                <where  label="IP2"/>
            </entity>
       
       <entity name="elementary_surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)" supertypes="surface">
                  <explicit name="position">
                     <typename name="axis2_placement_3d"/>
                  </explicit>
              </entity>
              
       <entity name="plane" supertypes="elementary_surface"/>
                    
      <entity name="cylindrical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="conical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="semi_angle">
                    <typename name="plane_angle_measure"/>
                 </explicit>
                 <where expression="radius &gt;= 0.0" label="WR1"/>
              </entity>
          
      <entity name="spherical_surface" supertypes="elementary_surface">
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
          
       <entity name="toroidal_surface" supertypes="elementary_surface">
                 <explicit name="major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
          
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
                 <explicit name="select_outer">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="major_radius &lt;   minor_radius" label="WR1"/>
              </entity>
          
       <entity name="dupin_cyclide_surface" supertypes="elementary_surface">
                 <explicit name="generalised_major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="generalised_minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="skewness">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="skewness &gt;= 0.0" label="WR1"/>
              </entity>
          
       <entity name="swept_surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface)" supertypes="surface">
                 <explicit name="swept_curve">
                    <typename name="curve"/>
                 </explicit>
              </entity>
          
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
                 <explicit name="extrusion_axis">
                    <typename name="vector"/>
                 </explicit>
                    <where  label="IP1"/>
            </entity>
              
       <entity name="surface_of_revolution" supertypes="swept_surface">
                 <explicit name="axis_position">
                    <typename name="axis1_placement"/>
                 </explicit>
                 <derived expression="representation_item('')||&#10;                     geometric_representation_item()|| curve()||&#10;                     line(axis_position.location, representation_item('')||&#10;                     geometric_representation_item()||&#10;                     vector(axis_position.z, 1.0))" name="axis_line">
                    <typename name="line"/>
                 </derived>
                  <where  label="IP1"/>
                  <where  label="IP2"/>
           </entity>
              
      <entity name="surface_curve_swept_surface" supertypes="swept_surface">
                 <explicit name="directrix">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="reference_surface">
                    <typename name="surface"/>
                 </explicit>
                 <where expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR&#10;          (reference_surface IN (directrix\surface_curve.basis_surface))" label="WR1"/>
                  <where  label="IP1"/>
                  <where  label="IP2"/>
            </entity>
              
      <entity name="fixed_reference_swept_surface" supertypes="swept_surface">
                 <explicit name="directrix">
                    <typename name="curve"/>
                 </explicit>
                 <explicit name="fixed_reference">
                    <typename name="direction"/>
                 </explicit>
                 <where  label="IP1"/>
                 <where  label="IP2"/>
             </entity>
              
      <entity name="bounded_surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)" supertypes="surface">
                  <where  label="IP1"/>
                 <where  label="IP2"/>
             </entity>
             
      <entity name="b_spline_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface" supertypes="bounded_surface">
                 <explicit name="u_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="surface_form">
                    <typename name="b_spline_surface_form"/>
                 </explicit>
                 <explicit name="u_closed">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="v_closed">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
                 <derived expression="SIZEOF(control_points_list) - 1" name="u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1]) - 1" name="v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="make_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper)" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))" label="WR1"/>
              </entity>
              
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
                 <explicit name="u_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="u_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="knot_spec">
                    <typename name="knot_type"/>
                 </explicit>
                 <derived expression="SIZEOF(u_knots)" name="knot_u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(v_knots)" name="knot_v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;                   knot_u_upper, SELF\b_spline_surface.u_upper,&#10;                               u_multiplicities, u_knots)" label="WR1"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;                   knot_v_upper, SELF\b_spline_surface.v_upper,&#10;                               v_multiplicities, v_knots)" label="WR2"/>
                 <where expression="SIZEOF(u_multiplicities) = knot_u_upper" label="WR3"/>
                 <where expression="SIZEOF(v_multiplicities) = knot_v_upper" label="WR4"/>
              </entity>
              
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
             
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
            
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="(SIZEOF(weights_data) =&#10;                     SIZEOF(SELF\b_spline_surface.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))" label="WR1"/>
                 <where expression="surface_weights_positive(SELF)" label="WR2"/>
              </entity>
              
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="u1">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="u2">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v1">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v2">
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="usense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="vsense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="u1 &lt;&gt; u2" label="WR1"/>
                 <where expression="v1 &lt;&gt; v2" label="WR2"/>
                 <where expression="(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))&#10;       AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR&#10;      ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))&#10;          OR (usense = (u2 &gt; u1))" label="WR3"/>
                 <where expression="(('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))&#10;          OR&#10;         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))&#10;          OR (vsense = (v2 &gt; v1))" label="WR4"/>
                   <where  label="IP1"/>
             </entity>
              
       <entity name="curve_bounded_surface" supertypes="bounded_surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="boundaries">
                    <aggregate lower="1" type="SET" upper="?"/>
                    <typename name="boundary_curve"/>
                 </explicit>
                 <explicit name="implicit_outer">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <where expression="(NOT implicit_outer) OR&#10;         (SIZEOF (QUERY (temp &lt;* boundaries |&#10;           'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)" label="WR1"/>
                 <where expression="(NOT(implicit_outer)) OR&#10;                ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface))" label="WR2"/>
                 <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;                  'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN&#10;                                         TYPEOF(temp))) &lt;= 1" label="WR3"/>
                 <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;            (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;&#10;                                         SELF.basis_surface))) = 0" label="WR4"/>
                   <where  label="IP1"/>
                   <where  label="IP2"/>
                   <where  label="IP3"/>
              </entity>
              
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
                 <where expression="SELF\composite_curve.closed_curve" label="WR1"/>
              </entity>
              
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
              
              
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
                 <explicit name="segments">
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <aggregate lower="1" type="LIST" upper="?"/>
                    <typename name="surface_patch"/>
                 </explicit>
                 <derived expression="SIZEOF(segments)" name="n_u">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(segments[1])" name="n_v">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0" label="WR1"/>
                 <where expression="constraints_rectangular_composite_surface(SELF)" label="WR2"/>
                   <where  label="IP1"/>
             </entity>
              
      <entity name="surface_patch" supertypes="founded_item">
                 <explicit name="parent_surface">
                    <typename name="bounded_surface"/>
                 </explicit>
                 <explicit name="u_transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="v_transition">
                    <typename name="transition_code"/>
                 </explicit>
                 <explicit name="u_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <explicit name="v_sense">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
                 <inverse attribute="segments" entity="rectangular_composite_surface" name="using_surfaces">
                    <inverse.aggregate lower="1" type="BAG" upper="?"/>
                 </inverse>
                 <where expression="(NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' &#10;                 IN TYPEOF(parent_surface)))" label="WR1"/>
              </entity>
              
      <entity name="offset_surface" supertypes="surface">
                 <explicit name="basis_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="distance">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="self_intersect">
                    <builtintype type="LOGICAL"/>
                 </explicit>
              </entity>
              
       <entity name="oriented_surface" supertypes="surface">
                 <explicit name="orientation">
                    <builtintype type="BOOLEAN"/>
                 </explicit>
              </entity>
              
      <entity name="surface_replica" supertypes="surface">
                 <explicit name="parent_surface">
                    <typename name="surface"/>
                 </explicit>
                 <explicit name="transformation">
                    <typename name="cartesian_transformation_operator_3d"/>
                 </explicit>
                 <where expression="acyclic_surface_replica(SELF, parent_surface)" label="WR1"/>
              </entity>
              
      <entity name="volume" super.expression="ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume)" supertypes="geometric_representation_item">
                 <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
              </entity>
              
      <entity name="block_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="x">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="y">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="z">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
       <entity name="wedge_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="x">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="y">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="z">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="ltx">
                    <typename name="length_measure"/>
                 </explicit>
                 <where expression="((0.0 &lt;= ltx) AND (ltx &lt; x))" label="WR1"/>
              </entity>
              
      <entity name="pyramid_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="xlength">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="ylength">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="tetrahedron_volume" supertypes="volume">
                 <explicit name="point_1">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_2">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_3">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <explicit name="point_4">
                    <typename name="cartesian_point"/>
                 </explicit>
                 <where expression="point_1.dim = 3" label="WR1"/>
                 <where expression="above_plane(point_1, point_2, point_3, point_4) &lt;&gt; 0.0" label="WR2"/>
              </entity>
              
       <entity name="hexahedron_volume" supertypes="volume">
                 <explicit name="points">
                    <aggregate lower="8" type="LIST" upper="8"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <where expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0" label="WR1"/>
                 <where expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0" label="WR2"/>
                 <where expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0" label="WR3"/>
                 <where expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0" label="WR4"/>
                 <where expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0" label="WR5"/>
                 <where expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0" label="WR6"/>
                 <where expression="same_side([points[1], points[2], points[3]],&#10;                     [points[5], points[6], points[7], points[8]])" label="WR7"/>
                 <where expression="same_side([points[1], points[4], points[8]],&#10;                     [points[3], points[7], points[6], points[2]])" label="WR8"/>
                 <where expression="same_side([points[1], points[2], points[5]],&#10;                      [points[3], points[7], points[8], points[4]])" label="WR9"/>
                 <where expression="same_side([points[5], points[6], points[7]],&#10;                     [points[1], points[2], points[3], points[4]])" label="WR10"/>
                 <where expression="same_side([points[3], points[7], points[6]],&#10;                     [points[1], points[4], points[8], points[5]])" label="WR11"/>
                 <where expression="same_side([points[3], points[7], points[8]],&#10;                      [points[1], points[5], points[6], points[2]])" label="WR12"/>
                 <where expression="points[1].dim = 3" label="WR13"/>
              </entity>
              
      <entity name="spherical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="cylindrical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="eccentric_conical_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="height">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="x_offset">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="y_offset">
                    <typename name="length_measure"/>
                 </explicit>
                 <explicit name="ratio">
                    <builtintype type="REAL"/>
                 </explicit>
                 <where expression="ratio &gt;= 0.0" label="WR1"/>
              </entity>
              
      <entity name="toroidal_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="major_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="minor_radius">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <where expression="minor_radius &lt; major_radius" label="WR1"/>
              </entity>
              
      <entity name="ellipsoid_volume" supertypes="volume">
                 <explicit name="position">
                    <typename name="axis2_placement_3d"/>
                 </explicit>
                 <explicit name="semi_axis_1">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_2">
                    <typename name="positive_length_measure"/>
                 </explicit>
                 <explicit name="semi_axis_3">
                    <typename name="positive_length_measure"/>
                 </explicit>
              </entity>
              
      <entity name="b_spline_volume" super.expression="ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume" supertypes="volume">
                 <explicit name="u_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="w_degree">
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="control_points_list">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="cartesian_point"/>
                 </explicit>
                 <derived expression="SIZEOF(control_points_list) - 1" name="u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1]) - 1" name="v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(control_points_list[1][1]) - 1" name="w_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="make_array_of_array_of_array (control_points_list,&#10;                                              0,u_upper,0,v_upper,&#10;                                              0,w_upper )" name="control_points">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="w_upper"/>
                    <typename name="cartesian_point"/>
                 </derived>
                 <where expression="('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR&#10;        ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF))" label="WR1"/>
              </entity>
              
       <entity name="b_spline_volume_with_knots" supertypes="b_spline_volume">
                 <explicit name="u_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="v_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="w_multiplicities">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="INTEGER"/>
                 </explicit>
                 <explicit name="u_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="v_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <explicit name="w_knots">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <typename name="parameter_value"/>
                 </explicit>
                 <derived expression="SIZEOF(u_knots)" name="knot_u_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(v_knots)" name="knot_v_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <derived expression="SIZEOF(w_knots)" name="knot_w_upper">
                    <builtintype type="INTEGER"/>
                 </derived>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.u_degree,&#10;                   knot_u_upper, SELF\b_spline_volume.u_upper,&#10;                               u_multiplicities, u_knots)" label="WR1"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.v_degree,&#10;                   knot_v_upper, SELF\b_spline_volume.v_upper,&#10;                               v_multiplicities, v_knots)" label="WR2"/>
                 <where expression="constraints_param_b_spline(SELF\b_spline_volume.w_degree,&#10;                   knot_w_upper, SELF\b_spline_volume.w_upper,&#10;                               w_multiplicities, w_knots)" label="WR3"/>
                 <where expression="SIZEOF(u_multiplicities) = knot_u_upper" label="WR4"/>
                 <where expression="SIZEOF(v_multiplicities) = knot_v_upper" label="WR5"/>
                 <where expression="SIZEOF(w_multiplicities) = knot_w_upper" label="WR6"/>
              </entity> 
              
       <entity name="bezier_volume" supertypes="b_spline_volume"/>
              
      <entity name="uniform_volume" supertypes="b_spline_volume"/>
              
      <entity name="quasi_uniform_volume" supertypes="b_spline_volume"/>
              
       <entity name="rational_b_spline_volume" supertypes="b_spline_volume">
                 <explicit name="weights_data">
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <aggregate lower="2" type="LIST" upper="?"/>
                    <builtintype type="REAL"/>
                 </explicit>
                 <derived expression="make_array_of_array_of_array&#10;                             (weights_data,0,u_upper,0,v_upper,0,w_upper)" name="weights">
                    <aggregate lower="0" type="ARRAY" upper="u_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="v_upper"/>
                    <aggregate lower="0" type="ARRAY" upper="w_upper"/>
                    <builtintype type="REAL"/>
                 </derived>
                 <where expression="(SIZEOF(weights_data) =&#10;                         SIZEOF(SELF\b_spline_volume.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))&#10;            AND (SIZEOF(weights_data[1][1]) =&#10;                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))" label="WR1"/>
                 <where expression="volume_weights_positive(SELF)" label="WR2"/>
              </entity>
      <rule appliesto="cartesian_point direction representation_context geometric_representation_context" name="compatible_dimension">
         <where expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0 )) =0" label="WR1"/>
         <where expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF( QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)))&#10;       &gt; 0 )) = 0" label="WR2"/>
      </rule>
      <function name="above_plane">
         <parameter name="p1">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p2">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p3">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p4">
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim &lt;&gt; 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);</algorithm>
      </function>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor &lt; 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="3" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
         (sum &lt;&gt; (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k &lt; 1) OR (k &gt; degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i &lt; up_knots) AND (k &gt; degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k &gt; degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag &gt; 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="default_b_spline_curve_weights">
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="up_cp"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([1:up_cp + 1]);</algorithm>
      </function>
      <function name="default_b_spline_knot_mult">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="?"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);</algorithm>
      </function>
      <function name="default_b_spline_knots">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="?"/>
         <typename name="parameter_value"/>
         <algorithm>LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);</algorithm>
      </function>
      <function name="default_b_spline_surface_weights">
         <parameter name="u_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="v_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="u_upper"/>
         <aggregate lower="0" type="ARRAY" upper="v_upper"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([[1:v_upper + 1]:u_upper +1]);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
    IF (SIZEOF(x) &gt; 0) THEN
       y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
    ELSE
      RETURN(?);
    -- mark error by returning indeterminate result
   END_IF;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim &lt;&gt; arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
          (z.direction_ratios &lt;&gt; [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim &lt;&gt; 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low" type="ARRAY" upper="u"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n &lt;&gt; (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low1" type="ARRAY" upper="u1"/>
         <aggregate lower="low2" type="ARRAY" upper="u2"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);</algorithm>
      </function>
      <function name="make_array_of_array_of_array">
         <parameter name="lis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low3">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u3">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="low1" type="ARRAY" upper="u1"/>
         <aggregate lower="low2" type="ARRAY" upper="u2"/>
         <aggregate lower="low3" type="ARRAY" upper="u3"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      v      : direction := dummy_gri || direction ([1.0,0.0,0.0]);
      result : vector_or_direction;
      vec    : vector := dummy_gri || vector (v, 1.0);
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg\vector.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag &gt; 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;</algorithm>
      </function>
      <function name="same_side">
         <parameter name="plane_pts">
            <aggregate lower="3" type="LIST" upper="3"/>
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="test_points">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 &lt;= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec\vector.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag &lt; 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] &lt;= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1\vector.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2\vector.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag &gt; 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="vector_sum">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1\vector.magnitude;
         vec1 := arg1\vector.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2\vector.magnitude;
         vec2 := arg2\vector.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag &gt; 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);</algorithm>
      </function>
      <function name="volume_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_volume"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] &lt;= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);</algorithm>
      </function>
   </schema>
</express>