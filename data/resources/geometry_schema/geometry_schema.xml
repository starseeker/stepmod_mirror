<?xml version="1.0"?>
<!-- $Id: express2xml.js,v 1.4 2001/12/14 11:56:28 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: $"
  rcs.revision="$Revision: $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.4"
    source="../data/resources/geometry_schema/geometry_schema.exp"/>

  <schema name="geometry_schema">
    <interface
      kind="reference"
      schema="representation_schema">
      <interfaced.item
        name="definitional_representation"/>
      <interfaced.item
        name="founded_item"/>
      <interfaced.item
        name="functionally_defined_transformation"/>
      <interfaced.item
        name="item_in_context"/>
      <interfaced.item
        name="representation"/>
      <interfaced.item
        name="representation_item"/>
      <interfaced.item
        name="representation_context"/>
      <interfaced.item
        name="using_representations"/>
    </interface>

    <interface
      kind="reference"
      schema="measure_schema">
      <interfaced.item
        name="global_unit_assigned_context"/>
      <interfaced.item
        name="length_measure"/>
      <interfaced.item
        name="parameter_value"/>
      <interfaced.item
        name="plane_angle_measure"/>
      <interfaced.item
        name="plane_angle_unit"/>
      <interfaced.item
        name="positive_length_measure"/>
      <interfaced.item
        name="positive_plane_angle_measure"/>
    </interface>

    <interface
      kind="reference"
      schema="topology_schema">
      <interfaced.item
        name="edge_curve"/>
      <interfaced.item
        name="face_surface"/>
      <interfaced.item
        name="poly_loop"/>
      <interfaced.item
        name="vertex_point"/>
    </interface>

    <interface
      kind="reference"
      schema="geometric_model_schema">
      <interfaced.item
        name="block"/>
      <interfaced.item
        name="boolean_result"/>
      <interfaced.item
        name="cyclide_segment_solid"/>
      <interfaced.item
        name="eccentric_cone"/>
      <interfaced.item
        name="edge_based_wireframe_model"/>
      <interfaced.item
        name="ellipsoid"/>
      <interfaced.item
        name="face_based_surface_model"/>
      <interfaced.item
        name="faceted_primitive"/>
      <interfaced.item
        name="geometric_set"/>
      <interfaced.item
        name="half_space_solid"/>
      <interfaced.item
        name="half_space_2d"/>
      <interfaced.item
        name="primitive_2d"/>
      <interfaced.item
        name="rectangular_pyramid"/>
      <interfaced.item
        name="right_angular_wedge"/>
      <interfaced.item
        name="right_circular_cone"/>
      <interfaced.item
        name="right_circular_cylinder"/>
      <interfaced.item
        name="shell_based_surface_model"/>
      <interfaced.item
        name="shell_based_wireframe_model"/>
      <interfaced.item
        name="solid_model"/>
      <interfaced.item
        name="sphere"/>
      <interfaced.item
        name="torus"/>
    </interface>

    <type name="axis2_placement">
      <select
        selectitems="axis2_placement_2d axis2_placement_3d">
      </select>

    </type>
    <type name="b_spline_curve_form">
      <enumeration
        items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified">
      </enumeration>


    </type>
    <type name="b_spline_surface_form">
      <enumeration
        items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified">
      </enumeration>


    </type>
    <type name="curve_on_surface">
      <select
        selectitems="pcurve surface_curve composite_curve_on_surface">
      </select>

    </type>
    <type name="dimension_count">
      <builtintype
        type="INTEGER">
      </builtintype>


      <where
        label="WHERE"
        expression="SELF &gt; 0">
      </where>
    </type>
    <type name="extent_enumeration">
      <enumeration
        items="invalid zero finite_non_zero infinite">
      </enumeration>


    </type>
    <type name="knot_type">
      <enumeration
        items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified">
      </enumeration>


    </type>
    <type name="pcurve_or_surface">
      <select
        selectitems="pcurve surface">
      </select>

    </type>
    <type name="preferred_surface_curve_representation">
      <enumeration
        items="curve_3d pcurve_s1 pcurve_s2">
      </enumeration>


    </type>
    <type name="surface_boundary">
      <select
        selectitems="boundary_curve degenerate_pcurve">
      </select>

    </type>
    <type name="transition_code">
      <enumeration
        items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature">
      </enumeration>


    </type>
    <type name="trimming_preference">
      <enumeration
        items="cartesian parameter unspecified">
      </enumeration>


    </type>
    <type name="trimming_select">
      <select
        selectitems="cartesian_point parameter_value">
      </select>

    </type>
    <type name="vector_or_direction">
      <select
        selectitems="vector direction">
      </select>

    </type>
    <entity
      name="geometric_representation_context"
      supertypes="representation_context">
      <explicit
        name="coordinate_space_dimension">
        <typename
          name="dimension_count"/>
      </explicit>
    </entity>

    <entity
      name="axis1_placement"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="z"
        expression="NVL(normalise(axis), dummy_gri ||                                 direction([0.0,0.0,1.0]))">
        <typename
          name="direction "/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim  = 3">
      </where>
    </entity>

    <entity
      name="axis2_placement_2d"
      supertypes="placement">
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_2axes(ref_direction)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="axis2_placement_3d"
      supertypes="placement">
      <explicit
        name="axis"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="ref_direction"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="p"
        expression="build_axes(axis,ref_direction)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\placement.location.dim = 3">
      </where>
      <where
        label="WR2"
        expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)">
      </where>
      <where
        label="WR3"
        expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)">
      </where>
      <where
        label="WR4"
        expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR          (cross_product(axis,ref_direction).magnitude &gt; 0.0)">
      </where>
    </entity>

    <entity
      name="b_spline_curve"
      super.expression="(ONEOF(uniform_curve, b_spline_curve_with_knots,                       quasi_uniform_curve, bezier_curve)                         ANDOR rational_b_spline_curve)"
      supertypes="bounded_curve">
      <explicit
        name="degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="curve_form">
        <typename
          name="b_spline_curve_form"/>
      </explicit>
      <explicit
        name="closed_curve">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="upper_index_on_control_points"
        expression="(SIZEOF(control_points_list) - 1)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="list_to_array(control_points_list,0,                                             upper_index_on_control_points)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="cartesian_point"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR        ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR        ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))">
      </where>
    </entity>

    <entity
      name="b_spline_curve_with_knots"
      supertypes="b_spline_curve">
      <explicit
        name="knot_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="upper_index_on_knots"
        expression="SIZEOF(knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(degree, upper_index_on_knots,                               upper_index_on_control_points,                               knot_multiplicities, knots)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(knot_multiplicities) = upper_index_on_knots">
      </where>
    </entity>

    <entity
      name="b_spline_surface"
      super.expression="(ONEOF(b_spline_surface_with_knots, uniform_surface,                       quasi_uniform_surface, bezier_surface)                         ANDOR rational_b_spline_surface)"
      supertypes="bounded_surface">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="surface_form">
        <typename
          name="b_spline_surface_form"/>
      </explicit>
      <explicit
        name="u_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="v_closed">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array(control_points_list,                                              0,u_upper,0,v_upper)">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))">
      </where>
    </entity>

    <entity
      name="b_spline_surface_with_knots"
      supertypes="b_spline_surface">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="knot_spec">
        <typename
          name="knot_type"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,                   knot_u_upper, SELF\b_spline_surface.u_upper,                               u_multiplicities, u_knots)">
      </where>
      <where
        label="WR2"
        expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,                   knot_v_upper, SELF\b_spline_surface.v_upper,                               v_multiplicities, v_knots)">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(u_multiplicities) = knot_u_upper">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(v_multiplicities) = knot_v_upper">
      </where>
    </entity>

    <entity
      name="b_spline_volume"
      super.expression="(ONEOF(b_spline_volume_with_knots, uniform_volume,                      quasi_uniform_volume,bezier_volume) ANDOR                       rational_b_spline_volume)"
      supertypes="volume">
      <explicit
        name="u_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="v_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="w_degree">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="control_points_list">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <derived
        name="u_upper"
        expression="SIZEOF(control_points_list) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="v_upper"
        expression="SIZEOF(control_points_list[1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="w_upper"
        expression="SIZEOF(control_points_list[1][1]) - 1">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="control_points"
        expression="make_array_of_array_of_array (control_points_list,                                              0,u_upper,0,v_upper,                                              0,w_upper )">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </derived>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR        ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF)) ">
      </where>
    </entity>

    <entity
      name="b_spline_volume_with_knots"
      supertypes="b_spline_volume">
      <explicit
        name="u_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="v_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="w_multiplicities">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <explicit
        name="u_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="w_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="parameter_value"/>
      </explicit>
      <derived
        name="knot_u_upper"
        expression="SIZEOF(u_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_v_upper"
        expression="SIZEOF(v_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="knot_w_upper"
        expression="SIZEOF(w_knots)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="constraints_param_b_spline(SELF\b_spline_volume.u_degree,                   knot_u_upper, SELF\b_spline_volume.u_upper,                               u_multiplicities, u_knots)">
      </where>
      <where
        label="WR2"
        expression="constraints_param_b_spline(SELF\b_spline_volume.v_degree,                   knot_v_upper, SELF\b_spline_volume.v_upper,                               v_multiplicities, v_knots)">
      </where>
      <where
        label="WR3"
        expression="constraints_param_b_spline(SELF\b_spline_volume.w_degree,                   knot_w_upper, SELF\b_spline_volume.w_upper,                               w_multiplicities, w_knots)">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(u_multiplicities) = knot_u_upper">
      </where>
      <where
        label="WR5"
        expression="SIZEOF(v_multiplicities) = knot_v_upper">
      </where>
      <where
        label="WR6"
        expression="SIZEOF(w_multiplicities) = knot_w_upper">
      </where>
    </entity>

    <entity
      name="bezier_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="bezier_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="bezier_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="block_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="boundary_curve"
      supertypes="composite_curve_on_surface">
      <where
        label="WR1"
        expression="SELF\composite_curve.closed_curve">
      </where>
    </entity>

    <entity
      name="bounded_curve"
      super.expression="(ONEOF(polyline, b_spline_curve, trimmed_curve,                      bounded_pcurve, bounded_surface_curve, composite_curve))"
      supertypes="curve">
    </entity>

    <entity
      name="bounded_pcurve"
      supertypes="pcurve bounded_curve">
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]))">
      </where>
    </entity>

    <entity
      name="bounded_surface"
      super.expression="(ONEOF(b_spline_surface, rectangular_trimmed_surface,                       curve_bounded_surface, rectangular_composite_surface))"
      supertypes="surface">
    </entity>

    <entity
      name="bounded_surface_curve"
      supertypes="surface_curve bounded_curve">
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN             TYPEOF(SELF\surface_curve.curve_3d))">
      </where>
    </entity>

    <entity
      name="cartesian_point"
      super.expression="(ONEOF(cylindrical_point, polar_point, spherical_point))"
      supertypes="point">
      <explicit
        name="coordinates">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_transformation_operator"
      super.expression="(ONEOF(cartesian_transformation_operator_2d,                               cartesian_transformation_operator_3d))"
      supertypes="geometric_representation_item functionally_defined_transformation">
      <explicit
        name="axis1"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="axis2"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="local_origin">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="scale"
        optional="YES">
        <builtintype
          type="REAL"/>
      </explicit>
      <derived
        name="scl"
        expression="NVL(scale, 1.0)">
        <builtintype
          type="REAL"/>
      </derived>
      <where
        label="WR1"
        expression="scl &gt; 0.0">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_2d"
      supertypes="cartesian_transformation_operator">
      <derived
        name="u"
        expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,                   SELF\cartesian_transformation_operator.axis2,?)">
        <aggregate
          type="LIST"
          lower="2"
          upper="2"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 2">
      </where>
    </entity>

    <entity
      name="cartesian_transformation_operator_3d"
      supertypes="cartesian_transformation_operator">
      <explicit
        name="axis3"
        optional="YES">
        <typename
          name="direction"/>
      </explicit>
      <derived
        name="u"
        expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,                        SELF\cartesian_transformation_operator.axis2,axis3)">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="direction"/>
      </derived>
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="circle"
      supertypes="conic">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="clothoid"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
      <explicit
        name="clothoid_constant">
        <typename
          name="length_measure"/>
      </explicit>
    </entity>

    <entity
      name="composite_curve"
      supertypes="bounded_curve">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="composite_curve_segment"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <derived
        name="n_segments"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="closed_curve"
        expression="segments[n_segments].transition &lt;&gt; discontinuous">
        <builtintype
          type="LOGICAL"/>
      </derived>
      <where
        label="WR1"
        expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |                temp.transition = discontinuous)) = 1)) OR            ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |                 temp.transition = discontinuous)) = 0))">
      </where>
    </entity>

    <entity
      name="composite_curve_on_surface"
      super.expression="(boundary_curve)"
      supertypes="composite_curve">
      <explicit
        name="DERIVE">
        <aggregate
          type="SET"
          lower="0"
          upper="2"/>
        <typename
          name="surface"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(basis_surface) &gt; 0">
      </where>
      <where
        label="WR2"
        expression="constraints_composite_curve_on_surface(SELF)">
      </where>
    </entity>

    <entity
      name="composite_curve_segment"
      supertypes="founded_item">
      <explicit
        name="transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="same_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <inverse
        name="using_curves"
        entity="composite_curve"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="WR1"
        expression="('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve))">
      </where>
    </entity>

    <entity
      name="conic"
      super.expression="(ONEOF(circle, ellipse, hyperbola, parabola))"
      supertypes="curve">
      <explicit
        name="position">
        <typename
          name="axis2_placement"/>
      </explicit>
    </entity>

    <entity
      name="conical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="semi_angle">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="radius &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="curve"
      super.expression="(ONEOF(line, conic, clothoid, pcurve, surface_curve,                       offset_curve_2d, offset_curve_3d, curve_replica))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="curve_bounded_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="boundaries">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="boundary_curve"/>
      </explicit>
      <explicit
        name="implicit_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="(NOT implicit_outer) OR         (SIZEOF (QUERY (temp &lt;* boundaries |           'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)">
      </where>
      <where
        label="WR2"
        expression="(NOT(implicit_outer)) OR                ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface))">
      </where>
      <where
        label="WR3"
        expression="SIZEOF(QUERY(temp &lt;* boundaries |                  'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN                                         TYPEOF(temp))) &lt;= 1">
      </where>
      <where
        label="WR4"
        expression="SIZEOF(QUERY(temp &lt;* boundaries |            (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;                                         SELF.basis_surface))) = 0">
      </where>
    </entity>

    <entity
      name="curve_replica"
      supertypes="curve">
      <explicit
        name="parent_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="WR1"
        expression="transformation.dim = parent_curve.dim">
      </where>
      <where
        label="WR2"
        expression="acyclic_curve_replica (SELF, parent_curve)">
      </where>
    </entity>

    <entity
      name="cylindrical_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="length_measure"/>
      </explicit>
      <derived
        name="SELF\cartesian_point.coordinates"
        expression="[r*cos(theta), r*sin(theta), z]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="cylindrical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="cylindrical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="degenerate_pcurve"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(reference_to_curve\representation.items) = 1">
      </where>
      <where
        label="WR2"
        expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF                    (reference_to_curve\representation.items[1])">
      </where>
      <where
        label="WR3"
        expression="reference_to_curve\representation.                   items[1]\geometric_representation_item.dim =2">
      </where>
    </entity>

    <entity
      name="degenerate_toroidal_surface"
      supertypes="toroidal_surface">
      <explicit
        name="select_outer">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="major_radius &lt;   minor_radius">
      </where>
    </entity>

    <entity
      name="direction"
      supertypes="geometric_representation_item">
      <explicit
        name="direction_ratios">
        <aggregate
          type="LIST"
          lower="2"
          upper="3"/>
        <typename
          name="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0">
      </where>
    </entity>

    <entity
      name="dupin_cyclide_surface"
      supertypes="elementary_surface">
      <explicit
        name="generalised_major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="generalised_minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="skewness">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="skewness &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="eccentric_conical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="x_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="y_offset">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="ratio">
        <builtintype
          type="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="ratio &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="elementary_surface"
      super.expression="(ONEOF(plane, cylindrical_surface, conical_surface,                       spherical_surface, toroidal_surface))"
      supertypes="surface">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
    </entity>

    <entity
      name="ellipse"
      supertypes="conic">
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="ellipsoid_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="semi_axis_1">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_2">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_axis_3">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="evaluated_degenerate_pcurve"
      supertypes="degenerate_pcurve">
      <explicit
        name="equivalent_point">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="fixed_reference_swept_surface"
      supertypes="swept_surface">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="fixed_reference">
        <typename
          name="direction"/>
      </explicit>
    </entity>

    <entity
      name="geometric_representation_item"
      super.expression="(ONEOF(point, direction, vector, placement,                 cartesian_transformation_operator, curve, surface,                 edge_curve, face_surface, poly_loop, vertex_point,                 solid_model, boolean_result, sphere, right_circular_cone,                 right_circular_cylinder, torus, block, primitive_2d,                 right_angular_wedge, ellipsoid, faceted_primitive,                 rectangular_pyramid, cyclide_segment_solid, volume,                 half_space_solid, half_space_2d,                 shell_based_surface_model, face_based_surface_model,                 shell_based_wireframe_model, edge_based_wireframe_model,                 geometric_set))"
      supertypes="representation_item">
      <derived
        name="dim"
        expression="dimension_of(SELF)">
        <typename
          name="dimension_count "/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |      NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN      TYPEOF (using_rep.context_of_items)))) = 0">
      </where>
    </entity>

    <entity
      name="line"
      supertypes="curve">
      <explicit
        name="pnt">
        <typename
          name="cartesian_point"/>
      </explicit>
      <explicit
        name="dir">
        <typename
          name="vector"/>
      </explicit>
      <where
        label="WR1"
        expression="dir.dim  = pnt.dim">
      </where>
    </entity>

    <entity
      name="hexahedron_volume"
      supertypes="volume">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="8"
          upper="8"/>
        <typename
          name="cartesian_point"/>
      </explicit>
      <where
        label="WR1"
        expression="above_plane(points[1], points[2], points[3], points[4]) = 0.0">
      </where>
      <where
        label="WR2"
        expression="above_plane(points[5], points[8], points[7], points[6]) = 0.0">
      </where>
      <where
        label="WR3"
        expression="above_plane(points[1], points[4], points[8], points[5]) = 0.0">
      </where>
      <where
        label="WR4"
        expression="above_plane(points[4], points[3], points[7], points[8]) = 0.0">
      </where>
      <where
        label="WR5"
        expression="above_plane(points[3], points[2], points[6], points[7]) = 0.0">
      </where>
      <where
        label="WR6"
        expression="above_plane(points[1], points[5], points[6], points[2]) = 0.0">
      </where>
      <where
        label="WR7"
        expression="same_side([points[1], points[2], points[3]],                     [points[5], points[6], points[7], points[8]])">
      </where>
      <where
        label="WR8"
        expression="same_side([points[1], points[4], points[8]],                     [points[3], points[7], points[6], points[2]])">
      </where>
      <where
        label="WR9"
        expression="same_side([points[1], points[2], points[5]],                      [points[3], points[7], points[8], points[4]])">
      </where>
      <where
        label="WR10"
        expression="same_side([points[5], points[6], points[7]],                     [points[1], points[2], points[3], points[4]])">
      </where>
      <where
        label="WR11"
        expression="same_side([points[3], points[7], points[6]],                     [points[1], points[4], points[8], points[5]])">
      </where>
      <where
        label="WR12"
        expression="same_side([points[3], points[7], points[8]],                      [points[1], points[5], points[6], points[2]])">
      </where>
      <where
        label="WR13"
        expression="points[1].dim = 3">
      </where>
    </entity>

    <entity
      name="hyperbola"
      supertypes="conic">
      <explicit
        name="semi_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="semi_imag_axis">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="intersection_curve"
      supertypes="surface_curve">
      <where
        label="WR1"
        expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
      </where>
      <where
        label="WR2"
        expression="associated_surface(SELF\surface_curve.associated_geometry[1]) &lt;&gt;             associated_surface(SELF\surface_curve.associated_geometry[2])">
      </where>
    </entity>

    <entity
      name="offset_curve_2d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <where
        label="WR1"
        expression="basis_curve.dim = 2">
      </where>
    </entity>

    <entity
      name="offset_curve_3d"
      supertypes="curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
      <explicit
        name="ref_direction">
        <typename
          name="direction"/>
      </explicit>
      <where
        label="WR1"
        expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)">
      </where>
    </entity>

    <entity
      name="offset_surface"
      supertypes="surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="distance">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="self_intersect">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="oriented_surface"
      supertypes="surface">
      <explicit
        name="orientation">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
    </entity>

    <entity
      name="outer_boundary_curve"
      supertypes="boundary_curve">
    </entity>

    <entity
      name="parabola"
      supertypes="conic">
      <explicit
        name="focal_dist">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="focal_dist &lt;&gt; 0.0">
      </where>
    </entity>

    <entity
      name="pcurve"
      supertypes="curve">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="reference_to_curve">
        <typename
          name="definitional_representation"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(reference_to_curve\representation.items) = 1">
      </where>
      <where
        label="WR2"
        expression="'GEOMETRY_SCHEMA.CURVE' IN TYPEOF                    (reference_to_curve\representation.items[1])">
      </where>
      <where
        label="WR3"
        expression="reference_to_curve\representation.items[1]\                               geometric_representation_item.dim =2">
      </where>
    </entity>

    <entity
      name="placement"
      super.expression="(ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))"
      supertypes="geometric_representation_item">
      <explicit
        name="location">
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="plane"
      supertypes="elementary_surface">
    </entity>

    <entity
      name="polar_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="SELF\cartesian_point.coordinates"
        expression="[r*cos(theta), r*sin(theta)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="point"
      super.expression="(ONEOF(cartesian_point, point_on_curve, point_on_surface,                        point_in_volume, point_replica, degenerate_pcurve))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="point_in_volume"
      supertypes="point">
      <explicit
        name="basis_volume">
        <typename
          name="volume"/>
      </explicit>
      <explicit
        name="point_parameter_u">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_v">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_w">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_on_curve"
      supertypes="point">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="point_parameter">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_on_surface"
      supertypes="point">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="point_parameter_u">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="point_parameter_v">
        <typename
          name="parameter_value"/>
      </explicit>
    </entity>

    <entity
      name="point_replica"
      supertypes="point">
      <explicit
        name="parent_pt">
        <typename
          name="point"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator"/>
      </explicit>
      <where
        label="WR1"
        expression="transformation.dim = parent_pt.dim">
      </where>
      <where
        label="WR2"
        expression="acyclic_point_replica (SELF,parent_pt)">
      </where>
    </entity>

    <entity
      name="polyline"
      supertypes="bounded_curve">
      <explicit
        name="points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </explicit>
    </entity>

    <entity
      name="pyramid_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="xlength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ylength">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="height">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="quasi_uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="quasi_uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="quasi_uniform_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="rational_b_spline_curve"
      supertypes="b_spline_curve">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
      <explicit
        name="DERIVE">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="upper_index_on_control_points"/>
        <typename
          name="REAL"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.                                           control_points_list)">
      </where>
      <where
        label="WR2"
        expression="curve_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rational_b_spline_surface"
      supertypes="b_spline_surface">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="DERIVE">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </explicit>
      <where
        label="WR1"
        expression="(SIZEOF(weights_data) =                     SIZEOF(SELF\b_spline_surface.control_points_list))           AND (SIZEOF(weights_data[1]) =                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))">
      </where>
      <where
        label="WR2"
        expression="surface_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rational_b_spline_volume"
      supertypes="b_spline_volume">
      <explicit
        name="weights_data">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <explicit
        name="DERIVE">
        <aggregate
          type="ARRAY"
          lower="0"
          upper="u_upper"/>
        <typename
          name="ARRAY"/>
      </explicit>
      <where
        label="WR1"
        expression="(SIZEOF(weights_data) =                         SIZEOF(SELF\b_spline_volume.control_points_list))           AND (SIZEOF(weights_data[1]) =                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))            AND (SIZEOF(weights_data[1][1]) =                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))">
      </where>
      <where
        label="WR2"
        expression="volume_weights_positive(SELF)">
      </where>
    </entity>

    <entity
      name="rectangular_composite_surface"
      supertypes="bounded_surface">
      <explicit
        name="segments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <derived
        name="n_u"
        expression="SIZEOF(segments)">
        <builtintype
          type="INTEGER"/>
      </derived>
      <derived
        name="n_v"
        expression="SIZEOF(segments[1])">
        <builtintype
          type="INTEGER"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0">
      </where>
      <where
        label="WR2"
        expression="constraints_rectangular_composite_surface(SELF)">
      </where>
    </entity>

    <entity
      name="rectangular_trimmed_surface"
      supertypes="bounded_surface">
      <explicit
        name="basis_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="u1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="u2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v1">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="v2">
        <typename
          name="parameter_value"/>
      </explicit>
      <explicit
        name="usense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="vsense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <where
        label="WR1"
        expression="u1 &lt;&gt; u2">
      </where>
      <where
        label="WR2"
        expression="v1 &lt;&gt; v2">
      </where>
      <where
        label="WR3"
        expression="(('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))       AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR      ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))          OR (usense = (u2 &gt; u1))">
      </where>
      <where
        label="WR4"
        expression="(('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))          OR         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))          OR (vsense = (v2 &gt; v1))">
      </where>
    </entity>

    <entity
      name="reparametrised_composite_curve_segment"
      supertypes="composite_curve_segment">
      <explicit
        name="param_length">
        <typename
          name="parameter_value"/>
      </explicit>
      <where
        label="WR1"
        expression="param_length &gt; 0.0">
      </where>
    </entity>

    <entity
      name="seam_curve"
      supertypes="surface_curve">
      <where
        label="WR1"
        expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2">
      </where>
      <where
        label="WR2"
        expression="associated_surface(SELF\surface_curve.associated_geometry[1]) =           associated_surface(SELF\surface_curve.associated_geometry[2])">
      </where>
      <where
        label="WR3"
        expression="'GEOMETRY_SCHEMA.PCURVE' IN           TYPEOF(SELF\surface_curve.associated_geometry[1])">
      </where>
      <where
        label="WR4"
        expression="'GEOMETRY_SCHEMA.PCURVE' IN            TYPEOF(SELF\surface_curve.associated_geometry[2])">
      </where>
    </entity>

    <entity
      name="spherical_point"
      supertypes="cartesian_point">
      <explicit
        name="r">
        <typename
          name="length_measure"/>
      </explicit>
      <explicit
        name="theta">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <explicit
        name="phi">
        <typename
          name="plane_angle_measure"/>
      </explicit>
      <derived
        name="SELF\cartesian_point.coordinates"
        expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="3"/>
        <typename
          name="length_measure"/>
      </derived>
      <where
        label="WR1"
        expression="r &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="spherical_surface"
      supertypes="elementary_surface">
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="spherical_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="surface"
      super.expression="(ONEOF(elementary_surface, swept_surface, bounded_surface,                       offset_surface, surface_replica))"
      supertypes="geometric_representation_item">
    </entity>

    <entity
      name="surface_curve"
      super.expression="(ONEOF(intersection_curve, seam_curve) ANDOR                                            bounded_surface_curve)"
      supertypes="curve">
      <explicit
        name="curve_3d">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="associated_geometry">
        <aggregate
          type="LIST"
          lower="1"
          upper="2"/>
        <typename
          name="pcurve_or_surface"/>
      </explicit>
      <explicit
        name="master_representation">
        <typename
          name="preferred_surface_curve_representation"/>
      </explicit>
      <derived
        name="basis_surface"
        expression="get_basis_surface(SELF)">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="surface"/>
      </derived>
      <where
        label="WR1"
        expression="curve_3d.dim = 3">
      </where>
      <where
        label="WR2"
        expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR                        (master_representation &lt;&gt; pcurve_s1)">
      </where>
      <where
        label="WR3"
        expression="('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR                        (master_representation &lt;&gt; pcurve_s2)">
      </where>
      <where
        label="WR4"
        expression="NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d))">
      </where>
    </entity>

    <entity
      name="surface_curve_swept_surface"
      supertypes="swept_surface">
      <explicit
        name="directrix">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="reference_surface">
        <typename
          name="surface"/>
      </explicit>
      <where
        label="WR1"
        expression="(NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR          (reference_surface IN (directrix\surface_curve.basis_surface))">
      </where>
    </entity>

    <entity
      name="surface_of_linear_extrusion"
      supertypes="swept_surface">
      <explicit
        name="extrusion_axis">
        <typename
          name="vector"/>
      </explicit>
    </entity>

    <entity
      name="surface_of_revolution"
      supertypes="swept_surface">
      <explicit
        name="axis_position">
        <typename
          name="axis1_placement"/>
      </explicit>
      <derived
        name="axis_line"
        expression="representation_item('')||                     geometric_representation_item()|| curve()||                     line(axis_position.location, representation_item('')||                     geometric_representation_item()||                     vector(axis_position.z, 1.0))">
        <typename
          name="line "/>
      </derived>
    </entity>

    <entity
      name="surface_patch"
      supertypes="founded_item">
      <explicit
        name="parent_surface">
        <typename
          name="bounded_surface"/>
      </explicit>
      <explicit
        name="u_transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="v_transition">
        <typename
          name="transition_code"/>
      </explicit>
      <explicit
        name="u_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="v_sense">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <inverse
        name="using_surfaces"
        entity="rectangular_composite_surface"
        attribute="segments">
        <inverse.aggregate
          type="BAG"
          lower="1"
          upper="?"/>
      </inverse>
      <where
        label="WR1"
        expression="(NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE'                  IN TYPEOF(parent_surface)))">
      </where>
    </entity>

    <entity
      name="surface_replica"
      supertypes="surface">
      <explicit
        name="parent_surface">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="transformation">
        <typename
          name="cartesian_transformation_operator_3d"/>
      </explicit>
      <where
        label="WR1"
        expression="acyclic_surface_replica(SELF, parent_surface)">
      </where>
    </entity>

    <entity
      name="swept_surface"
      super.expression="(ONEOF(surface_of_linear_extrusion, surface_of_revolution,                 surface_curve_swept_surface, fixed_reference_swept_surface))"
      supertypes="surface">
      <explicit
        name="swept_curve">
        <typename
          name="curve"/>
      </explicit>
    </entity>

    <entity
      name="tetrahedron_volume"
      supertypes="volume">
      <explicit
        name="point_1">
        <typename
          name="cartesian_point "/>
      </explicit>
      <explicit
        name="point_2">
        <typename
          name="cartesian_point "/>
      </explicit>
      <explicit
        name="point_3">
        <typename
          name="cartesian_point "/>
      </explicit>
      <explicit
        name="point_4">
        <typename
          name="cartesian_point "/>
      </explicit>
      <where
        label="WR1"
        expression="point_1.dim = 3 ">
      </where>
      <where
        label="WR2"
        expression="above_plane(point_1, point_2, point_3, point_4) &lt;&gt; 0.0 ">
      </where>
    </entity>

    <entity
      name="toroidal_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="minor_radius &lt; major_radius">
      </where>
    </entity>

    <entity
      name="trimmed_curve"
      supertypes="bounded_curve">
      <explicit
        name="basis_curve">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="trim_1">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="trimming_select"/>
      </explicit>
      <explicit
        name="trim_2">
        <aggregate
          type="SET"
          lower="1"
          upper="2"/>
        <typename
          name="trimming_select"/>
      </explicit>
      <explicit
        name="sense_agreement">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="master_representation">
        <typename
          name="trimming_preference"/>
      </explicit>
      <where
        label="WR1"
        expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))">
      </where>
      <where
        label="WR2"
        expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))">
      </where>
    </entity>

    <entity
      name="toroidal_surface"
      supertypes="elementary_surface">
      <explicit
        name="major_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="minor_radius">
        <typename
          name="positive_length_measure"/>
      </explicit>
    </entity>

    <entity
      name="uniform_curve"
      supertypes="b_spline_curve">
    </entity>

    <entity
      name="uniform_surface"
      supertypes="b_spline_surface">
    </entity>

    <entity
      name="uniform_volume"
      supertypes="b_spline_volume">
    </entity>

    <entity
      name="vector"
      supertypes="geometric_representation_item">
      <explicit
        name="orientation">
        <typename
          name="direction"/>
      </explicit>
      <explicit
        name="magnitude">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="magnitude &gt;= 0.0">
      </where>
    </entity>

    <entity
      name="volume"
      super.expression="(ONEOF(block_volume, wedge_volume, spherical_volume,                    cylindrical_volume, eccentric_conical_volume,                    toroidal_volume, pyramid_volume, b_spline_volume,                    ellipsoid_volume, tetrahedron_volume, hexahedron_volume))"
      supertypes="geometric_representation_item">
      <where
        label="WR1"
        expression="SELF\geometric_representation_item.dim = 3">
      </where>
    </entity>

    <entity
      name="wedge_volume"
      supertypes="volume">
      <explicit
        name="position">
        <typename
          name="axis2_placement_3d"/>
      </explicit>
      <explicit
        name="x">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="y">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="z">
        <typename
          name="positive_length_measure"/>
      </explicit>
      <explicit
        name="ltx">
        <typename
          name="length_measure"/>
      </explicit>
      <where
        label="WR1"
        expression="((0.0 &lt;= ltx) AND (ltx &lt; x))">
      </where>
    </entity>

    <rule
      name="compatible_dimension"
      appliesto="cartesian_point direction representation_context geometric_representation_context">
      <algorithm>
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY
       (y &lt;* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x &lt;* direction | SIZEOF( QUERY
       (y &lt;* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)))
       &gt; 0 )) = 0;
      </algorithm>

    </rule>

    <function
      name="above_plane">
      <builtintype
        type="REAL"/>
      <parameter
        name="p1">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p2">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p3">
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="p4">
        <typename
          name="cartesian_point"/>
      </parameter>
      <algorithm>
   LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim &lt;&gt; 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
      </algorithm>

    </function>

    <function
      name="acyclic_curve_replica">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="rep">
        <typename
          name="curve_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="curve"/>
      </parameter>
      <algorithm>
   IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
      </algorithm>

    </function>

    <function
      name="acyclic_point_replica">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="rep">
        <typename
          name="point_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="point"/>
      </parameter>
      <algorithm>
   IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
      </algorithm>

    </function>

    <function
      name="acyclic_surface_replica">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="rep">
        <typename
          name="surface_replica"/>
      </parameter>
      <parameter
        name="parent">
        <typename
          name="surface"/>
      </parameter>
      <algorithm>
   IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
      </algorithm>

    </function>

    <function
      name="associated_surface">
      <typename
        name="surface"/>
      <parameter
        name="arg">
        <typename
          name="pcurve_or_surface"/>
      </parameter>
      <algorithm>
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
      </algorithm>

    </function>

    <function
      name="base_axis">
      <aggregate
        type="LIST"
        lower="2"
        upper="3"/>
      <typename
        name="direction"/>
      <parameter
        name="dim">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="axis1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis2">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="axis3">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor &lt; 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
      </algorithm>

    </function>

    <function
      name="build_2axes">
      <aggregate
        type="LIST"
        lower="2"
        upper="2"/>
      <typename
        name="direction"/>
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
      </algorithm>

    </function>

    <function
      name="build_axes">
      <aggregate
        type="LIST"
        lower="3"
        upper="3"/>
      <typename
        name="direction"/>
      <parameter
        name="axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="ref_direction">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
      </algorithm>

    </function>

    <function
      name="constraints_composite_curve_on_surface">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="c">
        <typename
          name="composite_curve_on_surface"/>
      </parameter>
      <algorithm>
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
      </algorithm>

    </function>

    <function
      name="constraints_param_b_spline">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_cp">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="knot_mult">
        <aggregate
          type="LIST"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <parameter
        name="knots">
        <aggregate
          type="LIST"/>
        <typename
          name="parameter_value"/>
      </parameter>
      <algorithm>
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
         (sum &lt;&gt; (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k &lt; 1) OR (k &gt; degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i &lt; up_knots) AND (k &gt; degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k &gt; degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
      </algorithm>

    </function>

    <function
      name="constraints_rectangular_composite_surface">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="s">
        <typename
          name="rectangular_composite_surface"/>
      </parameter>
      <algorithm>

   (* Check the surface types *)
     REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
      </algorithm>

    </function>

    <function
      name="cross_product">
      <typename
        name="vector"/>
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag &gt; 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
      </algorithm>

    </function>

    <function
      name="curve_weights_positive">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="b">
        <typename
          name="rational_b_spline_curve"/>
      </parameter>
      <algorithm>
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
      </algorithm>

    </function>

    <function
      name="default_b_spline_curve_weights">
      <aggregate
        type="ARRAY"
        lower="0"
        upper="up_cp"/>
      <typename
        name="REAL"/>
      <parameter
        name="up_cp">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
   RETURN([1:up_cp + 1]);
      </algorithm>

    </function>

    <function
      name="default_b_spline_surface_weights">
      <aggregate
        type="ARRAY"
        lower="0"
        upper="u_upper"/>
      <typename
        name="ARRAY"/>
      <parameter
        name="u_upper">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="v_upper">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
    RETURN([[1:v_upper + 1]:u_upper +1]);
      </algorithm>

    </function>

    <function
      name="default_b_spline_knot_mult">
      <aggregate
        type="LIST"
        lower="2"
        upper="?"/>
      <typename
        name="INTEGER"/>
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="uniform">
        <typename
          name="knot_type"/>
      </parameter>
      <algorithm>
   LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);
      </algorithm>

    </function>

    <function
      name="default_b_spline_knots">
      <aggregate
        type="LIST"
        lower="2"
        upper="?"/>
      <typename
        name="parameter_value"/>
      <parameter
        name="degree">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="up_knots">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="uniform">
        <typename
          name="knot_type"/>
      </parameter>
      <algorithm>
  LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
      </algorithm>

    </function>

    <function
      name="dimension_of">
      <typename
        name="dimension_count"/>
      <parameter
        name="item">
        <typename
          name="geometric_representation_item"/>
      </parameter>
      <algorithm>
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);

      </algorithm>

    </function>

    <function
      name="dot_product">
      <builtintype
        type="REAL"/>
      <parameter
        name="arg1">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim &lt;&gt; arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
      </algorithm>

    </function>

    <function
      name="first_proj_axis">
      <typename
        name="direction"/>
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     x_axis : direction;
     v      : direction;
     z      : direction;
     x_vec  : vector;
   END_LOCAL;
   
   IF (NOT EXISTS(z_axis)) THEN
     RETURN (?) ;
   ELSE
     z := normalise(z_axis);
     IF NOT EXISTS(arg) THEN
       IF (z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) THEN
         v :=  dummy_gri || direction([1.0,0.0,0.0]);
       ELSE
         v := dummy_gri || direction([0.0,1.0,0.0]);
       END_IF;
     ELSE
       IF  (arg.dim &lt;&gt; 3) THEN
         RETURN (?) ;
       END_IF;
       IF ((cross_product(arg,z).magnitude) = 0.0) THEN
         RETURN (?);
       ELSE
         v := normalise(arg);
       END_IF;
     END_IF;
     x_vec := scalar_times_vector(dot_product(v, z), z);
     x_axis := vector_difference(v, x_vec).orientation;
     x_axis := normalise(x_axis);
   END_IF;
   RETURN(x_axis);
      </algorithm>

    </function>

    <function
      name="get_basis_surface">
      <aggregate
        type="SET"
        lower="0"
        upper="2"/>
      <typename
        name="surface"/>
      <parameter
        name="c">
        <typename
          name="curve_on_surface"/>
      </parameter>
      <algorithm>
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
      </algorithm>

    </function>

    <function
      name="list_to_array">
      <aggregate
        type="ARRAY"/>
      <typename
        name="GENERIC"/>
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="0"
          upper="?"/>
        <typename
          name="GENERIC"/>
      </parameter>
      <parameter
        name="low">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n &lt;&gt; (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
      </algorithm>

    </function>

    <function
      name="make_array_of_array">
      <aggregate
        type="ARRAY"/>
      <typename
        name="ARRAY"/>
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <parameter
        name="low1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
      </algorithm>

    </function>

    <function
      name="make_array_of_array_of_array">
      <aggregate
        type="ARRAY"/>
      <typename
        name="ARRAY"/>
      <parameter
        name="lis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <parameter
        name="low1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u1">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u2">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="low3">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="u3">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
 LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);
      </algorithm>

    </function>

    <function
      name="normalise">
      <typename
        name="vector_or_direction"/>
      <parameter
        name="arg">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <algorithm>
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag &gt; 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
      </algorithm>

    </function>

    <function
      name="orthogonal_complement">
      <typename
        name="direction"/>
      <parameter
        name="vec">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
      </algorithm>

    </function>

    <function
      name="same_side">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="plane_pts">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <parameter
        name="test_points">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="cartesian_point"/>
      </parameter>
      <algorithm>
   LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 &lt;= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
      </algorithm>

    </function>

    <function
      name="scalar_times_vector">
      <typename
        name="vector"/>
      <parameter
        name="scalar">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="vec">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <algorithm>
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag &lt; 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);
      </algorithm>

    </function>

    <function
      name="second_proj_axis">
      <typename
        name="direction"/>
      <parameter
        name="z_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="x_axis">
        <typename
          name="direction"/>
      </parameter>
      <parameter
        name="arg">
        <typename
          name="direction"/>
      </parameter>
      <algorithm>
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
      </algorithm>

    </function>

    <function
      name="surface_weights_positive">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="b">
        <typename
          name="rational_b_spline_surface"/>
      </parameter>
      <algorithm>
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] &lt;= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
      </algorithm>

    </function>

    <function
      name="vector_difference">
      <typename
        name="vector"/>
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <algorithm>
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag &gt; 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
      </algorithm>

    </function>

    <function
      name="vector_sum">
      <typename
        name="vector"/>
      <parameter
        name="arg1">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <parameter
        name="arg2">
        <typename
          name="vector_or_direction"/>
      </parameter>
      <algorithm>
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag &gt; 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
      </algorithm>

    </function>

    <function
      name="volume_weights_positive">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="b">
        <typename
          name="rational_b_spline_volume"/>
      </parameter>
      <algorithm>
     LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] &lt;= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);
      </algorithm>

    </function>

  </schema>

</express>
