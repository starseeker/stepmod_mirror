<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 13584-20">
   <application name="JSDAI" owner="LKSoft" source="iso13584_expressions_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="iso13584_expressions_schema">
      <interface kind="reference" schema="iso13584_generic_expressions_schema">
         <interfaced.item name="generic_expression"/>
         <interfaced.item name="simple_generic_expression"/>
         <interfaced.item name="generic_variable"/>
         <interfaced.item name="generic_literal"/>
         <interfaced.item name="unary_generic_expression"/>
         <interfaced.item name="binary_generic_expression"/>
         <interfaced.item name="multiple_arity_generic_expression"/>
      </interface>
      <entity abstract.supertype="YES" name="SQL_mappable_defined_function" supertypes="defined_function"/>
      <entity name="abs_function" supertypes="unary_function_call"/>
      <entity name="acos_function" supertypes="unary_function_call"/>
      <entity name="and_expression" supertypes="multiple_arity_boolean_expression"/>
      <entity name="asin_function" supertypes="unary_function_call"/>
      <entity name="atan_function" supertypes="binary_function_call"/>
      <entity abstract.supertype="YES" name="binary_boolean_expression" super.expression="ONEOF (xor_expression, equals_expression)" supertypes="boolean_expression binary_generic_expression"/>
      <entity abstract.supertype="YES" name="binary_function_call" super.expression="atan_function" supertypes="binary_numeric_expression"/>
      <entity abstract.supertype="YES" name="binary_numeric_expression" super.expression="ONEOF (minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call)" supertypes="numeric_expression binary_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="boolean_defined_function" supertypes="defined_function boolean_expression"/>
      <entity abstract.supertype="YES" name="boolean_expression" super.expression="ONEOF (simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function)" supertypes="expression"/>
      <entity name="boolean_literal" supertypes="simple_boolean_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="boolean_variable" supertypes="simple_boolean_expression variable"/>
      <entity name="comparison_equal" supertypes="comparison_expression"/>
      <entity abstract.supertype="YES" name="comparison_expression" super.expression="ONEOF (comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression)" supertypes="boolean_expression binary_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
         <where expression="(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[2]))) &#10;OR&#10; (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' &#10;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[2])))&#10;OR&#10;(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[2])))" label="WR1"/>
      </entity>
      <entity name="comparison_greater" supertypes="comparison_expression"/>
      <entity name="comparison_greater_equal" supertypes="comparison_expression"/>
      <entity name="comparison_less" supertypes="comparison_expression"/>
      <entity name="comparison_less_equal" supertypes="comparison_expression"/>
      <entity name="comparison_not_equal" supertypes="comparison_expression"/>
      <entity name="concat_expression" supertypes="string_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="string_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity name="cos_function" supertypes="unary_function_call"/>
      <entity abstract.supertype="YES" name="defined_function" super.expression="ONEOF (numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR SQL_mappable_defined_function"/>
      <entity name="div_expression" supertypes="binary_numeric_expression"/>
      <entity name="equals_expression" supertypes="binary_boolean_expression"/>
      <entity name="exp_function" supertypes="unary_function_call"/>
      <entity abstract.supertype="YES" name="expression" super.expression="ONEOF (numeric_expression, boolean_expression, string_expression)" supertypes="generic_expression"/>
      <entity name="format_function" supertypes="string_expression binary_generic_expression">
         <derived expression="SELF\binary_generic_expression.operands[1]" name="value_to_format">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\binary_generic_expression.operands[2]" name="format_string">
            <typename name="generic_expression"/>
         </derived>
         <where expression="(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(value_to_format)) &#10;&#9;&#9;&#9;AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(format_string))" label="WR1"/>
      </entity>
      <entity name="index_expression" supertypes="string_expression binary_generic_expression">
         <derived expression="SELF\binary_generic_expression.operands[1]" name="operand">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\binary_generic_expression.operands[2]" name="index">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;&#9;IN TYPEOF(operand))&#10;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;IN TYPEOF(index))" label="WR1"/>
         <where expression="is_int_expr (index)" label="WR2"/>
      </entity>
      <entity name="int_literal" supertypes="literal_number">
         <explicit name="the_value">
            <builtintype type="INTEGER"/>
            <redeclaration entity-ref="literal_number"/>
         </explicit>
      </entity>
      <entity name="int_numeric_variable" supertypes="numeric_variable"/>
      <entity name="int_value_function" supertypes="value_function"/>
      <entity abstract.supertype="YES" name="integer_defined_function" supertypes="numeric_defined_function"/>
      <entity name="interval_expression" supertypes="boolean_expression multiple_arity_generic_expression">
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="interval_low">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="interval_item">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[3]" name="interval_high">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_low))&#10;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_item) )&#10;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_high))" label="WR1"/>
         <where expression="(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_low)) &#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_high)) &#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_item))) &#10;&#9;&#9;OR&#10;&#9;&#9;(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_low)) &#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_item)) &#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_high)))" label="WR2"/>
      </entity>
      <entity name="length_function" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="string_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="like_expression" supertypes="comparison_expression">
         <where expression="('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND &#10;&#9;&#9;('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[2]))" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="literal_number" super.expression="ONEOF (int_literal, real_literal)" supertypes="simple_numeric_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="NUMBER"/>
         </explicit>
      </entity>
      <entity name="log10_function" supertypes="unary_function_call"/>
      <entity name="log2_function" supertypes="unary_function_call"/>
      <entity name="log_function" supertypes="unary_function_call"/>
      <entity name="maximum_function" supertypes="multiple_arity_function_call"/>
      <entity name="minimum_function" supertypes="multiple_arity_function_call"/>
      <entity name="minus_expression" supertypes="binary_numeric_expression"/>
      <entity name="minus_function" supertypes="unary_function_call"/>
      <entity name="mod_expression" supertypes="binary_numeric_expression"/>
      <entity name="mult_expression" supertypes="multiple_arity_numeric_expression"/>
      <entity abstract.supertype="YES" name="multiple_arity_boolean_expression" super.expression="ONEOF (and_expression, or_expression)" supertypes="boolean_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="multiple_arity_function_call" super.expression="ONEOF (maximum_function, minimum_function)" supertypes="multiple_arity_numeric_expression"/>
      <entity abstract.supertype="YES" name="multiple_arity_numeric_expression" super.expression="ONEOF (plus_expression, mult_expression, multiple_arity_function_call)" supertypes="numeric_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity name="not_expression" supertypes="unary_boolean_expression">
         <explicit name="operand">
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="numeric_defined_function" super.expression="ONEOF (integer_defined_function, real_defined_function)" supertypes="numeric_expression defined_function"/>
      <entity abstract.supertype="YES" name="numeric_expression" super.expression="ONEOF (simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function)" supertypes="expression">
         <derived expression="is_int_expr (SELF)" name="is_int">
            <builtintype type="BOOLEAN"/>
         </derived>
         <derived expression="is_SQL_mappable (SELF)" name="sql_mappable">
            <builtintype type="BOOLEAN"/>
         </derived>
      </entity>
      <entity name="numeric_variable" super.expression="ONEOF (int_numeric_variable, real_numeric_variable)" supertypes="simple_numeric_expression variable">
         <where expression="('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' &#10;&#9;&#9;&#9;IN TYPEOF(SELF) ) OR&#10;&#9;&#9;&#9;('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' &#10;&#9;&#9;&#9;IN TYPEOF(SELF) )" label="WR1"/>
      </entity>
      <entity name="odd_function" supertypes="unary_boolean_expression">
         <explicit name="operand">
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <where expression="is_int_expr(operand)" label="WR1"/>
      </entity>
      <entity name="or_expression" supertypes="multiple_arity_boolean_expression"/>
      <entity name="plus_expression" supertypes="multiple_arity_numeric_expression"/>
      <entity name="power_expression" supertypes="binary_numeric_expression"/>
      <entity abstract.supertype="YES" name="real_defined_function" supertypes="numeric_defined_function"/>
      <entity name="real_literal" supertypes="literal_number">
         <explicit name="the_value">
            <builtintype type="REAL"/>
            <redeclaration entity-ref="literal_number"/>
         </explicit>
      </entity>
      <entity name="real_numeric_variable" supertypes="numeric_variable"/>
      <entity abstract.supertype="YES" name="simple_boolean_expression" super.expression="ONEOF (boolean_literal, boolean_variable)" supertypes="boolean_expression simple_generic_expression"/>
      <entity abstract.supertype="YES" name="simple_numeric_expression" super.expression="ONEOF (literal_number, numeric_variable)" supertypes="numeric_expression simple_generic_expression"/>
      <entity abstract.supertype="YES" name="simple_string_expression" super.expression="ONEOF (string_literal, string_variable)" supertypes="string_expression simple_generic_expression"/>
      <entity name="sin_function" supertypes="unary_function_call"/>
      <entity name="slash_expression" supertypes="binary_numeric_expression"/>
      <entity name="square_root_function" supertypes="unary_function_call"/>
      <entity abstract.supertype="YES" name="string_defined_function" supertypes="defined_function string_expression"/>
      <entity abstract.supertype="YES" name="string_expression" super.expression="ONEOF (simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function)" supertypes="expression"/>
      <entity name="string_literal" supertypes="simple_string_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="string_variable" supertypes="simple_string_expression variable"/>
      <entity name="substring_expression" supertypes="string_expression multiple_arity_generic_expression">
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="operand">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="index1">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[3]" name="index2">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(operand))&#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(index1))&#10;&#9;&#9;&#9;AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(index2))" label="WR1"/>
         <where expression="SIZEOF(SELF\multiple_arity_generic_expression.operands)=3" label="WR2"/>
         <where expression="is_int_expr (index1)" label="WR3"/>
         <where expression="is_int_expr (index2)" label="WR4"/>
      </entity>
      <entity name="tan_function" supertypes="unary_function_call"/>
      <entity abstract.supertype="YES" name="unary_boolean_expression" super.expression="ONEOF (not_expression, odd_function)" supertypes="boolean_expression unary_generic_expression"/>
      <entity abstract.supertype="YES" name="unary_function_call" super.expression="ONEOF (abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function)" supertypes="unary_numeric_expression"/>
      <entity abstract.supertype="YES" name="unary_numeric_expression" super.expression="unary_function_call" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="value_function" super.expression="int_value_function" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="string_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="variable" super.expression="ONEOF (numeric_variable, boolean_variable, string_variable)" supertypes="generic_variable"/>
      <entity name="xor_expression" supertypes="binary_boolean_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
      </entity>
      <function name="is_SQL_mappable">
         <parameter name="arg">
            <typename name="expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);</algorithm>
      </function>
      <function name="is_int_expr">
         <parameter name="arg">
            <typename name="numeric_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);</algorithm>
      </function>
      <function name="used_functions">
         <parameter name="arg">
            <typename name="expression"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="defined_function"/>
         <algorithm>LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
		+ used_functions (arg\comparison_expression.operands[2]));
END_IF;

RETURN ([ ]);</algorithm>
      </function>
   </schema>
</express>
