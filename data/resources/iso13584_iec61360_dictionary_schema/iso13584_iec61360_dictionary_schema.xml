<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 13584-42">
   <application name="JSDAI" owner="LKSoft" source="iso13584_iec61360_dictionary_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="iso13584_iec61360_dictionary_schema">
      <interface kind="reference" schema="support_resource_schema">
         <interfaced.item name="identifier"/>
         <interfaced.item name="label"/>
         <interfaced.item name="text"/>
      </interface>
      <interface kind="reference" schema="person_organization_schema">
         <interfaced.item name="organization"/>
         <interfaced.item name="address"/>
      </interface>
      <interface kind="reference" schema="measure_schema"/>
      <interface kind="reference" schema="iso13584_iec61360_language_resource_schema"/>
      <constant expression="14" name="property_code_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="14" name="class_code_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="14" name="data_type_code_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="70" name="supplier_code_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="9" name="version_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="3" name="revision_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="18" name="value_code_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="70" name="pref_name_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="15" name="short_name_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="pref_name_len" name="syn_name_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="3" name="DET_classification_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="80" name="source_doc_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="80" name="value_format_len">
         <builtintype type="INTEGER"/>
      </constant>
      <constant expression="'-'" name="sep_cv">
         <builtintype type="STRING"/>
      </constant>
      <constant expression="'.'" name="sep_id">
         <builtintype type="STRING"/>
      </constant>
      <type name="DET_classification_type">
         <typename name="identifier"/>
         <where expression="LENGTH(SELF) = DET_classification_len" label="WR1"/>
      </type>
      <type name="class_code_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) &lt;= class_code_len" label="WR1"/>
      </type>
      <type name="code_type">
         <typename name="identifier"/>
         <where expression="NOT(SELF LIKE '*.*')" label="WR1"/>
         <where expression="NOT(SELF LIKE '*-*')" label="WR2"/>
         <where expression="NOT(SELF LIKE '* *')" label="WR3"/>
         <where expression="NOT(SELF = '')" label="WR4"/>
      </type>
      <type name="currency_code">
         <typename name="identifier"/>
         <where expression="LENGTH(SELF) = 3" label="WR1"/>
      </type>
      <type name="data_type_code_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) = data_type_code_len" label="WR1"/>
      </type>
      <type name="date_type">
         <builtintype fixed="YES" type="STRING" width="10"/>
      </type>
      <type name="definition_type">
         <typename name="translatable_text"/>
      </type>
      <type name="integer_type">
         <builtintype type="INTEGER"/>
      </type>
      <type name="level">
         <enumeration items="min nom typ max"/>
      </type>
      <type name="note_type">
         <typename name="translatable_text"/>
      </type>
      <type name="pref_name_type">
         <typename name="translatable_label"/>
         <where expression="check_label_length(SELF, pref_name_len)" label="WR1"/>
      </type>
      <type name="property_code_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) &lt;= property_code_len" label="WR1"/>
      </type>
      <type name="remark_type">
         <typename name="translatable_text"/>
      </type>
      <type name="revision_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) &lt;= revision_len" label="WR1"/>
      </type>
      <type name="short_name_type">
         <typename name="translatable_label"/>
         <where expression="check_label_length(SELF, short_name_len)" label="WR1"/>
      </type>
      <type name="source_doc_type">
         <typename name="identifier"/>
         <where expression="LENGTH(SELF) &lt;= source_doc_len" label="WR1"/>
      </type>
      <type name="supplier_code_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) &lt;= supplier_code_len" label="WR1"/>
      </type>
      <type name="syn_name_type">
         <select selectitems="label_with_language label"/>
         <where expression="check_syn_length(SELF, syn_name_len)" label="WR1"/>
      </type>
      <type name="value_code_type">
         <typename name="identifier"/>
         <where expression="LENGTH(SELF) &lt;= value_code_len" label="WR1"/>
      </type>
      <type name="value_format_type">
         <typename name="identifier"/>
         <where expression="LENGTH(SELF) &lt;= value_format_len" label="WR1"/>
      </type>
      <type name="value_type">
         <select selectitems="value_code_type integer_type"/>
      </type>
      <type name="version_type">
         <typename name="code_type"/>
         <where expression="LENGTH(SELF) &lt;= version_len" label="WR1"/>
         <where expression="EXISTS(VALUE(SELF)) AND ('INTEGER' IN TYPEOF(VALUE(SELF)))&#10;        AND (VALUE(SELF) &gt;= 0)" label="WR2"/>
      </type>
      <entity name="axis1_placement_type" supertypes="placement_type">
         <where expression="'GEOMETRY_SCHEMA.AXIS1_PLACEMENT' IN&#10;        SELF\entity_instance_type.type_name" label="WR1"/>
      </entity>
      <entity name="axis2_placement_2d_type" supertypes="placement_type">
         <where expression="'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D'&#10;        IN SELF\entity_instance_type.type_name" label="WR1"/>
      </entity>
      <entity name="axis2_placement_3d_type" supertypes="placement_type">
         <where expression="'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' &#10;        IN SELF\entity_instance_type.type_name" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="basic_semantic_unit" super.expression="ONEOF (supplier_BSU, class_BSU, property_BSU, data_type_BSU, supplier_related_BSU, class_related_BSU)">
         <explicit name="code">
            <typename name="code_type"/>
         </explicit>
         <explicit name="version">
            <typename name="version_type"/>
         </explicit>
         <derived expression="code + sep_cv + version" name="dic_identifier">
            <typename name="identifier"/>
         </derived>
         <inverse attribute="identified_by" entity="dictionary_element" name="definition">
            <inverse.aggregate lower="0" type="SET" upper="1"/>
         </inverse>
         <inverse attribute="dictionary_definition" entity="content_item" name="referenced_by">
            <inverse.aggregate lower="0" type="SET" upper="1"/>
         </inverse>
      </entity>
      <entity name="boolean_type" supertypes="simple_type"/>
      <entity abstract.supertype="YES" name="class" super.expression="item_class" supertypes="class_and_property_elements">
         <explicit name="identified_by">
            <typename name="class_BSU"/>
            <redeclaration entity-ref="dictionary_element"/>
         </explicit>
         <explicit name="its_superclass" optional="YES">
            <typename name="class_BSU"/>
         </explicit>
         <explicit name="described_by">
            <aggregate lower="0" type="LIST" unique="YES" upper="?"/>
            <typename name="property_BSU"/>
         </explicit>
         <explicit name="defined_types">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="data_type_BSU"/>
         </explicit>
         <derived expression="identified_by.subclasses" name="subclasses">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="class"/>
         </derived>
         <derived expression="compute_known_applicable_properties(&#10;            SELF\dictionary_element.identified_by)" name="known_applicable_properties">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="property_BSU"/>
         </derived>
         <derived expression="compute_known_applicable_data_types(&#10;            SELF\dictionary_element.identified_by)" name="known_applicable_data_types">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="data_type_BSU"/>
         </derived>
         <inverse attribute="relating_class" entity="class_BSU_relationship" name="associated_items">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <where expression="acyclic_superclass_relationship(SELF.identified_by, [])" label="WR1"/>
         <where expression="NOT all_class_descriptions_reachable(&#10;        SELF\dictionary_element.identified_by)&#10;        OR (list_to_set(SELF.described_by) &lt;= &#10;        SELF\dictionary_element.identified_by&#10;        \class_BSU.known_visible_properties)" label="WR2"/>
         <where expression="NOT all_class_descriptions_reachable(&#10;        SELF\dictionary_element.identified_by)&#10;        OR (SELF.defined_types &lt;= &#10;        SELF\dictionary_element.identified_by&#10;        \class_BSU.known_visible_data_types)" label="WR3"/>
         <where expression="check_properties_applicability(SELF)" label="WR4"/>
         <where expression="check_datatypes_applicability(SELF)" label="WR5"/>
      </entity>
      <entity name="class_BSU" supertypes="basic_semantic_unit">
         <explicit name="code">
            <typename name="class_code_type"/>
            <redeclaration entity-ref="basic_semantic_unit"/>
         </explicit>
         <explicit name="defined_by">
            <typename name="supplier_BSU"/>
         </explicit>
         <derived expression="defined_by.absolute_id + sep_id + dic_identifier" name="absolute_id">
            <typename name="identifier"/>
         </derived>
         <derived expression="compute_known_visible_properties(SELF)" name="known_visible_properties">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="property_BSU"/>
         </derived>
         <derived expression="compute_known_visible_data_types(SELF)" name="known_visible_data_types">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="data_type_BSU"/>
         </derived>
         <inverse attribute="its_superclass" entity="class" name="subclasses">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <inverse attribute="name_scope" entity="property_BSU" name="added_visible_properties">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <inverse attribute="name_scope" entity="data_type_BSU" name="added_visible_data_types">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <unique label="UR1">
            <unique.attribute attribute="absolute_id"/>
         </unique>
      </entity>
      <entity abstract.supertype="YES" name="class_BSU_relationship">
         <explicit name="relating_class">
            <typename name="class"/>
         </explicit>
         <explicit name="related_tokens">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="class_related_BSU"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="class_and_property_elements" super.expression="ONEOF (property_DET, class)" supertypes="dictionary_element">
         <explicit name="names">
            <typename name="item_names"/>
         </explicit>
         <explicit name="definition">
            <typename name="definition_type"/>
         </explicit>
         <explicit name="source_doc_of_definition" optional="YES">
            <typename name="document"/>
         </explicit>
         <explicit name="note" optional="YES">
            <typename name="note_type"/>
         </explicit>
         <explicit name="remark" optional="YES">
            <typename name="remark_type"/>
         </explicit>
      </entity>
      <entity name="class_instance_type" supertypes="complex_type">
         <explicit name="domain">
            <typename name="class_BSU"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="class_related_BSU" supertypes="basic_semantic_unit"/>
      <entity name="class_value_assignment">
         <explicit name="super_class_defined_property">
            <typename name="property_BSU"/>
         </explicit>
         <explicit name="assigned_value">
            <typename name="value_code_type"/>
         </explicit>
         <where expression="definition_available_implies(super_class_defined_property, &#10;        ('ISO13584_IEC61360_DICTIONARY_SCHEMA'&#10;        +'.NON_QUANTITATIVE_CODE_TYPE' IN TYPEOF(&#10;        super_class_defined_property.&#10;        definition[1]\property_DET.domain)))" label="WR1"/>
         <where expression="definition_available_implies(super_class_defined_property, &#10;        (SIZEOF(QUERY(v &lt;* &#10;        super_class_defined_property.&#10;        definition[1]\property_DET.domain&#10;        \non_quantitative_code_type.domain.its_values |&#10;        assigned_value = v.value_code)) = 1))" label="WR2"/>
      </entity>
      <entity abstract.supertype="YES" name="complex_type" super.expression="ONEOF (level_type, class_instance_type, entity_instance_type)" supertypes="data_type"/>
      <entity name="component_class" supertypes="item_class"/>
      <entity name="condition_DET" supertypes="property_DET"/>
      <entity abstract.supertype="YES" name="content_item">
         <explicit name="dictionary_definition">
            <typename name="basic_semantic_unit"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="data_type" super.expression="ONEOF (simple_type, complex_type, named_type)"/>
      <entity name="data_type_BSU" supertypes="basic_semantic_unit">
         <explicit name="code">
            <typename name="data_type_code_type"/>
            <redeclaration entity-ref="basic_semantic_unit"/>
         </explicit>
         <explicit name="name_scope">
            <typename name="class_BSU"/>
         </explicit>
         <derived expression="name_scope.defined_by.absolute_id   &#10;        + sep_id + name_scope.dic_identifier    &#10;        + sep_id + dic_identifier" name="absolute_id">
            <typename name="identifier"/>
         </derived>
         <inverse attribute="defined_types" entity="class" name="defining_class">
            <inverse.aggregate lower="0" type="SET" upper="1"/>
         </inverse>
         <unique>
            <unique.attribute attribute="absolute_id"/>
         </unique>
         <where expression="is_subclass(defining_class[1], name_scope.definition[1])" label="WR1"/>
      </entity>
      <entity name="data_type_element" supertypes="dictionary_element">
         <explicit name="identified_by">
            <typename name="data_type_BSU"/>
            <redeclaration entity-ref="dictionary_element"/>
         </explicit>
         <explicit name="names">
            <typename name="item_names"/>
         </explicit>
         <explicit name="type_definition">
            <typename name="data_type"/>
         </explicit>
      </entity>
      <entity name="dates">
         <explicit name="date_of_original_definition">
            <typename name="date_type"/>
         </explicit>
         <explicit name="date_of_current_version">
            <typename name="date_type"/>
         </explicit>
         <explicit name="date_of_current_revision" optional="YES">
            <typename name="date_type"/>
         </explicit>
      </entity>
      <entity name="dependent_P_DET" supertypes="property_DET">
         <explicit name="depends_on">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="property_BSU"/>
         </explicit>
         <where expression="QUERY(p &lt;* depends_on | NOT(definition_available_implies(&#10;        p, ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CONDITION_DET'&#10;        IN TYPEOF(p.definition[1]))))) = []" label="WR1"/>
      </entity>
      <entity name="dic_unit">
         <explicit name="structured_representation">
            <typename name="unit"/>
         </explicit>
         <explicit name="string_representation" optional="YES">
            <typename name="mathematical_string"/>
         </explicit>
      </entity>
      <entity name="dic_value">
         <explicit name="value_code">
            <typename name="value_type"/>
         </explicit>
         <explicit name="meaning">
            <typename name="item_names"/>
         </explicit>
         <explicit name="source_doc_of_value" optional="YES">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="dictionary_element" super.expression="ONEOF (supplier_element, class_and_property_elements, data_type_element)">
         <explicit name="identified_by">
            <typename name="basic_semantic_unit"/>
         </explicit>
         <explicit name="time_stamps" optional="YES">
            <typename name="dates"/>
         </explicit>
         <explicit name="revision">
            <typename name="revision_type"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="document"/>
      <entity name="entity_instance_type" supertypes="complex_type">
         <explicit name="type_name">
            <aggregate lower="0" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="graphics"/>
      <entity name="identified_document" supertypes="document">
         <explicit name="document_identifier">
            <typename name="source_doc_type"/>
         </explicit>
      </entity>
      <entity name="int_currency_type" supertypes="int_type">
         <explicit name="currency" optional="YES">
            <typename name="currency_code"/>
         </explicit>
      </entity>
      <entity name="int_measure_type" supertypes="int_type">
         <explicit name="unit">
            <typename name="dic_unit"/>
         </explicit>
      </entity>
      <entity name="int_type" super.expression="ONEOF (int_measure_type, int_currency_type, non_quantitative_int_type)" supertypes="number_type"/>
      <entity name="item_class" super.expression="ONEOF (component_class, material_class)" supertypes="class">
         <explicit name="simplified_drawing" optional="YES">
            <typename name="graphics"/>
         </explicit>
         <explicit name="sub_class_properties">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="property_BSU"/>
         </explicit>
         <explicit name="class_constant_values">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="class_value_assignment"/>
         </explicit>
         <explicit name="coded_name" optional="YES">
            <typename name="value_code_type"/>
         </explicit>
         <where expression="QUERY(p &lt;* sub_class_properties&#10;        | NOT(p IN SELF.described_by)) = []" label="WR1"/>
         <where expression="NOT all_class_descriptions_reachable(SELF.identified_by) OR&#10;        (QUERY(va &lt;* class_constant_values | SIZEOF(QUERY(c &lt;*&#10;        va.super_class_defined_property.describes_classes |&#10;        is_subclass(SELF, c) &#10;        AND (va.super_class_defined_property &#10;        IN c\item_class.sub_class_properties))) &lt;&gt; 1) = [])" label="WR2"/>
      </entity>
      <entity name="item_names">
         <explicit name="preferred_name">
            <typename name="pref_name_type"/>
         </explicit>
         <explicit name="synonymous_names">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="syn_name_type"/>
         </explicit>
         <explicit name="short_name">
            <typename name="short_name_type"/>
         </explicit>
         <explicit name="languages" optional="YES">
            <typename name="present_translations"/>
         </explicit>
         <explicit name="icon" optional="YES">
            <typename name="graphics"/>
         </explicit>
         <where expression="NOT(EXISTS(languages )) OR (&#10;        ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'&#10;        + '.TRANSLATED_LABEL' IN TYPEOF(preferred_name))&#10;        AND (languages :=: preferred_name\translated_label.languages)&#10;        AND ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'&#10;        + '.TRANSLATED_LABEL' IN TYPEOF(short_name))&#10;        AND (languages :=: short_name\translated_label.languages)&#10;        AND (QUERY(s &lt;* synonymous_names |&#10;        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + &#10;        '.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []))" label="WR1"/>
         <where expression="NOT EXISTS(languages) OR (QUERY(s &lt;* synonymous_names |&#10;        EXISTS(s.language) AND NOT(s.language IN&#10;        QUERY(l &lt;* languages.language_codes | TRUE&#10;        ))) = [])" label="WR2"/>
         <where expression="at_most_two_synonyms_per_language(languages, &#10;        synonymous_names)" label="WR3"/>
      </entity>
      <entity name="label_with_language">
         <explicit name="l">
            <typename name="label"/>
         </explicit>
         <explicit name="language">
            <typename name="language_code"/>
         </explicit>
      </entity>
      <entity name="level_type" supertypes="complex_type">
         <explicit name="levels">
            <aggregate lower="1" type="LIST" unique="YES" upper="4"/>
            <typename name="level"/>
         </explicit>
         <explicit name="value_type">
            <typename name="simple_type"/>
         </explicit>
         <where expression="'ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'&#10;        IN TYPEOF(value_type)" label="WR1"/>
      </entity>
      <entity name="material_class" supertypes="item_class"/>
      <entity name="mathematical_string">
         <explicit name="text_representation">
            <typename name="text"/>
         </explicit>
         <explicit name="SGML_representation" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="named_type" supertypes="data_type">
         <explicit name="referred_type">
            <typename name="data_type_BSU"/>
         </explicit>
      </entity>
      <entity name="non_dependent_P_DET" supertypes="property_DET"/>
      <entity name="non_quantitative_code_type" supertypes="string_type">
         <explicit name="domain">
            <typename name="value_domain"/>
         </explicit>
         <where expression="QUERY(v &lt;* domain.its_values | &#10;        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN&#10;        TYPEOF(v.value_code))) = []" label="WR1"/>
      </entity>
      <entity name="non_quantitative_int_type" supertypes="int_type">
         <explicit name="domain">
            <typename name="value_domain"/>
         </explicit>
         <where expression="QUERY(v &lt;* domain.its_values | &#10;        'ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN&#10;        TYPEOF(v.value_code)) = []" label="WR1"/>
      </entity>
      <entity name="non_si_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="number_type" super.expression="ONEOF (int_type, real_type)" supertypes="simple_type"/>
      <entity name="placement_type" super.expression="ONEOF (axis1_placement_type, axis2_placement_2d_type, axis2_placement_3d_type)" supertypes="entity_instance_type">
         <where expression="'GEOMETRY_SCHEMA.PLACEMENT' &#10;        IN SELF\entity_instance_type.type_name" label="WR1"/>
      </entity>
      <entity name="property_BSU" supertypes="basic_semantic_unit">
         <explicit name="code">
            <typename name="property_code_type"/>
            <redeclaration entity-ref="basic_semantic_unit"/>
         </explicit>
         <explicit name="name_scope">
            <typename name="class_BSU"/>
         </explicit>
         <derived expression="name_scope.defined_by.absolute_id&#10;        + sep_id + name_scope.dic_identifier&#10;        + sep_id + dic_identifier" name="absolute_id">
            <typename name="identifier"/>
         </derived>
         <inverse attribute="described_by" entity="class" name="describes_classes">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <unique label="UR1">
            <unique.attribute attribute="absolute_id"/>
         </unique>
         <where expression="QUERY(c &lt;* describes_classes |&#10;        NOT(is_subclass(c, name_scope.definition[1])))= []" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="property_DET" super.expression="ONEOF (condition_DET, dependent_P_DET, non_dependent_P_DET)" supertypes="class_and_property_elements">
         <explicit name="identified_by">
            <typename name="property_BSU"/>
            <redeclaration entity-ref="dictionary_element"/>
         </explicit>
         <explicit name="preferred_symbol" optional="YES">
            <typename name="mathematical_string"/>
         </explicit>
         <explicit name="synonymous_symbols">
            <aggregate lower="0" type="SET" upper="2"/>
            <typename name="mathematical_string"/>
         </explicit>
         <explicit name="figure" optional="YES">
            <typename name="graphics"/>
         </explicit>
         <explicit name="det_classification" optional="YES">
            <typename name="DET_classification_type"/>
         </explicit>
         <explicit name="domain">
            <typename name="data_type"/>
         </explicit>
         <explicit name="formula" optional="YES">
            <typename name="mathematical_string"/>
         </explicit>
         <derived expression="identified_by.describes_classes" name="describes_classes">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="class"/>
         </derived>
      </entity>
      <entity name="real_currency_type" supertypes="real_type">
         <explicit name="currency" optional="YES">
            <typename name="currency_code"/>
         </explicit>
      </entity>
      <entity name="real_measure_type" supertypes="real_type">
         <explicit name="unit">
            <typename name="dic_unit"/>
         </explicit>
      </entity>
      <entity name="real_type" super.expression="ONEOF (real_measure_type, real_currency_type)" supertypes="number_type"/>
      <entity abstract.supertype="YES" name="simple_type" super.expression="ONEOF (number_type, boolean_type, string_type)" supertypes="data_type">
         <explicit name="value_format">
            <typename name="value_format_type"/>
         </explicit>
      </entity>
      <entity name="string_type" supertypes="simple_type"/>
      <entity name="supplier_BSU" supertypes="basic_semantic_unit">
         <explicit name="code">
            <typename name="supplier_code_type"/>
            <redeclaration entity-ref="basic_semantic_unit"/>
         </explicit>
         <derived expression="'1'" name="version">
            <typename name="version_type"/>
            <redeclaration entity-ref="basic_semantic_unit"/>
         </derived>
         <derived expression="SELF\basic_semantic_unit.code" name="absolute_id">
            <typename name="identifier"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="absolute_id"/>
         </unique>
      </entity>
      <entity abstract.supertype="YES" name="supplier_BSU_relationship">
         <explicit name="relating_supplier">
            <typename name="supplier_element"/>
         </explicit>
         <explicit name="related_tokens">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="supplier_related_BSU"/>
         </explicit>
      </entity>
      <entity name="supplier_element" supertypes="dictionary_element">
         <explicit name="identified_by">
            <typename name="supplier_BSU"/>
            <redeclaration entity-ref="dictionary_element"/>
         </explicit>
         <explicit name="org">
            <typename name="organization"/>
         </explicit>
         <explicit name="addr">
            <typename name="address"/>
         </explicit>
         <inverse attribute="relating_supplier" entity="supplier_BSU_relationship" name="associated_items">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity abstract.supertype="YES" name="supplier_related_BSU" supertypes="basic_semantic_unit"/>
      <entity name="value_domain">
         <explicit name="its_values">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="dic_value"/>
         </explicit>
         <explicit name="source_doc_of_value_domain" optional="YES">
            <typename name="document"/>
         </explicit>
         <explicit name="languages" optional="YES">
            <typename name="present_translations"/>
         </explicit>
         <explicit name="terms">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="item_names"/>
         </explicit>
         <where expression="NOT EXISTS(languages) OR (QUERY(v &lt;* its_values |&#10;        languages :&lt;&gt;: v.meaning.languages) = [])" label="WR1"/>
         <where expression="codes_are_unique(its_values)" label="WR2"/>
      </entity>
      <rule appliesto="named_unit" name="assert_ONEOF">
         <where expression="QUERY(u &lt;* named_unit | &#10;        ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' &#10;        IN TYPEOF(u)) AND&#10;        ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u))&#10;        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' &#10;        IN TYPEOF(u)) AND&#10;        ('MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u))&#10;        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT'&#10;        IN TYPEOF(u)) AND&#10;        ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u))&#10;        ) = []" label="no_label_1"/>
      </rule>
      <function name="acyclic_superclass_relationship">
         <parameter name="current">
            <typename name="class_BSU"/>
         </parameter>
         <parameter name="visited">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="class"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF SIZEOF(current.definition) = 1 THEN 
    IF current.definition[1] IN visited THEN
        RETURN(FALSE);
    
    ELSE
        IF EXISTS(current.definition[1]\class.its_superclass)
        THEN 
            RETURN(acyclic_superclass_relationship(
                current.definition[1]\class.its_superclass,
                visited + current.definition[1])); 
        ELSE
            RETURN(TRUE);
        END_IF;
    END_IF;
ELSE
    RETURN(UNKNOWN);
END_IF;</algorithm>
      </function>
      <function name="all_class_descriptions_reachable">
         <parameter name="cl">
            <typename name="class_BSU"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT EXISTS(cl)
THEN
    RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(FALSE);
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
    RETURN(TRUE);
ELSE
    RETURN(all_class_descriptions_reachable(
        cl.definition[1]\class.its_superclass));
END_IF;</algorithm>
      </function>
      <function name="at_most_two_synonyms_per_language">
         <parameter name="languages">
            <typename name="present_translations"/>
         </parameter>
         <parameter name="synonymous_names">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="syn_name_type"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(languages) THEN
    REPEAT i := 1 TO SIZEOF(languages.language_codes);
        IF SIZEOF(QUERY(s &lt;* synonymous_names |
            s.language = languages.language_codes[i])) &gt; 2
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;
    RETURN(TRUE);
ELSE
    RETURN(SIZEOF(synonymous_names) &lt;= 2);
END_IF;</algorithm>
      </function>
      <function name="check_datatypes_applicability">
         <parameter name="cl">
            <typename name="class"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    inter: SET OF data_type_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition) = 1)
    THEN
        inter := cl.defined_types * 
            cl.its_superclass.definition[1]\class.
            known_applicable_data_types;
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;</algorithm>
      </function>
      <function name="check_properties_applicability">
         <parameter name="cl">
            <typename name="class"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    inter: SET OF property_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition)=1)
    THEN
        inter := (list_to_set(cl.described_by) * 
            cl.its_superclass.definition[1]\class.
            known_applicable_properties);
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;</algorithm>
      </function>
      <function name="check_syn_length">
         <parameter name="s">
            <typename name="syn_name_type"/>
         </parameter>
         <parameter name="s_length">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA.LABEL_WITH_LANGUAGE' 
    IN TYPEOF(s)
THEN 
    RETURN(LENGTH(s.l) &lt;= s_length); 
ELSE
    RETURN(LENGTH(s) &lt;= s_length); 
END_IF;</algorithm>
      </function>
      <function name="codes_are_unique">
         <parameter name="values">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="dic_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    ls: SET OF STRING := [];
    li: SET OF INTEGER := [];
END_LOCAL;

IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN 
    TYPEOF(values[1].value_code))
THEN
    REPEAT i := 1 TO SIZEOF(values);
        ls := ls + values[i].value_code;
    END_REPEAT;

    RETURN(SIZEOF(values) = SIZEOF(ls));
ELSE
    IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.INTEGER_TYPE' IN 
        TYPEOF(values[1].value_code))
    THEN
        REPEAT i := 1 TO SIZEOF(values);
            li := li + values[i].value_code;
        END_REPEAT;

        RETURN(SIZEOF(values) = SIZEOF(li));
    ELSE
        RETURN(UNKNOWN);
    END_IF;
END_IF;</algorithm>
      </function>
      <function name="compute_known_applicable_data_types">
         <parameter name="cl">
            <typename name="class_BSU"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="data_type_BSU"/>
         <algorithm>LOCAL
    s: SET OF data_type_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
        s := s + cl.definition[1]\class.defined_types[i];
    END_REPEAT;
    
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_applicable_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;</algorithm>
      </function>
      <function name="compute_known_applicable_properties">
         <parameter name="cl">
            <typename name="class_BSU"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="property_BSU"/>
         <algorithm>LOCAL 
    s: SET OF property_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition)=0
THEN 
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
        s := s + cl.definition[1]\class.described_by[i];
    END_REPEAT;

    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN 
        s := s + compute_known_applicable_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s); 
END_IF;</algorithm>
      </function>
      <function name="compute_known_visible_data_types">
         <parameter name="cl">
            <typename name="class_BSU"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="data_type_BSU"/>
         <algorithm>LOCAL
    s: SET OF data_type_BSU :=[ ];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.DATA_TYPE_BSU.NAME_SCOPE');

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_visible_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s);
END_IF;</algorithm>
      </function>
      <function name="compute_known_visible_properties">
         <parameter name="cl">
            <typename name="class_BSU"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="property_BSU"/>
         <algorithm>LOCAL
    s: SET OF property_BSU := [];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.PROPERTY_BSU.NAME_SCOPE');
IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) THEN
        s := s + compute_known_visible_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;</algorithm>
      </function>
      <function name="definition_available_implies">
         <parameter name="BSU">
            <typename name="basic_semantic_unit"/>
         </parameter>
         <parameter name="expression">
            <builtintype type="LOGICAL"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>RETURN(NOT(SIZEOF(BSU.definition) = 1) OR expression);</algorithm>
      </function>
      <function name="is_subclass">
         <parameter name="sub">
            <typename name="class"/>
         </parameter>
         <parameter name="super">
            <typename name="class"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF (NOT EXISTS(sub)) OR (NOT EXISTS(super)) THEN
        RETURN(UNKNOWN);
    END_IF;
    
    IF sub = super
    THEN
        RETURN(TRUE);
    END_IF;
    
    IF NOT EXISTS(sub.its_superclass) 
    THEN
        
        RETURN(FALSE); 
    END_IF;
    
    IF SIZEOF(sub.its_superclass.definition) = 1 
    THEN


        IF (sub.its_superclass.definition[1] = super) 
        THEN
            RETURN(TRUE);
        ELSE
            RETURN(is_subclass(sub.its_superclass.definition[1],
                super));
        END_IF;
    ELSE
        RETURN(UNKNOWN);
    END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="type_elem"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="GENERIC" typelabel="type_elem"/>
         <algorithm>LOCAL
    s: SET OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
END_REPEAT;

RETURN(s);</algorithm>
      </function>
      <function name="string_for_SI_unit">
         <parameter name="unit">
            <typename name="si_unit"/>
         </parameter>
         <builtintype type="STRING"/>
         <algorithm>LOCAL
    prefix_string, unit_string: STRING;
END_LOCAL;

IF EXISTS(unit.prefix) THEN
    CASE unit.prefix OF
        exa     : prefix_string := 'E';
        peta        : prefix_string := 'P';
        tera        : prefix_string := 'T';
        giga        : prefix_string := 'G';
        mega        : prefix_string := 'M';
        kilo        : prefix_string := 'k';
        hecto   : prefix_string := 'h';
        deca        : prefix_string := 'da';
        deci        : prefix_string := 'd';
        centi   : prefix_string := 'c';
        milli   : prefix_string := 'm';
        micro   : prefix_string := 'u';
        nano        : prefix_string := 'n';
        pico        : prefix_string := 'p';
        femto   : prefix_string := 'f';
        atto        : prefix_string := 'a';
    END_CASE;
ELSE
    prefix_string := '';
END_IF;

CASE unit.name OF
    metre           : unit_string:= 'm'; 
    gram                : unit_string := 'g'; 
    second          : unit_string := 's'; 
    ampere          : unit_string := 'A'; 
    kelvin          : unit_string := 'K'; 
    mole                : unit_string := 'mol'; 
    candela         : unit_string := 'cd'; 
    radian          : unit_string := 'rad'; 
    steradian           : unit_string := 'sr'; 
    hertz           : unit_string := 'Hz'; 
    newton          : unit_string := 'N'; 
    pascal          : unit_string := 'Pa'; 
    joule           : unit_string := 'J'; 
    watt                : unit_string := 'W'; 
    coulomb         : unit_string := 'C'; 
    volt                : unit_string := 'V'; 
    farad           : unit_string := 'F'; 
    ohm             : unit_string := 'Ohm';
    siemens         : unit_string := 'S'; 
    weber           : unit_string := 'Wb'; 
    tesla           : unit_string := 'T'; 
    henry           : unit_string := 'H'; 
    degree_Celsius      : unit_string := 'Cel';
    lumen           : unit_string := 'lm'; 
    lux             : unit_string := 'lx'; 
    becquerel           : unit_string := 'Bq'; 
    gray                : unit_string := 'Gy';
    sievert         : unit_string := 'Sv';
END_CASE;

RETURN(prefix_string + unit_string);</algorithm>
      </function>
      <function name="string_for_derived_unit">
         <parameter name="u">
            <typename name="derived_unit"/>
         </parameter>
         <builtintype type="STRING"/>
         <algorithm>FUNCTION string_for_derived_unit_element(
        u: derived_unit_element; neg_exp: BOOLEAN
        ): STRING;
        

    
    LOCAL
        result: STRING;
    END_LOCAL;
        
    result := string_for_named_unit(u.unit);
    IF (u.exponent &lt;&gt; 0) 
    THEN 
        IF (u.exponent &gt; 0) OR NOT neg_exp 
        THEN
            result := result + '**' + FORMAT(
                ABS(u.exponent), '2I')[2];
        ELSE
            result := result + '**' + FORMAT(u.exponent, '2I')[2];
        END_IF;
    END_IF;
        RETURN(result); 
    END_FUNCTION; -- string_for_derived_unit_element

LOCAL
    pos, neg: SET OF derived_unit_element;
    us: STRING;
END_LOCAL;
    

pos := QUERY(ue &lt;* u.elements | ue.exponent &gt; 0); 
neg := QUERY(ue &lt;* u.elements | ue.exponent &lt; 0); 
us := '';
IF SIZEOF(pos) &gt; 0 THEN
    
    REPEAT i := LOINDEX(pos) TO HIINDEX(pos);
        us := us + string_for_derived_unit_element(pos[i], FALSE);
        IF i &lt;&gt; HIINDEX(pos) 
        THEN
            us := us + '.'; 
        END_IF;
    END_REPEAT;

    IF SIZEOF(neg) &gt; 0 
    THEN 
        

        us := us + '/';

        IF SIZEOF(neg) &gt; 1 
        THEN
            us := us + '('; 
        END_IF;

        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], FALSE);
            IF i &lt;&gt; HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;

        IF SIZEOF(neg) &gt; 1 
        THEN 
            us := us + ')'; 
        END_IF;
    END_IF;
ELSE 
    
    IF SIZEOF(neg) &gt; 0 THEN
        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], TRUE);
            IF i &lt;&gt; HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;
    END_IF;
END_IF;

RETURN(us);</algorithm>
      </function>
      <function name="string_for_named_unit">
         <parameter name="u">
            <typename name="named_unit"/>
         </parameter>
         <builtintype type="STRING"/>
         <algorithm>IF 'MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u) THEN
    RETURN(string_for_SI_unit(u));
ELSE
    IF 'MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u)
    THEN
        RETURN(u\context_dependent_unit.name);
    ELSE
        IF 'MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u)
        THEN
            RETURN(u\conversion_based_unit.name);
        ELSE
            IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA'
                +'.NON_SI_UNIT' IN TYPEOF(u)
            THEN
                RETURN(u\non_si_unit.name);
            ELSE
                RETURN('name_unknown');
            END_IF;
        END_IF;
    END_IF;
END_IF;</algorithm>
      </function>
      <function name="string_for_unit">
         <parameter name="u">
            <typename name="unit"/>
         </parameter>
         <builtintype type="STRING"/>
         <algorithm>IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(u) 
    THEN
        RETURN(string_for_derived_unit(u));
    ELSE 
        RETURN(string_for_named_unit(u));
    END_IF;</algorithm>
      </function>
   </schema>
</express>
