<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-105">
   <application name="JSDAI" owner="LKSoft" source="kinematic_motion_representation_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="kinematic_motion_representation_schema">
      <interface kind="reference" schema="geometry_schema">
         <interfaced.item name="axis2_placement"/>
         <interfaced.item name="placement"/>
         <interfaced.item name="cartesian_point"/>
         <interfaced.item name="curve"/>
         <interfaced.item name="geometric_representation_context"/>
         <interfaced.item name="geometric_representation_item"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="length_measure"/>
         <interfaced.item name="measure_with_unit"/>
         <interfaced.item name="parameter_value"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="unit"/>
      </interface>
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="founded_item"/>
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_defined_transformation"/>
         <interfaced.item name="item_in_context"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="representation_relationship"/>
         <interfaced.item name="definitional_representation_relationship"/>
         <interfaced.item name="representation_relationship_with_transformation"/>
         <interfaced.item name="using_representations"/>
      </interface>
      <interface kind="reference" schema="kinematic_structure_schema">
         <interfaced.item name="kinematic_link_representation"/>
         <interfaced.item name="rigid_placement"/>
      </interface>
      <interface kind="reference" schema="kinematic_state_schema">
         <interfaced.item name="rotation_about_direction"/>
         <interfaced.item name="spatial_rotation"/>
         <interfaced.item name="ypr_rotation"/>
         <interfaced.item name="mechanism_state_representation"/>
      </interface>
      <interface kind="reference" schema="product_property_representation_schema">
         <interfaced.item name="shape_representation"/>
      </interface>
      <type name="interpolation_type">
         <enumeration items="undefined discontinuous synchronous linear"/>
      </type>
      <type name="link_or_shape_representation">
         <select selectitems="kinematic_link_representation shape_representation"/>
      </type>
      <type name="transform_or_placement">
         <select selectitems="transform axis2_placement"/>
      </type>
      <entity name="circular_path" supertypes="path_element">
         <explicit name="via_point">
            <typename name="cartesian_point"/>
         </explicit>
         <where expression="SELF\path_element.node_to.control_transform.translation_component &lt;&gt;&#10;       SELF\path_element.node_from.control_transform.translation_component" label="WR1"/>
      </entity>
      <entity name="composite_path" supertypes="kinematic_path">
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="path_element_connection"/>
         </explicit>
         <explicit name="t_start">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="t_end">
            <typename name="parameter_value"/>
         </explicit>
         <where expression="t_start &lt; t_end" label="WR1"/>
         <where expression="connected_in_simple_path (elements)" label="WR2"/>
      </entity>
      <entity name="curve_based_path" supertypes="path_element">
         <explicit name="path_curve">
            <typename name="curve"/>
         </explicit>
         <where expression="SELF\path_element.node_to.control_transform.translation_component &lt;&gt;&#10;       SELF\path_element.node_from.control_transform.translation_component" label="WR1"/>
      </entity>
      <entity name="geometric_representation_context_with_parameter" supertypes="geometric_representation_context">
         <explicit name="parameter_unit" optional="YES">
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="interpolated_configuration_representation" supertypes="representation">
         <explicit name="context_of_items">
            <typename name="geometric_representation_context_with_parameter"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="interpolated_configuration_sequence"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="interpolated_configuration_segment" supertypes="founded_item">
         <explicit name="state">
            <typename name="mechanism_state_representation"/>
         </explicit>
         <explicit name="t_parameter">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="interpolation">
            <typename name="interpolation_type"/>
         </explicit>
      </entity>
      <entity name="interpolated_configuration_sequence" supertypes="representation_item">
         <explicit name="segments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="interpolated_configuration_segment"/>
         </explicit>
         <derived expression="SIZEOF(segments)" name="n_segments">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="segments[n_segments].interpolation &lt;&gt; discontinuous" name="closed_interpoltation">
            <builtintype type="LOGICAL"/>
         </derived>
      </entity>
      <entity name="kinematic_path" super.expression="ONEOF (path_element, composite_path)" supertypes="geometric_representation_item">
         <where expression="SIZEOF(QUERY(using_rep &lt;* using_representations(SELF)| &#10;        NOT('KINEMATIC_MOTION_REPRESENTATION_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT_WITHPARAMETER' IN TYPEOF(using_rep.context_of_items))))= 0" label="WR1"/>
      </entity>
      <entity name="linear_path" supertypes="path_element"/>
      <entity name="link_motion_relationship" supertypes="representation_relationship_with_transformation definitional_representation_relationship">
         <explicit name="rep_1">
            <typename name="link_or_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="link_motion_representation_along_path"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="transformation_operator">
            <typename name="link_motion_transformation"/>
            <redeclaration entity-ref="representation_relationship_with_transformation"/>
         </explicit>
         <where expression="rep_1 IN using_representations(transformation_operator\item_defined_transformation.transform_item_1)" label="WR1"/>
         <where expression="item_in_context(transformation_operator\item_defined_transformation.transform_item_2, rep_2)" label="WR2"/>
      </entity>
      <entity name="link_motion_representation_along_path" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="kinematic_path"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="geometric_representation_context_with_parameter"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="link_motion_transformation" supertypes="item_defined_transformation">
         <explicit name="transform_item_1">
            <typename name="rigid_placement"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="kinematic_path"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
      </entity>
      <entity name="path_element" super.expression="ONEOF (point_to_point_path, circular_path, linear_path, curve_based_path)" supertypes="kinematic_path">
         <explicit name="node_from">
            <typename name="path_node"/>
         </explicit>
         <explicit name="node_to">
            <typename name="path_node"/>
         </explicit>
         <where expression="node_from.t_parameter &lt; node_to.t_parameter" label="WR1"/>
      </entity>
      <entity name="path_element_connection" supertypes="founded_item">
         <explicit name="previous_element">
            <typename name="path_element"/>
         </explicit>
         <explicit name="next_element">
            <typename name="path_element"/>
         </explicit>
         <where expression="previous_element.node_to = next_element.node_from" label="WR1"/>
      </entity>
      <entity name="path_node" supertypes="geometric_representation_item">
         <explicit name="control_transform">
            <typename name="transform_or_placement"/>
         </explicit>
         <explicit name="t_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_to_point_path" supertypes="path_element"/>
      <entity name="transform" supertypes="functionally_defined_transformation geometric_representation_item">
         <explicit name="rotation_component">
            <typename name="spatial_rotation"/>
         </explicit>
         <explicit name="translation_component">
            <typename name="translation"/>
         </explicit>
      </entity>
      <entity name="translation" supertypes="geometric_representation_item">
         <explicit name="offset">
            <aggregate lower="2" type="LIST" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <subtype.constraint entity="representation" name="kmr_representation_subtypes" super.expression="ONEOF (interpolated_configuration_representation, link_motion_representation_along_path)"/>
      <subtype.constraint entity="geometric_representation_item" name="kmr_geometric_representation_item_subtypes" super.expression="ONEOF (kinematic_path, path_node, placement, transform, translation)"/>
      <function name="connected_in_simple_path">
         <parameter name="connections">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="path_element_connection"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     connection_set : SET [0 : ?] OF path_element_connection;
     nec0           : INTEGER;
     pec0           : INTEGER;
     necbranch      : INTEGER;
     pecbranch      : INTEGER;
  END_LOCAL;

  IF SIZEOF (connections) &gt; 1 THEN
    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) = 0);
    nec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) = 0);
    pec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) &gt; 1);
    necbranch := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) &gt; 1);
    pecbranch := SIZEOF (connection_set);

    IF ((nec0 &lt;&gt; 1) OR (pec0 &lt;&gt; 1) OR (necbranch &gt; 0) OR (pecbranch &gt; 0)) THEN
      RETURN (FALSE);
    ELSE
      RETURN (TRUE);
    END_IF;
  ELSE
    RETURN (TRUE);
  END_IF;</algorithm>
      </function>
   </schema>
</express>
