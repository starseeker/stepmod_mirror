<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-105">
   <application name="JSDAI" owner="LKSoft" source="kinematic_motion_representation_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="kinematic_motion_representation_schema">
      <interface kind="reference" schema="geometry_schema">
         <interfaced.item name="axis2_placement"/>
         <interfaced.item name="placement"/>
         <interfaced.item name="cartesian_point"/>
         <interfaced.item name="curve"/>
         <interfaced.item name="geometric_representation_context"/>
         <interfaced.item name="geometric_representation_item"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="length_measure"/>
         <interfaced.item name="measure_with_unit"/>
         <interfaced.item name="parameter_value"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="unit"/>
      </interface>
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="founded_item"/>
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_defined_transformation"/>
         <interfaced.item name="item_in_context"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="representation_relationship"/>
         <interfaced.item name="definitional_representation_relationship"/>
         <interfaced.item name="representation_relationship_with_transformation"/>
         <interfaced.item name="using_representations"/>
      </interface>
      <interface kind="reference" schema="kinematic_structure_schema">
         <interfaced.item name="kinematic_link_representation"/>
         <interfaced.item name="rigid_placement"/>
      </interface>
      <interface kind="reference" schema="kinematic_state_schema">
         <interfaced.item name="rotation_about_direction"/>
         <interfaced.item name="spatial_rotation"/>
         <interfaced.item name="ypr_rotation"/>
      </interface>
      <interface kind="reference" schema="product_property_representation_schema">
         <interfaced.item name="shape_representation"/>
      </interface>
      <type name="link_or_shape_representation">
         <select selectitems="kinematic_link_representation shape_representation"/>
      </type>
      <type name="motion_parameter_measure">
         <select selectitems="parameter_value measure_with_unit"/>
      </type>
      <type name="transform_or_placement">
         <select selectitems="transform axis2_placement"/>
      </type>
      <entity name="circular_path" supertypes="path_element">
         <explicit name="via_point">
            <typename name="cartesian_point"/>
         </explicit>
         <where expression="SELF\path_element.node_to.control_transform.translation_component &lt;&gt;&#10;       SELF\path_element.node_from.control_transform.translation_component" label="WR1"/>
         <where expression="non_coincident_coordinates (via_point,&#10;         SELF\path_element.node_from.control_transform.translation_component)&#10;       AND&#10;       non_coincident_coordinates (via_point,&#10;         SELF\path_element.node_to.control_transform.translation_component)" label="WR2"/>
      </entity>
      <entity name="composite_path" supertypes="kinematic_path">
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="path_element_connection"/>
         </explicit>
         <explicit name="t_start">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="t_end">
            <typename name="parameter_value"/>
         </explicit>
         <where expression="increasing_measure_value (t_start, t_end)" label="WR1"/>
         <where expression="compare_unit_components (t_start, t_end)" label="WR2"/>
         <where expression="connected_in_simple_path (elements)" label="WR3"/>
      </entity>
      <entity name="curve_based_path" supertypes="path_element">
         <explicit name="path_curve">
            <typename name="curve"/>
         </explicit>
         <where expression="SELF\path_element.node_to.control_transform.translation_component &lt;&gt;&#10;       SELF\path_element.node_from.control_transform.translation_component" label="WR1"/>
      </entity>
      <entity name="geometric_representation_context_with_parameter" supertypes="geometric_representation_context">
         <explicit name="parameter_unit" optional="YES">
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="kinematic_path" super.expression="ONEOF (path_element, composite_path)" supertypes="geometric_representation_item">
         <where expression="SIZEOF(QUERY(using_rep &lt;* using_representations(SELF)| &#10;        NOT('KINEMATIC_MOTION_REPRESENTATION_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT_WITHPARAMETER' IN TYPEOF(using_rep.context_of_items))))= 0" label="WR1"/>
      </entity>
      <entity name="kinematic_path_representation_with_parameter" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="kinematic_path"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="geometric_representation_context_with_parameter"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="linear_path" supertypes="path_element"/>
      <entity name="link_motion_relationship" supertypes="representation_relationship_with_transformation definitional_representation_relationship">
         <explicit name="rep_1">
            <typename name="link_or_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="link_motion_representation_along_path"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="transformation_operator">
            <typename name="link_motion_transformation"/>
            <redeclaration entity-ref="representation_relationship_with_transformation"/>
         </explicit>
         <where expression="rep_1 IN using_representations(transformation_operator\item_defined_transformation.transform_item_1)" label="WR1"/>
         <where expression="item_in_context(transformation_operator\item_defined_transformation.transform_item_2, rep_2)" label="WR2"/>
      </entity>
      <entity name="link_motion_representation_along_path" supertypes="representation">
         <explicit name="context_of_items">
            <typename name="geometric_representation_context_with_parameter"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="link_motion_transformation" supertypes="item_defined_transformation">
         <explicit name="transform_item_1">
            <typename name="rigid_placement"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="kinematic_path"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
      </entity>
      <entity name="path_element" super.expression="ONEOF (point_to_point_path, circular_path, linear_path, curve_based_path)" supertypes="kinematic_path">
         <explicit name="node_from">
            <typename name="path_node"/>
         </explicit>
         <explicit name="node_to">
            <typename name="path_node"/>
         </explicit>
         <where expression="compare_unit_components (node_from.t_parameter,&#10;                                node_to.t_parameter)" label="WR1"/>
         <where expression="increasing_measure_value (node_from.t_parameter,&#10;                                 node_to.t_parameter)" label="WR2"/>
      </entity>
      <entity name="path_element_connection" supertypes="founded_item">
         <explicit name="previous_element">
            <typename name="path_element"/>
         </explicit>
         <explicit name="next_element">
            <typename name="path_element"/>
         </explicit>
         <where expression="previous_element.node_to = next_element.node_from" label="WR1"/>
         <where expression="compare_unit_components (previous_element.node_to.t_parameter,&#10;                                next_element.node_from.t_parameter)" label="WR2"/>
      </entity>
      <entity name="path_node" supertypes="geometric_representation_item">
         <explicit name="control_transform">
            <typename name="transform_or_placement"/>
         </explicit>
         <explicit name="t_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_to_point_path" supertypes="path_element"/>
      <entity name="transform" supertypes="functionally_defined_transformation geometric_representation_item">
         <explicit name="rotation_component">
            <typename name="spatial_rotation"/>
         </explicit>
         <explicit name="translation_component">
            <typename name="translation"/>
         </explicit>
      </entity>
      <entity name="translation" supertypes="geometric_representation_item">
         <explicit name="offset">
            <aggregate lower="2" type="LIST" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <subtype.constraint entity="representation" name="kmr_representation_subtypes" super.expression="ONEOF (kinematic_path_representation_with_parameter, link_motion_representation_along_path)"/>
      <subtype.constraint entity="geometric_representation_item" name="kmr_geometric_representation_item_subtypes" super.expression="ONEOF (kinematic_path, path_node, placement, transform, translation)"/>
      <function name="compare_unit_components">
         <parameter name="parm1">
            <typename name="motion_parameter_measure"/>
         </parameter>
         <parameter name="parm2">
            <typename name="motion_parameter_measure"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm1)) AND
       ('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm2))) THEN
         RETURN (TRUE);
   ELSE
     IF (('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm1)) AND
         ('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm2))) THEN
        IF (parm1.unit_component :=: parm2.unit_component) THEN
           RETURN (TRUE);
        ELSE
           RETURN (FALSE);
        END_IF;
     ELSE
       RETURN (FALSE);
     END_IF;
  END_IF;</algorithm>
      </function>
      <function name="connected_in_simple_path">
         <parameter name="connections">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="path_element_connection"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     connection_set : SET [0 : ?] OF path_element_connection;
     nec0           : INTEGER;
     pec0           : INTEGER;
     necbranch      : INTEGER;
     pecbranch      : INTEGER;
  END_LOCAL;

  IF SIZEOF (connections) &gt; 1 THEN
    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) = 0);
    nec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) = 0);
    pec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) &gt; 1);
    necbranch := SIZEOF (connection_set);

    connection_set := QUERY (pec1 &lt;* connections |
                        SIZEOF (QUERY (pec2 &lt;* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) &gt; 1);
    pecbranch := SIZEOF (connection_set);

    IF ((nec0 &lt;&gt; 1) OR (pec0 &lt;&gt; 1) OR (necbranch &gt; 0) OR (pecbranch &gt; 0)) THEN
      RETURN (FALSE);
    ELSE
      RETURN (TRUE);
    END_IF;
  ELSE
    RETURN (TRUE);
  END_IF;</algorithm>
      </function>
      <function name="increasing_measure_value">
         <parameter name="parm1">
            <typename name="motion_parameter_measure"/>
         </parameter>
         <parameter name="parm2">
            <typename name="motion_parameter_measure"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm1)) THEN
    IF (parm1 &lt; parm2)  THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;
  ELSE
    IF ('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm1)) THEN
      IF (parm1.value_component &lt; parm2.value_component) THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;</algorithm>
      </function>
      <function name="non_coincident_coordinates">
         <parameter name="crtpt">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="trltn">
            <typename name="translation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ((crtpt.coordinates[1] = trltn.x) AND
      (crtpt.coordinates[2] = trltn.y) AND
      (crtpt.coordinates[3] = trltn.z)) THEN
    RETURN (FALSE);
  ELSE
    RETURN (TRUE);
  END_IF;</algorithm>
      </function>
   </schema>
</express>
