<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-105">
   <application name="JSDAI" owner="LKSoft" source="kinematic_state_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="kinematic_state_schema">
      <interface kind="reference" schema="kinematic_structure_schema"/>
      <interface kind="reference" schema="geometry_schema">
         <interfaced.item name="axis2_placement_3d"/>
         <interfaced.item name="cartesian_transformation_operator_3d"/>
         <interfaced.item name="curve"/>
         <interfaced.item name="direction"/>
         <interfaced.item name="geometric_representation_context"/>
         <interfaced.item name="geometric_representation_item"/>
         <interfaced.item name="normalise"/>
         <interfaced.item name="point"/>
         <interfaced.item name="point_on_curve"/>
         <interfaced.item name="point_on_surface"/>
         <interfaced.item name="surface"/>
         <interfaced.item name="rectangular_trimmed_surface"/>
         <interfaced.item name="trimmed_curve"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="conversion_based_unit"/>
         <interfaced.item name="global_unit_assigned_context"/>
         <interfaced.item name="length_measure"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="si_prefix"/>
         <interfaced.item name="si_unit"/>
         <interfaced.item name="si_unit_name"/>
         <interfaced.item name="unit"/>
      </interface>
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_defined_transformation"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_context"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="representation_relationship"/>
         <interfaced.item name="representation_relationship_with_transformation"/>
      </interface>
      <type name="spatial_rotation">
         <select selectitems="ypr_rotation rotation_about_direction"/>
      </type>
      <type name="ypr_enumeration">
         <enumeration items="yaw pitch roll"/>
      </type>
      <type name="ypr_rotation">
         <aggregate lower="0" type="ARRAY" upper="0"/>
         <typename name="plane_angle_measure"/>
      </type>
      <entity name="cylindrical_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="cylindrical_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_translation">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="gear_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="gear_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_rotation_1">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="- actual_rotation_1 *&#10;                                     SELF\pair_value.applies_to_pair\&#10;                                     gear_pair.gear_ratio" name="actual_rotation_2">
            <typename name="plane_angle_measure"/>
         </derived>
      </entity>
      <entity name="mechanism_state_representation" supertypes="representation">
         <explicit name="context_of_items">
            <typename name="geometric_representation_context"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="pair_value"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <inverse attribute="rep_2" entity="mechanism_to_state_relationship" name="mechanism_relationship"/>
      </entity>
      <entity name="mechanism_to_state_relationship" supertypes="representation_relationship">
         <explicit name="rep_1">
            <typename name="mechanism_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="mechanism_state_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="pair_value" super.expression="ONEOF (sliding_surface_pair_value, rolling_surface_pair_value, revolute_pair_value, prismatic_pair_value, screw_pair_value, cylindrical_pair_value, spherical_pair_value, sliding_curve_pair_value, rolling_curve_pair_value, gear_pair_value, rack_and_pinion_pair_value, universal_pair_value, planar_pair_value, unconstrained_pair_value, point_on_surface_pair_value, point_on_planar_curve_pair_value)" supertypes="geometric_representation_item">
         <explicit name="applies_to_pair">
            <typename name="kinematic_pair"/>
         </explicit>
      </entity>
      <entity name="planar_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="planar_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="actual_translation_x">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="actual_translation_y">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="point_on_planar_curve_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="point_on_planar_curve_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_curve">
            <typename name="point_on_curve"/>
         </explicit>
         <explicit name="input_orientation">
            <typename name="spatial_rotation"/>
         </explicit>
         <derived expression="convert_spatial_to_ypr_rotation&#10;                                     (SELF\pair_value.applies_to_pair,&#10;                                      input_orientation)" name="actual_orientation">
            <typename name="ypr_rotation"/>
         </derived>
         <where expression="SELF\pair_value.applies_to_pair\point_on_planar_curve_pair.pair_curve&#10;       :=: actual_point_on_curve.basis_curve" label="WR1"/>
      </entity>
      <entity name="point_on_surface_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="point_on_surface_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_surface">
            <typename name="point_on_surface"/>
         </explicit>
         <explicit name="input_orientation">
            <typename name="spatial_rotation"/>
         </explicit>
         <derived expression="convert_spatial_to_ypr_rotation&#10;                                     (SELF\pair_value.applies_to_pair,&#10;                                      input_orientation)" name="actual_orientation">
            <typename name="ypr_rotation"/>
         </derived>
         <where expression="SELF\pair_value.applies_to_pair\point_on_surface_pair.pair_surface :=:&#10;       actual_point_on_surface.basis_surface" label="WR1"/>
      </entity>
      <entity name="prismatic_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="prismatic_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_translation">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="rack_and_pinion_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="rack_and_pinion_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_displacement">
            <typename name="length_measure"/>
         </explicit>
         <derived expression="convert_plane_angle_for_pair_from_radian&#10;                     (SELF\pair_value.applies_to_pair,&#10;                      (- actual_displacement /&#10;                       SELF\pair_value.applies_to_pair\&#10;                       rack_and_pinion_pair.pinion_radius))" name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </derived>
      </entity>
      <entity name="revolute_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="revolute_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="rolling_curve_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="rolling_curve_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_curve_1">
            <typename name="point_on_curve"/>
         </explicit>
         <where expression="SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:&#10;       actual_point_on_curve_1.basis_curve" label="WR1"/>
      </entity>
      <entity name="rolling_surface_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="rolling_surface_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_surface">
            <typename name="point_on_surface"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:&#10;       actual_point_on_surface.basis_surface" label="WR1"/>
      </entity>
      <entity name="rotation_about_direction" supertypes="geometric_representation_item">
         <explicit name="direction_of_axis">
            <typename name="direction"/>
         </explicit>
         <explicit name="rotation_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SIZEOF (direction_of_axis.direction_ratios) = 3" label="WR1"/>
      </entity>
      <entity name="screw_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="screw_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="SELF\pair_value.applies_to_pair\&#10;                                     screw_pair.pitch *&#10;                                     plane_angle_for_pair_in_radian&#10;                                      (SELF\pair_value.applies_to_pair,&#10;                                       actual_rotation) / (2 * PI)" name="actual_translation">
            <typename name="length_measure"/>
         </derived>
      </entity>
      <entity name="sliding_curve_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="sliding_curve_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_curve_1">
            <typename name="point_on_curve"/>
         </explicit>
         <explicit name="actual_point_on_curve_2">
            <typename name="point_on_curve"/>
         </explicit>
         <where expression="SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:&#10;       actual_point_on_curve_1.basis_curve" label="WR1"/>
         <where expression="SELF\pair_value.applies_to_pair\planar_curve_pair.curve_2 :=:&#10;       actual_point_on_curve_2.basis_curve" label="WR2"/>
      </entity>
      <entity name="sliding_surface_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="sliding_surface_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_point_on_surface_1">
            <typename name="point_on_surface"/>
         </explicit>
         <explicit name="actual_point_on_surface_2">
            <typename name="point_on_surface"/>
         </explicit>
         <explicit name="actual_rotation">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:&#10;       actual_point_on_surface_1.basis_surface" label="WR1"/>
         <where expression="SELF\pair_value.applies_to_pair\surface_pair.surface_2 :=:&#10;       actual_point_on_surface_2.basis_surface" label="WR2"/>
      </entity>
      <entity name="spherical_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="spherical_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="input_orientation">
            <typename name="spatial_rotation"/>
         </explicit>
         <derived expression="convert_spatial_to_ypr_rotation&#10;                                     (SELF\pair_value.applies_to_pair,&#10;                                      input_orientation)" name="actual_orientation">
            <typename name="ypr_rotation"/>
         </derived>
      </entity>
      <entity name="unconstrained_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="unconstrained_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="actual_placement">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="universal_pair_value" supertypes="pair_value">
         <explicit name="applies_to_pair">
            <typename name="universal_pair"/>
            <redeclaration entity-ref="pair_value"/>
         </explicit>
         <explicit name="first_rotation_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="second_rotation_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <subtype.constraint entity="geometric_representation_item" name="kss_geometric_representation_item_subtypes" super.expression="ONEOF (rotation_about_direction, su_parameters)"/>
      <function name="convert_spatial_to_ypr_rotation">
         <parameter name="pair">
            <typename name="kinematic_pair"/>
         </parameter>
         <parameter name="rotation">
            <typename name="spatial_rotation"/>
         </parameter>
         <typename name="ypr_rotation"/>
         <algorithm>LOCAL
    axis       : direction;
    angle      : plane_angle_measure;   -- rotation angle in application
                                        -- specific units
    conv_angle : plane_angle_measure;   -- rotation angle in radians
    ya, pa, ra : plane_angle_measure;   -- yaw, pitch, and roll angle
    ucf        : REAL;                  -- unit conversion factor
    dx, dy, dz : REAL;                  -- components of direction vector
    s_a, c_a   : REAL;                  -- sine and cosine of rotation angle
    rotmat     : ARRAY [1 : 3] OF
                 ARRAY [1 : 3] OF REAL; -- rotation matrix
    cm1        : REAL;
    s_y, c_y   : REAL;
    s_r, c_r   : REAL;
  END_LOCAL;

  -- If rotation is already a ypr_rotation, return it immediately
  IF 'KINEMATIC_STRUCTURE_SCHEMA.YPR_ROTATION' IN TYPEOF (rotation) THEN
    RETURN (rotation);
  END_IF;

  -- rotation is a rotation_about_direction

  axis  := normalise (rotation\rotation_about_direction.direction_of_axis);
  angle := rotation\rotation_about_direction.rotation_angle;

  -- a zero rotation is converted trivially
  IF (angle = 0.0) THEN
    RETURN ([0.0, 0.0, 0.0]);
  END_IF;

  dx := axis.direction_ratios[1];
  dy := axis.direction_ratios[2];
  dz := axis.direction_ratios[3];

  -- provide angle measured in radian

  conv_angle := plane_angle_for_pair_in_radian (pair, angle);

  IF (conv_angle = ?) THEN
    RETURN (?);
  END_IF;

  ucf := angle / conv_angle;
  s_a := SIN (conv_angle);
  c_a := COS (conv_angle);

  -- axis parallel either to x-axis or to z-axis?
  IF (dy = 0.0) AND (dx * dz = 0.0) THEN
    REPEAT WHILE (conv_angle &lt;= - PI);
      conv_angle := conv_angle + 2.0 * PI;
    END_REPEAT;
    REPEAT WHILE (conv_angle &gt; PI);
      conv_angle := conv_angle - 2.0 * PI;
    END_REPEAT;

    ya := ucf * conv_angle;
    IF (conv_angle &lt;&gt; PI) THEN
      ra := - ya;
    ELSE
      ra := ya;
    END_IF;

    IF (dx &lt;&gt; 0.0) THEN
      -- axis parallel to x-axis - use x-axis as roll axis
      IF (dx &gt; 0.0) THEN
        RETURN ([0.0, 0.0, ya]);
      ELSE
        RETURN ([0.0, 0.0, ra]);
      END_IF;
    ELSE
      -- axis parallel to z-axis - use z-axis as yaw axis
      IF (dz &gt; 0.0) THEN
        RETURN ([ya, 0.0, 0.0]);
      ELSE
        RETURN ([ra, 0.0, 0.0]);
      END_IF;
    END_IF;
  END_IF;

  -- axis parallel to y-axis - use y-axis as pitch axis
  IF ((dy &lt;&gt; 0.0) AND (dx = 0.0) AND (dz = 0.0)) THEN
    IF (c_a &gt;= 0.0) THEN
      ya := 0.0;
      ra := 0.0;
    ELSE
      ya := ucf * PI;
      ra := ya;
    END_IF;

    pa := ucf * ATAN (s_a, ABS (c_a));
    IF (dy &lt; 0.0) THEN
      pa := - pa;
    END_IF;

    RETURN ([ya, pa, ra]);
  END_IF;

  -- axis not parallel to any axis of coordinate system
  -- compute rotation matrix

  cm1 := 1.0 - c_a;

  rotmat := [ [ dx * dx * cm1 + c_a,
                dx * dy * cm1 - dz * s_a,
                dx * dz * cm1 + dy * s_a ],
              [ dx * dy * cm1 + dz * s_a,
                dy * dy * cm1 + c_a,
                dy * dz * cm1 - dx * s_a ],
              [ dx * dz * cm1 - dy * s_a,
                dy * dz * cm1 + dx * s_a,
                dz * dz * cm1 + c_a ] ];

  -- rotmat[1][3] equals SIN (pitch_angle)
  IF (ABS (rotmat[1][3]) = 1.0) THEN
    -- |pa| = PI/2
    BEGIN
      IF (rotmat[1][3] = 1.0) THEN
        pa := 0.5 * PI;
      ELSE
        pa := -0.5 * PI;
      END_IF;

      -- In this case, only the sum or difference of roll and yaw angles
      -- is relevant and can be evaluated from the matrix.
      -- According to IP `rectangular pitch angle' for ypr_rotation,
      -- the roll angle is set to zero.

      ra := 0.0;
      ya := ATAN (rotmat[2][1], rotmat[2][2]);

      -- result of ATAN is in the range [-PI/2, PI/2].
      -- Here all four quadrants are needed.

      IF (rotmat[2][2] &lt; 0.0) THEN
        IF ya &lt;= 0.0 THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;
    END;
  ELSE
    -- COS (pitch_angle) not equal to zero
    BEGIN
      ya := ATAN (- rotmat[1][2], rotmat[1][1]);

      IF (rotmat[1][1] &lt; 0.0) THEN
        IF (ya &lt;= 0.0) THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;

      ra := ATAN (-rotmat[2][3], rotmat[3][3]);

      IF (rotmat[3][3] &lt; 0.0) THEN
        IF (ra &lt;= 0.0) THEN
          ra := ra + PI;
        ELSE
          ra := ra - PI;
        END_IF;
      END_IF;

      s_y := SIN (ya);
      c_y := COS (ya);
      s_r := SIN (ra);
      c_r := COS (ra);

      IF ((ABS (s_y) &gt; ABS (c_y)) AND
          (ABS (s_y) &gt; ABS (s_r)) AND
          (ABS (s_y) &gt; ABS (c_r))) THEN
        cm1 := - rotmat[1][2] / s_y;
      ELSE
        IF ((ABS (c_y) &gt; ABS (s_r)) AND (ABS (c_y) &gt; ABS (c_r))) THEN
          cm1 := rotmat[1][1] / c_y;
        ELSE
          IF (ABS (s_r) &gt; ABS (c_r)) THEN
            cm1 := - rotmat[2][3] / s_r;
          ELSE
            cm1 := rotmat[3][3] / c_r;
          END_IF;
        END_IF;
      END_IF;

      pa := ATAN (rotmat[1][3], cm1);

    END;
  END_IF;

  ya := ya * ucf;
  pa := pa * ucf;
  ra := ra * ucf;

  RETURN ([ya, pa, ra]);</algorithm>
      </function>
      <function name="ypr_index">
         <parameter name="ypr">
            <typename name="ypr_enumeration"/>
         </parameter>
         <builtintype type="INTEGER"/>
         <algorithm>CASE ypr OF
    yaw    : RETURN (1);
    pitch  : RETURN (2);
    roll   : RETURN (3);
  END_CASE;
  RETURN (?);</algorithm>
      </function>
   </schema>
</express>
