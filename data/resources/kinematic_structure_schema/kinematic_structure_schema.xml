<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-105">
   <application name="JSDAI" owner="LKSoft" source="kinematic_structure_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="kinematic_structure_schema">
      <interface kind="reference" schema="kinematic_topology_schema"/>
      <interface kind="reference" schema="geometry_schema">
         <interfaced.item name="axis2_placement_3d"/>
         <interfaced.item name="cartesian_transformation_operator_3d"/>
         <interfaced.item name="curve"/>
         <interfaced.item name="direction"/>
         <interfaced.item name="geometric_representation_context"/>
         <interfaced.item name="geometric_representation_item"/>
         <interfaced.item name="normalise"/>
         <interfaced.item name="point"/>
         <interfaced.item name="point_on_curve"/>
         <interfaced.item name="point_on_surface"/>
         <interfaced.item name="surface"/>
         <interfaced.item name="rectangular_trimmed_surface"/>
         <interfaced.item name="trimmed_curve"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="conversion_based_unit"/>
         <interfaced.item name="global_unit_assigned_context"/>
         <interfaced.item name="length_measure"/>
         <interfaced.item name="plane_angle_measure"/>
         <interfaced.item name="si_prefix"/>
         <interfaced.item name="si_unit"/>
         <interfaced.item name="si_unit_name"/>
         <interfaced.item name="unit"/>
      </interface>
      <interface kind="reference" schema="product_property_definition_schema">
         <interfaced.item name="characterized_definition"/>
         <interfaced.item name="property_definition"/>
      </interface>
      <interface kind="reference" schema="product_property_representation_schema">
         <interfaced.item name="property_definition_representation"/>
         <interfaced.item name="shape_representation"/>
      </interface>
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="definitional_representation_relationship"/>
         <interfaced.item name="functionally_defined_transformation"/>
         <interfaced.item name="item_defined_transformation"/>
         <interfaced.item name="representation"/>
         <interfaced.item name="representation_context"/>
         <interfaced.item name="representation_item"/>
         <interfaced.item name="representation_relationship"/>
         <interfaced.item name="representation_relationship_with_transformation"/>
         <interfaced.item name="using_representations"/>
      </interface>
      <interface kind="reference" schema="support_resource_schema">
         <interfaced.item name="bag_to_set"/>
         <interfaced.item name="label"/>
      </interface>
      <type name="actuated_direction">
         <enumeration extensible="NO" items="bidirectional positive_only negative_only not_actuated"/>
      </type>
      <type name="kinematic_link_representation_items">
         <select extensible="NO" genericentity="NO" selectitems="curve point rigid_placement surface"/>
      </type>
      <type name="rigid_placement">
         <select extensible="NO" genericentity="NO" selectitems="axis2_placement_3d su_parameters"/>
      </type>
      <entity abstract.entity="NO" abstract.supertype="NO" name="actuated_kinematic_pair" supertypes="kinematic_pair">
         <explicit name="t_x" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
         <explicit name="t_y" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
         <explicit name="t_z" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
         <explicit name="r_x" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
         <explicit name="r_y" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
         <explicit name="r_z" optional="YES">
            <typename name="actuated_direction"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="cylindrical_pair" supertypes="low_order_kinematic_pair">
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="cylindrical_pair_with_range" supertypes="cylindrical_pair">
         <explicit name="lower_limit_actual_translation" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_translation" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="lower_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_translation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_translation))&#10;       XOR&#10;       (lower_limit_actual_translation &lt; upper_limit_actual_translation)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation))&#10;       XOR&#10;       (lower_limit_actual_rotation &lt; upper_limit_actual_rotation)" label="WR2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="fully_constrained_pair" supertypes="low_order_kinematic_pair">
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="gear_pair" supertypes="low_order_kinematic_pair_with_motion_coupling">
         <explicit name="radius_first_link" optional="NO">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="radius_second_link" optional="NO">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="bevel" optional="NO">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="helical_angle" optional="NO">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="gear_ratio" optional="NO">
            <builtintype fixed="NO" type="REAL"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="gear_pair_with_range" supertypes="gear_pair">
         <explicit name="lower_limit_actual_rotation_1" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation_1" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation_1)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation_1))&#10;       XOR&#10;       (lower_limit_actual_rotation_1 &lt; upper_limit_actual_rotation_1)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="high_order_kinematic_pair" super.expression="ONEOF (linear_flexible_and_planar_curve_pair, point_on_surface_pair, point_on_planar_curve_pair, planar_curve_pair, surface_pair)" supertypes="kinematic_pair">
         <derived expression="sort_link_associations(SELF\kinematic_pair.link_representation_associations, TRUE)" name="associated_link_representations_1">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="kinematic_link_representation"/>
         </derived>
         <derived expression="sort_link_associations(SELF\kinematic_pair.link_representation_associations, TRUE)" name="associated_link_representations_2">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="kinematic_link_representation"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="homokinetic_pair" supertypes="universal_pair">
         <where expression="NOT EXISTS(SELF.input_skew_angle)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="kinematic_link_representation" super.expression="ONEOF (linear_flexible_link_representation, rigid_link_representation)" supertypes="representation">
         <explicit name="context_of_items" optional="NO">
            <typename name="geometric_representation_context"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="items" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="kinematic_link_representation_items"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="represented_link" optional="NO">
            <typename name="kinematic_link"/>
         </explicit>
         <inverse attribute="rep_1" entity="kinematic_link_representation_association" name="associated_shape_representation">
            <inverse.aggregate lower="0" type="SET" upper="1"/>
         </inverse>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="kinematic_link_representation_association" supertypes="representation_relationship">
         <explicit name="rep_1" optional="NO">
            <typename name="kinematic_link_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2" optional="NO">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where expression="SELF\representation_relationship.rep_2.context_of_items :=:&#10;       SELF\representation_relationship.rep_1.context_of_items" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="kinematic_pair" super.expression="ONEOF (high_order_kinematic_pair, low_order_kinematic_pair_with_motion_coupling, low_order_kinematic_pair) ANDOR actuated_kinematic_pair" supertypes="item_defined_transformation geometric_representation_item">
         <explicit name="joint" optional="NO">
            <typename name="kinematic_joint"/>
         </explicit>
         <explicit name="transform_item_1" optional="NO">
            <typename name="rigid_placement"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <explicit name="transform_item_2" optional="NO">
            <typename name="rigid_placement"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <inverse attribute="transformation_operator" entity="pair_representation_relationship" name="link_representation_associations">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="linear_flexible_and_pinion_pair" supertypes="low_order_kinematic_pair_with_motion_coupling">
         <explicit name="pinion_radius" optional="NO">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="linear_flexible_and_planar_curve_pair" supertypes="high_order_kinematic_pair">
         <explicit name="pair_curve" optional="NO">
            <typename name="curve"/>
         </explicit>
         <explicit name="orientation" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(pair_curve IN r.items))) = 0" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="linear_flexible_link_representation" supertypes="kinematic_link_representation"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="low_order_kinematic_pair" super.expression="ONEOF (revolute_pair, cylindrical_pair, spherical_pair, spherical_pair_with_pin, planar_pair, unconstrained_pair, fully_constrained_pair, prismatic_pair, universal_pair)" supertypes="kinematic_pair">
         <explicit name="t_x" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <explicit name="t_y" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <explicit name="t_z" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <explicit name="r_x" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <explicit name="r_y" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <explicit name="r_z" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="low_order_kinematic_pair_with_motion_coupling" super.expression="ONEOF (gear_pair, linear_flexible_and_pinion_pair, rack_and_pinion_pair, screw_pair)" supertypes="kinematic_pair"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="mechanism_representation" supertypes="representation">
         <explicit name="context_of_items" optional="NO">
            <typename name="geometric_representation_context"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="items" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="pair_representation_relationship"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <explicit name="represented_topology" optional="NO">
            <typename name="kinematic_topology_representation_select"/>
         </explicit>
         <derived expression="collect_joints(items)" name="represented_joints">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="kinematic_joint"/>
         </derived>
         <where expression="(('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_STRUCTURE' IN TYPEOF(represented_topology))&#10;         AND (represented_joints :=: represented_topology.items)) OR&#10;       (('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_DIRECTED_STRUCTURE' IN TYPEOF(represented_topology))&#10;         AND (represented_joints :=: get_kinematic_joints_from_oriented_joints(represented_topology.items))) OR&#10;       (('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_NETWORK_STRUCTURE' IN TYPEOF(represented_topology))&#10;         AND (represented_joints :=: get_kinematic_joints_from_kinematic_loops(represented_topology.items)))" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="pair_representation_relationship" supertypes="representation_relationship_with_transformation geometric_representation_item">
         <explicit name="rep_1" optional="NO">
            <typename name="kinematic_link_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2" optional="NO">
            <typename name="rigid_link_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="transformation_operator" optional="NO">
            <typename name="kinematic_pair"/>
            <redeclaration entity-ref="representation_relationship_with_transformation"/>
         </explicit>
         <where expression="transformation_operator\item_defined_transformation.transform_item_1 IN rep_1.items" label="WR1"/>
         <where expression="transformation_operator\item_defined_transformation.transform_item_2 IN rep_2.items" label="WR2"/>
         <where expression="rep_1\kinematic_link_representation.represented_link = transformation_operator\kinematic_pair.joint.edge_start" label="WR3"/>
         <where expression="rep_2\kinematic_link_representation.represented_link = transformation_operator\kinematic_pair.joint.edge_end" label="WR4"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="planar_curve_pair" super.expression="ONEOF (sliding_curve_pair, rolling_curve_pair) ANDOR planar_curve_pair_range" supertypes="high_order_kinematic_pair">
         <explicit name="curve_1" optional="NO">
            <typename name="curve"/>
         </explicit>
         <explicit name="curve_2" optional="NO">
            <typename name="curve"/>
         </explicit>
         <explicit name="orientation" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(curve_1 IN r.items))) = 0" label="WR1"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_2 | NOT(curve_2 IN r.items))) = 0" label="WR2"/>
      <where label="IP1"/>
         <where label="IP2"/>
         <where label="IP3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="planar_curve_pair_range" supertypes="planar_curve_pair">
         <explicit name="range_on_curve_1" optional="NO">
            <typename name="trimmed_curve"/>
         </explicit>
         <explicit name="range_on_curve_2" optional="NO">
            <typename name="trimmed_curve"/>
         </explicit>
         <where expression="SELF\planar_curve_pair.curve_1 :=: range_on_curve_1.basis_curve" label="WR1"/>
         <where expression="SELF\planar_curve_pair.curve_2 :=: range_on_curve_2.basis_curve" label="WR2"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(range_on_curve_1 IN r.items))) = 0" label="WR3"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_2 | NOT(range_on_curve_2 IN r.items))) = 0" label="WR4"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="planar_pair" supertypes="low_order_kinematic_pair">
         <derived expression="TRUE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="planar_pair_with_range" supertypes="planar_pair">
         <explicit name="lower_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_actual_translation_x" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_translation_x" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="lower_limit_actual_translation_y" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_translation_y" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation))&#10;       XOR&#10;       (lower_limit_actual_rotation &lt; upper_limit_actual_rotation)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_actual_translation_x)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_translation_x))&#10;       XOR&#10;       (lower_limit_actual_translation_x &lt; upper_limit_actual_translation_x)" label="WR2"/>
         <where expression="(NOT EXISTS(lower_limit_actual_translation_y)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_translation_y))&#10;       XOR&#10;       (lower_limit_actual_translation_y &lt; upper_limit_actual_translation_y)" label="WR3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="point_on_planar_curve_pair" supertypes="high_order_kinematic_pair">
         <explicit name="pair_curve" optional="NO">
            <typename name="curve"/>
         </explicit>
         <explicit name="orientation" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(pair_curve IN r.items))) = 0" label="WR1"/>
      <where label="IP1"/>
         <where label="IP2"/>
         <where label="IP3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="point_on_planar_curve_pair_with_range" supertypes="point_on_planar_curve_pair">
         <explicit name="range_on_pair_curve" optional="NO">
            <typename name="trimmed_curve"/>
         </explicit>
         <explicit name="lower_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_pitch)&#10;        OR&#10;        NOT EXISTS(upper_limit_pitch))&#10;       XOR&#10;       (lower_limit_pitch &lt; upper_limit_pitch)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_yaw)&#10;        OR&#10;        NOT EXISTS(upper_limit_yaw))&#10;       XOR&#10;       (lower_limit_yaw &lt; upper_limit_yaw)" label="WR2"/>
         <where expression="(NOT EXISTS(lower_limit_roll)&#10;        OR&#10;        NOT EXISTS(upper_limit_roll))&#10;       XOR&#10;       (lower_limit_roll &lt; upper_limit_roll)" label="WR3"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(range_on_pair_curve IN r.items))) = 0" label="WR4"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="point_on_surface_pair" supertypes="high_order_kinematic_pair">
         <explicit name="pair_surface" optional="NO">
            <typename name="surface"/>
         </explicit>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(pair_surface IN r.items))) = 0" label="WR1"/>
      <where label="IP1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="point_on_surface_pair_with_range" supertypes="point_on_surface_pair">
         <explicit name="range_on_pair_surface" optional="NO">
            <typename name="rectangular_trimmed_surface"/>
         </explicit>
         <explicit name="lower_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_pitch)&#10;        OR&#10;        NOT EXISTS(upper_limit_pitch))&#10;       XOR&#10;       (lower_limit_pitch &lt; upper_limit_pitch)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_yaw)&#10;        OR&#10;        NOT EXISTS(upper_limit_yaw))&#10;       XOR&#10;       (lower_limit_yaw &lt; upper_limit_yaw)" label="WR2"/>
         <where expression="(NOT EXISTS(lower_limit_roll)&#10;        OR&#10;        NOT EXISTS(upper_limit_roll))&#10;       XOR&#10;       (lower_limit_roll &lt; upper_limit_roll)" label="WR3"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(range_on_pair_surface IN r.items))) = 0" label="WR4"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="prismatic_pair" supertypes="low_order_kinematic_pair">
         <derived expression="TRUE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="prismatic_pair_with_range" supertypes="prismatic_pair">
         <explicit name="lower_limit_actual_translation" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_translation" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_translation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_translation))&#10;       XOR&#10;       (lower_limit_actual_translation &lt; upper_limit_actual_translation)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="rack_and_pinion_pair" supertypes="low_order_kinematic_pair_with_motion_coupling">
         <explicit name="pinion_radius" optional="NO">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="rack_and_pinion_pair_with_range" supertypes="rack_and_pinion_pair">
         <explicit name="lower_limit_rack_displacement" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="upper_limit_rack_displacement" optional="YES">
            <typename name="length_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_rack_displacement)&#10;        OR&#10;        NOT EXISTS(upper_limit_rack_displacement))&#10;       XOR&#10;       (lower_limit_rack_displacement &lt; upper_limit_rack_displacement)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="revolute_pair" supertypes="low_order_kinematic_pair">
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="revolute_pair_with_range" supertypes="revolute_pair">
         <explicit name="lower_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation))&#10;       XOR&#10;       (lower_limit_actual_rotation &lt; upper_limit_actual_rotation)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="rigid_link_representation" supertypes="kinematic_link_representation"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="rolling_curve_pair" supertypes="planar_curve_pair"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="rolling_surface_pair" supertypes="surface_pair"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="screw_pair" supertypes="low_order_kinematic_pair_with_motion_coupling">
         <explicit name="pitch" optional="NO">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="screw_pair_with_range" supertypes="screw_pair">
         <explicit name="lower_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation))&#10;       XOR&#10;       (lower_limit_actual_rotation &lt; upper_limit_actual_rotation)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="sliding_curve_pair" supertypes="planar_curve_pair"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="sliding_surface_pair" supertypes="surface_pair"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="spherical_pair" supertypes="low_order_kinematic_pair">
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="spherical_pair_with_pin" supertypes="low_order_kinematic_pair">
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="spherical_pair_with_pin_and_range" supertypes="spherical_pair_with_pin">
         <explicit name="lower_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_yaw)&#10;        OR&#10;        NOT EXISTS(upper_limit_yaw))&#10;       XOR&#10;       (lower_limit_yaw &lt; upper_limit_yaw)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_roll)&#10;        OR&#10;        NOT EXISTS(upper_limit_roll))&#10;       XOR&#10;       (lower_limit_roll &lt; upper_limit_roll)" label="WR2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="spherical_pair_with_range" supertypes="spherical_pair">
         <explicit name="lower_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_yaw" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_pitch" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_roll" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_yaw)&#10;        OR&#10;        NOT EXISTS(upper_limit_yaw))&#10;       XOR&#10;       (lower_limit_yaw &lt; upper_limit_yaw)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_pitch)&#10;        OR&#10;        NOT EXISTS(upper_limit_pitch))&#10;       XOR&#10;       (lower_limit_pitch &lt; upper_limit_pitch)" label="WR2"/>
         <where expression="(NOT EXISTS(lower_limit_roll)&#10;        OR&#10;        NOT EXISTS(upper_limit_roll))&#10;       XOR&#10;       (lower_limit_roll &lt; upper_limit_roll)" label="WR3"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="su_parameters" supertypes="geometric_representation_item">
         <explicit name="a" optional="NO">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="alpha" optional="NO">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="b" optional="NO">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="beta" optional="NO">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="c" optional="NO">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="gamma" optional="NO">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim=3" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="YES" name="surface_pair" super.expression="ONEOF (sliding_surface_pair, rolling_surface_pair) ANDOR surface_pair_with_range" supertypes="high_order_kinematic_pair">
         <explicit name="surface_1" optional="NO">
            <typename name="surface"/>
         </explicit>
         <explicit name="surface_2" optional="NO">
            <typename name="surface"/>
         </explicit>
         <explicit name="orientation" optional="NO">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </explicit>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(surface_1 IN r.items))) = 0" label="WR1"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_2 | NOT(surface_2 IN r.items))) = 0" label="WR2"/>
      <where label="IP1"/>
         <where label="IP2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="surface_pair_with_range" supertypes="surface_pair">
         <explicit name="range_on_surface_1" optional="NO">
            <typename name="rectangular_trimmed_surface"/>
         </explicit>
         <explicit name="range_on_surface_2" optional="NO">
            <typename name="rectangular_trimmed_surface"/>
         </explicit>
         <explicit name="lower_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_actual_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SELF\surface_pair.surface_1 :=: range_on_surface_1.basis_surface" label="WR1"/>
         <where expression="SELF\surface_pair.surface_2 :=: range_on_surface_2.basis_surface" label="WR2"/>
         <where expression="(NOT EXISTS(lower_limit_actual_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_actual_rotation))&#10;       XOR&#10;       (lower_limit_actual_rotation &lt; upper_limit_actual_rotation)" label="WR3"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_1 | NOT(range_on_surface_1 IN r.items))) = 0" label="WR4"/>
         <where expression="SIZEOF( QUERY(r &lt;* SELF\high_order_kinematic_pair.associated_link_representations_2 | NOT(range_on_surface_2 IN r.items))) = 0" label="WR5"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="unconstrained_pair" supertypes="low_order_kinematic_pair">
         <derived expression="TRUE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="universal_pair" supertypes="low_order_kinematic_pair">
         <explicit name="input_skew_angle" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="FALSE" name="t_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="t_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_x">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="FALSE" name="r_y">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="TRUE" name="r_z">
            <builtintype fixed="NO" type="BOOLEAN"/>
            <redeclaration entity-ref="low_order_kinematic_pair"/>
         </derived>
         <derived expression="NVL (input_skew_angle, 0.0)" name="skew_angle">
            <typename name="plane_angle_measure"/>
         </derived>
         <where expression="COS (plane_angle_for_pair_in_radian (SELF, skew_angle))&#10;       &gt; 0.0" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="universal_pair_with_range" supertypes="universal_pair">
         <explicit name="lower_limit_first_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_first_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="lower_limit_second_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="upper_limit_second_rotation" optional="YES">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(NOT EXISTS(lower_limit_first_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_first_rotation))&#10;       XOR&#10;       (lower_limit_first_rotation &lt; upper_limit_first_rotation)" label="WR1"/>
         <where expression="(NOT EXISTS(lower_limit_second_rotation)&#10;        OR&#10;        NOT EXISTS(upper_limit_second_rotation))&#10;       XOR&#10;       (lower_limit_second_rotation &lt; upper_limit_second_rotation)" label="WR2"/>
      </entity>
      <subtype.constraint abstract.supertype="NO" entity="representation" name="kss_representation_subtypes" super.expression="ONEOF (kinematic_link_representation, kinematic_topology_structure, kinematic_topology_directed_structure, kinematic_topology_network_structure, mechanism_representation, shape_representation)"/>
      <function name="collect_joints">
         <parameter name="items">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="pair_representation_relationship"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="kinematic_joint"/>
         <algorithm>LOCAL
  result : SET OF kinematic_joint := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(items);
    result := result + items[i].transformation_operator.joint;
  END_REPEAT;
  RETURN(result);</algorithm>
      </function>
      <function name="plane_angle_for_pair_in_radian">
         <parameter name="pair">
            <typename name="kinematic_pair"/>
         </parameter>
         <parameter name="angle">
            <typename name="plane_angle_measure"/>
         </parameter>
         <typename name="plane_angle_measure"/>
         <algorithm>LOCAL
    converted_angle : plane_angle_measure := angle;
    link_rep        : kinematic_link_representation
                    := representation_of_link (pair.joint.edge_start);
    link_cntxt      : representation_context;
    pa_units        : SET OF unit := [];
    pau             : unit;
  END_LOCAL;

  link_cntxt := link_rep\representation.context_of_items;

  IF NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
          IN TYPEOF (link_cntxt)) THEN
    RETURN (?);
  END_IF;

  pa_units := QUERY (unit &lt;* link_cntxt\global_unit_assigned_context.units |
                     'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (unit));

  IF SIZEOF (pa_units) &lt;&gt; 1 THEN
    RETURN (?);
  END_IF;

  pau := pa_units[1];

  IF (NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
      NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) THEN
    RETURN (?);
  END_IF;

  REPEAT WHILE ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau));
    converted_angle := converted_angle *
                       pau\conversion_based_unit.conversion_factor.
                       value_component;
    pau := pau\conversion_based_unit.conversion_factor.unit_component;

    IF ((NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
         NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) OR
        (NOT ('MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (pau)))) THEN
      RETURN (?);
    END_IF;
  END_REPEAT;

  IF (pau\si_unit.name &lt;&gt; si_unit_name.radian) THEN
    RETURN (?);
  END_IF;

  CASE pau\si_unit.prefix OF
    si_prefix.exa     : RETURN (1.E18 * converted_angle);
    si_prefix.peta    : RETURN (1.E15 * converted_angle);
    si_prefix.tera    : RETURN (1.E12 * converted_angle);
    si_prefix.giga    : RETURN (1.E9 * converted_angle);
    si_prefix.mega    : RETURN (1.E6 * converted_angle);
    si_prefix.kilo    : RETURN (1.E3 * converted_angle);
    si_prefix.hecto   : RETURN (1.E2 * converted_angle);
    si_prefix.deca    : RETURN (1.E1 * converted_angle);
    si_prefix.deci    : RETURN (1.E-1 * converted_angle);
    si_prefix.centi   : RETURN (1.E-2 * converted_angle);
    si_prefix.milli   : RETURN (1.E-3 * converted_angle);
    si_prefix.micro   : RETURN (1.E-6 * converted_angle);
    si_prefix.nano    : RETURN (1.E-9 * converted_angle);
    si_prefix.pico    : RETURN (1.E-12 * converted_angle);
    si_prefix.femto   : RETURN (1.E-15 * converted_angle);
    si_prefix.atto    : RETURN (1.E-18 * converted_angle);
  OTHERWISE           : RETURN (converted_angle);
  END_CASE;</algorithm>
      </function>
      <function name="representation_of_link">
         <parameter name="link">
            <typename name="kinematic_link"/>
         </parameter>
         <typename name="kinematic_link_representation"/>
         <algorithm>RETURN (?);</algorithm>
      </function>
      <function name="sort_link_associations">
         <parameter name="aprr">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="pair_representation_relationship"/>
         </parameter>
         <parameter name="one_not_two">
            <builtintype fixed="NO" type="BOOLEAN"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="kinematic_link_representation"/>
         <algorithm>LOCAL
  result : SET OF kinematic_link_representation := [];
END_LOCAL;
  IF one_not_two THEN
    REPEAT i := 1 TO HIINDEX(aprr);
      result := result + aprr[i].rep_1;
    END_REPEAT;
  ELSE  
    REPEAT i := 1 TO HIINDEX(aprr);
      result := result + aprr[i].rep_2;
    END_REPEAT;
  END_IF;
  RETURN(result);</algorithm>
      </function>
   </schema>
</express>
