<?xml version="1.0"?>
<!-- $Id: mathematical_functions_schema.xml,v 1.1 2001/12/14 17:49:54 robbod Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  rcs.date="$Date: 2001/12/14 17:49:54 $"
  rcs.revision="$Revision: 1.1 $">

  <application
    name="express2xml.js"
    owner="Eurostep Limited"
    url="http://www.eurostep.com"
    version="1.4"
    source="../data/resources/mathematical_functions_schema/mathematical_functions_schema.exp"/>

  <schema name="mathematical_functions_schema">
    <interface
      kind="reference"
      schema="ISO13584_generic_expressions_schema">
      <interfaced.item
        name="binary_generic_expression"/>
      <interfaced.item
        name="environment"/>
      <interfaced.item
        name="generic_expression"/>
      <interfaced.item
        name="generic_literal"/>
      <interfaced.item
        name="generic_variable"/>
      <interfaced.item
        name="multiple_arity_generic_expression"/>
      <interfaced.item
        name="simple_generic_expression"/>
      <interfaced.item
        name="unary_generic_expression"/>
      <interfaced.item
        name="variable_semantics"/>
    </interface>

    <interface
      kind="reference"
      schema="ISO13584_expressions_schema">
      <interfaced.item
        name="abs_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="abs_expression"/>
      <interfaced.item
        name="acos_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="acos_expression"/>
      <interfaced.item
        name="and_expression"/>
      <interfaced.item
        name="asin_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="asin_expression"/>
      <interfaced.item
        name="atan_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="atan_expression"/>
      <interfaced.item
        name="binary_boolean_expression"/>
      <interfaced.item
        name="binary_function_call"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="binary_numeric_call_expression"/>
      <interfaced.item
        name="binary_numeric_expression"/>
      <interfaced.item
        name="boolean_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="boolean_defined_expression"/>
      <interfaced.item
        name="boolean_expression"/>
      <interfaced.item
        name="boolean_literal"/>
      <interfaced.item
        name="boolean_variable"/>
      <interfaced.item
        name="comparison_equal"/>
      <interfaced.item
        name="comparison_expression"/>
      <interfaced.item
        name="comparison_greater"/>
      <interfaced.item
        name="comparison_greater_equal"/>
      <interfaced.item
        name="comparison_less"/>
      <interfaced.item
        name="comparison_less_equal"/>
      <interfaced.item
        name="comparison_not_equal"/>
      <interfaced.item
        name="concat_expression"/>
      <interfaced.item
        name="cos_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="cos_expression"/>
      <interfaced.item
        name="defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="defined_expression"/>
      <interfaced.item
        name="div_expression"/>
      <interfaced.item
        name="equals_expression"/>
      <interfaced.item
        name="exp_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="exp_expression"/>
      <interfaced.item
        name="expression"/>
      <interfaced.item
        name="format_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="format_expression"/>
      <interfaced.item
        name="index_expression"/>
      <interfaced.item
        name="int_literal"/>
      <interfaced.item
        name="int_numeric_variable"/>
      <interfaced.item
        name="int_value_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="int_value_expression"/>
      <interfaced.item
        name="integer_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="integer_defined_expression"/>
      <interfaced.item
        name="interval_expression"/>
      <interfaced.item
        name="length_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="length_expression"/>
      <interfaced.item
        name="like_expression"/>
      <interfaced.item
        name="literal_number"/>
      <interfaced.item
        name="log_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="log_expression"/>
      <interfaced.item
        name="log10_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="log10_expression"/>
      <interfaced.item
        name="log2_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="log2_expression"/>
      <interfaced.item
        name="maximum_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="maximum_expression"/>
      <interfaced.item
        name="minimum_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="minimum_expression"/>
      <interfaced.item
        name="minus_expression"/>
      <interfaced.item
        name="minus_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="unary_minus_expression"/>
      <interfaced.item
        name="mod_expression"/>
      <interfaced.item
        name="mult_expression"/>
      <interfaced.item
        name="multiple_arity_boolean_expression"/>
      <interfaced.item
        name="multiple_arity_function_call"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="multiple_arity_numeric_call_expression"/>
      <interfaced.item
        name="multiple_arity_numeric_expression"/>
      <interfaced.item
        name="not_expression"/>
      <interfaced.item
        name="numeric_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="numeric_defined_expression"/>
      <interfaced.item
        name="numeric_expression"/>
      <interfaced.item
        name="numeric_variable"/>
      <interfaced.item
        name="odd_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="odd_expression"/>
      <interfaced.item
        name="or_expression"/>
      <interfaced.item
        name="plus_expression"/>
      <interfaced.item
        name="power_expression"/>
      <interfaced.item
        name="real_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="real_defined_expression"/>
      <interfaced.item
        name="real_literal"/>
      <interfaced.item
        name="real_numeric_variable"/>
      <interfaced.item
        name="simple_boolean_expression"/>
      <interfaced.item
        name="simple_numeric_expression"/>
      <interfaced.item
        name="simple_string_expression"/>
      <interfaced.item
        name="sin_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="sin_expression"/>
      <interfaced.item
        name="slash_expression"/>
      <interfaced.item
        name="sql_mappable_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="sql_mappable_defined_expression"/>
      <interfaced.item
        name="square_root_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="square_root_expression"/>
      <interfaced.item
        name="string_defined_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="string_defined_expression"/>
      <interfaced.item
        name="string_expression"/>
      <interfaced.item
        name="string_literal"/>
      <interfaced.item
        name="string_variable"/>
      <interfaced.item
        name="substring_expression"/>
      <interfaced.item
        name="tan_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="tan_expression"/>
      <interfaced.item
        name="unary_boolean_expression"/>
      <interfaced.item
        name="unary_function_call"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="unary_numeric_call_expression"/>
      <interfaced.item
        name="unary_numeric_expression"/>
      <interfaced.item
        name="value_function"/>
      <interfaced.item
        name="AS"/>
      <interfaced.item
        name="value_expression"/>
      <interfaced.item
        name="variable"/>
      <interfaced.item
        name="xor_expression"/>
    </interface>

    <interface
      kind="reference"
      schema="support_resource_schema">
      <interfaced.item
        name="label"/>
      <interfaced.item
        name="text"/>
    </interface>

    <interface
      kind="reference"
      schema="external_reference_schema">
      <interfaced.item
        name="externally_defined_item"/>
    </interface>

    <interface
      kind="reference"
      schema="geometry_schema">
      <interfaced.item
        name="curve"/>
      <interfaced.item
        name="dimension_of"/>
      <interfaced.item
        name="point"/>
      <interfaced.item
        name="surface"/>
      <interfaced.item
        name="volume"/>
    </interface>

    <type name="nonnegative_integer">
      <builtintype
        type="INTEGER">
      </builtintype>


      <where
        label="WHERE"
        expression="SELF &gt;= 0">
      </where>
    </type>
    <type name="positive_integer">
      <typename
        name="nonnegative_integer"/>

      <where
        label="WHERE"
        expression="SELF &gt; 0">
      </where>
    </type>
    <type name="zero_or_one">
      <typename
        name="nonnegative_integer"/>

      <where
        label="WHERE"
        expression="(SELF = 0) OR (SELF = 1)">
      </where>
    </type>
    <type name="one_or_two">
      <typename
        name="positive_integer"/>

      <where
        label="WHERE"
        expression="(SELF = 1) OR (SELF = 2)">
      </where>
    </type>
    <type name="maths_number">
      <builtintype
        type="NUMBER">
      </builtintype>


    </type>
    <type name="maths_real">
      <builtintype
        type="REAL">
      </builtintype>


    </type>
    <type name="maths_integer">
      <builtintype
        type="INTEGER">
      </builtintype>


    </type>
    <type name="maths_logical">
      <builtintype
        type="LOGICAL">
      </builtintype>


    </type>
    <type name="maths_boolean">
      <builtintype
        type="BOOLEAN">
      </builtintype>


    </type>
    <type name="maths_string">
      <builtintype
        type="STRING">
      </builtintype>


    </type>
    <type name="maths_binary">
      <builtintype
        type="BINARY">
      </builtintype>


    </type>
    <type name="maths_simple_atom">
      <select
        selectitems="maths_number maths_real maths_number maths_logical maths_boolean maths_string maths_binary">
      </select>

    </type>
    <type name="maths_atom">
      <select
        selectitems="maths_simple_atom maths_enum_atom">
      </select>

    </type>
    <type name="atom_based_tuple">
      <typename
        name="LIST OF atom_based_value"/>

    </type>
    <type name="atom_based_value">
      <select
        selectitems="maths_atom atom_based_tuple">
      </select>

    </type>
    <type name="maths_tuple">
      <typename
        name="LIST [0:?] OF maths_value"/>

    </type>
    <type name="maths_value">
      <select
        selectitems="atom_based_value maths_tuple generic_expression">
      </select>

      <where
        label="WHERE"
        expression="NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR             expression_is_constant(SELF)">
      </where>
    </type>
    <type name="maths_expression">
      <select
        selectitems="atom_based_value maths_tuple generic_expression">
      </select>

    </type>
    <type name="maths_function_select">
      <select
        selectitems="maths_function elementary_function_enumerators">
      </select>

    </type>
    <type name="input_selector">
      <typename
        name="positive_integer"/>

    </type>
    <type name="elementary_space_enumerators">
      <enumeration
        items="es_numbers es_complex_numbers es_reals es_integers es_logicals es_booleans es_strings es_binarys es_maths_spaces es_maths_functions es_generics">
      </enumeration>


    </type>
    <type name="ordering_type">
      <enumeration
        items="by_rows by_columns">
      </enumeration>


    </type>
    <type name="lower_upper">
      <enumeration
        items="lower upper">
      </enumeration>


    </type>
    <type name="symmetry_type">
      <enumeration
        items="identity skew hermitian skew_hermitian">
      </enumeration>


    </type>
    <type name="elementary_function_enumerators">
      <enumeration
        items="ef_and ef_or ef_not ef_xor ef_negate_i ef_add_i ef_subtract_i ef_multiply_i ef_divide_i ef_mod_i ef_exponentiate_i ef_eq_i ef_ne_i ef_gt_i ef_lt_i ef_ge_i ef_le_i ef_abs_i ef_max_i ef_min_i ef_if_i ef_negate_r ef_reciprocal_r ef_add_r ef_subtract_r ef_multiply_r ef_divide_r ef_mod_r ef_exponentiate_r ef_exponentiate_ri ef_eq_r ef_ne_r ef_gt_r ef_lt_r ef_ge_r ef_le_r ef_abs_r ef_max_r ef_min_r ef_acos_r ef_asin_r ef_atan2_r ef_cos_r ef_exp_r ef_ln_r ef_log2_r ef_log10_r ef_sin_r ef_sqrt_r ef_tan_r ef_if_r ef_form_c ef_rpart_c ef_ipart_c ef_negate_c ef_reciprocal_c ef_add_c ef_subtract_c ef_multiply_c ef_divide_c ef_exponentiate_c ef_exponentiate_ci ef_eq_c ef_ne_c ef_conjugate_c ef_abs_c ef_arg_c ef_cos_c ef_exp_c ef_ln_c ef_sin_c ef_sqrt_c ef_tan_c ef_if_c ef_subscript_s ef_eq_s ef_ne_s ef_gt_s ef_lt_s ef_ge_s ef_le_s ef_subsequence_s ef_concat_s ef_size_s ef_format ef_value ef_like ef_if_s ef_subscript_b ef_eq_b ef_ne_b ef_gt_b ef_lt_b ef_ge_b ef_le_b ef_subsequence_b ef_concat_b ef_size_b ef_if_b ef_subscript_t ef_eq_t ef_ne_t ef_concat_t ef_size_t ef_entuple ef_detuple ef_insert ef_remove ef_if_t ef_sum_it ef_product_it ef_add_it ef_subtract_it ef_scalar_mult_it ef_dot_prod_it ef_sum_rt ef_product_rt ef_add_rt ef_subtract_rt ef_scalar_mult_rt ef_dot_prod_rt ef_norm_rt ef_sum_ct ef_product_ct ef_add_ct ef_subtract_ct ef_scalar_mult_ct ef_dot_prod_ct ef_norm_ct ef_if ef_ensemble ef_member_of">
      </enumeration>


    </type>
    <type name="open_closed">
      <enumeration
        items="open closed">
      </enumeration>


    </type>
    <type name="space_constraint_type">
      <enumeration
        items="sc_equal sc_subspace sc_member">
      </enumeration>


    </type>
    <type name="repackage_options">
      <enumeration
        items="ro_nochange ro_wrap_as_tuple ro_unwrap_tuple">
      </enumeration>


    </type>
    <type name="extension_options">
      <enumeration
        items="eo_none eo_cont eo_cont_right eo_cont_left">
      </enumeration>


    </type>
    <type name="maths_enum_atom">
      <select
        selectitems="elementary_space_enumerators ordering_type lower_upper symmetry_type elementary_function_enumerators open_closed space_constraint_type repackage_options extension_options">
      </select>

    </type>
    <type name="dotted_express_identifier">
      <builtintype
        type="STRING">
      </builtintype>


      <where
        label="WHERE"
        expression="dotted_identifiers_syntax(SELF)">
      </where>
    </type>
    <type name="express_identifier">
      <typename
        name="dotted_express_identifier"/>

      <where
        label="WHERE"
        expression="dot_count(SELF) = 0">
      </where>
    </type>
    <type name="product_space">
      <select
        selectitems="uniform_product_space listed_product_space">
      </select>

    </type>
    <type name="tuple_space">
      <select
        selectitems="product_space extended_tuple_space">
      </select>

    </type>
    <type name="maths_space_or_function">
      <select
        selectitems="maths_space maths_function">
      </select>

    </type>
    <type name="real_interval">
      <select
        selectitems="real_interval_from_min real_interval_to_max finite_real_interval elementary_space">
      </select>

      <where
        label="WHERE"
        expression="NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR    (SELF\elementary_space.space_id = es_reals)">
      </where>
    </type>
    <entity
      name="quantifier_expression"
      abstract.supertype="YES"
      supertypes="multiple_arity_generic_expression">
      <explicit
        name="variables">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (vrbl &lt;* variables | NOT (vrbl IN       SELF\multiple_arity_generic_expression.operands))) = 0">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (vrbl &lt;* variables | NOT ((schema_prefix +       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0">
      </where>
    </entity>

    <entity
      name="dependent_variable_definition"
      supertypes="unary_generic_expression">
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <explicit
        name="description">
        <typename
          name="text"/>
      </explicit>
    </entity>

    <entity
      name="bound_variable_semantics"
      supertypes="variable_semantics">
    </entity>

    <entity
      name="free_variable_semantics"
      supertypes="variable_semantics">
    </entity>

    <entity
      name="complex_number_literal"
      supertypes="generic_literal">
      <explicit
        name="real_part">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="imag_part">
        <builtintype
          type="REAL"/>
      </explicit>
    </entity>

    <entity
      name="logical_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <builtintype
          type="LOGICAL"/>
      </explicit>
    </entity>

    <entity
      name="binary_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <builtintype
          type="BINARY"/>
      </explicit>
    </entity>

    <entity
      name="maths_enum_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <typename
          name="maths_enum_atom"/>
      </explicit>
    </entity>

    <entity
      name="real_tuple_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
    </entity>

    <entity
      name="integer_tuple_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
    </entity>

    <entity
      name="atom_based_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <typename
          name="atom_based_value"/>
      </explicit>
    </entity>

    <entity
      name="maths_tuple_literal"
      supertypes="generic_literal">
      <explicit
        name="lit_value">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_value"/>
      </explicit>
    </entity>

    <entity
      name="maths_variable"
      supertypes="generic_variable">
      <explicit
        name="values_space">
        <typename
          name="maths_space"/>
      </explicit>
      <explicit
        name="name">
        <typename
          name="label"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(values_space)">
      </where>
    </entity>

    <entity
      name="maths_real_variable"
      supertypes="maths_variable real_numeric_variable">
      <where
        label="WR1"
        expression="subspace_of_es(SELF\maths_variable.values_space,es_reals)">
      </where>
    </entity>

    <entity
      name="maths_integer_variable"
      supertypes="maths_variable int_numeric_variable">
      <where
        label="WR1"
        expression="subspace_of_es(SELF\maths_variable.values_space,es_integers)">
      </where>
    </entity>

    <entity
      name="maths_boolean_variable"
      supertypes="maths_variable boolean_variable">
      <where
        label="WR1"
        expression="subspace_of_es(SELF\maths_variable.values_space,es_booleans)">
      </where>
    </entity>

    <entity
      name="maths_string_variable"
      supertypes="maths_variable string_variable">
      <where
        label="WR1"
        expression="subspace_of_es(SELF\maths_variable.values_space,es_strings)">
      </where>
    </entity>

    <entity
      name="function_application"
      supertypes="multiple_arity_generic_expression">
      <explicit
        name="func">
        <typename
          name="maths_function_select"/>
      </explicit>
      <explicit
        name="arguments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_expression"/>
      </explicit>
      <derived
        name="SELF\multiple_arity_generic_expression.operands"
        expression="[convert_to_maths_function(func)] + convert_to_operands(arguments)">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="function_applicability(func, arguments)">
      </where>
    </entity>

    <entity
      name="maths_space"
      abstract.supertype="YES"
      super.expression="(ONEOF (elementary_space,                                finite_integer_interval,                                integer_interval_from_min,                                integer_interval_to_max,                                finite_real_interval,                                real_interval_from_min,                                real_interval_to_max,                                cartesian_complex_number_region,                                polar_complex_number_region,                                finite_space,                                uniform_product_space,                                listed_product_space,                                extended_tuple_space,                                function_space))"
      supertypes="generic_expression">
    </entity>

    <entity
      name="elementary_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="space_id">
        <typename
          name="elementary_space_enumerators"/>
      </explicit>
    </entity>

    <entity
      name="finite_integer_interval"
      supertypes="maths_space generic_literal">
      <explicit
        name="min">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <explicit
        name="max">
        <builtintype
          type="INTEGER"/>
      </explicit>
      <derived
        name="size"
        expression="max - min + 1">
        <typename
          name="positive_integer"/>
      </derived>
      <where
        label="WR1"
        expression="min &lt;= max">
      </where>
    </entity>

    <entity
      name="integer_interval_from_min"
      supertypes="maths_space generic_literal">
      <explicit
        name="min">
        <builtintype
          type="INTEGER"/>
      </explicit>
    </entity>

    <entity
      name="integer_interval_to_max"
      supertypes="maths_space generic_literal">
      <explicit
        name="max">
        <builtintype
          type="INTEGER"/>
      </explicit>
    </entity>

    <entity
      name="finite_real_interval"
      supertypes="maths_space generic_literal">
      <explicit
        name="min">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="min_closure">
        <typename
          name="open_closed"/>
      </explicit>
      <explicit
        name="max">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="max_closure">
        <typename
          name="open_closed"/>
      </explicit>
      <where
        label="WR1"
        expression="min &lt; max">
      </where>
    </entity>

    <entity
      name="real_interval_from_min"
      supertypes="maths_space generic_literal">
      <explicit
        name="min">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="min_closure">
        <typename
          name="open_closed"/>
      </explicit>
    </entity>

    <entity
      name="real_interval_to_max"
      supertypes="maths_space generic_literal">
      <explicit
        name="max">
        <builtintype
          type="REAL"/>
      </explicit>
      <explicit
        name="max_closure">
        <typename
          name="open_closed"/>
      </explicit>
    </entity>

    <entity
      name="cartesian_complex_number_region"
      supertypes="maths_space generic_literal">
      <explicit
        name="real_constraint">
        <typename
          name="real_interval"/>
      </explicit>
      <explicit
        name="imag_constraint">
        <typename
          name="real_interval"/>
      </explicit>
      <where
        label="WR1"
        expression="min_exists(real_constraint) OR max_exists(real_constraint) OR       min_exists(imag_constraint) OR max_exists(imag_constraint)">
      </where>
    </entity>

    <entity
      name="polar_complex_number_region"
      supertypes="maths_space generic_literal">
      <explicit
        name="centre">
        <typename
          name="complex_number_literal"/>
      </explicit>
      <explicit
        name="distance_constraint">
        <typename
          name="real_interval"/>
      </explicit>
      <explicit
        name="direction_constraint">
        <typename
          name="finite_real_interval"/>
      </explicit>
      <where
        label="WR1"
        expression="min_exists(distance_constraint) AND (real_min(distance_constraint) &gt;= 0.0)">
      </where>
      <where
        label="WR2"
        expression="{-PI &lt;= direction_constraint.min &lt; PI}">
      </where>
      <where
        label="WR3"
        expression="direction_constraint.max - direction_constraint.min &lt;= 2.0*PI">
      </where>
      <where
        label="WR4"
        expression="(direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR       (direction_constraint.min_closure = open)">
      </where>
      <where
        label="WR5"
        expression="(direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR       (direction_constraint.max_closure = open) OR       (direction_constraint.min = -PI)">
      </where>
      <where
        label="WR6"
        expression="(real_min(distance_constraint) &gt; 0.0) OR max_exists(distance_constraint) OR       (direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR       (direction_constraint.max_closure = open)">
      </where>
    </entity>

    <entity
      name="finite_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="members">
        <aggregate
          type="SET"/>
        <typename
          name="maths_value"/>
      </explicit>
      <where
        label="WR1"
        expression="VALUE_UNIQUE(members)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (expr &lt;* QUERY (member &lt;* members |       'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF (member))       | NOT expression_is_constant(expr))) = 0">
      </where>
      <where
        label="WR3"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
    </entity>

    <entity
      name="uniform_product_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="base">
        <typename
          name="maths_space"/>
      </explicit>
      <explicit
        name="exponent">
        <typename
          name="positive_integer"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(base)">
      </where>
      <where
        label="WR2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="WR3"
        expression="base &lt;&gt; the_empty_space">
      </where>
    </entity>

    <entity
      name="listed_product_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="factors">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_space"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (QUERY (space &lt;* factors |       NOT (expression_is_constant(space)))) = 0">
      </where>
      <where
        label="WR2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="WR3"
        expression="NOT (the_empty_space IN factors)">
      </where>
    </entity>

    <entity
      name="extended_tuple_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="base">
        <typename
          name="product_space"/>
      </explicit>
      <explicit
        name="extender">
        <typename
          name="maths_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(base) AND       expression_is_constant(extender)">
      </where>
      <where
        label="WR2"
        expression="no_cyclic_space_reference(SELF, [])">
      </where>
      <where
        label="WR3"
        expression="extender &lt;&gt; the_empty_space">
      </where>
    </entity>

    <entity
      name="function_space"
      supertypes="maths_space generic_literal">
      <explicit
        name="domain_constraint">
        <typename
          name="space_constraint_type"/>
      </explicit>
      <explicit
        name="domain_argument">
        <typename
          name="maths_space"/>
      </explicit>
      <explicit
        name="range_constraint">
        <typename
          name="space_constraint_type"/>
      </explicit>
      <explicit
        name="range_argument">
        <typename
          name="maths_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(domain_argument) AND       expression_is_constant(range_argument)">
      </where>
      <where
        label="WR2"
        expression="(domain_argument &lt;&gt; the_empty_space) AND       (range_argument &lt;&gt; the_empty_space)">
      </where>
      <where
        label="WR3"
        expression="(domain_constraint &lt;&gt; sc_member) OR NOT       member_of(the_empty_space,domain_argument)">
      </where>
      <where
        label="WR4"
        expression="(range_constraint &lt;&gt; sc_member) OR NOT       member_of(the_empty_space,range_argument)">
      </where>
      <where
        label="WR5"
        expression="NOT (any_space_satisfies(domain_constraint,domain_argument) AND       any_space_satisfies(range_constraint,range_argument))">
      </where>
    </entity>

    <entity
      name="maths_function"
      abstract.supertype="YES"
      super.expression="(ONEOF (finite_function,                                constant_function,                                selector_function,                                elementary_function,                                restriction_function,                                repackaging_function,                                reindexed_array_function,                                series_composed_function,                                parallel_composed_function,                                explicit_table_function,                                homogeneous_linear_function,                                general_linear_function,                                b_spline_basis,                                b_spline_function,                                rationalize_function,                                partial_derivative_function,                                definite_integral_function,                                abstracted_expression_function,                                expression_denoted_function,                                imported_point_function,                                imported_curve_function,                                imported_surface_function,                                imported_volume_function,                                application_defined_function))"
      supertypes="generic_expression">
      <derived
        name="domain"
        expression="derive_function_domain(SELF)">
        <typename
          name="tuple_space"/>
      </derived>
      <derived
        name="range"
        expression="derive_function_range(SELF)">
        <typename
          name="tuple_space"/>
      </derived>
    </entity>

    <entity
      name="finite_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="pairs">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </explicit>
      <where
        label="WR1"
        expression="VALUE_UNIQUE(list_selected_components(pairs, 1))">
      </where>
    </entity>

    <entity
      name="constant_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="sole_output">
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="source_of_domain">
        <typename
          name="maths_space_or_function"/>
      </explicit>
      <where
        label="WR1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="WR2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
    </entity>

    <entity
      name="selector_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="selector">
        <typename
          name="input_selector"/>
      </explicit>
      <explicit
        name="source_of_domain">
        <typename
          name="maths_space_or_function"/>
      </explicit>
      <where
        label="WR1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="WR2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
    </entity>

    <entity
      name="elementary_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="func_id">
        <typename
          name="elementary_function_enumerators"/>
      </explicit>
    </entity>

    <entity
      name="restriction_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_space"/>
      </explicit>
    </entity>

    <entity
      name="repackaging_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="input_repack">
        <typename
          name="repackage_options"/>
      </explicit>
      <explicit
        name="output_repack">
        <typename
          name="repackage_options"/>
      </explicit>
      <explicit
        name="selected_output">
        <typename
          name="nonnegative_integer"/>
      </explicit>
      <where
        label="WR1"
        expression="(input_repack &lt;&gt; ro_wrap_as_tuple) OR       ((space_dimension(operand.domain) = 1) AND         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))))">
      </where>
      <where
        label="WR2"
        expression="(output_repack &lt;&gt; ro_unwrap_tuple) OR       ((space_dimension(operand.range) = 1) AND         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))))">
      </where>
      <where
        label="WR3"
        expression="selected_output &lt;= space_dimension( repackage(       operand.range, output_repack))">
      </where>
    </entity>

    <entity
      name="reindexed_array_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="starting_indices">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <where
        label="WR1"
        expression="function_is_array(SELF\unary_generic_expression.operand)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF(starting_indices) = SIZEOF(shape_of_array(       SELF\unary_generic_expression.operand))">
      </where>
    </entity>

    <entity
      name="series_composed_function"
      supertypes="maths_function multiple_arity_generic_expression">
      <explicit
        name="SELF\multiple_arity_generic_expression.operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="maths_function"/>
      </explicit>
      <where
        label="WR1"
        expression="composable_sequence(SELF\multiple_arity_generic_expression.operands)">
      </where>
    </entity>

    <entity
      name="parallel_composed_function"
      supertypes="maths_function multiple_arity_generic_expression">
      <explicit
        name="source_of_domain">
        <typename
          name="maths_space_or_function"/>
      </explicit>
      <explicit
        name="prep_functions">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="final_function">
        <typename
          name="maths_function_select"/>
      </explicit>
      <derived
        name="SELF\multiple_arity_generic_expression.operands"
        expression="convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function)">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="no_cyclic_domain_reference(source_of_domain, [SELF])">
      </where>
      <where
        label="WR2"
        expression="expression_is_constant(domain_from(source_of_domain))">
      </where>
      <where
        label="WR3"
        expression="parallel_composed_function_domain_check(domain_from(source_of_domain),       prep_functions)">
      </where>
      <where
        label="WR4"
        expression="parallel_composed_function_composability_check(prep_functions, final_function)">
      </where>
    </entity>

    <entity
      name="explicit_table_function"
      abstract.supertype="YES"
      super.expression="(ONEOF (listed_real_data,                                listed_integer_data,                                listed_logical_data,                                listed_string_data,                                listed_complex_number_data,                                listed_data,                                externally_listed_data,                                linearized_table_function,                                basic_sparse_matrix))"
      supertypes="maths_function">
      <explicit
        name="index_base">
        <typename
          name="zero_or_one"/>
      </explicit>
      <explicit
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </explicit>
    </entity>

    <entity
      name="listed_real_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
      <derived
        name="self\explicit_table_function.shape"
        expression="[SIZEOF (values)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
    </entity>

    <entity
      name="listed_integer_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <derived
        name="self\explicit_table_function.shape"
        expression="[SIZEOF (values)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
    </entity>

    <entity
      name="listed_logical_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="LOGICAL"/>
      </explicit>
      <derived
        name="self\explicit_table_function.shape"
        expression="[SIZEOF (values)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
    </entity>

    <entity
      name="listed_string_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="STRING"/>
      </explicit>
      <derived
        name="self\explicit_table_function.shape"
        expression="[SIZEOF (values)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
    </entity>

    <entity
      name="listed_complex_number_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
      <derived
        name="self\explicit_table_function.shape"
        expression="[SIZEOF (values)/2]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
      <where
        label="WR1"
        expression="NOT ODD (SIZEOF (values))">
      </where>
    </entity>

    <entity
      name="listed_data"
      supertypes="explicit_table_function generic_literal">
      <explicit
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="value_range">
        <typename
          name="maths_space"/>
      </explicit>
      <derived
        name="SELF\explicit_table_function.shape"
        expression="[SIZEOF (values)]">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </derived>
      <where
        label="WR1"
        expression="expression_is_constant(value_range)">
      </where>
      <where
        label="WR2"
        expression="SIZEOF (QUERY (val &lt;* values | NOT (member_of( val, value_range)))) = 0">
      </where>
    </entity>

    <entity
      name="externally_listed_data"
      supertypes="explicit_table_function generic_literal externally_defined_item">
      <explicit
        name="value_range">
        <typename
          name="maths_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(value_range)">
      </where>
    </entity>

    <entity
      name="linearized_table_function"
      super.expression="(ONEOF (standard_table_function,                       regular_table_function,                       triangular_matrix,                       symmetric_matrix,                       banded_matrix))"
      supertypes="explicit_table_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="first">
        <typename
          name="integer"/>
      </explicit>
      <derived
        name="source"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="function_is_1d_array(source)">
      </where>
      <where
        label="WR2"
        expression="member_of(first, source.domain)">
      </where>
    </entity>

    <entity
      name="standard_table_function"
      supertypes="linearized_table_function">
      <explicit
        name="order">
        <typename
          name="ordering_type"/>
      </explicit>
      <where
        label="WR1"
        expression="extremal_position_check(SELF)">
      </where>
    </entity>

    <entity
      name="regular_table_function"
      supertypes="linearized_table_function">
      <explicit
        name="increments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape)">
      </where>
      <where
        label="WR2"
        expression="extremal_position_check(self)">
      </where>
    </entity>

    <entity
      name="triangular_matrix"
      supertypes="linearized_table_function">
      <explicit
        name="default_entry">
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="lo_up">
        <typename
          name="lower_upper"/>
      </explicit>
      <explicit
        name="order">
        <typename
          name="ordering_type"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (SELF\explicit_table_function.shape) = 2">
      </where>
      <where
        label="WR2"
        expression="member_of(default_entry, SELF\maths_function.range)">
      </where>
    </entity>

    <entity
      name="strict_triangular_matrix"
      supertypes="triangular_matrix">
      <explicit
        name="main_diagonal_value">
        <typename
          name="maths_value"/>
      </explicit>
    </entity>

    <entity
      name="symmetric_matrix"
      supertypes="linearized_table_function">
      <explicit
        name="symmetry">
        <typename
          name="symmetry_type"/>
      </explicit>
      <explicit
        name="triangle">
        <typename
          name="lower_upper"/>
      </explicit>
      <explicit
        name="order">
        <typename
          name="ordering_type"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (SELF\explicit_table_function.shape) = 2">
      </where>
      <where
        label="WR2"
        expression="SELF\explicit_table_function.shape[1] =       SELF\explicit_table_function.shape[2]">
      </where>
      <where
        label="WR3"
        expression="NOT (symmetry = skew) OR (       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND        subspace_of_es(factor1(SELF\linearized_table_function.source.range),        es_numbers))">
      </where>
      <where
        label="WR4"
        expression="NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND        subspace_of_es(factor1(SELF\linearized_table_function.source.range),        es_complex_numbers))">
      </where>
    </entity>

    <entity
      name="symmetric_banded_matrix"
      supertypes="symmetric_matrix">
      <explicit
        name="default_entry">
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="above">
        <typename
          name="nonnegative_integer"/>
      </explicit>
      <where
        label="WR1"
        expression="member_of(default_entry,       factor1(SELF\linearized_table_function.source.range))">
      </where>
    </entity>

    <entity
      name="banded_matrix"
      supertypes="linearized_table_function">
      <explicit
        name="default_entry">
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="below">
        <typename
          name="integer"/>
      </explicit>
      <explicit
        name="above">
        <typename
          name="integer"/>
      </explicit>
      <explicit
        name="order">
        <typename
          name="ordering_type"/>
      </explicit>
      <where
        label="WR1"
        expression="SIZEOF (self\explicit_table_function.shape) = 2">
      </where>
      <where
        label="WR2"
        expression="-below &lt;= above">
      </where>
      <where
        label="WR3"
        expression="member_of(default_entry,       factor1(SELF\linearized_table_function.source.range))">
      </where>
    </entity>

    <entity
      name="basic_sparse_matrix"
      supertypes="explicit_table_function multiple_arity_generic_expression">
      <explicit
        name="SELF\multiple_arity_generic_expression.operands">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="default_entry">
        <typename
          name="maths_value"/>
      </explicit>
      <explicit
        name="order">
        <typename
          name="ordering_type"/>
      </explicit>
      <derived
        name="index"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename
          name="maths_function"/>
      </derived>
      <derived
        name="loc"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename
          name="maths_function"/>
      </derived>
      <derived
        name="val"
        expression="SELF\multiple_arity_generic_expression.operands[3]">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="function_is_1d_table(index)">
      </where>
      <where
        label="WR2"
        expression="function_is_1d_table(loc)">
      </where>
      <where
        label="WR3"
        expression="function_is_1d_table(val)">
      </where>
      <where
        label="WR4"
        expression="check_sparse_index_domain(index.domain, index_base, shape, order)">
      </where>
      <where
        label="WR5"
        expression="check_sparse_index_to_loc(index.range, loc.domain)">
      </where>
      <where
        label="WR6"
        expression="loc.domain = val.domain">
      </where>
      <where
        label="WR7"
        expression="check_sparse_loc_range(loc.range, index_base, shape, order)">
      </where>
      <where
        label="WR8"
        expression="member_of(default_entry, val.range)">
      </where>
    </entity>

    <entity
      name="homogeneous_linear_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="sum_index">
        <typename
          name="one_or_two"/>
      </explicit>
      <derived
        name="mat"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="function_is_2d_table(mat)">
      </where>
      <where
        label="WR2"
        expression="(space_dimension(mat.range) = 1) AND       subspace_of_es(factor1(mat.range),es_numbers)">
      </where>
    </entity>

    <entity
      name="general_linear_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="sum_index">
        <typename
          name="one_or_two"/>
      </explicit>
      <derived
        name="mat"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="function_is_2d_table(mat)">
      </where>
      <where
        label="WR2"
        expression="(space_dimension(mat.range) = 1) AND       subspace_of_es(factor1(mat.range),es_numbers)">
      </where>
    </entity>

    <entity
      name="b_spline_basis"
      supertypes="maths_function generic_literal">
      <explicit
        name="degree">
        <typename
          name="nonnegative_integer"/>
      </explicit>
      <explicit
        name="repeated_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </explicit>
      <derived
        name="order"
        expression="degree + 1">
        <typename
          name="positive_integer"/>
      </derived>
      <derived
        name="num_basis"
        expression="SIZEOF (repeated_knots) - order">
        <typename
          name="positive_integer"/>
      </derived>
      <where
        label="WR1"
        expression="num_basis &gt;= order">
      </where>
      <where
        label="WR2"
        expression="nondecreasing(repeated_knots)">
      </where>
      <where
        label="WR3"
        expression="repeated_knots[order] &lt; repeated_knots[num_basis+1]">
      </where>
    </entity>

    <entity
      name="b_spline_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="basis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="b_spline_basis"/>
      </explicit>
      <derived
        name="coef"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="function_is_table(coef)">
      </where>
      <where
        label="WR2"
        expression="(space_dimension(coef.range) = 1) AND       (number_superspace_of(factor1(coef.range)) = the_reals)">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (basis) &lt;=       SIZEOF (shape_of_array(coef))">
      </where>
      <where
        label="WR4"
        expression="compare_basis_and_coef(basis, coef)">
      </where>
    </entity>

    <entity
      name="rationalize_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <derived
        name="fun"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="(space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1)">
      </where>
      <where
        label="WR2"
        expression="number_tuple_subspace_check(factor1(fun.range))">
      </where>
      <where
        label="WR3"
        expression="space_dimension(factor1(fun.range)) &gt; 1">
      </where>
    </entity>

    <entity
      name="partial_derivative_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="d_variables">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="input_selector"/>
      </explicit>
      <explicit
        name="extension">
        <typename
          name="extension_options"/>
      </explicit>
      <derived
        name="derivand"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="space_is_continuum (derivand.range)">
      </where>
      <where
        label="WR2"
        expression="partial_derivative_check (derivand.domain, d_variables)">
      </where>
    </entity>

    <entity
      name="partial_derivative_expression"
      supertypes="unary_generic_expression">
      <explicit
        name="d_variables">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_variable"/>
      </explicit>
      <explicit
        name="extension">
        <typename
          name="extension_options"/>
      </explicit>
      <derived
        name="derivand"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="has_values_space (derivand)">
      </where>
      <where
        label="WR2"
        expression="space_is_continuum (values_space_of (derivand))">
      </where>
      <where
        label="WR3"
        expression="SIZEOF (QUERY (vbl &lt;* d_variables | (NOT subspace_of (values_space_of (vbl),    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))    )) = 0">
      </where>
    </entity>

    <entity
      name="definite_integral_function"
      supertypes="maths_function unary_generic_expression">
      <explicit
        name="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </explicit>
      <explicit
        name="variable_of_integration">
        <typename
          name="input_selector"/>
      </explicit>
      <explicit
        name="lower_limit_neg_infinity">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="upper_limit_pos_infinity">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="integrand"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="maths_function"/>
      </derived>
      <where
        label="WR1"
        expression="space_is_continuum (integrand.range)">
      </where>
      <where
        label="WR2"
        expression="definite_integral_check (integrand.domain, variable_of_integration,    lower_limit_neg_infinity, upper_limit_pos_infinity)">
      </where>
    </entity>

    <entity
      name="definite_integral_expression"
      supertypes="quantifier_expression">
      <explicit
        name="lower_limit_neg_infinity">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <explicit
        name="upper_limit_pos_infinity">
        <builtintype
          type="BOOLEAN"/>
      </explicit>
      <derived
        name="integrand"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename
          name="generic_expression"/>
      </derived>
      <derived
        name="variable_of_integration"
        expression="SELF\multiple_arity_generic_expression.operands[2]">
        <typename
          name="maths_variable"/>
      </derived>
      <derived
        name="SELF\quantifier_expression.variables"
        expression="[variable_of_integration]">
        <aggregate
          type="LIST"
          lower="1"
          upper="1"/>
        <typename
          name="UNIQUE"/>
      </derived>
      <where
        label="WR1"
        expression="has_values_space (integrand)">
      </where>
      <where
        label="WR2"
        expression="space_is_continuum (values_space_of (integrand))">
      </where>
      <where
        label="WR3"
        expression="definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,    lower_limit_neg_infinity, upper_limit_pos_infinity)">
      </where>
    </entity>

    <entity
      name="abstracted_expression_function"
      supertypes="maths_function quantifier_expression">
      <derived
        name="SELF\quantifier_expression.variables"
        expression="remove_first(SELF\multiple_arity_generic_expression.operands)">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="UNIQUE"/>
      </derived>
      <derived
        name="expr"
        expression="SELF\multiple_arity_generic_expression.operands[1]">
        <typename
          name="generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="SIZEOF (QUERY ( operand &lt;*       SELF\multiple_arity_generic_expression.operands | NOT (       has_values_space( operand)))) = 0">
      </where>
    </entity>

    <entity
      name="expression_denoted_function"
      supertypes="maths_function unary_generic_expression">
      <derived
        name="expr"
        expression="SELF\unary_generic_expression.operand">
        <typename
          name="generic_expression"/>
      </derived>
      <where
        label="WR1"
        expression="(schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr))">
      </where>
    </entity>

    <entity
      name="imported_point_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="geometry">
        <typename
          name="point"/>
      </explicit>
    </entity>

    <entity
      name="imported_curve_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="geometry">
        <typename
          name="curve"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename
          name="tuple_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity
      name="imported_surface_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="geometry">
        <typename
          name="surface"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename
          name="tuple_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity
      name="imported_volume_function"
      supertypes="maths_function generic_literal">
      <explicit
        name="geometry">
        <typename
          name="volume"/>
      </explicit>
      <explicit
        name="parametric_domain">
        <typename
          name="tuple_space"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(parametric_domain)">
      </where>
    </entity>

    <entity
      name="application_defined_function"
      supertypes="maths_function">
      <explicit
        name="explicit_domain">
        <typename
          name="tuple_space"/>
      </explicit>
      <explicit
        name="explicit_range">
        <typename
          name="tuple_space"/>
      </explicit>
      <explicit
        name="parameters">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_value"/>
      </explicit>
      <where
        label="WR1"
        expression="expression_is_constant(explicit_domain)">
      </where>
      <where
        label="WR2"
        expression="expression_is_constant(explicit_range)">
      </where>
    </entity>

    <entity
      name="mathematical_description">
      <explicit
        name="described">
        <typename
          name="maths_expression"/>
      </explicit>
      <explicit
        name="describing">
        <builtintype
          type="STRING"/>
      </explicit>
      <explicit
        name="encoding">
        <typename
          name="label"/>
      </explicit>
    </entity>

    <function
      name="all_members_of_es">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="sv">
        <aggregate
          type="SET"/>
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="es">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <algorithm>
  CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) &gt; 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    -- complex_number_literal, maths_space, or maths_function.
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
      </algorithm>

    </function>

    <function
      name="any_space_satisfies">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="sc">
        <typename
          name="space_constraint_type"/>
      </parameter>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="assoc_product_space">
      <typename
        name="tuple_space"/>
      <parameter
        name="ts1">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="ts2">
        <typename
          name="tuple_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender &lt;&gt; factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
      </algorithm>

    </function>

    <function
      name="atan2">
      <builtintype
        type="REAL"/>
      <parameter
        name="y">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="x">
        <builtintype
          type="REAL"/>
      </parameter>
      <algorithm>
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x &lt; 0.0 THEN
    IF y &lt; 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
      </algorithm>

    </function>

    <function
      name="bool">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="lgcl">
        <builtintype
          type="LOGICAL"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl &lt;&gt; TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="check_sparse_index_domain">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="idxdom">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <algorithm>
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min &lt;= base) AND (interval.max &gt;= base + shape[i])));
  -- The index function is evaluated at (base+shape[i]) when determining the
  -- upper search bound for entries of the last row or column, respectively.
      </algorithm>

    </function>

    <function
      name="check_sparse_loc_range">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="locrng">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <algorithm>
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min &gt;= base) AND (interval.max &lt;= base + shape[i] - 1)));
      </algorithm>

    </function>

    <function
      name="check_sparse_index_to_loc">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="index_range">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="loc_domain">
        <typename
          name="tuple_space"/>
      </parameter>
      <algorithm>
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min &lt;= idx_rng_itvl.min) AND
    (idx_rng_itvl.max &lt;= loc_dmn_itvl.max+1)));
      </algorithm>

    </function>

    <function
      name="compare_basis_and_coef">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="basis">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="b_spline_basis"/>
      </parameter>
      <parameter
        name="coef">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) &lt; SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) &lt;&gt; TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="compare_list_and_value">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="lv">
        <aggregate
          type="LIST"/>
        <typename
          name="GENERICG"/>
      </parameter>
      <parameter
        name="op">
        <typename
          name="elementary_function_enumerators"/>
      </parameter>
      <parameter
        name="v">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (lv) OR NOT EXISTS (op) OR NOT EXISTS (v) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF (lv);
    IF NOT compare_values(lv[i], op, v) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="compare_values">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="v1">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="op">
        <typename
          name="elementary_function_enumerators"/>
      </parameter>
      <parameter
        name="v2">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <algorithm>
  -- This algorithm assumes a comparison between &quot;incompatible&quot; types will
  -- produce the indeterminate value (or UNKNOWN?).
  LOCAL
    logl : LOGICAL := UNKNOWN;
  END_LOCAL;
  IF NOT EXISTS (v1) OR NOT EXISTS (op) OR NOT EXISTS (v2) THEN
    RETURN (FALSE);
  END_IF;
  CASE op OF
  ef_eq_i : logl := (v1 = v2);
  ef_ne_i : logl := (v1 &lt;&gt; v2);
  ef_gt_i : logl := (v1 &gt; v2);
  ef_lt_i : logl := (v1 &lt; v2);
  ef_ge_i : logl := (v1 &gt;= v2);
  ef_le_i : logl := (v1 &lt;= v2);
  END_CASE;
  IF EXISTS (logl) THEN
    IF logl = TRUE THEN  RETURN (TRUE);  END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="compatible_complex_number_regions">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="sp1">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="sp2">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max &gt; PI) AND (prgn2.direction_constraint.max &lt; PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max &gt; PI) AND (prgn1.direction_constraint.max &lt; PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
      </algorithm>

    </function>

    <function
      name="compatible_es_values">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="esval1">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <parameter
        name="esval2">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <algorithm>
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 &gt;= es_numbers) AND (esval1 &lt;= es_integers);
  esval2_is_numeric := (esval2 &gt;= es_numbers) AND (esval2 &lt;= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="compatible_intervals">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="sp1">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="sp2">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin &gt; amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin &gt; amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="compatible_spaces">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="sp1">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="sp2">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent &lt;&gt; n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m &lt; n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n &lt;&gt; SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n &gt; m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="composable_sequence">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="convert_to_literal">
      <typename
        name="generic_literal"/>
      <parameter
        name="val">
        <typename
          name="maths_atom"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="convert_to_maths_function">
      <typename
        name="maths_function"/>
      <parameter
        name="func">
        <typename
          name="maths_function_select"/>
      </parameter>
      <algorithm>
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
      </algorithm>

    </function>

    <function
      name="convert_to_maths_value">
      <typename
        name="maths_value"/>
      <parameter
        name="val">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="convert_to_operand">
      <typename
        name="generic_expression"/>
      <parameter
        name="val">
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="convert_to_operands">
      <aggregate
        type="LIST"/>
      <typename
        name="generic_expression"/>
      <parameter
        name="values">
        <typename
          name="AGGREGATE OF maths_value"/>
      </parameter>
      <algorithm>
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
      </algorithm>

    </function>

    <function
      name="convert_to_operands_prcmfn">
      <aggregate
        type="LIST"
        lower="2"
        upper="?"/>
      <typename
        name="generic_expression"/>
      <parameter
        name="srcdom">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <parameter
        name="prepfun">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="finfun">
        <typename
          name="maths_function_select"/>
      </parameter>
      <algorithm>
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
      </algorithm>

    </function>

    <function
      name="definite_integral_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="domain">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="vrblint">
        <typename
          name="input_selector"/>
      </parameter>
      <parameter
        name="lowerinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="upperinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <algorithm>
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k &gt; dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="definite_integral_expr_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="generic_expression"/>
      </parameter>
      <parameter
        name="lowerinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="upperinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <algorithm>
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) &lt;&gt; nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="derive_definite_integral_domain">
      <typename
        name="tuple_space"/>
      <parameter
        name="igrl">
        <typename
          name="definite_integral_function"/>
      </parameter>
      <algorithm>

  -- Internal utility function:
  FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx &lt;= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx &lt;= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix &gt; 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix &gt; 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
      </algorithm>

    </function>

    <function
      name="derive_elementary_function_domain">
      <typename
        name="tuple_space"/>
      <parameter
        name="ef_val">
        <typename
          name="elementary_function_enumerators"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
      </algorithm>

    </function>

    <function
      name="derive_elementary_function_range">
      <typename
        name="tuple_space"/>
      <parameter
        name="ef_val">
        <typename
          name="elementary_function_enumerators"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
      </algorithm>

    </function>

    <function
      name="derive_finite_function_domain">
      <typename
        name="tuple_space"/>
      <parameter
        name="pairs">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <algorithm>
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
      </algorithm>

    </function>

    <function
      name="derive_finite_function_range">
      <typename
        name="tuple_space"/>
      <parameter
        name="pairs">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <algorithm>
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
      </algorithm>

    </function>

    <function
      name="derive_function_domain">
      <typename
        name="tuple_space"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] &lt;&gt; shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] &lt;&gt; shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="derive_function_range">
      <typename
        name="tuple_space"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output &gt; 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_point_function.geometry))));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_curve_function.geometry))));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_surface_function.geometry))));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_volume_function.geometry))));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="domain_from">
      <typename
        name="tuple_space"/>
      <parameter
        name="ref">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
      </algorithm>

    </function>

    <function
      name="dot_count">
      <builtintype
        type="INTEGER"/>
      <parameter
        name="str">
        <builtintype
          type="STRING"/>
      </parameter>
      <algorithm>
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
      </algorithm>

    </function>

    <function
      name="dotted_identifiers_syntax">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="str">
        <builtintype
          type="STRING"/>
      </parameter>
      <algorithm>
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k &lt;= LENGTH (str);
    IF (str[k] &lt;&gt; '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="drop_numeric_constraints">
      <typename
        name="maths_space"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
      </algorithm>

    </function>

    <function
      name="enclose_cregion_in_pregion">
      <typename
        name="polar_complex_number_region"/>
      <parameter
        name="crgn">
        <typename
          name="cartesian_complex_number_region"/>
      </parameter>
      <parameter
        name="centre">
        <typename
          name="complex_number_literal"/>
      </parameter>
      <algorithm>
  -- Find equivalent direction in range -PI &lt; a &lt;= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a &gt; PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a &lt;= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
      </algorithm>

    </function>

    <function
      name="strictly_in">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="z">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="zitv">
        <typename
          name="real_interval"/>
      </parameter>
      <algorithm>
    RETURN ((NOT min_exists(zitv) OR (z &gt; real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z &lt; real_max(zitv))));
      </algorithm>

    </function>

    <function
      name="enclose_pregion_in_cregion">
      <typename
        name="cartesian_complex_number_region"/>
      <parameter
        name="prgn">
        <typename
          name="polar_complex_number_region"/>
      </parameter>
      <algorithm>
  PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a &lt; aitv.min THEN
      -- a+2.0*PI &gt; aitv.min automatically!
      IF a+2.0*PI &lt; aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a &lt; aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) &gt;= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) &gt;= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) &lt;= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) &gt;= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) &lt;= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
      </algorithm>

    </function>

    <function
      name="enclose_pregion_in_pregion">
      <typename
        name="polar_complex_number_region"/>
      <parameter
        name="prgn">
        <typename
          name="polar_complex_number_region"/>
      </parameter>
      <parameter
        name="centre">
        <typename
          name="complex_number_literal"/>
      </parameter>
      <algorithm>
  -- Find equivalent direction in range -PI &lt; a &lt;= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a &gt; PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a &lt;= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
      </algorithm>

    </function>

    <function
      name="strictly_in">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="a">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="aitv">
        <typename
          name="finite_real_interval"/>
      </parameter>
      <algorithm>
    a := angle(a);
    RETURN ({aitv.min &lt; a &lt; aitv.max} OR {aitv.min &lt; a+2.0*PI &lt; aitv.max});
      </algorithm>

    </function>

    <function
      name="equal_cregion_pregion">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="crgn">
        <typename
          name="cartesian_complex_number_region"/>
      </parameter>
      <parameter
        name="prgn">
        <typename
          name="polar_complex_number_region"/>
      </parameter>
      <algorithm>
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) &lt;&gt; 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="equal_maths_functions">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="fun1">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="fun2">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
      </algorithm>

    </function>

    <function
      name="equal_maths_spaces">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="spc1">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="spc2">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 &lt;&gt; spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt &lt;&gt; spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt &lt;&gt; SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent &lt;&gt; SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) &lt;&gt; SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint &lt;&gt; fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint &lt;&gt; sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint &lt;&gt; sc_subspace) OR
        (fs2.domain_constraint &lt;&gt; sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) &lt;&gt;
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint &lt;&gt; fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint &lt;&gt; sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint &lt;&gt; sc_subspace) OR
        (fs2.range_constraint &lt;&gt; sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) &lt;&gt;
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="equal_maths_values">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="val1">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="val2">
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
      </algorithm>

    </function>

    <function
      name="es_subspace_of_es">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="es1">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <parameter
        name="es2">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="expression_is_constant">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
      </algorithm>

    </function>

    <function
      name="extract_factors">
      <typename
        name="tuple_space"/>
      <parameter
        name="tspace">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="m">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="n">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
      </algorithm>

    </function>

    <function
      name="extremal_position_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="fun">
        <typename
          name="linearized_table_function"/>
      </parameter>
      <algorithm>
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min &lt;= index &lt;= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] &gt;= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min &lt;= index &lt;= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min &lt;= index &lt;= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="factor1">
      <typename
        name="maths_space"/>
      <parameter
        name="tspace">
        <typename
          name="tuple_space"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="factor_space">
      <typename
        name="maths_space"/>
      <parameter
        name="tspace">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="idx">
        <typename
          name="positive_integer"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx &lt;= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx &lt;= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx &lt;= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="free_variables_of">
      <aggregate
        type="SET"/>
      <typename
        name="generic_variable"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge &lt;* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
      </algorithm>

    </function>

    <function
      name="function_applicability">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function_select"/>
      </parameter>
      <parameter
        name="arguments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) &lt;&gt; narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) &gt; narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="function_is_1d_array">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="function_is_1d_table">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="function_is_2d_table">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) &lt;&gt; 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
      </algorithm>

    </function>

    <function
      name="function_is_array">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="function_is_table">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base &lt;&gt; 0) AND (base &lt;&gt; 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min &lt;&gt; base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="has_values_space">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="list_selected_components">
      <aggregate
        type="LIST"/>
      <typename
        name="maths_value"/>
      <parameter
        name="aggr">
        <aggregate
          type="LIST"/>
        <typename
          name="LIST"/>
      </parameter>
      <parameter
        name="k">
        <typename
          name="positive_integer"/>
      </parameter>
      <algorithm>
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k &lt;= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
      </algorithm>

    </function>

    <function
      name="make_abstracted_expression_function">
      <typename
        name="abstracted_expression_function"/>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  RETURN (abstracted_expression_function()
    || maths_function()
      || generic_expression()
    || quantifier_expression (remove_first (operands))  -- derived
      || multiple_arity_generic_expression (operands) );
      </algorithm>

    </function>

    <function
      name="make_atom_based_literal">
      <typename
        name="atom_based_literal"/>
      <parameter
        name="lit_value">
        <typename
          name="atom_based_value"/>
      </parameter>
      <algorithm>
  RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_b_spline_basis">
      <typename
        name="b_spline_basis"/>
      <parameter
        name="degree">
        <typename
          name="nonnegative_integer"/>
      </parameter>
      <parameter
        name="repeated_knots">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </parameter>
      <algorithm>
  RETURN (b_spline_basis (degree, repeated_knots)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_b_spline_function">
      <typename
        name="b_spline_function"/>
      <parameter
        name="coef">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="bases">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="b_spline_basis"/>
      </parameter>
      <algorithm>
  RETURN (b_spline_function (bases)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (coef) );
      </algorithm>

    </function>

    <function
      name="make_banded_matrix">
      <typename
        name="banded_matrix"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="source">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="first">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="default_entry">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="below">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="above">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <algorithm>
  RETURN (banded_matrix (default_entry, below, above, order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (source) );
      </algorithm>

    </function>

    <function
      name="make_basic_sparse_matrix">
      <typename
        name="basic_sparse_matrix"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="3"
          upper="3"/>
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="default_entry">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <algorithm>
  RETURN (basic_sparse_matrix (default_entry, order)
    || explicit_table_function (index_base, shape)
      || maths_function()
        || generic_expression()
    || multiple_arity_generic_expression (operands) );
      </algorithm>

    </function>

    <function
      name="make_binary_literal">
      <typename
        name="binary_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="BINARY"/>
      </parameter>
      <algorithm>
  RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_boolean_literal">
      <typename
        name="boolean_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <algorithm>
  RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
      </algorithm>

    </function>

    <function
      name="make_cartesian_complex_number_region">
      <typename
        name="cartesian_complex_number_region"/>
      <parameter
        name="real_constraint">
        <typename
          name="real_interval"/>
      </parameter>
      <parameter
        name="imag_constraint">
        <typename
          name="real_interval"/>
      </parameter>
      <algorithm>
  RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_complex_number_literal">
      <typename
        name="complex_number_literal"/>
      <parameter
        name="rpart">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="ipart">
        <builtintype
          type="REAL"/>
      </parameter>
      <algorithm>
  RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_constant_function">
      <typename
        name="constant_function"/>
      <parameter
        name="sole_value">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="src_of_domn">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <algorithm>
  RETURN (constant_function (sole_value, src_of_domn)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_cos_expression">
      <typename
        name="cos_expression"/>
      <parameter
        name="operand">
        <typename
          name="numeric_expression"/>
      </parameter>
      <algorithm>
  RETURN (cos_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_definite_integral_expression">
      <typename
        name="definite_integral_expression"/>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="4"/>
        <typename
          name="generic_expression"/>
      </parameter>
      <parameter
        name="loinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="upinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <algorithm>
  RETURN (definite_integral_expression (loinf, upinf)
    || quantifier_expression ([operands[2]])
      || multiple_arity_generic_expression (operands)
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_definite_integral_function">
      <typename
        name="definite_integral_function"/>
      <parameter
        name="integrand">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="varintg">
        <typename
          name="input_selector"/>
      </parameter>
      <parameter
        name="loinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <parameter
        name="upinf">
        <builtintype
          type="BOOLEAN"/>
      </parameter>
      <algorithm>
  RETURN (definite_integral_function (varintg, loinf, upinf)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (integrand) );
      </algorithm>

    </function>

    <function
      name="make_elementary_function">
      <typename
        name="elementary_function"/>
      <parameter
        name="func_id">
        <typename
          name="elementary_function_enumerators"/>
      </parameter>
      <algorithm>
  RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_elementary_space">
      <typename
        name="elementary_space"/>
      <parameter
        name="space_id">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <algorithm>
  RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_environment">
      <typename
        name="environment"/>
      <parameter
        name="varbl">
        <typename
          name="generic_variable"/>
      </parameter>
      <parameter
        name="sem">
        <typename
          name="variable_semantics"/>
      </parameter>
      <algorithm>
  RETURN (environment (varbl, sem) );
      </algorithm>

    </function>

    <function
      name="make_expression_denoted_function">
      <typename
        name="expression_denoted_function"/>
      <parameter
        name="expression">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  RETURN (expression_denoted_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (expression) );
      </algorithm>

    </function>

    <function
      name="make_extended_tuple_space">
      <typename
        name="extended_tuple_space"/>
      <parameter
        name="base">
        <typename
          name="product_space"/>
      </parameter>
      <parameter
        name="extender">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_finite_function">
      <typename
        name="finite_function"/>
      <parameter
        name="pairs">
        <aggregate
          type="SET"
          lower="1"
          upper="?"/>
        <typename
          name="LIST"/>
      </parameter>
      <algorithm>
  RETURN (finite_function (pairs)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_finite_integer_interval">
      <typename
        name="finite_integer_interval"/>
      <parameter
        name="min">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="max">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_finite_real_interval">
      <typename
        name="finite_real_interval"/>
      <parameter
        name="min">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="minclo">
        <typename
          name="open_closed"/>
      </parameter>
      <parameter
        name="max">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="maxclo">
        <typename
          name="open_closed"/>
      </parameter>
      <algorithm>
  RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_finite_space">
      <typename
        name="finite_space"/>
      <parameter
        name="members">
        <aggregate
          type="SET"/>
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_function_application">
      <typename
        name="function_application"/>
      <parameter
        name="afunction">
        <typename
          name="maths_function_select"/>
      </parameter>
      <parameter
        name="arguments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_function_space">
      <typename
        name="function_space"/>
      <parameter
        name="domain_constraint">
        <typename
          name="space_constraint_type"/>
      </parameter>
      <parameter
        name="domain_argument">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="range_constraint">
        <typename
          name="space_constraint_type"/>
      </parameter>
      <parameter
        name="range_argument">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_general_linear_function">
      <typename
        name="general_linear_function"/>
      <parameter
        name="mat">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="sum_index">
        <typename
          name="one_or_two"/>
      </parameter>
      <algorithm>
  RETURN (general_linear_function (sum_index)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (mat) );
      </algorithm>

    </function>

    <function
      name="make_int_literal">
      <typename
        name="int_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
      </algorithm>

    </function>

    <function
      name="make_integer_interval_from_min">
      <typename
        name="integer_interval_from_min"/>
      <parameter
        name="min">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (integer_interval_from_min (min)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_listed_complex_number_data">
      <typename
        name="listed_complex_number_data"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="values">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="REAL"/>
      </parameter>
      <algorithm>
  RETURN (listed_complex_number_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)/2])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_listed_data">
      <typename
        name="listed_data"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="values">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="value_range">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  RETURN (listed_data (values, value_range)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_listed_integer_data">
      <typename
        name="listed_integer_data"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (listed_integer_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_listed_product_space">
      <typename
        name="listed_product_space"/>
      <parameter
        name="factors">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_listed_real_data">
      <typename
        name="listed_real_data"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="values">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="REAL"/>
      </parameter>
      <algorithm>
  RETURN (listed_real_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_logical_literal">
      <typename
        name="logical_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="LOGICAL"/>
      </parameter>
      <algorithm>
  RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_maths_enum_literal">
      <typename
        name="maths_enum_literal"/>
      <parameter
        name="lit_value">
        <typename
          name="maths_enum_atom"/>
      </parameter>
      <algorithm>
  RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_maths_real_variable">
      <typename
        name="maths_real_variable"/>
      <parameter
        name="values_space">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="name">
        <typename
          name="label"/>
      </parameter>
      <algorithm>
  RETURN (maths_real_variable()
    || maths_variable (values_space, name)
      || generic_variable()
        || simple_generic_expression()
          || generic_expression()
    || real_numeric_variable()
      || numeric_variable()
        || variable() );
      </algorithm>

    </function>

    <function
      name="make_maths_tuple_literal">
      <typename
        name="maths_tuple_literal"/>
      <parameter
        name="lit_value">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_mult_expression">
      <typename
        name="mult_expression"/>
      <parameter
        name="operands">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  RETURN (mult_expression()
    || multiple_arity_numeric_expression()
      || numeric_expression()
        || expression()
          || generic_expression()
      || multiple_arity_generic_expression (operands) );
      </algorithm>

    </function>

    <function
      name="make_parallel_composed_function">
      <typename
        name="parallel_composed_function"/>
      <parameter
        name="srcdom">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <parameter
        name="prepfuncs">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="finfunc">
        <typename
          name="maths_function_select"/>
      </parameter>
      <algorithm>
  RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );  -- derived
      </algorithm>

    </function>

    <function
      name="make_partial_derivative_expression">
      <typename
        name="partial_derivative_expression"/>
      <parameter
        name="derivand">
        <typename
          name="generic_expression"/>
      </parameter>
      <parameter
        name="dvars">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_variable"/>
      </parameter>
      <parameter
        name="extend">
        <typename
          name="extension_options"/>
      </parameter>
      <algorithm>
  RETURN (partial_derivative_expression (dvars, extend)
    || unary_generic_expression (derivand)
      || generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_partial_derivative_function">
      <typename
        name="partial_derivative_function"/>
      <parameter
        name="derivand">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="dvars">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="input_selector"/>
      </parameter>
      <parameter
        name="extend">
        <typename
          name="extension_options"/>
      </parameter>
      <algorithm>
  RETURN (partial_derivative_function (dvars, extend)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (derivand) );
      </algorithm>

    </function>

    <function
      name="make_polar_complex_number_region">
      <typename
        name="polar_complex_number_region"/>
      <parameter
        name="centre">
        <typename
          name="complex_number_literal"/>
      </parameter>
      <parameter
        name="dis_constraint">
        <typename
          name="real_interval"/>
      </parameter>
      <parameter
        name="dir_constraint">
        <typename
          name="finite_real_interval"/>
      </parameter>
      <algorithm>
  RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_rationalize_function">
      <typename
        name="rationalize_function"/>
      <parameter
        name="fun">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  RETURN (rationalize_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (fun) );
      </algorithm>

    </function>

    <function
      name="make_real_interval_from_min">
      <typename
        name="real_interval_from_min"/>
      <parameter
        name="min">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="minclo">
        <typename
          name="open_closed"/>
      </parameter>
      <algorithm>
  RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_real_interval_to_max">
      <typename
        name="real_interval_to_max"/>
      <parameter
        name="max">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="maxclo">
        <typename
          name="open_closed"/>
      </parameter>
      <algorithm>
  RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_real_literal">
      <typename
        name="real_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="REAL"/>
      </parameter>
      <algorithm>
  RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
      </algorithm>

    </function>

    <function
      name="make_regular_table_function">
      <typename
        name="regular_table_function"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="operand">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="first">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="increments">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (regular_table_function (increments)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_reindexed_array_function">
      <typename
        name="reindexed_array_function"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="start_idxs">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <algorithm>
  RETURN (reindexed_array_function(start_idxs)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (func) );
      </algorithm>

    </function>

    <function
      name="make_repackaging_function">
      <typename
        name="repackaging_function"/>
      <parameter
        name="operand">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="input_repack">
        <typename
          name="repackage_options"/>
      </parameter>
      <parameter
        name="output_repack">
        <typename
          name="repackage_options"/>
      </parameter>
      <parameter
        name="selected_output">
        <typename
          name="nonnegative_integer"/>
      </parameter>
      <algorithm>
  RETURN (repackaging_function (input_repack, output_repack, selected_output)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_selector_function">
      <typename
        name="selector_function"/>
      <parameter
        name="selector">
        <typename
          name="input_selector"/>
      </parameter>
      <parameter
        name="src_of_domn">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <algorithm>
  RETURN (selector_function (selector, src_of_domn)
    || maths_function()
       || generic_expression()
    || generic_literal()
       || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="make_series_composed_function">
      <typename
        name="series_composed_function"/>
      <parameter
        name="functions">
        <aggregate
          type="LIST"
          lower="2"
          upper="?"/>
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  RETURN (series_composed_function()
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (functions) );
      </algorithm>

    </function>

    <function
      name="make_sin_expression">
      <typename
        name="sin_expression"/>
      <parameter
        name="operand">
        <typename
          name="numeric_expression"/>
      </parameter>
      <algorithm>
  RETURN (sin_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_standard_table_function">
      <typename
        name="standard_table_function"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="operand">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="first">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <algorithm>
  RETURN (standard_table_function (order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_strict_triangular_matrix">
      <typename
        name="strict_triangular_matrix"/>
      <parameter
        name="index_base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="source">
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="first">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <parameter
        name="default_entry">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="lo_up">
        <typename
          name="lower_upper"/>
      </parameter>
      <parameter
        name="order">
        <typename
          name="ordering_type"/>
      </parameter>
      <parameter
        name="main_diagonal_value">
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  RETURN (strict_triangular_matrix (main_diagonal_value)
    || triangular_matrix (default_entry, lo_up, order)
      || linearized_table_function (first)
        || explicit_table_function (index_base, shape)
          || maths_function()
            || generic_expression()
        || unary_generic_expression (source) );
      </algorithm>

    </function>

    <function
      name="make_string_literal">
      <typename
        name="string_literal"/>
      <parameter
        name="lit_value">
        <builtintype
          type="STRING"/>
      </parameter>
      <algorithm>
  RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
      </algorithm>

    </function>

    <function
      name="make_unary_minus_expression">
      <typename
        name="unary_minus_expression"/>
      <parameter
        name="operand">
        <typename
          name="numeric_expression"/>
      </parameter>
      <algorithm>
  RETURN (unary_minus_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
      </algorithm>

    </function>

    <function
      name="make_uniform_product_space">
      <typename
        name="uniform_product_space"/>
      <parameter
        name="base">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="exponent">
        <typename
          name="positive_integer"/>
      </parameter>
      <algorithm>
  RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
      </algorithm>

    </function>

    <function
      name="max_exists">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
      </algorithm>

    </function>

    <function
      name="max_included">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="member_of">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="val">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>

  -- Trivial function introduced to avoid NIST Fedex compiler error
  FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
      </algorithm>

    </function>

    <function
      name="min_exists">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
      </algorithm>

    </function>

    <function
      name="min_included">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="no_cyclic_domain_reference">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="ref">
        <typename
          name="maths_space_or_function"/>
      </parameter>
      <parameter
        name="used">
        <aggregate
          type="SET"/>
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="no_cyclic_space_reference">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="refs">
        <aggregate
          type="SET"/>
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp &lt;* QUERY (mem &lt;* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac &lt;* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="nondecreasing">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="lr">
        <aggregate
          type="LIST"/>
        <typename
          name="REAL"/>
      </parameter>
      <algorithm>
  IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] &lt; lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="number_superspace_of">
      <typename
        name="elementary_space"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="number_tuple_subspace_check">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="one_tuples_of">
      <typename
        name="tuple_space"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  RETURN (make_uniform_product_space (spc, 1));
      </algorithm>

    </function>

    <function
      name="parallel_composed_function_composability_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="funcs">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_function"/>
      </parameter>
      <parameter
        name="final">
        <typename
          name="maths_function_select"/>
      </parameter>
      <algorithm>
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
      </algorithm>

    </function>

    <function
      name="parallel_composed_function_domain_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="comdom">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="funcs">
        <aggregate
          type="LIST"/>
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="parse_express_identifier">
      <typename
        name="positive_integer"/>
      <parameter
        name="s">
        <builtintype
          type="STRING"/>
      </parameter>
      <parameter
        name="i">
        <typename
          name="positive_integer"/>
      </parameter>
      <algorithm>
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i &lt;= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k &gt; LENGTH (s)) OR
        ((s[k] &lt;&gt; '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
      </algorithm>

    </function>

    <function
      name="partial_derivative_check">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="domain">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="d_vars">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="input_selector"/>
      </parameter>
      <algorithm>
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k &gt; dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
      </algorithm>

    </function>

    <function
      name="real_max">
      <builtintype
        type="REAL"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="real_min">
      <builtintype
        type="REAL"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="regular_indexing">
      <builtintype
        type="INTEGER"/>
      <parameter
        name="sub">
        <aggregate
          type="LIST"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <parameter
        name="base">
        <typename
          name="zero_or_one"/>
      </parameter>
      <parameter
        name="shape">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="positive_integer"/>
      </parameter>
      <parameter
        name="inc">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="INTEGER"/>
      </parameter>
      <parameter
        name="first">
        <builtintype
          type="INTEGER"/>
      </parameter>
      <algorithm>
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) &lt;&gt; SIZEOF (inc)) OR (SIZEOF (sub) &lt;&gt; SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 &lt;= k &lt; shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
      </algorithm>

    </function>

    <function
      name="remove_first">
      <aggregate
        type="LIST"/>
      <typename
        name="GENERICGEN"/>
      <parameter
        name="alist">
        <aggregate
          type="LIST"/>
        <typename
          name="GENERICGEN"/>
      </parameter>
      <algorithm>
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) &gt; 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
      </algorithm>

    </function>

    <function
      name="repackage">
      <typename
        name="tuple_space"/>
      <parameter
        name="tspace">
        <typename
          name="tuple_space"/>
      </parameter>
      <parameter
        name="repckg">
        <typename
          name="repackage_options"/>
      </parameter>
      <algorithm>
  CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
      </algorithm>

    </function>

    <function
      name="shape_of_array">
      <aggregate
        type="LIST"/>
      <typename
        name="positive_integer"/>
      <parameter
        name="func">
        <typename
          name="maths_function"/>
      </parameter>
      <algorithm>
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
      </algorithm>

    </function>

    <function
      name="simplify_function_application">
      <typename
        name="maths_value"/>
      <parameter
        name="expr">
        <typename
          name="function_application"/>
      </parameter>
      <algorithm>
  FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
      </algorithm>

    </function>

    <function
      name="makec">
      <typename
        name="complex_number_literal"/>
      <parameter
        name="x">
        <builtintype
          type="REAL"/>
      </parameter>
      <parameter
        name="y">
        <builtintype
          type="REAL"/>
      </parameter>
      <algorithm>
    RETURN (make_complex_number_literal(x,y));
      </algorithm>

    </function>

    <function
      name="good_t">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="v">
        <typename
          name="maths_value"/>
      </parameter>
      <parameter
        name="tn">
        <builtintype
          type="STRING"/>
      </parameter>
      <algorithm>
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="simplify_generic_expression">
      <typename
        name="maths_value"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
      </algorithm>

    </function>

    <function
      name="restore_binary">
      <typename
        name="generic_expression"/>
      <parameter
        name="expr">
        <typename
          name="binary_generic_expression"/>
      </parameter>
      <parameter
        name="opd1">
        <typename
          name="generic_expression"/>
      </parameter>
      <parameter
        name="opd2">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
      </algorithm>

    </function>

    <function
      name="restore_mulary">
      <typename
        name="generic_expression"/>
      <parameter
        name="expr">
        <typename
          name="multiple_arity_generic_expression"/>
      </parameter>
      <parameter
        name="ops">
        <aggregate
          type="LIST"/>
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
    expr.operands := ops;
    RETURN (expr);
      </algorithm>

    </function>

    <function
      name="make_number_literal">
      <typename
        name="generic_literal"/>
      <parameter
        name="nmb">
        <builtintype
          type="NUMBER"/>
      </parameter>
      <algorithm>
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
      </algorithm>

    </function>

    <function
      name="simplify_maths_space">
      <typename
        name="maths_space"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint &lt; zmin THEN
            zmin := zint;
          END_IF;
          IF zint &gt; zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
      </algorithm>

    </function>

    <function
      name="simplify_maths_value">
      <typename
        name="maths_value"/>
      <parameter
        name="val">
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
      </algorithm>

    </function>

    <function
      name="singleton_member_of">
      <typename
        name="maths_value"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="space_dimension">
      <typename
        name="nonnegative_integer"/>
      <parameter
        name="tspace">
        <typename
          name="tuple_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
      </algorithm>

    </function>

    <function
      name="space_is_continuum">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="space">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="space_is_singleton">
      <builtintype
        type="BOOLEAN"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
      </algorithm>

    </function>

    <function
      name="stripped_typeof">
      <aggregate
        type="SET"/>
      <typename
        name="STRING"/>
      <parameter
        name="arg">
        <builtintype
          type="GENERIC"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
      </algorithm>

    </function>

    <function
      name="subspace_of">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="space1">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="space2">
        <typename
          name="maths_space"/>
      </parameter>
      <algorithm>
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min&gt;=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max &lt;= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 &lt; bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 &gt; bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 &lt; bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 &gt; bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max &gt; PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) &gt;= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n &lt; space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
      </algorithm>

    </function>

    <function
      name="subspace_of_es">
      <builtintype
        type="LOGICAL"/>
      <parameter
        name="spc">
        <typename
          name="maths_space"/>
      </parameter>
      <parameter
        name="es">
        <typename
          name="elementary_space_enumerators"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
      </algorithm>

    </function>

    <function
      name="substitute">
      <typename
        name="generic_expression"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <parameter
        name="vars">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="generic_variable"/>
      </parameter>
      <parameter
        name="vals">
        <aggregate
          type="LIST"
          lower="1"
          upper="?"/>
        <typename
          name="maths_value"/>
      </parameter>
      <algorithm>
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) &lt;&gt; SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
      </algorithm>

    </function>

    <function
      name="values_space_of">
      <typename
        name="maths_space"/>
      <parameter
        name="expr">
        <typename
          name="generic_expression"/>
      </parameter>
      <algorithm>
  LOCAL
    e_prefix : STRING := 'ISO13584_EXPRESSIONS_SCHEMA.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);  -- not recognized as a mathematical expression
      </algorithm>

    </function>

  </schema>

</express>
