<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-52">
   <application name="JSDAI" owner="LKSoft" source="mesh_topology_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="mesh_topology_schema">
      <interface kind="reference" schema="mathematical_description_of_distribution_schema">
         <interfaced.item name="property_distribution_description"/>
      </interface>
      <interface kind="reference" schema="mathematical_functions_schema">
         <interfaced.item name="maths_space"/>
      </interface>
      <interface kind="reference" schema="structural_response_representation_schema">
         <interfaced.item name="element_order"/>
         <interfaced.item name="element_representation"/>
         <interfaced.item name="fea_model"/>
      </interface>
      <interface kind="reference" schema="support_resource_schema">
         <interfaced.item name="identifier"/>
         <interfaced.item name="label"/>
         <interfaced.item name="text"/>
      </interface>
      <interface kind="reference" schema="topology_schema">
         <interfaced.item name="topological_representation_item"/>
         <interfaced.item name="vertex"/>
         <interfaced.item name="vertex_point"/>
      </interface>
      <type name="cell_shape">
         <select extensible="YES" selectitems="cell_shape_0D cell_shape_1D cell_shape_2D cell_shape_3D"/>
      </type>
      <type name="cell_shape_0D">
         <enumeration extensible="YES" items="single"/>
      </type>
      <type name="cell_shape_1D">
         <enumeration extensible="YES" items="line"/>
      </type>
      <type name="cell_shape_2D">
         <enumeration extensible="YES" items="quadrilateral triangle"/>
      </type>
      <type name="cell_shape_3D">
         <enumeration extensible="YES" items="hexahedron wedge tetrahedron pyramid"/>
      </type>
      <type name="indices_group">
         <select selectitems="indices_list indices_range"/>
      </type>
      <type name="mesh_location">
         <enumeration extensible="YES" items="unspecified application_defined vertices cell_centre face_centre iface_centre jface_centre kface_centre edge_centre"/>
      </type>
      <type name="mesh_maths_space_type">
         <enumeration extensible="YES" items="cells vertices"/>
      </type>
      <type name="structured_mesh_type">
         <enumeration extensible="YES" items="rectangular pentahedral pyramidal tetrahedral"/>
      </type>
      <entity name="array_based_unstructured_mesh" supertypes="unstructured_mesh">
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" upper="SELF\unstructured_mesh.cell_count"/>
            <typename name="vertex_defined_cell"/>
         </explicit>
         <where expression="SELF\mesh.index_count = 1" label="wr1"/>
      </entity>
      <entity name="array_based_unstructured_mesh_and_vertices" supertypes="array_based_unstructured_mesh">
         <explicit name="vertex_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" type="ARRAY" unique="YES" upper="vertex_count"/>
            <typename name="vertex"/>
         </explicit>
         <where expression="all_mesh_vertices(SELF)" label="wr1"/>
      </entity>
      <entity name="cell" super.expression="ONEOF (cell_of_structured_mesh, vertex_defined_cell)" supertypes="topological_representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="dimension">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="cell_of_structured_mesh" supertypes="cell">
         <explicit name="the_mesh">
            <typename name="structured_mesh"/>
         </explicit>
         <explicit name="cell_identifier">
            <aggregate lower="1" type="ARRAY" upper="index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="the_mesh\mesh.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity name="cell_with_explicit_boundary" supertypes="cell">
         <explicit name="boundary">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="topological_representation_item"/>
         </explicit>
      </entity>
      <entity name="explicit_unstructured_mesh" supertypes="unstructured_mesh">
         <explicit name="explicit_model">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" unique="YES" upper="cell_count"/>
            <typename name="element_representation"/>
         </explicit>
      </entity>
      <entity name="extraction_of_structured_submesh" supertypes="extraction_of_submesh">
         <explicit name="lower_vertex">
            <aggregate lower="1" type="ARRAY" upper="whole_indices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="used_indices">
            <aggregate lower="1" type="ARRAY" upper="part_indices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="used_senses">
            <aggregate lower="1" type="ARRAY" upper="part_indices"/>
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="whole\mesh.index_count" name="whole_indices">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="part\mesh.index_count" name="part_indices">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN  TYPEOF(&#10;             SELF\extraction_of_submesh.whole))" label="WR1"/>
         <where expression="('MESH_TOPOLOGY_SCHEMA.STRUCTURED_MESH' IN  TYPEOF(&#10;             SELF\extraction_of_submesh.part))" label="WR2"/>
      </entity>
      <entity name="extraction_of_submesh">
         <explicit name="whole">
            <typename name="mesh"/>
         </explicit>
         <explicit name="part">
            <typename name="submesh"/>
         </explicit>
      </entity>
      <entity name="extraction_of_submesh_by_cells" supertypes="extraction_of_submesh">
         <explicit name="cell_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" upper="cell_count"/>
            <typename name="cell"/>
         </explicit>
      </entity>
      <entity name="extraction_of_submesh_by_vertices" supertypes="extraction_of_submesh">
         <explicit name="vertex_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" type="ARRAY" upper="vertex_count"/>
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="indices_list">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="indices">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="indices_range">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="start">
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="finish">
            <aggregate lower="1" type="ARRAY" upper="nindices"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="mesh" super.expression="ONEOF (structured_mesh, unstructured_mesh) ANDOR submesh" supertypes="topological_representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="mesh_derived_maths_space" supertypes="maths_space">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="the_mesh">
            <typename name="mesh"/>
         </explicit>
         <explicit name="kind">
            <typename name="mesh_maths_space_type"/>
         </explicit>
      </entity>
      <entity name="product_of_mesh">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="mesh"/>
         </explicit>
         <explicit name="product">
            <typename name="mesh"/>
         </explicit>
         <where expression="(this_schema+'.STRUCTURED_MESH' IN TYPEOF(operands[1])) AND&#10;        (this_schema+'.STRUCTURED_MESH' IN TYPEOF(operands[2])) AND&#10;        (this_schema+'.STRUCTURED_MESH' IN TYPEOF(product))" label="wr1"/>
         <where expression="operands[1].index_count = 1" label="wr2"/>
         <where expression="operands[1].index_count + operands[2].index_count&#10;        = product.index_count" label="wr3"/>
      </entity>
      <entity name="rind">
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="planes">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="structured_mesh" supertypes="mesh">
         <explicit name="vertex_counts">
            <aggregate lower="1" type="ARRAY" upper="SELF\mesh.index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="cell_counts">
            <aggregate lower="1" type="ARRAY" upper="SELF\mesh.index_count"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="kind">
            <typename name="structured_mesh_type"/>
         </explicit>
      </entity>
      <entity name="structured_mesh_with_rind" supertypes="structured_mesh">
         <explicit name="rind_planes">
            <typename name="rind"/>
         </explicit>
      </entity>
      <entity name="submesh" supertypes="mesh"/>
      <entity abstract.supertype="YES" name="unstructured_mesh" super.expression="ONEOF (array_based_unstructured_mesh, explicit_unstructured_mesh)" supertypes="mesh">
         <explicit name="cell_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="vertex_defined_cell" supertypes="cell">
         <explicit name="shape">
            <typename name="cell_shape"/>
         </explicit>
         <explicit name="order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" optional="YES" type="ARRAY" upper="vn_count"/>
            <typename name="vertex"/>
         </explicit>
         <derived expression="cell_counts(SELF)[1]" name="bound_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[2]" name="edge_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[3]" name="opt_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="bound_count + edge_node_count" name="required_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="required_count + opt_node_count" name="vn_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="shorten_array(vertices, vn_count, required_count)" name="required_vertices">
            <aggregate lower="1" type="ARRAY" upper="required_count"/>
            <typename name="vertex"/>
         </derived>
      </entity>
      <function name="all_mesh_vertices">
         <parameter name="arg">
            <typename name="array_based_unstructured_mesh_and_vertices"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  vertex_set : SET OF vertex := [];
  cell : vertex_defined_cell;
END_LOCAL;
  REPEAT i := 1 TO arg.cell_count;
    cell := arg.cells[i];
    REPEAT j := 1 TO cell.vn_count;
      vertex_set := vertex_set + cell.vertices[j];
    END_REPEAT;
  END_REPEAT;
  IF (SIZEOF(vertex_set) &lt;&gt; arg.index_count) THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i := 1 TO arg.index_count;
    IF (NOT (arg.vertices[i] IN vertex_set) ) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);</algorithm>
      </function>
      <function name="cell_counts">
         <parameter name="arg">
            <typename name="vertex_defined_cell"/>
         </parameter>
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
  om1    : INTEGER := 0;      -- (order - 1)
  om1sq  : INTEGER := om1**2; -- (order - 1) squared
  vts    : INTEGER;           -- number of bounding vertices
  eds    : INTEGER;           -- number of edges
  qf     : INTEGER := 0;      -- number of quadrilateral faces
  tf     : INTEGER := 0;      -- number of triangular faces
  result : ARRAY [1:3] OF INTEGER := [0,0,0];
END_LOCAL;
  CASE arg.order OF
    linear_order    : om1 := 0;
    quadratic_order : om1 := 1;
    cubic_order     : om1 := 2;
    OTHERWISE : RETURN(result);
  END_CASE;
  om1sq := om1**2;
  CASE arg.shape OF
    cell_shape_0D.single : 
        BEGIN
          vts := 1; eds := 0; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 0, 0
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_1D.line :
        BEGIN
          vts := 2; eds := 1; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 1, 2
          result[3] := 0;                         -- 0, 0, 0
        END;
    cell_shape_2D.quadrilateral : 
        BEGIN
          vts := 4; eds := 4; qf := 1; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 4, 8
          result[3] := om1sq*qf;                  -- 0, 1, 4
        END;
    cell_shape_2D.triangle : 
        BEGIN
          vts := 3; eds := 3; qf := 0; tf := 1;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 3, 6
          result[3] := (om1-1)*tf;                --    0, 1
          CASE arg.order OF
            linear_order : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3D.hexahedron :
        BEGIN
          vts := 8; eds := 12; qf := 6; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 12, 24
          result[3] := om1sq*(qf+om1);            -- 0, 7, 32
        END;
    cell_shape_3D.wedge :
        BEGIN
          vts := 6; eds := 9; qf := 3; tf := 2;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 9,  18
          result[3] := om1sq*qf + om1*tf;         -- 0, 3, 16
        END;
    cell_shape_3D.tetrahedron : 
        BEGIN
          vts := 4; eds := 6; qf := 0; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 6, 12
          result[3] := (om1-1)*tf;                --    0, 4
          CASE arg.order OF
            linear_order : result[3] := 0;              -- 0
          END_CASE;
        END;
    cell_shape_3D.pyramid : 
        BEGIN
          vts := 5; eds := 8; qf := 1; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 8, 16
          result[3] := om1sq*qf + (om1-1)*tf;     --    1, 9
          CASE arg.order OF
            linear_order : result[3] := 0;              -- 0
          END_CASE;
        END;
  END_CASE;
RETURN(result);</algorithm>
      </function>
      <function name="shorten_array">
         <parameter name="longa">
            <aggregate lower="0" type="ARRAY"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="oldl">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="newl">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     shorta : ARRAY [1:newl] OF GENERIC : T;
   END_LOCAL;

   IF (newl &gt; oldl) THEN
     RETURN(?);
   ELSE
     REPEAT i := 1 TO newl;
       shorta[i] := longa[i];
     END_REPEAT;
     RETURN(shorta);
   END_IF;</algorithm>
      </function>
      <function name="this_schema">
         <builtintype type="STRING"/>
         <algorithm>RETURN('MESH_TOPOLOGY_SCHEMA');</algorithm>
      </function>
   </schema>
</express>
