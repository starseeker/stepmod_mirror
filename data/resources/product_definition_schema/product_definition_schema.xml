<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="ISO 10303-41">
   <application name="JSDAI" owner="LKSoft" source="product_definition_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="product_definition_schema">
      <interface kind="reference" schema="application_context_schema">
         <interfaced.item name="product_context"/>
         <interfaced.item name="product_definition_context"/>
      </interface>
      <interface kind="reference" schema="basic_attribute_schema">
         <interfaced.item name="get_id_value"/>
         <interfaced.item name="get_name_value"/>
         <interfaced.item name="name_attribute"/>
      </interface>
      <interface kind="reference" schema="product_property_definition_schema">
         <interfaced.item name="characterized_object"/>
      </interface>
      <interface kind="reference" schema="document_schema">
         <interfaced.item name="document"/>
      </interface>
      <interface kind="reference" schema="effectivity_schema">
         <interfaced.item name="effectivity"/>
      </interface>
      <interface kind="reference" schema="support_resource_schema">
         <interfaced.item name="bag_to_set"/>
         <interfaced.item name="identifier"/>
         <interfaced.item name="label"/>
         <interfaced.item name="text"/>
      </interface>
      <type name="source">
         <enumeration extensible="NO" items="made bought not_known"/>
      </type>
      <entity abstract.entity="NO" abstract.supertype="NO" name="characterized_product" supertypes="characterized_object product"/>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product_context"/>
         </explicit>
      <where label="IP1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_category">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      <where label="IP1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_category_relationship">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="category" optional="NO">
            <typename name="product_category"/>
         </explicit>
         <explicit name="sub_category" optional="NO">
            <typename name="product_category"/>
         </explicit>
         <where expression="acyclic_product_category_relationship(SELF, [SELF.sub_category])" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation" optional="NO">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference" optional="NO">
            <typename name="product_definition_context"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_context_association">
         <explicit name="definition" optional="NO">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="frame_of_reference" optional="NO">
            <typename name="product_definition_context"/>
         </explicit>
         <explicit name="role" optional="NO">
            <typename name="product_definition_context_role"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_context_role">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage" optional="NO">
            <typename name="product_definition_relationship"/>
         </explicit>
         <where expression="SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_formation">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product" optional="NO">
            <typename name="product"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
            <unique.attribute attribute="of_product"/>
         </unique>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_formation_relationship">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition_formation" optional="NO">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="related_product_definition_formation" optional="NO">
            <typename name="product_definition_formation"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy" optional="NO">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_relationship">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition" optional="NO">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition" optional="NO">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_substitute">
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="context_relationship" optional="NO">
            <typename name="product_definition_relationship"/>
         </explicit>
         <explicit name="substitute_definition" optional="NO">
            <typename name="product_definition"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="context_relationship.related_product_definition :&lt;&gt;: substitute_definition" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_related_product_category" supertypes="product_category">
         <explicit name="products" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="product_relationship">
         <explicit name="id" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product" optional="NO">
            <typename name="product"/>
         </explicit>
         <explicit name="related_product" optional="NO">
            <typename name="product"/>
         </explicit>
      </entity>
      <function name="acyclic_product_category_relationship">
         <parameter name="relation">
            <typename name="product_category_relationship"/>
         </parameter>
         <parameter name="children">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product_category"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_formation_relationship">
         <parameter name="relation">
            <typename name="product_definition_formation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product_definition_formation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype fixed="NO" type="STRING"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf &lt;* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype fixed="NO" type="STRING"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_product_relationship">
         <parameter name="relation">
            <typename name="product_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="product"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype fixed="NO" type="STRING"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod &lt;* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="categories_of_product">
         <parameter name="obj">
            <typename name="product"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <builtintype fixed="NO" type="STRING"/>
         <algorithm>LOCAL
    category_assignments: BAG OF product_category;
    categories: SET OF STRING:=[];
  END_LOCAL;
    category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);</algorithm>
      </function>
      <function name="get_product_definitions">
         <parameter name="c_def_instance">
            <typename name="product"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) &lt; 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);</algorithm>
      </function>
   </schema>
</express>
