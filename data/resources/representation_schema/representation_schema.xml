<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date: 2017/06/17 15:09:06 $" rcs.revision="$Revision: 1.25 $" reference="ISO 10303-43">
   <application name="JSDAI" owner="LKSoft" source="representation_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="representation_schema">
      <interface kind="reference" schema="basic_attribute_schema">
         <interfaced.item name="description_attribute"/>
         <interfaced.item name="description_attribute_select"/>
         <interfaced.item name="get_description_value"/>
         <interfaced.item name="get_id_value"/>
         <interfaced.item name="id_attribute"/>
         <interfaced.item name="id_attribute_select"/>
      </interface>
      <interface kind="reference" schema="measure_schema">
         <interfaced.item name="measure_value"/>
         <interfaced.item name="measure_with_unit"/>
      </interface>
      <interface kind="reference" schema="support_resource_schema">
         <interfaced.item name="bag_to_set"/>
         <interfaced.item name="identifier"/>
         <interfaced.item name="label"/>
         <interfaced.item name="text"/>
      </interface>
      <type name="compound_item_definition">
         <select extensible="NO" genericentity="NO" selectitems="list_representation_item set_representation_item"/>
      </type>
      <type name="founded_item_select">
         <select extensible="NO" genericentity="NO" selectitems="founded_item representation_item"/>
      </type>
      <type name="list_item_defined_transformation">
         <aggregate lower="2" optional="NO" type="LIST" unique="NO" upper="?"/>
         <typename name="item_defined_transformation"/>
      </type>
      <type name="list_representation_item">
         <aggregate lower="1" optional="NO" type="LIST" unique="NO" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="representation_or_representation_reference">
         <select extensible="NO" genericentity="NO" selectitems="representation representation_reference"/>
	  </type>
      <type name="rs_description_attribute_select">
         <select basedon="description_attribute_select" extensible="NO" genericentity="NO" selectitems="representation"/>
      </type>
      <type name="rs_id_attribute_select">
         <select basedon="id_attribute_select" extensible="NO" genericentity="NO" selectitems="representation"/>
      </type>
      <type name="set_item_defined_transformation">
         <aggregate lower="2" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="item_defined_transformation"/>
      </type>
      <type name="set_representation_item">
         <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="transformation">
         <select extensible="NO" genericentity="NO" selectitems="item_defined_transformation functionally_defined_transformation list_item_defined_transformation set_item_defined_transformation"/>
      </type>
      <entity abstract.entity="NO" abstract.supertype="NO" name="binary_representation_item" supertypes="representation_item">
         <explicit name="binary_value" optional="NO">
            <builtintype fixed="NO" type="BINARY"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="bytes_representation_item" supertypes="binary_representation_item">
         <derived expression="BLENGTH(SELF\binary_representation_item.binary_value) DIV 8" name="no_of_bytes">
            <builtintype fixed="NO" type="INTEGER"/>
         </derived>
         <where expression="BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="compound_representation_item" supertypes="representation_item">
         <explicit name="item_element" optional="NO">
            <typename name="compound_item_definition"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation" supertypes="representation">
         <where expression="'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;          TYPEOF (SELF\representation.context_of_items )" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation_relationship" supertypes="representation_relationship">
         <where expression="acyclic_representation_relationship(SELF,&#10;         [SELF\representation_relationship.rep_2],&#10;         'REPRESENTATION_SCHEMA.'+'REPRESENTATION')" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation_relationship_with_same_context" supertypes="definitional_representation_relationship">
         <where expression="SELF\representation_relationship.rep_1.context_of_items :=: &#10;            SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="founded_item">
         <derived expression="using_items(SELF,[])" name="users">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="founded_item_select"/>
         </derived>
         <where expression="SIZEOF(users) &gt; 0" label="WR1"/>
         <where expression="NOT(SELF IN users)" label="WR2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="functionally_defined_transformation">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="item_defined_transformation">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1" optional="NO">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2" optional="NO">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source" optional="NO">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target" optional="NO">
            <typename name="representation_item"/>
         </explicit>
         <where expression="acyclic_mapped_representation(SELF)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="parametric_representation_context" supertypes="representation_context">
         <where label="IP1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="items" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items" optional="NO">
            <typename name="representation_context"/>
         </explicit>
         <derived expression="get_id_value (SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&#10;         &lt;= 1" label="WR1"/>
         <where expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&#10;         &lt;= 1" label="WR2"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_context">
         <explicit name="context_identifier" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type" optional="NO">
            <typename name="text"/>
         </explicit>
         <inverse attribute="context_of_items" entity="representation" name="representations_in_context">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_context_reference">
         <explicit name="context_identifier" optional="NO">
            <typename name="identifier"/>
         </explicit>
         <inverse attribute="context_of_items" entity="representation_reference" name="representations_in_context">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_item" super.expression="ONEOF (binary_representation_item, compound_representation_item, mapped_item, value_representation_item)">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <where expression="SIZEOF(using_representations(SELF)) &gt; 0" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_item_relationship">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_representation_item" optional="NO">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="related_representation_item" optional="NO">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_map">
         <explicit name="mapping_origin" optional="NO">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation" optional="NO">
            <typename name="representation"/>
         </explicit>
         <inverse attribute="mapping_source" entity="mapped_item" name="map_usage">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="item_in_context(mapping_origin, mapped_representation\representation.context_of_items)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_reference">
		  <explicit name="id" optional="NO">
				<typename name="identifier"/>
		  </explicit>
		  <explicit name="context_of_items" optional="NO">
				<typename name="representation_context_reference"/>
		  </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_relationship">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1" optional="NO">
            <typename name="representation_or_representation_reference"/>
         </explicit>
         <explicit name="rep_2" optional="NO">
            <typename name="representation_or_representation_reference"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator" optional="NO">
            <typename name="transformation"/>
         </explicit>
         <where expression="SELF\representation_relationship.rep_1.context_of_items&#10;           :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      <where label="IP1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="uncertainty_assigned_representation" supertypes="representation">
         <explicit name="uncertainty" optional="NO">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name" optional="NO">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <where expression="valid_measure_value (SELF\measure_with_unit.value_component)" label="WR1"/>
      </entity>
      <entity abstract.entity="NO" abstract.supertype="NO" name="value_representation_item" supertypes="representation_item">
         <explicit name="value_component" optional="NO">
            <typename name="measure_value"/>
         </explicit>
         <where expression="SIZEOF (QUERY (rep &lt;* using_representations (SELF) |&#10;        NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'&#10;        IN TYPEOF (rep.context_of_items)&#10;        ))) = 0" label="WR1"/>
      <where label="IP1"/>
      </entity>
      <function name="acyclic_mapped_representation">
         <parameter name="mi">
            <typename name="mapped_item"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) &gt; 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) &gt; 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_representation_relationship">
         <parameter name="relation">
            <typename name="representation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype fixed="NO" type="STRING"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r &lt;* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="get_representations_for_items">
         <parameter name="input">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="representation"/>
         <algorithm> LOCAL
            r_set : SET OF representation := [];
            END_LOCAL;
            REPEAT i := LOINDEX(input) TO HIINDEX(input);
            r_set := r_set + using_representations(input[i]);
            END_REPEAT;
            RETURN (r_set);
         </algorithm>
      </function>                
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) &gt; 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z &lt;* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) &gt; 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);</algorithm>
      </function>
      <function name="using_items">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <parameter name="checked_items">
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="founded_item_select"/>
         <algorithm>LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z &lt;* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) &gt; 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);</algorithm>
      </function>
      <function name="valid_measure_value">
         <parameter name="m">
            <typename name="measure_value"/>
         </parameter>
         <builtintype fixed="NO" type="BOOLEAN"/>
         <algorithm>IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m &gt; 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m &gt; 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;</algorithm>
      </function>
   </schema>
</express>
