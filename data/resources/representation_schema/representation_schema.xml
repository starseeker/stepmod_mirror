<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express
  SYSTEM "../../../dtd/express.dtd">
<express description.file="descriptions.xml" language_version="2" rcs.date="$Date: 2009/08/22 16:38:12 $" rcs.revision="$Revision: 1.14 $" reference="ISO 10303-43">
   
   <application name="JSDAI" owner="LKSoft" source="representation_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   
   <schema name="representation_schema">
      
      <interface kind="reference" schema="basic_attribute_schema">
         
         <interfaced.item name="get_description_value"/>
         
         <interfaced.item name="get_id_value"/>
      
      </interface>
      
      <interface kind="reference" schema="measure_schema">
         
         <interfaced.item name="measure_value"/>
         
         <interfaced.item name="measure_with_unit"/>
      
      </interface>
      
      <interface kind="reference" schema="support_resource_schema">
         
         <interfaced.item name="bag_to_set"/>
         
         <interfaced.item name="identifier"/>
         
         <interfaced.item name="label"/>
         
         <interfaced.item name="text"/>
      
      </interface>
      
      <type name="compound_item_definition">
         
         <select extensible="NO" genericentity="NO" selectitems="list_representation_item set_representation_item"/>
      
      </type>
      
      <type name="founded_item_select">
         
         <select extensible="NO" genericentity="NO" selectitems="founded_item representation_item"/>
      
      </type>
      
      <type name="list_representation_item">
         
         <aggregate lower="1" optional="NO" type="LIST" unique="NO" upper="?"/>
         
         <typename name="representation_item"/>
      
      </type>
      
      <type name="set_representation_item">
         
         <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
         
         <typename name="representation_item"/>
      
      </type>
      
      <type name="transformation">
         
         <select extensible="NO" genericentity="NO" selectitems="item_defined_transformation functionally_defined_transformation"/>
      
      </type>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="binary_representation_item" supertypes="representation_item">
         
         <explicit name="binary_value" optional="NO">
            
            <builtintype fixed="NO" type="BINARY"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="bytes_representation_item" supertypes="binary_representation_item">
         
         <derived expression="BLENGTH(SELF\binary_representation_item.binary_value) DIV 8" name="no_of_bytes">
            
            <builtintype fixed="NO" type="INTEGER"/>
         
         </derived>
         
         <where expression="BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="compound_representation_item" supertypes="representation_item">
         
         <explicit name="item_element" optional="NO">
            
            <typename name="compound_item_definition"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation" supertypes="representation">
         
         <where expression="'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#xA;          TYPEOF (SELF\representation.context_of_items )" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation_relationship" supertypes="representation_relationship">
         
         <where expression="acyclic_representation_relationship(SELF,&#xA;         [SELF\representation_relationship.rep_2],&#xA;         'REPRESENTATION_SCHEMA.'+'REPRESENTATION')" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="definitional_representation_relationship_with_same_context" supertypes="definitional_representation_relationship">
         
         <where expression="SELF\representation_relationship.rep_1.context_of_items :=: &#xA;            SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="founded_item">
         
         <derived expression="using_items(SELF,[])" name="users">
            
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="founded_item_select"/>
         
         </derived>
         
         <where expression="SIZEOF(users) &gt; 0" label="WR1"/>
         
         <where expression="NOT(SELF IN users)" label="WR2"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="functionally_defined_transformation">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="description" optional="YES">
            
            <typename name="text"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="global_uncertainty_assigned_context" supertypes="representation_context">
         
         <explicit name="uncertainty" optional="NO">
            
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="uncertainty_measure_with_unit"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="item_defined_transformation">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="description" optional="YES">
            
            <typename name="text"/>
         
         </explicit>
         
         <explicit name="transform_item_1" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
         
         <explicit name="transform_item_2" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="mapped_item" supertypes="representation_item">
         
         <explicit name="mapping_source" optional="NO">
            
            <typename name="representation_map"/>
         
         </explicit>
         
         <explicit name="mapping_target" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
         
         <where expression="acyclic_mapped_representation(SELF)" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="parametric_representation_context" supertypes="representation_context">
         <where label="IP1"/>
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="items" optional="NO">
            
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="representation_item"/>
         
         </explicit>
         
         <explicit name="context_of_items" optional="NO">
            
            <typename name="representation_context"/>
         
         </explicit>
         
         <derived expression="get_id_value (SELF)" name="id">
            
            <typename name="identifier"/>
         
         </derived>
         
         <derived expression="get_description_value (SELF)" name="description">
            
            <typename name="text"/>
         
         </derived>
         
         <where expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#xA;                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&#xA;         &lt;= 1" label="WR1"/>
         
         <where expression="SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#xA;                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&#xA;         &lt;= 1" label="WR2"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_context">
         
         <explicit name="context_identifier" optional="NO">
            
            <typename name="identifier"/>
         
         </explicit>
         
         <explicit name="context_type" optional="NO">
            
            <typename name="text"/>
         
         </explicit>
         
         <inverse attribute="context_of_items" entity="representation" name="representations_in_context">
            
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         
         </inverse>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_item" super.expression="ONEOF (binary_representation_item, compound_representation_item, mapped_item, value_representation_item)">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <where expression="SIZEOF(using_representations(SELF)) &gt; 0" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_item_relationship">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="description" optional="YES">
            
            <typename name="text"/>
         
         </explicit>
         
         <explicit name="relating_representation_item" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
         
         <explicit name="related_representation_item" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_map">
         
         <explicit name="mapping_origin" optional="NO">
            
            <typename name="representation_item"/>
         
         </explicit>
         
         <explicit name="mapped_representation" optional="NO">
            
            <typename name="representation"/>
         
         </explicit>
         
         <inverse attribute="mapping_source" entity="mapped_item" name="map_usage">
            
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         
         </inverse>
         
         <where expression="item_in_context(SELF.mapping_origin,&#xA;        SELF.mapped_representation.context_of_items)" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_relationship">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="description" optional="YES">
            
            <typename name="text"/>
         
         </explicit>
         
         <explicit name="rep_1" optional="NO">
            
            <typename name="representation"/>
         
         </explicit>
         
         <explicit name="rep_2" optional="NO">
            
            <typename name="representation"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="representation_relationship_with_transformation" supertypes="representation_relationship">
         
         <explicit name="transformation_operator" optional="NO">
            
            <typename name="transformation"/>
         
         </explicit>
         
         <where expression="SELF\representation_relationship.rep_1.context_of_items&#xA;           :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      
         <where label="IP1"/>
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="uncertainty_assigned_representation" supertypes="representation">
         
         <explicit name="uncertainty" optional="NO">
            
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="uncertainty_measure_with_unit"/>
         
         </explicit>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         
         <explicit name="name" optional="NO">
            
            <typename name="label"/>
         
         </explicit>
         
         <explicit name="description" optional="YES">
            
            <typename name="text"/>
         
         </explicit>
         
         <where expression="valid_measure_value (SELF\measure_with_unit.value_component)" label="WR1"/>
      
      </entity>
      
      <entity abstract.entity="NO" abstract.supertype="NO" name="value_representation_item" supertypes="representation_item">
         
         <explicit name="value_component" optional="NO">
            
            <typename name="measure_value"/>
         
         </explicit>
         
         <where expression="SIZEOF (QUERY (rep &lt;* using_representations (SELF) |&#xA;        NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'&#xA;        IN TYPEOF (rep.context_of_items)&#xA;        ))) = 0" label="WR1"/>
      
         <where label="IP1"/>
      </entity>
      
      <function name="acyclic_mapped_representation">
         
         <parameter name="mi">
            
            <typename name="mapped_item"/>
         
         </parameter>
         
         <builtintype fixed="NO" type="BOOLEAN"/>
         
         <algorithm>LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) &gt; 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) &gt; 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      
      </function>
      
      <function name="acyclic_representation_relationship">
         
         <parameter name="relation">
            
            <typename name="representation_relationship"/>
         
         </parameter>
         
         <parameter name="relatives">
            
            <aggregate lower="1" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="representation"/>
         
         </parameter>
         
         <parameter name="specific_relation">
            
            <builtintype fixed="NO" type="STRING"/>
         
         </parameter>
         
         <builtintype fixed="NO" type="BOOLEAN"/>
         
         <algorithm>LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r &lt;* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      
      </function>
      
      <function name="item_in_context">
         
         <parameter name="item">
            
            <typename name="representation_item"/>
         
         </parameter>
         
         <parameter name="cntxt">
            
            <typename name="representation_context"/>
         
         </parameter>
         
         <builtintype fixed="NO" type="BOOLEAN"/>
         
         <algorithm>LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) &gt; 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z &lt;* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) &gt; 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);</algorithm>
      
      </function>
      
      <function name="using_items">
         
         <parameter name="item">
            
            <typename name="founded_item_select"/>
         
         </parameter>
         
         <parameter name="checked_items">
            
            <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
            
            <typename name="founded_item_select"/>
         
         </parameter>
         
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         
         <typename name="founded_item_select"/>
         
         <algorithm>LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z &lt;* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) &gt; 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);</algorithm>
      
      </function>
      
      <function name="using_representations">
         
         <parameter name="item">
            
            <typename name="founded_item_select"/>
         
         </parameter>
         
         <aggregate lower="0" optional="NO" type="SET" unique="NO" upper="?"/>
         
         <typename name="representation"/>
         
         <algorithm>LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);</algorithm>
      
      </function>
      
      <function name="valid_measure_value">
         
         <parameter name="m">
            
            <typename name="measure_value"/>
         
         </parameter>
         
         <builtintype fixed="NO" type="BOOLEAN"/>
         
         <algorithm>IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m &gt; 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m &gt; 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;</algorithm>
      
      </function>
   
   </schema>

</express>