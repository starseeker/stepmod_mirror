<?xml version="1.0"?>
<!-- $Id: set_theory_schema.xml,v 1.6 2002/07/16 14:01:18 goset1 Exp $ -->
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express
  language_version="2"
  reference="ISO/DIS 10303-54"
  rcs.date="$Date: 2002/07/16 14:01:18 $"
  rcs.revision="$Revision: 1.6 $">

  <application
    name=" Eurostep EXPRESS Parser (Eep!)"
    owner="Eurostep Limited"
    url="www.eurostep.com"
    version="1, 2, 1041, 2056"
    source="express/foo1.exp"/>

  <schema name="set_theory_schema">
    <interface
      kind="reference"
      schema="support_resource_schema">
      <interfaced.item
        name="identifier"/>
      <interfaced.item
        name="label"/>
      <interfaced.item
        name="text"/>
    </interface>
    <interface
      kind="reference"
      schema="classification_schema">
      <interfaced.item
        name="class"/>
    </interface>
    <entity name="complement"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="set_1">
        <typename name="class"/>
      </explicit>
      <explicit
        name="set_2">
        <typename name="class"/>
      </explicit>
      <explicit
        name="universe">
        <typename name="class"/>
      </explicit>
      <where
        label="complement_different"
        expression="NOT identical_sets(set_1, set_2)">
      </where>
    </entity>

    <entity name="intersection"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="operand">
        <aggregate type="SET"
          lower="2"
          upper="?"
        />
        <typename name="class"/>
      </explicit>
      <explicit
        name="resultant">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="power_set"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="base">
        <typename name="class"/>
      </explicit>
      <explicit
        name="derived">
        <typename name="class"/>
      </explicit>
      <where
        label="derived_different"
        expression="NOT identical_sets(base, derived)">
      </where>
    </entity>

    <entity name="proper_subset"
      supertypes="subset"
    >
      <where
        label="subset_different"
        expression="NOT identical_sets(superset, subset)">
      </where>
    </entity>

    <entity name="same_membership"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="set_1">
        <typename name="class"/>
      </explicit>
      <explicit
        name="set_2">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="subset"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="subset">
        <typename name="class"/>
      </explicit>
      <explicit
        name="superset">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="union"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="operand">
        <aggregate type="SET"
          lower="2"
          upper="?"
        />
        <typename name="class"/>
      </explicit>
      <explicit
        name="resultant">
        <typename name="class"/>
      </explicit>
    </entity>

    <entity name="union_of_all_members"
    >
      <explicit
        name="id">
        <typename name="identifier"/>
      </explicit>
      <explicit
        name="name">
        <typename name="label"/>
      </explicit>
      <explicit
        name="description"
        optional="YES">
        <typename name="text"/>
      </explicit>
      <explicit
        name="operand">
        <typename name="class"/>
      </explicit>
      <explicit
        name="resultant">
        <typename name="class"/>
      </explicit>
      <where
        label="resultant_different"
        expression="NOT identical_sets(operand, resultant)">
      </where>
    </entity>

    <function name="identical_sets">
      <parameter name="set_a">
        <typename name="class"/>
      </parameter>
      <parameter name="set_b">
        <typename name="class"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;

  IF (set_a = set_b) THEN
    RETURN (TRUE);
  END_IF;
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));
      </algorithm>
    </function>

    <function name="identical_to_one_of_set_of_sets">
      <parameter name="set_a">
        <typename name="class"/>
      </parameter>
      <parameter name="set_of_sets">
        <aggregate type="SET"
        />
        <typename name="class"/>
      </parameter>
      <builtintype type="BOOLEAN"
      />
      <algorithm>
  LOCAL
    i : INTEGER;
    initial_size : INTEGER;
    augmented_size : INTEGER;
    set_of_forward_equivalences : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets : SET OF class := [];
  END_LOCAL;

  IF (set_a IN set_of_sets) THEN
    RETURN (TRUE);
  END_IF;
  initial_size := SIZEOF(set_of_sets);
  IF (initial_size = 0) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences + USEDIN(set_of_sets[i], &apos;SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_1&apos;);
    set_of_backward_equivalences := set_of_forward_equivalences + USEDIN(set_of_sets[i], &apos;SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_2&apos;);
  END_REPEAT;
  augmented_set_of_sets := set_of_sets;
  IF (SIZEOF(set_of_forward_equivalences) &gt; 0) THEN
    REPEAT i := 1 TO HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets + set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(set_of_backward_equivalences) &gt; 0) THEN
    REPEAT i := 1 TO HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets + set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));
      </algorithm>
    </function>

  </schema>

</express>
