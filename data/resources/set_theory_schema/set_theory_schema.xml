<?xml version="1.0"?>
<?xml-stylesheet 
  type="text/xsl" 
  href="../../../xsl/express.xsl"
?> <!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<express language_version="2" rcs.date="$Date: $" rcs.revision="$Revision: $"
reference="ISO 10303-54"  description.file="descriptions.xml"
>
<application name="GraphicalEXPRESS" owner="Eurostep" url="www.eurostep.com" version="1.3.14" source="part_54_v014.vsd" />
<schema name="set_theory_schema">
<interface kind="reference" schema="classification_schema">
<interfaced.item name="class" />
</interface>
<interface kind="reference" schema="support_resource_schema">
<interfaced.item name="identifier" />
<interfaced.item name="label" />
<interfaced.item name="text" />
</interface>
<entity name="complement">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="set_1">
<typename name="class" />
</explicit>
<explicit name="set_2">
<typename name="class" />
</explicit>
<explicit name="universe">
<typename name="class" />
</explicit>
<where label="complement_different" expression="NOT identical_sets(set_1, set_2)">
</where>
<graphic.element page="3" xcoord="99" ycoord="495" />
</entity>
<entity name="intersection">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="operand">
<aggregate type="SET" lower="0" upper="?" />
<typename name="class" />
</explicit>
<explicit name="resultant">
<typename name="class" />
</explicit>
<graphic.element page="3" xcoord="85" ycoord="318" />
</entity>
<entity name="power_set">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="base">
<typename name="class" />
</explicit>
<explicit name="derived">
<typename name="class" />
</explicit>
<where label="derived_different" expression="NOT identical_sets(base, derived)">
</where>
<graphic.element page="3" xcoord="321" ycoord="317" />
</entity>
<entity name="proper_subset" supertypes="subset">
<where label="subset_different" expression="NOT identical_sets(superset, subset)">
</where>
<graphic.element page="3" xcoord="41" ycoord="41" />
</entity>
<entity name="same_membership">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="set_1">
<typename name="class" />
</explicit>
<explicit name="set_2">
<typename name="class" />
</explicit>
<graphic.element page="3" xcoord="325" ycoord="498" />
</entity>
<entity name="subset">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="subset">
<typename name="class" />
</explicit>
<explicit name="superset">
<typename name="class" />
</explicit>
<graphic.element page="3" xcoord="94" ycoord="73" />
</entity>
<entity name="union">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="operand">
<aggregate type="SET" lower="2" upper="?" />
<typename name="class" />
</explicit>
<explicit name="resultant">
<typename name="class" />
</explicit>
<graphic.element page="3" xcoord="336" ycoord="89" />
</entity>
<entity name="union_of_all_members">
<explicit name="id">
<typename name="identifier" />
</explicit>
<explicit name="name">
<typename name="label" />
</explicit>
<explicit name="description" optional="YES">
<typename name="text" />
</explicit>
<explicit name="operand">
<typename name="class" />
</explicit>
<explicit name="resultant">
<typename name="class" />
</explicit>
<where label="resultant_different" expression="NOT identical_sets(operand, resultant)">
</where>
<graphic.element page="3" xcoord="65" ycoord="678" />
</entity>
<function
      name="identical_sets">
      <parameter
        name="set_a">
        <typename
          name="class"/>
      </parameter>
      <parameter
        name="set_b">
        <typename
          name="class"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;
  
  IF (set_a = set_b) THEN
    RETURN (TRUE);
  END_IF;
  
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));
      </algorithm>
    </function>

    <function
      name="identical_to_one_of_set_of_sets">
      <parameter
        name="set_a">
        <typename
          name="class"/>
      </parameter>
      <parameter
        name="set_of_sets">
        <aggregate
          type="SET"/>
        <typename
          name="class"/>
      </parameter>
      <builtintype
        type="BOOLEAN"/>
      <algorithm>
  LOCAL
    i                            : INTEGER;
    initial_size                 : INTEGER;
    augmented_size               : INTEGER;
    set_of_forward_equivalences  : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets        : SET OF class := [];
  END_LOCAL;
  
  --  test membership of the specified set of sets
  
  IF (set_a IN set_of_sets) THEN
    RETURN (TRUE);
  END_IF;
  
  --  extend the specified set to include all sets that have the same membership
  --  as an existing member
  
  initial_size := SIZEOF(set_of_sets);
  IF (initial_size = 0) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_1');
    set_of_backward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_2');
  END_REPEAT;
  
  augmented_set_of_sets := set_of_sets;
  IF (SIZEOF(set_of_forward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(set_of_backward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  
  -- if the specified set of sets has been augmented, then test membership
  
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));
      </algorithm>
    </function>
<graphic.element page="1" xcoord="60" ycoord="39" />
</schema>
</express>
