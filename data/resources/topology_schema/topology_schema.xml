<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">
<!-- re-ordered entities logically + added IPS February 2012 RJG  -->
<express description.file="descriptions.xml" language_version="2" rcs.date="$Date: 2012/03/14 11:32:45 $" rcs.revision="$Revision: 1.10 $" reference="ISO 10303-42">
   <application name="JSDAI" owner="LKSoft" source="topology_schema schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="topology_schema">
      <interface kind="reference" schema="geometry_schema"/>
      <interface kind="reference" schema="representation_schema">
         <interfaced.item name="representation_item"/>
      </interface>
      <constant expression="representation_item('')||&#10;                   topological_representation_item()" name="dummy_tri">
         <typename name="topological_representation_item"/>
      </constant>
      <type name="list_of_reversible_topology_item">
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="reversible_topology">
         <select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item"/>
      </type>
      <type name="reversible_topology_item">
         <select selectitems="edge path face face_bound closed_shell open_shell"/>
      </type>
      <type name="set_of_reversible_topology_item">
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="shell">
         <select selectitems="vertex_shell wire_shell open_shell closed_shell"/>
      </type>
      <entity
            name="topological_representation_item"
            super.expression="ONEOF(vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set,
            
                   connected_volume_set, volume_with_faces, (loop ANDOR path))"
            supertypes="representation_item">
          <where  label="IP1"/>
          </entity>
        
        <entity
            name="vertex"
            supertypes="topological_representation_item">
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
          
        <entity
            name="vertex_point"
            supertypes="vertex geometric_representation_item">
            <explicit
              name="vertex_geometry">
              <typename
                name="point"/>
            </explicit>
            <where  label="IP1"/>
          </entity>
      
       <entity
            name="edge"
            super.expression="ONEOF(edge_curve, oriented_edge, subedge)"
            supertypes="topological_representation_item">
            <explicit
              name="edge_start">
              <typename
                name="vertex"/>
            </explicit>
            <explicit
              name="edge_end">
              <typename
                name="vertex"/>
            </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>   
          
       <entity
             name="edge_curve"
             supertypes="edge geometric_representation_item">
             <explicit
               name="edge_geometry">
               <typename
                 name="curve"/>
             </explicit>
             <explicit
               name="same_sense">
               <builtintype
                 type="BOOLEAN"/>
             </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
            <where  label="IP6"/>
            <where  label="IP7"/>
          </entity>
          
       <entity
            name="oriented_edge"
            supertypes="edge">
            <explicit
              name="edge_element">
              <typename
                name="edge"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <derived
              name="edge.edge_start"
              expression="boolean_choose (SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end)">
              <typename
                name="vertex"/>
            </derived>
            <derived
              name="edge.edge_end"
              expression="boolean_choose (SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start)">
              <typename
                name="vertex"/>
            </derived>
            <where
              label="WR1"
              expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element))">
            </where>
          </entity>
          
      <entity
            name="seam_edge"
            supertypes="oriented_edge">
            <explicit
              name="pcurve_reference">
              <typename
                name="pcurve"/>
            </explicit>
            <where
              label="WR1"
              expression="('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element)) AND ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF (edge_element\edge_curve.edge_geometry))">
            </where>
            <where
              label="WR2"
              expression="pcurve_reference IN edge_element\edge_curve.edge_geometry\ surface_curve.associated_geometry">
            </where>
          </entity>
       
       <entity
             name="subedge"
             supertypes="edge">
             <explicit
               name="parent_edge">
               <typename
                 name="edge"/>
             </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
           </entity>
      
      <entity
            name="path"
            super.expression="ONEOF(open_path, edge_loop, oriented_path)"
            supertypes="topological_representation_item">
            <explicit
              name="edge_list">
              <aggregate
                type="LIST"
                lower="1"
                upper="?"
                unique="YES"/>
              <typename
                name="oriented_edge"/>
            </explicit>
            <where
              label="WR1"
              expression="path_head_to_tail(SELF)">
            </where>
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
          </entity>
      
      <entity
            name="oriented_path"
            supertypes="path">
            <explicit
              name="path_element">
              <typename
                name="path"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <derived
              name="path.edge_list"
              expression="conditional_reverse(SELF.orientation, SELF.path_element.edge_list)">
              <aggregate
                type="LIST"
                lower="1"
                upper="?"
                unique="YES"/>
              <typename
                name="oriented_edge"/>
            </derived>
            <where
              label="WR1"
              expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element))">
            </where>
          </entity>
          
      <entity
            name="open_path"
            supertypes="path">
            <derived
              name="ne"
              expression="SIZEOF(path.edge_list)">
              <builtintype
                type="INTEGER"/>
            </derived>
            <where
              label="WR1"
              expression="(path.edge_list[1].edge_element.edge_start) :&lt;&gt;: (SELF\path.edge_list[ne].edge_element.edge_end)">
            </where>
            <where  label="IP1"/>
         </entity>
      
      <entity
            name="loop"
            super.expression="ONEOF(vertex_loop, edge_loop, poly_loop)"
            supertypes="topological_representation_item">
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
          
      <entity
            name="vertex_loop"
            supertypes="loop">
            <explicit
              name="loop_vertex">
              <typename
                name="vertex"/>
            </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
         </entity>
          
      <entity
            name="edge_loop"
            supertypes="loop path">
            <derived
              name="ne"
              expression="SIZEOF(path.edge_list)">
              <builtintype
                type="INTEGER"/>
            </derived>
            <where
              label="WR1"
              expression="(path.edge_list[1].edge_start) :=: (SELF\path.edge_list[ne].edge_end)">
            </where>
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
          
       <entity
            name="poly_loop"
            supertypes="loop geometric_representation_item">
            <explicit
              name="polygon">
              <aggregate
                type="LIST"
                lower="3"
                upper="?"
                unique="YES"/>
              <typename
                name="cartesian_point"/>
            </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
      
      <entity
            name="face_bound"
            supertypes="topological_representation_item">
            <explicit
              name="bound">
              <typename
                name="loop"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
          </entity>
      
       <entity
            name="face_outer_bound"
            supertypes="face_bound">
          </entity>
          
       <entity
            name="face"
            super.expression="ONEOF(face_surface, subface, oriented_face)"
            supertypes="topological_representation_item">
            <explicit
              name="bounds">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="face_bound"/>
            </explicit>
            <where
              label="WR1"
              expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))))">
            </where>
            <where
              label="WR2"
              expression="SIZEOF(QUERY(temp &lt;* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp))) &lt;= 1">
            </where>
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
         </entity>
      
       <entity
            name="face_surface"
            supertypes="face geometric_representation_item">
            <explicit
              name="face_geometry">
              <typename
                name="surface"/>
            </explicit>
            <explicit
              name="same_sense">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <where
              label="WR1"
              expression="NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry))">
            </where>
             <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
            <where  label="IP6"/>
            <where  label="IP7"/>
            <where  label="IP8"/>
          </entity>
       
       <entity
             name="oriented_face"
             supertypes="face">
             <explicit
               name="face_element">
               <typename
                 name="face"/>
             </explicit>
             <explicit
               name="orientation">
               <builtintype
                 type="BOOLEAN"/>
             </explicit>
             <derived
               name="face.bounds"
               expression="conditional_reverse(SELF.orientation,SELF.face_element.bounds)">
               <aggregate
                 type="SET"
                 lower="1"
                 upper="?"/>
               <typename
                 name="face_bound"/>
             </derived>
             <where
               label="WR1"
               expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element))">
             </where>
           </entity>
       
       <entity
            name="subface"
            supertypes="face">
            <explicit
              name="parent_face">
              <typename
                name="face"/>
            </explicit>
            <where
              label="WR1"
              expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))))">
            </where>
            <where  label="IP1"/>
            <where  label="IP2"/>
         </entity>
          
       <entity
            name="connected_face_set"
            super.expression="ONEOF (closed_shell, open_shell)"
            supertypes="topological_representation_item">
            <explicit
              name="cfs_faces">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="face"/>
            </explicit>
            <where  label="IP1"/>
         </entity>
          
      <entity
            name="subface"
            supertypes="face">
            <explicit
              name="parent_face">
              <typename
                name="face"/>
            </explicit>
            <where
              label="WR1"
              expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))))">
            </where>
             <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
      
      <entity
            name="vertex_shell"
            supertypes="topological_representation_item">
            <explicit
              name="vertex_shell_extent">
              <typename
                name="vertex_loop"/>
            </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
          </entity>
          
      <entity
            name="wire_shell"
            supertypes="topological_representation_item">
            <explicit
              name="wire_shell_extent">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="loop"/>
            </explicit>
            <where
              label="WR1"
              expression="NOT mixed_loop_type_set(wire_shell_extent)">
            </where>
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
          </entity> 
          
       <entity
             name="open_shell"
             supertypes="connected_face_set">
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
            <where  label="IP6"/>
            <where  label="IP7"/>
            <where  label="IP8"/>
            <where  label="IP9"/>
          </entity>
          
       <entity
             name="oriented_open_shell"
             supertypes="open_shell">
             <explicit
               name="open_shell_element">
               <typename
                 name="open_shell"/>
             </explicit>
             <explicit
               name="orientation">
               <builtintype
                 type="BOOLEAN"/>
             </explicit>
             <derived
               name="connected_face_set.cfs_faces"
               expression="conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces)">
               <aggregate
                 type="SET"
                 lower="1"
                 upper="?"/>
               <typename
                 name="face"/>
             </derived>
             <where
               label="WR1"
               expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (SELF.open_shell_element))">
             </where>
           </entity>
      
      <entity
            name="closed_shell"
            supertypes="connected_face_set">
            <where  label="IP1"/>
            <where  label="IP2"/>
            <where  label="IP3"/>
            <where  label="IP4"/>
            <where  label="IP5"/>
            <where  label="IP6"/>
            <where  label="IP7"/>
            <where  label="IP8"/>
            <where  label="IP9"/>
            <where  label="IP10"/>
          </entity>
      
      <entity
            name="oriented_closed_shell"
            supertypes="closed_shell">
            <explicit
              name="closed_shell_element">
              <typename
                name="closed_shell"/>
            </explicit>
            <explicit
              name="orientation">
              <builtintype
                type="BOOLEAN"/>
            </explicit>
            <derived
              name="connected_face_set.cfs_faces"
              expression="conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces)">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="face"/>
            </derived>
            <where
              label="WR1"
              expression="NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (SELF.closed_shell_element))">
            </where>
          </entity>
          
      <entity
            name="connected_face_sub_set"
            supertypes="connected_face_set">
            <explicit
              name="parent_face_set">
              <typename
                name="connected_face_set"/>
            </explicit>
            <where  label="IP1"/>
          </entity>
          
       <entity
            name="connected_edge_set"
            supertypes="topological_representation_item">
            <explicit
              name="ces_edges">
              <aggregate
                type="SET"
                lower="1"
                upper="?"/>
              <typename
                name="edge"/>
            </explicit>
            <where  label="IP1"/>
            <where  label="IP2"/>
    </entity>
    
        
        <entity
                name="volume_with_faces"
                supertypes="topological_representation_item geometric_representation_item" abstract.supertype="YES" 
                super.expression="ONEOF(volume_with_parametric_boundary, volume_with_shell)">
                <explicit
                  name="volume_geometry">
                   <typename
                    name="volume"/>
                </explicit>
                  </entity>
    
          <entity
                    name="volume_with_parametric_boundary"
                    supertypes="volume_with_faces">
                    <explicit
                      name="outer_bound">
                       <aggregate
		               type="LIST"
		               lower="6"
		               upper="6"/>
		            <typename name="face"/>
                    </explicit>
                  </entity>
    
            <entity
                    name="volume_with_shell"
                    supertypes="volume_with_faces">
                    <explicit
                      name="outer_bound">
                              <typename name="closed_shell"/>
                    </explicit>
                  </entity> 
    
    <entity
                        name="connected_volume_set"
                        supertypes="topological_representation_item">
                        <explicit
                          name="cvs_volumes">
                           <aggregate
    		               type="SET"
    		               lower="1"
    		               upper="?"/>
    		            <typename name="volume_with_faces"/>
                        </explicit>
                       <where  label="IP1"/>
                       <where  label="IP2"/>
                      <where  label="IP3"/>
                      </entity>
        
                <entity
                        name="connected_volume_sub_set"
                        supertypes="connected_volume_set">
                        <explicit
                          name="parent_volume_set">
                                  <typename name="connected_volume_set"/>
                        </explicit>
                        <where  label="IP1"/>
                  </entity> 
      
    <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;</algorithm>
      </function>
      <function name="closed_shell_reversed">
         <parameter name="a_shell">
            <typename name="closed_shell"/>
         </parameter>
         <typename name="oriented_closed_shell"/>
         <algorithm>LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="conditional_reverse">
         <parameter name="p">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;</algorithm>
      </function>
      <function name="edge_curve_pcurves">
         <parameter name="an_edge">
            <typename name="edge_curve"/>
         </parameter>
         <parameter name="the_surface_curves">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="surface_curve"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="pcurve"/>
         <algorithm>LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (result);</algorithm>
      </function>
      <function name="edge_reversed">
         <parameter name="an_edge">
            <typename name="edge"/>
         </parameter>
         <typename name="oriented_edge"/>
         <algorithm>LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="face_bound_reversed">
         <parameter name="a_face_bound">
            <typename name="face_bound"/>
         </parameter>
         <typename name="face_bound"/>
         <algorithm>LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);</algorithm>
      </function>
      <function name="face_reversed">
         <parameter name="a_face">
            <typename name="face"/>
         </parameter>
         <typename name="oriented_face"/>
         <algorithm>LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_loop_edges">
         <parameter name="l">
            <typename name="loop"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="edge"/>
         <algorithm>LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);</algorithm>
      </function>
      <function name="list_of_topology_reversed">
         <parameter name="a_list">
            <typename name="list_of_reversible_topology_item"/>
         </parameter>
         <typename name="list_of_reversible_topology_item"/>
         <algorithm>LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="list_shell_edges">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="edge"/>
         <algorithm>LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);</algorithm>
      </function>
      <function name="list_shell_faces">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="face"/>
         <algorithm>LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);</algorithm>
      </function>
      <function name="list_shell_loops">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) &lt;= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt; poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="open_shell_reversed">
         <parameter name="a_shell">
            <typename name="open_shell"/>
         </parameter>
         <typename name="oriented_open_shell"/>
         <algorithm>LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);</algorithm>
      </function>
      <function name="path_reversed">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <typename name="oriented_path"/>
         <algorithm>LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);</algorithm>
      </function>
      <function name="set_of_topology_reversed">
         <parameter name="a_set">
            <typename name="set_of_reversible_topology_item"/>
         </parameter>
         <typename name="set_of_reversible_topology_item"/>
         <algorithm>LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="shell_reversed">
         <parameter name="a_shell">
            <typename name="shell"/>
         </parameter>
         <typename name="shell"/>
         <algorithm>IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;</algorithm>
      </function>
      <function name="topology_reversed">
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);</algorithm>
      </function>
      <function name="vertex_point_pcurves">
         <parameter name="a_vertex">
            <typename name="vertex_point"/>
         </parameter>
         <parameter name="the_degenerates">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="evaluated_degenerate_pcurve"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="degenerate_pcurve"/>
         <algorithm>LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (result);</algorithm>
      </function>
   </schema>
</express>