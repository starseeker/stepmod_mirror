<html>

<head>
<title>Guidelines for the content application modules</title>
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
</head>

<body bgcolor="#ffffff">

<p align="right"><strong>ISO TC184/SC4 N1161</strong><br>
Date: 2001-05-02
<h3 align="Center"><br>
<br>
ISO TC 184/SC4 DRAFT STANDING DOCUMENT</h3>
<p>&nbsp;
<hr>
<p align="Center">Technical Committee 184 for Industrial Automation Systems and
Integration Subcommittee 4 for Industrial Data
<p>&nbsp;
<p>&nbsp;
<table border="1" cellpadding="2" width="60%" align="Center">
  <tr>
    <td>
      <h2 align="Center">Guidelines for the content of application modules</h2>
    </td>
  </tr>
</table>
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<p align="Center">ISO TC 184/SC4 WG10 Technical Architecture<br>
National Institute of Standards and Technology<br>
Building 220/Room A127<br>
Gaithersburg, Maryland 20899<br>
USA
<p>&nbsp;
<hr>
<h3>Contents</h3>
<p><br>
<a href="#Scope">1 Scope</a><br>
<a href="#NormativeReferences">2 Normative references</a><br>
<a href="#definitions">3 Terms, definitions and abbreviations</a><br>
<a href="#AMContent">4 Application module content overview</a><br>
<a href="#AMSpec">5 Specification of application module content</a><br>
<a href="#annexa">Annex A Conformance testing concepts for application modules</a><br>
<a href="#annexb">Annex B Examples</a><br>
<p>&nbsp;
<p>&nbsp;
<hr>
<h3>Foreword</h3>
<p>The International Organization for Standardization (ISO) is a worldwide
federation of national standards bodies (ISO member bodies). The work of
preparing International Standards is normally carried out through ISO technical
committees. Each member body interested in a subject for which a technical
committee has been established has the right to be represented on that
committee. International organizations, governmental and non-governmental, in
liaison with ISO, also take part in the work. ISO collaborates closely with the
International Electrotechnical Commission (IEC) on all matters of
electrotechnical standardization.
<p>This standing document was prepared by Technical Committee ISO/TC 184, <i>Industrial
automation systems and integration</i>, Subcommittee SC4, <i>Industrial data</i>.
<p>ISO/TC 184/SC4 standards are prepared according to guidelines put forth in
the following standing documents:
<p>&nbsp;
<ul>
  <li>Guidelines for the content of application modules;
  <li>Guidelines for application interpreted model development;
  <li>Guidelines for the content of application protocols using application
    modules;
  <li>Guidelines for the development of abstract test suites;
  <li>ISO/TC 184/SC4 organization handbook;
  <li>Supplementary directives for the drafting and presentation of ISO 10303.
</ul>
<p>The use of the following guidelines are deprecated due to the new guidelines
for application modules and application protocols using application modules:
<ul>
  <li>Guidelines for the development and approval of STEP application protocols;
  <li>Guidelines for the development of mapping tables;
  <li>Guidelines for application interpreted construct development.
</ul>
<p>&nbsp;
<p>&nbsp;
<hr>
<h3>&nbsp;</h3>
<h3><a name="Introduction"></a>Introduction</h3>
<p>ISO 10303 is an International Standard for the computer-interpretable
representation and exchange of product data. The objective is to provide a
neutral mechanism capable of describing product data throughout the life cycle
of a product independent from any particular system. The nature of this
description makes it suitable not only for neutral file exchange, but also as a
basis for implementing and sharing product databases and archiving.
<p>This International Standard is organized as a series of parts, each published
separately. The parts of ISO 10303 fall into one of the following series:
description methods, integrated resources, application interpreted constructs,
application modules<sup>1</sup>, application protocols, abstract test suites,
implementation methods, and conformance testing. The series are described in ISO
10303-1.
<p>The purpose of this standing document is to provide guidelines for the
content of ISO 10303 application modules (AMs) that are used as the data
specification for ISO 10303 application protocols (APs).
<p>The application modules are the key component of the modularization of the
initial ISO 10303 architecture. The modularization approach extends the
application interpreted construct (AIC) concept of the initial ISO 10303
architecture through inclusion of the relevant portions of the AP's application
reference model. The basis of the approach is understanding and harmonizing the
requirements, both new and those documented in existing APs, grouping the
requirements into reuseable modules, documenting the modules, and using the
modules in the development of an application protocol.
<p>An AM contains much of the technical content that, in the initial ISO 10303
architecture, was previously documented in an AP. The role of an AP in the new
architecture is to select and constrain a set of the more generic AMs to satisfy
information requirements in a particular application context.
<p>The development of an application protocol modularization strategy was driven
by several requirements from different sources:
<ul>
  <li>to reduce the high cost of developing an application protocol;
  <li>to ensure the ability to implement a combination of subsets of multiple
    APs or to extend existing APs to meet a business need;
  <li>to ensure the ability to reuse a subset of the application software
    developed for one AP in the development of application software for another
    AP in the areas where they have the same, or similar, requirements;
  <li>to avoid the duplication and repeated documentation of the same
    requirements in different application protocols leading to potentially
    different solutions for the same requirements; and
  <li>to ensure the ability to reuse data generated by an implementation of one
    or more APs by an implementation of one or more different APs.
</ul>
<p>The expected audience for this document includes developers of ISO 10303
application modules and application protocols as well as users of application
protocols who are interested in a more in-depth understanding of the origins of
the structure of application protocols.
<p><small><b>NOTE</b> - This document is an adaptation of the guidance found in <i>Guidelines
for the development and approval of STEP application protocols</i>, <i>Guidelines
for application interpreted model development</i>, </small><i><small>Guidelines
for the development of mapping tables</small></i> <small>and <i>Guidelines for
application interpreted construct development</i>.</small>
<p><small><sup>1</sup> To be added to ISO 10303-1 as part of the WG10 STEP
Modularization PWI responsibilities.</small>
<p>&nbsp;
<p>&nbsp;
<p>&nbsp;
<hr>
<table cellpadding="2" width="100%">
  <tr>
    <td>DRAFT STANDING DOCUMENT</td>
    <td align="Right">ISO TC184/SC4 N1161</td>
  </tr>
</table>
<p>&nbsp;
<hr>
<p>&nbsp;
<h2>Guidelines for the content of application modules</h2>
<p>&nbsp;
<h3><a name="Scope"></a>1 Scope</h3>
<p>&nbsp;
<p>This standing document specifies guidelines for the content of ISO 10303
application modules.
<p>The following are within the scope of this standing document:
<ul>
  <li>description of the content of an application module.
</ul>
<p>The following are outside the scope of this standing document:
<ul>
  <li>guidelines for the development process for application modules;
  <li>guidelines for the development process for application protocols using
    application modules;
  <li>specification of presentation information for the documentation of an ISO
    10303 application module;
  <li>detailed guidance on how to select constructs of the ISO 10303 integrated
    resources that map to the information requirements of an ISO 10303
    application module;
  <li>guidelines for development of mapping specifications for documents other
    than ISO 10303 application modules;
  <li>guidelines for the use of EXPRESS in information models other than ISO
    10303 application modules;
  <li>description of how the application modules are to be used in the
    documentation of application protocols.
</ul>
<p>&nbsp;
<h3><a name="NormativeReferences"></a>2 Normative references</h3>
<p>The following standards contain provisions which, through reference in this
text, constitute provisions of this standing document. At the time of
publication, the editions indicated were valid. All standards are subject to
revision, and parties to agreements based on this standing document are
encouraged to investigate the possibility of applying the most recent editions
of the standards indicated below. Members of the IEC and ISO maintain registers
of currently valid International Standards.
<p>ISO 10303-1:1994, <em>Industrial automation systems and integration —
Product data representation and exchange — Part 1: Overview and fundamental
principles.</em>
<p>ISO 10303-11:1994, <em>Industrial automation systems and integration —
Product data representation and exchange — Part 11: Description methods:
Language reference manual</em> and its Amendment 1.
<p>The following documents contain provisions which, through reference in this
text, constitute provisions of this standing document. At the time of adoption,
the revisions of the documents indicated were valid. All documents are subject
to revision, and users of this standing document are encouraged to investigate
the possibility of applying the most recent editions of the documents indicated
below.
<p>ISO/TC 184/SC4 N534:1997, <em>Guidelines for application interpreted
construct development.</em>
<p>ISO/TC 184/SC4 N535:1997, <em>Guidelines for the development and approval of
STEP application protocols.</em>
<p>ISO/TC 184/SC4 N1113:2001, <em>Guidelines for the content of application
protocols using application modules.</em>
<p>ISO/TC 184/SC4 N1029 , <em>Guidelines for the development of mapping
specifications, 2nd Edition.</em>
<p>ISO/TC 184/SC4 N858:, <em>Supplementary directives for the drafting and
presentation of ISO 10303, edition 2.</em>
<p>&nbsp;
<h3><a name="definitions">3</a> Terms, definitions and abbreviations</h3>
<h3>3.1 Terms defined in ISO 10303-1</h3>
<p>For the purpose of this standing document, the following terms defined in ISO
10303-1 apply.
<p><b>3.1.1<br>
abstract test suite (ATS)</b><br>
a part of ISO 10303 that contains the set of abstract test cases necessary for
conformance testing of an implementation of an application protocol.<br>
<br>
<b>3.1.2<br>
application</b><br>
a group of one or more processes creating or using product data.<br>
<br>
<b>3.1.3<br>
application object</b><br>
an atomic element of an application reference model that defines a unique
application concept and contains attributes specifying the data elements of the
object.<br>
<br>
<b>3.1.4<br>
application reference model (ARM)</b><br>
an information model that describes the information requirements and constraints
of a specific application context.<br>
<br>
<b>3.1.5<br>
conformance class</b><br>
a subset of an application protocol for which conformance may be claimed.<br>
<br>
<b>3.1.6<br>
data</b><br>
a representation of information in a formal manner suitable for communication,
interpretation, or processing by human beings or computers.<br>
<br>
<b>3.1.7<br>
implementation method</b><br>
a part of ISO 10303 that specifies a technique used by computer systems to
exchange product data that is described using the EXPRESS data specification
language.<br>
<br>
<b>3.1.8<br>
information</b><br>
facts, concepts, or instructions.<br>
<br>
<b>3.1.9<br>
information model</b><br>
a formal model of a bounded set of facts, concepts, or instructions to meet a
specified requirement.<br>
<br>
<b>3.1.10<br>
integrated resource</b><br>
a part of ISO 10303 that defines a group of resource constructs used as a basis
for product data.<br>
<br>
<b>3.1.11<br>
interpretation</b><br>
the process of adapting a resource construct from the integrated resources to
satisfy a requirement of an application protocol. This may involve the addition
of restrictions on attributes, the addition of constraints, the addition of
relationships among resource constructs and application constructs, or all of
the above.<br>
<br>
<b>3.1.12<br>
product</b><br>
a thing or substance produced by a natural or artificial process.<br>
<br>
<b>3.1.13<br>
product data</b><br>
a representation of information about a product in a formal manner suitable for
communication, interpretation, or processing by human beings or by computers.<br>
<br>
<b>3.1.14<br>
resource construct</b><br>
a collection of EXPRESS language entities, types, functions, rules and
references that together define a valid description of an aspect of product
data.<br>
<br>
<b>3.1.15<br>
unit of functionality (UoF)</b><br>
a collection of application objects and their relationships that defines one or
more concepts within the application context such that the removal of any
component would render the concepts incomplete or ambiguous.<br>
<h3>3.2 Terms defined in ISO 10303-31</h3>
<p>For the purpose of this standing document, the following terms defined in ISO
10303-31 apply.<br>
<br>
<b>3.2.1<br>
abstract test case (ATC)</b><br>
a specification, encapsulating at least one test purpose, that provides the
formal basis from which executable test cases are derived. It is independent of
both the implementation and the values.<br>
<br>
<b>3.2.2<br>
conformance testing</b><br>
the testing of a candidate product for the existence of specific characteristics
required by a standard in order to determine the extent to which that product is
a conforming implementation.<br>
<h3>3.3 Terms defined in ISO 10303-202</h3>
<p>For the purpose of this standing document, the following terms defined in ISO
10303-202 apply.
<p><b>3.3.1<br>
application interpreted construct (AIC)</b><br>
a logical grouping of interpreted constructs that supports a specific function
for the usage of product data across multiple application contexts.<br>
<h3>3.4 Terms defined in ISO 10303-1001</h3>
<p>For the purpose of this standing document, the following terms defined in ISO
10303-1001 apply.
<p><b>3.4.1<br>
application module (AM)</b><br>
a reusable collection of a scope statement, information requirements, mappings
and module interpreted model that supports a specific usage of product data
across multiple application contexts.<br>
<h3>3.5 Definitions</h3>
<p>For the purpose of this standing document, the following definitions apply:
<p><b>3.5.1<br>
application protocol (AP)</b><br>
a part of ISO 10303 that species an application module satisfying the scope and
information requirements for a specific application.<br>
<table border="0" cellpadding="1" width="95%" align="CENTER">
  <tr>
    <td><small>NOTE - Adapted from ISO 10303-1.</small></td>
  </tr>
</table>
<h3>3.6 Abbreviations</h3>
<p>For the purposes of this standing document, the following abbreviations
apply.<br>
<table border="0" cellpadding="2" width="80%" align="CENTER">
  <tr>
    <td>AR</td>
    <td>application resource</td>
  </tr>
  <tr>
    <td>AIC</td>
    <td>application interpreted construct</td>
  </tr>
  <tr>
    <td>AM</td>
    <td>application module</td>
  </tr>
  <tr>
    <td>AP</td>
    <td>application protocol</td>
  </tr>
  <tr>
    <td>ARM</td>
    <td>application reference model</td>
  </tr>
  <tr>
    <td>CC</td>
    <td>conformance class</td>
  </tr>
  <tr>
    <td>GR</td>
    <td>generic resource</td>
  </tr>
  <tr>
    <td>IR</td>
    <td>integrated resource</td>
  </tr>
  <tr>
    <td>MIM</td>
    <td>module interpreted model</td>
  </tr>
  <tr>
    <td>MS</td>
    <td>mapping specification</td>
  </tr>
  <tr>
    <td>UoF</td>
    <td>unit of functionality</td>
  </tr>
  <tr>
    <td>URL</td>
    <td>universal resource locator</td>
  </tr>
</table>
<p align="Center">&nbsp;
<h3><a name="AMContent"></a>4 Application module content overview</h3>
<p>This clause provides an overview of the contents of an application module.
The contents for an application module are given in figure 1 and are explained
in the subsequent subclauses. The three major components of an AM are: 1) the
scope and functional requirements; 2) the application reference model as a
representation of the application domain information requirements; and 3) the
module interpreted model that specifies the required use of the common
resources. Additionally, each application module has an associated module
validation results document, test cases or abstract test suite.
<p>&nbsp;
<table border="2" align="CENTER">
  <tr>
    <td>Foreword<br>
      Introduction<br>
      1 Scope<br>
      2 Normative references<br>
      3 Definitions and abbreviations<br>
      4 Information requirements<br>
      4.1 Units of functionality<br>
      4.2 Required AM ARMs<br>
      4.3 ARM type definitions<br>
      4.4 ARM entity definitions<br>
      4.5 ARM rule definitions<br>
      4.6 ARM function definitions<br>
      5 Module interpreted model<br>
      5.1 Mapping specification<br>
      5.2 MIM EXPRESS short listing<br>
      <br>
      Annexes<br>
      A AM MIM short names<br>
      B Information object registration<br>
      C ARM EXPRESS-G<br>
      D MIM EXPRESS-G<br>
      E AM ARM and MIM EXPRESS listings<br>
      F Concepts required from other AMs<br>
      G Application module implementation and usage guide<br>
      H Technical discussions<br>
      I Bibliography<br>
      Index</td>
  </tr>
</table>
<p align="Center"><b>Figure 1 - Contents of an application module</b>
<h4>4.1 The foreword and introduction</h4>
<p>The Foreword for the AM shall contain the text specified in Figure 2 with the
normative and informative annex lists as appropriate for the AM. The footnote
reference shall be marked as in Figure 2 text &quot;. The series are described
in ISO 10303-11&quot;. The footnote shall read: &quot;A future edition of ISO
10303-1 will describe the application modules series.&quot;
<p>&nbsp;
<table border="1" cellpadding="2" width="80%" align="CENTER">
  <tr>
    <td>ISO (the International Organization for Standardization) is a worldwide
      federation of national standards bodies (ISO member bodies). The work of
      preparing International Standards is normally carried out through ISO
      technical committees. Each member body interested in a subject for which a
      technical committee has been established has the right to be represented
      on that committee. International organizations, governmental and
      non-governmental, in liaison with ISO, also take part in the work. ISO
      collaborates closely with the International Electrotechnical Commission (IEC)
      on all matters of electrotechnical standardization.
      <p>The main task of technical committees is to prepare International
      Standards. Draft International Standards adopted by the technical
      committees are circulated to the member bodies for voting. Publication as
      an International Standard requires approval by at least 75% of the member
      bodies casting a vote.
      <p>In other circumstances, particularly when there is an urgent market
      requirement for such documents, a technical committee may decide to
      publish other types of normative documents:
      <ul>
        <li>an ISO Publicly Available Specification (ISO/PAS) represents an
          agreement between technical experts in an ISO working group and is
          accepted for publication if it is approved by more than 50% of the
          members of the parent committee casting a vote;
        <li>an ISO Technical Specification (ISO/TS) represents an agreement
          between the members of a technical committee and is accepted for
          publication if it is approved for publication if it is approved by 2/3
          of the members of the committee casting a vote.
      </ul>
      <p>An ISO/PAS or ISO/TS is reviewed every three years with a view to
      deciding whether it can be transformed into an International Standard
      ISO/TS 10303-28 was prepared by Technical Committee 184, <i>Industrial
      automation systems and integration</i>, Subcommittee SC4, <i>Industrial
      data</i>.
      <p>This International Standard is organized as a series of parts, each
      published separately. The parts of ISO 10303 fall into one of the
      following series: description methods, integrated resources, application
      interpreted constructs, application modules, application protocols,
      abstract test suites, implementation methods, and conformance testing. The
      series are described in ISO 10303-1<sup>1</sup>. A complete list of parts
      of ISO 10303 is available from the Internet:
      <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;http://www.nist.gov/sc4/editing/step/titles/&gt;.
      <p>This part of ISO 10303 is a member of the application modules series.
      <p>Annexes &lt;normative annex list&gt; form an integral part of this part
      of ISO 10303. Annexes &lt;informative annex list&gt; are for information
      only.
      <p>&nbsp;
      <hr>
      <small>1 - A future edition of ISO 10303-1 will describe the application
      modules series.</small></td>
  </tr>
</table>
<p align="Center"><b>Figure 2 - The boilerplate text for the Foreword of an
application module.</b>
<p>The Introduction for the AM shall provide an overview of the technical
content. The Introduction shall explain the relationships between the AMs that
are used by the AM being defined and shall begin with the text specified in
Figure 3.
<p>&nbsp;
<table border="1" cellpadding="2" align="CENTER" width="80%">
  <tr>
    <td>ISO 10303 is an International Standard for the computer-interpretable
      representation of product information and for the exchange of product
      data. The objective is to provide a neutral mechanism capable of
      describing products throughout their life cycle. This mechanism is
      suitable not only for neutral file exchange, but also as a basis for
      implementing and sharing product databases, and as a basis for archiving.
      <p>This application module &lt;application module-specific introductory
      text&gt;.</td>
  </tr>
</table>
<p align="Center"><b>Figure 3 - The boilerplate text for the Introduction of an
application module.</b>
<p>&nbsp;
<h4>4.2 The scope</h4>
<p>Clause 1 of an AM shall define the domain of the AM and summarize the
fundamental concepts and assumptions of the scope, the functionality of the AM,
and the types of information that are accommodated by the AM. A description of
the functionality and information that are specifically outside the scope of the
application module shall be defined to clarify the domain of the AM.
<h4>4.3 The normative references</h4>
<p>All normative references shall be listed in clause 2 of an AM. The minimal
required set of normative references are:
<p>ISO 10303-1 Industrial automation systems and integration - Product data
representation and exchange - Part 1: Overview and fundamental principles.
<p>ISO 10303-11 Industrial automation systems and integration - Product data
representation and exchange - Part 11: Description methods: The EXPRESS language
reference manual.
<p>ISO/IEC 8824-1:1995, Information Technology - Open Systems Interconnection -
Abstract Syntax Notation One (ASN.1) - Part 1: Specification of Basic Notation.
<p>The normative references shall include the application modules directly used
by the application module being defined.
<h4>4.4 The definitions and abbreviations</h4>
<p>Clause 3 of an AM shall include definitions of all concepts necessary to
understand the Introduction, Scope, and Information requirements clauses. This
clause may include concepts that are defined further in the Information
requirements clause. The concept definitions provided in this clause shall be
consistent with the complete definitions provided in the Information
requirements clause. This clause shall not include the definitions of objects
defined in the application reference model or the module interpreted model. This
clause shall list the terms defined in other ISO standards, including AMs, that
are necessary for understanding the AM.
<h4>4.5 The information requirements</h4>
<p>Clause 4 of an AM shall describe the functionality and information
requirements of the AM. The first paragraphs of this clause provide a high level
description of the information requirements that are supported by the AM and a
summary of the structure used to partition the information requirements.
<p>This clause may include a description of the types of information supported
by the AM, any restrictions on the information supported, and the supported uses
of the defined information.
<p>This clause shall provide all additional information on the fundamental
concepts and assumptions (initially introduced in clauses 1 and 3) which is
necessary for complete understanding of the information requirements and the
scope boundaries. This clause shall include a description the fundamental
concepts and UoFs of the AM and any prerequisite AMs used by the AM.
<p>This clause shall include subclauses for units of functionality, referenced
AM ARMs and ARM type definitions, ARM entity definitions, ARM rule definitions,
and ARM function definitions as required. The ARM shall be defined using the
EXPRESS language and is constructed from AM specific declarations and other AM
ARMs referenced using the EXPRESS interface specification (USE FROM) defined in
ISO 10303-11.
<h4>4.5.1 The units of functionality</h4>
<p>The first subclause of clause 4 shall provide a complete list of the UoFs
defined in the AM and defined in any other AM used directly or indirectly by the
AM. This is the only place in an application module where the full domain of the
application module and all of its prerequisite application modules is found.
<p>A UoF is a grouping of data constructs which is important in the application
module. A UoF specifies the set of application objects that constitute one or
more concepts of the application reference model. UoFs are a mechanism for
modularizing the information requirements into primary concepts. The UoFs are
used to organize and summarize the functionality of the ARM.
<p>Each UoF definition shall include the scope of the UoF, a description of the
function(s) that the grouping of data is intended to support, and a list of the
application objects that are included in the UoF.
<p>For a UoF defined in another application module the UoF description in the
using AM shall list the application objects referenced by objects in the using
AM.
<p><b><small>NOTE</small></b><small> - The intent is for application modules to
define one UoF and possibly make use of UoFs defined within other application
modules.</small>
<h4>4.5.2 The referenced application module ARMs</h4>
<p>The next subclause of clause 4 of an AM shall specify the application
reference models defined in other application modules that are referenced by the
AM. This specification takes the form of documented EXPRESS USE FROM constructs
and shall use the ARM from the required AMs in its entirety.
<p>As part of the migration path to a modularized ISO 10303 standard, consensus
may be reached on the scope of an AM under development which requires other AMs
that do not yet exist. In this case the AM under development may create an
informative ARM defining the concepts it requires and document that ARM in annex
F. Requirements on an interpretation of that ARM may also be specified in annex
F.
<h4>4.5.3 The ARM type definitions</h4>
<p>If the AM ARM declares defined types, the next subclause of clause 4 of an AM
shall specify the defined types necessary for the description of the application
objects defined in the AM.
<p>The EXPRESS language has been extended adding support for extensible SELECT
data types and enumeration data types to support the creation of application
modules. The use of these constructs should be considered in any case where the
complete set of items required for a select or enumeration data type is not
known or not withing the scope of the application module.
<h4>4.5.4 The application objects as ARM entity definitions</h4>
<p>The next subclause of clause 4 of an AM shall include the definitions for all
application objects and attributes declared in the AM. An application object is
an atomic element of an application reference model that defines a unique
application concept and contains attributes specifying the data elements of the
object. Application objects are documented in the ARM by EXPRESS ENTITY
definitions.
<p>Application objects documented as EXPRESS entities contain the definitions of
simple attributes, derived attributes, relationship attributes and relationship
constraints. Simple attributes are those which evaluate to a simple data type.
Relationship attributes are those which establish a relationship with another
application object. Relationship constraints are EXPRESS INVERSE attributes
which constrain the cardinality of a relationship between two application
objects.
<h4>4.5.5 The ARM rule definitions</h4>
<p>If the AM ARM declares rules, the next subclause of clause 4 of an AM shall
specify the necessary rules constraining the application objects.
<p><small><b>NOTE</b>: Global rules should be examined carefully to avoid
unnecessarily preventing the reuse of the AM.</small>
<h4>4.5.6 The ARM function definitions</h4>
<p>If the AM ARM declares functions, the next subclause of clause 4 of an AM
shall specify the necessary functions used by the ARM rules and ARM entity
definitions.
<h4>4.6 The module interpreted model</h4>
<p>Clause 5 of an AM shall specify the module interpreted model. The MIM shall
be defined using the EXPRESS language and is constructed from the resource
constructs (including the MIM schemas of other AMs) using the EXPRESS interface
specification (USE FROM) defined in ISO 10303-11. The required resource
constructs may be further refined in the AM. The need for refinement of the
resource constructs arises out of the information requirements of the particular
application module domain.
<h4>4.6.1 The mapping specification</h4>
<p>Clause 5.1 of an AM shall specify the mapping specification. The mapping
specification documents the correspondence between the information requirements
and the constructs of the MIM. This mapping specification shall specify an
unambiguous mapping between the application objects and their attributes defined
in the information requirements clause and the constructs of the MIM. The
mapping shows how the common resource constructs are used to meet the
information requirements of the application module.
<h4>4.6.1.1 The reuse and specialization of mapping specifications</h4>
<p>When one AM requires the use of another AM, that use includes the mapping
specification of the used AM in the scope of the using AM. This reuse of mapping
specifications is the same as the reuse of the ARM and MIM from a used AM in the
scope of the using AM. The using AM may not contradict the mapping specification
in the used AM but may specialize the mapping specification to meet more
specialized requirements defined in the using AM. This specialization of a
mapping specification consists of the following:<br>
<ul>
  <li>the elimination of one or more possibilities in an OR map;
  <li>the addition of mapping constraints on attribute domain values.
</ul>
<h4>4.6.1.2 The mapping specification for abstract concepts in the ARM</h4>
<p>In the case that a generic and abstract concept appears in the ARM of an AM
with the expectation that the concept will be completed in the ARM of a using
AM, then a mapping specification need not be complete for that ARM concept.
<p>Additionally, if a mapping specification is written for a concept, the
concept need not appear in the MIM short form schema. This allows for the
concept to be completed in a using ARM where a complete mapping specification
and instantiable and complete MIM short form constructs are defined. An example
of the use of this mechanism might be to address Part 41 management resource
assignment completion.
<h4>4.6.2 The MIM short form</h4>
<p>Clause 5.2 of an AM shall specify the MIM EXPRESS short listing. The MIM
EXPRESS short listing shall consist of USE FROM statements that select common
resource constructs and the MIM schemas from other AMs, AM specific
declarations, and any appropriate modifications to textual material that applies
to constructs interfaced into the MIM schema from the common resources. The
declarations include TYPE declarations, ENTITY declarations that create subtypes
of resource entities, and any necessary RULES, and FUNCTIONS that are required
to satisfy the information requirements. Any declarations of types, entities,
rules, and functions defined in the AM are fully documented in the MIM EXPRESS
short listing. Textual modifications may also be made in the MIM documentation
including the following:
<ul>
  <li>clarification of application specific interpretation of the meaning of a
    generic entity definition;
  <li>clarification of application specific interpretation of the meaning of one
    or more attributes;
  <li>specification of application specific informal propositions;
  <li>addition of application specific examples and notes.
</ul>
<h4>4.7 The annexes and bibliography</h4>
<p>The following annexes appear in an AM.<br>
<dl>
  <dl>
    <dt>A MIM short names (normative)</dt>
    <dd>This annex shall contain a&nbsp;correspondence table&nbsp;between the
      EXPRESS entities defined in the short form&nbsp;MIM and a short name. This
      list shall be unique across all common&nbsp;resources.&nbsp; This list
      shall not contain EXPRESS entities defined in the ARM of the AM.&nbsp; The
      short name shall be defined using SC4 procedures.</dd>
  </dl>
  <dt>&nbsp;
  <dt>B Information object registration (normative)</dt>
  <dd>This annex shall specify the information object identifiers for the
    application module. This shall include identifiers for the AM document, the
    ARM schema and for the MIM schema.
    <p>&nbsp;
  <dt>C ARM EXPRESS-G (informative)
  <dd>This annex shall contain an EXPRESS-G representation containing at a
    minimum all entity data types defined in the ARM. Additional constructs from
    the ARMs defined in required AMs may also be contained in order to assist in
    clarifying the relationships between ARM concepts. The graphical
    presentation of the ARM, i.e., EXPRESS-G, aids the understanding and review
    of the information requirements and definitions. The ARM diagrams shall be
    at a detail level sufficient to present the requirements in a manner that it
    is understandable to an application domain expert. This representation shall
    be documented in accordance with annex D of ISO 10303-11 and the <i>Supplementary
    directives for the drafting and presentation of ISO 10303</i>.
    <p>&nbsp;
  <dt>D MIM EXPRESS-G (informative)
  <dd>This annex shall contain the EXPRESS-G representation of all interface
    specifications and all types and entities defined in the MIM. This
    representation shall be documented in accordance with annex D of ISO
    10303-11 and the <i>Supplementary directives for the drafting and
    presentation of ISO 10303</i>.
    <p>&nbsp;
  <dt>E MIM and ARM EXPRESS listing (informative)
  <dd>This annex shall contain a reference to a URL with the entire MIM and ARM
    EXPRESS short listing without comments.
    <p>&nbsp;
  <dt>F Concepts required from other AMs (optional and informative)
  <dd>This annex, if provided, contains the concepts required from other AMs
    that do not yet exist. These include one or more annotated informative ARM
    schema declaring constructs required by the ARM schema of the AM being
    defined. Constraints on the interpretation of the informative ARM schema may
    also be defined. These define the concepts required for the successful use
    of the AM without defining them completely and without specifying where they
    will be standardized. This annex should not appear in AMs that are complete
    and ready for ballot.
    <p>&nbsp;
  <dt>G Application module implementation and usage guide (optional and
    informative)
  <dd>This annex, if provided, contains informative guidance on implementing and
    using the AM. This annex provides guidance to two different audiences, i.e.,
    implementors and end users of AM compliant implementations. Example
    information descriptions that are supported by the AM and the corresponding
    AM exchange files may be included in this annex. If exchange files are
    included in this annex, the annex should explain the primary data structures
    and the logic and meaning of the values used in the exchange file.
    <p>&nbsp;
  <dt>H Technical discussions (optional and informative)
  <dd>This annex, if provided, contains a summary of relevant technical
    discussions and the resolution of issues raised during the development of
    the AM. This annex provides background information for potential users of
    the AM and for developers of similar or related AMs. The material given
    should not cast doubt or self justify. Only material which supports the
    normative text shall be given.
    <p>&nbsp;
  <dt>Bibliography (informative)
  <dd>This lists all informative references relevant to the AM.
    <p>&nbsp;
</dl>
<h3><a name="AMSpec"></a>5 Specification of application module content</h3>
<p>&nbsp;
<p>This clause specifies the required content for an AM. Unless overridden by
this standing document, the presentation of the various elements of an
application module is governed by the relevant ISO directives and SC4 standing
documents.
<h4>5.1 Scope content</h4>
<p>The definition of the scope and information requirements begins with the
formulation of a statement of the application module functional requirements.
The detailed scoping and information requirements definition shall follow from
this statement.
<p>The scope and requirements identify the primary concepts and relationships to
be supported by the AM. The AM's scope and information requirements shall be
carefully defined and documented. The AM scope statement shall include a summary
of the data that are within scope. This scope statement shall define the
following characteristics of the scope of the application module as appropriate
given the AM domain:
<ul>
  <li>types of information;
  <li>types of data;
  <li>life cycle stages supported;
  <li>uses of the information, e.g., functional or application processes,
    supported;
  <li>discipline views supported.
</ul>
<p>For the purposes of clarification, an AM exclusion from scope statement shall
appear that includes the data outside the scope of the AM. The same
characteristics used to define the scope may be included as appropriate.
<h4><a name="ScopeRefine"></a>5.1.1 Scope refinement</h4>
<p><a href="#b3">Scope refinement</a> is the process of taking a single
application module and breaking it down into two or more application modules to
address exactly the original scope. A revision is then made to the original AM
such that it uses the new AMs to meet its requirements. The refinement of the
scope of an AM includes identifying and separating concepts to maximize reuse of
the AMs and identifying mandatory relationships with other AM's. Each AM should
define a unique and distinct set of Application Objects relating only to the
concept being represented. It should contain no Application Objects that are
defined by another AM, that is representing another concept. Vocabulary will
typically change from concept to concept. The description of the AM should not
contain sentences that move from one concept to another. The use of
conjunctions, such as 'and', in either the name or description of an AM is an
indication that there is more than one concept being represented. Unless it can
be demonstrated that the concepts being represented are inseparable in all
applications, serious consideration should be given to separating those concepts
and defining an AM for each.
<h4>5.2 Information requirements specification</h4>
<p>Based on the detailed scope and functional requirements that have been
defined, the information domain of the AM is defined in the application
reference model (ARM). The ARM shall be documented using EXPRESS. The ARM shall
describe fully the data needs of the application module, using the potentially
harmonized terminology of the application domain(s).
<p>The ARM documents the required data and relationships of the AM. The
information requirements shall be modelled only to the level necessary to convey
the information that is important from the application experts' point of view.
An ARM shall be sufficiently detailed so that the selection and interpretation
of the common resources can be done accurately.
<p>A mechanism for modularizing the scope of an industry domain into manageable
constructs is to define units of functionality. A UoF is a collection of
application objects and assertions that conveys one or more well-defined
concepts within the context of an ARM. A UoF may result in one or more AM's and
an AM may include or use more than one UoF. However, to realize the most
reusability of an application module the scope of application modules that
define multiple UoFs should be reviewed for potential <a href="#ScopeRefine">refinement</a>.
A UoF usually supports an application function or process. UoFs are used to
organize and summarize the functionality of the ARM. For example, if a geometric
modelling application has a requirement for wireframe geometry, then a UoF may
be defined which provides a grouping of those application objects in the ARM
which are intended to support geometric modelling using wireframe geometry.
<p>This standing document does not constrain the size, scope or domain of an AM.
Therefore, it is possible that an AM may be created that is of a sufficiently
large scope that it might contain more than one UoF. It is also possible that AM
developers might want do break find a domain where an AM with a very small scope
needs to be shared by two other larger AMs.<br>
<table border="0" cellpadding="2" width="95%">
  <tr>
    <td><small>EXAMPLE - Conformance Class 1 of ISO 10303-203 Edition 1 might be
      reformulated as a single AM and thus it would contain several UoFs.
      Conformance Class 1 of ISO 10303-203 Edition 1 might be reformulated as
      many AMs and a single AO might nbe identified that needs to be shared
      among two larger AMs and so a small AM is created containing only one AO.
      In this case, the small AM might not be large enough to have been
      considered a UoF in ISO 10303-203 Edition 1.</small></td>
  </tr>
</table>
<p>In a harmonized suite of application modules, two or more AMs shall not
contain equivalent UoFs or common information requirements. When two or more AMs
have equivalent UoFs or common information requirements, a new AM shall be
created, the same interpretation of the integrated resources shall be used in
the new AM, and the new AM shall be used by the AM's with common requirements
without changing the scope of the existing AM.
<h4>5.2.1 Information requirements documentation</h4>
<p>Clause 4 of the AM shall include a high level description of the information
requirements, a summary of the structure used to define the partition of the
information requirements defined by the AM, and subclauses for specifying UoFs,
referenced AMs and the AM ARM components. The description of the information
requirements shall be sufficient to prepare the reader for the material in the
subclauses.
<p>The information requirements shall be defined using EXPRESS annotated with
prose. The referenced AMs and the ARM components including application objects,
relationship attributes and constraints shall be defined as a single documented
EXPRESS schema. The elements listed within each subclause shall be ordered
alphabetically. In a harmonized suite of application modules, the UoFs, ARM
schema, ARM types, application objects, ARM rules and ARM functions shall have
unique names, i.e., no application elements shall share the same name across the
complete suite of AMs.
<p>The documentation for an AM's ARM and information requirements includes the
following components as required. The clause numbers mentioned in the text
assume at there is at least one of each possible construct included so that no
subclause is omitted. Should there be no ARM types, functions or rules these
clauses shall be omitted in the AM and the clause numbering shall change
accordingly.
<p>1. units of functionality
<p>This subclause provides a complete list of the UoFs defined in the AM and
defined in any other AM used directly or indirectly by the AM. This is the only
place in an application module where the full domain of the application module
and all of its prerequisite application modules is found. For UoFs defined in
the AM, a description of the functions that each UoF supports, and the list of
application objects included in the UoF is specified. For UoFs used from another
AM, the name of the AM in which the UoF is defined shall be included in the
list. Application objects defined in another AM specifically referenced by
application objects defined in the AM shall be listed under the description of
the UoF in the other AM in which they are defined.
<p>2. referenced application module ARMs
<p>The referenced application module ARMs takes the form of documented EXPRESS
USE FROM constructs. Each AM ARM shall be used in its entirety. Should the AM
not use any other AM this fact shall be stated in this subclause.
<p>3. ARM type definitions
<p>The ARM defined types specification takes the form of documented EXPRESS TYPE
definitions.
<p>4. ARM entity definitions
<p>The application objects are documented as ARM EXPRESS entities. Every EXPRESS
entity in the ARM shall be considered an application object. Each application
object which exists in the ARM shall appear in the mapping specification
although it may not be fully mapped.
<p>5. ARM rule definitions
<p>The ARM rules specify the necessary constraints on the application objects.
These constraints are documented in the ARM as EXPRESS RULE definitions.
<p>6. ARM function definitions
<p>The ARM functions specify the necessary functions used by the ARM rules and
ARM entity definitions. These functions are documented as EXPRESS FUNCTION
definitions.
<h4>5.2.2 EXPRESS ARM documentation</h4>
<p>The ARM EXPRESS definitions shall be specified as follows.
<ul>
  <li>The ARM schema name shall be the name of the AM appended with the suffix
    &quot;_arm&quot;.
  <li>The ARM type definitions shall appear in alphabetical order. Each type
    shall appear in its own subclause.
  <li>Each application object shall be stated in the ARM entity definitions and
    each ARM entity definition shall represent an application object. The ARM
    entity definitions shall appear in alphabetical order. Each application
    object shall appear in its own subclause.
  <li>The ARM rule definitions shall appear in alphabetical order. Each rule
    shall appear in its own subclause.
  <li>The ARM function definitions shall appear in alphabetical order. Each
    function shall appear in its own subclause.
</ul>
<h4>5.3 The module interpreted model</h4>
<p>The MIM documents the interpretation of the information requirements into the
common resources. The results of that interpretation are:
<ul>
  <li>a selection of the required application module MIMs to satisfy ARM
    requirements;
  <li>the selection of the required SC4 common standardized resource constructs
    to satisfy ARM requirements;
  <li>additional EXPRESS constructs and constraints needed to satisfy ARM
    requirements and to specify the MIM short listing, and;
  <li>the mapping of ARM constructs to the MIM schema constructs.
</ul>
<h4>5.3.1 Selected resource constructs</h4>
<p>The result of interpretation is the specification of one or several resource
constructs which satisfy the requirements of the ARM construct, along with any
needed constraints.
<p>The integrated resource constructs are designed for generic use by all AMs.
In the selection process, the best entity for an ARM requirement may have
attributes that are not supported by requirements in the ARM. In the cases where
the additional attributes have underlying types that are base types and there is
no data to support the instantiation of these attributes, the recommended values
for these attributes may be documented in the &quot;Module implementation and
usage guide&quot; annex of the application module.
<h4>5.3.2 MIM short form specification</h4>
<p>The MIM is constructed from the common resources, including AMs, through the
use of the EXPRESS USE FROM; this MIM schema is called the short form. The short
form consists of two parts. The first part contains the interface specification
that provides the relationship between the common resources and the MIM. The
second part defines the unique MIM constructs that refine or specialize the
usage of the integrated resources. The MIM schema name shall be the name of the
AM appended with the suffix &quot;_mim&quot;. The remainder of this subclause of
this standing document expands on the detailed use of EXPRESS in defining an MIM.
<p>The EXPRESS short listing specifies the selection of application module MIMs
and constructs from other common resources through a formal interface
specification method. This interface is accomplished through the EXPRESS USE
FROM specification described in clause 11 of ISO 10303-11. The required MIMs
from other AMs shall be used in their entirety.
<p>The MIM short listing also specifies all constructs that are new and unique
to the MIM, which may include entities, attributes, type definitions, local and
global rules, and functions. Only two classes of new constructs are allowed in
an MIM; those that:
<ul>
  <li>complete and assign a concept definition; and
  <li>constrain a generic concept.
</ul>
<h4>5.3.3 Concept completion and assignment</h4>
<p>In the ISO 10303 integrated resources, there are a number of template
structures that have been used to specify product data management resources,
such as the construct specified in annex E of ISO 10303-41. These template
structures are semantically incomplete by themselves; they are designed to be
used to specify structurally similar though semantically dissimilar concepts in
a standard and consistent manner. The template entity is completed by an
explicit and unique assignment of semantics in the MIM. The explicit assignments
are made between the management concepts (e.g., approval or organization) and
the items that require the management information. Details on how the new MIM
constructs which complete the assignment template structure are documented in
the MIM short listing follow.
<p>Subtypes of interfaced entities may be created for the completion and
assignment of generic concepts. The assignment of a generic concept is the only
time that an explicit attribute may be added to a subtype declared in an MIM
schema. In order to assign the generic constructs to the appropriate entities as
defined in the ARM requirements, two constructs are created. The first construct
is a SELECT type. That SELECT type may contain all of those entities or other
SELECT types that may have the concept assigned to it. That SELECT type may also
be an extensible SELECT type. In this case, using AMs extend the SELECT type
domain to complete the entities or SELECT types that may have the concept
assigned to it. The second construct is an entity which is a subtype of the
entity in the ISO 10303 integrated resources representing the generic concept.
This entity shall contain a single attribute which references a SET of the
SELECT type that was defined previously. A SET is used here so that all concepts
that are the same are able to be assigned to different instances of entities
that share the information. The subtypes shall be the string
&quot;applied_&quot; with the name of the entity type from ISO 10303-41
appended, the attribute shall be named &quot;items&quot; and the SELECT type
shall be named based on the entity name from ISO 10303-41. See <a href="#b4">B.4
</a>for an example.
<p>A mapping specification supporting the concept completion and assignment
constructs defined in the AM shall be included in this clause of the AM.
<h4>5.3.4 Constrained generic concepts</h4>
<p>Standardized common resource constructs are generic in nature and designed to
be shared by multiple application contexts. Several AMs may require the same
generic concept that a resource construct represents, but each may constrain the
generic concepts in order to represent a specific usage within the AM domain.
New MIM constructs may be created (through subtyping) to:
<ul>
  <li>constrain a generic concept;
  <li>constrain the relationship between generic concepts; or
  <li>create multiple, specialized concepts of the generic concept, through
    specification of different constraints representing different usages of the
    same generic concept under specific circumstances within the domain of the
    AM.
</ul>
<p>Global rules and functions and subtype constraints are allowed in an MIM to
constrain generic concepts. In the case that a constraint in the MIM is the
result of a constraint in the ARM that constrains concepts defined in a used AM,
the documentation of the MIM constraint shall reference the ARM constraint upon
which it is based.
<p>Global rules are frequently written to constrain an entity from being
independently instantiated.When an application requirement results in a
constraint on every use of an interfaced entity or attribute of an interfaced
entity, a global rule is specified. Global rules are also used to specify
constraints on the relationships among two or more entities. Constraints may be
specified as global rules to serve four specific functions and as subtype
constraints to serve one function. These functions are described in the
following subclauses.
<h4>5.3.4.1 Global rules as supertype constraints and using subtype constraints</h4>
<p>A supertype constraint is one that constrains the relationships among
interfaced entities in the same subtype/supertype tree. These constraints are in
addition to any constraints applied through the specification of the interface
statements (i.e., dependence). There are many uses for this type of constraint;
only two uses are described here.
<p>A supertype constraint, for example, may make the instantiation of a subtype
mandatory for a particular supertype entity. The requirement for a rule of this
type will arise when an entity is 1) explicitly interfaced to be subtyped, or 2)
is implicitly interfaced via attribute reference as well as subtype reference.
If the ARM requirement is only for the new subtype entity, then a rule is
required to prohibit the instantiation of the interfaced supertype entity.
<p>Rules for constraining supertype relationships may also be used to limit the
combinations of subtypes of a single supertype entity in order to define the
appropriate set of complex entity data types allowed satisfy the requirements
specified in the ARM.
<p>In the cases where any constraint may be written using an EXPRESS subtype
constraint instead of a global rule, a subtype constraint may be specified for
that purpose.
<h4>5.3.4.2 Cardinality constraint</h4>
<p>A cardinality constraint is one that constrains the relationship between two
interfaced entities by limiting the number of instances of one entity type that
may be related to instances of the other. Explicit cardinality is specified in
the referential direction of the relationship (i.e., from the entity with the
attribute to the entity that is the data type of that attribute). When an
INVERSE attribute does not exist to constrain the cardinality of the referenced
entity, the cardinality defined is, by default, zero, one or many. These
cardinalities may be constrained using a cardinality constraint.
<p>The integrated resources, for example, always model the existence dependency
of one entity with respect to another by the referential direction of the
relationship. That is, the dependent entity always references the independent
entity so that an instance of the dependent entity requires the existence of an
instance of the independent entity. In the ARM, two entities might be
interdependent. That is, each entity requires a single instance of the other in
order to model a complete concept. In this case, a cardinality constraint would
be necessary to constrain the inverse cardinality to be exactly one rather than
the default zero, one or many.
<h4>5.3.4.3 Referential integrity constraint</h4>
<p>Global rules can be used to specify referential integrity constraints. This
type of constraint is one that constrains valid reference paths for all
instances of an interfaced entity. The paths that are constrained may be
combinatorial in nature. These combinatorial constraints are ones where a single
entity may be required to be instantiated through two or more distinct paths in
order to completely satisfy an ARM requirement. This type of constraint may also
constrain an attribute value that is reached via a single reference path for all
instances of a referencing entity.
<h4>5.3.4.4 Attribute domain constraint</h4>
<p>An attribute domain constraint is one which constrains the value of an
attribute in instances of a particular entity. This constraint is used to
constrain the values, for example, of an attribute of type STRING in an
interfaced entity to correspond to values of an enumeration as defined in ARM
requirements. In the design of the integrated resources, the use of enumerated
types was limited to preserve the generic nature of the integrated resources.
Instead of referencing enumerated types, integrated resource entity attributes
reference base types or defined types where the underlying type is a base type
(i.e., INTEGER, STRING etc.). When an application context as defined in an ARM
is used to determine requirements for specific structures, enumerations are
considered specific requirements. A domain constraint specifies the legal values
of the simple data types that correspond to the enumeration values and the
standard interpretation of those values for that application context.
<p>Another use of an attribute domain constraint is to place limits on the
values of attributes of an entity. For example, if an entity has an attribute
that is an INTEGER, and an ARM specifies a requirement that the INTEGER value
must be greater than 1, the domain constraint is specified on the entity that
contains that attribute to declare that constraint.
<h4>5.3.5 Use of functions</h4>
<p>In the specification of rules, EXPRESS functions may be used in order to make
the specification of the rule simpler. Due to the recursive nature of many of
the references in the common resources, a constraint may need to be defined
recursively. Additionally, many rules may need to use the iterative and logical
capabilities of the executable statements defined in EXPRESS in order to specify
complex constraints on the interactions among different entities. This type of
complex interaction will usually require that a function be defined in order to
support the specification of a constraint. In these cases, new functions may be
defined to be used by a rule. See B.7 for an example.
<h4>5.3.6 Completed short form schema</h4>
<p>Global rules may appear in the MIM to constrain an entity, relationship or
attribute.
<p>Constructs from the integrated resources are pruned in the MIM (see 5.1.2 of <i>Guidelines
for application interpreted model development</i>). There may be subtypes and
items of select lists that appear in the integrated resources that are not
imported into the AM. Constructs are eliminated from the subtype tree or select
list through the use of the implicit interface rules of ISO 10303-11. References
to eliminated constructs are outside the scope of the MIM.
<h4>5.3.7 EXPRESS usage guidelines for MIMs</h4>
<p>This clause describes the use of the EXPRESS language in an MIM EXPRESS short
listing, and provides additional details that describe the semantics of a
particular usage of EXPRESS.
<h4>5.3.7.1 Schema interface</h4>
<p>An MIM establishes a formal relationship to the integrated resources and
application modules by containing the EXPRESS USE FROM keyword. USE FROM is the
only interface mechanism that may be employed in an MIM.
<p>The USE FROM keyword interfaces named data types and entire schemas into
another schema. In an MIM EXPRESS short form, if the interface is to a construct
defined in the integrated resources, the desired construct is individually named
in the interface specification for the schema in which the construct is defined.
If all constructs from an integrated resource schema are desired, the entire
schema may be interfaced by providing only the schema name in the interface
specification. If the interface is to an AM, only the AM schema name is
provided. The AM must be used in its entirety; the use of subsets of an AM is
not allowed.
<h4>5.3.7.2 Entity type specialization</h4>
<p>The requirements for the declaration of unique MIM constructs during the
development of the MIM EXPRESS short listing is defined earlier in this standing
document. Entities are created in the MIM only to achieve one of three
objectives: constraint localization, attribute definition specialization, and
concept completion and assignment. Entities used from the Integrated Resources
and from the MIM schemas in other AMs may be subtyped as part of meeting one of
these three objectives. Concept completion and assignment also requires the
specification of a SELECT type. In the development of an MIM, this is the only
case where an MIM-specific defined type is specified.
<h4>5.3.7.2.1 Localization of constraints</h4>
<p>In an MIM, there may be requirements to specify constraints on an entity that
differ depending on its usage in different structures. This type of constraint
is called an <a href="#b5">entity behavioral constraint</a>. In order to specify
this type of constraint, the entity is interfaced explicitly into the MIM schema
from the integrated resources or included via a USEd AM. There are two methods
for representing the constraint:
<ul>
  <li>a global rule is defined to constrain attribute values representing the
    required constraint from the ARM; or
  <li>a new subtype of the entity is be created to represent the concept for
    which the constraints are defined.
</ul>
<p>Using global rules is the preferred method to consider to represent these
constraints. Global rules that, when pulled into a larger context, may apply to
a broader scope than originally intended are discouraged. Subtyping should be
employed when the complete set of subtypes for all possible domains can be
determined.
<p>In addition to constraints on the usage of a particular entity, there may be
a need to specify differing, and often conflicting, constraints on an entity or
an entity's attributes depending on its usage in the reference path of a generic
entity interfaced to the MIM. In this case, subtypes of the referencing entity
shall be created in order to establish a context for the constraint and to
specify the constraint on the referenced entity. This type of constraint is
called a <a href="#b6">referential integrity constraint</a>.
<h4>5.3.7.2.2 Specialization of attribute definitions</h4>
<p>The creation of subtypes of the interfaced entities from the integrated
resources or AMs enables more specific attribute definitions to be given when
the generic definition is not sufficient to satisfy the ARM requirements. This
situation most often occurs when there is an ARM requirement for relationships
defined between two entities that play specific roles within those
relationships. There are two practices which may be used in this case, depending
on the application requirements.
<p>The first practice concerns attribute naming. If there is a requirement that
an attribute have a specific name based on the ARM, then a subtype entity is
created in the MIM and a derived attribute is specified which names the
attribute inherited from the supertype entity. Derived attributes may be used,
for example, to specialize the generic product_definition_relationship entity
when an application requirement states that the relationship is prioritized: one
product_definition is first priority and the other is second priority. The
attributes names first_priority and second_priority have a very specific
application meaning and the development team has defined those roles
specifically within the ARM requirements. The MIM would then contain an entity
such as:
<p><code>*)</code>
<p><code>ENTITY priority_product_definition_relationship;</code><br>
<code>SUBTYPE OF (product_definition_relationship);</code><br>
<code>DERIVE</code><br>
<code>first_priority : product_definition :=</code><br>
<code>SELF\product_definition_relationship.relating_product_definition;</code><br>
<code>second_priority : product_definition :=</code><br>
<code>SELF\product_definition_relationship.related_product_definition;</code><br>
<code>END_ENTITY;</code>
<p><code>(*</code>
<p>The second practice is used if there is no application requirement for a
specific attribute name. If the definition of an inherited attribute must be
specialized in the MIM and there is no application requirement for an attribute
name to be given, a subtype may be created and additional textual definitions
are created in the MIM for inherited attributes. This entity would then be used
to represent the semantics given in the textual definitions of the inherited
attributes.
<p>An example of this second practice may be found in ISO 10303-203. The entity
supplied_part_relationship is declared as a subtype of the generic
product_definition_relationship entity. Since there are no application
requirements for specific attribute names, the definitions are refined to say
that the related_product_definition is to be interpreted as that
product_definition that is supplied by an outside organization and the
relating_product_definition is the product_definition that is internal to the
owning organization.
<h4>5.3.8 Documenting new MIM constructs</h4>
<p>The AM document must include complete definitions of all new MIM constructs
found in the MIM EXPRESS short listing. It may also include textual definitions
and descriptions from the interfaced resource constructs that have been further
specialized to suit the established application context of the AM. Guidance for
developing and formatting these definitions is found in <i>Supplementary
directives for the drafting and presentation of ISO 10303</i>.
<h4>5.4 Mapping specification</h4>
<p>The mapping specification is a pivotal component of an AM. The mapping
specification specifies the relationship between the information requirements as
specified in the ARM and the resource constructs that satisfy those requirements
in the module interpreted model. Unless otherwise specified in this standing
document, the mapping specification for an AM shall follow the <i>Guidelines for
the development of mapping specifications, 2nd edition</i>.
<p>Exceptions to the mapping specification guidelines include the following.
<ul>
  <li>In all cases where the guideline uses or specifies the term application
    interpreted model or AIM, that term is to be replaced by module interpreted
    model or MIM.
  <li>As AM ARMs are written using EXPRESS, the concept of application assertion
    is not applicable. These are specified in the EXPRESS structure rather than
    separately from the application object.
  <li>In all cases where options are allowed to be specified in the mapping
    specification that may be numbered, they shall be numbered. This allows
    options to be referenced by number in using application modules.
  <li>An application module may be the source of an element in the mapping
    specification.
</ul>
<p>Several concepts are available to enable generic and abstract concepts to be
defined in one AM but completed in a using AM.
<ul>
  <li>Incomplete or uninstantiable ARM concepts shall appear in the mapping
    specification but need not be fully mapped in the mapping specification. In
    the case that the concept is an abstract supertype in the ARM with the
    intent that using AMs will define subtypes, text may be specified stating
    that the mapping appears in using AMs.
  <li>All concepts that appear in the mapping specification need not appear in
    the MIM. This enables the constraint on a mapping to be specified in one AM
    while allowing the MIM object into which something is mapped to appear in
    the MIM of a using AM.
  <li>The mapping specification in a using AM may eliminate one or more of the
    options found in a supertype declared in a required AM. This is specified in
    text referencing the mapping in the used AM and stating the number of the
    mapping that is eliminated. An example may be added that is the referenced
    mapping specification repeated in the AM with the eliminated option omitted.
</ul>
<h4>5.5 Short names table</h4>
<p>Short names are required for each entity in the MIM EXPRESS short form
schema. An explanation of short names is found in <i>Guidelines for the
development and approval of STEP application protocols</i>.
<p>&nbsp;
<p>&nbsp;
<hr>
<p>&nbsp;
<h3>&nbsp;</h3>
<p align="Center"><a name="annexa"><!-- --></a>Annex A<br>
<br>
Conformance testing concepts for application modules
<p align="Left">&nbsp;
<p align="Left">The application concepts defined in application modules are of
varying levels of detail, scope, semantic completeness and applicability to
specific contexts. For these reasons not all application modules have the same
requirements on conformance testing. The following guidelines and principles
shall be used to determine the required testing related developments for
application modules.<br>
<ul>
  <li>all application modules shall have associated ISO 10303-21 files covering
    every application object defined in the application module which maps to a
    construct in the MIM;
  <li>application modules that are the data specification for an application
    protocol shall fall under the same requirements for providing conformance
    testing supporting documents as a non-modularized AP.
</ul>
<p>&nbsp;
<p>&nbsp;
<h3>&nbsp;</h3>
<p align="Center"><a name="annexb">Annex B</a><br>
<br>
Examples
<p>&nbsp;
<p>This annex contains examples of a UoF, application objects, and relationship
attributes that appear in the example mapping specification.
<h3>B.1 Example UoF, application objects, and relationship attributes that
appear in the example mapping specification</h3>
<h3>4.1 Units of Functionality</h3>
<p>Product_identification specifies things organizations have identified for
some purpose. This UoF consists of the following application objects:
<ul>
  <li>product;
  <li>product_category;
  <li>organization.
</ul>
<h3>4.2 ARM entity definitions</h3>
<p><font face="Courier">(*</font>
<h3>4.2.1 product application object</h3>
<p>A <b>product</b> is something an <b>organization</b> has identified for some
purpose.
<p>Products are uniquely identified by product.id, organization.id and one or
more product_category.name.
<p>The mechanism for guaranteeing the uniqueness of organization id is outside
the scope of ISO 10303.
<p>The same organization that assigns the product id also categorizes the
product in the context of uniquely identifying the product.
<p>EXPRESS Specification
<p>&nbsp;
<hr>
<font face="Courier">*)<br>
<font size="-1"><a name="product"></a>ENTITY product;<br>
id : label;<br>
name : text;<br>
categories : SET[1:?] <a href="#product_category">product_category;</a><br>
id_assigning_organization : <a href="#organization">organization;</a><br>
WHERE<br>
wr1: id_assigning_organization :=: categories[1].name_assigning_organization;<br>
END_ENTITY;<br>
</font>(*</font>
<hr>
<b>id </b>: the identification of the product assigned by the organization<br>
<b>name</b> : words by which the product is known.<br>
<b>categories</b> : the categories by which the product is classified or which
specify the type of the product<br>
<b>id_assigning_organization</b> : the organization that assigned the product
its id<br>
<font face="Courier">*)</font>
<p><font face="Courier">(*</font>
<h3>4.2.2 product_category application object</h3>
<p>A product_category is a possible classification for products by an
organization.
<p>A product_category is uniquely identified by its name within the
organization.
<p>The same organization that assigns the product.id also categorizes the
product in the context of uniquely identifying a product.
<p>EXPRESS Specification
<p>&nbsp;
<hr>
<font face="Courier">*)<br>
<font size="-1"><a name="product_category"></a>ENTITY product_category;<br>
name : label;<br>
name_assigning_organization : <a href="#organization">organization;</a><br>
END_ENTITY;<br>
</font>(*</font>
<hr>
<b>name</b> : the identification of the product_category assigned by the
organization<br>
<b>name_assigning_organization</b> : the organization that assigned the
product_category its name<br>
<font face="Courier">*)</font>
<p><font face="Courier">(*</font>
<h3>4.2.3 organization application object</h3>
<p>An <b>organization</b> is a group of people involved in a particular business
process. An organization is not an ad hoc organization, such as project teams,
meetings or informal groups.
<p>The mechanism for guaranteeing the uniqueness of organization id is outside
the scope of ISO 10303.
<p>EXPRESS Specification
<p>&nbsp;
<hr>
<font face="Courier">*)<br>
<font size="-1"><a name="organization"></a>ENTITY organization;<br>
id : label;<br>
name : text;<br>
address : OPTIONAL text;<br>
UNIQUE<br>
organizations_are_unique : id;<br>
END_ENTITY;<br>
</font>(*</font>
<hr>
<b>id</b> : the unique identification of the organization<br>
<b>name</b> : the name of the organization<br>
<b>address</b> : the optional address of the organization which may be used to
indicate an item delivery address, a postal address, or a physical location
visitor address.<br>
<font face="Courier">*)</font>
<h3><a href="amexmt.html">B.2 Example mapping specifications</a></h3>
<h3><a name="b3">B.3</a> Example scope refinement</h3>
<p>There is a requirement for an AP team to be able to use a portion of an
existing AM whose scope is too large. The concept of “scope refinement” is
intended to address this requirement. The process is defined as:
<ul>
  <li>Break the existing AM into two or more smaller AMs;
  <li>Exactly the same scope for the combination of the smaller AMs as for the
    existing AM;
  <li>No change to the Application objects or mappings allowed;
  <li>Need to allow APs using the existing AM to be unaffected.
</ul>
<p>The following application objects define the concept of a <b>product </b>and
a <b>product_version</b> in a single <b>product_id </b>AM. The <b>pdm_ap</b>
then uses this <b>product_id</b> AM in its entirety.
<p><code>*)</code>
<p><code>SCHEMA product_id_arm;</code>
<p><code>ENTITY product;<br>
id : label;<br>
END_ENTITY;</code>
<p><code>ENTITY product_version;<br>
of_product : product;<br>
END_ENTITY;</code>
<p><code>END_SCHEMA;</code>
<p>&nbsp;
<hr>
<code>SCHEMA pdm_ap_arm;</code>
<p><code>USE FROM product_id_arm;</code>
<p><code>END_SCHEMA;</code>
<p><code>(*</code>
<p>After the <b>product_id </b>AM and the <b>pdm_ap</b> AP have been developed,
the <b>process_plant</b> AP begins development and has the requirement for a
product without an associated <b>product_version</b>. Thus, the <b>process_plant
</b>AP team needs to refine the scope of the <b>product_id </b>AM creating the <b>product_only</b>
and <b>product_version </b>AMs.
<p><code>*)</code>
<p><code>SCHEMA product_only_arm;</code>
<p><code>ENTITY product;</code><br>
<code>id : label;</code><br>
<code>END_ENTITY;</code>
<p><code>END_SCHEMA;</code>
<p>&nbsp;
<hr>
<code>SCHEMA product_version_arm;</code>
<p><code>USE FROM product_only_arm;</code>
<p><code>ENTITY product_version;</code><br>
<code>of_product : product;</code><br>
<code>END_ENTITY;</code>
<p><code>END_SCHEMA;</code>
<p>&nbsp;
<hr>
<code>SCHEMA plant_ap_arm;</code>
<p><code>USE FROM product_only_arm;</code>
<p><code>END_SCHEMA;</code>
<p>(*
<p>Finally, the <b>product_id </b>AM needs to be revised to use these two new
AMs. The <b>pdm_ap</b> need not be revised as the scope refinement maintains the
original scope of the <b>product_id</b> AM.
<p>*)
<p><code>SCHEMA product_id_arm;</code>
<p><code>USE FROM product_only_arm;</code>
<p><code>USE FROM product_version_arm;</code>
<p><code>END_SCHEMA;</code>
<p>&nbsp;
<h3><a name="b4">B.4 </a>Example management resource completion</h3>
<p>The following example illustrates the use of the concept completion and
assignment technique in an AIM. The items attribute of the new SUBTYPE <b>applied_date_assignment</b>
that references the new SELECT type <b>date_assigned_items</b> illustrates the
only case where it is allowable to add an attribute in a subtype.<br>
<br>
*)
<p>SCHEMA resource_example_schema;
<p><code>REFERENCE FROM date_schema (date, date_role);</code>
<p><code>ENTITY date_assignment;</code><br>
<code>ABSTRACT SUPERTYPE;</code><br>
<code>role : date_role;</code><br>
<code>assigned_date : date;</code><br>
<code>END_ENTITY</code>
<p><code>END_SCHEMA; -- resource_example_schema</code>
<p><code>SCHEMA concept_completion_example_schema;</code>
<p><code>USE FROM partial_product_definition_schema</code><br>
<code>(product,</code><br>
<code>product_definition_formation);</code>
<p><code>USE FROM resource_example_schema (date_assignment);</code>
<p><code>TYPE date_assigned_items = SELECT -- SELECT type definition</code><br>
<code>(product,</code><br>
<code>product_definition_formation);</code><br>
<code>END_TYPE;</code>
<p><code>ENTITY applied_date_assignment; -- ENTITY subtype definition</code><br>
<code>SUBTYPE OF (date_assignment);</code><br>
<code>items : SET [1:?] OF date_assigned_items;</code><br>
<code>END_ENTITY;</code>
<p><code>END_SCHEMA; -- concept_completion_example_schema</code>
<p><code>(*</code>
<p>The new subtype entity declaration may also be combined with the localization
of constraints practice which would enable the specification of either
behavioral or referential integrity constraints in the WHERE clause of the
entity. An example of this is provided in the following example schema; date
assignments are coordinated with the value of the role attribute. The function
date_time_correlation says, for example, that a date with the role of
&quot;creation date&quot; must be assigned to a product_definition entity.
Again, the addition of attributes in an newly defined subtype is allowed only
for the assignment template structures in the STEP integrated resources; these
ABSTRACT SUPERTYPE entities are incomplete by definition and must be completed
in the using schema.
<p><code>*)</code>
<p><code>SCHEMA role_correlation_example;</code>
<p><code>TYPE date_and_time_assigned_items = SELECT</code><br>
<code>(product_definition,</code><br>
<code>change_request,</code><br>
<code>start_request,</code><br>
<code>change,</code><br>
<code>start_work,</code><br>
<code>approval_person_organization,</code><br>
<code>contract,</code><br>
<code>security_classification,</code><br>
<code>certification);</code><br>
<code>END_TYPE; -- date_time_item</code>
<p><code>ENTITY applied_date_and_time_assignment</code><br>
<code>SUBTYPE OF (date_and_time_assignment);</code><br>
<code>items : SET [1:?] OF date_and_time_assigned_items;</code><br>
<code>WHERE</code><br>
<code>WR1: date_time_correlation(SELF);</code><br>
<code>END_ENTITY; -- applied_date_and_time_assignment</code>
<p><code>ENTITY date_and_time;</code><br>
<code>date_component : date;</code><br>
<code>time_component : local_time;</code><br>
<code>END_ENTITY; -- date_and_time</code>
<p><code>ENTITY date_and_time_assignment</code><br>
<code>ABSTRACT SUPERTYPE;</code><br>
<code>assigned_date_and_time : date_and_time;</code><br>
<code>role : date_time_role;</code><br>
<code>END_ENTITY; -- date_and_time_assignment</code>
<p><code>ENTITY date_time_role;</code><br>
<code>name : label;</code><br>
<code>END_ENTITY; -- date_time_role</code>
<p><code>FUNCTION date_time_correlation</code><br>
<code>(e : applied_date_and_time_assignment ) : BOOLEAN;</code>
<p><code>LOCAL</code><br>
<code>dt_role : STRING;</code><br>
<code>END_LOCAL;</code>
<p><code>dt_role := e\applied_date_and_time_assignment.role.name;</code>
<p><code>CASE dt_role OF</code>
<p><code>'creation_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
&nbsp;&nbsp;<code> SIZEOF (QUERY (x &lt;* e.items |'ROLE_CORRELATION_EXAMPLE.'&nbsp;&nbsp;
+</code> <code>'PRODUCT_DEFINITION'</code> <code>IN TYPEOF (x)))</code>
<p><code>&nbsp; THEN RETURN(FALSE);</code>
<p><code>&nbsp; END_IF;</code>
<p><code>'request_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>SIZEOF (</code><br>
<code>['ROLE_CORRELATION_EXAMPLE.CHANGE_REQUEST' +</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.START_REQUEST'] *</code><br>
<code>TYPEOF (x)) = 1))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'release_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>SIZEOF (</code><br>
<code>['ROLE_CORRELATION_EXAMPLE.CHANGE' +</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.START_WORK'] *</code><br>
<code>TYPEOF (x)) = 1))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'start_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>SIZEOF (</code><br>
<code>['CONFIG_CONTROL_DESIGN.CHANGE' +</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.START_WORK'] *</code><br>
<code>TYPEOF (x)) = 1))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'sign_off_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.' +</code><br>
<code>'APPROVAL_PERSON_ORGANIZATION'</code><br>
<code>IN TYPEOF (x)))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'contract_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.CONTRACT'</code><br>
<code>IN TYPEOF (x)))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'certification_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.CERTIFICATION'</code><br>
<code>IN TYPEOF (x)))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'classification_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.' +</code><br>
<code>'SECURITY_CLASSIFICATION'</code>
<p><code>IN TYPEOF (x)))</code>
<p><code>THEN RETURN(FALSE);</code>
<p><code>END_IF;</code>
<p><code>'declassification_date' : IF SIZEOF (e.items) &lt;&gt;</code><br>
<code>SIZEOF (QUERY (x &lt;* e.items |</code><br>
<code>'ROLE_CORRELATION_EXAMPLE.' +</code><br>
<code>'SECURITY_CLASSIFICATION'</code><br>
<code>IN TYPEOF (x)))</code>
<p><code>THEN RETURN(FALSE);</code><br>
<code>END_IF;</code>
<p><code>OTHERWISE : RETURN(TRUE);</code><br>
<code>END_CASE;</code>
<p><code>RETURN (TRUE);</code><br>
<code>END_FUNCTION; -- date_time_correlation</code>
<p><code>END_SCHEMA; -- role_correlation_example</code>
<p><code>(*</code>
<h3><a name="b5">B.5</a> Entity behavioral constraints</h3>
<p>An example of the use of entity behavioral constraints consists of an
application requirement defined in an ARM for two different types of the
product_definition entity. One type of product_definition entity is always a
component in an assembly and another type of product_definition is never a
component in an assembly. This is a behavioral constraint on the
product_definition that could be implemented with two subtypes or with
constrained attribute values. In the case where subtypes are created, the first
subtype could contain a constraint that says it must always be used in the
product_definition_relationship entity as the related_product_definition. The
second subtype of product_definition could contain a constraint specifying that
it shall never be used in the product_definition_relationship entity. In the
case where attribute values are constrained, a global rule could be written
specifying that when the description attribute of product_definition has a value
of component, the product_definition must always be used in a product_definition
relationship as the related_product_definition.
<p>In the case that subtypes are created, entity behavioral constraints are
specified as local rules and the EXPRESS USEDIN function is employed to gain
access to the other entities that reference the particular entity which needs to
be constrained in the MIM. Each subtype definition allows the MIM schema to
specify different uses of the generic concept (as defined in the STEP integrated
resources) for different purposes (as defined in an ARM).
<h3><a name="b6">B.6 </a>Referential integrity constraints</h3>
<p>For example, referential integrity constraints would be used to support an
application requirement for two separate uses of the polyline entity defined in
ISO 10303-42. Let us assume for the case of this example, that the requirements
for the usage of the polyline are differentiated by the fact that there are two
different mathematical methods for describing the shape of something. One
representation requires polylines to contain exactly two points for the
representation of line segments. The other representation has a requirement for
polylines to contain more than two points and line segments defined by trimmed
curves with underlying lines as the basis curves. This example will use the
entities defined in ISO 10303-41, ISO 10303-42 and ISO 10303-43.
<p>Since the polyline is constrained differently based on its usage in the
particular method, if both methods are required in a single AP, the constraints
on use of the polyline entity must be localized. Constraint localization is
accomplished by defining an entity in the MIM schema that is a subtype of a
resource entity to define a scope for the constraints. To localize the
constraints in this example, two subtypes of the shape_representation entity
from ISO 10303-41 need to be created where the applicable constraints for the
polyline are specified in the two different representation subtypes. One of them
is to create a scope for the mathematical method in which polylines are defined
only by two points; and the other is to create a scope for the mathematical
method in which polylines are defined by more than two points. The entity
definition for the subtypes shall contain an explanation of the purpose of the
constraints. The polyline entity is referenced by an attribute of the
geometric_set entity, which is, in turn, referenced by the representation
structure from ISO 10303-43. The constraints on polyline will be specified as
referential integrity constraints on the representation_items (inherited by
shape_representation entity from the representation entity in ISO 10303-43) that
are of type &quot;polyline&quot; within the contents set of the geometric_set
that is in the set of items in the representation entity. In one
shape_representation subtype, the size of the set of points that define the
polyline is constrained to two elements, and in the other shape_representation
subtype the size of the set of points that define the polyline is constrained to
be more than two. Each MIM entity (the created subtypes of the
shape_representation entity), therefore, defines a context within which
conflicting constraints on the polyline may exist within the MIM schema.
<p>Referential integrity constraints are written as local rules that use the
EXPRESS TYPEOF function to identify the appropriate traversal through the
reference path in specifying the constraint on the subtype and gain access to
the attributes that ultimately need to be constrained. In the example, each
subtype allows different constraints to be placed on a single attribute of a
single entity depending on the reference path by which those attributes are
reached.
<h3>B.7 Complex iterating function</h3>
<p><code><small>FUNCTION assembly_shape_is_defined</small></code>
<p><code><small>(assy: next_assembly_usage_occurrence) : BOOLEAN;</small></code>
<p><code><small>LOCAL</small></code>
<p><code><small>sdr_set : SET OF shape_definition_representation := [];<br>
srr_set : SET OF shape_representation_relationship := [];</small></code><br>
<code><small>sdr1_set : SET OF shape_definition_representation := [];</small></code><br>
<code><small>pd_set : SET OF property_definition := [];</small></code><br>
<code><small>pdr_set : SET OF product_definition_relationship := [];</small></code><br>
<code><small>pds_set : SET OF product_definition_shape := [];</small></code><br>
<code><small>prop_set : SET OF property_definition := [];</small></code>
<p><code><small>END_LOCAL;</small></code>
<p><code><small>-- Gather all instances of shape_definition_representation where
the</small></code><br>
<code><small>-- component part has a representation defined for it.</small></code>
<p><code><small>pd_set := QUERY( x &lt;* bag_to_set(
USEDIN(assy.related_product_definition,<br>
'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION')) |</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION' IN TYPEOF(x));</small></code>
<p><code><small>pdr_set := QUERY( pdr &lt;*
bag_to_set(USEDIN(assy.related_product_definition,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP.' +</small></code><br>
<code><small>'RELATED_PRODUCT_DEFINITION')) |</small></code><br>
<code><small>SIZEOF( USEDIN( pdr,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION')) &gt; 0);</small></code>
<p><code><small>IF SIZEOF(pd_set) &gt; 0 THEN</small></code>
<p><code><small>REPEAT i:=1 TO HIINDEX(pd_set);</small></code>
<p><code><small>sdr_set := sdr_set + QUERY( pdr &lt;* USEDIN(pd_set[i],</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
|</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN</small></code><br>
<code><small>TYPEOF(pdr));</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>IF SIZEOF(pdr_set) &gt; 0 THEN</small></code>
<p><code><small>--first, get all the property_definitions</small></code><br>
<code><small>--that reference the elements of pdr_set</small></code>
<p><code><small>REPEAT i:=1 TO HIINDEX(pdr_set);</small></code>
<p><code><small>prop_set := prop_set + bag_to_set(USEDIN(pdr_set[i],</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'));</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>--now, get all the shape_definition_representations</small></code><br>
<code><small>-- that are reps of the properties found</small></code>
<p><code><small>IF SIZEOF (prop_set) &gt; 0 THEN</small></code>
<p><code><small>REPEAT i:=1 TO HIINDEX(prop_set);</small></code>
<p><code><small>sdr_set := sdr_set + QUERY( pdr &lt;* USEDIN(prop_set[i],</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.' +</small></code><br>
<code><small>'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN</small></code><br>
<code><small>TYPEOF(pdr));</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>-- If there is a representation defined for the component part</small></code>
<p><code><small>IF SIZEOF (sdr_set) &gt; 0 THEN</small></code>
<p><code><small>-- For each representation of the shape of the component part
gather all</small></code><br>
<code><small>-- instances of shape_representation_relationship where the</small></code><br>
<code><small>-- representation of component part is related to another
representation.</small></code>
<p><code><small>REPEAT i := 1 TO HIINDEX (sdr_set);</small></code>
<p><code><small>srr_set := QUERY (rr &lt;* bag_to_set (</small></code><br>
<code><small>USEDIN (sdr_set[i]\</small></code><br>
<code><small>property_definition_representation.used_representation,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2')) |</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.SHAPE_REPRESENTATION_RELATIONSHIP' IN</small></code><br>
<code><small>TYPEOF (rr));</small></code>
<p><code><small>-- If there is a shape_representation_relationship where the
component</small></code><br>
<code><small>-- part's shape_representation is related to another shape_-</small></code><br>
<code><small>-- representation.</small></code>
<p><code><small>IF SIZEOF (srr_set) &gt; 0 THEN</small></code>
<p><code><small>-- For each shape_representation_relationship in that set</small></code>
<p><code><small>REPEAT j := 1 TO HIINDEX (srr_set);</small></code>
<p><code><small>-- If the other shape_representation in the shape_representation_-</small></code><br>
<code><small>-- relationship is the shape_representation of the assembly</small></code><br>
<code><small>-- product_definition in at least one instance.</small></code>
<p><code><small>pd_set := bag_to_set(USEDIN(assy.relating_product_definition,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION'));</small></code>
<p><code><small>IF SIZEOF(pd_set) &gt; 0 THEN</small></code>
<p><code><small>REPEAT i:=1 TO HIINDEX(pd_set);</small></code>
<p><code><small>sdr1_set := sdr1_set + QUERY( pdr &lt;* USEDIN(pd_set[i],</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')
|</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN</small></code><br>
<code><small>TYPEOF(pdr));</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>IF SIZEOF (QUERY (pdr &lt;* bag_to_set (USEDIN</small></code><br>
<code><small>(srr_set[j]\representation_relationship.rep_1,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +</small></code><br>
<code><small>'USED_REPRESENTATION')) |</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN</small></code><br>
<code><small>TYPEOF (pdr)) * sdr1_set) &gt;= 1 THEN</small></code>
<p><code><small>-- If the shape_representation_relationship and the product_-</small></code><br>
<code><small>-- definition_relationship of each occurrence of the component</small></code><br>
<code><small>-- and assembly relationship is not given via the</small></code><br>
<code><small>-- context_dependent_shape_representation then return FALSE</small></code>
<p><code><small>pds_set := QUERY(x &lt;* bag_to_set( USEDIN(assy,</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PROPERTY_DEFINITION.DEFINITION')) |</small></code><br>
<code><small>'AUTOMOTIVE_DESIGN.PRODUCT_DEFINITION_SHAPE' IN</small></code><br>
<code><small>TYPEOF(x));</small></code>
<p><code><small>IF SIZEOF(pds_set) = 0 THEN</small></code>
<p><code><small>RETURN (FALSE);</small></code>
<p><code><small>END_IF;</small></code>
<p>&nbsp;
<p><code><small>REPEAT k:=1 TO HIINDEX(pds_set);</small></code>
<p><code><small>IF SIZEOF (QUERY (cdsr &lt;*</small></code><br>
<code><small>USEDIN (pds_set[k], 'AUTOMOTIVE_DESIGN.' +</small></code><br>
<code><small>'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +</small></code><br>
<code><small>'REPRESENTED_PRODUCT_RELATION') |</small></code><br>
<code><small>(cdsr.representation_relation :=: srr_set[j]) )) &gt; 0</small></code>
<p><code><small>THEN RETURN (FALSE);</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>END_REPEAT;</small></code>
<p><code><small>END_IF;</small></code>
<p><code><small>-- If the shape of the component is not specified or there are
no</small></code><br>
<code><small>-- violations then return TRUE</small></code>
<p><code><small>RETURN (TRUE);</small></code>
<p><code><small>END_FUNCTION; -- assembly_shape_is_defined</small></code>
<p>&nbsp;

</body>

</html>
