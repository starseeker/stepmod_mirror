# $Id: express_model.rnc,v 1.4 2004/10/05 20:41:35 joshualubell Exp $

# EXPRESS MODEL DECLARATION MODULE

# This set of declarations defines the EXPRESS-2 Model

# This file was developed by Eurostep and supplied to NIST under contract.
# Authors:
#    Rob Bodington
#    David Price
#    Nigel Shaw
#    Phil Spiby
# Reviewed by:
#    Josh Lubell

# underlying type

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

underlying = aggregate*, (typename | builtintype)
description.content = text
# Attributes for source control software like RCS or CVS

# The rcs attributes are keywords for RCS source control systems

# rcs.date      $Date: 2004/10/05 20:41:35 $

# rcs.revision  $Revision: 1.4 $

# reference is the source of the schema, e.g. ISO 10303-41
express =
   ## EXPRESS specification containing one or more EXPRESS schemas
  element express {
    express.attlist, description?, application?, schema+
  }

express.attlist &=
  ## EXPRESS language version
   [ a:defaultValue = "1" ]
  attribute language_version { "1" | "2" | "3" }?,
  ## date stamp, assumed to be generated using version control software
  attribute rcs.date { text },
  ## revision stamp, assumed to be generated using version control software
  attribute rcs.revision { text },
  attribute reference { text }?,
  ## file containing descriptive text documenting the EXPRESS objects
  attribute description.file { text }?

description =
  ## text documenting an EXPRESS object
  element description { description.attlist, description.content* }
description.attlist &= empty
application =
   ## software used to generate the EXPRESS schema
   element application { application.attlist, empty }
application.attlist &=
   ## application name
  attribute name { text }?,
   ## application developer
  attribute owner { text }?,
   ## application developer's website
  attribute url { text }?,
   ## application version number
  attribute version { text }?,
   ## name of file used as input to the application
  attribute source { text }
schema =
   ## EXPRESS schema
  element schema {
    schema.attlist,
    description?,
    interface*,
    constant*,
    (entity | function | procedure | rule | subtype.constraint | type)*,
    graphic.element?
  }
schema.attlist &=
   ## schema name
  attribute name { xsd:NMTOKEN },
   ## schema version
  attribute version { xsd:NMTOKEN }?
interface =
   ## interface specification
  element interface {
    interface.attlist, interfaced.item*, described.item*
  }
interface.attlist &=
   ## specifies whether USE FROM or REFERENCE FROM
  [ a:defaultValue = "use" ] attribute kind { "use" | "reference" }?,
   ## name of schema being interfaced
  attribute schema { xsd:NMTOKEN }
interfaced.item =
   ## object imported from another EXPRESS schema
  element interfaced.item { interfaced.item.attlist, empty }
interfaced.item.attlist &=
   ## name of object imported
attribute name { xsd:NMTOKEN },
   ## alias in this schema for the imported object
attribute alias { xsd:NMTOKEN }?
described.item =
   ## A description of any item in the interface. In other words the
## documentation of an imported construct.         
element described.item { described.item.attlist, description? }
described.item.attlist &=
   ## the name of the imported construct
  attribute item { xsd:NMTOKEN },
   ## only used if the imported construct is an entity in which case, item is
   ## the name of the entity and attribute is the name of the attribute
  attribute attribute { xsd:NMTOKEN }?,
   ## the kind of item being imported
  [ a:defaultValue = "ENTITY" ]
  attribute kind {
    "ENTITY"
    | "TYPE"
    | "ATTRIBUTE"
    | "FUNCTION"
    | "PROCEDURE"
    | "CONSTANT"
  }?
constant =
   ## constant declaration
  element constant { constant.attlist, description?, underlying }
constant.attlist &=
   ## constant name
  attribute name { xsd:NMTOKEN },
   ## constant expression
  attribute expression { text }
type =
   ## type declaration
  element type {
    type.attlist,
    description?,
    aggregate*,
    (typename | builtintype | enumeration | select),
    where*,
    graphic.element?
  }
type.attlist &= 
   ## type name
   attribute name { xsd:NMTOKEN }
typename = 
   ## reference to another type declaration
   element typename { typename.attlist, empty }
typename.attlist &= 
   ## name of the referenced type
   attribute name { xsd:NMTOKEN }
builtintype =
   ## EXPRESS built-in type
  element builtintype { builtintype.attlist, graphic.element? }
builtintype.attlist &=
   ## specifies which built-in type
  [ a:defaultValue = "STRING" ]
  attribute type {
    "BINARY"
    | "BOOLEAN"
    | "GENERIC"
    | "GENERICENTITY"
    | "INTEGER"
    | "LOGICAL"
    | "NUMBER"
    | "REAL"
    | "STRING"
  }?,
   ## expression specifying width of binary or string (ignored for other
## built-in types)
  attribute width { text }?,
   ## expression specifying whether the width is fixed (applies only to binary
## and string types)
  [ a:defaultValue = "NO" ] attribute fixed { "YES" | "NO" }?,
   ## expression specifying the number of significant digits for a real type
  attribute precision { text }?,
   ## type label
  attribute typelabel { xsd:NMTOKEN }?
aggregate = 
   ## aggregate type
   element aggregate { aggregate.attlist, empty }
aggregate.attlist &=
   ## the kind of aggregate
  [ a:defaultValue = "SET" ]
  attribute type { "AGGREGATE" | "ARRAY" | "BAG" | "LIST" | "SET" }?,
   ## whether the aggregate type is optional
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?,
   ## whether the aggregate type is unique
  [ a:defaultValue = "NO" ] attribute unique { "YES" | "NO" }?,
   ## lower bound
  attribute lower { text }?,
   ## upper bound
  attribute upper { text }?,
   ## type label
  attribute typelabel { xsd:NMTOKEN }?
select = 
   ## select type
   element select { select.attlist, graphic.element? }
select.attlist &=
   ## whether select type is extensible
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
   ## whether extensible select type is constrained to have only entity
## instances in its domain
  [ a:defaultValue = "NO" ] attribute genericentity { "YES" | "NO" }?,
   ## type which this select type extends
  attribute basedon { xsd:NMTOKEN }?,
   ## select list
  attribute selectitems { xsd:NMTOKENS }?
graphic.element =
   ## reference to EXPRESS-G representation of an EXPRESS item
  element graphic.element { graphic.element.attlist, empty }
graphic.element.attlist &=
  attribute image { text }?,
   ## the graphic's page number
  attribute page { text },
   ## x-coordinate of the graphic's position on the page
  attribute xcoord { text }?,
   ## y-coordinate of the graphic's position on the page
  attribute ycoord { text }?
enumeration =
   ## EXPRESS enumeration type
  element enumeration { enumeration.attlist, graphic.element? }
enumeration.attlist &=
   ## whether the enumeration is extensible
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
   ## type which this enumeration extends
  attribute basedon { xsd:NMTOKEN }?,
   ## enumeration choices
  attribute items { xsd:NMTOKENS }?
entity =
   ## EXPRESS entity type
  element entity {
    entity.attlist,
    description?,
    explicit*,
    derived*,
    inverse*,
    unique*,
    where*,
    graphic.element?
  }
entity.attlist &=
   ## name of the entity type
  attribute name { xsd:NMTOKEN },
   ## whether the entity type is abstract (instantiable)
  [ a:defaultValue = "NO" ] attribute abstract.entity { "YES" | "NO" }?,
   ## whether the entity is an abstract supertype
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
   ## supertypes of this entity
  attribute supertypes { xsd:NMTOKENS }?,
   ## supertype expression
  attribute super.expression { text }?
explicit =
   ## explicit EXPRESS attribute
  element explicit {
    explicit.attlist, description?, underlying, redeclaration?
  }
explicit.attlist &=
   ## EXPRESS attribute name
  attribute name { xsd:NMTOKEN },
   ## specifies whether optional
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?
derived =
   ## derived EXPRESS attribute
  element derived {
    derived.attlist, description?, underlying, redeclaration?
  }
derived.attlist &=
   ## EXPRESS attribute name
  attribute name { xsd:NMTOKEN },
   ## expression for computing the EXPRESS attribute's value
  attribute expression { text }
inverse =
   ## EXPRESS inverse attribute
  element inverse {
    inverse.attlist, description?, inverse.aggregate?, redeclaration?
  }
inverse.attlist &=
   ## EXPRESS attribute name
  attribute name { xsd:NMTOKEN },
   ## name of entity to which inverted EXPRESS attribute belongs
  attribute entity { xsd:NMTOKEN },
   ## inverted EXPRESS attribute name
  attribute attribute { xsd:NMTOKEN }
inverse.aggregate =
   ## aggregate as part of an inverse EXPRESS attribute
  element inverse.aggregate { inverse.aggregate.attlist, empty }
inverse.aggregate.attlist &=
   ## kind of aggregate
  [ a:defaultValue = "SET" ] attribute type { "BAG" | "SET" }?,
   ## lower bound
  attribute lower { text }?,
   ## upper bound
  attribute upper { text }?
redeclaration = 
   ## redeclared EXPRESS attribute
   element redeclaration { redeclaration.attlist, empty }
redeclaration.attlist &=
   ## entity containing the old EXPRESS attribute
  attribute entity-ref { xsd:NMTOKEN },
   ## old EXPRESS attribute name
  attribute old_name { xsd:NMTOKEN }?
where = 
   ## domain rule
   element where { where.attlist, description? }
where.attlist &=
   ## domain rule label
  attribute label { xsd:NMTOKEN }?,
   ## domain rule expression
  attribute expression { text }?
# <!ELEMENT unique (description?, unique.attribute)>
unique =
   ## uniqueness rule
  element unique { unique.attlist, description?, unique.attribute+ }
unique.attlist &= 
   ## uniqueness rule label
   attribute label { xsd:NMTOKEN }?
unique.attribute =
   ## EXPRESS attribute in a uniqueness rule
  element unique.attribute { unique.attribute.attlist, empty }
unique.attribute.attlist &=
   ## name of entity
  attribute entity-ref { xsd:NMTOKEN }?,
   ## name of EXPRESS attribute
  attribute attribute { xsd:NMTOKEN }
subtype.constraint =
   ## subtype constraint
  element subtype.constraint {
    subtype.constraint.attlist, description?, graphic.element?
  }
subtype.constraint.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute totalover { xsd:NMTOKENS }?,
  attribute super.expression { text }?
function =
   ## EXPRESS function
  element function {
    function.attlist, description?, parameter*, underlying, algorithm
  }
function.attlist &= 
   ## function name
   attribute name { xsd:NMTOKEN }
parameter =
   ## argument to a function or procedure
  element parameter { parameter.attlist, description?, underlying }
parameter.attlist &= 
   ## name of argument
   attribute name { xsd:NMTOKEN }
procedure =
   ## EXPRESS procedure
  element procedure {
    procedure.attlist, description?, parameter*, algorithm?
  }
procedure.attlist &= 
   ## procedure name
   attribute name { xsd:NMTOKEN }
rule = 
   ## WHERE rule
   element rule { rule.attlist, description?, algorithm?, where+ }
rule.attlist &=
   ## rule name
  attribute name { xsd:NMTOKEN },
   ## names of entities to which rule applies
  attribute appliesto { xsd:NMTOKENS }
algorithm = 
   ## EXPRESS algorithm
   element algorithm { algorithm.attlist, text }
algorithm.attlist &= empty
start = express
