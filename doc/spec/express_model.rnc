# $Id: express_model.rnc,v 1.2 2004/09/21 18:41:09 joshualubell Exp $

# EXPRESS MODEL DECLARATION MODULE

# This set of declarations defines the EXPRESS-2 Model

# This file was developed by Eurostep and supplied to NIST under contract.
# Authors:
#    Rob Bodington
#    David Price
#    Nigel Shaw
#    Phil Spiby
# Reviewed by:
#    Josh Lubell

# underlying type

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

underlying = aggregate*, (typename | builtintype)
description.content = text
# Attributes for source control software like RCS or CVS

# The rcs attributes are keywords for RCS source control systems

# rcs.date      $Date: 2004/09/21 18:41:09 $

# rcs.revision  $Revision: 1.2 $

# reference is the source of the schema, e.g. ISO 10303-41
express =
  element express {
    express.attlist, description?, application?, schema+
  }

## attributes specifying metadata for the EXPRESS schema
express.attlist &=
  ## EXPRESS language version
   [ a:defaultValue = "1" ]
  attribute language_version { "1" | "2" | "3" }?,
  ## date stamp, assumed to be generated using version control software
  attribute rcs.date { text },
  ## revision stamp, assumed to be generated using version control software
  attribute rcs.revision { text },
  attribute reference { text }?,
  ## file containing descriptive text documenting the EXPRESS objects
  attribute description.file { text }?

description =
  ## text documenting an EXPRESS object
  element description { description.attlist, description.content* }
description.attlist &= empty
application =
   ## software used to generate the EXPRESS schema
   element application { application.attlist, empty }
application.attlist &=
   ## application name
  attribute name { text }?,
   ## application developer
  attribute owner { text }?,
   ## application developer's website
  attribute url { text }?,
   ## application version number
  attribute version { text }?,
   ## name of file used as input to the application
  attribute source { text }
schema =
   ## EXPRESS schema
  element schema {
    schema.attlist,
    description?,
    interface*,
    constant*,
    (entity | function | procedure | rule | subtype.constraint | type)*,
    graphic.element?
  }
schema.attlist &=
   ## schema name
  attribute name { xsd:NMTOKEN },
   ## schema version
  attribute version { xsd:NMTOKEN }?
interface =
   ## interface specification
  element interface {
    interface.attlist, interfaced.item*, described.item*
  }
interface.attlist &=
   ## specifies whether USE FROM or REFERENCE FROM
  [ a:defaultValue = "use" ] attribute kind { "use" | "reference" }?,
   ## name of schema being interfaced
  attribute schema { xsd:NMTOKEN }
interfaced.item =
  element interfaced.item { interfaced.item.attlist, empty }
interfaced.item.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute alias { xsd:NMTOKEN }?
# A description of any item in the interface. In other words the
# documentation of an imported construct.         
# item is the name of the imported construct
# attribute is only used if the imported construct is an entity in whihc
# case, item is the name of the entty and item is the name of the attribute
described.item =
  element described.item { described.item.attlist, description? }
described.item.attlist &=
  attribute item { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }?,
  [ a:defaultValue = "ENTITY" ]
  attribute kind {
    "ENTITY"
    | "TYPE"
    | "ATTRIBUTE"
    | "FUNCTION"
    | "PROCEDURE"
    | "CONSTANT"
  }?
constant =
  element constant { constant.attlist, description?, underlying }
constant.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
type =
  element type {
    type.attlist,
    description?,
    aggregate*,
    (typename | builtintype | enumeration | select),
    where*,
    graphic.element?
  }
type.attlist &= attribute name { xsd:NMTOKEN }
typename = element typename { typename.attlist, empty }
typename.attlist &= attribute name { xsd:NMTOKEN }
builtintype =
  element builtintype { builtintype.attlist, graphic.element? }
builtintype.attlist &=
  [ a:defaultValue = "STRING" ]
  attribute type {
    "BINARY"
    | "BOOLEAN"
    | "GENERIC"
    | "GENERICENTITY"
    | "INTEGER"
    | "LOGICAL"
    | "NUMBER"
    | "REAL"
    | "STRING"
  }?,
  attribute width { text }?,
  [ a:defaultValue = "NO" ] attribute fixed { "YES" | "NO" }?,
  attribute precision { text }?,
  attribute typelabel { xsd:NMTOKEN }?
# Width to allow for Binary and string

# Fixed to allow for Binary and string

# Precision to allow for REAL
aggregate = element aggregate { aggregate.attlist, empty }
aggregate.attlist &=
  [ a:defaultValue = "SET" ]
  attribute type { "AGGREGATE" | "ARRAY" | "BAG" | "LIST" | "SET" }?,
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute unique { "YES" | "NO" }?,
  attribute lower { text }?,
  attribute upper { text }?,
  attribute typelabel { xsd:NMTOKEN }?
select = element select { select.attlist, graphic.element? }
select.attlist &=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute genericentity { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute selectitems { xsd:NMTOKENS }?
graphic.element =
  element graphic.element { graphic.element.attlist, empty }
graphic.element.attlist &=
  attribute image { text }?,
  attribute page { text },
  attribute xcoord { text }?,
  attribute ycoord { text }?
enumeration =
  element enumeration { enumeration.attlist, graphic.element? }
enumeration.attlist &=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute items { xsd:NMTOKENS }?
entity =
  element entity {
    entity.attlist,
    description?,
    explicit*,
    derived*,
    inverse*,
    unique*,
    where*,
    graphic.element?
  }
entity.attlist &=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute abstract.entity { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute supertypes { xsd:NMTOKENS }?,
  attribute super.expression { text }?
explicit =
  element explicit {
    explicit.attlist, description?, underlying, redeclaration?
  }
explicit.attlist &=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?
derived =
  element derived {
    derived.attlist, description?, underlying, redeclaration?
  }
derived.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
inverse =
  element inverse {
    inverse.attlist, description?, inverse.aggregate?, redeclaration?
  }
inverse.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }
inverse.aggregate =
  element inverse.aggregate { inverse.aggregate.attlist, empty }
inverse.aggregate.attlist &=
  [ a:defaultValue = "SET" ] attribute type { "BAG" | "SET" }?,
  attribute lower { text }?,
  attribute upper { text }?
redeclaration = element redeclaration { redeclaration.attlist, empty }
redeclaration.attlist &=
  attribute entity-ref { xsd:NMTOKEN },
  attribute old_name { xsd:NMTOKEN }?
where = element where { where.attlist, description? }
where.attlist &=
  attribute label { xsd:NMTOKEN }?,
  attribute expression { text }?
# <!ELEMENT unique (description?, unique.attribute)>
unique =
  element unique { unique.attlist, description?, unique.attribute+ }
unique.attlist &= attribute label { xsd:NMTOKEN }?
unique.attribute =
  element unique.attribute { unique.attribute.attlist, empty }
unique.attribute.attlist &=
  attribute entity-ref { xsd:NMTOKEN }?,
  attribute attribute { xsd:NMTOKEN }
subtype.constraint =
  element subtype.constraint {
    subtype.constraint.attlist, description?, graphic.element?
  }
subtype.constraint.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute totalover { xsd:NMTOKENS }?,
  attribute super.expression { text }?
function =
  element function {
    function.attlist, description?, parameter*, underlying, algorithm
  }
function.attlist &= attribute name { xsd:NMTOKEN }
parameter =
  element parameter { parameter.attlist, description?, underlying }
parameter.attlist &= attribute name { xsd:NMTOKEN }
procedure =
  element procedure {
    procedure.attlist, description?, parameter*, algorithm?
  }
procedure.attlist &= attribute name { xsd:NMTOKEN }
rule = element rule { rule.attlist, description?, algorithm?, where+ }
rule.attlist &=
  attribute name { xsd:NMTOKEN },
  attribute appliesto { xsd:NMTOKENS }
algorithm = element algorithm { algorithm.attlist, text }
algorithm.attlist &= empty
start = express
