<?xml version="1.0"?>
<!--
# $Id: express_model.dtd,v 1.14 2003/07/18 21:50:20 thendrix Exp $

# EXPRESS MODEL DECLARATION MODULE

# This set of declarations defines the EXPRESS-2 Model as of the
#      date shown in the Formal Public Identifier (FPI) for this entity.
# 
#      This set of declarations may be referred to using a public external
#      entity declaration and reference as shown in the following two lines:
# 
# <!ENTITY % express.model PUBLIC "-//TC184 SC4//DTD EXPRESS Model 20010901">
# %express.model;
# 
#      If the parameter entity description.content used within this set 
#      of declarations is to be given non-default values, the appropriate 
#      declaration should be given before calling in this package 
#      (i.e., before the "%express.model;" reference).

# This file was developed by Eurostep and supplied to NIST under contract.
# Authors:
#    Rob Bodington
#    David Price
#    Nigel Shaw
#    Phil Spiby
# Reviewed by:
#    Josh Lubell
-->

<article>
  <articleinfo>
    <author>
      <firstname>Joshua</firstname>
      <surname>Lubell</surname>
    </author>
    <title>STEP Modules Repository (STEPmod) EXPRESS Model Specification</title>
  </articleinfo>
  <programlisting>
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

# underlying type
underlying = aggregate*, (typename | builtintype)
description.content = text
# Attributes for source control software like RCS or CVS

# The rcs attributes are keywords for RCS source control systems

# rcs.date      $Date: 2003/07/18 21:50:20 $

# rcs.revision  $Revision: 1.14 $

# reference is the source of the schema, e.g. ISO 10303-41
express =
  element express {
    express.attlist, description?, application?, schema+
  }
express.attlist &amp;=
  [ a:defaultValue = "1" ]
  attribute language_version { "1" | "2" | "3" }?,
  attribute rcs.date { text },
  attribute rcs.revision { text },
  attribute reference { text }?,
  attribute description.file { text }?
description =
  element description { description.attlist, description.content* }
description.attlist &amp;= empty
application = element application { application.attlist, empty }
application.attlist &amp;=
  attribute name { text }?,
  attribute owner { text }?,
  attribute url { text }?,
  attribute version { text }?,
  attribute source { text }
schema =
  element schema {
    schema.attlist,
    description?,
    interface*,
    constant*,
    (entity | function | procedure | rule | subtype.constraint | type)*,
    graphic.element?
  }
schema.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute version { xsd:NMTOKEN }?
interface =
  element interface {
    interface.attlist, interfaced.item*, described.item*
  }
interface.attlist &amp;=
  [ a:defaultValue = "use" ] attribute kind { "use" | "reference" }?,
  attribute schema { xsd:NMTOKEN }
interfaced.item =
  element interfaced.item { interfaced.item.attlist, empty }
interfaced.item.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute alias { xsd:NMTOKEN }?
# A description of any item in the interface. In other words the
# documentation of an imported construct.         
# item is the name of the imported construct
# attribute is only used if the imported construct is an entity in whihc
# case, item is the name of the entty and item is the name of the attribute
described.item =
  element described.item { described.item.attlist, description? }
described.item.attlist &amp;=
  attribute item { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }?,
  [ a:defaultValue = "ENTITY" ]
  attribute kind {
    "ENTITY"
    | "TYPE"
    | "ATTRIBUTE"
    | "FUNCTION"
    | "PROCEDURE"
    | "CONSTANT"
  }?
constant =
  element constant { constant.attlist, description?, underlying }
constant.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
type =
  element type {
    type.attlist,
    description?,
    aggregate*,
    (typename | builtintype | enumeration | select),
    where*,
    graphic.element?
  }
type.attlist &amp;= attribute name { xsd:NMTOKEN }
typename = element typename { typename.attlist, empty }
typename.attlist &amp;= attribute name { xsd:NMTOKEN }
builtintype =
  element builtintype { builtintype.attlist, graphic.element? }
builtintype.attlist &amp;=
  [ a:defaultValue = "STRING" ]
  attribute type {
    "BINARY"
    | "BOOLEAN"
    | "GENERIC"
    | "GENERICENTITY"
    | "INTEGER"
    | "LOGICAL"
    | "NUMBER"
    | "REAL"
    | "STRING"
  }?,
  attribute width { text }?,
  [ a:defaultValue = "NO" ] attribute fixed { "YES" | "NO" }?,
  attribute precision { text }?,
  attribute typelabel { xsd:NMTOKEN }?
# Width to allow for Binary and string

# Fixed to allow for Binary and string

# Precision to allow for REAL
aggregate = element aggregate { aggregate.attlist, empty }
aggregate.attlist &amp;=
  [ a:defaultValue = "SET" ]
  attribute type { "AGGREGATE" | "ARRAY" | "BAG" | "LIST" | "SET" }?,
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute unique { "YES" | "NO" }?,
  attribute lower { text }?,
  attribute upper { text }?,
  attribute typelabel { xsd:NMTOKEN }?
select = element select { select.attlist, graphic.element? }
select.attlist &amp;=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute genericentity { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute selectitems { xsd:NMTOKENS }?
graphic.element =
  element graphic.element { graphic.element.attlist, empty }
graphic.element.attlist &amp;=
  attribute image { text }?,
  attribute page { text },
  attribute xcoord { text }?,
  attribute ycoord { text }?
enumeration =
  element enumeration { enumeration.attlist, graphic.element? }
enumeration.attlist &amp;=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute items { xsd:NMTOKENS }?
entity =
  element entity {
    entity.attlist,
    description?,
    explicit*,
    derived*,
    inverse*,
    unique*,
    where*,
    graphic.element?
  }
entity.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute abstract.entity { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute supertypes { xsd:NMTOKENS }?,
  attribute super.expression { text }?
explicit =
  element explicit {
    explicit.attlist, description?, underlying, redeclaration?
  }
explicit.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?
derived =
  element derived {
    derived.attlist, description?, underlying, redeclaration?
  }
derived.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
inverse =
  element inverse {
    inverse.attlist, description?, inverse.aggregate?, redeclaration?
  }
inverse.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }
inverse.aggregate =
  element inverse.aggregate { inverse.aggregate.attlist, empty }
inverse.aggregate.attlist &amp;=
  [ a:defaultValue = "SET" ] attribute type { "BAG" | "SET" }?,
  attribute lower { text }?,
  attribute upper { text }?
redeclaration = element redeclaration { redeclaration.attlist, empty }
redeclaration.attlist &amp;=
  attribute entity-ref { xsd:NMTOKEN },
  attribute old_name { xsd:NMTOKEN }?
where = element where { where.attlist, description? }
where.attlist &amp;=
  attribute label { xsd:NMTOKEN }?,
  attribute expression { text }?
# <!ELEMENT unique (description?, unique.attribute)>
unique =
  element unique { unique.attlist, description?, unique.attribute+ }
unique.attlist &amp;= attribute label { xsd:NMTOKEN }?
unique.attribute =
  element unique.attribute { unique.attribute.attlist, empty }
unique.attribute.attlist &amp;=
  attribute entity-ref { xsd:NMTOKEN }?,
  attribute attribute { xsd:NMTOKEN }
subtype.constraint =
  element subtype.constraint {
    subtype.constraint.attlist, description?, graphic.element?
  }
subtype.constraint.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute totalover { xsd:NMTOKENS }?,
  attribute super.expression { text }?
function =
  element function {
    function.attlist, description?, parameter*, underlying, algorithm
  }
function.attlist &amp;= attribute name { xsd:NMTOKEN }
parameter =
  element parameter { parameter.attlist, description?, underlying }
parameter.attlist &amp;= attribute name { xsd:NMTOKEN }
procedure =
  element procedure {
    procedure.attlist, description?, parameter*, algorithm?
  }
procedure.attlist &amp;= attribute name { xsd:NMTOKEN }
rule = element rule { rule.attlist, description?, algorithm?, where+ }
rule.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute appliesto { xsd:NMTOKENS }
algorithm = element algorithm { algorithm.attlist, text }
algorithm.attlist &amp;= empty

[ a:documentation [ "Here is " html:em [ "some" ] " documentation." ] ]
start = express
  </programlisting>
</article>
