<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="express_model.xsl"?>
<!--
# $Id: express_model.xml,v 1.3 2004/09/15 21:18:54 joshualubell Exp $

# EXPRESS MODEL DECLARATION MODULE

# This set of declarations defines the EXPRESS-2 Model as of the
#      date shown in the Formal Public Identifier (FPI) for this entity.
# 
#      This set of declarations may be referred to using a public external
#      entity declaration and reference as shown in the following two lines:
# 
# <!ENTITY % express.model PUBLIC "-//TC184 SC4//DTD EXPRESS Model 20010901">
# %express.model;
# 
#      If the parameter entity description.content used within this set 
#      of declarations is to be given non-default values, the appropriate 
#      declaration should be given before calling in this package 
#      (i.e., before the "%express.model;" reference).

# This file was developed by Eurostep and supplied to NIST under contract.
# Authors:
#    Rob Bodington
#    David Price
#    Nigel Shaw
#    Phil Spiby
# Reviewed by:
#    Josh Lubell
-->

<article>
  <articleinfo>
    <author>
      <firstname>Joshua</firstname>
      <surname>Lubell</surname>
    </author>
    <title>STEP Modules Repository EXPRESS Model (STEPmod)
Specification</title>
    <date>$Date: 2004/09/15 21:18:54 $</date>
  </articleinfo>
  <section>
    <title>Introduction</title>
    <para>

The STEP Modules Repository is a collection of reusable XML building
blocks for developing standards from information models defined in
EXPRESS. An integral part of the repository's XML vocabulary is its
representation of EXPRESS language constructs, i.e. its EXPRESS
model. This specification shall refer to this EXPRESS model portion of
the repository's XML vocabulary as <emphasis>STEPmod
EXPRESS</emphasis>.

    </para>
<para>

STEPmod EXPRESS was originally defined using a DTD. However, this
specification uses RELAX NG syntax because RELAX NG is better able to
represent co-occurrence constraints between XML attributes, and most
of the information in STEPmod EXPRESS data is in XML attribute values
rather than in element content.

</para>
<para>

STEPmod EXPRESS takes a middle-of-the-road approach regarding the
level of granularity of the XML markup with respect to to the EXPRESS
language. High level EXPRESS structures such as data types, their
attributes, and inheritance relationships are marked up. Expressions,
on the other hand, are not. As a result, STEPmod EXPRESS is suitable
for applications such as EXPRESS schema browsers as well as partial
mappings to other modeling languages such as UML and OWL.

</para>
  </section>
  <section>
    <title>STEPmod RELAX NG Schema</title>

  <programlisting>
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"

# underlying type
underlying = aggregate*, (typename | builtintype)
description.content = text
# Attributes for source control software like RCS or CVS

# The rcs attributes are keywords for RCS source control systems

# rcs.date      $Date: 2004/09/15 21:18:54 $

# rcs.revision  $Revision: 1.3 $

# reference is the source of the schema, e.g. ISO 10303-41
express =
  element express {
    express.attlist, description?, application?, schema+
  }
express.attlist &amp;=
  [ a:defaultValue = "1" ]
  attribute language_version { "1" | "2" | "3" }?,
  attribute rcs.date { text },
  attribute rcs.revision { text },
  attribute reference { text }?,
  attribute description.file { text }?
description =
  element description { description.attlist, description.content* }
description.attlist &amp;= empty
application = element application { application.attlist, empty }
application.attlist &amp;=
  attribute name { text }?,
  attribute owner { text }?,
  attribute url { text }?,
  attribute version { text }?,
  attribute source { text }
schema =
  element schema {
    schema.attlist,
    description?,
    interface*,
    constant*,
    (entity | function | procedure | rule | subtype.constraint | type)*,
    graphic.element?
  }
schema.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute version { xsd:NMTOKEN }?
interface =
  element interface {
    interface.attlist, interfaced.item*, described.item*
  }
interface.attlist &amp;=
  [ a:defaultValue = "use" ] attribute kind { "use" | "reference" }?,
  attribute schema { xsd:NMTOKEN }
interfaced.item =
  element interfaced.item { interfaced.item.attlist, empty }
interfaced.item.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute alias { xsd:NMTOKEN }?
# A description of any item in the interface. In other words the
# documentation of an imported construct.         
# item is the name of the imported construct
# attribute is only used if the imported construct is an entity in whihc
# case, item is the name of the entty and item is the name of the attribute
described.item =
  element described.item { described.item.attlist, description? }
described.item.attlist &amp;=
  attribute item { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }?,
  [ a:defaultValue = "ENTITY" ]
  attribute kind {
    "ENTITY"
    | "TYPE"
    | "ATTRIBUTE"
    | "FUNCTION"
    | "PROCEDURE"
    | "CONSTANT"
  }?
constant =
  element constant { constant.attlist, description?, underlying }
constant.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
type =
  element type {
    type.attlist,
    description?,
    aggregate*,
    (typename | builtintype | enumeration | select),
    where*,
    graphic.element?
  }
type.attlist &amp;= attribute name { xsd:NMTOKEN }
typename = element typename { typename.attlist, empty }
typename.attlist &amp;= attribute name { xsd:NMTOKEN }
builtintype =
  element builtintype { builtintype.attlist, graphic.element? }
builtintype.attlist &amp;=
  [ a:defaultValue = "STRING" ]
  attribute type {
    "BINARY"
    | "BOOLEAN"
    | "GENERIC"
    | "GENERICENTITY"
    | "INTEGER"
    | "LOGICAL"
    | "NUMBER"
    | "REAL"
    | "STRING"
  }?,
  attribute width { text }?,
  [ a:defaultValue = "NO" ] attribute fixed { "YES" | "NO" }?,
  attribute precision { text }?,
  attribute typelabel { xsd:NMTOKEN }?
# Width to allow for Binary and string

# Fixed to allow for Binary and string

# Precision to allow for REAL
aggregate = element aggregate { aggregate.attlist, empty }
aggregate.attlist &amp;=
  [ a:defaultValue = "SET" ]
  attribute type { "AGGREGATE" | "ARRAY" | "BAG" | "LIST" | "SET" }?,
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute unique { "YES" | "NO" }?,
  attribute lower { text }?,
  attribute upper { text }?,
  attribute typelabel { xsd:NMTOKEN }?
select = element select { select.attlist, graphic.element? }
select.attlist &amp;=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ] attribute genericentity { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute selectitems { xsd:NMTOKENS }?
graphic.element =
  element graphic.element { graphic.element.attlist, empty }
graphic.element.attlist &amp;=
  attribute image { text }?,
  attribute page { text },
  attribute xcoord { text }?,
  attribute ycoord { text }?
enumeration =
  element enumeration { enumeration.attlist, graphic.element? }
enumeration.attlist &amp;=
  [ a:defaultValue = "NO" ] attribute extensible { "YES" | "NO" }?,
  attribute basedon { xsd:NMTOKEN }?,
  attribute items { xsd:NMTOKENS }?
entity =
  element entity {
    entity.attlist,
    description?,
    explicit*,
    derived*,
    inverse*,
    unique*,
    where*,
    graphic.element?
  }
entity.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute abstract.entity { "YES" | "NO" }?,
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute supertypes { xsd:NMTOKENS }?,
  attribute super.expression { text }?
explicit =
  element explicit {
    explicit.attlist, description?, underlying, redeclaration?
  }
explicit.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ] attribute optional { "YES" | "NO" }?
derived =
  element derived {
    derived.attlist, description?, underlying, redeclaration?
  }
derived.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute expression { text }
inverse =
  element inverse {
    inverse.attlist, description?, inverse.aggregate?, redeclaration?
  }
inverse.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  attribute attribute { xsd:NMTOKEN }
inverse.aggregate =
  element inverse.aggregate { inverse.aggregate.attlist, empty }
inverse.aggregate.attlist &amp;=
  [ a:defaultValue = "SET" ] attribute type { "BAG" | "SET" }?,
  attribute lower { text }?,
  attribute upper { text }?
redeclaration = element redeclaration { redeclaration.attlist, empty }
redeclaration.attlist &amp;=
  attribute entity-ref { xsd:NMTOKEN },
  attribute old_name { xsd:NMTOKEN }?
where = element where { where.attlist, description? }
where.attlist &amp;=
  attribute label { xsd:NMTOKEN }?,
  attribute expression { text }?
# &lt;!ELEMENT unique (description?, unique.attribute)&gt;
unique =
  element unique { unique.attlist, description?, unique.attribute+ }
unique.attlist &amp;= attribute label { xsd:NMTOKEN }?
unique.attribute =
  element unique.attribute { unique.attribute.attlist, empty }
unique.attribute.attlist &amp;=
  attribute entity-ref { xsd:NMTOKEN }?,
  attribute attribute { xsd:NMTOKEN }
subtype.constraint =
  element subtype.constraint {
    subtype.constraint.attlist, description?, graphic.element?
  }
subtype.constraint.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute entity { xsd:NMTOKEN },
  [ a:defaultValue = "NO" ]
  attribute abstract.supertype { "YES" | "NO" }?,
  attribute totalover { xsd:NMTOKENS }?,
  attribute super.expression { text }?
function =
  element function {
    function.attlist, description?, parameter*, underlying, algorithm
  }
function.attlist &amp;= attribute name { xsd:NMTOKEN }
parameter =
  element parameter { parameter.attlist, description?, underlying }
parameter.attlist &amp;= attribute name { xsd:NMTOKEN }
procedure =
  element procedure {
    procedure.attlist, description?, parameter*, algorithm?
  }
procedure.attlist &amp;= attribute name { xsd:NMTOKEN }
rule = element rule { rule.attlist, description?, algorithm?, where+ }
rule.attlist &amp;=
  attribute name { xsd:NMTOKEN },
  attribute appliesto { xsd:NMTOKENS }
algorithm = element algorithm { algorithm.attlist, text }
algorithm.attlist &amp;= empty

[ a:documentation [ "Here is " html:em [ "some" ] " documentation." ] ]
start = express
</programlisting>
  </section>
</article>
