SCHEMA Production_rule_arm;

USE FROM Specification_document_arm;
USE FROM Software_arm;
USE FROM Activity_arm;
USE FROM Identification_assignment_arm;
USE FROM Product_identification_arm;
USE FROM Date_time_assignment_arm;

TYPE PR_Number = NUMBER; END_TYPE;
TYPE PR_String = STRING; END_TYPE;
TYPE PR_Logical = LOGICAL; END_TYPE;

TYPE pr_identification_item = SELECT BASED_ON identification_item WITH 
   (Rule_set);
END_TYPE; 

TYPE Clause_select = SELECT (Simple_clause, Complex_clause);
END_TYPE;

TYPE Constants = EXTENSIBLE SELECT (PR_Number, PR_String, PR_Logical);
END_TYPE;

TYPE Function_symbol = SELECT (PR_String, Built_in_functions);
END_TYPE;

TYPE Built_in_functions = EXTENSIBLE ENUMERATION OF (ATTR_VAL);
END_TYPE;

TYPE Expression_syntax = EXTENSIBLE ENUMERATION OF (EXPRESS);
END_TYPE;

TYPE Predicate_symbol = STRING;
END_TYPE;

TYPE Scope_select = SELECT (Rule_definition, Rule_set, Rule_set_group);
END_TYPE;

TYPE Term_select = SELECT (Symbol, Constants, Func, Scalar_variable, Row_value, Row_variable); 
END_TYPE;

ENTITY Enum_reference_prefix;
 prefix : STRING;
END_ENTITY;

RULE max_one_entity_prefix FOR (Enum_reference_prefix);
 WHERE
   SIZEOF(QUERY(x <* Enum_reference_prefix | TRUE)) <= 1;
END_RULE;

ENTITY Rule_creation
    SUBTYPE OF (Rule_action);
END_ENTITY;
  
ENTITY Rule_definition
  ABSTRACT SUPERTYPE OF (ONEOF (Forward_chaining_rule, Back_chaining_rule))
  SUBTYPE OF (Rule_software_definition);
END_ENTITY; 

ENTITY Forward_chaining_rule
  SUBTYPE OF (Rule_definition);
  premise : Clause_Select; 
  conclusion : Literal_conjunction;
  WHERE
  WR1:  local_vars_of(SELF.conclusion) <= local_vars_of(SELF.premise);
END_ENTITY;

ENTITY Back_chaining_rule
  SUBTYPE OF (Rule_definition);
  head : Rule_condition;
  body : LIST OF Rule_condition;
 WHERE
  WR1: SELF.head.positive = TRUE;
  WR2:  local_vars_of(SELF.head) <= local_vars_of(SELF.body);
END_ENTITY;

ENTITY Simple_clause;
  formulas : LIST [1:?] OF Rule_condition;
END_ENTITY;

SUBTYPE_CONSTRAINT Simple_clause_sc FOR Simple_Clause;
  ABSTRACT SUPERTYPE;
  ONEOF (Literal_conjunction, Literal_disjunction);
END_SUBTYPE_CONSTRAINT;

ENTITY Literal_conjunction
  SUBTYPE OF (Simple_clause);
END_ENTITY;

ENTITY Literal_disjunction
  SUBTYPE OF (Simple_clause);
END_ENTITY;

ENTITY Atomic_formula;
  pred_sym : Predicate_Symbol;  
  terms : LIST OF Term_select;
END_ENTITY;

SUBTYPE_CONSTRAINT Atomic_formula_sc FOR Atomic_formula;
  ABSTRACT SUPERTYPE;
  ONEOF (Rule_condition, Ground_fact);
END_SUBTYPE_CONSTRAINT;

ENTITY Rule_condition
 SUBTYPE OF (Atomic_formula);
  positive : BOOLEAN;
END_ENTITY;

ENTITY Ground_fact
 SUBTYPE OF (Atomic_formula);
 WHERE
  WR1: SIZEOF(QUERY(r <* SELF\Atomic_formula.terms | contains_variable(r))) = 0;
END_ENTITY;

SUBTYPE_CONSTRAINT Complex_clause_sc FOR Complex_Clause;
  ABSTRACT SUPERTYPE;
  ONEOF (Complex_conjunctive_clause, Complex_disjunctive_clause);
END_SUBTYPE_CONSTRAINT;

ENTITY Complex_Clause;
  clauses : LIST [2:?] OF Clause_select;
END_ENTITY;

ENTITY Complex_conjunctive_clause
  SUBTYPE OF (Complex_Clause); 
END_ENTITY;

ENTITY Complex_disjunctive_clause
  SUBTYPE OF (Complex_Clause); 
END_ENTITY;

ENTITY Symbol;
  name : STRING;
END_ENTITY;

ENTITY Abstract_variable
  ABSTRACT SUPERTYPE OF (ONEOF (Scalar_variable, Row_variable));
  name : STRING;
  scope : Scope_select;
 UNIQUE 
  UR1 : name, scope;
END_ENTITY;

ENTITY Scalar_variable
 SUBTYPE OF (Abstract_variable);
END_ENTITY;

ENTITY Row_variable
 SUBTYPE OF (Abstract_variable);
END_ENTITY;

ENTITY Row_value;
  values : LIST OF Term_select;
 WHERE
  WR1: SIZEOF(QUERY(v <* SELF.values | contains_variable(v))) = 0;
  WR2: SIZEOF(QUERY(v <* SELF.values | 'PRODUCTION_RULE_ARM.ROW_VALUE' IN TYPEOF(v))) = 0;
END_ENTITY;

ENTITY Func;
 func_sym : Function_Symbol;
 terms : LIST OF Term_select;
END_ENTITY;

ENTITY Extent;
  source : STRING;
  query_expression : STRING;
  syntax : OPTIONAL Expression_syntax;
END_ENTITY;

ENTITY Fact_type
  ABSTRACT SUPERTYPE OF (ONEOF (Entity_assertion, Attribute_assertion));
   source : Extent;
   predicate_symbol : STRING;
END_ENTITY;

ENTITY Entity_assertion
  SUBTYPE OF (Fact_type);
END_ENTITY;

ENTITY Attribute_assertion
  SUBTYPE OF (Fact_type);
   entity_type : STRING;
   attribute : STRING;
END_ENTITY; 

ENTITY Global_assignment;
  variable : Abstract_variable;
  val : Term_select;
 WHERE
  WR1: NOT(contains_variable(SELF.val));
END_ENTITY;
 
ENTITY Rule_set
   SUBTYPE OF (Rule_software_definition);
   engine : Language_reference_manual;
   conflict_resolution_strategy : OPTIONAL STRING;
   rule_member : SET[1:?] OF Rule_priority;
 INVERSE
   purpose : Identification_assignment FOR items;
 WHERE
   WR1: purpose.role = 'purpose' ;
END_ENTITY;

ENTITY Rule_set_group
  SUBTYPE OF (Rule_software_definition);
  elements : SET[2:?] OF Rule_set;
END_ENTITY;

FUNCTION contains_variable (x : Term_select) : BOOLEAN;
  IF ('PRODUCTION_RULE_ARM.ABSTRACT_VARIABLE' IN TYPEOF(x)) THEN RETURN (TRUE);
      ELSE IF (('PRODUCTION_RULE_ARM.FUNC' IN TYPEOF(X)) AND
              (SIZEOF(QUERY(y <* x.terms | contains_variable(y))) > 0)) 
              THEN RETURN (TRUE);
              ELSE RETURN (FALSE);
           END_IF;
  END_IF;
END_FUNCTION;

FUNCTION local_vars_of (thing : GENERIC) : SET [0:?] OF Scalar_variable;
  LOCAL
    accum : SET [0:?] OF Scalar_variable := [];
  END_LOCAL;
  RETURN (local_vars_aux(thing, accum));
END_FUNCTION;

FUNCTION local_vars_aux (thing : GENERIC; accum : SET [0:?] OF Scalar_variable) 
                                                : SET [0:?] OF Scalar_variable;
  LOCAL i,j,k : INTEGER; END_LOCAL;
  IF (('PRODUCTION_RULE_ARM.ABSTRACT_VARIABLE' IN TYPEOF(thing)) AND 
      ('PRODUCTION_RULE_ARM.RULE_DEFINITION' IN (TYPEOF(thing.scope))))
   THEN accum := accum + thing;
   ELSE IF ('PRODUCTION_RULE_ARM.RULE_CONDITION' IN TYPEOF(thing))
        THEN REPEAT i := 1 TO HIINDEX(thing\Atomic_formula.terms);
                accum := local_vars_aux(thing\Atomic_formula.terms[i],accum);
             END_REPEAT;
        ELSE IF ('PRODUCTION_RULE_ARM.SIMPLE_CLAUSE' IN TYPEOF(thing))
             THEN REPEAT j := 1 TO HIINDEX(thing.formulas);
                        accum := local_vars_aux(thing.formulas[j],accum);
                  END_REPEAT;
             ELSE IF ('PRODUCTION_RULE_ARM.COMPLEX_CLAUSE' IN TYPEOF(thing))
                  THEN REPEAT k := 1 TO HIINDEX(thing.clauses);
                        accum := local_vars_aux(thing.clauses[k],accum);
                       END_REPEAT;
                  END_IF;
             END_IF;
        END_IF;
  END_IF;
  RETURN(accum);
END_FUNCTION;

-- =====================================================
-- Rule management 
-- =====================================================

ENTITY Rule_action
   ABSTRACT SUPERTYPE OF (ONEOF (Rule_submission,
                                 Rule_adoption,
                                 Rule_rejection,
                                 Rule_supersedence,
                                 Rule_creation,
                                 Rule_expiration,
                                 Rule_change_request,
                                 Rule_request,
                                 Rule_modification));
   subject_rule : Rule_version;
DERIVE
   subject_action_assignment : SET[0:?] OF Organization_or_person_in_organization_assignment := 
         bag_to_set(QUERY(temp <* USEDIN ( SELF , 'PERSON_ORGANIZATION_ASSIGNMENT_ARM.' + 
                                       'ORGANIZATION_OR_PERSON_IN_ORGANIZATION_ASSIGNMENT.ITEMS' ) 
                    | ( temp.role = 'subject action assignment')));
  UNIQUE
   UR1: SELF\Rule_action.subject_rule, SELF\Rule_action.subject_action_assignment;
  WHERE
   WR1: EXISTS (subject_action_assignment) AND (SIZEOF(subject_action_assignment) = 1 );
END_ENTITY;

ENTITY Rule_adoption
   SUBTYPE OF (Rule_action);
END_ENTITY;

ENTITY Rule_change_request
   SUBTYPE OF (Rule_action);
   change_reason : STRING;
END_ENTITY;

ENTITY Rule_expiration
   SUBTYPE OF (Rule_action);
   expiration_rationale : STRING;
END_ENTITY;

ENTITY Rule_justification
   SUBTYPE OF (Rule_action);
   justified_action : Rule_action;
   justification_rationale : STRING;
WHERE
   WR1: SELF <> justified_action ;
END_ENTITY;

ENTITY Rule_modification
   SUBTYPE OF (Rule_action);
   modification_rationale : Rule_change_request;
END_ENTITY;

ENTITY Rule_priority;
   priority : INTEGER;
   prioritized_rule : Rule_definition;
WHERE
   WR1: priority >= 0 ;
END_ENTITY;

ENTITY Rule_product
   SUBTYPE OF (Software);
WHERE
   WR1: SIZEOF ( [ 'rule' ] * types_of_product ( SELF ) ) = 1 ;
END_ENTITY;

ENTITY Rule_rejection
   SUBTYPE OF (Rule_action);
   rejection_reason : STRING;
END_ENTITY;

ENTITY Rule_request
   SUBTYPE OF (Rule_action);
END_ENTITY;

ENTITY Rule_software_definition
   SUPERTYPE OF (ONEOF (Rule_definition,
                       Rule_set_group,
                       Rule_set))
   SUBTYPE OF (Software_definition);
   SELF\Product_view_definition.defined_version : Rule_version;
END_ENTITY;

ENTITY Rule_submission
   SUBTYPE OF (Rule_action);
   submission_rationale : STRING;
END_ENTITY;

ENTITY Rule_supersedence
   SUBTYPE OF (Rule_action);
   superseded_rule : Rule_version;
END_ENTITY;

ENTITY Rule_version
   SUBTYPE OF (Software_version);
   SELF\Product_version.of_product : Rule_product;
INVERSE
   management_action : SET[1:?] OF Rule_action FOR subject_rule;
   product_definition : SET[1:?] OF Rule_software_definition FOR defined_version;
END_ENTITY;

RULE rule_software_definition_constraint FOR (Product_view_definition);
WHERE
   WR1: SIZEOF (QUERY ( pvd <* Product_view_definition | ( NOT('PRODUCT_RULE_ARM.' + 'RULE_SOFTWARE_DEFINITION' 
                       IN TYPEOF(pvd))) 
                       AND ('PRODUCT_RULE_ARM.' + 'RULE_VERSION' IN TYPEOF (pvd . defined_version)))) = 0 ;
END_RULE; 

RULE rule_version_constraint FOR (Product_version);
WHERE
   WR1: SIZEOF (QUERY(pv <* Product_version | (NOT('PRODUCT_RULE_ARM.' + 'RULE_VERSION' IN TYPEOF(pv))) 
                      AND ( 'PRODUCT_RULE_ARM.' + 'RULE_PRODUCT' IN TYPEOF(pv.of_product)))) = 0 ;
END_RULE;

  FUNCTION bag_to_set(
    the_bag : BAG OF GENERIC : intype
  ) : SET OF GENERIC : intype;

    LOCAL
      the_set : SET OF GENERIC : intype := [];
      i       : INTEGER;
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);
  END_FUNCTION;


END_SCHEMA;
