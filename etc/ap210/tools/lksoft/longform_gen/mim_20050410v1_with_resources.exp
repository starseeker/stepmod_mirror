(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N657 - ISO/TS 10303-1003 Curve appearance - EXPRESS MIM
*) 


SCHEMA Curve_appearance_mim;

USE FROM Colour_mim;    -- ISO/TS 10303-1002

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (curve_style,
   curve_style_font,
   curve_style_font_pattern,
   draughting_pre_defined_curve_font,
   externally_defined_curve_font,
   externally_defined_text_font,
   marker_select,
   marker_type,
   point_style,
   pre_defined_curve_font,
   pre_defined_marker); 

USE FROM presentation_definition_schema   -- ISO 10303-46
  (externally_defined_symbol,
   pre_defined_symbol); 

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 


TYPE terminator =  SELECT
   (externally_defined_terminator_symbol, 
    pre_defined_terminator_symbol, 
    user_defined_terminator_symbol);
END_TYPE; 

ENTITY externally_defined_marker
  SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
END_ENTITY;

ENTITY externally_defined_terminator_symbol
  SUBTYPE OF (externally_defined_symbol);
END_ENTITY;

ENTITY pre_defined_terminator_symbol
  SUBTYPE OF (pre_defined_symbol);
WHERE
  WR1: SELF.name IN ['blanked arrow', 'blanked box', 'blanked dot', 'dimension origin', 'filled arrow', 'filled box', 'filled dot', 'integral symbol', 'open arrow', 'slash', 'unfilled arrow'];
END_ENTITY;

ENTITY user_defined_curve_font
  SUBTYPE OF (curve_style_font, mapped_item);
END_ENTITY;

ENTITY user_defined_marker
  SUBTYPE OF (mapped_item, pre_defined_marker);
END_ENTITY;

ENTITY user_defined_terminator_symbol
  SUBTYPE OF (mapped_item, pre_defined_symbol);
END_ENTITY;

ENTITY vector_style
  SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
END_ENTITY;

END_SCHEMA;  -- Curve_appearance_mim



(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA action_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   id_attribute,
   name_attribute); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE supported_item = SELECT
   (action, 
    action_directive, 
    action_method);
END_TYPE; 

ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET[1:?] OF versioned_action_request;
END_ENTITY;

ENTITY action_method;
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;

ENTITY action_method_relationship;
  name : label;
  description : OPTIONAL text;
  relating_method : action_method;
  related_method : action_method;
END_ENTITY;

ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;

ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_resource;
  name : label;
  description : OPTIONAL text;
  usage : SET[1:?] OF supported_item;
  kind : action_resource_type;
END_ENTITY;

ENTITY action_resource_relationship;
  name : label;
  description : OPTIONAL text;
  relating_resource : action_resource;
  related_resource : action_resource;
END_ENTITY;

ENTITY action_resource_type;
  name : label;
END_ENTITY;

ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY versioned_action_request_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_versioned_action_request : versioned_action_request;
  related_versioned_action_request : versioned_action_request;
END_ENTITY;

FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

END_SCHEMA;  -- action_schema
SCHEMA aic_advanced_brep;
  
USE FROM aic_topologically_bounded_surface;
 USE FROM geometry_schema ( cartesian_transformation_operator_3d);
 USE FROM geometric_model_schema ( manifold_solid_brep, brep_with_voids);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, oriented_closed_shell);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY advanced_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.FACETED_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM', 'AIC_ADVANCED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* SELF.items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('AIC_ADVANCED_BREP.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_ADVANCED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 (* EXPRESS short form corresponding to 10303-520 IS 
   WG12 N383 *)

SCHEMA aic_associative_draughting_elements;

 USE FROM measure_schema                            -- ISO 10303-41
  (derived_unit,
  named_unit);

 USE FROM product_property_definition_schema        -- ISO 10303-41
  (shape_aspect_relationship);

 USE FROM product_property_representation_schema    -- ISO 10303-41
   (shape_definition_representation);

 REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (bag_to_set);

 USE FROM representation_schema                     -- ISO 10303-43
  (mapped_item,
  representation,
  representation_item,
  representation_map);

 REFERENCE FROM representation_schema               -- ISO 10303-43
  (using_representations);

 USE FROM qualified_measure_schema                  -- ISO 10303-45
  (measure_representation_item);

 USE FROM presentation_appearance_schema            -- ISO 10303-46
  (curve_style,
  styled_item);
 
 USE FROM presentation_definition_schema            -- ISO 10303-46
  (annotation_curve_occurrence,
  annotation_fill_area_occurrence,
  annotation_occurrence,
  annotation_occurrence_relationship,
  annotation_symbol_occurrence,
  annotation_text_occurrence,
  text_literal);

 USE FROM presentation_organization_schema            -- ISO 10303-46
  (camera_model);

 USE FROM shape_dimension_schema                    -- ISO 10303-47
  (dimensional_characteristic_representation,
  shape_dimension_representation);

 USE FROM draughting_element_schema                 -- ISO 10303-101
  (draughting_callout,
  leader_curve,
  projection_curve);


ENTITY annotation_occurrence_associativity
  SUBTYPE OF (annotation_occurrence_relationship);
WHERE
  WR1:  SIZEOF (TYPEOF (SELF.related_annotation_occurrence) *
                ['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.ANNOTATION_FILL_AREA_OCCURRENCE',
                'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PROJECTION_CURVE',
                'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.LEADER_CURVE']) = 1;
END_ENTITY;

ENTITY dimension_text_associativity
  SUBTYPE OF (text_literal, mapped_item);
WHERE
  WR1:  ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_DIMENSION_REPRESENTATION'
          IN TYPEOF (SELF\mapped_item.
                          mapping_source.mapped_representation));
  WR2:  ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_CALLOUT'
          IN TYPEOF (SELF\mapped_item.mapping_target));
  WR3:  SIZEOF (QUERY (ato <* QUERY (si <* 
                USEDIN (SELF, 'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
                  ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
                    IN TYPEOF(si))) |
                NOT (SIZEOF( QUERY (dc <*
                   USEDIN (ato, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                                 'DRAUGHTING_CALLOUT.CONTENTS') |
                     ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_CALLOUT'
                   IN TYPEOF (dc)))
                  * [SELF\mapped_item.mapping_target]) = 1)
                )) = 0;
END_ENTITY;

ENTITY draughting_model
  SUBTYPE OF (representation);
UNIQUE
  UR1:  SELF\representation.name;
WHERE
  WR1:  SIZEOF (QUERY (it <* SELF.items |
                 NOT (SIZEOF (['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.MAPPED_ITEM',
                               'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.STYLED_ITEM',
                               'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.AXIS2_PLACEMENT',
                               'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.CAMERA_MODEL'] *
                      TYPEOF (it)) = 1
               ))) = 0;
  WR2:  SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
                 ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.MAPPED_ITEM' IN TYPEOF(it))) |
                 NOT (
                   SIZEOF (['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_REPRESENTATION',
                            'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL'] *
                      TYPEOF (mi\mapped_item.mapping_source.
                              mapped_representation)) = 1
               ))) = 0;
  WR3:  SIZEOF (QUERY (smi <* QUERY (si <* QUERY (it <* SELF.items |
                 ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.STYLED_ITEM' IN TYPEOF(it))) |
                 ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.MAPPED_ITEM' IN
                     TYPEOF(si\styled_item.item))) |
                 (NOT (('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_REPRESENTATION' IN
                          TYPEOF(smi\styled_item.item\mapped_item.
                                 mapping_source.mapped_representation))
                     AND
                      (SIZEOF (QUERY (sty <* smi\styled_item.styles |
                        (NOT (SIZEOF (QUERY (psa <* sty.styles |
                               (NOT ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.CURVE_STYLE'
                                       IN TYPEOF(psa))))) = 1
                     )))) = 1)))
               )) = 0;
END_ENTITY;

ENTITY shape_aspect_associativity
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1:  SELF.relating_shape_aspect.product_definitional;
  WR2:  NOT (SELF.related_shape_aspect.product_definitional);
  WR3:  SIZEOF (QUERY (pd <* USEDIN (SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                 'PROPERTY_DEFINITION.DEFINITION') |
          NOT (SIZEOF (QUERY (sdr <* QUERY (pdr <* USEDIN (pd,
                          'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
               ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_DEFINITION_REPRESENTATION'
                   IN TYPEOF (pdr))) |
            NOT (SIZEOF (QUERY (it <* sdr.used_representation.items |
              NOT ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.CURVE' IN TYPEOF(it))
              AND
              (SIZEOF (QUERY (aco <* USEDIN (it,
                          'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
               SIZEOF (TYPEOF (aco) * 
                     ['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.LEADER_CURVE',
                      'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PROJECTION_CURVE']) = 1)) +
               SIZEOF (USEDIN (it, 'PRESENTATION_DEFINITION_SCHEMA.' +
                      'ANNOTATION_FILL_AREA.BOUNDARIES')) >= 1)
            )) = 1) 
          )) = 0)
        )) = 0;
  WR4:  SIZEOF (QUERY (pd <* USEDIN (SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                 'PROPERTY_DEFINITION.DEFINITION') |
          NOT (SIZEOF (QUERY (sdr <* QUERY (pdr <* USEDIN (pd,
                          'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                          'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
               ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_DEFINITION_REPRESENTATION'
                   IN TYPEOF (pdr))) |
            NOT (check_associative_shape_aspects(sdr))
          )) = 0)
        )) = 0;
END_ENTITY;

FUNCTION check_associative_shape_aspects
  (sdr : shape_definition_representation) : BOOLEAN;
  LOCAL
    sr1, sr2 : SET OF representation;
    dm, pv   : SET OF representation;
  END_LOCAL;

  -- Check if the representation contains only two items
  IF (SIZEOF (sdr.used_representation.items) <> 2) THEN
     RETURN (FALSE);
  END_IF;

  -- Find the representations that use each item
  sr1 := using_representations(sdr.used_representation.items[1]);
  sr2 := using_representations(sdr.used_representation.items[2]);

  -- Find the representations in which item 1 representations are mapped
  REPEAT i := 1 TO HIINDEX(sr1);
    dm := representations_mapped_into(sr1[i]);
    REPEAT j := 1 TO HIINDEX(dm);
      IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL' IN TYPEOF(dm[j]))
      THEN
        IF (dm[j] IN sr2) THEN RETURN (TRUE);
        END_IF;
        -- Find the views that the draughting model is mapped into
        pv := representations_mapped_into(dm[j]);
        REPEAT k := 1 TO HIINDEX(pv);
          IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PRESENTATION_VIEW' IN TYPEOF(pv[k]))
          THEN
            IF (pv[k] IN sr2) THEN RETURN (TRUE);
            END_IF;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_REPEAT;

  -- Find the representations in which item 2 representations are mapped
  REPEAT i := 1 TO HIINDEX(sr2);
    dm := representations_mapped_into(sr2[i]);
    REPEAT j := 1 TO HIINDEX(dm);
      IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL' IN TYPEOF(dm[j]))
      THEN
        IF (dm[j] IN sr1) THEN RETURN (TRUE);
        END_IF;
        -- Find the views that the draughting model is mapped into
        pv := representations_mapped_into(dm[j]);
        REPEAT k := 1 TO HIINDEX(pv);
          IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PRESENTATION_VIEW' IN TYPEOF(pv[k]))
          THEN
            IF (pv[k] IN sr1) THEN RETURN (TRUE);
            END_IF;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(FALSE);
END_FUNCTION;

FUNCTION representations_mapped_into 
  (rep : representation) : SET of representation;
  LOCAL
    results : SET OF representation := [];
    rm      : SET OF representation_map;
    mi      : SET OF mapped_item := [];
  END_LOCAL;

  -- Find set of representation_maps which specify the representation
  rm := bag_to_set(USEDIN(rep, 'REPRESENTATION_SCHEMA.' +
                    'REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  -- Find the set of mapped_items that use each representation_map
  REPEAT i := 1 TO HIINDEX(rm);
    mi := mi + rm[i].map_usage;
  END_REPEAT;
  -- Find the set of representations that use each mapped_item
  REPEAT j := 1 TO HIINDEX(mi);
    results := results + USEDIN(mi[j],'REPRESENTATION_SCHEMA.' +
                                      'REPRESENTATION.ITEMS');
  END_REPEAT;
  RETURN(results);
END_FUNCTION;

END_SCHEMA;  
SCHEMA aic_csg;
  
USE FROM aic_advanced_brep;
 USE FROM aic_faceted_brep;
 USE FROM geometric_model_schema ( block, boolean_operand, boolean_operator, boolean_result, box_domain, boxed_half_space, csg_primitive, csg_select, csg_solid, extruded_face_solid, half_space_solid, revolved_face_solid, right_angular_wedge, right_circular_cone, right_circular_cylinder, solid_replica, sphere, torus);
  
ENTITY csg_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_CSG.CSG_SOLID', 'AIC_CSG.MAPPED_ITEM', 'AIC_CSG.AXIS2_PLACEMENT_3D', 'AIC_CSG.SOLID_REPLICA', 'AIC_CSG.REVOLVED_FACE_SOLID', 'AIC_CSG.EXTRUDED_FACE_SOLID' ] * TYPEOF (it)) <> 1) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_CSG.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_CSG.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sr <* 
QUERY ( it <* SELF.items| ('AIC_CSG.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'AIC_CSG.CSG_SOLID', 'AIC_CSG.REVOLVED_FACE_SOLID', 'AIC_CSG.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ('AIC_CSG.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) > 0;
 END_ENTITY ;
END_SCHEMA;
  (* First draft of Curve Swept Solid AIC EXPRESS definitions - not yet verified
 by compiler *)
 SCHEMA aic_curve_swept_solid;
  USE FROM measure_schema; -- 	

  USE FROM aic_topologically_bounded_surface; -- ISO 10303-511

  USE FROM geometry_schema  -- ISO 10303-42
  (axis2_placement_2d,
                           axis2_placement_3d,
                           bezier_curve,
                           bezier_surface,
                           b_spline_curve_with_knots,
                           b_spline_curve,
                           b_spline_surface,
                           b_spline_surface_with_knots,
			   bounded_surface_curve,
                           cartesian_point,
                           circle,
                           composite_curve_on_surface,
                           conical_surface,
                           cylindrical_surface,
                           degenerate_toroidal_surface,
                           direction,
                           ellipse,
                           geometric_representation_context,
                           hyperbola,
                           line,
                           parabola,
                           pcurve,
                           plane,
                           polyline,
                           quasi_uniform_curve,
                           quasi_uniform_surface,
			   outer_boundary_curve,
                           rational_b_spline_curve,
                           rational_b_spline_surface,
                           spherical_surface,
                           surface_curve,
                           surface_of_linear_extrusion,
                           surface_of_revolution,
                           swept_surface,
		           trimmed_curve,		
                           toroidal_surface,
                           uniform_curve,
                           uniform_surface,
                           vector);

  USE FROM geometric_model_schema  -- ISO  10303-42
      (extruded_area_solid,
       revolved_area_solid,
       surface_curve_swept_area_solid,
       swept_disk_solid);

  USE FROM representation_schema(mapped_item);   -- ISO  10303-43

  USE FROM product_property_representation_schema   -- ISO  10303-41
      (shape_representation);

 ENTITY curve_swept_solid_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_CURVE_SWEPT_SOLID.SWEPT_AREA_SOLID',
                'AIC_CURVE_SWEPT_SOLID.SWEPT_DISK_SOLID',
                'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM',
                'AIC_CURVE_SWEPT_SOLID.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_CURVE_SWEPT_SOLID.SWEPT_AREA_SOLID',
                'AIC_CURVE_SWEPT_SOLID.SWEPT_DISK_SOLID',
          'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AIC_CURVE_SWEPT_SOLID.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR4: SIZEOF (QUERY (scsas <* QUERY (it <* SELF.items |
        'AIC_CURVE_SWEPT_SOLID.SURFACE_CURVE_SWEPT_AREA_SOLID' IN
              TYPEOF(it)) |
          NOT(('AIC_CURVE_SWEPT_SOLID.SURFACE_CURVE' IN
                   TYPEOF(scsas.directrix)) OR
                   ('AIC_CURVE_SWEPT_SOLID.PCURVE' IN
                   TYPEOF(scsas.directrix))))) = 0;
 END_ENTITY;
(* Formal propositions:
 WR1: Each item im the items set shall be a swept_area_solid,
      a swept_disk_solid, a mapped_item or an axis2_placement_3d.
 WR2: At least one of the items in the items set shall be a
      swept_area_solid, a swept_disk_solid, or a mapped_item.
 WR3: If there is a mapped_item in a curve_swept_solid_shape_representation the
     mapping_source shall be a curve_swept_solid_shape_representation.
 WR4: If there is a surface_curve_swept_area_solid in a
      curve_swept_solid_shape_representation the directrix shall be either a
      pcurve or a surface_curve.
*)
ENTITY ruled_surface_swept_area_solid
  SUBTYPE OF(surface_curve_swept_area_solid);
  WHERE
  WR1: 'B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface) AND
         (SELF.reference_surface\b_spline_surface.u_degree = 1);
  WR2: ('PCURVE' IN TYPEOF(SELF.directrix)) OR
        (('B_SPLINE_CURVE' IN TYPEOF(SELF.directrix\surface_curve.curve_3d))
         AND
         (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree =
         SELF.reference_surface\b_spline_surface.v_degree));
END_ENTITY;
(* Formal propositions:
  WR1: The reference_surface of a ruled_surface_swept_area_solid shall be a
       b_spline_surface of u_degree 1.
  NOTE: This ensures that the reference surface has the form of a ruled
        surface bounded by two b_spline_curves.
  WR2: The directrix shall be either a pcurve or surface curve. If the directrix
       is a surface_curve the curve_3d shall be a b_spline_curve of the same
       degree as the boundary curves of the ruled surface that is the
       reference_surface.
*)
END_SCHEMA; -- end AIC_CURVE_SWEPT_SOLID SCHEMA
(*
  This is the EXPRESS of the IS version of ISO 10303-504.
  This document is ISO TC 184/SC4/WG12 N503.
*)
SCHEMA aic_draughting_annotation;

USE FROM draughting_element_schema	-- ISO 10303-101
  (draughting_callout,
   terminator_symbol);

USE FROM geometry_schema	-- ISO 10303-42
  (axis2_placement_2d,
   geometric_representation_context);

USE FROM measure_schema	-- ISO 10303-41
  (conversion_based_unit,
   derived_unit,
   global_unit_assigned_context,
   length_measure_with_unit,
   length_unit,
   measure_with_unit,
   named_unit,
   plane_angle_unit,
   plane_angle_measure_with_unit,
   si_unit);
USE FROM presentation_appearance_schema	-- ISO 10303-46
  (box_height,
   box_rotate_angle,
   box_slant_angle,
   box_width,
   context_dependent_invisibility,
   curve_style,
   curve_style_font,
   externally_defined_curve_font,
   externally_defined_hatch_style,
   externally_defined_tile_style,
   fill_area_style,
   fill_area_style_colour,
   fill_area_style_hatching,
   fill_area_style_tile_symbol_with_style,
   fill_area_style_tiles,
   null_style,
   pre_defined_curve_font,
   presentation_style_by_context,
   symbol_colour,
   symbol_style,
   text_style,
   text_style_for_defined_font,
   text_style_with_box_characteristics,
   text_style_with_mirror,
   text_style_with_spacing);

USE FROM presentation_definition_schema	-- ISO 10303-46
  (annotation_curve_occurrence,
   annotation_fill_area,
   annotation_fill_area_occurrence,
   annotation_occurrence,
   annotation_symbol,
   annotation_symbol_occurrence,
   annotation_text_occurrence,
   composite_text,
   composite_text_with_associated_curves,
   composite_text_with_blanking_box,
   composite_text_with_extent,
   defined_symbol,
   externally_defined_symbol,
   pre_defined_symbol,
   symbol_representation,
   symbol_representation_map,
   text_alignment,
   text_literal,
   text_literal_with_associated_curves,
   text_literal_with_blanking_box,
   text_literal_with_delineation,
   text_literal_with_extent);

USE FROM presentation_resource_schema	-- ISO 10303-46
  (colour_rgb,
   externally_defined_text_font,
   font_select,
   pre_defined_colour,
   pre_defined_text_font);

USE FROM representation_schema	-- ISO 10303-43
  (mapped_item,
   representation,
   representation_item);

ENTITY annotation_subfigure_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (QUERY (sty <* SELF.styles |
         NOT (SIZEOF (sty.styles) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (sty <* SELF.styles |
         NOT ('AIC_DRAUGHTING_ANNOTATION.NULL_STYLE'
               IN TYPEOF (sty.styles[1]))       ))=0;
  WR3: ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
           IN TYPEOF (SELF.item));
  WR4: ('AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_SUBFIGURE_REPRESENTATION'
           IN TYPEOF
           (SELF.item\mapped_item.mapping_source.mapped_representation));
END_ENTITY;

ENTITY draughting_annotation_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1:	-- curve_has_curve_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
         AND ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE'
                 IN TYPEOF (sty.styles[1]))) )) = 0);
  WR2:	-- fill_area_has_fill_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
      NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR3:	-- styled_fill_boundaries:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (bound <*
                     SELF.item\annotation_fill_area.boundaries |
       NOT (SIZEOF (QUERY (si <*
                   USEDIN (bound, 'PRESENTATION_APPEARANCE_SCHEMA.' +
                                  'STYLED_ITEM.ITEM') |
         ('AIC_DRAUGHTING_ANNOTATION.' +
             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) > 0))) = 0);
  WR4:	-- symbol_has_symbol_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)           AND
            (SIZEOF (TYPEOF (sty.styles[1]) *
                ['AIC_DRAUGHTING_ANNOTATION.SYMBOL_STYLE',
                 'AIC_DRAUGHTING_ANNOTATION.NULL_STYLE']) = 1)) )) = 0);
  WR5:	-- allowable_symbol_representations:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
             IN TYPEOF(SELF.item)))) OR
         (SIZEOF (['AIC_DRAUGHTING_ANNOTATION.' +
                   'DRAUGHTING_SYMBOL_REPRESENTATION',
                  'AIC_DRAUGHTING_ANNOTATION.' +
                  'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *
          TYPEOF (SELF.item\mapped_item.mapping_source.
                  mapped_representation)) = 1);
  WR6:	-- text_has_text_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR7:	-- allowable_text:
     (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF))) OR
         (SIZEOF (TYPEOF(SELF.item) *
             ['AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT',
              'AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL']) = 1);
  WR8:	-- text_not_nested:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR    (SIZEOF (QUERY (tl <*
                   SELF.item\composite_text.collected_text |
             NOT ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' 
             IN TYPEOF (tl)) )) = 0);
  WR9:	-- text_alignment_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL'
             IN TYPEOF (SELF.item)))) OR (SELF.item\text_literal.alignment 
             IN ['baseline left', 'baseline centre', 'baseline right']);
  WR10:	-- text_alignment_composites:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <* SELF.
                  item\composite_text.collected_text
             |('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF(text))) |
          NOT (tl\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right']) )) = 0);
  WR11:	-- single_text_alignment:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_alignment(SELF.item);
  WR12:	-- single_text_font:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_font(SELF.item);
  WR13:	-- allowable_text_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
               IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <*
            SELF.item\composite_text.collected_text |
            ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF (text))) |
             NOT (SIZEOF (TYPEOF(tl) *
                  ['AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_BLANKING_BOX',
                   'AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0) )) = 0);
  WR14:	-- styled_text_literal_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                   SELF.item\text_literal_with_associated_curves.
                   associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 
             'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
        ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si)) )) > 0) )) = 0);
  WR15:	-- styled_composite_text_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
          (SIZEOF (QUERY (crv <*
                SELF.item\composite_text_with_associated_curves.
                associated_curves |
           NOT (SIZEOF (QUERY (si <*  USEDIN (crv,
                'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
               ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
           IN TYPEOF (si)) )) > 0) )) = 0);
WR16:	-- curve_style_has_width:
    SIZEOF (QUERY (cs <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE' IN TYPEOF (sty.styles[1])))
      | NOT (('AIC_DRAUGHTING_ANNOTATION.LENGTH_MEASURE_WITH_UNIT'
        IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND
       ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (cs.styles[1]\curve_style.
        curve_width\measure_with_unit.value_component))))) = 0;
WR17:	-- tiling_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
          IN TYPEOF (sty.styles[1]))) |
      NOT ((SIZEOF (QUERY (fs <* fas.styles[1]\fill_area_style.fill_styles
                    | ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                       IN TYPEOF (fs)))) <= 1)
       AND (SIZEOF (QUERY (fst <* QUERY (fs <*
                           fas.styles[1]\fill_area_style.fill_styles |
              ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs))) |
                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)
           )) = 0))
    )) = 0;
  WR18:	-- hatching_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
           ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE' 
            IN TYPEOF (sty.styles[1]))) |
             NOT (SIZEOF (QUERY (fsh <* QUERY (fs <*
                          fas.styles[1]\fill_area_style.fill_styles |
             ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_HATCHING'
               IN TYPEOF (fs))) |
        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:
             fsh\fill_area_style_hatching.pattern_start)  )) = 0)  )) = 0;
  WR19:	-- text_style_constraint:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE' 
         IN TYPEOF(sty.styles[1]))) |
             NOT ('AIC_DRAUGHTING_ANNOTATION.' +
                  'TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (ts.styles[1])))) = 0;
  WR20:	-- text_style_characteristics:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (sty.styles[1]))) |
           NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.
                characteristics) = 4) )) = 0;
END_ENTITY;

ENTITY draughting_subfigure_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_OCCURRENCE',
              'AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_CALLOUT',
              'GEOMETRY_SCHEMA.AXIS2_PLACEMENT']
               * TYPEOF (item)) = 1))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
         SIZEOF (['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_OCCURRENCE',
                  'AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_CALLOUT'] *
           TYPEOF (item)) = 1)) >= 1;
  WR3: SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('AIC_DRAUGHTING_ANNOTATION.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) | 
            NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
          | NOT (SIZEOF (QUERY (aso <*
            USEDIN (a_s, 'PRESENTATION_APPEARANCE_SCHEMA.' + 
                         'STYLED_ITEM.ITEM') |
          NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
            IN TYPEOF(aso)))) = 0))) = 0))) > 0;
  WR4: NOT (acyclic_mapped_item_usage (SELF));
  WR5: SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_symbol_representation
  SUBTYPE of (symbol_representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         NOT (SIZEOF (TYPEOF (item) *
            ['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE',
             'GEOMETRY_SCHEMA.AXIS2_PLACEMENT']) = 1)
       )) = 0;
  WR2: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         (SIZEOF (TYPEOF (item) *
            ['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE']) = 1)
       )) >= 1;
  WR3: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
          IN TYPEOF (item))) = 0;
  WR4: 
    SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('REPRESENTATION_SCHEMA.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) |
         NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
           ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL' IN TYPEOF(mi))) |
         NOT (SIZEOF (QUERY(aso <*
             USEDIN(a_s, 'PRESENTATION_APPEARANCE_SCHEMA.' +
                         'STYLED_ITEM.ITEM') |
             NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
                  IN TYPEOF(aso))
          )) = 0) )) = 0) )) > 0;
  WR5: 
    NOT (acyclic_mapped_item_usage (SELF));
  WR6: 
    SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_text_literal_with_delineation
  SUBTYPE OF (text_literal_with_delineation);
WHERE
  WR1: SELF.delineation IN ['underline', 'overline'];
END_ENTITY;

FUNCTION acyclic_mapped_item_usage (rep: representation) : BOOLEAN;
  -- returns TRUE if the representation contains one or more mapped_items
  -- that are a mapping of the representation itself
  LOCAL
    items : SET OF representation_item;
  END_LOCAL;

  items := QUERY (item <* rep.items |
           'AIC_DRAUGHTING_ANNOTATION.MAPPED_ITEM' IN TYPEOF (item));
  IF SIZEOF (items) = 0
  THEN 
    RETURN (FALSE);
  ELSE 
    REPEAT i := 1 TO HIINDEX (items);
      IF items[i]\mapped_item.mapping_source.mapped_representation :=: rep
      THEN 
        RETURN (TRUE);
      ELSE 
        RETURN (acyclic_mapped_item_usage(items[i]\
                  mapped_item.mapping_source.mapped_representation));
      END_IF;
    END_REPEAT;
  RETURN (FALSE);
  END_IF;
END_FUNCTION;

FUNCTION check_text_alignment (ct : composite_text) : BOOLEAN;

  LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF(a) = 1);
END_FUNCTION;

FUNCTION check_text_font (ct : composite_text) : BOOLEAN;

  LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF(f) <= 1);
END_FUNCTION;

END_SCHEMA; -- aic_draughting_annotation
(*
  This is the EXPRESS of the IS version of ISO 10303-506.
  This document is ISO TC 184/SC4/WG12 N488.
*)

SCHEMA aic_draughting_elements;

USE FROM draughting_element_schema	-- ISO 10303-101
  (dimension_curve,
   dimension_curve_directed_callout,
   dimension_curve_terminator,
   draughting_callout,
   draughting_callout_relationship,
   leader_curve,
   leader_directed_callout,
   leader_terminator,
   projection_curve,
   projection_directed_callout);

USE FROM presentation_definition_schema	-- ISO 10303-46
  (annotation_text_occurrence);

ENTITY angular_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY curve_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY datum_feature_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY datum_target_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY diameter_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY dimension_callout_component_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['prefix', 'suffix'];
  WR2: 'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT'
           IN TYPEOF (SELF.relating_draughting_callout);
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
  WR5: ((SELF.name = 'prefix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'prefix text')
       )) = 0));
 
  WR6: ((SELF.name = 'suffix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'suffix text')
       )) = 0));
END_ENTITY;

ENTITY dimension_callout_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['primary', 'secondary'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) * 
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])>=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
END_ENTITY;

ENTITY dimension_pair
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['chained', 'parallel'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
END_ENTITY;

ENTITY draughting_elements
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (QUERY (l_c <* QUERY (con <* SELF.contents |
              ('AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF(con))) |
              NOT (SIZEOF (QUERY (ldc <* USEDIN (l_c,
               'DRAUGHTING_ELEMENT_SCHEMA.' + 'DRAUGHTING_CALLOUT.CONTENTS') |
              ('AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT'
              IN TYPEOF (ldc)))) <= 1)))=0;
  WR2: NOT    ('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE_DIRECTED_CALLOUT'
              IN TYPEOF(SELF)) OR
              (SIZEOF (QUERY (con <* SELF.contents |
              ('AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN
               TYPEOF (con)))) <= 2);
  WR3: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
              ('AIC_DRAUGHTING_ELEMENTS.' +
               'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
              (rc.name = 'primary') )) <= 1;
  WR4: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
                (rc.name = 'secondary') )) <= 1;
  WR5: SIZEOF (QUERY (sec <* QUERY (rc <* USEDIN (SELF,
               'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND         
                (rc.name = 'secondary') ) |
         NOT (SIZEOF (QUERY (prim <* USEDIN (SELF,
               'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (prim)) AND         
                (prim.name = 'primary') )) = 1))) = 0;  
END_ENTITY;

ENTITY geometrical_tolerance_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY leader_directed_dimension
  SUBTYPE OF (leader_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF (con)))=1;
END_ENTITY;

ENTITY linear_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY ordinate_dimension
   SUBTYPE OF (projection_directed_callout);
END_ENTITY;

ENTITY radius_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN TYPEOF (con)))<=1;
END_ENTITY;

ENTITY structured_dimension_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (TYPEOF (SELF) *
       ['AIC_DRAUGHTING_ELEMENTS.DATUM_FEATURE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DATUM_TARGET_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.GEOMETRICAL_TOLERANCE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0;
  WR2: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         NOT (ato.name IN
             ['dimension value', 'tolerance value', 'unit text',
              'prefix text', 'suffix text']))) = 0;
  WR3: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         (ato.name = 'dimension value')
       )) >= 1;
  WR4: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'prefix') )) <= 1;
  WR5: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'suffix') )) <= 1;
  WR6: NOT((SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con)) ) |
         (ato.name = 'prefix text')
       )) > 0)) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND  
         (dcr.name = 'prefix') )) = 1);
  WR7: NOT(SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         (ato.name = 'suffix text')
       )) > 0) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND    
            (dcr.name = 'suffix') )) = 1);
END_ENTITY;

END_SCHEMA;
(*

This EXPRESS file is WG12 N997
*)



SCHEMA aic_drawing_structure_and_administration;



USE FROM approval_schema    -- ISO 10303-41

  (approval,

   approval_date_time,

   approval_person_organization);



USE FROM date_time_schema   -- ISO 10303-41

  (calendar_date);



USE FROM drawing_definition_schema  -- ISO 10303-101

  (draughting_title,

   drawing_revision,

   drawing_sheet_revision,

   drawing_sheet_revision_usage);



USE FROM geometry_schema    -- ISO 10303-42

  (axis2_placement_2d);



USE FROM management_resources_schema    -- ISO 10303-41

  (approval_assignment,

   contract_assignment,

   document_reference,

   organization_assignment,

   person_and_organization_assignment,

   person_assignment,

   security_classification_assignment);



USE FROM person_organization_schema -- ISO 10303-41

  (organizational_address,

   personal_address);



USE FROM presentation_definition_schema -- ISO 10303-46

  (annotation_occurrence);



USE FROM presentation_organization_schema   -- ISO 10303-46

  (camera_image,

   presentation_size,

   presentation_view,

   presented_item,

   presented_item_representation);



USE FROM product_definition_schema  -- ISO 10303-41

  (product,

   product_definition,

   product_definition_formation);


TYPE approved_item = SELECT
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE classified_item = SELECT
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE contracted_item = SELECT
  (drawing_revision);
END_TYPE;

TYPE draughting_organization_item = SELECT
  (product_definition_formation,
   drawing_revision,
   drawing_sheet_revision);
END_TYPE;

TYPE draughting_presented_item_select = SELECT
  (product_definition_formation);
END_TYPE;

TYPE specified_item = SELECT
  (drawing_revision);
END_TYPE;

ENTITY draughting_approval_assignment
  SUBTYPE OF (approval_assignment);
  approved_items : SET [1:?] OF approved_item;
WHERE
  WR1: SIZEOF (QUERY (item <* approved_items |
       'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_REVISION'
       IN TYPEOF (item)))<=1;
END_ENTITY;

ENTITY draughting_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contracted_item;
END_ENTITY;


ENTITY draughting_drawing_revision

  SUBTYPE OF (drawing_revision);

WHERE

  WR1:  -- drawing_requires_sheets:

    (SIZEOF (USEDIN (SELF,

      'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET')) >= 1)

       AND 

    (SIZEOF (QUERY (ais <* USEDIN (SELF,

       'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') | 

        NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_SHEET_REVISION'

        IN TYPEOF (ais.area))

    )) = 0);

  WR2:   -- drawing_approval_has_date:

    SIZEOF (QUERY (app_ass <* USEDIN (SELF,

                         'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |

       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,

          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

          'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)

    )) = 0;

  WR3:  -- sheet_approval_has_date:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

           NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,

             'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

             'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |

        NOT (SIZEOF (USEDIN (app_ass.assigned_approval,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

            'APPROVAL_DATE_TIME.DATED_APPROVAL')) = 1)

      )) = 0)

    )) = 0;

  WR4:  -- drawing_approval_has_authorization:

    SIZEOF (QUERY (app_ass <* USEDIN (SELF,

                         'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                         'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |

       NOT (SIZEOF (USEDIN (app_ass.assigned_approval,

           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

           'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)

    )) = 0;

  WR5:  -- sheet_approval_has_authorization:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

              NOT (SIZEOF (QUERY (app_ass <* USEDIN (ais.area,

                'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                'DRAUGHTING_APPROVAL_ASSIGNMENT.APPROVED_ITEMS') |

                NOT (SIZEOF (USEDIN (app_ass.assigned_approval,

                     'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                     'APPROVAL_PERSON_ORGANIZATION.AUTHORIZED_APPROVAL')) >= 1)

              )) = 0)

    )) = 0;

  WR6:  -- drawing_title:

    SIZEOF (USEDIN (SELF, 'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                          'DRAUGHTING_TITLE.ITEMS')) <= 1;

  WR7:  -- sheet_title:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |   

             NOT (SIZEOF (USEDIN (ais.area,

                          'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                          'DRAUGHTING_TITLE.ITEMS')) <= 1)

    )) = 0;

  WR8:  -- allowable_items_of_sheet:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |   

            NOT (SIZEOF (QUERY (item <* ais.area.items |

            NOT (SIZEOF (TYPEOF(item) *

              ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.STYLED_ITEM',

              'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM',

              'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT',

              'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PLANAR_BOX']) = 1)

      )) = 0)

    )) = 0;

  WR9:  -- sheet_contains_view_or_annotation:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

            NOT (SIZEOF (QUERY (item <* ais.area.items |

             (SIZEOF (TYPEOF(item) *

               ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.STYLED_ITEM',

                'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM']) = 1)

      )) > 0)

    )) = 0;

  WR10: -- planar_box_in_sheet:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

              NOT (SIZEOF (QUERY (p_b <* 

                QUERY (item <* ais.area.items |

                  ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PLANAR_BOX' 

                   IN TYPEOF(item))) |

                   NOT (SIZEOF (USEDIN (p_b, 'AIC_DRAWING_STRUCTURE_AND_' +

                        'ADMINISTRATION.PRESENTATION_SIZE.SIZE')  ) = 1)

      )) = 0)

    )) = 0;

  WR11:  -- sheets_contain_views:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

            NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

           ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

           IN TYPEOF(item))) |

             NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.PRESENTATION_VIEW'

               IN TYPEOF(mi.mapping_source.mapped_representation))

      )) = 0)

    )) = 0;

  WR12:  -- sheets_contain_placements:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

              NOT (SIZEOF (QUERY (a2p <* QUERY (item <* ais.area.items |

               ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT'

              IN TYPEOF(item))) |

                NOT (SIZEOF (USEDIN (a2p,

                             'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                             'MAPPED_ITEM.MAPPING_TARGET')) > 0)

      )) = 0)

    )) = 0;

  WR13: -- sheets_have_unique_context:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

              NOT (SIZEOF (ais.area.context_of_items.

                   representations_in_context) = 1)   )) = 0;

  WR14: -- views_presented_once:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

           'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

      NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

             ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

                 IN TYPEOF(item))) |

        NOT (SIZEOF (USEDIN (mi.mapping_source.mapped_representation,

                        'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION')) = 1)

      )) = 0)

    )) = 0;

  WR15: -- allowable_items_of_view:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

             NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

               ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

               IN TYPEOF(item))) |

                 NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.

                              mapped_representation.items |

                   NOT (SIZEOF (TYPEOF(pv_item) *

                     ['AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                      'STYLED_ITEM',

                      'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.CAMERA_IMAGE',

                      'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                      'AXIS2_PLACEMENT']) = 1)

        )) = 0)

      )) = 0)

    )) = 0;

  WR16: -- views_contain_one_projection:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

            NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

                ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

                IN TYPEOF(item))) |

                NOT (SIZEOF (QUERY (pv_item <* mi.mapping_source.

                             mapped_representation.items |

                    ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.CAMERA_IMAGE'

                    IN TYPEOF(pv_item))

                )) = 1)

            )) = 0)

    )) = 0;

  WR17: -- views_contain_one_placement:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

              NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

                ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

                IN TYPEOF(item))) |

                NOT (SIZEOF (QUERY (a2p <* QUERY (pv_item <* mi.mapping_source.

                       mapped_representation.items |

                    ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AXIS2_PLACEMENT'

                      IN TYPEOF(pv_item))) |

                     ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +

                      'REPRESENTATION_MAP.MAPPING_SOURCE' IN ROLESOF (a2p))

                  )) = 1)

              )) = 0)

    )) = 0;

  WR18: -- views_have_unique_context:

    SIZEOF (QUERY (ais <* USEDIN (SELF,

            'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.AREA_IN_SET.IN_SET') |

             NOT (SIZEOF (QUERY (mi <* QUERY (item <* ais.area.items |

                 ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.MAPPED_ITEM'

                 IN TYPEOF(item))) |

        NOT (SIZEOF (mi.mapping_source.

                     mapped_representation.context_of_items.

                     representations_in_context) = 1)

      )) = 0)

    )) = 0;

END_ENTITY;


ENTITY draughting_organization_assignment
  SUBTYPE OF (organization_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_person_assignment
  SUBTYPE OF (person_assignment);
  assigned_items : SET [1:?] OF draughting_organization_item;
END_ENTITY;

ENTITY draughting_presented_item
  SUBTYPE OF (presented_item);
  items : SET [1:?] OF draughting_presented_item_select;
WHERE
  WR1:                                        -- presented_item_presentation:
       SIZEOF (QUERY (pir <* USEDIN (SELF,
                'AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.' +
                'PRESENTED_ITEM_REPRESENTATION.ITEM') |
          NOT ('AIC_DRAWING_STRUCTURE_AND_ADMINISTRATION.DRAWING_REVISION'
                IN TYPEOF (pir.presentation)) )) = 0;
END_ENTITY;

ENTITY draughting_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  assigned_items : SET [1:?] OF classified_item;
END_ENTITY;

ENTITY draughting_specification_reference
  SUBTYPE OF (document_reference);
  specified_items : SET [1:?] OF specified_item;
WHERE
  WR1: (SELF.assigned_document.kind.product_data_type =
        'draughting specification');
END_ENTITY;


END_SCHEMA;SCHEMA aic_edge_based_wireframe;
  
USE FROM geometric_model_schema ( edge_based_wireframe_model);
 USE FROM geometry_schema ( axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
 USE FROM topology_schema ( edge_curve, vertex_point);
  
ENTITY edge_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL', 'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM', 'AIC_EDGE_BASED_WIREFRAME.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL', 'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT ('AIC_EDGE_BASED_WIREFRAME.EDGE_CURVE' IN TYPEOF (edges)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( pline_edges <* 
QUERY ( edges <* eb.ces_edges| ('AIC_EDGE_BASED_WIREFRAME.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND ('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (edges.edge_end))) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_EDGE_BASED_WIREFRAME.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR9 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
  
FUNCTION valid_wireframe_edge_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.LINE', 'AIC_EDGE_BASED_WIREFRAME.CONIC', 'AIC_EDGE_BASED_WIREFRAME.B_SPLINE_CURVE', 'AIC_EDGE_BASED_WIREFRAME.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_wireframe_vertex_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_EDGE_BASED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
 SCHEMA aic_faceted_brep;
  
USE FROM geometry_schema ( axis2_placement_3d, cartesian_point, cartesian_transformation_operator_3d, elementary_surface, plane);
 USE FROM geometric_model_schema ( brep_with_voids, faceted_brep, manifold_solid_brep);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, face_bound, face_outer_bound, face_surface, oriented_closed_shell, poly_loop);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY faceted_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* items| NOT ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM', 'AIC_FACETED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* items| ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('AIC_FACETED_BREP.FACE_SURFACE' IN TYPEOF (fcs)) AND (('AIC_FACETED_BREP.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('AIC_FACETED_BREP.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( 
QUERY ( bnds <* fcs.bounds| ('AIC_FACETED_BREP.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_FACETED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 SCHEMA aic_geometric_tolerances;
  
USE FROM measure_schema ( derived_unit, named_unit);
 USE FROM product_property_definition_schema ( shape_aspect_relationship);
 USE FROM shape_aspect_definition_schema ( apex, centre_of_symmetry, composite_shape_aspect, datum, datum_feature, datum_reference, datum_target, derived_shape_aspect, extension, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, referenced_modified_datum, shape_aspect_deriving_relationship, symmetric_shape_aspect, tangent);
 USE FROM shape_tolerance_schema ( dimension_related_tolerance_zone_element, geometric_tolerance, geometric_tolerance_relationship, geometric_tolerance_with_datum_reference, geometric_tolerance_with_defined_unit, modified_geometric_tolerance, projected_zone_definition, runout_zone_definition, runout_zone_orientation_reference_direction, tolerance_zone, tolerance_zone_definition);
  
ENTITY angularity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
 END_ENTITY ;
ENTITY circular_runout_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
ENTITY coaxiality_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
ENTITY common_datum 
 SUBTYPE OF ( composite_shape_aspect , datum );
 WHERE 
WR1 : 
SIZEOF (SELF.component_relationships) = 2;
WR2 : 
SIZEOF ( 
QUERY ( sar <* SELF.component_relationships| NOT (('AIC_GEOMETRIC_TOLERANCES.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND NOT ('AIC_GEOMETRIC_TOLERANCES.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0;
 END_ENTITY ;
ENTITY concentricity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) = 1;
 END_ENTITY ;
ENTITY cylindricity_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
ENTITY flatness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
ENTITY line_profile_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
WR2 : 
SIZEOF ( 
QUERY ( sar <* USEDIN (SELF\geometric_tolerance.toleranced_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.name IN [ 'affected plane association', 'resulting intersection curve association' ]) )) = 1;
 END_ENTITY ;
ENTITY parallelism_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) < 3;
 END_ENTITY ;
ENTITY perpendicularity_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
 END_ENTITY ;
ENTITY position_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
 END_ENTITY ;
ENTITY roundness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
ENTITY straightness_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
 END_ENTITY ;
ENTITY surface_profile_tolerance 
 SUBTYPE OF ( geometric_tolerance );
 WHERE 
WR1 : NOT ('AIC_GEOMETRIC_TOLERANCES.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3);
 END_ENTITY ;
ENTITY symmetry_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 3;
 END_ENTITY ;
ENTITY total_runout_tolerance 
 SUBTYPE OF ( geometric_tolerance_with_datum_reference );
 WHERE 
WR1 : 
SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) <= 2;
 END_ENTITY ;
END_SCHEMA;
 (* EXPRESS short form corresponding to 10303-503 IS 
   WG12 N376 *)
SCHEMA aic_geometrically_bounded_2d_wireframe;
USE FROM geometric_model_schema    -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);
USE FROM geometry_schema -- ISO 10303-42
   (axis2_placement_2d,
    b_spline_curve_with_knots,
    bezier_curve,
    circle,
    composite_curve,
    composite_curve_segment,
    curve,
    curve_replica,
    ellipse,
    geometric_representation_context,
    hyperbola,
    line,
    offset_curve_2d,
    parabola,
    point_on_curve,
    polyline,
    quasi_uniform_curve,
    rational_b_spline_curve,
    trimmed_curve,
    uniform_curve);
USE FROM product_property_representation_schema -- ISO 10303-41
   (shape_representation);
USE FROM representation_schema -- ISO 10303-43
   (mapped_item);
ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
           
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *
          
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         ('AIC_- GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT',
                'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
  WR8: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
        
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
           IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pl <* 
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE'
                  IN TYPEOF (elem))) |
             NOT (SIZEOF (pl\polyline.points) > 2)
         )) = 0)
       )) = 0;
END_ENTITY;
FUNCTION valid_basis_curve_in_2d_wireframe
   (crv: curve) : BOOLEAN;
   -- check for valid basic curve types
  IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.LINE',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.PARABOLA',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

END_SCHEMA;  --aic_geometrically_bounded_2d_wireframe



(* ISO 10303-507, TC 184/SC4/WG12 N564 *)

SCHEMA aic_geometrically_bounded_surface;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 

USE FROM geometric_model_schema   -- ISO 10303-42
  (geometric_set); 

USE FROM geometry_schema   -- ISO 10303-42
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   b_spline_curve,
   b_spline_curve_with_knots,
   b_spline_surface,
   b_spline_surface_with_knots,
   bezier_curve,
   bezier_surface,
   boundary_curve,
   bounded_pcurve,
   bounded_surface_curve,
   cartesian_point,
   cartesian_transformation_operator_3d,
   circle,
   composite_curve,
   composite_curve_on_surface,
   composite_curve_segment,
   conical_surface,
   curve,
   curve_bounded_surface,
   curve_replica,
   cylindrical_surface,
   degenerate_pcurve,
   degenerate_toroidal_surface,
   direction,
   ellipse,
   evaluated_degenerate_pcurve,
   geometric_representation_context,
   hyperbola,
   intersection_curve,
   line,
   offset_curve_3d,
   offset_surface,
   outer_boundary_curve,
   parabola,
   pcurve,
   plane,
   point,
   point_on_curve,
   point_on_surface,
   polyline,
   quasi_uniform_curve,
   quasi_uniform_surface,
   rational_b_spline_curve,
   rational_b_spline_surface,
   rectangular_composite_surface,
   rectangular_trimmed_surface,
   reparametrised_composite_curve_segment,
   seam_curve,
   spherical_surface,
   surface,
   surface_curve,
   surface_of_linear_extrusion,
   surface_of_revolution,
   surface_patch,
   surface_replica,
   swept_surface,
   toroidal_surface,
   trimmed_curve,
   uniform_curve,
   uniform_surface,
   vector); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

USE FROM representation_schema   -- ISO 10303-43
  (definitional_representation,
   mapped_item,
   parametric_representation_context,
   representation,
   representation_item,
   representation_map); 


ENTITY geometrically_bounded_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it <* SELF.items | NOT (SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
  WR2: SIZEOF(QUERY(it <* SELF.items | SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
  WR3: SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' IN TYPEOF(it)) | NOT (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it <* mi\mapped_item.mapping_source.mapped_representation.items | ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(mr_it)))) > 0)))) = 0;
  WR4: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT' IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0;
  WR5: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE' IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0;
  WR6: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0;
  WR7: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | SIZEOF(QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(gsel))) > 0)) > 0;
END_ENTITY;

FUNCTION gbsf_check_point
 (pnt : point) : BOOLEAN; 
  IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

FUNCTION gbsf_check_curve
 (cv : representation_item) : BOOLEAN; 
  IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.BOUNDED_CURVE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONIC', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.LINE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.CIRCLE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.ELLIPSE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg <* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) >= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

FUNCTION gbsf_check_surface
 (sf : surface) : BOOLEAN; 
  IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.SPHERICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TOROIDAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_BOUNDED_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_TRIMMED_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_REPLICA' IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_OF_REVOLUTION' IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

END_SCHEMA;  -- aic_geometrically_bounded_surface
SCHEMA aic_geometrically_bounded_wireframe;
  
USE FROM geometric_model_schema ( geometric_curve_set, geometric_set);
 USE FROM geometry_schema ( axis1_placement, axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, composite_curve, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_on_curve, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, reparametrised_composite_curve_segment, trimmed_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
  
ENTITY geometrically_bounded_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ( TYPEOF (it) * [ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' ]) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ( TYPEOF (it) * [ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' ]) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( crv <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_curve(crv) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pnts <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_point(pnts) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( cnc <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CONIC' IN TYPEOF (elem)) )| NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D' IN TYPEOF (cnc\conic.position)) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pline <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE' IN TYPEOF (elem)) )| NOT ( SIZEOF (pline\polyline.points) > 2) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
  
FUNCTION valid_geometrically_bounded_wf_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.B_SPLINE_CURVE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.ELLIPSE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CIRCLE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.TRIMMED_CURVE' IN TYPEOF (crv) THEN 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.LINE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.PARABOLA', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.HYPERBOLA' ] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.COMPOSITE_CURVE' IN TYPEOF (crv) THEN 
 RETURN ( SIZEOF ( 
QUERY ( ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve) )) = 0);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_geometrically_bounded_wf_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
  (* part 521 Manifold subsurface AIC EXPRESS listing WG12 N1308
 2002-07-23 *)
 SCHEMA aic_manifold_subsurface;  --- extracted from part 521 IS WG12 N1307
  USE FROM aic_topologically_bounded_surface; -- ISO 10303-511

  USE FROM geometry_schema    -- ISO  10303-42
      (cartesian_transformation_operator_3d);
  USE FROM topology_schema  -- ISO  10303-42
      (closed_shell,
       connected_face_set,
       connected_face_sub_set,
       face,
       open_shell,
       subedge,
       subface);

  USE FROM representation_schema(mapped_item);   -- ISO  10303-43

  USE FROM product_property_representation_schema   -- ISO  10303-41
      (shape_representation);

 ENTITY manifold_subsurface_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1: SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
                'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM',
                'AIC_MANIFOLD_SUBSURFACE.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
         'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AIC_MANIFOLD_SUBSURFACE.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR4: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('AIC_MANIFOLD_SUBSURFACE.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
   WR5: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT( (('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN
                   TYPEOF(cfss.parent_face_set)) AND
            (SIZEOF (QUERY (fac <* cfss.parent_face_set.cfs_faces | NOT
                 advanced_face_properties(fac))) = 0)) OR
             (SIZEOF (QUERY (fac <* cfss.parent_face_set.cfs_faces | NOT
              ('AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(fac)))) = 0)
                    ))) = 0;
   WR6: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          ( SIZEOF (QUERY (fac <* cfss\connected_face_set.cfs_faces  | NOT
              advanced_face_properties(fac))) = 0))) = 0;
   WR7: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
               ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('AIC_MANIFOLD_SUBSURFACE.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('AIC_MANIFOLD_SUBSURFACE.SUBEDGE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
   WR8: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUBSET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
   WR9: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP',
                'AIC_MANIFOLD_SUBSURFACE.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 )
                   )) = 0)
                 ))) = 0
             ))) = 0;
   WR10: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.LINE',
                         'AIC_MANIFOLD_SUBSURFACE.CONIC',
                         'AIC_MANIFOLD_SUBSURFACE.POLYLINE',
                         'AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE',
                         'AIC_MANIFOLD_SUBSURFACE.B_SPLINE_CURVE' ] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 )))) = 0
                    ))) = 0;
   WR11: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUBSET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT ((SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
   WR12: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUBSET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
 END_ENTITY;

FUNCTION advanced_face_properties (testface : face) : BOOLEAN;
(* return TRUE if testface is of type advanced_face *)
IF 'AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(testface)) THEN
   RETURN(advanced_face_properties(testface.parent_face));
   ELSE  RETURN (FALSE);
END_IF;
END_FUNCTION;

END_SCHEMA; -- end AIC_MANIFOLD_SUBSURFACE SCHEMA
(* ISO 10303-509, TC 184/SC4/WG12 N578 *)
SCHEMA aic_manifold_surface; 
 
  USE FROM aic_topologically_bounded_surface;       -- ISO 10303-511
 
  USE FROM geometric_model_schema (                 -- ISO 10303-42
      shell_based_surface_model); 
 
  USE FROM geometry_schema (                        -- ISO 10303-42
      b_spline_curve,
      b_spline_surface,
      bounded_pcurve,
      bounded_surface_curve,
      cartesian_transformation_operator_3d,
      curve, 
      curve_replica, 
      degenerate_pcurve, 
      evaluated_degenerate_pcurve, 
      intersection_curve, 
      offset_curve_3d, 
      offset_surface, 
      point_on_curve, 
      point_on_surface, 
      seam_curve, 
      surface, 
      surface_replica); 

  USE FROM product_property_representation_schema ( -- ISO 10303-41 
      shape_representation); 
 
  USE FROM representation_schema (                  -- ISO 10303-43
      mapped_item,
      representation,
      representation_item,
      representation_map);
 
  USE FROM topology_schema (                        -- ISO 10303-42
      closed_shell,
      connected_face_set, 
      face,
      open_shell, 
      oriented_closed_shell);

ENTITY manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AIC_MANIFOLD_SURFACE.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.OPEN_SHELL',
       'AIC_MANIFOLD_SURFACE.ORIENTED_CLOSED_SHELL',
       'AIC_MANIFOLD_SURFACE.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT ('AIC_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.EDGE_LOOP',
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.B_SPLINE_CURVE',
       'AIC_MANIFOLD_SURFACE.CONIC',
       'AIC_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_MANIFOLD_SURFACE.LINE',
       'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_MANIFOLD_SURFACE.PCURVE',
       'AIC_MANIFOLD_SURFACE.POLYLINE',
       'AIC_MANIFOLD_SURFACE.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR14: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION msf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)

(* complex subtypes of curve that are both bounded_curve and
   oneof conic, curve_replica, line, or offset_curve_3d are not
   valid
*)
IF SIZEOF (['AIC_MANIFOLD_SURFACE.BOUNDED_CURVE',
  'AIC_MANIFOLD_SURFACE.CONIC',
  'AIC_MANIFOLD_SURFACE.CURVE_REPLICA', 'AIC_MANIFOLD_SURFACE.LINE',
  'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
  RETURN(FALSE);
END_IF;

(* b_spline_curves shall not self-intersect
 *)
IF (('AIC_MANIFOLD_SURFACE.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE

  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['AIC_MANIFOLD_SURFACE.CONIC', 'AIC_MANIFOLD_SURFACE.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    (* a curve_replica shall reference a valid curve
     *)
    IF 'AIC_MANIFOLD_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve)); 
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('AIC_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve)); 
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'AIC_MANIFOLD_SURFACE.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'AIC_MANIFOLD_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN 

            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);

                (* do for one or two associated_geometrys:
                 *)
                IF 'AIC_MANIFOLD_SURFACE.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'AIC_MANIFOLD_SURFACE.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF; 
              END_REPEAT;  
              RETURN(TRUE);
            END_IF; 
          ELSE

            (* a polyline shall have at least 3 points
             *)
            IF 'AIC_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
END_IF; 
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE); 
END_FUNCTION;

FUNCTION msf_surface_check (surf : surface) : BOOLEAN;

(* This function varifies the validity of a surface in the
   context of a manifold surface model.
*)

  (* elementary_surfaces are valid surface types
   *)
  IF 'AIC_MANIFOLD_SURFACE.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AIC_MANIFOLD_SURFACE.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AIC_MANIFOLD_SURFACE.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AIC_MANIFOLD_SURFACE.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AIC_MANIFOLD_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

END_SCHEMA; (* aic_manifold_surface *)
--this is wg12n968
SCHEMA aic_mechanical_design_geometric_presentation;

    USE FROM geometry_schema                          -- ISO 10303-42
     (axis2_placement_2d,
      axis2_placement_3d); 

    USE FROM presentation_appearance_schema           -- ISO 10303-46
       (curve_style,
        curve_style_font, 
        curve_style_font_pattern,
        draughting_pre_defined_curve_font,
        fill_area_style_colour,
        invisibility,
        marker_type,
        over_riding_styled_item,
        point_style,
        presentation_style_by_context,
        styled_item,
        surface_side_style,
        surface_style_boundary,
        surface_style_control_grid, 
        surface_style_fill_area,
        surface_style_parameter_line,
        surface_style_segmentation_curve, 
        surface_style_silhouette, 
        surface_style_usage,
        u_direction_count,        
        v_direction_count);

    REFERENCE FROM presentation_organization_schema    -- ISO 10303-46
       (aspect_ratio);

    USE FROM presentation_organization_schema          -- ISO 10303-46
       (background_colour,
        camera_image_3d_with_scale,
        camera_usage,
        presentation_area,        
        presentation_representation,
        presentation_size,
        presentation_view);

    USE FROM presentation_resource_schema              -- ISO 10303-46
       (colour_rgb,
        draughting_pre_defined_colour,
        planar_extent);

    USE FROM product_property_representation_schema    -- ISO 10303-41
     (shape_representation);

    USE FROM representation_schema                     -- ISO 10303-43
       (mapped_item,
        representation); 

ENTITY mechanical_design_geometric_presentation_area
  SUBTYPE OF (presentation_area);
WHERE
  WR1:  -- only presentation_views or axis2_placements in
        -- mechanical_design_geometric_presentation_area
        SIZEOF(QUERY(it1 <* SELF.items |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF(it1))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1)) AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))))) = 0;
  WR2:  -- only mechanical_design_geometric_presentation_representation
        -- via camera_image_3d_with_scale or axis2_placements in
        -- presentation_views
        SIZEOF(QUERY(pv <* QUERY(mi1 <* QUERY(it1 <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1)) |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        -- search in all presentation_views for axis2_placements and
        -- mapped_items and for the subtype of mapped_item
        -- camera_image_3d_with_scale; the latter shall reference
        -- a mechanical_design_geometric_presentation_representation;
        -- the supertype mapped_item shall reference presentation_view.
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
  WR3:  (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | ((ps.size\planar_extent.size_in_x <= 0)
        OR
        (ps.size\planar_extent.size_in_y <= 0)))) = 0)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ((ps.size\planar_extent.size_in_x <= 0)
        OR
        (ps.size\planar_extent.size_in_y <= 0)))) > 0))) = 0);
  WR4:  (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)
        AND
        (SIZEOF(QUERY(ps <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)
        OR
        ((SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('GEOMETRY_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1))) = 1)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF\presentation_area,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0))) = 1));
END_ENTITY;

ENTITY mechanical_design_geometric_presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1:  SIZEOF(QUERY(it <* SELF.items |
        NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.AXIS2_PLACEMENT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CAMERA_MODEL_D3']
        * TYPEOF(it)) = 1))) = 0;
  WR2:  -- only shape_representations and
        -- mechanical_design_geometric_presentation_representations
        -- shall be referenced from mapped_items
        SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
  WR3:  -- a mapped_item that is styled shall reference a
        -- shape_representation
        SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
  WR4:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(pss <* psa.styles | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE']
        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0;
  WR5:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psbc <* QUERY(psa <* si\styled_item.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'REPRESENTATION_ITEM',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.REPRESENTATION']
        * TYPEOF(psbc\presentation_style_by_context.style_context))
        = 1))) = 0))) = 0;
  WR6:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ps <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE'
        IN TYPEOF(pss)) | NOT
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ps\point_style.marker_size))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ps\point_style.marker_colour))
        = 1)))) = 0))) = 0))) = 0;
  WR7:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(cs <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF(pss)) | NOT((SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(cs\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (cs\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
  WR8:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) |
        NOT ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_SIDE_STYLE' IN TYPEOF
        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0;
  WR9:  SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_FILL_AREA',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY']
        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0;
  WR10: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR11: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF 
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR12: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.
        curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR13: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
  WR14: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))
        = 0))) = 0))) = 0;
END_ENTITY;

END_SCHEMA;  
(* ISO 10303-508, TC 184/SC4/WG12 N571 *)
SCHEMA aic_non_manifold_surface; 
 
  USE FROM aic_topologically_bounded_surface;       -- ISO 10303-511
 
  USE FROM geometric_model_schema (                 -- ISO 10303-42
      face_based_surface_model); 
 
  USE FROM geometry_schema (                        -- ISO 10303-42
      b_spline_curve,
      b_spline_surface,
      bounded_pcurve,
      bounded_surface_curve,
      cartesian_transformation_operator_3d,
      curve, 
      curve_replica, 
      degenerate_pcurve, 
      evaluated_degenerate_pcurve, 
      intersection_curve, 
      offset_curve_3d, 
      offset_surface, 
      point_on_curve, 
      point_on_surface, 
      seam_curve, 
      surface, 
      surface_replica); 

  USE FROM product_property_representation_schema ( -- ISO 10303-41
      shape_representation); 
 
  USE FROM representation_schema (                  -- ISO 10303-43
      mapped_item,
      representation,
      representation_item,
      representation_map);
 
  USE FROM topology_schema (                        -- ISO 10303-42
      closed_shell,
      connected_face_set, 
      face,
      open_shell, 
      oriented_face);
 

ENTITY non_manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL',
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_NON_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1)))
       = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL',
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.'+
       'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR4: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_SURFACE',
       'AIC_NON_MANIFOLD_SURFACE.ORIENTED_FACE'] * TYPEOF (fa)) = 1)))
       = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces |
       ('AIC_NON_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa))) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (nmsf_surface_check(f_sf\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR6: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces |
       ('AIC_NON_MANIFOLD_SURFACE.ORIENTED_FACE' IN TYPEOF (fa))) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF 
       (o_fa\oriented_face.face_element))
       OR
       (nmsf_surface_check
       (o_fa\oriented_face.face_element\face_surface.face_geometry)))))
       = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP',
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items|
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AIC_NON_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.B_SPLINE_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.CONIC',
       'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_NON_MANIFOLD_SURFACE.LINE',
       'AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_NON_MANIFOLD_SURFACE.PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POLYLINE',
       'AIC_NON_MANIFOLD_SURFACE.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (nmsf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY(fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR14: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION nmsf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   non-manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)

 (* complex subtypes of curve that are both bounded_curve and
    oneof conic, curve_replica, line, or offset_curve_3d are not
    valid
 *)
 IF SIZEOF (['AIC_NON_MANIFOLD_SURFACE.BOUNDED_CURVE',
   'AIC_NON_MANIFOLD_SURFACE.CONIC',
   'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA',
   'AIC_NON_MANIFOLD_SURFACE.LINE',
   'AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
 THEN RETURN(FALSE);
 ELSE

  (* b_spline_curves shall not self-intersect
   *)
  IF (('AIC_NON_MANIFOLD_SURFACE.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE) OR
    (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN RETURN(TRUE);
  ELSE

    (* conics and lines are valid curve types
     *)
    IF SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CONIC',
    'AIC_NON_MANIFOLD_SURFACE.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE

      (* a curve_replica shall reference a valid curve
       *)
      IF 'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (nmsf_curve_check(cv\curve_replica.parent_curve)); 
      ELSE 
 
        (* an offset_curve_3d shall not self-intersect and
           shall reference a valid curve; a polyline is not a
           valid basis_curve
         *)
        IF (('AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D' IN TYPEOF (cv)) 
          AND
          ((cv\offset_curve_3d.self_intersect = FALSE) OR
          (cv\offset_curve_3d.self_intersect = UNKNOWN))
          AND
          (NOT ('AIC_NON_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF
          (cv\offset_curve_3d.basis_curve)))) THEN
          RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve)); 
        ELSE 
 
          (* a pcurve shall reference a valid curve and a valid
             basis_surface
           *)
          IF 'AIC_NON_MANIFOLD_SURFACE.PCURVE' IN TYPEOF(cv) THEN 
            RETURN ((nmsf_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1]))
            AND
            (nmsf_surface_check(cv\pcurve.basis_surface)));
          ELSE 
 
            (* a surface_curve references a curve_3d and one or
               two pcurves or one or two surfaces or one of
               each; all of these references shall be valid
             *)
            IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN 

              (* if the curve reference is correct, check also the rest
               *)
              IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);

                  (* do for one or two associated_geometrys:
                   *)
                  IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT nmsf_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'AIC_NON_MANIFOLD_SURFACE.PCURVE' IN TYPEOF 
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT nmsf_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF; 
                END_REPEAT;  
                RETURN(TRUE);
              END_IF; 
            ELSE

              (* a polyline shall have at least 3 points 
               *)
              IF 'AIC_NON_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
 END_IF; 
 (* FALSE is returned if the input parameter cv is not a valid curve.
  *)
 RETURN (FALSE); 
END_FUNCTION;

FUNCTION nmsf_surface_check (surf : surface) : BOOLEAN;

(* This function varifies the validity of a surface in the
   context of a non-manifold surface model.
*)

  (* elementary_surfaces are valid surface types
   *)
  IF 'AIC_NON_MANIFOLD_SURFACE.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AIC_NON_MANIFOLD_SURFACE.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AIC_NON_MANIFOLD_SURFACE.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AIC_NON_MANIFOLD_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(surf))
            AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

END_SCHEMA; (* aic_non_manifold_surface *)
SCHEMA aic_shell_based_wireframe;
  
USE FROM geometric_model_schema ( shell_based_wireframe_model);
 USE FROM geometry_schema ( axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
 USE FROM topology_schema ( edge_curve, edge_loop, path, vertex_loop, vertex_point, vertex_shell, wire_shell);
  
ENTITY shell_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL', 'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM', 'AIC_SHELL_BASED_WIREFRAME.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL', 'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT ('AIC_SHELL_BASED_WIREFRAME.EDGE_CURVE' IN TYPEOF (el.edge_element)) )) = 0) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( pline_el <* 
QUERY ( el <* eloop\path.edge_list| ('AIC_SHELL_BASED_WIREFRAME.POLYLINE' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))) )) = 0) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (vloop\vertex_loop.loop_vertex)) )) = 0) )) = 0) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0) )) = 0;
WR10 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)) )) = 0) )) = 0;
WR11 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0;
WR12 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR13 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
  
FUNCTION valid_wireframe_edge_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.LINE', 'AIC_SHELL_BASED_WIREFRAME.CONIC', 'AIC_SHELL_BASED_WIREFRAME.B_SPLINE_CURVE', 'AIC_SHELL_BASED_WIREFRAME.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_wireframe_vertex_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_SHELL_BASED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
 SCHEMA aic_topologically_bounded_surface;
  
USE FROM geometry_schema ( axis2_placement_2d, axis2_placement_3d, bezier_curve, bezier_surface, b_spline_curve_with_knots, b_spline_surface_with_knots, cartesian_point, circle, composite_curve_on_surface, conical_surface, cylindrical_surface, degenerate_toroidal_surface, direction, ellipse, geometric_representation_context, hyperbola, line, parabola, pcurve, plane, polyline, quasi_uniform_curve, quasi_uniform_surface, rational_b_spline_curve, rational_b_spline_surface, spherical_surface, surface_curve, surface_of_linear_extrusion, surface_of_revolution, swept_surface, toroidal_surface, uniform_curve, uniform_surface, vector);
 USE FROM topology_schema ( edge, edge_curve, edge_loop, face_bound, face_outer_bound, face_surface, oriented_edge, path, vertex_loop, vertex_point);
 USE FROM representation_schema ( definitional_representation, parametric_representation_context);
 USE FROM measure_schema ( parameter_value);
  
ENTITY advanced_face 
 SUBTYPE OF ( face_surface );
 WHERE 
WR1 : 
SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
WR2 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
WR6 : NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
WR7 : 
SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
WR10 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
 END_ENTITY ;
END_SCHEMA;
 (*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA application_context_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   id_attribute); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (year_number); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value (SELF);
  id : identifier := get_id_value (SELF);
INVERSE
  context_elements : SET[1:?] OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (library_context,
                       product_concept_context,
                       product_context,
                       product_definition_context));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;

ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;

END_SCHEMA;  -- application_context_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA approval_schema; 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_role,
   object_role,
   role_association); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_time_select); 

REFERENCE FROM person_organization_schema   -- ISO 10303-41
  (person_organization_select); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   text); 


ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;

ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

FUNCTION acyclic_approval_relationship
 (relation : approval_relationship; relatives : SET[1:?] OF approval; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- approval_schema
(* Copied from  TC184/SC4/WG12 N2649 *)
SCHEMA assembly_constraint_schema;

REFERENCE FROM assembly_feature_relationship_schema; -- ISO 10303-109
REFERENCE FROM explicit_constraint_schema; -- ISO 10303-108
REFERENCE FROM explicit_geometric_constraint_schema; -- ISO 10303-108
REFERENCE FROM geometry_schema; -- ISO 10303-42
REFERENCE FROM geometric_model_schema; -- ISO 10303-42
--REFERENCE FROM parameterization_schema; -- ISO 10303-108
REFERENCE FROM product_definition_schema; -- 10303-41
REFERENCE FROM product_structure_schema; -- ISO 10303-44
REFERENCE FROM representation_schema; -- ISO 10303-43
REFERENCE FROM support_resource_schema; -- 10303-41

ENTITY assembly_geometric_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
           (binary_assembly_constraint,
           fixed_constituent_assembly_constraint))
  SUBTYPE OF (explicit_constraint);

END_ENTITY;-- assembly_geometric_constraint

ENTITY binary_assembly_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
           (parallel_assembly_constraint,
            surface_distance_assembly_constraint_with_dimension,
             angle_assembly_constraint_with_dimension,
            perpendicular_assembly_constraint,
            incidence_assembly_constraint,
            coaxial_assembly_constraint,
            tangent_assembly_constraint))
  SUBTYPE OF (assembly_geometric_constraint,
            representation_relationship_with_transformation);
SELF\representation_relationship.rep_1:  
representative_shape_representation;
SELF\representation_relationship.rep_2: 
representative_shape_representation;
WHERE
WR1: (SELF\explicit_constraint.constrained_elements[1]
      \geometric_representation_item.dim = 3) AND
     (SELF\explicit_constraint.reference_elements[1]
      \geometric_representation_item.dim = 3);
WR2: (SELF\representation_relationship.rep_1 IN (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN (using_representations 
     (SELF\representation_relationship_with_transformation.
       transformation_operator\item_defined_transformation.transform_item_2) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2)));
WR3: (SIZEOF(SELF\explicit_constraint.constrained_elements)=1) AND
     (SIZEOF(SELF\explicit_constraint.reference_elements)=1);
WR4: (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1 =  
      SELF\explicit_constraint.reference_elements[1]) AND
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2 =  
      SELF\explicit_constraint.constrained_elements[1]);

END_ENTITY;-- binary_assembly_constraint

ENTITY fixed_constituent_assembly_constraint
SUBTYPE OF (assembly_geometric_constraint,
            fixed_element_geometric_constraint);
WHERE
WR1: SELF\explicit_constraint.constrained_elements[1]
     \geometric_representation_item.dim = 3;
WR2: (assembly_leaf (using_product_definition_of_shape_representation
      (SELF\representation_relationship.rep_2\shape_representation)[1]));
WR3: (SIZEOF(SELF\explicit_constraint.constrained_elements) = 1) AND
     (SIZEOF(SELF\explicit_constraint.reference_elements) = 0);

END_ENTITY;-- fixed_constituent_assembly_constraint

ENTITY parallel_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              parallel_geometric_constraint);
END_ENTITY;-- parallel_assembly_constraint

ENTITY  parallel_assembly_constraint_with_dimension
  SUBTYPE OF (parallel_assembly_constraint,
              pgc_with_dimension);
END_ENTITY;-- parallel_assembly_constraint_with_dimension



ENTITY surface_distance_assembly_constraint_with_dimension
  SUBTYPE OF (binary_assembly_constraint,
              sdgc_with_dimension);
END_ENTITY;-- surface_distance_assembly_constraint_with_dimension

ENTITY angle_assembly_constraint_with_dimension
  SUBTYPE OF (binary_assembly_constraint,
              agc_with_dimension);
END_ENTITY;-- angle_assembly_constraint_with_dimension

ENTITY perpendicular_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              perpendicular_geometric_constraint);
END_ENTITY;-- perpendicular_assembly_constraint

ENTITY incidence_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              incidence_geometric_constraint);
END_ENTITY;-- incidence_assembly_constraint

ENTITY coaxial_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              coaxial_geometric_constraint);
END_ENTITY;-- coaxial_assembly_constraint

ENTITY tangent_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              tangent_geometric_constraint);
END_ENTITY;-- tangent_assembly_constraint

FUNCTION assembly_leaf
  (item: product_definition) : BOOLEAN;
LOCAL
  local_relation: SET OF assembly_component_usage := [];
  local_relation2: BAG OF assembly_component_usage := [];
END_LOCAL;
-- extraction of related assembly_component_relationships --
local_relation2 := local_relation2 + (USEDIN (item, 
    'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.'+ 
    'RELATING_PRODUCT_DEFINITION'));
local_relation := bag_to_set (local_relation2);
IF (SIZEOF (local_relation) = 0) THEN RETURN (TRUE);
  ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;


END_SCHEMA; -- assembly_constraint
(* Copied from  TC184/SC4/WG12 N2649 *)

SCHEMA assembly_feature_relationship_schema;

REFERENCE FROM assembly_constraint_schema; -- 10303-109
REFERENCE FROM geometry_schema; -- 10303-41
REFERENCE FROM kinematic_motion_representation_schema; -- 10303-105
REFERENCE FROM kinematic_structure_schema; -- 10303-105
REFERENCE FROM product_definition_schema; -- 10303-41
REFERENCE FROM product_property_definition_schema; -- 10303-41
REFERENCE FROM product_property_representation_schema; -- 10303-41
REFERENCE FROM product_structure_schema; -- 10303-44
REFERENCE FROM representation_schema; -- 10303-43
REFERENCE FROM support_resource_schema; -- 10303-41

TYPE representing_relationship = SELECT
(binary_assembly_constraint,
constrained_kinematic_motion_representation,
free_kinematic_motion_representation);
END_TYPE;-- representing_relationship

ENTITY shape_aspect_relationship_representation_association;
  represented_shape_aspect_relationship: shape_aspect_relationship;
  representing_representation_relationship : representation_relationship;
WHERE
WR1: ('REPRESENTATIVE_SHAPE_REPRESENTATION' IN 
      TYPEOF(representing_representation_relationship\
      representation_relationship.rep_1)) AND
     ('REPRESENTATIVE_SHAPE_REPRESENTATION' IN 
      TYPEOF(representing_representation_relationship\
      representation_relationship.rep_2));
WR2: (represented_shape_aspect_relationship.relating_shape_aspect IN 
      using_shape_aspect_of_shape_representation 
      (representing_representation_relationship.rep_1\shape_representation)) AND
     (represented_shape_aspect_relationship.related_shape_aspect IN 
      using_shape_aspect_of_shape_representation 
      (representing_representation_relationship.rep_2\shape_representation));
WR3: ((find_representative_shape_representation_of_product_definition 
     (using_product_definition_of_shape_aspect
     (represented_shape_aspect_relationship.relating_shape_aspect)).
      context_of_items) :=:
     (find_representative_shape_representation_of_shape_aspect 
     (represented_shape_aspect_relationship.relating_shape_aspect).
      context_of_items)) AND
     ((find_representative_shape_representation_of_product_definition 
     (using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect)).
      context_of_items) :=:
     (find_representative_shape_representation_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect).
      context_of_items));
WR4: using_product_definition_of_shape_aspect
     (represented_shape_aspect_relationship.relating_shape_aspect) :<>: 
     using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect);
WR5: find_assembly_root ([using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.relating_shape_aspect)]) :=: 
     find_assembly_root ([using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect)]);
END_ENTITY; -- shape_aspect_relationship_representation_association

ENTITY representative_shape_representation
  SUBTYPE OF (shape_representation);
WHERE 
WR1: unique_in_product_definition (SELF) OR unique_in_shape_aspect (SELF);
END_ENTITY; -- representative_shape_representation

ENTITY free_kinematic_motion_representation
  SUBTYPE OF (representation_relationship_with_transformation);
SELF\representation_relationship.rep_1: 
   representative_shape_representation;
SELF\representation_relationship.rep_2: 
   representative_shape_representation;
  motion : kinematic_path;
WHERE
WR1: 'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator);
WR2: ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1)) AND
     ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2));
WR3: ((dimension_of
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.
      transform_item_1\geometric_representation_item) = 3 ) AND
     (dimension_of 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.
      transform_item_2\geometric_representation_item) = 3 ));
WR4:(SELF\representation_relationship.rep_1 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2)));
END_ENTITY; -- free_kinematic_motion_representation

ENTITY constrained_kinematic_motion_representation
  SUBTYPE OF (representation_relationship_with_transformation);
SELF\representation_relationship.rep_1: 
    representative_shape_representation;
SELF\representation_relationship.rep_2: 
    representative_shape_representation;
WHERE
WR1: ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1)) AND
     ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2));
WR2: ((dimension_of
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.
     transform_item_1\geometric_representation_item) = 3 ) AND
     (dimension_of 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.
     transform_item_2\geometric_representation_item) = 3 ));
WR3:(SELF\representation_relationship.rep_1 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1) +
     using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2) +
     using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2)));
WR4: 'KINEMATIC_PAIR' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator);
END_ENTITY; -- constrained_kinematic_motion_representation

FUNCTION assembly_root
  (item: product_definition) : BOOLEAN;
-- extraction of related assembly_component_relationships --
IF (SIZEOF(USEDIN (item, 
   'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.' + 
   'RELATED_PRODUCT_DEFINITION')) = 0) THEN RETURN(TRUE);
ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION find_assembly_root
  (constituent: SET OF product_definition) : SET OF product_definition;
LOCAL
  local_relation: SET OF assembly_component_usage := [];
  local_relation2: BAG OF assembly_component_usage := [];
  local_parent: SET OF product_definition := [];
  root : SET OF product_definition;
  i : INTEGER := 0;
  j : INTEGER := 0;
END_LOCAL;

-- Is constituent root ? --
IF ((SIZEOF (constituent) = 1) AND assembly_root (constituent[1]))
  THEN RETURN ([constituent [1]]);
-- ERROR constituent is vacant --
  ELSE IF (SIZEOF (constituent) = 0 ) THEN RETURN ([]);

-- extraction of related assembly_component_relationships --
    ELSE
      REPEAT j:= 1 TO HIINDEX(constituent);
        local_relation2 := local_relation2 + (USEDIN (constituent[j], 
                    'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE.' 
                    +'RELATED_PRODUCT_DEFINITION'));
      END_REPEAT;
      local_relation := bag_to_set (local_relation2);
      IF (SIZEOF(local_relation) = 0) THEN
        IF (SIZEOF(constituent) = 1) THEN RETURN ([constituent[1]]);
          ELSE RETURN ([]);
        END_IF;
      ELSE
-- extraction of a set of parents --
        REPEAT i :=1 TO HIINDEX(local_relation);
          REPEAT j := 1 TO HIINDEX(constituent);
          IF (local_relation[i].relating_product_definition <> 
              constituent[j]) THEN
            local_parent := local_parent + 
                            local_relation[i].relating_product_definition;
          END_IF;
          END_REPEAT;
        END_REPEAT;
        IF ((SIZEOF (local_parent) = 1 ) AND 
             assembly_root (local_parent[1])) 
          THEN RETURN ([local_parent[1]]); 
          ELSE IF (SIZEOF (local_parent) = 0) THEN RETURN ([]);
-- try again --
            ELSE 
              root := find_assembly_root(local_parent);
              IF (SIZEOF (root) =1) THEN RETURN (root);
                ELSE IF (SIZEOF (root) = 0) THEN RETURN ([]);
                END_IF;
              END_IF;
          END_IF;
        END_IF;
      END_IF;
  END_IF;
END_IF;
END_FUNCTION;
 
FUNCTION find_shape_representation_of_product_definition
    (item:product_definition) : SET OF shape_representation;
LOCAL
  local_p_d_s: SET OF product_definition_shape := [];
  local_p_d_s2: BAG OF product_definition_shape := [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find product_definition_shape representing the product_definiton
  local_p_d_s2 := local_p_d_s2 + (USEDIN (item, 
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE.DEFINITION'));
  local_p_d_s := bag_to_set(local_p_d_s2);
-- find shape_definition_representations refereing to the local_p_d_s
  REPEAT i := 1 to HIINDEX (local_p_d_s);
    local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d_s[i], 
                   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                   'SHAPE_DEFINITION_REPRESENTATION.DEFINITION')); 
  END_REPEAT;
  local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' 
        IN TYPEOF (local_s_d_r[i]\property_definition_representation.
                   used_representation\shape_representation)) THEN
        local_s_r := local_s_r + 
        local_s_d_r[i]\property_definition_representation.
        used_representation\shape_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);
END_FUNCTION;

FUNCTION find_shape_representation_of_shape_aspect
    (item:shape_aspect) : SET OF shape_representation;
LOCAL
  local_p_d: SET OF property_definition:= [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find property_definition representing the shape_aspect
  local_p_d := bag_to_set (USEDIN (item, 
   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
-- find shape_definition_representations refereing to the local_p_d
  REPEAT i := 1 to HIINDEX (local_p_d);
    local_s_d_r2 := local_s_d_r2 + (USEDIN (local_p_d[i], 
                   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                   'SHAPE_DEFINITION_REPRESENTATION.DEFINITION')); 
  END_REPEAT;
    local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION'
        IN TYPEOF 
        (local_s_d_r[i].used_representation\shape_representation)) THEN
        local_s_r := local_s_r + 
        local_s_d_r[i]\property_definition_representation.
        used_representation\shape_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);
END_FUNCTION;
 
FUNCTION find_representative_shape_representation_of_product_definition
    (item:product_definition) : shape_representation;
LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the product_definition
  local_s_r := QUERY 
    ( z <* find_shape_representation_of_product_definition (item)|
      'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]); 
   ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;
END_FUNCTION;

FUNCTION find_representative_shape_representation_of_shape_aspect
    (item:shape_aspect) : shape_representation;
LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the shape_aspect
  local_s_r := QUERY ( z <* find_shape_representation_of_shape_aspect (item)|
               'REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
IF (SIZEOF (local_s_r) = 1) THEN RETURN (local_s_r[1]); 
   ELSE local_s_r := []; RETURN(local_s_r[1]);
END_IF;
END_FUNCTION;

FUNCTION unique_in_product_definition
    (item:representative_shape_representation) : BOOLEAN;
LOCAL
  local_p_d: SET OF product_definition := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find product_definitions represented by the input 
-- representative_shape_representation
  local_p_d := using_product_definition_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_p_d) = 0) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the product_definitions
    REPEAT i := 1 to HIINDEX (local_p_d);
      local_s_r := find_shape_representation_of_product_definition 
                   (local_p_d[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF (('REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF (local_s_r[j])) 
             AND (local_s_r[j] :<>: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION unique_in_shape_aspect
    (item:representative_shape_representation) : BOOLEAN;
LOCAL
  local_s_a: SET OF shape_aspect := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find shape_aspects represented by the input 
-- representative_shape_representation
  local_s_a := using_shape_aspect_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_s_a) = 0) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the shape_aspect
    REPEAT i := 1 to HIINDEX (local_s_a);
      local_s_r := find_shape_representation_of_shape_aspect 
                   (local_s_a[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF ((' REPRESENTATIVE_SHAPE_REPRESENTATION ' IN TYPEOF (local_s_r[j])) 
           AND (local_s_r[j] :<>: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION using_product_definition_of_shape_aspect
    (item:shape_aspect) : product_definition ;
IF ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF 
    (item.of_shape\property_definition.definition)) THEN
    RETURN (item.of_shape\property_definition.definition\product_definition);
END_IF;
END_FUNCTION;

FUNCTION using_product_definition_of_shape_representation
    (item: shape_representation) : SET OF product_definition;
LOCAL
  local_s_d_r: SET OF shape_definition_representation := [];
  local_p_d_s: SET OF product_definition_shape := [];
  local_p_d: SET OF product_definition := [];
  i : INTEGER;
END_LOCAL;

-- find shape_definition_representations 
  local_s_d_r  := local_s_d_r + bag_to_set (USEDIN (item, 
 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
 'SHAPE_DEFINITION_REPRESENTATION.USED_REPRESENTATION')); 

-- find product_definition_shape & product_definitions
REPEAT i := 1 TO HIINDEX (local_s_d_r);
   IF (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN 
     TYPEOF (local_s_d_r[i]\property_definition_representation.definition))
     AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
       (local_s_d_r[i]\property_definition_representation.
        definition\property_definition.definition))) 
   THEN local_p_d := local_p_d + 
        local_s_d_r[i]\property_definition_representation.
        definition\property_definition.definition;
   ELSE IF (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION' IN 
     TYPEOF (local_s_d_r[i]\property_definition_representation.definition))
     AND
     ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
       (local_s_d_r[i]\property_definition_representation.
        definition\property_definition.definition)))
   THEN local_p_d := local_p_d + 
        local_s_d_r[i]\property_definition_representation.
        definition\property_definition.definition;
   END_IF;
   END_IF;
END_REPEAT;
RETURN (local_p_d);
END_FUNCTION;

FUNCTION using_shape_aspect_of_shape_representation
    (item: shape_representation) : SET OF shape_aspect;
LOCAL
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_a: SET OF shape_aspect := [];
  i : INTEGER;
END_LOCAL;
-- find shape_definition_representations 
  local_s_d_r2  := local_s_d_r2 + (USEDIN (item, 
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
  'SHAPE_DEFINITION_REPRESENTATION.USED_REPRESENTATION')); 
  local_s_d_r := bag_to_set (local_s_d_r2);
-- find shape_aspects
REPEAT i := 1 TO HIINDEX (local_s_d_r);
   IF ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF 
      (local_s_d_r[i]\property_definition_representation.definition))
   THEN local_s_a := local_s_a + local_s_d_r[i]\
                property_definition_representation.definition;
   END_IF;
END_REPEAT;
RETURN (local_s_a);
END_FUNCTION;

FUNCTION using_representation_with_mapping (item : representation_item)
         : SET OF representation;
LOCAL 
  results: SET OF representation := [];
  local_results : SET OF representation := [];
  local_representation_map : SET OF representation_map := [];
  intermediate_items : SET OF representation_item := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find the representations in which the item is used
-- and which is referenced from the representation_map
   local_results := QUERY (z <* using_representations (item)|
           SIZEOF (USEDIN (z, 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.' +
                              'MAPPED_REPRESENTATION')) > 0 );
  IF (SIZEOF (local_results) = 0) THEN RETURN ([]);
  ELSE 
-- find the set of representation_map in which the local_results are used
  REPEAT i := 1 TO HIINDEX(local_results);
  local_representation_map := local_representation_map +
      bag_to_set (USEDIN (local_results[i], 
                 'REPREZENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
-- find the set of mapped_item
  REPEAT i := 1 TO HIINDEX(local_representation_map);
  intermediate_items := intermediate_items + 
          bag_to_set (USEDIN (local_representation_map[i], 
                 'REPREZENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
  END_REPEAT;
-- repeat same manner
  REPEAT j := 1 to HIINDEX(intermediate_items);
        results := results + bag_to_set (using_representation_with_mapping 
                             (intermediate_items[j]));
    END_REPEAT;
  END_IF;
  RETURN (results);
END_FUNCTION; 

END_SCHEMA;  -- assembly_feature_relationship_schema 
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 

SCHEMA basic_attribute_schema; 

REFERENCE FROM action_schema   -- ISO 10303-41
  (action,
   action_request_solution); 

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (application_context); 

REFERENCE FROM approval_schema   -- ISO 10303-41
  (approval_date_time,
   approval_role); 

REFERENCE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_design); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_role,
   date_time_role,
   time_role); 

REFERENCE FROM effectivity_schema   -- ISO 10303-41
  (effectivity); 

REFERENCE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (derived_unit); 

REFERENCE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization_role,
   organizational_project,
   person_and_organization,
   person_and_organization_role,
   person_role); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_definition,
   product_definition_substitute); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (context_dependent_shape_representation,
   property_definition_representation); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


TYPE description_attribute_select = SELECT
   (action_request_solution, 
    application_context, 
    approval_role, 
    configuration_design, 
    context_dependent_shape_representation, 
    date_role, 
    date_time_role, 
    effectivity, 
    external_source, 
    organization_role, 
    person_and_organization, 
    person_and_organization_role, 
    person_role, 
    property_definition_representation, 
    representation, 
    time_role);
END_TYPE; 

TYPE id_attribute_select = SELECT
   (action, 
    address, 
    application_context, 
    group, 
    organizational_project, 
    product_category, 
    property_definition, 
    representation, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

TYPE name_attribute_select = SELECT
   (action_request_solution, 
    address, 
    configuration_design, 
    context_dependent_shape_representation, 
    derived_unit, 
    effectivity, 
    person_and_organization, 
    product_definition, 
    product_definition_substitute, 
    property_definition_representation);
END_TYPE; 

TYPE role_select = SELECT
   (action_assignment, 
    action_request_assignment, 
    approval_assignment, 
    approval_date_time, 
    certification_assignment, 
    contract_assignment, 
    document_reference, 
    effectivity_assignment, 
    external_referent_assignment, 
    group_assignment, 
    name_assignment, 
    security_classification_assignment);
END_TYPE; 

ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;

ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;

FUNCTION get_description_value
 (obj : description_attribute_select) : text; 
  LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_id_value
 (obj : id_attribute_select) : identifier; 
LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;
END_FUNCTION; 

FUNCTION get_name_value
 (obj : name_attribute_select) : label; 
  LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

FUNCTION get_role
 (obj : role_select) : object_role; 
  LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION; 

END_SCHEMA;  -- basic_attribute_schema





(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N28872 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA certification_schema; 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;

END_SCHEMA;  -- certification_schema



(* 
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3213 - ISO/IS 10303-54 Classification and set theory - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1510
*) 


SCHEMA classification_schema;

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE complete_membership_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET[1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF (classification,
         complete_membership);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- classification_schema
(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA configuration_management_schema;

  REFERENCE FROM product_definition_schema
    (product_definition,
     product_definition_formation,
     product_definition_effectivity);

  REFERENCE FROM product_structure_schema
    (product_definition_usage);

  REFERENCE FROM product_concept_schema
    (product_concept,
     product_concept_feature_association);

  REFERENCE FROM basic_attribute_schema
    (get_description_value,
     get_name_value);

  REFERENCE FROM support_resource_schema
    (text, label, identifier, bag_to_set);

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       usage,
       id;
WHERE
  WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

END_SCHEMA; -- configuration_management_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA contract_schema; 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;

ENTITY contract_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_contract : contract;
  related_contract : contract;
END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

FUNCTION acyclic_contract_relationship
 (relation : contract_relationship; relatives : SET[1:?] OF contract; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- contract_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA date_time_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (time_measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE; 

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE; 

TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE; 

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; 

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; 

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; 

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; 

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; 

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; 

TYPE year_number = INTEGER;
END_TYPE; 

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION; 

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION; 

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; 

END_SCHEMA;  -- date_time_schema

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA document_schema;

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE product_or_formation_or_definition = SELECT
   (product, 
    product_definition_formation, 
    product_definition);
END_TYPE; 

ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET[0:?] OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;

ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY;

FUNCTION acyclic_document_relationship
 (relation : document_relationship; relatives : SET[1:?] OF document; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- document_schema
(* Genenerated from: ../../irs/wg12n268.exp *)

SCHEMA draughting_dimension_schema;

REFERENCE FROM draughting_element_schema
    (dimension_curve,
     leader_curve,
     projection_curve,
     draughting_callout,
     draughting_callout_relationship,
     dimension_curve_directed_callout,
     leader_directed_callout,
     projection_directed_callout,
     dimension_extent_usage);

ENTITY dimension_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: ('DRAUGHTING_ELEMENT_SCHEMA.LEADER_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
  WR2: ('DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
  WR3:
('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
END_ENTITY;

ENTITY dimension_graph
  SUBTYPE OF (dimension_curve_directed_callout);
WHERE
  WR1: SIZEOF(USEDIN(SELF,'DRAUGHTING_DIMENSION_SCHEMA.'+
       'DIMENSION_GRAPH_PROJECTION_CURVE_USAGE.GRAPH')) <= 2;
  WR2: SIZEOF(QUERY(dce <* SELF\draughting_callout.contents |
       'DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE'
       IN (TYPEOF(dce)))) = 0;
  WR3: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_CALLOUT' 
       IN (TYPEOF(SELF));
END_ENTITY;

ENTITY dimension_graph_projection_curve_usage;
  graph           : dimension_graph;
  projection_line : projection_curve;
  role            : dimension_extent_usage;
UNIQUE
  UR1: graph, projection_line;
  UR2: graph, role;
END_ENTITY;

ENTITY dimension_graph_sequence
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_GRAPH' IN
       TYPEOF (SELF\draughting_callout_relationship.
                    relating_draughting_callout);
  WR2: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_GRAPH' IN
       TYPEOF (SELF\draughting_callout_relationship.
                    related_draughting_callout);
END_ENTITY;

END_SCHEMA; -- draughting_dimension_schema
(* Genenerated from: ../../irs/wg12n268.exp *)

SCHEMA draughting_element_schema;

REFERENCE FROM geometry_schema (geometric_representation_item);

REFERENCE FROM support_resource_schema
    (label,
     text);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     annotation_curve_occurrence,
     annotation_text_occurrence, 
     annotation_symbol_occurrence);

TYPE draughting_callout_element = SELECT
  (annotation_text_occurrence, 
   annotation_symbol_occurrence,
   annotation_curve_occurrence);
END_TYPE;

TYPE dimension_extent_usage = ENUMERATION OF
  (origin,
   target);
END_TYPE;

ENTITY dimension_curve
  SUBTYPE OF (annotation_curve_occurrence);
WHERE
  wr1: (SIZEOF(
          QUERY(dct <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                'TERMINATOR_SYMBOL.ANNOTATED_CURVE')
               | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct))
                  ))
          ) <= 2);
   wr2:  SIZEOF(
            QUERY( dcdc <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                   'DRAUGHTING_CALLOUT.CONTENTS') |
                   ('DRAUGHTING_ELEMENT_SCHEMA.'+
                    'DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(dcdc)))
       )>= 1;
   wr3: (SIZEOF(
            QUERY(dct1 <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                  'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
               | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct1)) 
                  AND (dct1.role = origin)))
        ) <= 1)
     AND 
        (SIZEOF(
            QUERY (dct2 <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.'+
                   'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
                 | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                   'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct2))
                   AND (dct2.role = target)))
       ) <= 1);
END_ENTITY;

ENTITY leader_curve
  SUBTYPE OF (annotation_curve_occurrence);
WHERE
  WR1: SIZEOF( 
          QUERY(ldc <* USEDIN( SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                       'DRAUGHTING_CALLOUT.CONTENTS')
                   |   'DRAUGHTING_ELEMENT_SCHEMA.' +
                       'LEADER_DIRECTED_CALLOUT'  IN TYPEOF(ldc))) >= 1;
END_ENTITY;

ENTITY projection_curve
  SUBTYPE OF (annotation_curve_occurrence);
END_ENTITY;

ENTITY terminator_symbol
  SUBTYPE OF (annotation_symbol_occurrence);
  annotated_curve : annotation_curve_occurrence;
END_ENTITY;

ENTITY dimension_curve_terminator
  SUBTYPE OF (terminator_symbol);
  role  : dimension_extent_usage;
WHERE
  WR1: 'DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE' IN TYPEOF
       (SELF\terminator_symbol.annotated_curve);
END_ENTITY;

ENTITY leader_terminator
  SUBTYPE OF (terminator_symbol);
WHERE
  WR1: 'DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE' IN TYPEOF
       (SELF\terminator_symbol.annotated_curve);
END_ENTITY;

ENTITY draughting_callout
  SUBTYPE OF (geometric_representation_item);
  contents : SET [1:?] OF draughting_callout_element; 
END_ENTITY;

ENTITY draughting_callout_relationship;
  name : label;
  description : text;
  relating_draughting_callout : draughting_callout;
  related_draughting_callout : draughting_callout;
END_ENTITY;

ENTITY leader_directed_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
       'DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE' IN (TYPEOF(l_1)))) >= 1;
  WR2: SIZEOF(SELF\draughting_callout.contents) >=2;
END_ENTITY;

ENTITY projection_directed_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF(QUERY(p_1<*SELF\draughting_callout.contents | 
      'DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE' IN (TYPEOF(p_1))))=1;
  WR2: SIZEOF(SELF\draughting_callout.contents) >=2;
END_ENTITY;

ENTITY dimension_curve_directed_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF(QUERY(d_c<*SELF\draughting_callout.contents | 
      'DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE' IN (TYPEOF(d_c))))=1;
  WR2: SIZEOF(SELF\draughting_callout.contents) >= 2;
END_ENTITY;

END_SCHEMA; -- draughting_element_schema
(* Genenerated from: ../../irs/wg12n268.exp *)

SCHEMA drawing_definition_schema;

REFERENCE FROM support_resource_schema
    (label,
     text,
     identifier,
     bag_to_set);

REFERENCE FROM representation_schema
    (mapped_item,
     representation_relationship,
     representation);

REFERENCE FROM presentation_organization_schema
    (area_in_set,
     presentation_area,
     presentation_set,
     presentation_representation_relationship);

TYPE draughting_titled_item = SELECT 
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

ENTITY drawing_definition;
  drawing_number : identifier;
  drawing_type   : OPTIONAL label;
END_ENTITY;

ENTITY drawing_revision
  SUBTYPE OF (presentation_set);
  revision_identifier : identifier;
  drawing_identifier  : drawing_definition;
  intended_scale      : OPTIONAL text;
UNIQUE
  UR1: revision_identifier, drawing_identifier;
END_ENTITY;

ENTITY drawing_revision_sequence;
  predecessor : drawing_revision;
  successor   : drawing_revision;
WHERE
  WR1: predecessor :<>: successor;
END_ENTITY;

ENTITY drawing_sheet_revision
  SUBTYPE OF (presentation_area);
  revision_identifier : identifier;
WHERE
  WR1: SIZEOF( QUERY(item <* SELF\representation.items |
       ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN (TYPEOF(item)))
       AND
       ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' IN
       (TYPEOF(item\mapped_item.mapping_source.mapped_representation)))))=0;
END_ENTITY;

ENTITY drawing_sheet_revision_sequence
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: SELF\representation_relationship.rep_1 :<>:                            
       SELF\representation_relationship.rep_2;
  WR2: 'DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_1);
  WR3: 'DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY drawing_sheet_revision_usage
  SUBTYPE OF (area_in_set);
  sheet_number : identifier;
UNIQUE
  UR1: sheet_number, in_set;
WHERE
  WR1: ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' IN 
                  TYPEOF(SELF\area_in_set.area)) 
              AND
              ('DRAWING_DEFINITION_SCHEMA.DRAWING_REVISION' 
               IN TYPEOF (SELF\area_in_set.in_set));
END_ENTITY;

ENTITY draughting_title;
  items    : SET [1:?] OF draughting_titled_item;
  language : label;
  contents : text;
END_ENTITY;

RULE drawing_sheets_not_nested FOR (presentation_representation_relationship);
WHERE
  WR1: SIZEOF( QUERY(p_r_r <* presentation_representation_relationship |      
         ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' 
        IN (TYPEOF(p_r_r.rep_1))) AND
        ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
        IN (TYPEOF( p_r_r.rep_2))))) = 0;
END_RULE;

END_SCHEMA; -- drawing_definition_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA effectivity_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM date_time_schema   -- ISO 10303-41
  (date_time_or_event_occurrence,
   time_interval); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity,
                       dated_effectivity,
                       lot_effectivity,
                       time_interval_based_effectivity));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

FUNCTION acyclic_effectivity_relationship
 (relation : effectivity_relationship; relatives : SET[1:?] OF effectivity; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- effectivity_schema


(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA experience_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY experience;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience : experience;
  related_experience : experience;
END_ENTITY;

ENTITY experience_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_experience_type : experience_type;
  related_experience_type : experience_type;
END_ENTITY;

FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- experience_schema
(* Genenerated from: 10303-108.exp *)

SCHEMA explicit_constraint_schema;

REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (text);

REFERENCE FROM representation_schema               -- ISO 10303-43
  (item_in_context,
   representation_item,
   using_representations);

REFERENCE FROM mathematical_functions_schema       -- ISO 10303-50
  (compatible_spaces,
   values_space_of);

(*
REFERENCE FROM parameterization_schema             -- ISO 10303-108
  (bound_model_parameter,
   unbound_model_parameter);
*)

REFERENCE FROM variational_representation_schema   -- ISO 10303-108
  (variational_representation_item);

REFERENCE FROM ISO13584_generic_expressions_schema -- ISO 13584-20
  (used_variables);

REFERENCE FROM ISO13584_expressions_schema;        -- ISO 13584-20

TYPE constraint_group_member = SELECT
  (explicit_constraint,
   simultaneous_constraint_group);
END_TYPE;

ENTITY explicit_constraint
  ABSTRACT SUPERTYPE OF (ONEOF(defined_constraint,
                               free_form_constraint))
  SUBTYPE OF (variational_representation_item); 
  description : OPTIONAL text;
  constrained_elements : SET[1:?] OF representation_item;
  reference_elements   : SET[0:?] OF representation_item;
WHERE
  WR1: SIZEOF(constrained_elements * reference_elements) = 0;
END_ENTITY;

ENTITY defined_constraint 
  ABSTRACT SUPERTYPE OF (equal_parameter_constraint)
  SUBTYPE OF (explicit_constraint);
END_ENTITY; 

ENTITY equal_parameter_constraint
  SUBTYPE OF (defined_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF model_parameter;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF model_parameter;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) >= 2;
END_ENTITY;

ENTITY free_form_constraint 
  ABSTRACT SUPERTYPE OF (ONEOF(free_form_assignment, free_form_relation))
  SUBTYPE OF (explicit_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF model_parameter;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF model_parameter;
  constraining_expression : expression;
END_ENTITY; 

ENTITY free_form_assignment 
  SUBTYPE OF (free_form_constraint);
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\free_form_constraint.constrained_elements | 
    q IN used_variables
    (SELF\free_form_constraint.constraining_expression))) = 0; 
  WR2: SIZEOF(QUERY(q <* SELF\free_form_constraint.reference_elements | 
    NOT (q IN used_variables(
    SELF\free_form_constraint.constraining_expression)))) = 0; 
  WR3: SIZEOF(SELF\free_form_constraint.reference_elements) >= 1;
  WR4: SIZEOF(QUERY(q <* SELF\free_form_constraint.constrained_elements |
    NOT (compatible_spaces(values_space_of(
    SELF\free_form_constraint.constraining_expression),
    q\maths_variable.values_space)))) = 0;
END_ENTITY; 

ENTITY free_form_relation 
  SUBTYPE OF (free_form_constraint);
WHERE 
  WR1: 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF
    (SELF\free_form_constraint.constraining_expression); 
  WR2: SIZEOF(QUERY(q <* (SELF\free_form_constraint.constrained_elements + 
    SELF\free_form_constraint.reference_elements) | NOT (q IN used_variables
    (SELF\free_form_constraint.constraining_expression)))) = 0; 
END_ENTITY; 

ENTITY simultaneous_constraint_group
  SUBTYPE OF (variational_representation_item);
  constraint_group : SET[1:?] OF constraint_group_member;
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(SELF) |
    SIZEOF(QUERY(r <* q.items | 
    ('EXPLICIT_CONSTRAINT_SCHEMA.SIMULTANEOUS_CONSTRAINT_GROUP'
    IN TYPEOF(r)) AND (SIZEOF(QUERY(s <* constraint_group | 
    (s IN r.constraint_group) AND NOT (r :=: SELF))) > 0))) > 0)) = 0;
  WR2: SIZEOF(QUERY(q <* using_representations(constraint_group[1]) | 
    (SIZEOF(QUERY(r <* constraint_group | 
    item_in_context(r,q.context_of_items)))
    = SIZEOF(constraint_group)))) > 0;
  WR3: SIZEOF(QUERY(q <* constraint_group |
    (('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) 
    AND (SIZEOF(QUERY(r <* q.constrained_elements |
    SIZEOF(QUERY(s <* constraint_group | 
    r IN s.reference_elements)) > 0)) > 0)))) = 0;
END_ENTITY;

END_SCHEMA; -- explicit_constraint_schema
(* Genenerated from: 10303-108.exp *)

SCHEMA explicit_geometric_constraint_schema;

REFERENCE FROM measure_schema             -- ISO 10303-41
  (length_measure,
   plane_angle_measure,
   positive_length_measure);

REFERENCE FROM geometry_schema;           -- ISO 10303-42

REFERENCE FROM geometric_model_schema     -- ISO 10303-42
  (extruded_area_solid,
   extruded_face_solid,
   revolved_area_solid,
   revolved_face_solid,
   right_circular_cone,
   right_circular_cylinder,
   sphere,
   swept_area_solid,
   swept_face_solid,
   torus);

REFERENCE FROM representation_schema      -- ISO 10303-43
  (representation_item_relationship);

REFERENCE FROM explicit_constraint_schema -- ISO 10303-108
  (defined_constraint);

TYPE geometric_constraint_element = SELECT
  (point,
   curve,
   surface,
   vector,
   direction);
END_TYPE;

TYPE point_curve_or_surface_constraint_element = SELECT
  (point,
   curve,
   surface);
END_TYPE;

TYPE curve_or_surface_constraint_element = SELECT
  (curve,
   surface);
END_TYPE;

TYPE linear_geometry_constraint_element = SELECT
  (line,
   plane,
   direction,
   vector);
END_TYPE;

TYPE radial_geometry_constraint_element = SELECT
  (circle,
   cylindrical_surface,
   conical_surface,
   spherical_surface,
   right_circular_cylinder,
   right_circular_cone,
   sphere);
END_TYPE;

TYPE axial_geometry_constraint_element = SELECT
  (point,
   line,
   circle,
   plane,
   cylindrical_surface,
   conical_surface,
   spherical_surface,
   toroidal_surface,
   surface_of_revolution,
   sphere,
   right_circular_cone,
   right_circular_cylinder,
   torus,
   revolved_face_solid,
   revolved_area_solid);
END_TYPE;

TYPE swept_surface_or_solid = SELECT
  (swept_surface,
   swept_face_solid,
   swept_area_solid);
END_TYPE;

TYPE tangent_contact_type = ENUMERATION OF
  (point_contact,
   curve_contact,
   surface_contact);
END_TYPE;

TYPE parallel_offset_type = ENUMERATION OF
  (curve_2d_offset,
   curve_3d_offset,
   surface_offset);
END_TYPE;

TYPE non_negative_length_measure = length_measure;
WHERE
  WR1: SELF >= 0;
END_TYPE;

ENTITY explicit_geometric_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
    (fixed_element_geometric_constraint,
     parallel_geometric_constraint,
     point_distance_geometric_constraint,
     skew_line_distance_geometric_constraint,
     curve_distance_geometric_constraint,
     surface_distance_geometric_constraint,
     radius_geometric_constraint,
     curve_length_geometric_constraint,
     parallel_offset_geometric_constraint,
     angle_geometric_constraint,
     perpendicular_geometric_constraint,
     incidence_geometric_constraint,
     coaxial_geometric_constraint,
     tangent_geometric_constraint,
     symmetry_geometric_constraint,
     swept_point_curve_geometric_constraint,
     swept_curve_surface_geometric_constraint,
     curve_smoothness_geometric_constraint,
     surface_smoothness_geometric_constraint))
  SUBTYPE OF (defined_constraint, geometric_representation_item);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_representation_item;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF geometric_representation_item;
END_ENTITY;

ENTITY fixed_element_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY; 

ENTITY parallel_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element; 
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF linear_geometry_constraint_element;
END_ENTITY; 

ENTITY pgc_with_dimension
  SUBTYPE OF (parallel_geometric_constraint);
  distance_value : non_negative_length_measure;
  negative_direction : BOOLEAN;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: SIZEOF(QUERY(q <* (SELF\explicit_constraint.reference_elements +
    SELF\explicit_constraint.constrained_elements) | SIZEOF(TYPEOF(q) *
    ['GEOMETRY_SCHEMA.DIRECTION', 'GEOMETRY_SCHEMA.VECTOR']) > 0)) = 0;
END_ENTITY; 

ENTITY point_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF point;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.PDGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
END_ENTITY;

ENTITY pdgc_with_dimension
  SUBTYPE OF (point_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY skew_line_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF line;
  SELF\explicit_constraint.reference_elements   : SET[0:1] OF line;
  distance_value : non_negative_length_measure;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) = 2;
END_ENTITY;

ENTITY near_point_relationship
  SUBTYPE OF (representation_item_relationship);
  SELF\representation_item_relationship.relating_representation_item :
    curve_or_surface_constraint_element;
  SELF\representation_item_relationship.related_representation_item : 
    point;
END_ENTITY;

ENTITY curve_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF curve;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
  near_points : SET[0:4] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.CDGC_WITH_DIMENSION'
    IN TYPEOF(SELF)) 
    AND (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements);
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY cdgc_with_dimension
  SUBTYPE OF (curve_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY surface_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF surface;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
  near_points : SET[0:4] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR 
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.SDGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) 
    AND (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements);
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY sdgc_with_dimension
  SUBTYPE OF (surface_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY radius_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF radial_geometry_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY rgc_with_dimension
  SUBTYPE OF (radius_geometric_constraint);
  radius_value : positive_length_measure;
END_ENTITY;

ENTITY curve_length_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF bounded_curve;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY clgc_with_dimension
  SUBTYPE OF (curve_length_geometric_constraint);
  length_value : positive_length_measure;
END_ENTITY;

ENTITY parallel_offset_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF curve_or_surface_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF curve_or_surface_constraint_element;
  offset_type : parallel_offset_type;   
WHERE
  WR1: NOT(((offset_type = curve_2d_offset) 
    OR (offset_type = curve_3d_offset)) AND 
    (SIZEOF(QUERY( q <* (SELF\explicit_constraint.constrained_elements 
    + SELF\explicit_constraint.reference_elements) |
    'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(q))) > 0));
  WR2: NOT((offset_type = surface_offset) AND (SIZEOF(QUERY( q <* 
    (SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) | 
    'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(q))) > 0));
END_ENTITY;

ENTITY pogc_with_dimension 
  SUBTYPE OF (parallel_offset_geometric_constraint); 
  offset_value : positive_length_measure; 
  offset_direction_constrained : BOOLEAN; 
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: (NOT (offset_direction_constrained = TRUE)
    AND ((offset_type = curve_2d_offset) 
    OR (offset_type = surface_offset))); 
END_ENTITY; 

ENTITY angle_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF linear_geometry_constraint_element;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.AGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
END_ENTITY;

ENTITY agc_with_dimension
  SUBTYPE OF (angle_geometric_constraint);
  angle_value : plane_angle_measure;
END_ENTITY;

ENTITY perpendicular_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:2] OF linear_geometry_constraint_element;
WHERE   
  WR1: NOT ((SIZEOF(SELF\explicit_constraint.reference_elements) = 2) AND 
    NOT ((SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements + 
    SELF\explicit_constraint.reference_elements | 
    'GEOMETRY_SCHEMA.LINE' IN TYPEOF(q))) =
    SIZEOF(SELF\explicit_constraint.reference_elements + 
    SELF\explicit_constraint.constrained_elements)) XOR 
    (SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements + 
    SELF\explicit_constraint.reference_elements | 
    'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(q))) =
    SIZEOF(SELF\explicit_constraint.reference_elements + 
    SELF\explicit_constraint.constrained_elements))));
  WR2: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (SIZEOF(SELF\explicit_constraint.constrained_elements) IN [2,3]);
  WR3: NOT ((SIZEOF(SELF\explicit_constraint.reference_elements) = 0) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 3)) AND NOT  
    ((SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements | 
    'GEOMETRY_SCHEMA.LINE' IN TYPEOF(q))) = 3) XOR
    (SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements | 
    'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(q))) = 3));
END_ENTITY; 

ENTITY incidence_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET [0:?] OF geometric_constraint_element;
  near_points : SET[0:?] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements); 
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY coaxial_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF axial_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF axial_geometry_constraint_element;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\explicit_constraint.reference_elements | 
    SIZEOF(TYPEOF(q) * ['GEOMETRY_SCHEMA.POINT','GEOMETRY_SCHEMA.PLANE',
    'GEOMETRY_SCHEMA.SPHERICAL_SURFACE','GEOMETRY_SCHEMA.SPHERE']) 
    > 0)) = 0;
END_ENTITY; 

ENTITY tangent_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF curve_or_surface_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF curve_or_surface_constraint_element;
  near_points         : SET[0:?] OF near_point_relationship;
  tangent_contact     : tangent_contact_type;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: NOT ((SELF\geometric_representation_item.dim = 2)
    AND (tangent_contact = surface_contact));
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY symmetry_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[2:2] OF geometric_representation_item;
  mirror_element : linear_geometry_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
  WR2: SIZEOF(TYPEOF(mirror_element) * 
    ['GEOMETRY_SCHEMA.DIRECTION','GEOMETRY_SCHEMA.VECTOR']) = 0;
  WR3: NOT ((SELF\geometric_representation_item.dim = 2) AND 
    ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(mirror_element)));
END_ENTITY;

ENTITY swept_point_curve_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF curve;
  SELF\explicit_constraint.reference_elements   : 
    SET[1:1] OF swept_face_solid;
END_ENTITY;

ENTITY swept_curve_surface_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF surface;
  SELF\explicit_constraint.reference_elements   : 
    SET[1:1] OF swept_surface_or_solid;
END_ENTITY;

ENTITY curve_segment_set
  SUBTYPE OF (geometric_representation_item);
  segments : SET[1:?] OF composite_curve_segment;
END_ENTITY;

ENTITY curve_smoothness_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:1] OF curve_segment_set;
  smoothness : transition_code;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY surface_patch_set
  SUBTYPE OF (geometric_representation_item);
  patches : SET[1:?] OF surface_patch;
END_ENTITY;

ENTITY surface_smoothness_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET [1:1] OF surface_patch_set;
  u_smoothness : transition_code;
  v_smoothness : transition_code;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

END_SCHEMA; -- explicit_geometric_constraint_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  WG12N1826 - ISO 10303-57 expression_extensions_schema
*)

SCHEMA expression_extensions_schema; 

REFERENCE FROM iso13584_expressions_schema   -- ISO 13584-20
  (defined_function,
   expression); 

REFERENCE FROM iso13584_generic_expressions_schema   -- ISO 13584-20
  (generic_literal,
   generic_variable); 

REFERENCE FROM iso13584_iec61360_dictionary_schema   -- ISO 13584-42
  (entity_instance_type); 


TYPE assignment_target_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE entity_instance_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY entity_expression
  SUBTYPE OF (entity_instance_type, expression);
  SELF\entity_instance_type.type_name RENAMED entity_name : SET[1:1] OF STRING;
END_ENTITY;

ENTITY entity_instance
  SUBTYPE OF (generic_literal);
  entity_definition : entity_expression;
  the_instance : entity_instance_select;
END_ENTITY;

ENTITY expression_assignment;
  assigned_expression : expression;
  assigned_to_object : assignment_target_select;
  role : STRING;
END_ENTITY;

ENTITY expression_relationship;
  description : OPTIONAL STRING;
  name : OPTIONAL STRING;
  related : expression;
  relating : expression;
  role : STRING;
END_ENTITY;

ENTITY literal_assignment;
  base : expression;
  literal_value : generic_literal;
  value_context : OPTIONAL entity_instance;
END_ENTITY;

ENTITY named_function
  SUBTYPE OF (defined_function);
  name : STRING;
END_ENTITY;

ENTITY named_variable
  SUBTYPE OF (generic_variable);
  name : STRING;
END_ENTITY;

ENTITY variable_assignment;
  the_function : defined_function;
  the_variable : generic_variable;
END_ENTITY;

ENTITY variable_entity_type
  SUBTYPE OF (entity_expression, generic_variable);
END_ENTITY;

END_SCHEMA;  -- expression_extensions_schema

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA external_reference_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE message = STRING;
END_TYPE; 

TYPE source_item = SELECT
   (identifier, 
    message);
END_TYPE; 

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY external_source_relationship;
  name : label;
  description : OPTIONAL text;
  relating_source : external_source;
  related_source : external_source;
END_ENTITY;

ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;

ENTITY externally_defined_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item : externally_defined_item;
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

FUNCTION acyclic_external_source_relationship
 (relation : external_source_relationship; relatives : SET[1:?] OF external_source; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_externally_defined_item_relationship
 (relation : externally_defined_item_relationship; relatives : SET[1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- external_reference_schema
(* Genenerated from: ../../irs/wg12n550.exp *)

SCHEMA fea_scalar_vector_tensor_schema;

  REFERENCE FROM measure_schema 
      (context_dependent_measure);

  REFERENCE FROM representation_schema
      (representation_item);

TYPE angular_value = 
     context_dependent_measure;
END_TYPE;

TYPE scalar = 
     context_dependent_measure;
END_TYPE;

TYPE tensor1 = SELECT
  (tensor1_2d,
   tensor1_3d);
END_TYPE;

TYPE tensor1_2d = 
     ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE tensor1_3d = 
  ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor2_2d = SELECT
  (anisotropic_symmetric_tensor2_2d);
END_TYPE;

TYPE anisotropic_symmetric_tensor2_2d = 
  ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor2_3d = SELECT
  (isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE isotropic_symmetric_tensor2_3d = 
     context_dependent_measure;
END_TYPE;

TYPE orthotropic_symmetric_tensor2_3d = 
     ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE anisotropic_symmetric_tensor2_3d = 
     ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE symmetric_tensor4_2d = SELECT
  (anisotropic_symmetric_tensor4_2d);
END_TYPE;

TYPE anisotropic_symmetric_tensor4_2d = 
     ARRAY [1:6] OF context_dependent_measure;
END_TYPE;

TYPE tensor_type = SELECT 
  (scalar,
   angular_value,
   tensor1_2d,
   tensor1_3d,
   anisotropic_symmetric_tensor2_2d,
   isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor4_2d,
   anisotropic_symmetric_tensor4_3d,
   fea_isotropic_symmetric_tensor4_3d,
   fea_iso_orthotropic_symmetric_tensor4_3d,
   fea_transverse_isotropic_symmetric_tensor4_3d,
   fea_column_normalised_orthotropic_symmetric_tensor4_3d,
   fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE symmetric_tensor4_3d = SELECT
 (anisotropic_symmetric_tensor4_3d,
  fea_isotropic_symmetric_tensor4_3d,
  fea_iso_orthotropic_symmetric_tensor4_3d,
  fea_transverse_isotropic_symmetric_tensor4_3d,
  fea_column_normalised_orthotropic_symmetric_tensor4_3d,
  fea_column_normalised_monoclinic_symmetric_tensor4_3d);
END_TYPE;

TYPE anisotropic_symmetric_tensor4_3d = 
     ARRAY [1:21] OF context_dependent_measure;
END_TYPE;

TYPE fea_isotropic_symmetric_tensor4_3d = 
     ARRAY [1:2] OF context_dependent_measure;
END_TYPE;

TYPE fea_iso_orthotropic_symmetric_tensor4_3d = 
     ARRAY [1:3] OF context_dependent_measure;
END_TYPE;

TYPE fea_transverse_isotropic_symmetric_tensor4_3d = 
     ARRAY [1:5] OF context_dependent_measure;
END_TYPE;

TYPE fea_column_normalised_orthotropic_symmetric_tensor4_3d = 
     ARRAY [1:9] OF context_dependent_measure;
END_TYPE;

TYPE fea_column_normalised_monoclinic_symmetric_tensor4_3d = 
     ARRAY [1:13] OF context_dependent_measure;
END_TYPE;

ENTITY tensor_representation_item
  SUBTYPE OF (representation_item);
  tensor_value              : tensor_type;
END_ENTITY;

END_SCHEMA; -- fea_scalar_vector_tensor_schema
(* Genenerated from: ../../irs/wg12n550.exp *)

SCHEMA finite_element_analysis_control_and_result_schema;

  REFERENCE FROM fea_scalar_vector_tensor_schema
      (anisotropic_symmetric_tensor2_2d,
       anisotropic_symmetric_tensor2_3d,
       anisotropic_symmetric_tensor4_2d,
       isotropic_symmetric_tensor2_3d,
       orthotropic_symmetric_tensor2_3d,
       scalar,
       symmetric_tensor2_2d,
       symmetric_tensor2_3d,
       symmetric_tensor4_2d,
       tensor1,
       tensor1_2d,
       tensor1_3d);

  REFERENCE FROM geometric_model_schema 
      (solid_model);

  REFERENCE FROM geometry_schema 
      (curve,
       point,
       surface);

  REFERENCE FROM measure_schema 
      (context_dependent_measure,
       count_measure,
       length_measure,
       plane_angle_measure);

  REFERENCE FROM structural_response_representation_schema 
      (analysis_item_within_representation,
       axisymmetric_curve_2d_element_descriptor,
       axisymmetric_curve_2d_element_representation,
       axisymmetric_surface_2d_element_descriptor,
       axisymmetric_surface_2d_element_representation,
       axisymmetric_volume_2d_element_descriptor,
       axisymmetric_volume_2d_element_representation,
       curve_2d_element_coordinate_system,
       curve_2d_element_descriptor,
       curve_2d_element_group,
       curve_2d_element_representation,
       curve_3d_element_coordinate_system,
       curve_3d_element_descriptor,
       curve_3d_element_group,
       curve_3d_element_representation,
       curve_element_location,
       curve_section_element_location,
       curve_volume_element_location,
       degree_of_freedom,
       directionally_explicit_element_representation,
       element_descriptor,
       element_group,
       element_representation,
       explicit_element_representation,
       fea_axis2_placement_3d,
       fea_model,      
       node_group,
       node_representation,
       plane_curve_2d_element_descriptor,
       plane_curve_2d_element_representation,
       plane_surface_2d_element_descriptor,
       plane_surface_2d_element_representation,
       plane_volume_2d_element_descriptor,
       plane_volume_2d_element_representation,
       point_element_representation,
       substructure_element_representation,
       surface_2d_element_coordinate_system,
       surface_2d_element_descriptor,
       surface_2d_element_group,
       surface_2d_element_representation,
       surface_3d_element_coordinate_system,
       surface_3d_element_descriptor,
       surface_3d_element_group,
       surface_3d_element_representation,
       surface_element_location,
       surface_section_element_location,
       surface_volume_element_location,
       volume_2d_element_coordinate_system,
       volume_2d_element_descriptor,
       volume_2d_element_group,
       volume_2d_element_representation,
       volume_3d_element_coordinate_system,
       volume_3d_element_group,
       volume_3d_element_descriptor,
       volume_3d_element_representation,
       volume_element_location);

  REFERENCE FROM support_resource_schema 
      (identifier,
       label,
       text);

TYPE model_or_control_element = SELECT
     (element_representation,
      constraint_element);
END_TYPE;

TYPE cylindrical_harmonic_number = INTEGER;
WHERE
  WR1: SELF >= 0;
END_TYPE;

TYPE volume_3d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 6);
END_TYPE;

TYPE volume_2d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE volume_3d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 12);
END_TYPE;

TYPE volume_2d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE surface_3d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_3d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 4);
END_TYPE;

TYPE surface_2d_face = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE surface_2d_edge = INTEGER;
WHERE
  WR1: (SELF >= 1) AND (SELF <= 2);
END_TYPE;

TYPE field_value = SELECT 
  (unspecified_value,
   scalar,
   tensor1_2d,
   tensor1_3d,
   anisotropic_symmetric_tensor2_2d,
   isotropic_symmetric_tensor2_3d,
   orthotropic_symmetric_tensor2_3d,
   anisotropic_symmetric_tensor2_3d);
END_TYPE;

TYPE unspecified_value = ENUMERATION OF
  (unspecified);
END_TYPE;

TYPE measure_or_unspecified_value = SELECT
  (context_dependent_measure,
   unspecified_value);
END_TYPE;

TYPE boundary_variable = SELECT
   (boundary_surface_scalar_variable,
   boundary_surface_vector_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable);
END_TYPE;

TYPE boundary_aggregated_variable = SELECT
   (aggregated_vector_3d_variable,
   application_defined_vector_3d_variable);
END_TYPE;

TYPE volume_variable = SELECT 
  (volume_scalar_variable,
   volume_angular_variable,
   volume_vector_3d_variable,
   volume_tensor2_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable,
   application_defined_tensor2_3d_variable);
END_TYPE;

TYPE volume_aggregated_variable = SELECT 
  (aggregated_scalar_variable,
   aggregated_angular_variable,
   aggregated_vector_3d_variable,
   aggregated_tensor2_3d_variable,
   application_defined_scalar_variable,
   application_defined_vector_3d_variable,
   application_defined_tensor2_3d_variable);
END_TYPE;

TYPE surface_element_variable = SELECT
  (volume_variable,
   surface_scalar_variable,
   surface_vector_2d_variable,
   surface_vector_3d_variable,
   surface_tensor2_2d_variable,
   application_defined_tensor2_2d_variable);
END_TYPE;

TYPE boundary_edge_variable = SELECT
   (boundary_curve_scalar_variable,
    boundary_curve_vector_3d_variable,
    application_defined_scalar_variable,
    application_defined_vector_3d_variable);
END_TYPE;

TYPE curve_element_variable = SELECT
  (volume_variable,
   curve_scalar_variable,
   curve_vector_2d_variable,
   application_defined_vector_2d_variable,
   curve_vector_3d_variable);
END_TYPE;

TYPE curve_scalar_variable = ENUMERATION OF 
     (curve_axial_force,
      curve_axial_strain,
      torque,
      curve_warping,
      bi_moment,
      twist);
END_TYPE;

TYPE surface_scalar_variable = ENUMERATION OF 
     (thickness,
      surface_thermal_gradient,
      reference_surface_thermal_gradient);
END_TYPE;

TYPE volume_scalar_variable = ENUMERATION OF 
     (temperature,
      moisture,
      reference_temperature,
      strain_energy_per_unit_volume);
END_TYPE;

TYPE boundary_curve_scalar_variable = ENUMERATION OF 
     (normal_force_per_unit_length);
END_TYPE;

TYPE boundary_surface_scalar_variable = ENUMERATION OF 
     (pressure);
END_TYPE;

TYPE aggregated_scalar_variable = ENUMERATION OF 
     (total_strain_energy,
      mass,
      volume);
END_TYPE;

TYPE volume_angular_variable = ENUMERATION OF 
     (constant_angular_acceleration,
      application_defined_angular_scalar_variable);
END_TYPE;

TYPE aggregated_angular_variable = ENUMERATION OF 
      (total_applied_moment,
       application_defined_aggregated_angular_scalar_variable);
END_TYPE;

TYPE application_defined_scalar_variable = STRING;
END_TYPE;

TYPE curve_vector_2d_variable = ENUMERATION OF 
     (curve_shear_force,
      curve_bending_moment,
      curve_element_curvature,
      curve_thermal_gradient,
      reference_curve_thermal_gradient);
END_TYPE;

TYPE surface_vector_2d_variable = ENUMERATION OF 
     (surface_out_of_plane_shear_force,
      surface_out_of_plane_shear_strain);
END_TYPE;

TYPE application_defined_vector_2d_variable = STRING;
END_TYPE;

TYPE curve_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_length,
      applied_moment_per_unit_length);
END_TYPE;

TYPE surface_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_area,
      applied_moment_per_unit_area);
END_TYPE;

TYPE volume_vector_3d_variable = ENUMERATION OF 
     (position,
      applied_force_per_unit_volume,
      applied_moment_per_unit_volume,
      displacement,
      infinitesimal_rotation,
      acceleration);
END_TYPE;

TYPE boundary_curve_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_length,
      applied_moment_per_unit_length);
END_TYPE;

TYPE boundary_surface_vector_3d_variable = ENUMERATION OF 
     (applied_force_per_unit_area,
      applied_moment_per_unit_area);
END_TYPE;

TYPE aggregated_vector_3d_variable = ENUMERATION OF 
     (total_applied_force,
      centre_of_mass_offset);
END_TYPE;

TYPE application_defined_vector_3d_variable = STRING;
END_TYPE;

TYPE surface_tensor2_2d_variable = ENUMERATION OF 
     (surface_membrane_force,
      surface_membrane_strain,
      surface_bending_moment,
      surface_curvature);
END_TYPE;

TYPE application_defined_tensor2_2d_variable = STRING;
END_TYPE;

TYPE volume_tensor2_3d_variable = ENUMERATION OF 
     (total_strain,
      stress);
END_TYPE;

TYPE aggregated_tensor2_3d_variable = ENUMERATION OF 
     (rotational_inertia);
END_TYPE;

TYPE application_defined_tensor2_3d_variable = STRING;
END_TYPE;

TYPE message_level = ENUMERATION OF 
     (error,
      warning,
      note);
END_TYPE;

TYPE surface_3d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_2d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      surface_2d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_2d_state_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_2d_element_coordinate_system);
END_TYPE;

TYPE action_type = ENUMERATION OF
     (applied_loads,
      residual_loads);
END_TYPE;

TYPE volume_3d_element_output_reference = SELECT
     (volume_3d_element_representation,
      volume_3d_element_descriptor,
      volume_3d_element_group,
      volume_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE volume_2d_element_output_reference = SELECT
     (volume_2d_element_representation,
      volume_2d_element_descriptor,
      volume_2d_element_group,
      volume_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE surface_3d_element_output_reference = SELECT
     (surface_3d_element_representation,
      surface_3d_element_descriptor,
      surface_3d_element_group,
      surface_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE surface_2d_element_output_reference = SELECT
     (surface_2d_element_representation,
      surface_2d_element_descriptor,
      surface_2d_element_group,
      surface_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE curve_3d_element_output_reference = SELECT
     (curve_3d_element_representation,
      curve_3d_element_descriptor,
      curve_3d_element_group,
      curve_3d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE curve_2d_element_output_reference = SELECT
     (curve_2d_element_representation,
      curve_2d_element_descriptor,
      curve_2d_element_group,
      curve_2d_substructure_element_reference,
      analysis_item_within_representation);
END_TYPE;

TYPE node_output_reference = SELECT
     (node_representation,
      node_group,
      substructure_node_reference,
      analysis_item_within_representation);
END_TYPE;

ENTITY control;                             
  model_ref                 : fea_model;
  control_id                : identifier;
  creating_software         : text;  
  description               : text;
  user_defined_control      : SET [1:?] OF text;
  intended_analysis_code    : SET [1:?] of text;
UNIQUE
  UR1: model_ref, control_id;
END_ENTITY;      

ENTITY analysis_step
  SUPERTYPE OF (ONEOF (control_analysis_step,
                       result_analysis_step));
  analysis_control          : control;
END_ENTITY;

ENTITY control_analysis_step
  SUPERTYPE OF (ONEOF(control_linear_static_analysis_step,
                control_linear_modes_and_frequencies_analysis_step))
  SUBTYPE OF (analysis_step);
  step_id                   : identifier;
  sequence                  : integer;
  initial_state             : state;
  description               : text;
UNIQUE
  UR1: SELF\analysis_step.analysis_control, sequence;
  UR2: SELF\analysis_step.analysis_control, step_id;
END_ENTITY;    

ENTITY symmetry_control
  SUPERTYPE OF (ONEOF (no_symmetry_control,
                       cylindrical_symmetry_control));
END_ENTITY;    

ENTITY no_symmetry_control
  SUBTYPE OF (symmetry_control);
END_ENTITY;    

ENTITY cylindrical_symmetry_control
  SUBTYPE OF (symmetry_control);
  harmonic                  : cylindrical_harmonic_number;
  phase                     : measure_or_unspecified_value;
END_ENTITY;    

ENTITY control_linear_static_analysis_step
  SUBTYPE OF (control_analysis_step);
  process                   : control_linear_static_load_increment_process;   
END_ENTITY;    

ENTITY control_linear_static_analysis_step_with_harmonic
  SUBTYPE OF (control_linear_static_analysis_step);
  symmetry                  : cylindrical_symmetry_control;
END_ENTITY;    

ENTITY control_linear_modes_and_frequencies_analysis_step
  SUBTYPE OF (control_analysis_step);
  process                   : control_linear_modes_and_frequencies_process;
  number_of_modes           : count_measure;
  frequency_range           : ARRAY [1:2] OF context_dependent_measure;
END_ENTITY;    

ENTITY constraint_element
  SUPERTYPE OF (ONEOF (single_point_constraint_element,
                       linear_constraint_equation_element,
                       nodal_dof_reduction,
                       point_constraint,
                       curve_constraint,
                       surface_constraint,
                       solid_constraint));
  element_id                : identifier;
  steps                     : SET [1:?] OF control_analysis_step;
END_ENTITY;                              

ENTITY single_point_constraint_element
  SUBTYPE OF (constraint_element);
  required_node             : node_output_reference;
  coordinate_system         : fea_axis2_placement_3d;  
  freedoms_and_values       : SET [1:?] OF freedom_and_coefficient;
  description               : text;
END_ENTITY;

ENTITY linear_constraint_equation_element
  SUBTYPE OF (constraint_element);
  freedoms_and_coefficients : SET [1:?] OF 
                                 linear_constraint_equation_nodal_term;
  description               : text;
END_ENTITY;

ENTITY linear_constraint_equation_nodal_term;
  node                      : node_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedom_and_coefficient_term : freedom_and_coefficient;
  dependent                 : LOGICAL;
END_ENTITY;

ENTITY freedom_and_coefficient;
  freedom                   : degree_of_freedom;
  a                         : measure_or_unspecified_value;
END_ENTITY;

ENTITY nodal_dof_reduction
  SUBTYPE OF (constraint_element);
  required_node             : node_output_reference;
  coordinate_system         : fea_axis2_placement_3d;  
  freedoms                  : SET [1:?] OF degree_of_freedom;
  description               : text;
END_ENTITY;

ENTITY point_constraint
  SUBTYPE OF (constraint_element);
  required_point            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.POINT' IN TYPEOF (required_point.item)) OR
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;

ENTITY curve_constraint
  SUBTYPE OF (constraint_element);
  required_curve            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (required_curve.item)) OR
       ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;

ENTITY surface_constraint
  SUBTYPE OF (constraint_element);
  required_surface          : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;

ENTITY solid_constraint
  SUBTYPE OF (constraint_element);
  required_solid            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  freedoms_and_coefficients : SET [1:?] OF freedom_and_coefficient;
  description               : text;
WHERE
  WR1: 'GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;

ENTITY control_process
  SUPERTYPE OF (ONEOF (control_linear_static_load_increment_process,
                       control_linear_modes_and_frequencies_process));
  process_id                : identifier;
  description               : text;
END_ENTITY;

ENTITY control_linear_static_load_increment_process
  SUBTYPE OF (control_process);
  final_input_state         : state;
END_ENTITY;

ENTITY control_linear_modes_and_frequencies_process
  SUBTYPE OF (control_process);
  final_input_state         : state;
END_ENTITY;

ENTITY element_sequence;
  order_id                  : identifier;
  control_ref               : control;
  purpose                   : text;
  elements                  : LIST [1:?] OF model_or_control_element;
UNIQUE
  UR1: order_id, control_ref;
END_ENTITY;

ENTITY node_sequence;
  order_id                  : identifier;
  control_ref               : control;
  purpose                   : text;
  nodes                     : LIST [1:?] OF node_representation;
UNIQUE
  UR1: order_id, control_ref;
END_ENTITY;

ENTITY result;                             
  result_id                 : identifier;
  creating_software         : text;  
  description               : text;
END_ENTITY;      

ENTITY result_analysis_step
  SUPERTYPE OF (ONEOF (result_linear_static_analysis_sub_step,
                result_linear_modes_and_frequencies_analysis_sub_step))
  SUBTYPE OF (analysis_step);
  analysis_result           : result;
UNIQUE
  UR1: SELF\analysis_step.analysis_control, analysis_result;
END_ENTITY;

ENTITY result_linear_static_analysis_sub_step
  SUBTYPE OF (result_analysis_step);
  state                     : calculated_state;
END_ENTITY;

ENTITY result_linear_modes_and_frequencies_analysis_sub_step
  SUBTYPE OF (result_analysis_step);
  states                    : SET [1:?] OF calculated_state;
END_ENTITY;

ENTITY control_result_relationship;
  control                   : control_analysis_step;
  result                    : result_analysis_step;
END_ENTITY;

ENTITY state
  SUPERTYPE OF (ONEOF (specified_state,
                       calculated_state,
                       linearly_superimposed_state,
                       output_request_state));
  state_id                  : identifier;
  description               : text;
END_ENTITY;    

ENTITY state_with_harmonic
  SUBTYPE OF (state);
  symmetry                  : cylindrical_symmetry_control;
END_ENTITY;    

ENTITY specified_state
  SUBTYPE OF (state);
END_ENTITY;

ENTITY calculated_state
  SUBTYPE OF (state);
END_ENTITY;

ENTITY linearly_superimposed_state
  SUBTYPE OF (state);
INVERSE
  components                : SET [1:?] OF state_component FOR state;
END_ENTITY;

ENTITY state_component
  SUBTYPE OF (state);
  state                     : linearly_superimposed_state;
  factor                    : context_dependent_measure;
END_ENTITY;

ENTITY output_request_state
  SUBTYPE OF (state);
  steps                     : SET [1:?] OF control_analysis_step;
END_ENTITY;

ENTITY state_relationship;
  name                      : label;
  description               : text;
  relating_state            : state;
  related_state             : state;
END_ENTITY;

ENTITY state_definition
  SUPERTYPE OF (ONEOF (field_variable_definition,
                       nodal_freedom_and_value_definition,
                       element_nodal_freedom_actions,
                       point_freedom_and_value_definition,
                       curve_freedom_and_value_definition,
                       surface_freedom_and_value_definition,
                       solid_freedom_and_value_definition,
                       linear_constraint_equation_element_value,
                       single_point_constraint_element_values,
                       analysis_message));
  defined_state             : state;
END_ENTITY;

ENTITY field_variable_definition
  SUPERTYPE OF (ONEOF (field_variable_element_definition,
                       field_variable_element_group_value,
                       field_variable_whole_model_value,
                       field_variable_node_definition))
  SUBTYPE OF (state_definition);
END_ENTITY;

ENTITY field_variable_element_definition
  SUPERTYPE OF (ONEOF (volume_3d_element_field_variable_definition,
                       volume_2d_element_field_variable_definition,
                       surface_3d_element_field_variable_definition,
                       surface_2d_element_field_variable_definition,
                       curve_3d_element_field_variable_definition,
                       curve_2d_element_field_variable_definition))
  SUBTYPE OF (field_variable_definition);
END_ENTITY;

ENTITY volume_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
   volume_3d_element_location_point_variable_values,
   volume_3d_whole_element_variable_value,
   volume_3d_element_constant_specified_variable_value,
   volume_3d_element_nodal_specified_variable_values,
   volume_3d_element_boundary_location_point_variable_values,
   volume_3d_element_boundary_whole_face_variable_value,
   volume_3d_element_boundary_constant_specified_variable_value,
   volume_3d_element_boundary_nodal_specified_variable_values,
   volume_3d_element_boundary_edge_location_point_volume_variable_values,
   volume_3d_element_boundary_edge_whole_edge_variable_value,
   volume_3d_element_boundary_edge_constant_specified_volume_variable_value,
   volume_3d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : volume_3d_element_output_reference;
END_ENTITY;

ENTITY volume_3d_element_location_point_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : volume_element_location;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY volume_3d_whole_element_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_constant_specified_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : volume_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_location_point_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_whole_face_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : volume_3d_face;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : volume_3d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_3d_element_boundary_edge_location_point_volume_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_3d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : volume_3d_edge;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_3d_element_boundary_edge_constant_specified_volume_variable_value
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_3d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (volume_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : volume_3d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
   volume_2d_element_location_point_variable_values,
   volume_2d_whole_element_variable_value,
   volume_2d_element_constant_specified_variable_value,
   volume_2d_element_nodal_specified_variable_values,
   volume_2d_element_boundary_location_point_variable_values,
   volume_2d_element_boundary_whole_face_variable_value,
   volume_2d_element_boundary_constant_specified_variable_value,
   volume_2d_element_boundary_nodal_specified_variable_values,
   volume_2d_element_boundary_edge_location_point_volume_variable_values,
   volume_2d_element_boundary_edge_whole_edge_variable_value,
   volume_2d_element_boundary_edge_constant_specified_volume_variable_value,
   volume_2d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : volume_2d_element_output_reference;
END_ENTITY;

ENTITY volume_2d_element_location_point_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : volume_element_location;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY volume_2d_whole_element_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_constant_specified_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value; 
  additional_node_values    : BOOLEAN;
  variable                  : volume_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_location_point_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : volume_2d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_whole_face_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : volume_2d_face;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : volume_2d_face;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  variable                  : boundary_variable;
  additional_node_values    : BOOLEAN;
  element_face              : volume_2d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_2d_element_boundary_edge_location_point_volume_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              volume_2d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : volume_2d_edge;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 volume_2d_element_boundary_edge_constant_specified_volume_variable_value
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (volume_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : volume_2d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
  surface_3d_element_location_point_volume_variable_values,
  surface_3d_element_location_point_variable_values,
  surface_3d_whole_element_variable_value,
  surface_3d_element_constant_specified_variable_value,
  surface_3d_element_constant_specified_volume_variable_value,
  surface_3d_element_nodal_specified_variable_values,
  surface_3d_element_boundary_location_point_surface_variable_values,
  surface_3d_element_boundary_whole_face_variable_value,
  surface_3d_element_boundary_constant_specified_variable_value,
  surface_3d_element_boundary_constant_specified_surface_variable_value,
  surface_3d_element_boundary_nodal_specified_variable_values,
  surface_3d_element_boundary_edge_location_point_surface_variable_values,
  surface_3d_element_boundary_edge_location_point_variable_values,
  surface_3d_element_boundary_edge_whole_edge_variable_value,
  surface_3d_element_boundary_edge_constant_specified_variable_value,
  surface_3d_element_boundary_edge_constant_specified_surface_variable_value,
  surface_3d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : surface_3d_element_output_reference;
END_ENTITY;

ENTITY surface_3d_element_location_point_volume_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));

END_ENTITY;

ENTITY surface_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : surface_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_3d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : surface_volume_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_3d_element_location_point_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_whole_element_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_constant_specified_volume_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_location_point_surface_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_whole_face_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_constant_specified_surface_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_3d_face;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : surface_3d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_location_point_surface_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_volume_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_location_point_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_3d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_3d_element_boundary_edge_constant_specified_surface_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_constant_specified_variable_value
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
  coordinate_system         : OPTIONAL surface_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (surface_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : surface_3d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
  surface_2d_element_location_point_volume_variable_values,
  surface_2d_element_location_point_variable_values,
  surface_2d_whole_element_variable_value,
  surface_2d_element_constant_specified_variable_value,
  surface_2d_element_constant_specified_volume_variable_value,
  surface_2d_element_nodal_specified_variable_values,
  surface_2d_element_boundary_location_point_surface_variable_values,
  surface_2d_element_boundary_whole_face_variable_value,
  surface_2d_element_boundary_constant_specified_variable_value,
  surface_2d_element_boundary_constant_specified_surface_variable_value,
  surface_2d_element_boundary_nodal_specified_variable_values,
  surface_2d_element_boundary_edge_location_point_surface_variable_values,
  surface_2d_element_boundary_edge_location_point_variable_values,
  surface_2d_element_boundary_edge_whole_edge_variable_value,
  surface_2d_element_boundary_edge_constant_specified_variable_value,
  surface_2d_element_boundary_edge_constant_specified_surface_variable_value,
  surface_2d_element_boundary_edge_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : surface_2d_element_output_reference;
END_ENTITY;

ENTITY surface_2d_element_location_point_volume_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : surface_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_2d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : surface_volume_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY surface_2d_element_location_point_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_whole_element_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_constant_specified_volume_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : surface_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_location_point_surface_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_whole_face_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_constant_specified_surface_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_face              : surface_2d_face;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_variable;
  element_face              : surface_2d_face;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_location_point_surface_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_volume_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_location_point_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              surface_2d_element_value_and_location;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_whole_edge_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_aggregated_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY 
 surface_2d_element_boundary_edge_constant_specified_surface_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_constant_specified_variable_value
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
  coordinate_system         : OPTIONAL surface_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_element_boundary_edge_nodal_specified_variable_values
  SUBTYPE OF (surface_2d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : boundary_edge_variable;
  element_edge              : surface_2d_edge;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_3d_element_location_point_volume_variable_values,
            curve_3d_element_location_point_variable_values,
            curve_3d_whole_element_variable_value,
            curve_3d_element_constant_specified_variable_value,
            curve_3d_element_constant_specified_volume_variable_value,
            curve_3d_element_nodal_specified_variable_values))

  SUBTYPE OF (field_variable_element_definition);
  element                   : curve_3d_element_output_reference;
END_ENTITY;

ENTITY curve_3d_element_location_point_volume_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_3d_element_value_and_volume_location;
  variable                  : volume_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_value_and_location;
  simple_value              : field_value;
  location                  : curve_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_3d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : curve_volume_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_3d_element_location_point_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_3d_element_value_and_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_whole_element_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_constant_specified_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_constant_specified_volume_variable_value
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL curve_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_element_nodal_specified_variable_values
  SUBTYPE OF (curve_3d_element_field_variable_definition);
  values                    : LIST [1:?] OF field_value;
  additional_node_values    : BOOLEAN;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_list_values (values, variable);
  WR2: appropriate_list_value_existence (values, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_2d_element_location_point_volume_variable_values,
            curve_2d_element_location_point_variable_values,
            curve_2d_whole_element_variable_value,
            curve_2d_element_constant_specified_variable_value,
            curve_2d_element_constant_specified_volume_variable_value))
  SUBTYPE OF (field_variable_element_definition);
  element                   : curve_2d_element_output_reference;
END_ENTITY;

ENTITY curve_2d_element_location_point_volume_variable_values
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_2d_element_value_and_volume_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_value_and_location;
  simple_value              : field_value;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_2d_element_value_and_volume_location;
  simple_value              : field_value;
  location                  : curve_volume_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
END_ENTITY;

ENTITY curve_2d_element_location_point_variable_values
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  basis                     : BOOLEAN;
  values_and_locations      : SET [1:?] OF 
                              curve_2d_element_value_and_location;
  variable                  : curve_element_variable;
WHERE
  WR1: consistent_set_values (values_and_locations, variable);
  WR2: appropriate_set_value_existence (values_and_locations, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_whole_element_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_constant_specified_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_element_constant_specified_volume_variable_value
  SUBTYPE OF (curve_2d_element_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL curve_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_element_group_value
  SUBTYPE OF (field_variable_definition);
  group                     : element_group;
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL fea_axis2_placement_3d;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_whole_model_value
  SUBTYPE OF (field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL fea_axis2_placement_3d;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY field_variable_node_definition
  SUPERTYPE OF (ONEOF (volume_3d_node_field_variable_definition,
                       volume_2d_node_field_variable_definition,
                       surface_3d_node_field_variable_definition,
                       surface_2d_node_field_variable_definition,
                       curve_3d_node_field_variable_definition,
                       curve_2d_node_field_variable_definition))
  SUBTYPE OF (field_variable_definition);
  node                      : node_output_reference;
  group                     : OPTIONAL element_group;
END_ENTITY;

ENTITY volume_3d_node_field_variable_definition
  SUBTYPE OF (field_variable_node_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_3d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY volume_2d_node_field_variable_definition
  SUBTYPE OF (field_variable_node_definition);
  simple_value              : field_value;
  variable                  : volume_variable;
  coordinate_system         : OPTIONAL volume_2d_element_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            surface_3d_node_field_section_variable_values,
            surface_3d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY surface_3d_node_field_section_variable_values
  SUBTYPE OF (surface_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  location                  : surface_section_element_location;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_3d_node_field_aggregated_variable_values
  SUBTYPE OF (surface_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            surface_2d_node_field_section_variable_values,
            surface_2d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY surface_2d_node_field_section_variable_values
  SUBTYPE OF (surface_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : surface_element_variable;
  location                  : surface_section_element_location;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY surface_2d_node_field_aggregated_variable_values
  SUBTYPE OF (surface_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL surface_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_3d_node_field_section_variable_values,
            curve_3d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY curve_3d_node_field_section_variable_values
  SUBTYPE OF (curve_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_3d_node_field_aggregated_variable_values
  SUBTYPE OF (curve_3d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_3d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_node_field_variable_definition
  SUPERTYPE OF (ONEOF (
            curve_2d_node_field_section_variable_values,
            curve_2d_node_field_aggregated_variable_values))
  SUBTYPE OF (field_variable_node_definition);
END_ENTITY;

ENTITY curve_2d_node_field_section_variable_values
  SUBTYPE OF (curve_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : curve_element_variable;
  location                  : curve_section_element_location;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY curve_2d_node_field_aggregated_variable_values
  SUBTYPE OF (curve_2d_node_field_variable_definition);
  simple_value              : field_value;
  variable                  : volume_aggregated_variable;
  coordinate_system         : OPTIONAL curve_2d_state_coordinate_system;
WHERE
  WR1: necessary_value_coordinate_system (simple_value, coordinate_system);
  WR2: consistent_value (simple_value, variable);
  WR3: appropriate_value_existence (simple_value, 
       TYPEOF (SELF\state_definition.defined_state));
END_ENTITY;

ENTITY nodal_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (nodal_freedom_values,
                       nodal_freedom_action_definition))
  SUBTYPE OF (state_definition);
  node                      : node_output_reference;    
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;

ENTITY nodal_freedom_values
  SUBTYPE OF (nodal_freedom_and_value_definition);
END_ENTITY;

ENTITY nodal_freedom_action_definition
  SUBTYPE OF (nodal_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY element_nodal_freedom_actions
  SUBTYPE OF (state_definition);
  element                   : model_or_control_element;
  nodal_action              : LIST [1:?] OF 
                                 element_nodal_freedom_terms;
END_ENTITY;

ENTITY element_nodal_freedom_terms;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
END_ENTITY;

ENTITY point_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (point_freedom_values,
                       point_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_point            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.POINT' IN TYPEOF (required_point.item)) OR
       ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF (required_point.item));
END_ENTITY;

ENTITY point_freedom_values
  SUBTYPE OF (point_freedom_and_value_definition);
END_ENTITY;

ENTITY point_freedom_action_definition
  SUBTYPE OF (point_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY curve_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (curve_freedom_values,
                       curve_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_curve            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (required_curve.item)) OR
       ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (required_curve.item));
END_ENTITY;

ENTITY curve_freedom_values
  SUBTYPE OF (curve_freedom_and_value_definition);
END_ENTITY;

ENTITY curve_freedom_action_definition
  SUBTYPE OF (curve_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY surface_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (surface_freedom_values,
                       surface_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_surface          : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF (required_surface.item)) OR
       ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF (required_surface.item));
END_ENTITY;

ENTITY surface_freedom_values
  SUBTYPE OF (surface_freedom_and_value_definition);
END_ENTITY;

ENTITY surface_freedom_action_definition
  SUBTYPE OF (surface_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY solid_freedom_and_value_definition
  SUPERTYPE OF (ONEOF (solid_freedom_values,
                       solid_freedom_action_definition))
  SUBTYPE OF (state_definition);
  required_solid            : analysis_item_within_representation;
  coordinate_system         : fea_axis2_placement_3d;
  degrees_of_freedom        : freedoms_list;
  values                    : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values);
  WR2: 'GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN TYPEOF (required_solid.item);
END_ENTITY;

ENTITY solid_freedom_values
  SUBTYPE OF (solid_freedom_and_value_definition);
END_ENTITY;

ENTITY solid_freedom_action_definition
  SUBTYPE OF (solid_freedom_and_value_definition);
  action                    : action_type;
END_ENTITY;

ENTITY freedoms_list;
  freedoms                  : LIST [1:?] OF degree_of_freedom;
END_ENTITY;

ENTITY linear_constraint_equation_element_value
  SUBTYPE OF (state_definition);
  element                   : linear_constraint_equation_element;
  b                         : measure_or_unspecified_value;
END_ENTITY;

ENTITY single_point_constraint_element_values
  SUBTYPE OF (state_definition);
  element                   : single_point_constraint_element;
  degrees_of_freedom        : freedoms_list;
  b                         : LIST [1:?] OF measure_or_unspecified_value;
WHERE
  WR1: SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (b);
END_ENTITY;

ENTITY analysis_message
  SUPERTYPE OF (ONEOF (whole_model_analysis_message,
                       element_analysis_message,
                       node_analysis_message,
                       element_group_analysis_message))
  SUBTYPE OF (state_definition);
  level                     : message_level;
  message_text              : text;
END_ENTITY;

ENTITY whole_model_analysis_message
  SUPERTYPE OF (whole_model_modes_and_frequencies_analysis_message)
  SUBTYPE OF (analysis_message);
END_ENTITY;

ENTITY whole_model_modes_and_frequencies_analysis_message
  SUBTYPE OF (whole_model_analysis_message);
  mode                      : count_measure;
  frequency                 : context_dependent_measure;
END_ENTITY;

ENTITY element_analysis_message
  SUBTYPE OF (analysis_message);
  element                   : element_representation;
END_ENTITY;

ENTITY node_analysis_message
  SUBTYPE OF (analysis_message);
  node                      : node_output_reference;
END_ENTITY;

ENTITY element_group_analysis_message
  SUBTYPE OF (analysis_message);
  group                     : element_group;
END_ENTITY;

ENTITY volume_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : volume_3d_element_representation;
END_ENTITY;

ENTITY volume_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : volume_2d_element_representation;
END_ENTITY;

ENTITY surface_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : surface_3d_element_representation;
END_ENTITY;

ENTITY surface_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : surface_2d_element_representation;
END_ENTITY;

ENTITY curve_3d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : curve_3d_element_representation;
END_ENTITY;

ENTITY curve_2d_substructure_element_reference;
  substructure_element_ref  : substructure_element_representation;
  element_ref               : curve_2d_element_representation;
END_ENTITY;

ENTITY substructure_node_reference;
  substructure_element_ref  : substructure_element_representation;
  node_ref                  : node_representation;
END_ENTITY;

FUNCTION necessary_value_coordinate_system 
    (cs_value               : field_value;
     coordinate_system      : GENERIC): BOOLEAN;

    IF (SIZEOF (
        ['FEA_SCALAR_VECTOR_TENSOR_SCHEMA.TENSOR1_2D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.TENSOR1_3D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.SYMMETRIC_TENSOR2_2D',
         'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.SYMMETRIC_TENSOR2_3D'] *
        TYPEOF (cs_value)) = 1) THEN
        IF (NOT EXISTS (coordinate_system) ) THEN
            RETURN (FALSE);
        END_IF;
    END_IF;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_set_values
    (values_and_locations   : SET [1:?] OF GENERIC;
     variable               : GENERIC) : BOOLEAN;

    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values_and_locations);

       fv_type := TYPEOF (values_and_locations[i].simple_value);

       IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_list_values
    (values                 : LIST [1:?] OF field_value;
     variable               : GENERIC) : BOOLEAN;
 
    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values);

       fv_type := TYPEOF (values[i]);

       IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION consistent_value
    (c_value                : field_value;
     variable               : GENERIC) : BOOLEAN;

    LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    fv_type := TYPEOF (c_value);

    IF NOT (('FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.' +
       'UNSPECIFIED_VALUE') IN fv_type) THEN

       IF NOT (vv_type IN fv_type) THEN
          RETURN (FALSE);
       END_IF;

    END_IF;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION variable_value_type
    (variable               : GENERIC) : STRING;

    LOCAL
     svt                    : STRING;
     feacr                  : STRING;
     variable_typeof        : SET [1:?] OF STRING;
    END_LOCAL;
        
    svt     := 'FEA_SCALAR_VECTOR_TENSOR_SCHEMA.';
    feacr   := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
    variable_typeof := TYPEOF (variable);

    IF SIZEOF ([(feacr + 'CURVE_SCALAR_VARIABLE'),
                (feacr + 'SURFACE_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_SCALAR_VARIABLE'),
                (feacr + 'AGGREGATED_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_ANGULAR_VARIABLE'),
                (feacr + 'AGGREGATED_ANGULAR_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_SCALAR_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SCALAR');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_2D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_2D');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'VOLUME_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'AGGREGATED_VECTOR_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'SURFACE_TENSOR2_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'VOLUME_TENSOR2_3D_VARIABLE'),
                (feacr + 'AGGREGATED_TENSOR2_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    RETURN ('NO_MATCH');

END_FUNCTION;

FUNCTION appropriate_set_value_existence
    (values_and_locations   : SET [1:?] OF GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values_and_locations);
       IF NOT (appropriate_value_existence
                (values_and_locations[i].simple_value, type_self)) 
          THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION appropriate_list_value_existence
    (values                 : LIST [1:?] OF GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values);
       IF NOT (appropriate_value_existence (values[i], type_self)) THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION appropriate_value_existence
    (a_value_e              : GENERIC;
     type_self              : SET [1:?] OF STRING) : BOOLEAN;

    LOCAL
     feacr                  : STRING;
     value_typeof           : SET [1:?] OF STRING;
    END_LOCAL;
        
    feacr := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
    value_typeof := TYPEOF(a_value_e);

    IF (((feacr + 'OUTPUT_REQUEST_STATE') IN type_self) AND
       NOT ((feacr + 'UNSPECIFIED_VALUE') IN value_typeof)) THEN
       RETURN (FALSE);
    END_IF;

    RETURN (TRUE);

END_FUNCTION;

END_SCHEMA; -- finite_element_analysis_control_and_result_schema
 (* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)

 SCHEMA geometric_model_schema;
   REFERENCE FROM geometry_schema;
   REFERENCE FROM topology_schema;
   REFERENCE FROM measure_schema(length_measure,
                                 parameter_value,
                                 plane_angle_measure,
                                 plane_angle_unit,
                                 positive_length_measure,
                                 positive_plane_angle_measure);
   REFERENCE FROM representation_schema(founded_item);

 TYPE boolean_operand = SELECT
   (solid_model, 
    half_space_solid,
    csg_primitive,
    boolean_result,
    half_space_2d);
 END_TYPE;

 TYPE boolean_operator = ENUMERATION OF 
   (union, 
    intersection, 
    difference);
 END_TYPE;

 TYPE csg_select = SELECT
   (boolean_result,
    csg_primitive);
 END_TYPE;

 TYPE csg_primitive = SELECT
   (sphere,
    ellipsoid,
    block,
    right_angular_wedge,
    faceted_primitive,
    rectangular_pyramid,
    torus,
    right_circular_cone,
    eccentric_cone,
    right_circular_cylinder,
    cyclide_segment_solid,
    primitive_2d);
 END_TYPE;

 TYPE geometric_set_select = SELECT
   (point,
    curve,
    surface);
 END_TYPE;

 TYPE surface_model = SELECT
   (shell_based_surface_model, 
    face_based_surface_model);
 END_TYPE;

 TYPE wireframe_model = SELECT
   (shell_based_wireframe_model,
    edge_based_wireframe_model);
 END_TYPE;

 ENTITY block
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boolean_result
   SUBTYPE OF (geometric_representation_item);
   operator        : boolean_operator;
   first_operand   :  boolean_operand;
   second_operand  :  boolean_operand;
 END_ENTITY;

 ENTITY box_domain
   SUBTYPE OF (founded_item);
   corner  : cartesian_point;
   xlength : positive_length_measure;
   ylength : positive_length_measure;
   zlength : positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE'
                    IN TYPEOF(item)))) = 0;
 END_ENTITY;

 ENTITY boxed_half_space
   SUBTYPE OF(half_space_solid);
   enclosure : box_domain;
 END_ENTITY;

 ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
  WHERE
    WR1:  SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE',
          'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] *
              TYPEOF (SELF.extent)) = 0;
   WR2 : SIZEOF (QUERY (bnds <* extent.bounds |
         NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
   WR3 : SIZEOF (QUERY (bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
   WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
          NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT
          (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND
         (oe.edge_element\geometric_representation_item.dim = 2)))) =
                0))) = 0;
 END_ENTITY;

 ENTITY brep_with_voids
   SUBTYPE OF (manifold_solid_brep);
   voids : SET [1:?] OF oriented_closed_shell;
 END_ENTITY;

ENTITY  circular_area
  SUBTYPE OF (primitive_2d);
    centre: cartesian_point;
    radius: positive_length_measure;
END_ENTITY;

 ENTITY convex_hexahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 8 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR8: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR9: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR10: same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR11: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR12: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR13: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
  END_ENTITY;

 ENTITY csg_solid
   SUBTYPE OF (solid_model);
   tree_root_expression : csg_select;
 END_ENTITY;

ENTITY cyclide_segment_solid
   SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   radius1     : positive_length_measure;
   radius2     : positive_length_measure;
   cone_angle1 : plane_angle_measure;
   cone_angle2 : plane_angle_measure;
   turn_angle  : plane_angle_measure;
END_ENTITY;

 ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY edge_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   ebwm_boundary  : SET [1:?] OF connected_edge_set;
 END_ENTITY;

 ENTITY face_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   fbsm_faces : SET [1:?] OF connected_face_set;
 END_ENTITY;

 ENTITY geometric_curve_set
   SUBTYPE OF (geometric_set);
 WHERE
   WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
 END_ENTITY;

 ENTITY geometric_set
   SUPERTYPE OF (ONEOF(geometric_curve_set,
                       geometric_set_replica))
   SUBTYPE OF (geometric_representation_item);
   elements :  SET [1:?] OF geometric_set_select;
 END_ENTITY;

 ENTITY ellipsoid
   SUBTYPE OF (geometric_representation_item);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

ENTITY  elliptic_area
  SUBTYPE OF (primitive_2d);
    position : axis2_placement_2d;
    semi_axis_1 : positive_length_measure;
    semi_axis_2 : positive_length_measure;
END_ENTITY;

 ENTITY extruded_area_solid
   SUBTYPE OF (swept_area_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_area_solid.swept_area.basis_surface\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY extruded_face_solid
   SUBTYPE OF (swept_face_solid);
   extruded_direction : direction;
   depth              : positive_length_measure;
 WHERE
   WR1: dot_product(
        (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction) <> 0.0;
 END_ENTITY;

 ENTITY faceted_brep
   SUBTYPE OF (manifold_solid_brep);
 END_ENTITY;

 ENTITY faceted_primitive
   SUPERTYPE OF (ONEOF(tetrahedron, convex_hexahedron))
   SUBTYPE OF (geometric_representation_item) ;
     points : LIST[4:?] OF UNIQUE cartesian_point ;
  WHERE
    WR1: points[1].dim = 3 ;
  END_ENTITY;

  ENTITY geometric_set_replica
   SUBTYPE OF (geometric_set); 
     parent_set     : geometric_set; 
     transformation : cartesian_transformation_operator; 
   DERIVE 
     SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
           build_transformed_set(transformation, parent_set); 
   WHERE
     WR1: acyclic_set_replica(SELF, parent_set);
   END_ENTITY;

ENTITY  half_space_2d
  SUBTYPE OF (geometric_representation_item);
    base_curve:  curve;
    agreement_flag: BOOLEAN;
END_ENTITY;

 ENTITY half_space_solid
   SUBTYPE OF(geometric_representation_item);
   base_surface   : surface;
   agreement_flag : BOOLEAN;
 END_ENTITY;

 ENTITY manifold_solid_brep
   SUBTYPE OF (solid_model);
   outer : closed_shell;
 END_ENTITY;

 ENTITY polygonal_area
   SUBTYPE OF (primitive_2d);
   bounds:  LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY primitive_2d
   SUPERTYPE  OF (ONEOF (circular_area, elliptic_area, rectangular_area,
                            polygonal_area))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY rectangle_domain
   SUBTYPE OF (founded_item);
   corner: cartesian_point;
   xlength: positive_length_measure;
   ylength: positive_length_measure;
 WHERE
   WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT
   ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
 END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
    enclosure: rectangle_domain;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
    position: axis2_placement_2d;
    x: positive_length_measure;
    y: positive_length_measure;
END_ENTITY;

 ENTITY rectangular_pyramid
   SUBTYPE OF (geometric_representation_item);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength        : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY revolved_area_solid
   SUBTYPE OF (swept_area_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;

ENTITY revolved_face_solid
   SUBTYPE OF (swept_face_solid);
   axis  : axis1_placement;
   angle : plane_angle_measure;
 DERIVE
  axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
 END_ENTITY;

 ENTITY right_angular_wedge
   SUBTYPE OF (geometric_representation_item);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

 ENTITY right_circular_cone
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

 ENTITY right_circular_cylinder
   SUBTYPE OF (geometric_representation_item);
   position   : axis1_placement;
   height     : positive_length_measure;
   radius     : positive_length_measure;
 END_ENTITY;

 ENTITY sectioned_spine
   SUBTYPE OF (geometric_curve_set);
      cross_sections   : LIST[2:?] OF curve;
      spine_points     : LIST[2:?] OF point;
   WHERE
     WR1 : SIZEOF(SELF\geometric_set.elements) = 1;
     WR2 : 'GEOMETRY_SCHEMA.CURVE' IN
                     TYPEOF(SELF\geometric_set.elements[1]);
     WR3 : SIZEOF(cross_sections) = SIZEOF(spine_points);
     WR4 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY shell_based_surface_model
   SUBTYPE OF (geometric_representation_item);
   sbsm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_surface_model(SELF);
 END_ENTITY;

 ENTITY shell_based_wireframe_model
   SUBTYPE OF (geometric_representation_item);
   sbwm_boundary  : SET [1:?] OF shell;
 WHERE
   WR1: constraints_geometry_shell_based_wireframe_model(SELF);
 END_ENTITY;

 ENTITY solid_model
   SUPERTYPE OF (ONEOF( csg_solid, manifold_solid_brep, swept_face_solid,
                        swept_area_solid, swept_disk_solid, solid_replica,
                        brep_2d, trimmed_volume))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY solid_replica
   SUBTYPE OF (solid_model);
   parent_solid   : solid_model;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_solid_replica(SELF, parent_solid);
   WR2: parent_solid\geometric_representation_item.dim = 3;
 END_ENTITY;


 ENTITY sphere
   SUBTYPE OF (geometric_representation_item);
   radius : positive_length_measure;
   centre : point;
 END_ENTITY;

 ENTITY surface_curve_swept_area_solid
   SUBTYPE OF (swept_area_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_curve_swept_face_solid
   SUBTYPE OF (swept_face_solid);
      directrix          : curve;
      start_param        : REAL;
      end_param          : REAL;
      reference_surface  : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY swept_area_solid
   SUPERTYPE OF (ONEOF(revolved_area_solid, extruded_area_solid,
                       surface_curve_swept_area_solid))
   SUBTYPE OF (solid_model);
   swept_area :  curve_bounded_surface;
 WHERE
   WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
 END_ENTITY;

 ENTITY swept_disk_solid
   SUBTYPE OF (solid_model);
     directrix    : curve;
     radius       : positive_length_measure;
     inner_radius : OPTIONAL positive_length_measure;
     start_param : REAL;
     end_param   : REAL;
   WHERE
     WR1 : directrix.dim = 3;
     WR2 : (NOT EXISTS(inner_radius)) OR (radius > inner_radius) ;
 END_ENTITY;

 ENTITY swept_face_solid
   SUPERTYPE OF (ONEOF(extruded_face_solid, revolved_face_solid,
                 surface_curve_swept_face_solid))
   SUBTYPE OF (solid_model);
   swept_face :  face_surface;
 WHERE
   WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
 END_ENTITY;

 ENTITY tetrahedron
   SUBTYPE OF (faceted_primitive);
  WHERE
    WR1: SIZEOF(points) = 4 ;
    WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
  END_ENTITY;

 ENTITY torus
   SUBTYPE OF (geometric_representation_item);
   position     : axis1_placement;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1: major_radius > minor_radius;
 END_ENTITY;

 ENTITY trimmed_volume
   SUBTYPE OF (solid_model);
   basis_volume :  volume;
     u1         :  parameter_value;
     u2         :  parameter_value;
     v1         :  parameter_value;
     v2         :  parameter_value;
     w1         :  parameter_value;
     w2         :  parameter_value;
   WHERE
     WR1 : u1 <> u2;
     WR2 : v1 <> v2;
     WR3 : w1 <> w2;
 END_ENTITY;

 
 FUNCTION acyclic_set_replica(rep : geometric_set_replica;
                           parent : geometric_set) : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type geometric_set_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_solid_replica(rep : solid_replica; parent :
                    solid_model) : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;
  END_FUNCTION;

 FUNCTION build_transformed_set(tr: cartesian_transformation_operator;
           gset : geometric_set) : SET [0:?] OF geometric_set_select;
  LOCAL
   s          : SET [1:?] OF geometric_set_select := gset.elements;
   trset      : SET [0:?] OF geometric_set_select := [];
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
     trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || point() || point_replica(s[j],tr);
       ELSE
       IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || surface()  || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d (?));
       END_IF;
     END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);
 END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_surface_model
             (m: shell_based_surface_model): BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION constraints_geometry_shell_based_wireframe_model
                       (m : shell_based_wireframe_model) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION msb_shells (brep: manifold_solid_brep) :
                          SET [1:?] OF  closed_shell;
 
     IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
       msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
       RETURN (brep\brep_with_voids.voids + brep.outer);
     ELSE
       RETURN([brep.outer]);
     END_IF;
 END_FUNCTION;

 END_SCHEMA; -- end GEOMETRIC MODEL schema
 (* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)
 SCHEMA geometry_schema;
   REFERENCE FROM representation_schema
     (definitional_representation,
      founded_item,
      functionally_defined_transformation,
      item_in_context,
      representation,
      representation_item,
      representation_context,
      using_representations);
   REFERENCE FROM measure_schema
     (global_unit_assigned_context,
      length_measure,
      parameter_value,
      plane_angle_measure,
      plane_angle_unit,
      positive_length_measure,
      positive_plane_angle_measure);
   REFERENCE FROM topology_schema
     (edge_curve,
      face_surface,
      poly_loop,
      vertex_point);
    REFERENCE FROM geometric_model_schema
      (block,
       boolean_result,
       cyclide_segment_solid,
       eccentric_cone,
       edge_based_wireframe_model,
       ellipsoid,
       face_based_surface_model,
       faceted_primitive,
       geometric_set,
       half_space_solid,
       half_space_2d,
       primitive_2d,
       rectangular_pyramid,
       right_angular_wedge,
       right_circular_cone,
       right_circular_cylinder,
       shell_based_surface_model,
       shell_based_wireframe_model,
       solid_model,
       sphere,
       torus);

 CONSTANT
  dummy_gri : geometric_representation_item :=  representation_item('')||
                                   geometric_representation_item();
 END_CONSTANT;

 TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
 END_TYPE;

 TYPE b_spline_curve_form = ENUMERATION OF
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
 END_TYPE;

 TYPE b_spline_surface_form = ENUMERATION OF
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
 END_TYPE;

 TYPE curve_on_surface = SELECT
   (pcurve, 
    surface_curve, 
    composite_curve_on_surface);
 END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

 TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
 END_TYPE;

 TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
 END_TYPE;

 TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
 END_TYPE;

 TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1, 
    pcurve_s2);
 END_TYPE;

TYPE surface_boundary = SELECT
   (boundary_curve,
    degenerate_pcurve);
END_TYPE;

 TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
 END_TYPE;

 TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
 END_TYPE;

 TYPE trimming_select = SELECT 
   (cartesian_point, 
    parameter_value);
 END_TYPE;

 TYPE vector_or_direction = SELECT
   (vector, 
    direction);
 END_TYPE;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

 ENTITY axis1_placement
 SUBTYPE OF (placement);
   axis     : OPTIONAL direction;
 DERIVE
   z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
 WHERE
   WR1: SELF\geometric_representation_item.dim  = 3;
 END_ENTITY;

 ENTITY axis2_placement_2d
   SUBTYPE OF (placement);
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [2:2] OF direction := build_2axes(ref_direction);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY axis2_placement_3d
   SUBTYPE OF (placement);
   axis          : OPTIONAL direction;
   ref_direction : OPTIONAL direction;
 DERIVE
   p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
 WHERE
   WR1: SELF\placement.location.dim = 3;
   WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
   WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
   WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
          (cross_product(axis,ref_direction).magnitude > 0.0);
 END_ENTITY;

 ENTITY b_spline_curve
   SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots,
                       quasi_uniform_curve, bezier_curve)
                         ANDOR rational_b_spline_curve)
   SUBTYPE OF (bounded_curve);
   degree               : INTEGER;
   control_points_list  : LIST [2:?] OF cartesian_point;
   curve_form           : b_spline_curve_form;
   closed_curve         : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   upper_index_on_control_points  : INTEGER 
                                  := (SIZEOF(control_points_list) - 1);
   control_points       : ARRAY [0:upper_index_on_control_points]
                                                         OF cartesian_point 
                                  := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
 END_ENTITY;

 ENTITY b_spline_curve_with_knots
   SUBTYPE OF (b_spline_curve);
   knot_multiplicities  : LIST [2:?] OF INTEGER;
   knots                : LIST [2:?] OF parameter_value;
   knot_spec            : knot_type;
 DERIVE
   upper_index_on_knots : INTEGER := SIZEOF(knots);
 WHERE
   WR1: constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
    WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

 ENTITY b_spline_surface
   SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface,
                       quasi_uniform_surface, bezier_surface)
                         ANDOR rational_b_spline_surface)
   SUBTYPE OF (bounded_surface);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF cartesian_point;
   surface_form         : b_spline_surface_form;
   u_closed             : LOGICAL;
   v_closed             : LOGICAL;
   self_intersect       : LOGICAL;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF 
                         cartesian_point 
                       := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
 END_ENTITY;

 ENTITY b_spline_surface_with_knots
   SUBTYPE OF (b_spline_surface);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   knot_spec         : knot_type;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
    WR3: SIZEOF(u_multiplicities) = knot_u_upper;
    WR4: SIZEOF(v_multiplicities) = knot_v_upper;
 END_ENTITY;

 ENTITY b_spline_volume
   SUPERTYPE OF (ONEOF(b_spline_volume_with_knots, uniform_volume,
                      quasi_uniform_volume,bezier_volume) ANDOR
                       rational_b_spline_volume)
   SUBTYPE OF (volume);
   u_degree             : INTEGER;
   v_degree             : INTEGER;
   w_degree             : INTEGER;
   control_points_list  : LIST [2:?] OF
                            LIST [2:?] OF
                              LIST [2:?] OF cartesian_point;
 DERIVE
   u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
   v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
   w_upper             : INTEGER := SIZEOF(control_points_list[1][1]) - 1;

   control_points      : ARRAY [0:u_upper] OF ARRAY [0:v_upper]
                         OF ARRAY [0:w_upper] OF  cartesian_point
                       := make_array_of_array_of_array (control_points_list,
                                              0,u_upper,0,v_upper,
                                              0,w_upper );
 WHERE
   WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
        ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF)) ;
 END_ENTITY;

 ENTITY b_spline_volume_with_knots
   SUBTYPE OF (b_spline_volume);
   u_multiplicities  : LIST [2:?] OF INTEGER;
   v_multiplicities  : LIST [2:?] OF INTEGER;
   w_multiplicities  : LIST [2:?] OF INTEGER;
   u_knots           : LIST [2:?] OF parameter_value;
   v_knots           : LIST [2:?] OF parameter_value;
   w_knots           : LIST [2:?] OF parameter_value;
 DERIVE
   knot_u_upper      : INTEGER := SIZEOF(u_knots);
   knot_v_upper      : INTEGER := SIZEOF(v_knots);
   knot_w_upper      : INTEGER := SIZEOF(w_knots);
 WHERE
    WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree,
                   knot_u_upper, SELF\b_spline_volume.u_upper,
                               u_multiplicities, u_knots);
    WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree,
                   knot_v_upper, SELF\b_spline_volume.v_upper,
                               v_multiplicities, v_knots);
    WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree,
                   knot_w_upper, SELF\b_spline_volume.w_upper,
                               w_multiplicities, w_knots);
    WR4: SIZEOF(u_multiplicities) = knot_u_upper;
    WR5: SIZEOF(v_multiplicities) = knot_v_upper;
    WR6: SIZEOF(w_multiplicities) = knot_w_upper;
 END_ENTITY;

 ENTITY bezier_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY bezier_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY bezier_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY block_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
 END_ENTITY;

 ENTITY boundary_curve
   SUBTYPE OF (composite_curve_on_surface);
 WHERE
   WR1: SELF\composite_curve.closed_curve;
 END_ENTITY;

 ENTITY bounded_curve
   SUPERTYPE OF (ONEOF(polyline, b_spline_curve, trimmed_curve,
                      bounded_pcurve, bounded_surface_curve, composite_curve))
   SUBTYPE OF (curve);
 END_ENTITY;

 ENTITY bounded_pcurve
   SUBTYPE OF (pcurve, bounded_curve);
  WHERE
    WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY;

 ENTITY bounded_surface
   SUPERTYPE OF (ONEOF(b_spline_surface, rectangular_trimmed_surface,
                       curve_bounded_surface, rectangular_composite_surface))
   SUBTYPE OF (surface);
 END_ENTITY;

 ENTITY bounded_surface_curve
   SUBTYPE OF (surface_curve, bounded_curve);
 WHERE
   WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
 END_ENTITY;

 ENTITY cartesian_point
   SUPERTYPE OF (ONEOF(cylindrical_point, polar_point, spherical_point))
   SUBTYPE OF (point);
    coordinates  : LIST [1:3] OF length_measure;
 END_ENTITY;

 ENTITY cartesian_transformation_operator
   SUPERTYPE OF(ONEOF(cartesian_transformation_operator_2d,
                               cartesian_transformation_operator_3d))
   SUBTYPE OF (geometric_representation_item,
                            functionally_defined_transformation);
   axis1        : OPTIONAL direction;
   axis2        : OPTIONAL direction;
   local_origin : cartesian_point;
   scale        : OPTIONAL REAL;
 DERIVE
   scl          : REAL := NVL(scale, 1.0);
 WHERE
   WR1: scl > 0.0;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_2d
   SUBTYPE OF (cartesian_transformation_operator);
 DERIVE
   u : LIST[2:2] OF direction := 
       base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 2;
 END_ENTITY;

 ENTITY cartesian_transformation_operator_3d
   SUBTYPE OF (cartesian_transformation_operator);
   axis3 : OPTIONAL direction;
 DERIVE
   u     : LIST[3:3] OF direction 
         := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
 WHERE
   WR1: SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

 ENTITY circle
   SUBTYPE OF (conic);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY circular_involute
   SUBTYPE OF (curve);
   position    : axis2_placement;
   base_radius : positive_length_measure;
 END_ENTITY;

 ENTITY clothoid
   SUBTYPE OF (curve);
     position          : axis2_placement;
     clothoid_constant : length_measure;
  END_ENTITY;

 ENTITY composite_curve
   SUBTYPE OF (bounded_curve);
   segments       : LIST [1:?] OF composite_curve_segment;
   self_intersect : LOGICAL;
 DERIVE
   n_segments     : INTEGER := SIZEOF(segments);
   closed_curve   : LOGICAL 
                  := segments[n_segments].transition <> discontinuous;
 WHERE
   WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous)) = 0));
 END_ENTITY;

 ENTITY composite_curve_on_surface
   SUPERTYPE OF(boundary_curve)
   SUBTYPE OF (composite_curve);

 DERIVE
   basis_surface : SET[0:2] OF surface :=
                get_basis_surface(SELF);
 WHERE
   WR1: SIZEOF(basis_surface) > 0;
   WR2: constraints_composite_curve_on_surface(SELF);
 END_ENTITY;

 ENTITY composite_curve_segment
 SUBTYPE OF (founded_item);
   transition    : transition_code;
   same_sense    : BOOLEAN;
   parent_curve  : curve;
 INVERSE
   using_curves  : BAG[1:?] OF composite_curve FOR segments;
 WHERE
   WR1 : ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
 END_ENTITY;

 ENTITY conic
   SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
   SUBTYPE OF (curve);
   position: axis2_placement;
 END_ENTITY;

 ENTITY
 conical_surface
   SUBTYPE OF (elementary_surface);
   radius     : length_measure;
   semi_angle : plane_angle_measure;
 WHERE
   WR1: radius >= 0.0;
 END_ENTITY;

ENTITY curve
   SUPERTYPE OF (ONEOF(line, conic, clothoid, circular_involute, pcurve,
             surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
   SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
 ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
    basis_surface    : surface;
    boundaries       : SET [1:?] OF boundary_curve;
    implicit_outer   : BOOLEAN;
  WHERE
    WR1: (NOT implicit_outer) OR
         (SIZEOF (QUERY (temp <* boundaries |
           'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
    WR2: (NOT(implicit_outer)) OR
                ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
    WR3: SIZEOF(QUERY(temp <* boundaries |
                  'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp))) <= 1;
    WR4: SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface))) = 0;
 END_ENTITY;

 ENTITY curve_replica
   SUBTYPE OF (curve);
   parent_curve   : curve;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_curve.dim;
   WR2: acyclic_curve_replica (SELF, parent_curve);
 END_ENTITY;

 ENTITY cylindrical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     z     : length_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                     [r*cos(theta), r*sin(theta), z];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY cylindrical_surface
   SUBTYPE OF (elementary_surface);
   radius : positive_length_measure;
 END_ENTITY;

 ENTITY  cylindrical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
   height   : positive_length_measure;
 END_ENTITY;

 ENTITY degenerate_pcurve
   SUBTYPE OF (point);
   basis_surface:  surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY degenerate_toroidal_surface
   SUBTYPE OF (toroidal_surface);
   select_outer : BOOLEAN;
 WHERE
  WR1: major_radius <   minor_radius;
 END_ENTITY;

 ENTITY direction
   SUBTYPE OF (geometric_representation_item);
   direction_ratios : LIST [2:3] OF REAL;
 WHERE
   WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
 END_ENTITY;

ENTITY dupin_cyclide_surface
   SUBTYPE OF (elementary_surface);
   generalised_major_radius : positive_length_measure;
   generalised_minor_radius : positive_length_measure;
   skewness                 : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

 ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
   position    : axis2_placement_3d;
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
   height      : positive_length_measure;
   x_offset    : length_measure;
   y_offset    : length_measure;
   ratio       : REAL;
 WHERE
  WR1 : ratio >= 0.0;
 END_ENTITY;

 ENTITY elementary_surface
   SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface,
                       spherical_surface, toroidal_surface))
   SUBTYPE OF (surface);
   position : axis2_placement_3d;
 END_ENTITY;

 ENTITY ellipse
   SUBTYPE OF (conic);
   semi_axis_1 : positive_length_measure;
   semi_axis_2 : positive_length_measure;
 END_ENTITY;

 ENTITY ellipsoid_volume
   SUBTYPE OF (volume);
     position      : axis2_placement_3d;
     semi_axis_1 : positive_length_measure;
     semi_axis_2 : positive_length_measure;
     semi_axis_3 : positive_length_measure;
 END_ENTITY;

 ENTITY evaluated_degenerate_pcurve
   SUBTYPE OF (degenerate_pcurve);
   equivalent_point : cartesian_point;
 END_ENTITY;

 ENTITY fixed_reference_swept_surface
   SUBTYPE OF (swept_surface);
      directrix       : curve;
      fixed_reference : direction;
 END_ENTITY;

  ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF(point, direction, vector, placement,
                 cartesian_transformation_operator, curve, surface,
                 edge_curve, face_surface, poly_loop, vertex_point,
                 solid_model, boolean_result, sphere, right_circular_cone,
                 right_circular_cylinder, torus, block, primitive_2d,
                 right_angular_wedge, ellipsoid, faceted_primitive,
                 rectangular_pyramid, cyclide_segment_solid, volume,
                 half_space_solid, half_space_2d,
                 shell_based_surface_model, face_based_surface_model,
                 shell_based_wireframe_model, edge_based_wireframe_model,
                 geometric_set))
  SUBTYPE OF (representation_item);
  DERIVE
    dim : dimension_count := dimension_of(SELF);
  WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
      NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

 ENTITY line
   SUBTYPE OF (curve);
   pnt : cartesian_point;
   dir : vector;
 WHERE
   WR1: dir.dim  = pnt.dim;
 END_ENTITY;

 ENTITY hexahedron_volume
   SUBTYPE OF (volume);
   points  : LIST[8:8] OF cartesian_point;
  WHERE
    WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
    WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
    WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
    WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
    WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
    WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
    WR7: same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
    WR8: same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
    WR9:  same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
    WR10: same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
    WR11: same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
    WR12: same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
    WR13: points[1].dim = 3;
  END_ENTITY;

 ENTITY hyperbola
   SUBTYPE OF (conic);
   semi_axis      : positive_length_measure;
   semi_imag_axis : positive_length_measure;
 END_ENTITY;

 ENTITY intersection_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY offset_curve_2d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
 WHERE
   WR1: basis_curve.dim = 2;
 END_ENTITY;

 ENTITY offset_curve_3d
   SUBTYPE OF (curve);
   basis_curve    : curve;
   distance       : length_measure;
   self_intersect : LOGICAL;
   ref_direction  : direction;
 WHERE
   WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
 END_ENTITY;

 ENTITY offset_surface
   SUBTYPE OF (surface);
   basis_surface  : surface;
   distance       : length_measure;
   self_intersect : LOGICAL;
 END_ENTITY;

 ENTITY oriented_surface
   SUBTYPE OF (surface);
   orientation : BOOLEAN;
 END_ENTITY;

 ENTITY outer_boundary_curve
   SUBTYPE OF (boundary_curve);
 END_ENTITY;

 ENTITY parabola
   SUBTYPE OF (conic);
   focal_dist : length_measure;
 WHERE
   WR1: focal_dist <> 0.0;
 END_ENTITY;

 ENTITY pcurve
   SUBTYPE OF (curve);
   basis_surface      : surface;
   reference_to_curve : definitional_representation;
 WHERE
   WR1: SIZEOF(reference_to_curve\representation.items) = 1;
   WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
                    (reference_to_curve\representation.items[1]);
   WR3: reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
 END_ENTITY;

 ENTITY placement
   SUPERTYPE OF (ONEOF(axis1_placement,axis2_placement_2d,axis2_placement_3d))
   SUBTYPE OF (geometric_representation_item);
   location : cartesian_point;
 END_ENTITY;

 ENTITY plane
 SUBTYPE OF (elementary_surface);
 END_ENTITY;

 ENTITY polar_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
                   [r*cos(theta), r*sin(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

ENTITY point
   SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface,
                        point_in_volume, point_replica, degenerate_pcurve))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY point_in_volume
   SUBTYPE OF (point);
   basis_volume     : volume;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
   point_parameter_w : parameter_value;
 END_ENTITY;

 ENTITY point_on_curve
   SUBTYPE OF (point);
   basis_curve     : curve;
   point_parameter : parameter_value;
 END_ENTITY;

 ENTITY point_on_surface
   SUBTYPE OF (point);
   basis_surface     : surface;
   point_parameter_u : parameter_value;
   point_parameter_v : parameter_value;
 END_ENTITY;

 ENTITY point_replica
   SUBTYPE OF (point);
   parent_pt      : point;
   transformation : cartesian_transformation_operator;
 WHERE
   WR1: transformation.dim = parent_pt.dim;
   WR2: acyclic_point_replica (SELF,parent_pt);
 END_ENTITY;

 ENTITY polyline
   SUBTYPE OF (bounded_curve);
   points : LIST [2:?] OF cartesian_point;
 END_ENTITY;

 ENTITY pyramid_volume
   SUBTYPE OF (volume);
   position       : axis2_placement_3d;
   xlength        : positive_length_measure;
   ylength          : positive_length_measure;
   height         : positive_length_measure;
 END_ENTITY;

 ENTITY quasi_uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY quasi_uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY quasi_uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY rational_b_spline_curve
   SUBTYPE OF (b_spline_curve);
   weights_data : LIST [2:?] OF REAL;
                                
 DERIVE
   weights           : ARRAY [0:upper_index_on_control_points] OF REAL
                               := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
 WHERE
   WR1:  SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
   WR2:  curve_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_surface
   SUBTYPE OF (b_spline_surface);
   weights_data : LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                      ARRAY [0:v_upper] OF REAL
                 := make_array_of_array(weights_data,0,u_upper,0,v_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
   WR2: surface_weights_positive(SELF);
 END_ENTITY;

 ENTITY rational_b_spline_volume
   SUBTYPE OF (b_spline_volume);
   weights_data : LIST [2:?] OF
                   LIST [2:?] OF
                    LIST [2:?] OF REAL;
                                
 DERIVE
   weights       : ARRAY [0:u_upper] OF
                    ARRAY [0:v_upper] OF
                     ARRAY [0:w_upper] OF REAL
                 := make_array_of_array_of_array
                             (weights_data,0,u_upper,0,v_upper,0,w_upper);
 WHERE
   WR1: (SIZEOF(weights_data) =
                         SIZEOF(SELF\b_spline_volume.control_points_list))
           AND (SIZEOF(weights_data[1]) =
                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))
            AND (SIZEOF(weights_data[1][1]) =
                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
   WR2: volume_weights_positive(SELF);
 END_ENTITY;

 ENTITY rectangular_composite_surface
   SUBTYPE OF (bounded_surface);
   segments      : LIST [1:?] OF LIST [1:?] OF surface_patch;
 DERIVE
   n_u : INTEGER := SIZEOF(segments);
   n_v : INTEGER := SIZEOF(segments[1]);
 WHERE
   WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
   WR2: constraints_rectangular_composite_surface(SELF);
 END_ENTITY;

 ENTITY rectangular_trimmed_surface
   SUBTYPE OF (bounded_surface);
   basis_surface : surface;
   u1            : parameter_value;
   u2            : parameter_value;
   v1            : parameter_value;
   v2            : parameter_value;
   usense        : BOOLEAN;
   vsense        : BOOLEAN;
 WHERE
   WR1: u1 <> u2;
   WR2: v1 <> v2;
   WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
       AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR
      ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR (usense = (u2 > u1));
   WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
          OR
         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR (vsense = (v2 > v1));
 END_ENTITY;

 ENTITY reparametrised_composite_curve_segment
   SUBTYPE OF (composite_curve_segment);
   param_length : parameter_value;
 WHERE
   WR1: param_length > 0.0;
 END_ENTITY;

 ENTITY seam_curve
   SUBTYPE OF (surface_curve);
 WHERE
   WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
   WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
           associated_surface(SELF\surface_curve.associated_geometry[2]);
   WR3: 'GEOMETRY_SCHEMA.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
   WR4: 'GEOMETRY_SCHEMA.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
 END_ENTITY;

 ENTITY spherical_point
   SUBTYPE OF (cartesian_point);
     r     : length_measure;
     theta : plane_angle_measure;
     phi   : plane_angle_measure;
   DERIVE
     SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=
       [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
   WHERE
    WR1: r >= 0.0;
 END_ENTITY;

 ENTITY spherical_surface
   SUBTYPE OF (elementary_surface);
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY spherical_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   radius   : positive_length_measure;
 END_ENTITY;

 ENTITY surface
   SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface,
                       offset_surface, surface_replica))
   SUBTYPE OF (geometric_representation_item);
 END_ENTITY;

 ENTITY surface_curve
   SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR
                                            bounded_surface_curve)
   SUBTYPE OF (curve);
   curve_3d              : curve;
   associated_geometry   : LIST[1:2] OF pcurve_or_surface;
   master_representation : preferred_surface_curve_representation;
 DERIVE
   basis_surface         : SET[1:2] OF surface
                         := get_basis_surface(SELF);
 WHERE
   WR1: curve_3d.dim = 3;
   WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR
                        (master_representation <> pcurve_s1);
   WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR
                        (master_representation <> pcurve_s2);
   WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
 END_ENTITY;

 ENTITY surface_curve_swept_surface
   SUBTYPE OF (swept_surface);
      directrix  : curve;
      reference_surface : surface;
   WHERE
     WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
          (reference_surface IN (directrix\surface_curve.basis_surface));
 END_ENTITY;

 ENTITY surface_of_linear_extrusion
   SUBTYPE OF (swept_surface);
   extrusion_axis      : vector;
 END_ENTITY;

 ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
   axis_position       : axis1_placement;
 DERIVE
   axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
 END_ENTITY;

 ENTITY surface_patch
 SUBTYPE OF (founded_item);
   parent_surface : bounded_surface;
   u_transition   : transition_code;
   v_transition   : transition_code;
   u_sense        : BOOLEAN;
   v_sense        : BOOLEAN;
 INVERSE
   using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
 WHERE
   WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
 END_ENTITY;

 ENTITY surface_replica
   SUBTYPE OF (surface);
   parent_surface : surface;
   transformation : cartesian_transformation_operator_3d;
 WHERE
   WR1: acyclic_surface_replica(SELF, parent_surface);
 END_ENTITY;

 ENTITY swept_surface
   SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution,
                 surface_curve_swept_surface, fixed_reference_swept_surface))
   SUBTYPE OF (surface);
   swept_curve : curve;
 END_ENTITY;

 ENTITY tetrahedron_volume
   SUBTYPE OF (volume);
     point_1 : cartesian_point ;
     point_2 : cartesian_point ;
     point_3 : cartesian_point ;
     point_4 : cartesian_point ;
  WHERE
    WR1: point_1.dim = 3 ;
    WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0 ;
  END_ENTITY;

 ENTITY toroidal_volume
   SUBTYPE OF (volume);
   position     : axis2_placement_3d;
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 WHERE
   WR1 : minor_radius < major_radius;
 END_ENTITY;

 ENTITY trimmed_curve
   SUBTYPE OF (bounded_curve);
   basis_curve           : curve;
   trim_1                : SET[1:2] OF trimming_select;
   trim_2                : SET[1:2] OF trimming_select;
   sense_agreement       : BOOLEAN;
   master_representation : trimming_preference;
 WHERE
   WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
   WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
 END_ENTITY;

 ENTITY toroidal_surface
   SUBTYPE OF (elementary_surface);
   major_radius : positive_length_measure;
   minor_radius : positive_length_measure;
 END_ENTITY;

 ENTITY uniform_curve
   SUBTYPE OF (b_spline_curve);
 END_ENTITY;

 ENTITY uniform_surface
   SUBTYPE OF (b_spline_surface);
 END_ENTITY;

 ENTITY uniform_volume
   SUBTYPE OF (b_spline_volume);
 END_ENTITY;

 ENTITY vector
   SUBTYPE OF (geometric_representation_item);
   orientation : direction;
   magnitude   : length_measure;
 WHERE
   WR1 : magnitude >= 0.0;
 END_ENTITY;

 ENTITY volume
   SUPERTYPE OF (ONEOF(block_volume, wedge_volume, spherical_volume,
                    cylindrical_volume, eccentric_conical_volume,
                    toroidal_volume, pyramid_volume, b_spline_volume,
                    ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
   SUBTYPE OF (geometric_representation_item);
   WHERE
     WR1 : SELF\geometric_representation_item.dim = 3;
 END_ENTITY;

  ENTITY wedge_volume
   SUBTYPE OF (volume);
   position : axis2_placement_3d;
   x        : positive_length_measure;
   y        : positive_length_measure;
   z        : positive_length_measure;
   ltx      : length_measure;
 WHERE
   WR1: ((0.0 <= ltx) AND (ltx < x));
 END_ENTITY;

RULE compatible_dimension FOR 
  (cartesian_point,
  direction,
  representation_context,
  geometric_representation_context);
WHERE

  -- ensure that the count of coordinates of each cartesian_point
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;

  -- ensure that the count of direction_ratios of each direction
  -- matches the coordinate_space_dimension of each geometric_context in
  -- which it is geometrically founded
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
       (y <* geometric_representation_context | item_in_context(x,y) AND
       (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
       > 0 )) = 0;
END_RULE;

 FUNCTION above_plane(p1, p2, p3, p4 : cartesian_point) : REAL;
   LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
 END_FUNCTION;

 FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_point_replica(rep : point_replica; parent : point)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION;

 FUNCTION acyclic_surface_replica(rep : surface_replica; parent : surface)
                                              : BOOLEAN;
   IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;
  END_FUNCTION;

 FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
   LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);
 END_FUNCTION;

FUNCTION base_axis(dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                 LIST [2:3] OF 
direction;
  LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

 FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
   LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);
 END_FUNCTION;

 FUNCTION build_axes(axis, ref_direction : direction) :
                                          LIST [3:3] OF direction;
   LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
 END_FUNCTION;

 FUNCTION constraints_composite_curve_on_surface
               (c: composite_curve_on_surface) : BOOLEAN;
   LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION constraints_param_b_spline(degree, up_knots, up_cp : INTEGER;
                                               knot_mult : LIST OF INTEGER;
                        knots : LIST OF parameter_value) : BOOLEAN;
   LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

   FUNCTION constraints_rectangular_composite_surface
           (s : rectangular_composite_surface) : BOOLEAN;

   (* Check the surface types *)
     REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

FUNCTION cross_product (arg1, arg2 : direction) : vector;
  LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;
END_FUNCTION;

 FUNCTION curve_weights_positive(b: rational_b_spline_curve) : BOOLEAN;
   LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION default_b_spline_curve_weights(up_cp : INTEGER)
                                          : ARRAY [0:up_cp] OF REAL;
   RETURN([1:up_cp + 1]);
 END_FUNCTION;

 FUNCTION default_b_spline_surface_weights(u_upper, v_upper: INTEGER)
                                      : ARRAY [0:u_upper] OF 
                                        ARRAY [0:v_upper] OF REAL;
    RETURN([[1:v_upper + 1]:u_upper +1]);
 END_FUNCTION;

 FUNCTION default_b_spline_knot_mult(degree, up_knots : INTEGER;
                                          uniform : knot_type) 
                                                  : LIST [2:?] OF INTEGER;
   LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);
 END_FUNCTION;

 FUNCTION default_b_spline_knots(degree,up_knots : INTEGER;
                              uniform : knot_type)
                                      : LIST [2:?] OF parameter_value;
  LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
 END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);

END_FUNCTION;

 FUNCTION dot_product(arg1, arg2 : direction) : REAL;
   LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);
 END_FUNCTION;

FUNCTION first_proj_axis(z_axis, arg : direction) : direction;
  LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION get_basis_surface (c : curve_on_surface) : SET[0:2] OF surface;
  LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);
END_FUNCTION;

 FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC : T;
                      low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
   LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;
 END_FUNCTION;

 FUNCTION make_array_of_array(lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                              low1, u1, low2, u2 : INTEGER):
                 ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);
 END_FUNCTION;

 FUNCTION make_array_of_array_of_array(lis : LIST[1:?] OF
              LIST [1:?] OF LIST [1:?] OF GENERIC : T;
              low1, u1, low2, u2, low3, u3 : INTEGER):
      ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T;
 LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);
 END_FUNCTION;

 FUNCTION normalise (arg : vector_or_direction) : vector_or_direction;
   LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag > 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION orthogonal_complement(vec : direction) : direction;
   LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;
 END_FUNCTION;

 FUNCTION same_side(plane_pts : LIST [3:3] of cartesian_point;
                    test_points : LIST [2:?] of cartesian_point) : BOOLEAN;
   LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);
 END_FUNCTION;

 FUNCTION scalar_times_vector (scalar : REAL; vec : vector_or_direction)
                                      : vector;
   LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag < 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION second_proj_axis(z_axis, x_axis, arg: direction) : direction;
   LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);
 END_FUNCTION;

 FUNCTION surface_weights_positive(b: rational_b_spline_surface) : BOOLEAN;
   LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);
 END_FUNCTION;

 FUNCTION vector_difference(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION vector_sum(arg1, arg2 : vector_or_direction) : vector;
   LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);
 END_FUNCTION;

 FUNCTION volume_weights_positive(b: rational_b_spline_volume): BOOLEAN;
     LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);
   END_FUNCTION;

 END_SCHEMA; -- end GEOMETRY schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA group_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   id_attribute); 


ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY group_relationship;
  name : label;
  description : OPTIONAL text;
  relating_group : group;
  related_group : group;
END_ENTITY;

FUNCTION acyclic_group_relationship
 (relation : group_relationship; relatives : SET[1:?] OF group; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- group_schema
(* Genenerated from: ISO.exp *)

SCHEMA ISO13584_expressions_schema;

REFERENCE FROM ISO13584_generic_expressions_schema(
			generic_expression,
			simple_generic_expression,
			generic_variable,
			generic_literal,
			unary_generic_expression,
			binary_generic_expression,
			multiple_arity_generic_expression);

ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,
				boolean_expression,
				string_expression))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable,
				boolean_variable,
					string_variable))
SUBTYPE OF(generic_variable);
END_ENTITY;

ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function,
				string_defined_function,
				boolean_defined_function)
				)
				ANDOR SQL_mappable_defined_function);
END_ENTITY;

ENTITY SQL_mappable_defined_function
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
								unary_numeric_expression,
								binary_numeric_expression,
								multiple_arity_numeric_expression,
								length_function,
								value_function,
								numeric_defined_function))
SUBTYPE OF (expression);
DERIVE
	is_int: BOOLEAN := is_int_expr (SELF);
	sql_mappable: BOOLEAN := is_SQL_mappable (SELF);
END_ENTITY;

ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;

ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;

ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;

ENTITY numeric_variable
SUPERTYPE OF (ONEOF (int_numeric_variable,
			          real_numeric_variable))
SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;

ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (unary_function_call))
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;

ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,
				div_expression,
				mod_expression,
				slash_expression,
				power_expression,
				binary_function_call))
SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,
				mult_expression,
				multiple_arity_function_call))
SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;

ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY value_function
SUPERTYPE OF (int_value_function)
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;

ENTITY numeric_defined_function
ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function,
				real_defined_function))
SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (abs_function,
				minus_function,
				sin_function,
				cos_function,
				tan_function,
				asin_function,
				acos_function,
				exp_function,
				log_function,
				log2_function,
				log10_function,
				square_root_function))
SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (atan_function))
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, 
				minimum_function))
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY integer_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY real_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression,
				unary_boolean_expression,
				binary_boolean_expression,
				multiple_arity_Boolean_expression,
				comparison_expression,
				interval_expression,
				boolean_defined_function))
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal,
				boolean_variable))
SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;

ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;

ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(SELF\numeric_expression);
END_ENTITY;

ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;

ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal,
				comparison_greater,
				comparison_greater_equal,
				comparison_less,
				comparison_less_equal,
				comparison_not_equal,
				like_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;

ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 

ENTITY boolean_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;

ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression,
				index_expression,
				substring_expression,
				concat_expression,
				format_function,
				string_defined_function)) 
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (string_literal,
				string_variable))
SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;

ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;

ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;

ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;

ENTITY string_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;

FUNCTION is_int_expr (arg: numeric_expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

FUNCTION is_SQL_mappable (arg: expression) : BOOLEAN;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions (arg : expression) : SET OF defined_function;

LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\like_expression.operands[1])
		+ used_functions (arg\like_expression.operands[2]));
END_IF;
RETURN ([ ]);

END_FUNCTION; -- used_functions

END_SCHEMA;
SCHEMA ISO13584_generic_expressions_schema;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_generic_expression,
								unary_generic_expression,
								binary_generic_expression,
								multiple_arity_generic_expression));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
END_ENTITY; 

ENTITY generic_variable
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;

END_FUNCTION; -- acyclic

FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' 
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables

END_SCHEMA; 
SCHEMA ISO13584_IEC61360_dictionary_schema;


REFERENCE FROM support_resource_schema(identifier, label, text); 

 
REFERENCE FROM person_organization_schema(organization, address); 

 
REFERENCE FROM measure_schema;

 
REFERENCE FROM ISO13584_IEC61360_language_resource_schema; 



CONSTANT 
    property_code_len: INTEGER := 14; 
    class_code_len: INTEGER := 14;
    data_type_code_len:INTEGER := 14;
    supplier_code_len: INTEGER := 70;
    version_len: INTEGER := 9; 
    revision_len: INTEGER := 3; 
    value_code_len: INTEGER :=18; 
    pref_name_len: INTEGER := 70;
    short_name_len: INTEGER := 15;
    syn_name_len: INTEGER := pref_name_len;
    DET_classification_len: INTEGER := 3;
    source_doc_len: INTEGER := 80;
    value_format_len: INTEGER := 80;
    sep_cv: STRING := '-';
    sep_id: STRING := '.'; 
END_CONSTANT;


ENTITY basic_semantic_unit
ABSTRACT SUPERTYPE OF(ONEOF(
    supplier_BSU,
    class_BSU,
    property_BSU,
    data_type_BSU,
    supplier_related_BSU,
    class_related_BSU));
    
    code: code_type;
    version: version_type;
DERIVE
    dic_identifier: identifier := code + sep_cv + version;
INVERSE
    definition: SET [0:1] OF dictionary_element FOR 
    identified_by;
    referenced_by: SET [0:1] OF content_item 
        FOR dictionary_definition;
END_ENTITY; -- basic_semantic_unit


ENTITY dictionary_element
ABSTRACT SUPERTYPE OF(ONEOF(
    supplier_element,
    class_and_property_elements,
    data_type_element));

    identified_by: basic_semantic_unit;
    time_stamps: OPTIONAL dates;
    revision: revision_type;
END_ENTITY; -- dictionary_element


ENTITY content_item
ABSTRACT SUPERTYPE;
    dictionary_definition: basic_semantic_unit;
END_ENTITY; -- content_item


ENTITY supplier_related_BSU
ABSTRACT SUPERTYPE
SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- supplier_related_BSU


ENTITY class_related_BSU
ABSTRACT SUPERTYPE
SUBTYPE OF(basic_semantic_unit);
END_ENTITY; -- class_related_BSU


ENTITY supplier_BSU_relationship
ABSTRACT SUPERTYPE;
    relating_supplier: supplier_element;
    related_tokens: SET [1:?] OF supplier_related_BSU;
END_ENTITY; -- supplier_BSU_relationship


ENTITY class_BSU_relationship
ABSTRACT SUPERTYPE;
    relating_class: class;
    related_tokens: SET [1:?] OF class_related_BSU;
END_ENTITY; -- class_BSU_relationship


ENTITY supplier_BSU 
SUBTYPE OF(basic_semantic_unit); 
    SELF\basic_semantic_unit.code: supplier_code_type; 
DERIVE 
    SELF\basic_semantic_unit.version: version_type := '1';
    absolute_id: identifier := SELF\basic_semantic_unit.code; 
UNIQUE 
    UR1: absolute_id; 
END_ENTITY; -- supplier_BSU


ENTITY supplier_element
SUBTYPE OF(dictionary_element);
    SELF\dictionary_element.identified_by: supplier_BSU;
    org: organization;
    addr: address;
INVERSE
    associated_items: SET [0:?] OF supplier_BSU_relationship 
        FOR relating_supplier;
END_ENTITY; -- supplier_element


ENTITY class_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: class_code_type;
    defined_by: supplier_BSU;
DERIVE
    absolute_id: identifier 
        := defined_by.absolute_id + sep_id + dic_identifier; 
    known_visible_properties : SET [0:?]OF property_BSU
        :=compute_known_visible_properties(SELF);
    known_visible_data_types: SET [0:?]OF data_type_BSU
        :=compute_known_visible_data_types(SELF);
INVERSE
    subclasses: SET [0:?] OF class FOR its_superclass;
    added_visible_properties:SET [0:?] OF property_BSU 
        FOR name_scope;
    added_visible_data_types:SET [0:?] OF data_type_BSU 
        FOR name_scope;
UNIQUE
    UR1: absolute_id; 
END_ENTITY; -- class_BSU


ENTITY class_and_property_elements
ABSTRACT SUPERTYPE OF(ONEOF(
    property_DET, 
    class))
SUBTYPE OF(dictionary_element);
    names: item_names;
    definition: definition_type;
    source_doc_of_definition: OPTIONAL document;
    note: OPTIONAL note_type;
    remark: OPTIONAL remark_type;
END_ENTITY; -- class_and_property_elements


ENTITY class
ABSTRACT SUPERTYPE OF(item_class)
SUBTYPE OF(class_and_property_elements);
    SELF\dictionary_element.identified_by: class_BSU;
    its_superclass: OPTIONAL class_BSU;
    described_by: LIST [0:?] OF UNIQUE property_BSU;
    defined_types: SET [0:?] OF data_type_BSU;
DERIVE
    subclasses: SET [0:?] OF class := identified_by.subclasses;
    known_applicable_properties: SET [0:?] OF property_BSU
        := compute_known_applicable_properties(
            SELF\dictionary_element.identified_by);
    known_applicable_data_types: SET [0:?] OF data_type_BSU
        := compute_known_applicable_data_types(
            SELF\dictionary_element.identified_by);
INVERSE
    associated_items: SET [0:?] OF class_BSU_relationship 
        FOR relating_class;
WHERE
    WR1: acyclic_superclass_relationship(SELF.identified_by, []);
    WR2: NOT all_class_descriptions_reachable(
        SELF\dictionary_element.identified_by)
        OR (list_to_set(SELF.described_by) <= 
        SELF\dictionary_element.identified_by
        \class_BSU.known_visible_properties);
    WR3: NOT all_class_descriptions_reachable(
        SELF\dictionary_element.identified_by)
        OR (SELF.defined_types <= 
        SELF\dictionary_element.identified_by
        \class_BSU.known_visible_data_types); 
    WR4: check_properties_applicability(SELF);
    WR5: check_datatypes_applicability(SELF);
END_ENTITY; -- class


ENTITY item_class 
SUPERTYPE OF(ONEOF(component_class, material_class))
SUBTYPE OF(class);
    simplified_drawing: OPTIONAL graphics;
    sub_class_properties: SET [0:?] OF property_BSU;
    class_constant_values: SET [0:?] 
        OF class_value_assignment;
    coded_name: OPTIONAL value_code_type;
WHERE
    WR1: QUERY(p <* sub_class_properties
        | NOT(p IN SELF.described_by)) = [];
    WR2: NOT all_class_descriptions_reachable(SELF.identified_by) OR
        (QUERY(va <* class_constant_values | SIZEOF(QUERY(c <*
        va.super_class_defined_property.describes_classes |
        is_subclass(SELF, c) 
        AND (va.super_class_defined_property 
        IN c\item_class.sub_class_properties))) <> 1) = []);
END_ENTITY; -- item_class


ENTITY component_class 
SUBTYPE OF(item_class);
END_ENTITY; -- component_class


ENTITY material_class 
SUBTYPE OF(item_class);
END_ENTITY; -- material_class


ENTITY property_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: property_code_type;
    name_scope: class_BSU;
DERIVE
    absolute_id: identifier :=
        name_scope.defined_by.absolute_id
        + sep_id + name_scope.dic_identifier
        + sep_id + dic_identifier;
INVERSE
    describes_classes: SET OF class FOR described_by;
UNIQUE
    UR1: absolute_id;
WHERE
    WR1: QUERY(c <* describes_classes |
        NOT(is_subclass(c, name_scope.definition[1])))= [];
END_ENTITY; -- property_BSU


ENTITY property_DET
ABSTRACT SUPERTYPE OF(ONEOF(
    condition_DET, dependent_P_DET, non_dependent_P_DET))
SUBTYPE OF(class_and_property_elements);
    SELF\dictionary_element.identified_by: property_BSU;
    preferred_symbol: OPTIONAL mathematical_string;
    synonymous_symbols: SET [0:2] OF mathematical_string;
    figure: OPTIONAL graphics;
    det_classification: OPTIONAL DET_classification_type;
    domain: data_type;
    formula: OPTIONAL mathematical_string;
DERIVE
    describes_classes: SET [0:?] OF class
        := identified_by.describes_classes;
END_ENTITY; -- property_DET


ENTITY condition_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- condition_DET


ENTITY dependent_P_DET
SUBTYPE OF(property_DET);
    depends_on: SET [1:?] OF property_BSU;
WHERE
    WR1: QUERY(p <* depends_on | NOT(definition_available_implies(
        p, ('ISO13584_IEC61360_DICTIONARY_SCHEMA.CONDITION_DET'
        IN TYPEOF(p.definition[1]))))) = [];
END_ENTITY; -- dependent_P_DET


ENTITY non_dependent_P_DET
SUBTYPE OF(property_DET);
END_ENTITY; -- non_dependent_P_DET


ENTITY class_value_assignment;
    super_class_defined_property: property_BSU;
    assigned_value: value_code_type;
WHERE
    WR1: definition_available_implies(super_class_defined_property, 
        ('ISO13584_IEC61360_DICTIONARY_SCHEMA'
        +'.NON_QUANTITATIVE_CODE_TYPE' IN TYPEOF(
        super_class_defined_property.
        definition[1]\property_DET.domain)));
    WR2: definition_available_implies(super_class_defined_property, 
        (SIZEOF(QUERY(v <* 
        super_class_defined_property.
        definition[1]\property_DET.domain
        \non_quantitative_code_type.domain.its_values |
        assigned_value = v.value_code)) = 1));
END_ENTITY; -- class_value_assignment


ENTITY data_type_BSU
SUBTYPE OF(basic_semantic_unit);
    SELF\basic_semantic_unit.code: data_type_code_type;
    name_scope: class_BSU;
DERIVE
    absolute_id: identifier := 
        name_scope.defined_by.absolute_id   
        + sep_id + name_scope.dic_identifier    
        + sep_id + dic_identifier;          
INVERSE
    defining_class: SET [0:1] OF class FOR defined_types;
UNIQUE
    absolute_id;
WHERE
    WR1: is_subclass(defining_class[1], name_scope.definition[1]); 
END_ENTITY; -- data_type_BSU


ENTITY data_type_element
SUBTYPE OF(dictionary_element);
    SELF\dictionary_element.identified_by: data_type_BSU;
    names: item_names;
    type_definition: data_type;
END_ENTITY; -- data_type_element


ENTITY data_type
ABSTRACT SUPERTYPE OF(ONEOF(
    simple_type,
    complex_type,
    named_type));
END_ENTITY; -- data_type


ENTITY simple_type
ABSTRACT SUPERTYPE OF(ONEOF(
    number_type,
    boolean_type,
    string_type))
SUBTYPE OF(data_type);
    value_format: value_format_type;
END_ENTITY; -- simple_type


ENTITY number_type
SUPERTYPE OF(ONEOF(
    int_type,
    real_type))
SUBTYPE OF(simple_type); 
END_ENTITY; -- number_type


ENTITY int_type
SUPERTYPE OF(ONEOF(
    int_measure_type,
    int_currency_type,
    non_quantitative_int_type))
SUBTYPE OF(number_type);
END_ENTITY; -- int_type


ENTITY int_measure_type
SUBTYPE OF(int_type);
    unit: dic_unit;
END_ENTITY; -- int_measure_type


ENTITY int_currency_type
SUBTYPE OF(int_type);
    currency: OPTIONAL currency_code; 
END_ENTITY; -- int_currency_type


ENTITY non_quantitative_int_type
SUBTYPE OF(int_type);
    domain: value_domain;
WHERE
    WR1: QUERY(v <* domain.its_values | 
        'ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN
        TYPEOF(v.value_code)) = [];
END_ENTITY; -- non_quantitative_int_type


ENTITY real_type
SUPERTYPE OF(ONEOF(
    real_measure_type,
    real_currency_type))
SUBTYPE OF(number_type);
END_ENTITY; -- real_type


ENTITY real_measure_type
SUBTYPE OF(real_type);
    unit: dic_unit;
END_ENTITY; -- real_measure_type


ENTITY real_currency_type
SUBTYPE OF(real_type);
    currency: OPTIONAL currency_code; 
END_ENTITY; -- real_currency_type


ENTITY boolean_type
SUBTYPE OF(simple_type);
END_ENTITY; -- boolean_type


ENTITY string_type
SUBTYPE OF(simple_type);
END_ENTITY; -- string_type


ENTITY non_quantitative_code_type
SUBTYPE OF(string_type);
    domain: value_domain;
WHERE
    WR1: QUERY(v <* domain.its_values | 
        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN
        TYPEOF(v.value_code))) = [];
END_ENTITY; -- non_quantitative_code_type


ENTITY complex_type
ABSTRACT SUPERTYPE OF(ONEOF(
    level_type,
    class_instance_type,
    entity_instance_type))
SUBTYPE OF(data_type);
END_ENTITY; -- complex_type


ENTITY level_type
SUBTYPE OF(complex_type);
    levels: LIST [1:4] OF UNIQUE level;
    value_type: simple_type;
WHERE
    WR1: 'ISO13584_IEC61360_DICTIONARY_SCHEMA.NUMBER_TYPE'
        IN TYPEOF(value_type);
END_ENTITY; -- level_type


TYPE level = ENUMERATION OF(
    min,        
    nom,        
    typ,        
    max);   
END_TYPE; -- level 


ENTITY class_instance_type
SUBTYPE OF(complex_type);
    domain: class_BSU;
END_ENTITY; -- class_instance_type


ENTITY entity_instance_type
SUBTYPE OF(complex_type);
    type_name: SET OF STRING;
END_ENTITY; -- entity_instance_type


ENTITY placement_type
SUPERTYPE OF(ONEOF(
    axis1_placement_type,
    axis2_placement_2d_type,
    axis2_placement_3d_type))
SUBTYPE OF(entity_instance_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.PLACEMENT' 
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- placement_type


ENTITY axis1_placement_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS1_PLACEMENT' IN
        SELF\entity_instance_type.type_name;
END_ENTITY; -- axis1_placement_type


ENTITY axis2_placement_2d_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D'
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_2d_type


ENTITY axis2_placement_3d_type
SUBTYPE OF(placement_type);
WHERE
    WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' 
        IN SELF\entity_instance_type.type_name;
END_ENTITY; -- axis2_placement_3d_type


ENTITY named_type
SUBTYPE OF(data_type );
    referred_type: data_type_BSU;
END_ENTITY; -- named_type


ENTITY value_domain;
    its_values: LIST [2:?] OF dic_value;
    source_doc_of_value_domain: OPTIONAL document;
    languages: OPTIONAL present_translations;
    terms: LIST [0:?] OF item_names;
WHERE
    WR1: NOT EXISTS(languages) OR (QUERY(v <* its_values |
        languages :<>: v.meaning.languages) = []);
    WR2: codes_are_unique(its_values);
END_ENTITY; -- value_domain


TYPE integer_type = INTEGER; 
END_TYPE; -- integer_type

TYPE value_type = SELECT(value_code_type, integer_type); 
END_TYPE; -- value_type


ENTITY dic_value;
    value_code: value_type;
    meaning: item_names;
    source_doc_of_value: OPTIONAL document;
END_ENTITY; -- dic_value


ENTITY non_si_unit
SUBTYPE OF(named_unit);
    name: label;
END_ENTITY; -- non_si_unit


RULE assert_ONEOF FOR(named_unit);
WHERE
    QUERY(u <* named_unit | 
        ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' 
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u))
        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT' 
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u))
        OR ('ISO13584_IEC61360_DICTIONARY_SCHEMA.NON_SI_UNIT'
        IN TYPEOF(u)) AND
        ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u))
        ) = []; 
END_RULE; -- assert_ONEOF


ENTITY dic_unit;
    structured_representation: unit; 
    string_representation: OPTIONAL mathematical_string;
END_ENTITY; -- dic_unit


TYPE class_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= class_code_len;
END_TYPE; -- class_code_type


TYPE code_type = identifier; 
WHERE 
    WR1: NOT(SELF LIKE '*.*');
    WR2: NOT(SELF LIKE '*-*');
    WR3: NOT(SELF LIKE '* *');
    WR4: NOT(SELF = '');
END_TYPE; -- code_type


TYPE currency_code = identifier;
WHERE
    WR1: LENGTH(SELF) = 3;
END_TYPE; -- currency_code


TYPE data_type_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) = data_type_code_len;
END_TYPE; -- data_type_code_type


TYPE date_type = STRING(10) FIXED;
END_TYPE; -- date_type


TYPE definition_type = translatable_text;
END_TYPE; -- definition_type


TYPE DET_classification_type = identifier;
WHERE
    WR1: LENGTH(SELF) = DET_classification_len; 
END_TYPE; -- DET_classification_type


TYPE note_type = translatable_text;
END_TYPE; -- note_type


TYPE pref_name_type = translatable_label;
WHERE
    WR1: check_label_length(SELF, pref_name_len);
END_TYPE; -- pref_name_type


TYPE property_code_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= property_code_len;
END_TYPE; -- property_code_type


TYPE remark_type = translatable_text; 
END_TYPE; -- remark_type


TYPE revision_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= revision_len; 
END_TYPE; -- revision_type


TYPE short_name_type = translatable_label;
WHERE
    WR1: check_label_length(SELF, short_name_len); 
END_TYPE; -- short_name_type


TYPE supplier_code_type = code_type;
WHERE
    WR1: LENGTH(SELF) <= supplier_code_len; 
END_TYPE; -- supplier_code_type


TYPE syn_name_type = SELECT(label_with_language, label);
WHERE
    WR1: check_syn_length(SELF, syn_name_len); 
END_TYPE; -- syn_name_type


TYPE value_code_type = identifier;
WHERE
    WR1: LENGTH(SELF) <= value_code_len; 
END_TYPE; -- value_code_type


TYPE value_format_type = identifier;
WHERE
    WR1: LENGTH(SELF) <= value_format_len; 
END_TYPE; -- value_format_type


TYPE version_type = code_type; 
WHERE 
    WR1: LENGTH(SELF) <= version_len; 
    WR2: EXISTS(VALUE(SELF)) AND ('INTEGER' IN TYPEOF(VALUE(SELF)))
        AND (VALUE(SELF) >= 0);
END_TYPE; -- version_type


TYPE source_doc_type = identifier; 
WHERE
    WR1: LENGTH(SELF) <= source_doc_len; 
END_TYPE; -- source_doc_type


ENTITY dates;
    date_of_original_definition: date_type;
    date_of_current_version: date_type;
    date_of_current_revision: OPTIONAL date_type;
END_ENTITY; -- dates


ENTITY document
ABSTRACT SUPERTYPE;
END_ENTITY; -- document


ENTITY graphics
ABSTRACT SUPERTYPE;
END_ENTITY; -- graphics


ENTITY identified_document
SUBTYPE OF(document);
    document_identifier: source_doc_type;
END_ENTITY; -- identified_document


ENTITY item_names;
    preferred_name: pref_name_type;
    synonymous_names: SET OF syn_name_type;
    short_name: short_name_type;
    languages: OPTIONAL present_translations;
    icon : OPTIONAL graphics;
WHERE
    WR1: NOT(EXISTS(languages )) OR (
        ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'
        + '.TRANSLATED_LABEL' IN TYPEOF(preferred_name))
        AND (languages :=: preferred_name\translated_label.languages)
        AND ('ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA'
        + '.TRANSLATED_LABEL' IN TYPEOF(short_name))
        AND (languages :=: short_name\translated_label.languages)
        AND (QUERY(s <* synonymous_names |
        NOT('ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
        '.LABEL_WITH_LANGUAGE' IN TYPEOF(s))) = []));
    WR2: NOT EXISTS(languages) OR (QUERY(s <* synonymous_names |
        EXISTS(s.language) AND NOT(s.language IN
        QUERY(l <* languages.language_codes | TRUE
        ))) = []);
    WR3: at_most_two_synonyms_per_language(languages, 
        synonymous_names);
END_ENTITY; -- item_names


ENTITY label_with_language;
    l: label;
    language: language_code;
END_ENTITY; -- label_with_language


ENTITY mathematical_string;
    text_representation: text; 
    SGML_representation: OPTIONAL text;
END_ENTITY; -- mathematical_string


FUNCTION acyclic_superclass_relationship(
    current: class_BSU; visited: SET OF class): LOGICAL;

IF SIZEOF(current.definition) = 1 THEN 
    IF current.definition[1] IN visited THEN
        RETURN(FALSE);
    
    ELSE
        IF EXISTS(current.definition[1]\class.its_superclass)
        THEN 
            RETURN(acyclic_superclass_relationship(
                current.definition[1]\class.its_superclass,
                visited + current.definition[1])); 
        ELSE
            RETURN(TRUE);
        END_IF;
    END_IF;
ELSE
    RETURN(UNKNOWN);
END_IF;
END_FUNCTION; -- acyclic_superclass_relationship


FUNCTION at_most_two_synonyms_per_language(
    languages: present_translations;
    synonymous_names: SET OF syn_name_type): BOOLEAN;

IF EXISTS(languages) THEN
    REPEAT i := 1 TO SIZEOF(languages.language_codes);
        IF SIZEOF(QUERY(s <* synonymous_names |
            s.language = languages.language_codes[i])) > 2
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;
    RETURN(TRUE);
ELSE
    RETURN(SIZEOF(synonymous_names) <= 2);
END_IF;
END_FUNCTION; -- at_most_two_synonyms_per_language


FUNCTION check_syn_length(s: syn_name_type; s_length: INTEGER):BOOLEAN;

IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA.LABEL_WITH_LANGUAGE' 
    IN TYPEOF(s)
THEN 
    RETURN(LENGTH(s.l) <= s_length); 
ELSE
    RETURN(LENGTH(s) <= s_length); 
END_IF;
END_FUNCTION; -- check_syn_length 


FUNCTION codes_are_unique(values: LIST OF dic_value): BOOLEAN;
LOCAL
    ls: SET OF STRING := [];
    li: SET OF INTEGER := [];
END_LOCAL;

IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.VALUE_CODE_TYPE' IN 
    TYPEOF(values[1].value_code))
THEN
    REPEAT i := 1 TO SIZEOF(values);
        ls := ls + values[i].value_code;
    END_REPEAT;

    RETURN(SIZEOF(values) = SIZEOF(ls));
ELSE
    IF('ISO13584_IEC61360_DICTIONARY_SCHEMA.INTEGER_TYPE' IN 
        TYPEOF(values[1].value_code))
    THEN
        REPEAT i := 1 TO SIZEOF(values);
            li := li + values[i].value_code;
        END_REPEAT;

        RETURN(SIZEOF(values) = SIZEOF(li));
    ELSE
        RETURN(UNKNOWN);
    END_IF;
END_IF;

END_FUNCTION; -- codes_are_unique


FUNCTION definition_available_implies(
    BSU: basic_semantic_unit;
    expression: LOGICAL): LOGICAL;

RETURN(NOT(SIZEOF(BSU.definition) = 1) OR expression);

END_FUNCTION; -- definition_available_implies


FUNCTION is_subclass(sub, super: class): LOGICAL;
    IF (NOT EXISTS(sub)) OR (NOT EXISTS(super)) THEN
        RETURN(UNKNOWN);
    END_IF;
    
    IF sub = super
    THEN
        RETURN(TRUE);
    END_IF;
    
    IF NOT EXISTS(sub.its_superclass) 
    THEN
        
        RETURN(FALSE); 
    END_IF;
    
    IF SIZEOF(sub.its_superclass.definition) = 1 
    THEN


        IF (sub.its_superclass.definition[1] = super) 
        THEN
            RETURN(TRUE);
        ELSE
            RETURN(is_subclass(sub.its_superclass.definition[1],
                super));
        END_IF;
    ELSE
        RETURN(UNKNOWN);
    END_IF;

END_FUNCTION; -- is_subclass


FUNCTION string_for_derived_unit(u: derived_unit): STRING;

    FUNCTION string_for_derived_unit_element(
        u: derived_unit_element; neg_exp: BOOLEAN
        ): STRING;
        

    
    LOCAL
        result: STRING;
    END_LOCAL;
        
    result := string_for_named_unit(u.unit);
    IF (u.exponent <> 0) 
    THEN 
        IF (u.exponent > 0) OR NOT neg_exp 
        THEN
            result := result + '**' + FORMAT(
                ABS(u.exponent), '2I')[2];
        ELSE
            result := result + '**' + FORMAT(u.exponent, '2I')[2];
        END_IF;
    END_IF;
        RETURN(result); 
    END_FUNCTION; -- string_for_derived_unit_element

LOCAL
    pos, neg: SET OF derived_unit_element;
    us: STRING;
END_LOCAL;
    

pos := QUERY(ue <* u.elements | ue.exponent > 0); 
neg := QUERY(ue <* u.elements | ue.exponent < 0); 
us := '';
IF SIZEOF(pos) > 0 THEN
    
    REPEAT i := LOINDEX(pos) TO HIINDEX(pos);
        us := us + string_for_derived_unit_element(pos[i], FALSE);
        IF i <> HIINDEX(pos) 
        THEN
            us := us + '.'; 
        END_IF;
    END_REPEAT;

    IF SIZEOF(neg) > 0 
    THEN 
        

        us := us + '/';

        IF SIZEOF(neg) > 1 
        THEN
            us := us + '('; 
        END_IF;

        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], FALSE);
            IF i <> HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;

        IF SIZEOF(neg) > 1 
        THEN 
            us := us + ')'; 
        END_IF;
    END_IF;
ELSE 
    
    IF SIZEOF(neg) > 0 THEN
        REPEAT i := LOINDEX(neg) TO HIINDEX(neg);
            us := us + string_for_derived_unit_element(
                neg[i], TRUE);
            IF i <> HIINDEX(neg) 
            THEN 
                us := us + '.'; 
            END_IF;
        END_REPEAT;
    END_IF;
END_IF;

RETURN(us);

END_FUNCTION; -- string_for_derived_unit


FUNCTION string_for_named_unit(u: named_unit): STRING;

IF 'MEASURE_SCHEMA.SI_UNIT' IN TYPEOF(u) THEN
    RETURN(string_for_SI_unit(u));
ELSE
    IF 'MEASURE_SCHEMA.CONTEXT_DEPENDENT_UNIT' IN TYPEOF(u)
    THEN
        RETURN(u\context_dependent_unit.name);
    ELSE
        IF 'MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF(u)
        THEN
            RETURN(u\conversion_based_unit.name);
        ELSE
            IF 'ISO13584_IEC61360_DICTIONARY_SCHEMA'
                +'.NON_SI_UNIT' IN TYPEOF(u)
            THEN
                RETURN(u\non_si_unit.name);
            ELSE
                RETURN('name_unknown');
            END_IF;
        END_IF;
    END_IF;
END_IF;

END_FUNCTION; -- string_for_named_unit


FUNCTION string_for_SI_unit(unit: si_unit): STRING;

LOCAL
    prefix_string, unit_string: STRING;
END_LOCAL;

IF EXISTS(unit.prefix) THEN
    CASE unit.prefix OF
        exa     : prefix_string := 'E';
        peta        : prefix_string := 'P';
        tera        : prefix_string := 'T';
        giga        : prefix_string := 'G';
        mega        : prefix_string := 'M';
        kilo        : prefix_string := 'k';
        hecto   : prefix_string := 'h';
        deca        : prefix_string := 'da';
        deci        : prefix_string := 'd';
        centi   : prefix_string := 'c';
        milli   : prefix_string := 'm';
        micro   : prefix_string := 'u';
        nano        : prefix_string := 'n';
        pico        : prefix_string := 'p';
        femto   : prefix_string := 'f';
        atto        : prefix_string := 'a';
    END_CASE;
ELSE
    prefix_string := '';
END_IF;

CASE unit.name OF
    metre           : unit_string:= 'm'; 
    gram                : unit_string := 'g'; 
    second          : unit_string := 's'; 
    ampere          : unit_string := 'A'; 
    kelvin          : unit_string := 'K'; 
    mole                : unit_string := 'mol'; 
    candela         : unit_string := 'cd'; 
    radian          : unit_string := 'rad'; 
    steradian           : unit_string := 'sr'; 
    hertz           : unit_string := 'Hz'; 
    newton          : unit_string := 'N'; 
    pascal          : unit_string := 'Pa'; 
    joule           : unit_string := 'J'; 
    watt                : unit_string := 'W'; 
    coulomb         : unit_string := 'C'; 
    volt                : unit_string := 'V'; 
    farad           : unit_string := 'F'; 
    ohm             : unit_string := 'Ohm';
    siemens         : unit_string := 'S'; 
    weber           : unit_string := 'Wb'; 
    tesla           : unit_string := 'T'; 
    henry           : unit_string := 'H'; 
    degree_Celsius      : unit_string := 'Cel';
    lumen           : unit_string := 'lm'; 
    lux             : unit_string := 'lx'; 
    becquerel           : unit_string := 'Bq'; 
    gray                : unit_string := 'Gy';
    sievert         : unit_string := 'Sv';
END_CASE;

RETURN(prefix_string + unit_string); 

END_FUNCTION; -- string_for_SI_unit


FUNCTION string_for_unit(u: unit): STRING;
    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(u) 
    THEN
        RETURN(string_for_derived_unit(u));
    ELSE 
        RETURN(string_for_named_unit(u));
    END_IF;
END_FUNCTION; -- string_for_unit


FUNCTION all_class_descriptions_reachable(cl: class_BSU): BOOLEAN;

IF NOT EXISTS(cl)
THEN
    RETURN(UNKNOWN);
END_IF;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(FALSE);
END_IF;

IF NOT(EXISTS(cl.definition[1]\class.its_superclass))
THEN
    RETURN(TRUE);
ELSE
    RETURN(all_class_descriptions_reachable(
        cl.definition[1]\class.its_superclass));
END_IF;

END_FUNCTION; -- all_class_descriptions_reachable


FUNCTION compute_known_visible_properties(cl: class_BSU):
    SET OF property_BSU;
LOCAL
    s: SET OF property_BSU := [];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.PROPERTY_BSU.NAME_SCOPE');
IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) THEN
        s := s + compute_known_visible_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_properties


FUNCTION compute_known_visible_data_types(cl: class_BSU):
    SET OF data_type_BSU;
LOCAL
    s: SET OF data_type_BSU :=[ ];
END_LOCAL;

s := s + USEDIN(cl, 'ISO13584_IEC61360_DICTIONARY_SCHEMA' + 
    '.DATA_TYPE_BSU.NAME_SCOPE');

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_visible_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_visible_data_types


FUNCTION compute_known_applicable_properties(cl: class_BSU): 
    SET OF property_BSU;

LOCAL 
    s: SET OF property_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition)=0
THEN 
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.described_by);
        s := s + cl.definition[1]\class.described_by[i];
    END_REPEAT;

    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN 
        s := s + compute_known_applicable_properties(
            cl.definition[1]\class.its_superclass);
    END_IF;

    RETURN(s); 
END_IF;
END_FUNCTION; -- compute_known_applicable_properties


FUNCTION compute_known_applicable_data_types(cl: class_BSU):
    SET OF data_type_BSU;
LOCAL
    s: SET OF data_type_BSU := [];
END_LOCAL;

IF SIZEOF(cl.definition) = 0
THEN
    RETURN(s);
ELSE
    REPEAT i := 1 TO SIZEOF(cl.definition[1]\class.defined_types);
        s := s + cl.definition[1]\class.defined_types[i];
    END_REPEAT;
    
    IF EXISTS(cl.definition[1]\class.its_superclass) 
    THEN
        s := s + compute_known_applicable_data_types(
            cl.definition[1]\class.its_superclass);
    END_IF;
    
    RETURN(s);
END_IF;

END_FUNCTION; -- compute_known_applicable_data_types


FUNCTION list_to_set(l: LIST [0:?] OF GENERIC:type_elem):
    SET OF GENERIC: type_elem;

LOCAL
    s: SET OF GENERIC: type_elem := [];
END_LOCAL;

REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
END_REPEAT;

RETURN(s);
END_FUNCTION; -- list_to_set


FUNCTION check_properties_applicability(cl: class): LOGICAL;
LOCAL
    inter: SET OF property_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition)=1)
    THEN
        inter := (list_to_set(cl.described_by) * 
            cl.its_superclass.definition[1]\class.
            known_applicable_properties);
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_properties_applicability


FUNCTION check_datatypes_applicability(cl: class): LOGICAL;
LOCAL
    inter: SET OF data_type_bsu := [];
END_LOCAL;

IF EXISTS(cl.its_superclass)
THEN
    IF (SIZEOF(cl.its_superclass.definition) = 1)
    THEN
        inter := cl.defined_types * 
            cl.its_superclass.definition[1]\class.
            known_applicable_data_types;
        RETURN(inter = []);
    ELSE
        RETURN(UNKNOWN);
    END_IF;
ELSE
    RETURN(TRUE);
END_IF;

END_FUNCTION; -- check_datatypes_applicability

END_SCHEMA; -- ISO13584_IEC61360_dictionary_schema
SCHEMA ISO13584_IEC61360_language_resource_schema;

REFERENCE FROM support_resource_schema(identifier, label, text); 
    
 


TYPE language_code = identifier; 
END_TYPE; -- language_code


ENTITY global_language_assignment;
    language: language_code;
END_ENTITY; -- global_language_assignment


ENTITY present_translations; 
    language_codes: LIST [1:?] OF UNIQUE language_code;
UNIQUE
    UR1: language_codes;
END_ENTITY; -- present_translations


TYPE translatable_label = SELECT(label, translated_label);
END_TYPE; -- translatable_label


ENTITY translated_label; 
    labels: LIST [1:?] OF label;
    languages: present_translations; 
WHERE
    WR1: SIZEOF(labels) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_label


TYPE translatable_text = SELECT(text, translated_text);
END_TYPE; -- translatable_text


ENTITY translated_text; 
    texts: LIST [1:?] OF text;
    languages: present_translations; 
WHERE
    WR1: SIZEOF(texts) = SIZEOF(languages.language_codes);
END_ENTITY; -- translated_text


FUNCTION check_label_length(l: translatable_label;
    l_length: INTEGER): BOOLEAN;

IF 'ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA.TRANSLATED_LABEL' 
    IN TYPEOF(l) 
THEN 
    REPEAT i :=1 TO SIZEOF(l.labels);
        IF LENGTH(l.labels[i]) > l_length 
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;

    RETURN(TRUE);

ELSE 
    RETURN(LENGTH(l) <= l_length); 
END_IF;
END_FUNCTION; -- check_label_length 


FUNCTION check_text_length(t: translatable_text;
    t_length: INTEGER): BOOLEAN;

IF 'ISO13584_IEC61360_LANGUAGE_RESOURCE_SCHEMA.TRANSLATED_TEXT' 
    IN TYPEOF(t) 
THEN 
    REPEAT i :=1 TO SIZEOF(t.texts);
        IF LENGTH(t.texts[i]) > t_length 
        THEN
            RETURN(FALSE);
        END_IF;
    END_REPEAT;

    RETURN(TRUE);

ELSE 
    RETURN(LENGTH(t) <= t_length); 
END_IF;
END_FUNCTION; -- check_text_length 


RULE single_language_assignment FOR(global_language_assignment);
WHERE
    SIZEOF(global_language_assignment) <= 1;
END_RULE; -- single_language_assignment


END_SCHEMA; -- ISO13584_IEC61360_language_resource_schema
(* Genenerated from: ../../irs/wg12n587.exp *)

SCHEMA kinematic_analysis_control_and_result_schema;

REFERENCE FROM kinematic_motion_representation_schema
    (kinematic_path,
     motion_parameter_measure);

REFERENCE FROM kinematic_structure_schema
    (kinematic_joint,
     kinematic_link_representation,
     mechanism,
     pair_value,
     rigid_placement);

REFERENCE FROM geometry_schema
    (geometric_representation_context);

REFERENCE FROM representation_schema
    (representation,
     representation_relationship);

TYPE interpolation_type = ENUMERATION OF
  (undefined,
   synchronous,
   linear);
END_TYPE;

TYPE kinematic_analysis_definition = SELECT
  (interpolated_configuration_sequence,
   prescribed_path);
END_TYPE;

TYPE kinematic_result = SELECT
  (interpolated_configuration_sequence,
   resulting_path);
END_TYPE;

ENTITY configuration_interpolation;
  previous_configuration_definition : configuration_definition;
  next_configuration_definition     : configuration_definition;
  interpolation                     : interpolation_type;
END_ENTITY ;

ENTITY kinematic_control;
  controlled_mechanism         : mechanism;
  contained_kinematic_programs : SET [1 : ?] OF kinematic_analysis_definition;
END_ENTITY;

ENTITY founded_kinematic_path
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1 : ?] OF kinematic_path;
  SELF\representation.context_of_items :
       geometric_representation_context;
DERIVE
  paths : SET [1 : ?] OF kinematic_path := SELF\representation.items;
  founding : geometric_representation_context
           := SELF\representation.context_of_items;
END_ENTITY;

ENTITY motion_link_relationship
  SUPERTYPE OF (ONEOF (prescribed_path, resulting_path))
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : founded_kinematic_path;
  SELF\representation_relationship.rep_2 :
       kinematic_link_representation;
  related_frame                          : rigid_placement;
DERIVE
  motion     : founded_kinematic_path
             := SELF\representation_relationship.rep_1;
  frame_link : kinematic_link_representation
             := SELF\representation_relationship.rep_2;
WHERE
  WR1: related_frame IN frame_link\representation.items;
END_ENTITY;

ENTITY configuration_definition;
  pair_values : SET [1 : ?] OF pair_value;
  t_parameter : motion_parameter_measure;
END_ENTITY;

ENTITY interpolated_configuration_sequence;
  interpolation : SET [1 : ?] OF configuration_interpolation;
END_ENTITY;

ENTITY prescribed_path
  SUBTYPE OF (motion_link_relationship);
  controlling_joints : OPTIONAL SET [1 : 6] OF kinematic_joint;
END_ENTITY;

ENTITY kinematic_analysis_result;
  analysed_mechanism          : mechanism;
  contained_kinematic_results : SET [1 : ?] OF kinematic_result;
WHERE
WR1: (SIZEOF (QUERY (result <* contained_kinematic_results |
       'KINEMATIC_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.RESULTING_PATH'
       IN TYPEOF (result)))
       > 0)
     XOR
     (SIZEOF (QUERY (result <* contained_kinematic_results |
       (('KINEMATIC_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.'+
         'INTERPOLATED_CONFIGURATION_SEQUENCE' IN TYPEOF (result))
              AND
       (SIZEOF (QUERY (sequence <* result\
                interpolated_configuration_sequence.interpolation |
                (sequence.interpolation <> undefined ))) > 0)))) = 0);
END_ENTITY;

ENTITY kinematic_analysis_consistency;
  control : kinematic_control;
  result  : kinematic_analysis_result;
WHERE
  WR1: control.controlled_mechanism :=: result.analysed_mechanism;
END_ENTITY;

ENTITY resulting_path
  SUBTYPE OF (motion_link_relationship);
  controlling_joints : SET [1 : ?] OF kinematic_joint;
END_ENTITY;

END_SCHEMA;              -- end kinematic_analysis_control_and_result_schema
(* Genenerated from: ../../irs/wg12n587.exp *)

SCHEMA kinematic_motion_representation_schema;

REFERENCE FROM geometry_schema
    (cartesian_point,
     curve);

REFERENCE FROM measure_schema
    (length_measure,
     measure_with_unit,
     parameter_value,
     plane_angle_measure);

REFERENCE FROM representation_schema
    (functionally_defined_transformation,
     representation_item);

REFERENCE FROM kinematic_structure_schema
    (rotation_about_direction,
     spatial_rotation,
     ypr_rotation);

TYPE motion_parameter_measure = SELECT
  (parameter_value,
   measure_with_unit);
END_TYPE;

ENTITY translation;
  x : length_measure;
  y : length_measure;
  z : length_measure;
END_ENTITY;

ENTITY transform
  SUBTYPE OF (functionally_defined_transformation);
  rotation_component    : spatial_rotation;
  translation_component : translation;
END_ENTITY;

ENTITY path_node;
  control_transform : transform;
  t_parameter       : motion_parameter_measure;
END_ENTITY;

ENTITY kinematic_path
  SUPERTYPE OF (ONEOF (path_element, composite_path))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY path_element_connection;
  previous_element     : path_element;
  next_element         : path_element;
WHERE
  WR1: previous_element.node_to = next_element.node_from;
  WR2: compare_unit_components (previous_element.node_to.t_parameter,
                                next_element.node_from.t_parameter);
END_ENTITY;

ENTITY composite_path
  SUBTYPE OF (kinematic_path);
  elements : SET [1 : ?] OF path_element_connection;
  t_start  : motion_parameter_measure;
  t_end    : motion_parameter_measure;
WHERE
  WR1: increasing_measure_value (t_start, t_end);
  WR2: compare_unit_components (t_start, t_end);
  WR3: connected_in_simple_path (elements);
END_ENTITY;

ENTITY path_element
  SUPERTYPE OF (ONEOF (point_to_point_path,
                       circular_path,
                       linear_path,
                       curve_based_path))
  SUBTYPE OF (kinematic_path);
  node_from : path_node;
  node_to   : path_node;
WHERE
  WR1: compare_unit_components (node_from.t_parameter,
                                node_to.t_parameter);
  WR2: increasing_measure_value (node_from.t_parameter,
                                 node_to.t_parameter);
END_ENTITY;

ENTITY point_to_point_path
  SUBTYPE OF (path_element);
END_ENTITY;

ENTITY circular_path
  SUBTYPE OF (path_element);
  via_point : cartesian_point;
WHERE
  WR1: SELF\path_element.node_to.control_transform.translation_component <>
       SELF\path_element.node_from.control_transform.translation_component;
  WR2: non_coincident_coordinates (via_point,
         SELF\path_element.node_from.control_transform.translation_component)
       AND
       non_coincident_coordinates (via_point,
         SELF\path_element.node_to.control_transform.translation_component);
END_ENTITY;

ENTITY linear_path
  SUBTYPE OF (path_element);
END_ENTITY;

ENTITY curve_based_path
  SUBTYPE OF (path_element);
  path_curve : curve;
WHERE
  WR1: SELF\path_element.node_to.control_transform.translation_component <>
       SELF\path_element.node_from.control_transform.translation_component;
END_ENTITY;

FUNCTION connected_in_simple_path (connections : SET OF path_element_connection)
                                               : BOOLEAN;
  LOCAL
     connection_set : SET [0 : ?] OF path_element_connection;
     nec0           : INTEGER;
     pec0           : INTEGER;
     necbranch      : INTEGER;
     pecbranch      : INTEGER;
  END_LOCAL;

  IF SIZEOF (connections) > 1 THEN
    connection_set := QUERY (pec1 <* connections |
                        SIZEOF (QUERY (pec2 <* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) = 0);
    nec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 <* connections |
                        SIZEOF (QUERY (pec2 <* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) = 0);
    pec0 := SIZEOF (connection_set);

    connection_set := QUERY (pec1 <* connections |
                        SIZEOF (QUERY (pec2 <* connections - pec1 |
                          pec1.next_element :=: pec2.previous_element)) > 1);
    necbranch := SIZEOF (connection_set);

    connection_set := QUERY (pec1 <* connections |
                        SIZEOF (QUERY (pec2 <* connections - pec1 |
                          pec2.next_element :=: pec1.previous_element)) > 1);
    pecbranch := SIZEOF (connection_set);

    IF ((nec0 <> 1) OR (pec0 <> 1) OR (necbranch > 0) OR (pecbranch > 0)) THEN
      RETURN (FALSE);
    ELSE
      RETURN (TRUE);
    END_IF;
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;

FUNCTION compare_unit_components (parm1 : motion_parameter_measure;
                                  parm2 : motion_parameter_measure) : BOOLEAN;
   IF (('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm1)) AND
       ('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm2))) THEN
         RETURN (TRUE);
   ELSE
     IF (('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm1)) AND
         ('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm2))) THEN
        IF (parm1.unit_component :=: parm2.unit_component) THEN
           RETURN (TRUE);
        ELSE
           RETURN (FALSE);
        END_IF;
     ELSE
       RETURN (FALSE);
     END_IF;
  END_IF;
END_FUNCTION;

FUNCTION increasing_measure_value (parm1 : motion_parameter_measure;
                                   parm2 : motion_parameter_measure) : BOOLEAN;
  IF ('MEASURE_SCHEMA.PARAMETER_VALUE' IN TYPEOF (parm1)) THEN
    IF (parm1 < parm2)  THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;
  ELSE
    IF ('MEASURE_SCHEMA.MEASURE_WITH_UNIT' IN TYPEOF (parm1)) THEN
      IF (parm1.value_component < parm2.value_component) THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    ELSE
      RETURN (FALSE);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION non_coincident_coordinates (crtpt : cartesian_point;
                                     trltn : translation) : BOOLEAN;
  IF ((crtpt.coordinates[1] = trltn.x) AND
      (crtpt.coordinates[2] = trltn.y) AND
      (crtpt.coordinates[3] = trltn.z)) THEN
    RETURN (FALSE);
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;

END_SCHEMA;   -- end kinematic_motion_representation_schema
(* Genenerated from: ../../irs/wg12n587.exp *)

SCHEMA kinematic_structure_schema;

REFERENCE FROM geometry_schema
    (axis2_placement_3d,
     cartesian_transformation_operator_3d,
     curve,
     direction,
     geometric_representation_context,
     geometric_representation_item,
     normalise,
     point,
     point_on_curve,
     point_on_surface,
     surface,
     rectangular_trimmed_surface,
     trimmed_curve);

REFERENCE FROM measure_schema
    (conversion_based_unit,
     global_unit_assigned_context,
     length_measure,
     plane_angle_measure,
     si_prefix,
     si_unit,
     si_unit_name,
     unit);

REFERENCE FROM product_property_definition_schema
    (characterized_definition,
     property_definition);

REFERENCE FROM product_property_representation_schema
    (property_definition_representation);

REFERENCE FROM representation_schema
    (functionally_defined_transformation,
     item_defined_transformation,
     representation,
     representation_context,
     representation_item,
     representation_relationship,
     representation_relationship_with_transformation);

REFERENCE FROM support_resource_schema
    (bag_to_set,
     label);

TYPE rigid_placement = SELECT
  (axis2_placement_3d,
   su_parameters);
END_TYPE;

TYPE rotational_range_measure = SELECT
  (plane_angle_measure,
   unlimited_range);
END_TYPE;

TYPE translational_range_measure = SELECT
  (length_measure,
   unlimited_range);
END_TYPE;

TYPE unlimited_range = ENUMERATION OF
  (unlimited);
END_TYPE;

TYPE spatial_rotation = SELECT
  (ypr_rotation,
   rotation_about_direction);
END_TYPE;

TYPE ypr_enumeration = ENUMERATION OF
  (yaw,
   pitch,
   roll);
END_TYPE;

TYPE ypr_rotation = ARRAY [ypr_index(yaw) : ypr_index(roll)]
                    OF plane_angle_measure;
END_TYPE;

TYPE kinematic_frame_background = SELECT
  (point,
   curve,
   surface);
END_TYPE;

ENTITY rotation_about_direction;
  direction_of_axis : direction;
  rotation_angle    : plane_angle_measure;
WHERE
  WR1: SIZEOF (direction_of_axis.direction_ratios) = 3;
END_ENTITY;

ENTITY kinematic_property_definition
  SUBTYPE OF (property_definition);
  ground_definition : characterized_definition;
END_ENTITY;

ENTITY kinematic_property_representation_relation
  SUBTYPE OF (property_definition_representation);
UNIQUE
  UR1: SELF\property_definition_representation.definition;
WHERE
  WR1: 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_PROPERTY_DEFINITION'
         IN TYPEOF (SELF\property_definition_representation.definition);
  WR2: 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_GROUND_REPRESENTATION'
         IN TYPEOF (SELF\property_definition_representation.used_representation);
END_ENTITY;

ENTITY kinematic_ground_representation
  SUBTYPE OF (representation);
INVERSE
  property : kinematic_property_representation_relation FOR used_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF (SELF\representation.context_of_items);
END_ENTITY;

ENTITY mechanism;
  structure_definition : kinematic_structure;
  base                 : kinematic_link;
  containing_property  : kinematic_property_definition;
WHERE
  WR1: SIZEOF (QUERY (joint <* structure_definition.joints |
               (base :=: joint.first_link) OR
               (base :=: joint.second_link) )) > 0;
END_ENTITY;

ENTITY mechanism_base_placement
  SUBTYPE OF (representation_relationship_with_transformation);
  base_of_mechanism         : mechanism;
  SELF\representation_relationship_with_transformation.
    transformation_operator : cartesian_transformation_operator_3d;
DERIVE
  SELF\representation_relationship.rep_2
                            : kinematic_link_representation
                            := representation_of_link (base_of_mechanism.base);
UNIQUE
  UR1: base_of_mechanism;
WHERE
  WR1: ('KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_GROUND_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1))
       OR
       ('KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_LINK_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1));
  WR2: suitably_based_mechanism (SELF, base_of_mechanism);
  WR3: SELF\representation_relationship_with_transformation.
         transformation_operator IN
       SELF\representation_relationship.rep_1.items;
END_ENTITY;

ENTITY initial_state;
  applies_to_mechanism : mechanism;
  pair_values          : SET [1 : ?] OF pair_value;
WHERE
  WR1: SIZEOF (QUERY (joint <* applies_to_mechanism.structure_definition.joints |
               SIZEOF (QUERY (init_val <* pair_values |
                       init_val.applies_to_pair.joint :=: joint)) <> 1)) = 0;
END_ENTITY;

ENTITY kinematic_structure;
  joints : SET [1 : ?] OF kinematic_joint;
END_ENTITY;

ENTITY kinematic_joint ;
  first_link  : kinematic_link;
  second_link : kinematic_link;
INVERSE
  structure   : kinematic_structure FOR joints;
WHERE
  WR1: first_link :<>: second_link;
END_ENTITY;

ENTITY kinematic_link;
WHERE
  WR1: SIZEOF (USEDIN (SELF,
                 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.FIRST_LINK') +
               USEDIN (SELF,
                 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.SECOND_LINK')) > 0;
  WR2: unique_link_usage (SELF);
END_ENTITY;

ENTITY kinematic_link_representation_relation;
  topological_aspects : kinematic_link;
  geometric_aspects   : kinematic_link_representation;
UNIQUE
  UR1: topological_aspects;
END_ENTITY;

ENTITY kinematic_link_representation
  SUBTYPE OF (representation);
  SELF\representation.context_of_items :  geometric_representation_context;
DERIVE
  link_frame                  :  geometric_representation_context
                              := SELF\representation.context_of_items;
INVERSE
  link_representation_relation :
        kinematic_link_representation_relation FOR geometric_aspects;
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
               NOT (('KINEMATIC_STRUCTURE_SCHEMA.RIGID_PLACEMENT' IN
                      TYPEOF (item))
                    OR
 ('GEOMETRY_SCHEMA.CARTESIAN_TRANSFORMATION_OPERATOR_3D' IN
                      TYPEOF (item))) )) = 0;
END_ENTITY;

ENTITY kinematic_link_representation_association
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : kinematic_link_representation;
WHERE
  WR1: SELF\representation_relationship.rep_2.context_of_items :=:
       SELF\representation_relationship.rep_1\representation.context_of_items;
  WR2: SIZEOF (['KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_GROUND_REPRESENTATION',
                'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_LINK_REPRESENTATION'] *
               TYPEOF (SELF\representation_relationship.rep_2)) = 0;
END_ENTITY;

ENTITY kinematic_frame_background_representation
  SUBTYPE OF (representation);
  SELF\representation.items            : SET [1 : ?] OF
                                         kinematic_frame_background;
  SELF\representation.context_of_items : geometric_representation_context;
WHERE
  WR1: SELF\representation.context_of_items\
         geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;

ENTITY kinematic_frame_based_transformation
  SUBTYPE OF (geometric_representation_item,
     functionally_defined_transformation);
  transformator : rigid_placement;
WHERE
  WR1: SELF\geometric_representation_item.dim=3;
END_ENTITY;

ENTITY kinematic_frame_background_representation_association
  SUBTYPE OF (representation_relationship_with_transformation);
  SELF\representation_relationship_with_transformation.
    transformation_operator : kinematic_frame_based_transformation;
WHERE
  WR1: 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_LINK_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_FRAME_BACKGROUND_REPRESENTATION'
         IN TYPEOF (SELF\representation_relationship.rep_2);
  WR3: SELF\representation_relationship_with_transformation.
           transformation_operator\kinematic_frame_based_transformation.
           transformator IN
         SELF\representation_relationship.rep_1.items;
END_ENTITY;

ENTITY su_parameters
  SUBTYPE OF (geometric_representation_item);
  a     : length_measure;
  alpha : plane_angle_measure;
  b     : length_measure;
  beta  : plane_angle_measure;
  c     : length_measure;
  gamma : plane_angle_measure;
WHERE
  WR1: SELF\geometric_representation_item.dim=3;
END_ENTITY;

ENTITY kinematic_pair
  SUBTYPE OF (item_defined_transformation);
  joint : kinematic_joint;
DERIVE
  pair_placement_in_first_link_context
        : rigid_placement
        := SELF\item_defined_transformation.transform_item_1;
  pair_placement_in_second_link_context
        : rigid_placement
        := SELF\item_defined_transformation.transform_item_2;
UNIQUE
  UR1: joint;
WHERE
  WR1: coordinated_pair_link_representation
         (joint.first_link, pair_placement_in_first_link_context);
  WR2: coordinated_pair_link_representation
         (joint.second_link, pair_placement_in_second_link_context);
END_ENTITY;

ENTITY pair_actuator;
  actuated_pair : kinematic_pair;
  name          : label;
UNIQUE
  UR1: actuated_pair;
END_ENTITY;

ENTITY pair_value;
  applies_to_pair : kinematic_pair;
END_ENTITY;

ENTITY simple_pair_range;
  applies_to_pair : kinematic_pair;
END_ENTITY;

ENTITY revolute_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY revolute_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : revolute_pair;
  actual_rotation                 : plane_angle_measure ;
END_ENTITY;

ENTITY revolute_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : revolute_pair;
  lower_limit_actual_rotation            : rotational_range_measure;
  upper_limit_actual_rotation            : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation)))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY prismatic_pair
  SUBTYPE OF ( kinematic_pair);
END_ENTITY;

ENTITY prismatic_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : prismatic_pair;
  actual_translation              : length_measure;
END_ENTITY;

ENTITY prismatic_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : prismatic_pair;
  lower_limit_actual_translation         : translational_range_measure;
  upper_limit_actual_translation         : translational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_translation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_translation)))
       XOR
       (lower_limit_actual_translation < upper_limit_actual_translation);
END_ENTITY;

ENTITY screw_pair
  SUBTYPE OF (kinematic_pair);
  pitch : length_measure;
END_ENTITY;

ENTITY screw_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : screw_pair;
  actual_rotation                 : plane_angle_measure;
DERIVE
  actual_translation              : length_measure
                                  := SELF\pair_value.applies_to_pair\
                                     screw_pair.pitch *
                                     plane_angle_for_pair_in_radian
                                      (SELF\pair_value.applies_to_pair,
                                       actual_rotation) / (2 * PI);
END_ENTITY;

ENTITY screw_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : screw_pair;
  lower_limit_actual_rotation            : rotational_range_measure;
  upper_limit_actual_rotation            : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation)))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY cylindrical_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY cylindrical_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : cylindrical_pair;
  actual_translation              : length_measure;
  actual_rotation                 : plane_angle_measure;
END_ENTITY;

ENTITY cylindrical_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : cylindrical_pair;
  lower_limit_actual_translation         : translational_range_measure;
  upper_limit_actual_translation         : translational_range_measure;
  lower_limit_actual_rotation            : rotational_range_measure;
  upper_limit_actual_rotation            : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_translation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_translation)))
       XOR
       (lower_limit_actual_translation < upper_limit_actual_translation);
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation)))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY spherical_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY spherical_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : spherical_pair;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
END_ENTITY;

ENTITY spherical_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : spherical_pair;
  lower_limit_yaw                        : rotational_range_measure;
  upper_limit_yaw                        : rotational_range_measure;
  lower_limit_pitch                      : rotational_range_measure;
  upper_limit_pitch                      : rotational_range_measure;
  lower_limit_roll                       : rotational_range_measure;
  upper_limit_roll                       : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_yaw))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_yaw)))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_pitch))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_pitch)))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR3: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_roll))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_roll)))
       XOR
       (lower_limit_roll < upper_limit_roll);
END_ENTITY;

ENTITY universal_pair
  SUBTYPE OF (kinematic_pair);
  input_skew_angle : OPTIONAL plane_angle_measure;
DERIVE
  skew_angle       : plane_angle_measure := NVL (input_skew_angle, 0.0);
WHERE
  WR1: COS (plane_angle_for_pair_in_radian (SELF, skew_angle))
       > 0.0;
END_ENTITY;

ENTITY universal_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : universal_pair;
  first_rotation_angle            : plane_angle_measure;
  second_rotation_angle           : plane_angle_measure;
END_ENTITY;

ENTITY universal_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : universal_pair;
  lower_limit_first_rotation             : rotational_range_measure;
  upper_limit_first_rotation             : rotational_range_measure;
  lower_limit_second_rotation            : rotational_range_measure;
  upper_limit_second_rotation            : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_first_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_first_rotation)))
       XOR
       (lower_limit_first_rotation < upper_limit_first_rotation);
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_second_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_second_rotation)))
       XOR
       (lower_limit_second_rotation < upper_limit_second_rotation);
END_ENTITY;

ENTITY planar_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY planar_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : planar_pair;
  actual_rotation                 : plane_angle_measure;
  actual_translation_x            : length_measure;
  actual_translation_y            : length_measure;
END_ENTITY;

ENTITY planar_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : planar_pair;
  lower_limit_actual_rotation            : rotational_range_measure;
  upper_limit_actual_rotation            : rotational_range_measure;
  lower_limit_actual_translation_x       : translational_range_measure;
  upper_limit_actual_translation_x       : translational_range_measure;
  lower_limit_actual_translation_y       : translational_range_measure;
  upper_limit_actual_translation_y       : translational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation)))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_translation_x))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_translation_x)))
       XOR
       (lower_limit_actual_translation_x < upper_limit_actual_translation_x);
  WR3: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_translation_y))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_translation_y)))
       XOR
       (lower_limit_actual_translation_y < upper_limit_actual_translation_y);
END_ENTITY;

ENTITY unconstrained_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY unconstrained_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : unconstrained_pair;
  actual_placement                : axis2_placement_3d;
END_ENTITY;

ENTITY fully_constrained_pair
  SUBTYPE OF (kinematic_pair);
END_ENTITY;

ENTITY point_on_surface_pair
  SUBTYPE OF (kinematic_pair);
  pair_surface : surface;
WHERE
  WR1: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_first_link_context,
         pair_surface);
END_ENTITY;

ENTITY point_on_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : point_on_surface_pair;
  actual_point_on_surface         : point_on_surface;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
WHERE
  WR1: SELF\pair_value.applies_to_pair\point_on_surface_pair.pair_surface :=:
       actual_point_on_surface.basis_surface;
END_ENTITY;

ENTITY point_on_surface_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : point_on_surface_pair;
  range_on_pair_surface                  : rectangular_trimmed_surface;
  lower_limit_yaw                        : rotational_range_measure;
  upper_limit_yaw                        : rotational_range_measure;
  lower_limit_pitch                      : rotational_range_measure;
  upper_limit_pitch                      : rotational_range_measure;
  lower_limit_roll                       : rotational_range_measure;
  upper_limit_roll                       : rotational_range_measure;
WHERE
  WR1: SELF\simple_pair_range.applies_to_pair\point_on_surface_pair.pair_surface
       :=: range_on_pair_surface.basis_surface;
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_yaw))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_yaw)))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR3: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_pitch))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_pitch)))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR4: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_roll))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_roll)))
       XOR
       (lower_limit_roll < upper_limit_roll);
END_ENTITY;

ENTITY surface_pair
  SUBTYPE OF ( kinematic_pair);
  surface_1   : surface;
  surface_2   : surface;
  orientation : BOOLEAN;
WHERE
  WR1: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_first_link_context,
          surface_1);
  WR2: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_second_link_context,
          surface_2);
END_ENTITY;

ENTITY surface_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : surface_pair;
  range_on_surface_1                     : rectangular_trimmed_surface;
  range_on_surface_2                     : rectangular_trimmed_surface;
  lower_limit_actual_rotation            : rotational_range_measure;
  upper_limit_actual_rotation            : rotational_range_measure;
WHERE
  WR1: SELF\simple_pair_range.applies_to_pair\surface_pair.surface_1 :=:
       range_on_surface_1.basis_surface;
  WR2: SELF\simple_pair_range.applies_to_pair\surface_pair.surface_2 :=:
       range_on_surface_2.basis_surface;
  WR3: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation)))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY sliding_surface_pair
  SUBTYPE OF (surface_pair);
END_ENTITY;

ENTITY sliding_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : sliding_surface_pair;
  actual_point_on_surface_1       : point_on_surface;
  actual_point_on_surface_2       : point_on_surface;
  actual_rotation                 : plane_angle_measure;
WHERE
  WR1: SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:
       actual_point_on_surface_1.basis_surface;
  WR2: SELF\pair_value.applies_to_pair\surface_pair.surface_2 :=:
       actual_point_on_surface_2.basis_surface;
END_ENTITY;

ENTITY rolling_surface_pair
  SUBTYPE OF (surface_pair);
END_ENTITY;

ENTITY rolling_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rolling_surface_pair;
  actual_point_on_surface         : point_on_surface;
  actual_rotation                 : plane_angle_measure;
WHERE
  WR1: SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:
       actual_point_on_surface.basis_surface;
END_ENTITY;

ENTITY point_on_planar_curve_pair
  SUBTYPE OF (kinematic_pair);
  pair_curve  : curve;
  orientation : BOOLEAN;
WHERE
  WR1: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_first_link_context,
         pair_curve);
END_ENTITY;

ENTITY point_on_planar_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : point_on_planar_curve_pair;
  actual_point_on_curve           : point_on_curve;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
WHERE
  WR1: SELF\pair_value.applies_to_pair\point_on_planar_curve_pair.pair_curve
       :=: actual_point_on_curve.basis_curve;
END_ENTITY;

ENTITY point_on_planar_curve_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : point_on_planar_curve_pair;
  range_on_pair_curve                    : trimmed_curve;
  lower_limit_yaw                        : rotational_range_measure;
  upper_limit_yaw                        : rotational_range_measure;
  lower_limit_pitch                      : rotational_range_measure;
  upper_limit_pitch                      : rotational_range_measure;
  lower_limit_roll                       : rotational_range_measure;
  upper_limit_roll                       : rotational_range_measure;
WHERE
  WR1: SELF\simple_pair_range.applies_to_pair\
           point_on_planar_curve_pair.pair_curve
       :=: range_on_pair_curve.basis_curve;
  WR2: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_yaw))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_yaw)))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR3: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_pitch))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_pitch)))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR4: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_roll))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_roll)))
       XOR
       (lower_limit_roll < upper_limit_roll);
END_ENTITY;

ENTITY planar_curve_pair
  SUBTYPE OF (kinematic_pair);
  curve_1     : curve;
  curve_2     : curve;
  orientation : BOOLEAN;
WHERE
  WR1: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_first_link_context,
          curve_1);
  WR2: frame_associated_to_background
         (SELF\kinematic_pair.pair_placement_in_second_link_context,
          curve_2);
END_ENTITY;

ENTITY planar_curve_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : planar_curve_pair;
  range_on_curve_1                       : trimmed_curve;
  range_on_curve_2                       : trimmed_curve;
WHERE
  WR1: SELF\simple_pair_range.applies_to_pair\planar_curve_pair.curve_1 :=:
       range_on_curve_1.basis_curve;
  WR2: SELF\simple_pair_range.applies_to_pair\planar_curve_pair.curve_2 :=:
       range_on_curve_2.basis_curve;
END_ENTITY;

ENTITY sliding_curve_pair
  SUBTYPE OF (planar_curve_pair);
END_ENTITY;

ENTITY sliding_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : sliding_curve_pair;
  actual_point_on_curve_1         : point_on_curve;
  actual_point_on_curve_2         : point_on_curve;
WHERE
  WR1: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:
       actual_point_on_curve_1.basis_curve;
  WR2: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_2 :=:
       actual_point_on_curve_2.basis_curve;
END_ENTITY;

ENTITY rolling_curve_pair
  SUBTYPE OF (planar_curve_pair);
END_ENTITY;

ENTITY rolling_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rolling_curve_pair;
  actual_point_on_curve_1         : point_on_curve;
WHERE
  WR1: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:
       actual_point_on_curve_1.basis_curve;
END_ENTITY;

ENTITY gear_pair
  SUBTYPE OF (kinematic_pair);
  radius_first_link  : length_measure;
  radius_second_link : length_measure;
  bevel              : plane_angle_measure;
  helical_angle      : plane_angle_measure;
  gear_ratio         : REAL;
END_ENTITY;

ENTITY gear_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : gear_pair;
  actual_rotation_1               : plane_angle_measure;
DERIVE
  actual_rotation_2               : plane_angle_measure
                                  := - actual_rotation_1 *
                                     SELF\pair_value.applies_to_pair\
                                     gear_pair.gear_ratio;
END_ENTITY;

ENTITY gear_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : gear_pair;
  lower_limit_actual_rotation_1          : rotational_range_measure;
  upper_limit_actual_rotation_1          : rotational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_actual_rotation_1))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_actual_rotation_1)))
       XOR
       (lower_limit_actual_rotation_1 <
        upper_limit_actual_rotation_1);
END_ENTITY;

ENTITY rack_and_pinion_pair
  SUBTYPE OF (kinematic_pair);
  pinion_radius : length_measure;
END_ENTITY;

ENTITY rack_and_pinion_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rack_and_pinion_pair;
  actual_displacement             : length_measure;
DERIVE
  actual_rotation : plane_angle_measure
                  := convert_plane_angle_for_pair_from_radian
                     (SELF\pair_value.applies_to_pair,
                      (- actual_displacement /
                       SELF\pair_value.applies_to_pair\
                       rack_and_pinion_pair.pinion_radius));
END_ENTITY;

ENTITY rack_and_pinion_pair_range
  SUBTYPE OF (simple_pair_range);
  SELF\simple_pair_range.applies_to_pair : rack_and_pinion_pair;
  lower_limit_rack_displacement          : translational_range_measure;
  upper_limit_rack_displacement          : translational_range_measure;
WHERE
  WR1: (('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (lower_limit_rack_displacement))
        OR
        ('KINEMATIC_STRUCTURE_SCHEMA.UNLIMITED_RANGE' IN
         TYPEOF (upper_limit_rack_displacement)))
       XOR
       (lower_limit_rack_displacement < upper_limit_rack_displacement);
END_ENTITY;

ENTITY kinematic_substructure
  SUPERTYPE OF (ONEOF (kinematic_tree_structure,
                       kinematic_network_structure));
  parent_structure : kinematic_structure;
END_ENTITY;

ENTITY kinematic_network_structure
  SUBTYPE OF (kinematic_substructure);
END_ENTITY;

ENTITY kinematic_tree_structure
  SUBTYPE OF (kinematic_substructure);
END_ENTITY;

ENTITY kinematic_loop;
  network : kinematic_network_structure;
WHERE
 WR1 : SIZEOF(USEDIN(SELF,
   'KINEMATIC_STRUCTURE_SCHEMA.JOINT_LOGICAL_RELATIONSHIP.LOOP')) > 0;
 WR2 : SIZEOF (QUERY( relation_1 <* USEDIN(SELF,
    'KINEMATIC_STRUCTURE_SCHEMA.JOINT_LOGICAL_RELATIONSHIP.LOOP') |
         SIZEOF (QUERY (relation_2 <*  (USEDIN(SELF, 
         'KINEMATIC_STRUCTURE_SCHEMA.JOINT_LOGICAL_RELATIONSHIP.LOOP')
              - relation_1) |
              NOT(connected_in_simple_loop (relation_1, relation_2))
         )) > 0 
       )) = 0;
END_ENTITY;

ENTITY joint_logical_relationship;
  loop                             : kinematic_loop;
  previous_joint_logical_structure : oriented_joint;
  next_joint_logical_structure     : oriented_joint;
UNIQUE
  UR1: loop, previous_joint_logical_structure;
  UR2: loop, next_joint_logical_structure;
WHERE
  WR1: previous_joint_logical_structure.exit_link :=:
       next_joint_logical_structure.advent_link;
END_ENTITY;

ENTITY oriented_joint;
  joint       : kinematic_joint;
  orientation : BOOLEAN;
DERIVE
  advent_link : kinematic_link
              := assign_directed_link (joint, orientation);
  exit_link   : kinematic_link
              := assign_directed_link (joint, NOT (orientation));
END_ENTITY;

ENTITY oriented_joint_in_tree
  SUBTYPE OF (oriented_joint);
  parent_structure : kinematic_tree_structure;
END_ENTITY;

ENTITY advent_oriented_joint
  SUBTYPE OF (oriented_joint);
END_ENTITY;

FUNCTION ypr_index (ypr : ypr_enumeration) : INTEGER;
  CASE ypr OF
    yaw    : RETURN (1);
    pitch  : RETURN (2);
    roll   : RETURN (3);
  END_CASE;
  RETURN (?);
END_FUNCTION;

FUNCTION representation_of_link (link : kinematic_link)
    : kinematic_link_representation;
  LOCAL
    link_rep_rel : BAG OF kinematic_link_representation_relation;
  END_LOCAL;

  link_rep_rel := USEDIN (link, 'KINEMATIC_STRUCTURE_SCHEMA.'+
                                'KINEMATIC_LINK_REPRESENTATION_RELATION.'+
                                'TOPOLOGICAL_ASPECTS');
  IF (SIZEOF (link_rep_rel) = 0) THEN
    RETURN (?);
  ELSE
    RETURN (link_rep_rel[1].geometric_aspects);
  END_IF;
END_FUNCTION;

FUNCTION suitably_based_mechanism (mbp  : mechanism_base_placement;
                                   mech : mechanism) : BOOLEAN;
  LOCAL
    kprop  : kinematic_property_definition;
    kgrep  : kinematic_ground_representation;
    klrep  : kinematic_link_representation;
    klnk   : kinematic_link;
    kjnts  : BAG OF kinematic_joint;
    nmechs : BAG OF mechanism;
    nmbps  : BAG OF mechanism_base_placement;
  END_LOCAL;

  kprop := mech.containing_property;

  IF ('KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_GROUND_REPRESENTATION' IN
      TYPEOF (mbp\representation_relationship.rep_1)) THEN
      kgrep := mbp\representation_relationship.rep_1;

    IF (kgrep.property\property_definition_representation.definition
        :=: kprop) THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;
  ELSE
    klrep := mbp\representation_relationship.rep_1;
    klnk   := klrep.link_representation_relation.topological_aspects;
    kjnts  := USEDIN (klnk,
            'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.FIRST_LINK') +
              USEDIN (klnk,
            'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.SECOND_LINK');
    nmechs := USEDIN (kjnts[1].structure,
         'KINEMATIC_STRUCTURE_SCHEMA.MECHANISM.STRUCTURE_DEFINITION');

    IF (nmechs[1] :=: mech) THEN
      RETURN (FALSE);
    ELSE
      IF (nmechs[1].containing_property :<>: kprop) THEN
        RETURN (FALSE);
      ELSE
        nmbps := USEDIN (nmechs[1], 'KINEMATIC_STRUCTURE_SCHEMA.'+
                        'MECHANISM_BASE_PLACEMENT.BASE_OF_MECHANISM');

        IF (SIZEOF (nmbps) = 0) THEN
          RETURN (FALSE);
        ELSE
          RETURN (suitably_based_mechanism (nmbps[1], mech));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION unique_link_usage (link : kinematic_link) : BOOLEAN;
  LOCAL
    mechs  : SET OF mechanism;
    joints : SET OF kinematic_joint;
    struct : kinematic_structure;
  END_LOCAL;
  joints := bag_to_set
              (USEDIN (link,
                 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.FIRST_LINK') +
               USEDIN (link,
                 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_JOINT.SECOND_LINK'));
  struct := joints[1].structure;
  REPEAT i := 2 TO SIZEOF (joints);
    IF (joints[i].structure :<>: struct) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  mechs := bag_to_set
             (USEDIN (struct,
                'KINEMATIC_STRUCTURE_SCHEMA.MECHANISM.STRUCTURE_DEFINITION'));
  IF (SIZEOF (mechs) <> 1) THEN
    RETURN (FALSE);
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION coordinated_pair_link_representation
    (link           : kinematic_link;
     pair_placement : rigid_placement) : BOOLEAN;
  LOCAL
    link_rep : kinematic_link_representation;
  END_LOCAL;

  link_rep := representation_of_link (link);

  IF (link_rep = ?) THEN
    RETURN (FALSE);
  ELSE
    IF NOT (pair_placement IN link_rep\representation.items) THEN
      RETURN (FALSE);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION frame_associated_to_background
  (frame      : rigid_placement;
   background : kinematic_frame_background) : BOOLEAN;
  LOCAL
    rep_bag : BAG OF kinematic_frame_background_representation;
    trf_bag : BAG OF kinematic_frame_based_transformation;
    trm_bag : BAG OF kinematic_frame_based_transformation;
    ass_bag : BAG OF
              kinematic_frame_background_representation_association;
    rep     : kinematic_frame_background_representation;
    ass     : kinematic_frame_background_representation_association;
  END_LOCAL;

  rep_bag := QUERY ( bg <* USEDIN (background,
                     'KINEMATIC_STRUCTURE_SCHEMA.' +
                     'REPRESENTATION.ITEMS')|
                     'KINEMATIC_STRUCTURE_SCHEMA.'+
                     'KINEMATIC_FRAME_BACKGROUND_REPRESENTATION' 
                      IN TYPEOF (bg) );

  IF SIZEOF (rep_bag) = 0 THEN
    RETURN (FALSE);
  END_IF;

  trf_bag := USEDIN (frame,
                     'KINEMATIC_STRUCTURE_SCHEMA.' +
                     'KINEMATIC_FRAME_BASED_TRANSFORMATION.' +
                     'TRANSFORMATOR');

  IF SIZEOF (trf_bag) = 0 THEN
    RETURN (FALSE);
  END_IF;

  REPEAT i := 1 TO HIINDEX (rep_bag);
    rep := rep_bag[i];

ass_bag := QUERY ( kfbra <* USEDIN ( rep,
             'KINEMATIC_STRUCTURE_SCHEMA.' +
             'REPRESENTATION_RELATIONSHIP.REP_2') |
             'KINEMATIC_STRUCTURE_SCHEMA.'+
             'KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION'
             IN TYPEOF ( kfbra ) );

    IF SIZEOF (ass_bag) > 0 THEN
      REPEAT j:= 1 TO HIINDEX (ass_bag);
        ass := ass_bag[j];

        trm_bag := QUERY (trm <* trf_bag |
          (trm :=:
           ass\representation_relationship_with_transformation.
           transformation_operator));

        IF SIZEOF (trm_bag) > 0 THEN
          RETURN (TRUE);
        END_IF;

      END_REPEAT;
    END_IF;
  END_REPEAT;

  RETURN (FALSE);

END_FUNCTION;

FUNCTION plane_angle_for_pair_in_radian
         (pair  : kinematic_pair;
          angle : plane_angle_measure) : plane_angle_measure;
  LOCAL
    converted_angle : plane_angle_measure := angle;
    link_rep        : kinematic_link_representation
                    := representation_of_link (pair.joint.first_link);
    link_cntxt      : representation_context;
    pa_units        : SET OF unit := [];
    pau             : unit;
  END_LOCAL;

  link_cntxt := link_rep\representation.context_of_items;

  IF NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
          IN TYPEOF (link_cntxt)) THEN
    RETURN (?);
  END_IF;

  pa_units := QUERY (unit <* link_cntxt\global_unit_assigned_context.units |
                     'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (unit));

  IF SIZEOF (pa_units) <> 1 THEN
    RETURN (?);
  END_IF;

  pau := pa_units[1];

  IF (NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
      NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) THEN
    RETURN (?);
  END_IF;

  REPEAT WHILE ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau));
    converted_angle := converted_angle *
                       pau\conversion_based_unit.conversion_factor.
                       value_component;
    pau := pau\conversion_based_unit.conversion_factor.unit_component;

    IF ((NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
         NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) OR
        (NOT ('MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (pau)))) THEN
      RETURN (?);
    END_IF;
  END_REPEAT;

  IF (pau\si_unit.name <> si_unit_name.radian) THEN
    RETURN (?);
  END_IF;

  CASE pau\si_unit.prefix OF
    si_prefix.exa     : RETURN (1.E18 * converted_angle);
    si_prefix.peta    : RETURN (1.E15 * converted_angle);
    si_prefix.tera    : RETURN (1.E12 * converted_angle);
    si_prefix.giga    : RETURN (1.E9 * converted_angle);
    si_prefix.mega    : RETURN (1.E6 * converted_angle);
    si_prefix.kilo    : RETURN (1.E3 * converted_angle);
    si_prefix.hecto   : RETURN (1.E2 * converted_angle);
    si_prefix.deca    : RETURN (1.E1 * converted_angle);
    si_prefix.deci    : RETURN (1.E-1 * converted_angle);
    si_prefix.centi   : RETURN (1.E-2 * converted_angle);
    si_prefix.milli   : RETURN (1.E-3 * converted_angle);
    si_prefix.micro   : RETURN (1.E-6 * converted_angle);
    si_prefix.nano    : RETURN (1.E-9 * converted_angle);
    si_prefix.pico    : RETURN (1.E-12 * converted_angle);
    si_prefix.femto   : RETURN (1.E-15 * converted_angle);
    si_prefix.atto    : RETURN (1.E-18 * converted_angle);
  OTHERWISE           : RETURN (converted_angle);
  END_CASE;

END_FUNCTION;

FUNCTION convert_plane_angle_for_pair_from_radian
         (pair       : kinematic_pair;
          angle_expr : REAL) : plane_angle_measure;
  LOCAL
    link_rep    : kinematic_link_representation
                := representation_of_link (pair.joint.first_link);
    link_cntxt  : representation_context;
    pa_units    : SET OF unit := [];
    pau         : unit;
    conv_factor : REAL := 1.0;
    result      : plane_angle_measure;
  END_LOCAL;

  link_cntxt := link_rep\representation.context_of_items;

  IF NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
          IN TYPEOF (link_cntxt)) THEN
    RETURN (?);
  END_IF;

  pa_units := QUERY (unit <* link_cntxt\global_unit_assigned_context.units |
                     'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (unit));

  IF SIZEOF (pa_units) <> 1 THEN
    RETURN (?);
  END_IF;

  pau := pa_units[1];

  IF (NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
      NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) THEN
    RETURN (?);
  END_IF;

  REPEAT WHILE ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau));
    conv_factor := conv_factor *
                   pau\conversion_based_unit.conversion_factor.
                   value_component;
    pau := pau\conversion_based_unit.conversion_factor.unit_component;

    IF ((NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
         NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) OR
        (NOT ('MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (pau)))) THEN
      RETURN (?);
    END_IF;
  END_REPEAT;

  IF (pau\si_unit.name <> si_unit_name.radian) THEN
    RETURN (?);
  END_IF;

  CASE pau\si_unit.prefix OF
    si_prefix.exa     : conv_factor := 1.E18 * conv_factor;
    si_prefix.peta    : conv_factor := 1.E15 * conv_factor;
    si_prefix.tera    : conv_factor := 1.E12 * conv_factor;
    si_prefix.giga    : conv_factor := 1.E9 * conv_factor;
    si_prefix.mega    : conv_factor := 1.E6 * conv_factor;
    si_prefix.kilo    : conv_factor := 1.E3 * conv_factor;
    si_prefix.hecto   : conv_factor := 1.E2 * conv_factor;
    si_prefix.deca    : conv_factor := 1.E1 * conv_factor;
    si_prefix.deci    : conv_factor := 1.E-1 * conv_factor;
    si_prefix.centi   : conv_factor := 1.E-2 * conv_factor;
    si_prefix.milli   : conv_factor := 1.E-3 * conv_factor;
    si_prefix.micro   : conv_factor := 1.E-6 * conv_factor;
    si_prefix.nano    : conv_factor := 1.E-9 * conv_factor;
    si_prefix.pico    : conv_factor := 1.E-12 * conv_factor;
    si_prefix.femto   : conv_factor := 1.E-15 * conv_factor;
    si_prefix.atto    : conv_factor := 1.E-18 * conv_factor;
  END_CASE;

  result := angle_expr / conv_factor;
  RETURN (result);
END_FUNCTION;

FUNCTION convert_spatial_to_ypr_rotation (pair     : kinematic_pair;
                                          rotation : spatial_rotation)
                                                   : ypr_rotation;
  LOCAL
    axis       : direction;
    angle      : plane_angle_measure;   -- rotation angle in application
                                        -- specific units
    conv_angle : plane_angle_measure;   -- rotation angle in radians
    ya, pa, ra : plane_angle_measure;   -- yaw, pitch, and roll angle
    ucf        : REAL;                  -- unit conversion factor
    dx, dy, dz : REAL;                  -- components of direction vector
    s_a, c_a   : REAL;                  -- sine and cosine of rotation angle
    rotmat     : ARRAY [1 : 3] OF
                 ARRAY [1 : 3] OF REAL; -- rotation matrix
    cm1        : REAL;
    s_y, c_y   : REAL;
    s_r, c_r   : REAL;
  END_LOCAL;

  -- If rotation is already a ypr_rotation, return it immediately
  IF 'KINEMATIC_STRUCTURE_SCHEMA.YPR_ROTATION' IN TYPEOF (rotation) THEN
    RETURN (rotation);
  END_IF;

  -- rotation is a rotation_about_direction

  axis  := normalise (rotation\rotation_about_direction.direction_of_axis);
  angle := rotation\rotation_about_direction.rotation_angle;

  -- a zero rotation is converted trivially
  IF (angle = 0.0) THEN
    RETURN ([0.0, 0.0, 0.0]);
  END_IF;

  dx := axis.direction_ratios[1];
  dy := axis.direction_ratios[2];
  dz := axis.direction_ratios[3];

  -- provide angle measured in radian

  conv_angle := plane_angle_for_pair_in_radian (pair, angle);

  IF (conv_angle = ?) THEN
    RETURN (?);
  END_IF;

  ucf := angle / conv_angle;
  s_a := SIN (conv_angle);
  c_a := COS (conv_angle);

  -- axis parallel either to x-axis or to z-axis?
  IF (dy = 0.0) AND (dx * dz = 0.0) THEN
    REPEAT WHILE (conv_angle <= - PI);
      conv_angle := conv_angle + 2.0 * PI;
    END_REPEAT;
    REPEAT WHILE (conv_angle > PI);
      conv_angle := conv_angle - 2.0 * PI;
    END_REPEAT;

    ya := ucf * conv_angle;
    IF (conv_angle <> PI) THEN
      ra := - ya;
    ELSE
      ra := ya;
    END_IF;

    IF (dx <> 0.0) THEN
      -- axis parallel to x-axis - use x-axis as roll axis
      IF (dx > 0.0) THEN
        RETURN ([0.0, 0.0, ya]);
      ELSE
        RETURN ([0.0, 0.0, ra]);
      END_IF;
    ELSE
      -- axis parallel to z-axis - use z-axis as yaw axis
      IF (dz > 0.0) THEN
        RETURN ([ya, 0.0, 0.0]);
      ELSE
        RETURN ([ra, 0.0, 0.0]);
      END_IF;
    END_IF;
  END_IF;

  -- axis parallel to y-axis - use y-axis as pitch axis
  IF ((dy <> 0.0) AND (dx = 0.0) AND (dz = 0.0)) THEN
    IF (c_a >= 0.0) THEN
      ya := 0.0;
      ra := 0.0;
    ELSE
      ya := ucf * PI;
      ra := ya;
    END_IF;

    pa := ucf * ATAN (s_a, ABS (c_a));
    IF (dy < 0.0) THEN
      pa := - pa;
    END_IF;

    RETURN ([ya, pa, ra]);
  END_IF;

  -- axis not parallel to any axis of coordinate system
  -- compute rotation matrix

  cm1 := 1.0 - c_a;

  rotmat := [ [ dx * dx * cm1 + c_a,
                dx * dy * cm1 - dz * s_a,
                dx * dz * cm1 + dy * s_a ],
              [ dx * dy * cm1 + dz * s_a,
                dy * dy * cm1 + c_a,
                dy * dz * cm1 - dx * s_a ],
              [ dx * dz * cm1 - dy * s_a,
                dy * dz * cm1 + dx * s_a,
                dz * dz * cm1 + c_a ] ];

  -- rotmat[1][3] equals SIN (pitch_angle)
  IF (ABS (rotmat[1][3]) = 1.0) THEN
    -- |pa| = PI/2
    BEGIN
      IF (rotmat[1][3] = 1.0) THEN
        pa := 0.5 * PI;
      ELSE
        pa := -0.5 * PI;
      END_IF;

      -- In this case, only the sum or difference of roll and yaw angles
      -- is relevant and can be evaluated from the matrix.
      -- According to IP `rectangular pitch angle' for ypr_rotation,
      -- the roll angle is set to zero.

      ra := 0.0;
      ya := ATAN (rotmat[2][1], rotmat[2][2]);

      -- result of ATAN is in the range [-PI/2, PI/2].
      -- Here all four quadrants are needed.

      IF (rotmat[2][2] < 0.0) THEN
        IF ya <= 0.0 THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;
    END;
  ELSE
    -- COS (pitch_angle) not equal to zero
    BEGIN
      ya := ATAN (- rotmat[1][2], rotmat[1][1]);

      IF (rotmat[1][1] < 0.0) THEN
        IF (ya <= 0.0) THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;

      ra := ATAN (-rotmat[2][3], rotmat[3][3]);

      IF (rotmat[3][3] < 0.0) THEN
        IF (ra <= 0.0) THEN
          ra := ra + PI;
        ELSE
          ra := ra - PI;
        END_IF;
      END_IF;

      s_y := SIN (ya);
      c_y := COS (ya);
      s_r := SIN (ra);
      c_r := COS (ra);

      IF ((ABS (s_y) > ABS (c_y)) AND
          (ABS (s_y) > ABS (s_r)) AND
          (ABS (s_y) > ABS (c_r))) THEN
        cm1 := - rotmat[1][2] / s_y;
      ELSE
        IF ((ABS (c_y) > ABS (s_r)) AND (ABS (c_y) > ABS (c_r))) THEN
          cm1 := rotmat[1][1] / c_y;
        ELSE
          IF (ABS (s_r) > ABS (c_r)) THEN
            cm1 := - rotmat[2][3] / s_r;
          ELSE
            cm1 := rotmat[3][3] / c_r;
          END_IF;
        END_IF;
      END_IF;

      pa := ATAN (rotmat[1][3], cm1);

    END;
  END_IF;

  ya := ya * ucf;
  pa := pa * ucf;
  ra := ra * ucf;

  RETURN ([ya, pa, ra]);

END_FUNCTION;

FUNCTION assign_directed_link
   (joint : kinematic_joint; orientation : BOOLEAN ) : kinematic_link;
   IF (orientation) THEN
      RETURN (joint.first_link);
   ELSE
      RETURN (joint.second_link);
   END_IF;
END_FUNCTION;

FUNCTION connected_in_simple_loop
   (relation_1 : joint_logical_relationship;
    relation_2 : joint_logical_relationship) : BOOLEAN;
  LOCAL
    next_jlr_in_loop_set : SET [1:?] OF joint_logical_relationship;
  END_LOCAL;

  IF ((relation_1.loop:<>: relation_2.loop) OR
       (relation_1 :=: relation_2)) THEN
         RETURN (FALSE);
  ELSE
    IF (relation_1.next_joint_logical_structure :=:
        relation_2.previous_joint_logical_structure) THEN
       RETURN (TRUE);
    ELSE
      next_jlr_in_loop_set :=
          QUERY (relation <* 
           bag_to_set (USEDIN (relation_1.next_joint_logical_structure,
           'KINEMATIC_STRUCTURE_SCHEMA.JOINT_LOGICAL_RELATIONSHIP.' +
           'PREVIOUS_JOINT_LOGICAL_STRUCTURE'))
            | relation.loop :=: relation_1.loop);
      IF (SIZEOF(next_jlr_in_loop_set) <> 1) THEN
         RETURN (FALSE);
      ELSE
         RETURN (connected_in_simple_loop(next_jlr_in_loop_set [1],
                 relation_2));
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION;

END_SCHEMA;         -- end kinematic_structure_schema
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA location_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY location;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_location : location;
  related_location : location;
END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- location_schema

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  WG12N1826 - ISO 10303-57 logical_expressions_schema
*)

SCHEMA logical_expressions_schema; 

REFERENCE FROM iso13584_expressions_schema   -- ISO 13584-20
  (expression,
   variable); 

REFERENCE FROM iso13584_generic_expressions_schema   -- ISO 13584-20
  (binary_generic_expression,
   generic_expression,
   generic_literal,
   generic_variable,
   simple_generic_expression,
   unary_generic_expression); 

REFERENCE FROM iso13584_iec61360_dictionary_schema   -- ISO 13584-42
  (entity_instance_type); 


ENTITY binary_logical_expression
  SUPERTYPE OF (ONEOF (instance_equal,
                       logical_xor))
  SUBTYPE OF (binary_generic_expression, logical_expression);
END_ENTITY;

ENTITY default_boolean_literal
  SUBTYPE OF (logical_literal);
  SELF\logical_literal.the_value : BOOLEAN;
END_ENTITY;

ENTITY default_boolean_variable
  SUBTYPE OF (logical_variable);
END_ENTITY;

ENTITY defined_logical_comparison
  SUBTYPE OF (logical_comparison);
  declaration : STRING;
  description : STRING;
  encoding : OPTIONAL STRING;
END_ENTITY;

ENTITY instance_equal
  SUBTYPE OF (binary_logical_expression);
END_ENTITY;

ENTITY logical_and
  SUBTYPE OF (multiple_arity_logical_expression);
END_ENTITY;

ENTITY logical_comparison
  SUPERTYPE OF (ONEOF (defined_logical_comparison,
                       logical_equal,
                       logical_greater,
                       logical_greater_equal,
                       logical_less,
                       logical_less_equal,
                       logical_like,
                       logical_not_equal))
  SUBTYPE OF (logical_expression);
  specified_value : generic_literal;
  the_parameter : generic_variable;
END_ENTITY;

ENTITY logical_equal
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_expression
  SUPERTYPE OF (ONEOF (binary_logical_expression,
                       logical_comparison,
                       multiple_arity_logical_expression,
                       simple_logical_expression,
                       unary_logical_expression))
  SUBTYPE OF (expression);
END_ENTITY;

ENTITY logical_greater
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_greater_equal
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_less
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_less_equal
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_like
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_literal
  SUBTYPE OF (generic_literal, simple_logical_expression);
  the_value : LOGICAL;
END_ENTITY;

ENTITY logical_not
  SUBTYPE OF (unary_logical_expression);
END_ENTITY;

ENTITY logical_not_equal
  SUBTYPE OF (logical_comparison);
END_ENTITY;

ENTITY logical_or
  SUBTYPE OF (multiple_arity_logical_expression);
END_ENTITY;

ENTITY logical_variable
  SUBTYPE OF (simple_logical_expression, variable);
END_ENTITY;

ENTITY logical_xor
  SUBTYPE OF (binary_logical_expression);
END_ENTITY;

ENTITY multiple_arity_logical_expression
  SUPERTYPE OF (ONEOF (logical_and,
                       logical_or))
  SUBTYPE OF (logical_expression, multiple_arity_generic_expression);
END_ENTITY;

ENTITY simple_logical_expression
  SUBTYPE OF (logical_expression, simple_generic_expression);
END_ENTITY;

ENTITY unary_logical_expression
  SUBTYPE OF (logical_expression, unary_generic_expression);
END_ENTITY;

END_SCHEMA;  -- logical_expressions_schema
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA management_resources_schema;

REFERENCE FROM action_schema;    -- ISO 10303-41

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (library_context); 

REFERENCE FROM approval_schema;    -- ISO 10303-41

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_role,
   object_role,
   role_association); 

REFERENCE FROM certification_schema;    -- ISO 10303-41

REFERENCE FROM contract_schema;    -- ISO 10303-41

REFERENCE FROM date_time_schema;    -- ISO 10303-41

REFERENCE FROM document_schema;    -- ISO 10303-41

REFERENCE FROM effectivity_schema;    -- ISO 10303-41

REFERENCE FROM experience_schema;    -- ISO 10303-41

REFERENCE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

REFERENCE FROM group_schema;    -- ISO 10303-41

REFERENCE FROM location_schema;    -- ISO 10303-41

REFERENCE FROM person_organization_schema;    -- ISO 10303-41

REFERENCE FROM qualifications_schema;    -- ISO 10303-41

REFERENCE FROM security_classification_schema;    -- ISO 10303-41

REFERENCE FROM support_resource_schema;    -- ISO 10303-41


TYPE attribute_type = SELECT
   (label, 
    text);
END_TYPE; 

ENTITY action_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action : action;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_method : action_method;
  role : action_method_role;
END_ENTITY;

ENTITY action_method_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE ;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE ;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY certification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_class : group;
  role : classification_role;
END_ENTITY;

ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE ;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE ;
  assigned_date : date;
  role : date_role;
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE ;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE ;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_effectivity_assignment : effectivity_assignment;
  role : effectivity_context_role;
END_ENTITY;

ENTITY effectivity_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE ;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role : event_occurrence_context_role;
END_ENTITY;

ENTITY experience_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience : experience;
  role : experience_role;
END_ENTITY;

ENTITY experience_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_experience_type : experience_type;
  role : experience_type_role;
END_ENTITY;

ENTITY experience_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

ENTITY group_assignment
  ABSTRACT SUPERTYPE ;
  assigned_group : group;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;

ENTITY identification_assignment_relationship;
  name : label;
  description : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment : identification_assignment;
END_ENTITY;

ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY library_assignment
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY;

ENTITY location_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_location : location;
  role : location_role;
END_ENTITY;

ENTITY location_representation_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  represented_location : location;
  role : location_representation_role;
END_ENTITY;

ENTITY location_representation_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY name_assignment
  ABSTRACT SUPERTYPE ;
  assigned_name : label;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_organization_type : organization_type;
  role : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project_assignment
  ABSTRACT SUPERTYPE ;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;

ENTITY person_assignment
  ABSTRACT SUPERTYPE ;
  assigned_person : person;
  role : person_role;
END_ENTITY;

ENTITY person_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type : person_type;
  role : person_type_role;
END_ENTITY;

ENTITY person_type_definition_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_person_type_definition : person_type_definition;
  role : person_type_definition_role;
END_ENTITY;

ENTITY person_type_definition_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization : position_in_organization;
  role : position_in_organization_role;
END_ENTITY;

ENTITY position_in_organization_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_position_in_organization_type : position_in_organization_type;
  role : position_in_organization_type_role;
END_ENTITY;

ENTITY position_in_organization_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification : qualification;
  role : qualification_role;
END_ENTITY;

ENTITY qualification_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_assignment
  ABSTRACT SUPERTYPE ;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  assigned_qualification_type : qualification_type;
  role : qualification_type_role;
END_ENTITY;

ENTITY qualification_type_role;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE ;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role (SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY time_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time : local_time;
  role : time_role;
END_ENTITY;

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE ;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;

FUNCTION acyclic_identification_assignment_relationship
 (relation : identification_assignment_relationship; relatives : SET[1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);

END_FUNCTION; 

END_SCHEMA;  -- management_resources_schema



(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA material_property_definition_schema;

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY property_definition_relationship;
  name                       : label;
  description                 : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

ENTITY material_designation;
  name       : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class               : label;
  constituent_amount   : SET [1:?] OF measure_with_unit;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;

  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;

  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality

  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));

  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;

  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema
(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA material_property_representation_schema;

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY data_environment;
  name       : label;
  description : text;
  elements    : SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    : label;
  description              : text;
  relating_data_environment : data_environment;
  related_data_environment  : data_environment;
END_ENTITY;

END_SCHEMA;    -- material_property_representation_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $

From ISO TC184/SC4/WG12 N3251 - ISO/IS 10303-51 Mathematical representation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1001
*) 


SCHEMA mathematical_context_schema;

REFERENCE FROM action_schema   -- ISO 10303-41
  (action,
   action_method); 

REFERENCE FROM mathematical_functions_schema   -- ISO 10303-50
  (maths_space,
   maths_value); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (unit); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property,
   shape_aspect); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context,
   representation_item); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 

REFERENCE FROM ISO13584_generic_expressions_schema   -- ISO 13584-20
  (generic_expression); 


TYPE space_context_select = EXTENSIBLE SELECT
   (action, 
    action_method, 
    general_property, 
    product_definition, 
    representation_item, 
    shape_aspect);
END_TYPE; 

TYPE value_context_select = EXTENSIBLE SELECT
   (action, 
    action_method, 
    general_property, 
    product_definition, 
    representation_item, 
    shape_aspect);
END_TYPE; 

ENTITY compound_maths_space_context
  SUBTYPE OF (maths_space_context);
  components : LIST[2:?] OF maths_space_context;
END_ENTITY;

ENTITY defined_maths_space_context
  SUBTYPE OF (maths_space_context);
END_ENTITY;

ENTITY explicitly_enumerated_maths_space_context
  SUBTYPE OF (maths_space_context);
  members : SET[1:?] OF maths_value_context;
END_ENTITY;

ENTITY maths_space_context
  SUPERTYPE OF (ONEOF (compound_maths_space_context,
                       defined_maths_space_context,
                       explicitly_enumerated_maths_space_context));
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_space : maths_space;
  physical_space : space_context_select;
END_ENTITY;

ENTITY maths_value_context;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_value : maths_value;
  physical_value : value_context_select;
END_ENTITY;

ENTITY membership_of_maths_space_context;
  space_context : maths_space_context;
  value_context : maths_value_context;
END_ENTITY;

ENTITY normalized_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  normalization_basis : value_context_select;
END_ENTITY;

ENTITY representation_context_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  representation_basis : representation_context;
END_ENTITY;

ENTITY unit_defined_maths_space_context
  SUBTYPE OF (defined_maths_space_context);
  unit_basis : unit;
END_ENTITY;

END_SCHEMA;  -- mathematical_context_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
From ISO TC184/SC4/WG12 N3251 - ISO/IS 10303-51 Mathematical representation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1001
*) 


SCHEMA mathematical_description_of_distribution_schema;

REFERENCE FROM mathematical_context_schema   -- ISO 10303-51
  (maths_space_context); 

REFERENCE FROM mathematical_functions_schema   -- ISO 10303-50
  (maths_function); 

REFERENCE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   resource_property); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition,
   general_property_relationship); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


TYPE property_distribution_select = EXTENSIBLE SELECT
   (action_property, 
    general_property_relationship, 
    property_definition, 
    resource_property);
END_TYPE; 

ENTITY maths_space_context_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_context : maths_space_context;
  related_context : maths_space_context;
END_ENTITY;

ENTITY maths_space_context_relationship_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  described_relationship : maths_space_context_relationship;
  describing_relationship : maths_function;
END_ENTITY;

ENTITY normalized_property_distribution_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_function : maths_function;
  domain_context : maths_space_context;
  normalization_basis : property_distribution_select;
  physical_function : property_distribution_select;
END_ENTITY;

ENTITY property_distribution_description;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  abstract_function : maths_function;
  domain_context : maths_space_context;
  physical_function : property_distribution_select;
  range_context : maths_space_context;
END_ENTITY;

END_SCHEMA;  -- mathematical_description_of_distribution_schema
(* Genenerated from: ../../irs/wg12n921.exp *)

SCHEMA mathematical_functions_schema;
-- This file constitutes document WG12 N921
-- Master document: ISO 10303-50:2001
-- EXPRESS last modified: 2001-09-07

REFERENCE FROM ISO13584_generic_expressions_schema     -- ISO 13584-20
  (binary_generic_expression,
   environment,
   generic_expression,
   generic_literal,
   generic_variable,
   multiple_arity_generic_expression,
   simple_generic_expression,
   unary_generic_expression,
   variable_semantics);

REFERENCE FROM ISO13584_expressions_schema             -- ISO 13584-20
  (abs_function                   AS abs_expression,
   acos_function                  AS acos_expression,
   and_expression,
   asin_function                  AS asin_expression,
   atan_function                  AS atan_expression,
   binary_boolean_expression,
   binary_function_call           AS binary_numeric_call_expression,
   binary_numeric_expression,
   boolean_defined_function       AS boolean_defined_expression,
   boolean_expression,
   boolean_literal,
   boolean_variable,
   comparison_equal,
   comparison_expression,
   comparison_greater,
   comparison_greater_equal,
   comparison_less,
   comparison_less_equal,
   comparison_not_equal,
   concat_expression,
   cos_function                   AS cos_expression,
   defined_function               AS defined_expression,
   div_expression,
   equals_expression,
   exp_function                   AS exp_expression,
   expression,
   format_function                AS format_expression,
   index_expression,
   int_literal,
   int_numeric_variable,
   int_value_function             AS int_value_expression,
   integer_defined_function       AS integer_defined_expression,
   interval_expression,
   length_function                AS length_expression,
   like_expression,
   literal_number,
   log_function                   AS log_expression,
   log10_function                 AS log10_expression,
   log2_function                  AS log2_expression,
   maximum_function               AS maximum_expression,
   minimum_function               AS minimum_expression,
   minus_expression,
   minus_function                 AS unary_minus_expression,
   mod_expression,
   mult_expression,
   multiple_arity_boolean_expression,
   multiple_arity_function_call   AS multiple_arity_numeric_call_expression,
   multiple_arity_numeric_expression,
   not_expression,
   numeric_defined_function       AS numeric_defined_expression,
   numeric_expression,
   numeric_variable,
   odd_function                   AS odd_expression,
   or_expression,
   plus_expression,
   power_expression,
   real_defined_function          AS real_defined_expression,
   real_literal,
   real_numeric_variable,
   simple_boolean_expression,
   simple_numeric_expression,
   simple_string_expression,
   sin_function                   AS sin_expression,
   slash_expression,
   sql_mappable_defined_function  AS sql_mappable_defined_expression,
   square_root_function           AS square_root_expression,
   string_defined_function        AS string_defined_expression,
   string_expression,
   string_literal,
   string_variable,
   substring_expression,
   tan_function                   AS tan_expression,
   unary_boolean_expression,
   unary_function_call            AS unary_numeric_call_expression,
   unary_numeric_expression,
   value_function                 AS value_expression,
   variable,
   xor_expression);

REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (label,
   text);

REFERENCE FROM external_reference_schema               -- ISO 10303-41
  (externally_defined_item);

REFERENCE FROM geometry_schema                         -- ISO 10303-42
  (curve,
   dimension_of,
   point,
   surface,
   volume);

CONSTANT
  schema_prefix : STRING := 'MATHEMATICAL_FUNCTIONS_SCHEMA.';
  the_integers        : elementary_space := make_elementary_space(es_integers);
  the_reals           : elementary_space := make_elementary_space(es_reals);
  the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);
  the_numbers         : elementary_space := make_elementary_space(es_numbers);
  the_logicals        : elementary_space := make_elementary_space(es_logicals);
  the_booleans        : elementary_space := make_elementary_space(es_booleans);
  the_strings         : elementary_space := make_elementary_space(es_strings);
  the_binarys         : elementary_space := make_elementary_space(es_binarys);
  the_maths_spaces    : elementary_space := make_elementary_space(es_maths_spaces);
  the_generics        : elementary_space := make_elementary_space(es_generics);
  the_empty_space : finite_space := make_finite_space([]);
  the_nonnegative_reals         : real_interval_from_min :=
    make_real_interval_from_min(0.0, closed);
  the_zero_one_interval         : finite_real_interval := make_finite_real_interval(
    0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval := make_finite_real_interval(
    0.0, closed, pi, closed);
  the_neg1_one_interval         : finite_real_interval := make_finite_real_interval(
    -1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval := make_finite_real_interval(
    -0.5*pi, closed, 0.5*pi, closed);
  the_negpi_pi_interval         : finite_real_interval := make_finite_real_interval(
    -pi, open, pi, closed);
  the_zero_tuple_space : listed_product_space := make_listed_product_space([]);
  the_tuples           : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_generics);
  the_integer_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_integers);
  the_real_tuples      : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_reals);
  the_complex_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_complex_numbers);
  the_empty_maths_tuple      : maths_tuple := [];
  the_empty_maths_value      : maths_value := the_empty_maths_tuple;
  the_empty_atom_based_tuple : atom_based_tuple := [];
  the_empty_atom_based_value : atom_based_value := the_empty_atom_based_tuple;
END_CONSTANT;
TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;
TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;
TYPE zero_or_one = nonnegative_integer;
WHERE in_range: (SELF = 0) OR (SELF = 1);
END_TYPE;
TYPE one_or_two = positive_integer;
WHERE in_range: (SELF = 1) OR (SELF = 2);
END_TYPE;
TYPE maths_number = NUMBER;
END_TYPE;
TYPE maths_real = REAL;
END_TYPE;
TYPE maths_integer = INTEGER;
END_TYPE;
TYPE maths_logical = LOGICAL;
END_TYPE;
TYPE maths_boolean = BOOLEAN;
END_TYPE;
TYPE maths_string = STRING;
END_TYPE;
TYPE maths_binary = BINARY;
END_TYPE;

(* TYPE below fixed by David Leal 2003-12-18 *)

TYPE maths_simple_atom = SELECT
  (maths_number,
   maths_real,
   maths_integer,
   maths_logical,
   maths_boolean,
   maths_string,
   maths_binary);
END_TYPE;
TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;
TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;
TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;
TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;
TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;
TYPE maths_expression = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
END_TYPE;
TYPE maths_function_select = SELECT
  (maths_function,
   elementary_function_enumerators);
END_TYPE;
TYPE input_selector = positive_integer;
END_TYPE;
TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;
TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;
TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;
TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;
TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and, ef_or, ef_not, ef_xor,
   ef_negate_i, ef_add_i, ef_subtract_i, ef_multiply_i, ef_divide_i, ef_mod_i,
   ef_exponentiate_i, ef_eq_i, ef_ne_i, ef_gt_i, ef_lt_i, ef_ge_i, ef_le_i,
   ef_abs_i, ef_max_i, ef_min_i, ef_if_i,
   ef_negate_r, ef_reciprocal_r, ef_add_r, ef_subtract_r, ef_multiply_r,
   ef_divide_r, ef_mod_r, ef_exponentiate_r, ef_exponentiate_ri,
   ef_eq_r, ef_ne_r, ef_gt_r, ef_lt_r, ef_ge_r, ef_le_r, ef_abs_r,
   ef_max_r, ef_min_r, ef_acos_r, ef_asin_r, ef_atan2_r, ef_cos_r, ef_exp_r,
   ef_ln_r, ef_log2_r, ef_log10_r, ef_sin_r, ef_sqrt_r, ef_tan_r, ef_if_r,
   ef_form_c, ef_rpart_c, ef_ipart_c,
   ef_negate_c, ef_reciprocal_c, ef_add_c, ef_subtract_c, ef_multiply_c,
   ef_divide_c, ef_exponentiate_c, ef_exponentiate_ci, ef_eq_c, ef_ne_c,
   ef_conjugate_c, ef_abs_c, ef_arg_c, ef_cos_c, ef_exp_c, ef_ln_c, ef_sin_c,
   ef_sqrt_c, ef_tan_c, ef_if_c,
   ef_subscript_s, ef_eq_s, ef_ne_s, ef_gt_s, ef_lt_s, ef_ge_s, ef_le_s,
   ef_subsequence_s, ef_concat_s, ef_size_s, ef_format, ef_value, ef_like, ef_if_s,
   ef_subscript_b, ef_eq_b, ef_ne_b, ef_gt_b, ef_lt_b, ef_ge_b, ef_le_b,
   ef_subsequence_b, ef_concat_b, ef_size_b, ef_if_b,
   ef_subscript_t, ef_eq_t, ef_ne_t, ef_concat_t, ef_size_t,
   ef_entuple, ef_detuple, ef_insert, ef_remove, ef_if_t,
   ef_sum_it, ef_product_it,
   ef_add_it, ef_subtract_it, ef_scalar_mult_it, ef_dot_prod_it,
   ef_sum_rt, ef_product_rt,
   ef_add_rt, ef_subtract_rt, ef_scalar_mult_rt, ef_dot_prod_rt, ef_norm_rt,
   ef_sum_ct, ef_product_ct,
   ef_add_ct, ef_subtract_ct, ef_scalar_mult_ct, ef_dot_prod_ct, ef_norm_ct,
   ef_if, ef_ensemble, ef_member_of);
END_TYPE;
TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;
TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;
TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;
TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;
TYPE maths_enum_atom = SELECT
  (elementary_space_enumerators,
   ordering_type,
   lower_upper,
   symmetry_type,
   elementary_function_enumerators,
   open_closed,
   space_constraint_type,
   repackage_options,
   extension_options);
END_TYPE;
TYPE dotted_express_identifier = STRING;
WHERE syntax: dotted_identifiers_syntax(SELF);
END_TYPE;
TYPE express_identifier = dotted_express_identifier;
WHERE syntax: dot_count(SELF) = 0;
END_TYPE;
TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;
TYPE tuple_space = SELECT
  (product_space,
   extended_tuple_space);
END_TYPE;
TYPE maths_space_or_function = SELECT
  (maths_space,
   maths_function);
END_TYPE;
TYPE real_interval = SELECT
  (real_interval_from_min,
   real_interval_to_max,
   finite_real_interval,
   elementary_space);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR
    (SELF\elementary_space.space_id = es_reals);
END_TYPE;
ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;
ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;
ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;
ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;
ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;
ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;
ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF REAL;
END_ENTITY;
ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;
ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;
ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;
ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;
ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_reals);
END_ENTITY;
ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_integers);
END_ENTITY;
ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_booleans);
END_ENTITY;
ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_strings);
END_ENTITY;
ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1:?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression
    := [convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;
ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (elementary_space,
                                finite_integer_interval,
                                integer_interval_from_min,
                                integer_interval_to_max,
                                finite_real_interval,
                                real_interval_from_min,
                                real_interval_to_max,
                                cartesian_complex_number_region,
                                polar_complex_number_region,
                                finite_space,
                                uniform_product_space,
                                listed_product_space,
                                extended_tuple_space,
                                function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;
ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;
ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;
ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;
ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;
ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;
ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;
ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;
ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR
       min_exists(imag_constraint) OR max_exists(imag_constraint);
END_ENTITY;
ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0*PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open);
END_ENTITY;
ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF (member))
       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;
ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;
ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;
ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : product_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;
ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument  : maths_space;
  range_constraint : space_constraint_type;
  range_argument   : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND
       expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND
       (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT
       member_of(the_empty_space,domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT
       member_of(the_empty_space,range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint,domain_argument) AND
       any_space_satisfies(range_constraint,range_argument));
END_ENTITY;
ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF (finite_function,
                                constant_function,
                                selector_function,
                                elementary_function,
                                restriction_function,
                                repackaging_function,
                                reindexed_array_function,
                                series_composed_function,
                                parallel_composed_function,
                                explicit_table_function,
                                homogeneous_linear_function,
                                general_linear_function,
                                b_spline_basis,
                                b_spline_function,
                                rationalize_function,
                                partial_derivative_function,
                                definite_integral_function,
                                abstracted_expression_function,
                                expression_denoted_function,
                                imported_point_function,
                                imported_curve_function,
                                imported_surface_function,
                                imported_volume_function,
                                application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range : tuple_space := derive_function_range(SELF);
END_ENTITY;
ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;
ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;
ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;
ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack    : repackage_options;
  output_repack   : repackage_options;
  selected_output : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))));
  WR3: selected_output <= space_dimension( repackage(
       operand.range, output_repack));
END_ENTITY;
ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices : LIST [1:?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(
       SELF\unary_generic_expression.operand));
END_ENTITY;
ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;
ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain  : maths_space_or_function;
  prep_functions : LIST [1:?] OF maths_function;
  final_function : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of generic_expression
    := convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain),
       prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;
ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data,
                                listed_integer_data,
                                listed_logical_data,
                                listed_string_data,
                                listed_complex_number_data,
                                listed_data,
                                externally_listed_data,
                                linearized_table_function,
                                basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1:?] OF positive_integer;
END_ENTITY;
ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF REAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF INTEGER;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_logical_data
  SUBTYPE OF(explicit_table_function, generic_literal);
  values : LIST [1:?] OF LOGICAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF STRING;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2:?] OF REAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)/2];
WHERE
  WR1: NOT ODD (SIZEOF (values));
END_ENTITY;
ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1:?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF (QUERY (val <* values | NOT (member_of( val, value_range)))) = 0;
END_ENTITY;
ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;
ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF (standard_table_function,
                       regular_table_function,
                       triangular_matrix,
                       symmetric_matrix,
                       banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first  : integer;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source.domain);
END_ENTITY;
ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;
ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1:?] OF INTEGER;
WHERE
  WR1: SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape);
  WR2: extremal_position_check(self);
END_ENTITY;
ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;
ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;
ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] =
       SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = skew) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_numbers));
  WR4: NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_complex_numbers));
END_ENTITY;
ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : integer;
  above         : integer;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (self\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
  default_entry : maths_value;
  order : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;
ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2:?] OF REAL;
DERIVE
  order          : positive_integer := degree + 1;
  num_basis      : positive_integer := SIZEOF (repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis+1];
END_ENTITY;
ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis : LIST [1:?] OF b_spline_basis;
DERIVE
  coef  : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND
       (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF (basis) <=
       SIZEOF (shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;
ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;
ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables : LIST [1:?] OF input_selector;
  extension : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (derivand.range);
  WR2: partial_derivative_check (derivand.domain, d_variables);
END_ENTITY;
ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1:?] OF maths_variable;
  extension : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space (derivand);
  WR2: space_is_continuum (values_space_of (derivand));
  WR3: SIZEOF (QUERY (vbl <* d_variables | (NOT subspace_of (values_space_of (vbl),
    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))
    )) = 0;
END_ENTITY;
ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration : input_selector;
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (integrand.range);
  WR2: definite_integral_check (integrand.domain, variable_of_integration,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : generic_expression
    := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration : maths_variable
    := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable
    := [variable_of_integration];
WHERE
  WR1: has_values_space (integrand);
  WR2: space_is_continuum (values_space_of (integrand));
  WR3: definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable :=
    remove_first(SELF\multiple_arity_generic_expression.operands);
  expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF (QUERY ( operand <*
       SELF\multiple_arity_generic_expression.operands | NOT (
       has_values_space( operand)))) = 0;
END_ENTITY;
ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr));
END_ENTITY;
ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;
ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;
ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;
FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;
  CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) > 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    -- complex_number_literal, maths_space, or maths_function.
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
END_FUNCTION;  -- all_members_of_es
FUNCTION any_space_satisfies(sc  : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
END_FUNCTION;  -- any_space_satisfies
FUNCTION assoc_product_space(ts1, ts2 : tuple_space) : tuple_space;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender <> factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
END_FUNCTION;  -- assoc_product_space
FUNCTION atan2(y, x : REAL) : REAL;
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x < 0.0 THEN
    IF y < 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
END_FUNCTION;  -- atan2
FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- bool
FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base   : zero_or_one;
                                   shape  : LIST [1:?] OF positive_integer;
                                   order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
  -- The index function is evaluated at (base+shape[i]) when determining the
  -- upper search bound for entries of the last row or column, respectively.
END_FUNCTION;  -- check_sparse_index_domain;
FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base   : zero_or_one;
                                shape  : LIST [1:?] OF positive_integer;
                                order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) <> 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;  -- check_sparse_loc_range;
FUNCTION check_sparse_index_to_loc(index_range, loc_domain : tuple_space) : BOOLEAN;
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND
    (idx_rng_itvl.max <= loc_dmn_itvl.max+1)));
END_FUNCTION;  -- check_sparse_index_to_loc
FUNCTION compare_basis_and_coef(basis : LIST [1:?] OF b_spline_basis;
                                coef  : maths_function) : BOOLEAN;
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) < SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_basis_and_coef
FUNCTION compare_list_and_value(lv : LIST OF GENERIC:G;
                                op : elementary_function_enumerators;
                                v  : GENERIC:G) : BOOLEAN;
  IF NOT EXISTS (lv) OR NOT EXISTS (op) OR NOT EXISTS (v) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF (lv);
    IF NOT compare_values(lv[i], op, v) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_list_and_value
FUNCTION compare_values(v1 : GENERIC:G;
                        op : elementary_function_enumerators;
                        v2 : GENERIC:G) : BOOLEAN;
  -- This algorithm assumes a comparison between "incompatible" types will
  -- produce the indeterminate value (or UNKNOWN?).
  LOCAL
    logl : LOGICAL := UNKNOWN;
  END_LOCAL;
  IF NOT EXISTS (v1) OR NOT EXISTS (op) OR NOT EXISTS (v2) THEN
    RETURN (FALSE);
  END_IF;
  CASE op OF
  ef_eq_i : logl := (v1 = v2);
  ef_ne_i : logl := (v1 <> v2);
  ef_gt_i : logl := (v1 > v2);
  ef_lt_i : logl := (v1 < v2);
  ef_ge_i : logl := (v1 >= v2);
  ef_le_i : logl := (v1 <= v2);
  END_CASE;
  IF EXISTS (logl) THEN
    IF logl = TRUE THEN  RETURN (TRUE);  END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- compare_values
FUNCTION compatible_complex_number_regions(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
END_FUNCTION;  -- compatible_complex_number_regions
FUNCTION compatible_es_values(esval1, esval2 : elementary_space_enumerators) : BOOLEAN;
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
END_FUNCTION;  -- compatible_es_values
FUNCTION compatible_intervals(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- compatible_intervals
FUNCTION compatible_spaces(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n <> SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n > m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
END_FUNCTION;  -- compatible_spaces
FUNCTION composable_sequence(operands : LIST [2:?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- composable_sequence
FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_literal
FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
END_FUNCTION;  -- convert_to_maths_function
FUNCTION convert_to_maths_value(val : GENERIC:G) : maths_value;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- convert_to_maths_value
FUNCTION convert_to_operand(val : maths_value) : generic_expression;
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_operand
FUNCTION convert_to_operands(values : AGGREGATE OF maths_value)
                            : LIST OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands
FUNCTION convert_to_operands_prcmfn(srcdom  : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun  : maths_function_select)
                                   : LIST [2:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands_prcmfn
FUNCTION definite_integral_check(domain   : tuple_space;
                                 vrblint  : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k > dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_check
FUNCTION definite_integral_expr_check(operands : LIST [2:?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) <> nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_expr_check
FUNCTION derive_definite_integral_domain(igrl : definite_integral_function)
                                        : tuple_space;

  -- Internal utility function:
  FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx <= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx <= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix > 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix > 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;
END_FUNCTION;  -- derive_definite_integral_domain
FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators)
                                          : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_domain
FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators)
                                         : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_range
FUNCTION derive_finite_function_domain(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                      : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_domain
FUNCTION derive_finite_function_range(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                     : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_range
FUNCTION derive_function_domain(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_domain
FUNCTION derive_function_range(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_point_function.geometry))));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_curve_function.geometry))));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_surface_function.geometry))));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      dimension_of (func\imported_volume_function.geometry))));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_range
FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
END_FUNCTION;  -- domain_from
FUNCTION dot_count(str : STRING) : INTEGER;
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
END_FUNCTION;  -- dot_count
FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k <= LENGTH (str);
    IF (str[k] <> '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- dotted_identifiers_syntax
FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- drop_numeric_constraints
FUNCTION enclose_cregion_in_pregion(crgn   : cartesian_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z < real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin > a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax < a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax < r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin < 0.0) OR (rmin > r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc <= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc <= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc >= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc >= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc <= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc <= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc >= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc >= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc <= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc <= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc <= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc <= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc >= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc >= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc >= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc >= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_cregion_in_pregion
FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region)
                                   : cartesian_complex_number_region;
  PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a < aitv.min THEN
      -- a+2.0*PI > aitv.min automatically!
      IF a+2.0*PI < aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a < aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) >= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) <= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) >= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) <= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
END_FUNCTION;  -- enclose_pregion_in_cregion
FUNCTION enclose_pregion_in_pregion(prgn   : polar_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min < a < aitv.max} OR {aitv.min < a+2.0*PI < aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc > rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc > rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax < r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax < r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax < r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc >= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc <= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 < rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 < rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc >= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc > rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc > rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc > rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp < r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp < r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc > rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_pregion_in_pregion
FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_cregion_pregion
FUNCTION equal_maths_functions(fun1, fun2 : maths_function) : LOGICAL;
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_functions
FUNCTION equal_maths_spaces(spc1, spc2 : maths_space) : LOGICAL;
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt <> spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) <> SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR
        (fs2.domain_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) <>
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint <> fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR
        (fs2.range_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) <>
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_maths_spaces
FUNCTION equal_maths_values(val1, val2 : maths_value) : LOGICAL;
  FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) <> SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_values
FUNCTION es_subspace_of_es(es1, es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- es_subspace_of_es
FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
END_FUNCTION;  -- expression_is_constant
FUNCTION extract_factors(tspace : tuple_space;
                         m, n   : INTEGER) : tuple_space;
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
END_FUNCTION;  -- extract_factors
FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- extremal_position_check
FUNCTION factor1(tspace : tuple_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor1
FUNCTION factor_space(tspace : tuple_space;
                      idx    : positive_integer) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx <= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx <= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx <= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor_space
FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
END_FUNCTION;  -- free_variables_of
FUNCTION function_applicability(func      : maths_function_select;
                                arguments : LIST [1:?] OF maths_value) : BOOLEAN;
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) <> narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) > narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_applicability
FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_array
FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_table
FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) <> 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;  -- function_is_2d_table
FUNCTION function_is_array(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_array
FUNCTION function_is_table(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_table
FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- has_values_space
FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k    : positive_integer) : LIST OF maths_value;
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k <= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- list_selected_components
FUNCTION make_abstracted_expression_function(
                                    operands : LIST [2:?] OF generic_expression)
                                   : abstracted_expression_function;
  RETURN (abstracted_expression_function()
    || maths_function()
      || generic_expression()
    || quantifier_expression (remove_first (operands))  -- derived
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_abstracted_expression_function
FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_atom_based_literal
FUNCTION make_b_spline_basis(degree         : nonnegative_integer;
                             repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
  RETURN (b_spline_basis (degree, repeated_knots)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_b_spline_basis
FUNCTION make_b_spline_function(coef  : maths_function;
                                bases : LIST [1:?] OF b_spline_basis)
                               : b_spline_function;
  RETURN (b_spline_function (bases)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (coef) );
END_FUNCTION;  -- make_b_spline_function
FUNCTION make_banded_matrix(index_base    : zero_or_one;
                            shape         : LIST [1:?] OF positive_integer;
                            source        : maths_function;
                            first         : INTEGER;
                            default_entry : maths_value;
                            below         : INTEGER;
                            above         : INTEGER;
                            order         : ordering_type) : banded_matrix;
  RETURN (banded_matrix (default_entry, below, above, order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (source) );
END_FUNCTION;  -- make_banded_matrix
FUNCTION make_basic_sparse_matrix(index_base    : zero_or_one;
                                  shape         : LIST [1:?] OF positive_integer;
                                  operands      : LIST [3:3] OF maths_function;
                                  default_entry : maths_value;
                                  order         : ordering_type)
                                 : basic_sparse_matrix;
  RETURN (basic_sparse_matrix (default_entry, order)
    || explicit_table_function (index_base, shape)
      || maths_function()
        || generic_expression()
    || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_basic_sparse_matrix
FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_binary_literal
FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_boolean_literal
FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval)
                                             : cartesian_complex_number_region;
  RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_cartesian_complex_number_region
FUNCTION make_complex_number_literal(rpart, ipart : REAL) : complex_number_literal;
  RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_complex_number_literal
FUNCTION make_constant_function(sole_value   : maths_value;
                                src_of_domn  : maths_space_or_function)
                               : constant_function;
  RETURN (constant_function (sole_value, src_of_domn)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_constant_function
FUNCTION make_cos_expression(operand : numeric_expression) : cos_expression;
  RETURN (cos_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_cos_expression
FUNCTION make_definite_integral_expression(
                                   operands     : LIST [2:4] OF generic_expression;
                                   loinf, upinf : BOOLEAN)
                                          : definite_integral_expression;
  RETURN (definite_integral_expression (loinf, upinf)
    || quantifier_expression ([operands[2]])
      || multiple_arity_generic_expression (operands)
        || generic_expression() );
END_FUNCTION;  -- make_definite_integral_expression
FUNCTION make_definite_integral_function(integrand    : maths_function;
                                         varintg      : input_selector;
                                         loinf, upinf : BOOLEAN)
                                        : definite_integral_function;
  RETURN (definite_integral_function (varintg, loinf, upinf)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (integrand) );
END_FUNCTION;  -- make_definite_integral_function
FUNCTION make_elementary_function(func_id : elementary_function_enumerators)
                                 : elementary_function;
  RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_function
FUNCTION make_elementary_space(space_id : elementary_space_enumerators)
                              : elementary_space;
  RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_space
FUNCTION make_environment(varbl : generic_variable;
                          sem   : variable_semantics) : environment;
  RETURN (environment (varbl, sem) );
END_FUNCTION;  -- make_environment
FUNCTION make_expression_denoted_function(expression : generic_expression)
                                         : expression_denoted_function;
  RETURN (expression_denoted_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (expression) );
END_FUNCTION;  -- make_expression_denoted_function
FUNCTION make_extended_tuple_space(base     : product_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
END_FUNCTION;  -- make_extended_tuple_space
FUNCTION make_finite_function(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                             : finite_function;
  RETURN (finite_function (pairs)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_function
FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_integer_interval
FUNCTION make_finite_real_interval(min    : REAL;
                                   minclo : open_closed;
                                   max    : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_real_interval
FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_space
FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1:?] OF maths_value)
                                  : function_application;
  RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
END_FUNCTION;  -- make_function_application
FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument   : maths_space;
                             range_constraint  : space_constraint_type;
                             range_argument    : maths_space) : function_space;
  RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_function_space
FUNCTION make_general_linear_function(mat       : maths_function;
                                      sum_index : one_or_two)
                                     : general_linear_function;
  RETURN (general_linear_function (sum_index)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (mat) );
END_FUNCTION;  -- make_general_linear_function
FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_int_literal
FUNCTION make_integer_interval_from_min(min : INTEGER)
  : integer_interval_from_min;
  RETURN (integer_interval_from_min (min)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_integer_interval_from_min
FUNCTION make_listed_complex_number_data(index_base : zero_or_one;
                                         values     : LIST [2:?] OF REAL)
                                        : listed_complex_number_data;
  RETURN (listed_complex_number_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)/2])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_complex_number_data
FUNCTION make_listed_data(index_base  : zero_or_one;
                          values      : LIST [2:?] OF maths_value;
                          value_range : maths_space) : listed_data;
  RETURN (listed_data (values, value_range)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_data
FUNCTION make_listed_integer_data(index_base : zero_or_one;
                                  values     : LIST [1:?] OF INTEGER)
                                 : listed_integer_data;
  RETURN (listed_integer_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_integer_data
FUNCTION make_listed_product_space(factors : LIST OF maths_space)
                                  : listed_product_space;
  RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_product_space
FUNCTION make_listed_real_data(index_base : zero_or_one;
                               values     : LIST [1:?] OF REAL)
                              : listed_real_data;
  RETURN (listed_real_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_real_data
FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_logical_literal
FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_enum_literal
FUNCTION make_maths_real_variable(values_space : maths_space;
                                  name         : label) : maths_real_variable;
  RETURN (maths_real_variable()
    || maths_variable (values_space, name)
      || generic_variable()
        || simple_generic_expression()
          || generic_expression()
    || real_numeric_variable()
      || numeric_variable()
        || variable() );
END_FUNCTION;  -- make_maths_real_variable
FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value)
                                 : maths_tuple_literal;
  RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_tuple_literal
FUNCTION make_mult_expression(operands : LIST [2:?] OF generic_expression)
                             : mult_expression;
  RETURN (mult_expression()
    || multiple_arity_numeric_expression()
      || numeric_expression()
        || expression()
          || generic_expression()
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_mult_expression
FUNCTION make_parallel_composed_function(srcdom    : maths_space_or_function;
                                         prepfuncs : LIST [2:?] OF maths_function;
                                         finfunc   : maths_function_select)
                                        : parallel_composed_function;
  RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );  -- derived
END_FUNCTION;  -- make_parallel_composed_function
FUNCTION make_partial_derivative_expression(derivand : generic_expression;
                                            dvars    : LIST [1:?] OF maths_variable;
                                            extend   : extension_options)
                                           : partial_derivative_expression;
  RETURN (partial_derivative_expression (dvars, extend)
    || unary_generic_expression (derivand)
      || generic_expression() );
END_FUNCTION;  -- make_partial_derivative_expression
FUNCTION make_partial_derivative_function(derivand : maths_function;
                                          dvars    : LIST [1:?] OF input_selector;
                                          extend   : extension_options)
                                         : partial_derivative_function;
  RETURN (partial_derivative_function (dvars, extend)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (derivand) );
END_FUNCTION;  -- make_partial_derivative_function
FUNCTION make_polar_complex_number_region(centre         : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval)
                                         : polar_complex_number_region;
  RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_polar_complex_number_region
FUNCTION make_rationalize_function(fun : maths_function) : rationalize_function;
  RETURN (rationalize_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (fun) );
END_FUNCTION;  -- make_rationalize_function
FUNCTION make_real_interval_from_min(min    : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_from_min
FUNCTION make_real_interval_to_max(max    : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_to_max
FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_real_literal
FUNCTION make_regular_table_function(index_base : zero_or_one;
                                     shape      : LIST [1:?] OF positive_integer;
                                     operand    : maths_function;
                                     first      : INTEGER;
                                     increments : LIST [1:?] OF INTEGER)
                                    : regular_table_function;
  RETURN (regular_table_function (increments)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_regular_table_function
FUNCTION make_reindexed_array_function(func       : maths_function;
                                       start_idxs : LIST [1:?] OF INTEGER)
                                      : reindexed_array_function;
  RETURN (reindexed_array_function(start_idxs)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (func) );
END_FUNCTION;  -- make_reindexed_array_function
FUNCTION make_repackaging_function(operand         : maths_function;
                                   input_repack    : repackage_options;
                                   output_repack   : repackage_options;
                                   selected_output : nonnegative_integer)
                                  : repackaging_function;
  RETURN (repackaging_function (input_repack, output_repack, selected_output)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (operand) );
END_FUNCTION;  -- make_repackaging_function
FUNCTION make_selector_function(selector    : input_selector;
                                src_of_domn : maths_space_or_function)
                               : selector_function;
  RETURN (selector_function (selector, src_of_domn)
    || maths_function()
       || generic_expression()
    || generic_literal()
       || simple_generic_expression() );
END_FUNCTION;  -- make_selector_function
FUNCTION make_series_composed_function(functions : LIST [2:?] OF maths_function)
                                      : series_composed_function;
  RETURN (series_composed_function()
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (functions) );
END_FUNCTION;  -- make_series_composed_function
FUNCTION make_sin_expression(operand : numeric_expression) : sin_expression;
  RETURN (sin_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_sin_expression
FUNCTION make_standard_table_function(index_base : zero_or_one;
                                      shape      : LIST [1:?] OF positive_integer;
                                      operand    : maths_function;
                                      first      : INTEGER;
                                      order      : ordering_type)
                                     : standard_table_function;
  RETURN (standard_table_function (order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_standard_table_function
FUNCTION make_strict_triangular_matrix(index_base    : zero_or_one;
                                       shape         : LIST [1:?] OF positive_integer;
                                       source        : maths_function;
                                       first         : INTEGER;
                                       default_entry : maths_value;
                                       lo_up         : lower_upper;
                                       order         : ordering_type;
                                       main_diagonal_value : maths_value)
                                      : strict_triangular_matrix;
  RETURN (strict_triangular_matrix (main_diagonal_value)
    || triangular_matrix (default_entry, lo_up, order)
      || linearized_table_function (first)
        || explicit_table_function (index_base, shape)
          || maths_function()
            || generic_expression()
        || unary_generic_expression (source) );
END_FUNCTION;  -- make_strict_triangular_matrix
FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_string_literal
FUNCTION make_unary_minus_expression(operand : numeric_expression)
  : unary_minus_expression;
  RETURN (unary_minus_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_unary_minus_expression
FUNCTION make_uniform_product_space(base     : maths_space;
                                    exponent : positive_integer)
                                   : uniform_product_space;
  RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_uniform_product_space
FUNCTION max_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;  -- max_exists
FUNCTION max_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- max_included
FUNCTION member_of(val : GENERIC:G;
                   spc : maths_space) : LOGICAL;

  -- Trivial function introduced to avoid NIST Fedex compiler error
  FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min <= tmp_int <=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min <= tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min <= tmp_real <
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min < tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min < tmp_real <
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min < tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real < s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) >= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- member_of
FUNCTION min_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;  -- min_exists
FUNCTION min_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- min_included
FUNCTION no_cyclic_domain_reference(ref  : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_domain_reference
FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_space_reference
FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] < lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
END_FUNCTION;  -- number_superspace_of
FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN (make_uniform_product_space (spc, 1));
END_FUNCTION;  -- one_tuples_of
FUNCTION parallel_composed_function_composability_check(
                                      funcs  : LIST OF maths_function;
                                      final  : maths_function_select) : BOOLEAN;
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
END_FUNCTION;  -- parallel_composed_function_composability_check
FUNCTION parallel_composed_function_domain_check(
                                comdom : tuple_space;
                                funcs  : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- parallel_composed_function_domain_check
FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i <= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k > LENGTH (s)) OR
        ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
END_FUNCTION;  -- parse_express_identifier
FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k > dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- partial_derivative_check
FUNCTION real_max(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_max
FUNCTION real_min(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_min
FUNCTION regular_indexing(sub   : LIST OF INTEGER;
                          base  : zero_or_one;
                          shape : LIST [1:?] OF positive_integer;
                          inc   : LIST [1:?] OF INTEGER;
                          first : INTEGER) : INTEGER;
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) <> SIZEOF (inc)) OR (SIZEOF (sub) <> SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
END_FUNCTION;
FUNCTION remove_first(alist : LIST OF GENERIC:GEN) : LIST OF GENERIC:GEN;
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) > 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
END_FUNCTION;  -- remove_first
FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- repackage
FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- shape_of_array
FUNCTION simplify_function_application(expr : function_application) : maths_value;
  FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) >= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) >= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) >= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k < 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <> k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j > k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j < k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j >= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k > j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k < j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t < 0.0) AND (j <> t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k < 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <> s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r > s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r < s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r >= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s > r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s < r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q <> 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p <> 1.0) OR (q <> 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k < 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p <> r) OR (q <> s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <> st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str > st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str < st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str >= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str <> '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str <> '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <> bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin > bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin < bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin >= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) <> 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) <> 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- simplify_function_application
FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
  FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  -- restore_unary
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  -- restore_binary
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  -- restore_mulary
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  -- make_number_literal;
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  -- No simpler expression available
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 > v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 >= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 < v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 <= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 <> v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) > 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) > 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) > 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb < vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb > vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);
END_FUNCTION;  -- simplify_generic_expression
FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin THEN
            zmin := zint;
          END_IF;
          IF zint > zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- simplify_maths_space
FUNCTION simplify_maths_value(val : maths_value) : maths_value;
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
END_FUNCTION;  -- simplify_maths_value
FUNCTION singleton_member_of(spc : maths_space) : maths_value;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- singleton_member_of
FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- space_dimension
FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_continuum
FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_singleton
FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
END_FUNCTION;  -- stripped_typeof
FUNCTION subspace_of(space1, space2 : maths_space) : LOGICAL;
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min>=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max > PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) >= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n < space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of
FUNCTION subspace_of_es(spc : maths_space;
                        es  : elementary_space_enumerators) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of_es
FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1:?] OF generic_variable;
                    vals : LIST [1:?] OF maths_value) : generic_expression;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) <> SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- substitute
FUNCTION values_space_of(expr : generic_expression) : maths_space;
  LOCAL
    e_prefix : STRING := 'ISO13584_EXPRESSIONS_SCHEMA.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);  -- not recognized as a mathematical expression
END_FUNCTION;  -- values_space_of
END_SCHEMA;  -- mathematical_functions_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA measure_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_name_value,
   name_attribute); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context); 

REFERENCE FROM support_resource_schema;    -- ISO 10303-41


TYPE amount_of_substance_measure = REAL;
END_TYPE; 

TYPE area_measure = REAL;
END_TYPE; 

TYPE celsius_temperature_measure = REAL;
END_TYPE; 

TYPE context_dependent_measure = REAL;
END_TYPE; 

TYPE count_measure = NUMBER;
END_TYPE; 

TYPE descriptive_measure = STRING;
END_TYPE; 

TYPE electric_current_measure = REAL;
END_TYPE; 

TYPE length_measure = REAL;
END_TYPE; 

TYPE luminous_intensity_measure = REAL;
END_TYPE; 

TYPE mass_measure = REAL;
END_TYPE; 

TYPE measure_value = SELECT
   (amount_of_substance_measure, 
    area_measure, 
    celsius_temperature_measure, 
    context_dependent_measure, 
    count_measure, 
    descriptive_measure, 
    electric_current_measure, 
    length_measure, 
    luminous_intensity_measure, 
    mass_measure, 
    numeric_measure, 
    parameter_value, 
    plane_angle_measure, 
    positive_length_measure, 
    positive_plane_angle_measure, 
    positive_ratio_measure, 
    ratio_measure, 
    solid_angle_measure, 
    thermodynamic_temperature_measure, 
    time_measure, 
    volume_measure);
END_TYPE; 

TYPE numeric_measure = NUMBER;
END_TYPE; 

TYPE parameter_value = REAL;
END_TYPE; 

TYPE plane_angle_measure = REAL;
END_TYPE; 

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE; 

TYPE ratio_measure = REAL;
END_TYPE; 

TYPE si_prefix = ENUMERATION OF 
   (exa,
    peta,
    tera,
    giga,
    mega,
    kilo,
    hecto,
    deca,
    deci,
    centi,
    milli,
    micro,
    nano,
    pico,
    femto,
    atto);
END_TYPE; 

TYPE si_unit_name = ENUMERATION OF 
   (metre,
    gram,
    second,
    ampere,
    kelvin,
    mole,
    candela,
    radian,
    steradian,
    hertz,
    newton,
    pascal,
    joule,
    watt,
    coulomb,
    volt,
    farad,
    ohm,
    siemens,
    weber,
    tesla,
    henry,
    degree_Celsius,
    lumen,
    lux,
    becquerel,
    gray,
    sievert);
END_TYPE; 

TYPE solid_angle_measure = REAL;
END_TYPE; 

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; 

TYPE time_measure = REAL;
END_TYPE; 

TYPE unit = SELECT
   (derived_unit, 
    named_unit);
END_TYPE; 

TYPE volume_measure = REAL;
END_TYPE; 

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;

ENTITY derived_unit;
  elements : SET[1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET[1:?] OF unit;
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit,
                       mass_measure_with_unit,
                       time_measure_with_unit,
                       electric_current_measure_with_unit,
                       thermodynamic_temperature_measure_with_unit,
                       celsius_temperature_measure_with_unit,
                       amount_of_substance_measure_with_unit,
                       luminous_intensity_measure_with_unit,
                       plane_angle_measure_with_unit,
                       solid_angle_measure_with_unit,
                       area_measure_with_unit,
                       volume_measure_with_unit,
                       ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
WHERE
  WR1: valid_units (SELF);
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit,
                       conversion_based_unit,
                       context_dependent_unit)
               ANDOR ONEOF (length_unit,
                    mass_unit,
                    time_unit,
                    electric_current_unit,
                    thermodynamic_temperature_unit,
                    amount_of_substance_unit,
                    luminous_intensity_unit,
                    plane_angle_unit,
                    solid_angle_unit,
                    area_unit,
                    volume_unit,
                    ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY;

FUNCTION derive_dimensional_exponents
 (x : unit) : dimensional_exponents; 
  LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION; 

FUNCTION dimensions_for_si_unit
 (n : si_unit_name) : dimensional_exponents; 
 CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;
END_FUNCTION; 

FUNCTION valid_units
 (m : measure_with_unit) : BOOLEAN; 
 IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) <>
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- measure_schema


(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA method_definition_schema;

REFERENCE FROM action_schema
    (action_method, 
     action_method_relationship, 
     action_relationship);

REFERENCE FROM document_schema
    (document, 
     document_usage_constraint);

REFERENCE FROM effectivity_schema
    (effectivity);

REFERENCE FROM measure_schema
    (count_measure);

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM process_property_schema
    (product_definition_process,
     property_process);

TYPE relationship_with_condition = SELECT
  (action_method_relationship,
   action_relationship,
   context_dependent_action_method_relationship,
   context_dependent_action_relationship);
END_TYPE;

TYPE process_or_process_relationship = SELECT
  (product_definition_process,
   property_process,
   relationship_with_condition);
END_TYPE;

ENTITY action_method_with_associated_documents
  SUBTYPE OF (action_method);
  documents : SET [1:?] of document;
END_ENTITY;

ENTITY action_method_with_associated_documents_constrained
  SUBTYPE OF (action_method_with_associated_documents);
  usage_constraints : SET [1:?] OF document_usage_constraint;
WHERE
  WR1: SIZEOF (QUERY (item <* usage_constraints | 
       NOT (item.source 
       IN SELF\action_method_with_associated_documents.documents))) = 0;
END_ENTITY;

ENTITY action_method_to_select_from
  SUBTYPE OF (action_method);
  number_of_elements : count_measure;
WHERE
  WR1: number_of_elements >=1;
  WR2: SIZEOF (USEDIN (SELF, 
       'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.RELATING_METHOD')) >= 
       number_of_elements;
END_ENTITY;

ENTITY process_or_process_relationship_effectivity
  SUBTYPE OF (effectivity);
  effective_process_or_process_relationship : process_or_process_relationship;
END_ENTITY;

ENTITY serial_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY sequential_method
  SUBTYPE OF (serial_action_method);
  sequence_position : count_measure;
END_ENTITY;

ENTITY concurrent_action_method
  SUBTYPE OF (action_method_relationship);
END_ENTITY;

ENTITY context_dependent_action_method_relationship;
  name                  : label;
  relating_relationship : action_method_relationship;
  related_relationship  : action_method_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_method :=:
       related_relationship.relating_method;
END_ENTITY;

ENTITY context_dependent_action_relationship;
  name                  : label;
  relating_relationship : action_relationship;
  related_relationship  : action_relationship;
UNIQUE
  UR1: relating_relationship, related_relationship;
WHERE
  WR1: relating_relationship.relating_action :=:
       related_relationship.relating_action;
END_ENTITY;

ENTITY relationship_condition;
  name                     : label;
  applicable_relationships : SET [1:?] OF relationship_with_condition;
  condition_description    : text;
END_ENTITY;

END_SCHEMA;  -- method_definition_schema
SCHEMA nut_and_bolt_1_schema; 


TYPE select_space_or_element = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY drift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

ENTITY generic_symmetry;
  applies_to : LIST[0:?] OF select_space_or_element;
END_ENTITY;

ENTITY generic_symmetry_relationship;
  related : generic_symmetry;
  relating : generic_symmetry;
END_ENTITY;

ENTITY lift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

ENTITY rift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

ENTITY shift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

END_SCHEMA;  -- nut_and_bolt_1_schema
SCHEMA nut_and_bolt_2_schema; 

USE FROM nut_and_bolt_1_schema;    -- ISO 10303-88


TYPE applied_symmetry_select = SELECT BASED_ON select_space_or_element WITH 
   (gift, 
    grift, 
    sift);
END_TYPE; 

ENTITY gift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

ENTITY grift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

ENTITY sift
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

END_SCHEMA;  -- nut_and_bolt_2_schema
SCHEMA nut_and_bolt_3_schema; 

USE FROM nut_and_bolt_1_schema;    -- ISO 10303-88


ENTITY quote
  SUBTYPE OF (generic_symmetry);
END_ENTITY;

END_SCHEMA;  -- nut_and_bolt_3_schema          
        
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA person_organization_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_id_value,
   get_name_value,
   get_role,
   id_attribute,
   name_attribute,
   object_role,
   role_association); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE person_organization_select = SELECT
   (organization, 
    person, 
    person_and_organization);
END_TYPE; 

ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_organization_type : organization_type;
  related_organization_type : organization_type;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET[1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET[1:?] OF organization;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;

ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL LIST[1:?] OF label;
  prefix_titles : OPTIONAL LIST[1:?] OF label;
  suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value (SELF);
  description : text := get_description_value(SELF);
  
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_definition;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  formation : person_type_definition_formation;
END_ENTITY;

ENTITY person_type_definition_formation;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  of_person_type : person_type;
END_ENTITY;

ENTITY person_type_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition : person_type_definition;
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people : SET[1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization : position_in_organization;
END_ENTITY;

ENTITY position_in_organization_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_organization_type_relationship
 (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

FUNCTION acyclic_person_type_definition_relationship
 (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_position_in_organization_relationship
 (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING) : BOOLEAN; 
   LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

END_SCHEMA;  -- person_organization_schema
SCHEMA presentation_appearance_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     cartesian_point,
     curve,
     geometric_representation_item,
     point,
     vector);

REFERENCE FROM group_schema
  (group);

REFERENCE FROM measure_schema
    (descriptive_measure,
     length_measure,
     measure_with_unit,
     plane_angle_measure,
     positive_length_measure,
     ratio_measure,
     positive_ratio_measure);

REFERENCE FROM presentation_organization_schema
     (area_dependent_annotation_representation,
      presentation_area,
      presentation_layer_assignment,
      presentation_layer_usage,
      presentation_representation,
      presentation_set,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation);

REFERENCE FROM presentation_definition_schema
    (annotation_curve_occurrence,
     annotation_fill_area,
     annotation_symbol_occurrence,
     annotation_text_with_delineation,
     symbol_representation_with_blanking_box);

REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol_outline,
     character_glyph_symbol_stroke,
     colour);

REFERENCE FROM representation_schema
    (mapped_item,
     representation,
     representation_item,
     representation_map,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     bag_to_set);
 

TYPE style_context_select = SELECT
  (group,
   presentation_layer_assignment,
   representation,
   representation_item,
   presentation_set);
END_TYPE;

TYPE presentation_style_select = SELECT
  (pre_defined_presentation_style,
   point_style,
   curve_style,
   surface_style_usage,
   symbol_style,
   fill_area_style,
   text_style,
   approximation_tolerance,
   externally_defined_style,
   null_style);
END_TYPE;

TYPE null_style = ENUMERATION OF
  (null);
END_TYPE;

TYPE marker_select = SELECT
  (marker_type,
   pre_defined_marker);
END_TYPE;

TYPE marker_type = ENUMERATION OF
  (dot,
   x,
   plus,
   asterisk,
   ring,
   square,
   triangle);
END_TYPE;

TYPE size_select  = SELECT
  (positive_length_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_size);
END_TYPE;

TYPE curve_font_or_scaled_curve_font_select = SELECT
  (curve_style_font_select,
   curve_style_font_and_scaling);
END_TYPE;

TYPE curve_style_font_select = SELECT
  (curve_style_font,
   pre_defined_curve_font,
   externally_defined_curve_font);
END_TYPE;

TYPE squared_or_rounded = ENUMERATION OF
  (squared,
   rounded);
END_TYPE;

TYPE fill_style_select = SELECT
  (fill_area_style_colour,
   pre_defined_tile_style,
   externally_defined_tile_style,
   fill_area_style_tiles,
   pre_defined_hatch_style,
   externally_defined_hatch_style,
   fill_area_style_hatching);
END_TYPE;

TYPE fill_area_style_tile_shape_select = SELECT
  (fill_area_style_tile_curve_with_style,
   fill_area_style_tile_coloured_region,
   fill_area_style_tile_symbol_with_style,
   pre_defined_tile,
   externally_defined_tile);
END_TYPE;

TYPE curve_or_annotation_curve_occurrence = SELECT
  (curve,
   annotation_curve_occurrence);
END_TYPE;

TYPE surface_side = ENUMERATION OF
  (positive,
   negative,
   both);
END_TYPE;

TYPE surface_side_style_select = SELECT
  (surface_side_style,
   pre_defined_surface_side_style);
END_TYPE;

TYPE surface_style_element_select = SELECT
  (surface_style_fill_area,
   surface_style_boundary,
   surface_style_silhouette,
   surface_style_segmentation_curve,
   surface_style_control_grid,
   surface_style_parameter_line,
   surface_style_rendering);
END_TYPE;

TYPE curve_or_render = SELECT
  (curve_style,
   curve_style_rendering);
END_TYPE;

TYPE shading_curve_method = ENUMERATION OF
  (constant_colour,
   linear_colour);
END_TYPE;

TYPE direction_count_select = SELECT
  (u_direction_count,
   v_direction_count);
END_TYPE;

TYPE u_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE v_direction_count = INTEGER;
WHERE
  WR1: SELF > 1;
END_TYPE;

TYPE shading_surface_method = ENUMERATION OF
  (constant_shading,
   colour_shading,
   dot_shading,
   normal_shading);
END_TYPE;

TYPE rendering_properties_select = SELECT
  (surface_style_reflectance_ambient,
   surface_style_transparent);
END_TYPE;

TYPE character_style_select = SELECT
  (character_glyph_style_stroke,
   character_glyph_style_outline,
   text_style_for_defined_font);
END_TYPE;

TYPE text_justification = label;
END_TYPE;

TYPE box_characteristic_select = SELECT
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle);
END_TYPE;

TYPE box_height = positive_ratio_measure;
END_TYPE;

TYPE box_width = positive_ratio_measure;
END_TYPE;

TYPE  box_slant_angle = plane_angle_measure;
END_TYPE;

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE;

TYPE character_spacing_select = SELECT
  (length_measure,
   ratio_measure,
   measure_with_unit,
   descriptive_measure,
   pre_defined_character_spacing);
END_TYPE;

TYPE symbol_style_select= SELECT
  (symbol_element_style,
   symbol_colour);
END_TYPE;

TYPE tolerance_select = SELECT
  (approximation_tolerance_deviation,
   approximation_tolerance_parameter);
END_TYPE;

TYPE approximation_method = ENUMERATION OF
  (chordal_deviation,
   chordal_length);
END_TYPE;

TYPE tolerance_deviation_select = SELECT
  (curve_tolerance_deviation,
   surface_tolerance_deviation);
END_TYPE;

TYPE curve_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE surface_tolerance_deviation = positive_length_measure;
END_TYPE;

TYPE product_or_presentation_space = ENUMERATION OF
  (product_shape_space,
   presentation_area_space);
END_TYPE;

TYPE tolerance_parameter_select = SELECT
  (curve_tolerance_parameter,
   surface_tolerance_parameter);
END_TYPE;

TYPE curve_tolerance_parameter = REAL;
END_TYPE;

TYPE surface_tolerance_parameter = REAL;
END_TYPE;

TYPE hiding_or_blanking_select = SELECT
  (presentation_area,
   presentation_view,
   product_data_representation_view,
   annotation_fill_area,
   area_dependent_annotation_representation,
   view_dependent_annotation_representation,
   annotation_text_with_delineation,
   character_glyph_symbol_stroke,
   character_glyph_symbol_outline,
   symbol_representation_with_blanking_box);
END_TYPE;

TYPE invisibility_context = SELECT 
  (presentation_layer_usage,
   presentation_representation,
   presentation_set);
END_TYPE;

TYPE invisible_item = SELECT 
  (styled_item,
   presentation_layer_assignment,
   representation);
END_TYPE;

ENTITY styled_item
  SUBTYPE OF (representation_item);
  styles :  SET [1:?] OF presentation_style_assignment;
  item   :  representation_item;
WHERE
  WR1: (SIZEOF(SELF.styles) = 1)
               XOR
       (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
END_ENTITY;

ENTITY over_riding_styled_item
  SUBTYPE OF (styled_item);
  over_ridden_style : styled_item;
END_ENTITY;

ENTITY context_dependent_over_riding_styled_item
  SUBTYPE OF(over_riding_styled_item);
  style_context : SET[1:2] OF style_context_select;
WHERE
  WR1: (SIZEOF(QUERY( sc <* SELF.style_context |
       'REPRESENTATION_SCHEMA.REPRESENTATION' IN
         TYPEOF(sc))) = 1 )
                 AND
       (SIZEOF(QUERY( sc <* SELF.style_context |
       'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN
         TYPEOF(sc))) = 1);
END_ENTITY;

ENTITY presentation_style_assignment;
  styles : SET [1:?] OF presentation_style_select;
WHERE
  WR1: SIZEOF (QUERY (style1 <* SELF.styles |
         NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['PRESENTATION_APPEARANCE_SCHEMA.' +
                       'SURFACE_STYLE_USAGE',
                       'PRESENTATION_APPEARANCE_SCHEMA.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
  WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
END_ENTITY;

ENTITY presentation_style_by_context
  SUBTYPE OF (presentation_style_assignment);
  style_context : style_context_select;
END_ENTITY;

ENTITY pre_defined_presentation_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_style
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY point_style;
  name          : label;
  marker        : marker_select;
  marker_size   : size_select;
  marker_colour : colour;
END_ENTITY;

ENTITY pre_defined_marker
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY pre_defined_size
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY curve_style;
  name         : label;
  curve_font   : curve_font_or_scaled_curve_font_select;
  curve_width  : size_select;
  curve_colour : colour;
END_ENTITY;

ENTITY curve_style_with_ends_and_corners
  SUBTYPE OF (curve_style);
  curve_ends    : squared_or_rounded;
  curve_corners : squared_or_rounded;
END_ENTITY;

ENTITY curve_style_with_extension
  SUBTYPE OF (curve_style);
  curve_extensions   : length_measure;
END_ENTITY;

ENTITY pre_defined_curve_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_curve_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY curve_style_font;
  name         : label;
  pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY;

ENTITY curve_style_font_pattern;
  visible_segment_length   : positive_length_measure;
  invisible_segment_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_wide
  SUBTYPE OF (curve_style_font);
  interior_style : fill_area_style;
END_ENTITY;

ENTITY curve_style_curve_pattern_set
  SUBTYPE OF (curve_style_font, 
              geometric_representation_item);
  pattern_set : SET [1:?] OF curve_style_curve_pattern;
END_ENTITY;

ENTITY curve_style_curve_pattern
  SUBTYPE OF (geometric_representation_item);
  pattern        : annotation_curve_occurrence;
  pattern_length : positive_length_measure;
END_ENTITY;

ENTITY curve_style_font_and_scaling;
  name               : label;
  curve_font         : curve_style_font_select;
  curve_font_scaling : REAL;
END_ENTITY;

ENTITY draughting_pre_defined_curve_font
  SUBTYPE OF (pre_defined_curve_font);
WHERE
  WR1: SELF.name IN
       ['continuous',
        'chain',
        'chain double dash',
        'dashed',
        'dotted'];
END_ENTITY;

ENTITY fill_area_style;
  name       : label;
  fill_styles : SET [1:?] OF fill_style_select;
WHERE
  WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'PRESENTATION_APPEARANCE_SCHEMA.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
END_ENTITY;

ENTITY fill_area_style_colour;
  name        : label;
  fill_colour : colour;
END_ENTITY;

ENTITY pre_defined_hatch_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_hatch_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style_hatching
  SUBTYPE OF (geometric_representation_item);
  hatch_line_appearance         : curve_style;
  start_of_next_hatch_line      : one_direction_repeat_factor;
  point_of_reference_hatch_line : cartesian_point;
  pattern_start                 : cartesian_point;
  hatch_line_angle              : plane_angle_measure;
END_ENTITY;

ENTITY pre_defined_tile_style
  SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY externally_defined_tile_style
  SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY;

ENTITY fill_area_style_tiles
  SUBTYPE OF (geometric_representation_item);
  tiling_pattern : two_direction_repeat_factor;
  tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
  tiling_scale   : positive_ratio_measure;
END_ENTITY;

ENTITY fill_area_style_tile_curve_with_style
  SUBTYPE OF (geometric_representation_item);
  styled_curve : annotation_curve_occurrence;
END_ENTITY;

ENTITY fill_area_style_tile_coloured_region
  SUBTYPE OF (geometric_representation_item);
  closed_curve  : curve_or_annotation_curve_occurrence;
  region_colour : colour;
END_ENTITY;

ENTITY fill_area_style_tile_symbol_with_style
  SUBTYPE OF (geometric_representation_item);
  symbol : annotation_symbol_occurrence;
END_ENTITY;

ENTITY pre_defined_tile
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_tile
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY one_direction_repeat_factor
  SUBTYPE OF (geometric_representation_item);
  repeat_factor : vector;
END_ENTITY;

ENTITY two_direction_repeat_factor
  SUBTYPE OF (one_direction_repeat_factor);
  second_repeat_factor : vector;
END_ENTITY;

ENTITY surface_style_usage;
  side  : surface_side;
  style : surface_side_style_select;
END_ENTITY;

ENTITY pre_defined_surface_side_style
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY surface_side_style;
  name   : label;
  styles : SET [1:7] OF surface_style_element_select;
WHERE
  WR1: SIZEOF(QUERY( style1 <* SELF.styles |
         SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
         )) = 0;
END_ENTITY;

ENTITY surface_style_fill_area;
  fill_area : fill_area_style;
END_ENTITY;

ENTITY surface_style_boundary;
  style_of_boundary : curve_or_render;
END_ENTITY;

ENTITY curve_style_rendering;
  rendering_method     : shading_curve_method;
  rendering_properties : surface_rendering_properties;
END_ENTITY;

ENTITY surface_rendering_properties;
  rendered_colour : colour;
END_ENTITY;

ENTITY surface_style_silhouette;
  style_of_silhouette : curve_or_render;
END_ENTITY;

ENTITY surface_style_segmentation_curve;
  style_of_segmentation_curve : curve_or_render;
END_ENTITY;

ENTITY surface_style_control_grid;
  style_of_control_grid : curve_or_render;
END_ENTITY;

ENTITY surface_style_parameter_line;
  style_of_parameter_lines : curve_or_render;
  direction_counts         : SET [1:2] OF direction_count_select;
WHERE
  WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
       (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
END_ENTITY;

ENTITY surface_style_rendering;
  rendering_method : shading_surface_method;
  surface_colour   : colour;
END_ENTITY;

ENTITY surface_style_rendering_with_properties
  SUBTYPE OF (surface_style_rendering);
  properties : SET [1:2] OF rendering_properties_select;
WHERE
  WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
       (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
END_ENTITY;

ENTITY surface_style_reflectance_ambient;
  ambient_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse
  SUBTYPE OF (surface_style_reflectance_ambient);
  diffuse_reflectance : REAL;
END_ENTITY;

ENTITY surface_style_reflectance_ambient_diffuse_specular
  SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
  specular_reflectance : REAL;
  specular_exponent    : REAL;
  specular_colour      : colour;
END_ENTITY;

ENTITY surface_style_transparent;
  transparency : REAL;
WHERE
  WR1: {0.0 <= transparency <= 1.0};
END_ENTITY;

ENTITY text_style;
  name                 : label;
  character_appearance : character_style_select;
END_ENTITY;

ENTITY character_glyph_style_stroke;
  stroke_style : curve_style;
END_ENTITY;

ENTITY character_glyph_style_outline;
  outline_style : curve_style;
END_ENTITY;

ENTITY character_glyph_style_outline_with_characteristics
  SUBTYPE OF (character_glyph_style_outline);
  characteristics : fill_area_style;
END_ENTITY;

ENTITY text_style_for_defined_font;
  text_colour : colour;
END_ENTITY;

ENTITY text_style_with_justification
  SUBTYPE OF (text_style);
  justification : text_justification;
END_ENTITY;

ENTITY text_style_with_box_characteristics
  SUBTYPE OF (text_style);
  characteristics : SET [1:4] OF box_characteristic_select;
WHERE
  WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
         SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
       )) = 0;
END_ENTITY;

ENTITY text_style_with_spacing
  SUBTYPE OF (text_style);
  character_spacing : character_spacing_select;
END_ENTITY;

ENTITY pre_defined_character_spacing
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY text_style_with_mirror
  SUBTYPE OF (text_style);
  mirror_placement : axis2_placement;
END_ENTITY;

ENTITY symbol_style;
  name            : label; 
  style_of_symbol : symbol_style_select;
END_ENTITY;

ENTITY symbol_element_style;
  style_of_symbol : presentation_style_assignment;
WHERE
  WR1: SIZEOF (QUERY ( style <* SELF.style_of_symbol.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SYMBOL_STYLE' IN
         TYPEOF (style))) = 0;
  WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
            'PRESENTATION_STYLE_BY_CONTEXT' IN
            TYPEOF (SELF.style_of_symbol)
           );
END_ENTITY;

ENTITY symbol_colour;
  colour_of_symbol : colour;
END_ENTITY;

ENTITY approximation_tolerance;
  tolerance : tolerance_select;
END_ENTITY;

ENTITY approximation_tolerance_deviation;
  tessellation_type : approximation_method;
  tolerances        : SET [1:2] OF tolerance_deviation_select;
  definition_space  : product_or_presentation_space;
WHERE
  WR1: (HIINDEX(SELF.tolerances) = 1)
                XOR
       (TYPEOF(SELF.tolerances[1]) <> TYPEOF(SELF.tolerances[2]));
END_ENTITY;

ENTITY approximation_tolerance_parameter;
  tolerances : SET [1:2] OF tolerance_parameter_select;
WHERE
  WR1: (HIINDEX (SELF.tolerances) = 1 )
               XOR
       (TYPEOF (SELF.tolerances[1]) <> TYPEOF (SELF.tolerances[2]));
END_ENTITY;

ENTITY occlusion_precedence;
  higher_precedence : hiding_or_blanking_select;
  lower_precedence  : hiding_or_blanking_select;
  occlusion_context : representation;
WHERE
  WR1: acyclic_occlusion_precedence (SELF, [SELF.lower_precedence]);
END_ENTITY;

ENTITY invisibility;
  invisible_items : SET [1:?] OF invisible_item;
END_ENTITY;

ENTITY context_dependent_invisibility
  SUBTYPE OF (invisibility);
  presentation_context : invisibility_context;
END_ENTITY;

FUNCTION acyclic_occlusion_precedence
   ( relation : occlusion_precedence;
     set_of_lower : SET OF hiding_or_blanking_select ) : BOOLEAN;
   LOCAL
      x : SET OF occlusion_precedence;
      local_set_of_lower : SET OF hiding_or_blanking_select;
   END_LOCAL;
   REPEAT i:=1 TO HIINDEX(set_of_lower);
      IF relation.higher_precedence :=: set_of_lower[i] THEN
         RETURN(FALSE);
      END_IF;
   END_REPEAT;
   x := bag_to_set (USEDIN ( relation.higher_precedence,
                   'PRESENTATION_APPEARANCE_SCHEMA.'+
           'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
   local_set_of_lower := set_of_lower + relation.higher_precedence;
   IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
         If NOT acyclic_occlusion_precedence(x[i] ,
 
                                     local_set_of_lower) THEN
            RETURN (FALSE);
         END_IF;
      END_REPEAT;
   END_IF;
   RETURN (TRUE);
END_FUNCTION;

END_SCHEMA; -- presentation_appearance_schema
(* Genenerated from: ../../irs/wg12n953.exp *)

SCHEMA presentation_definition_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);
 
REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item,
     point
     );
 
REFERENCE FROM measure_schema
    (positive_ratio_measure);
 
REFERENCE FROM presentation_appearance_schema
    (styled_item);
 
REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol,
     planar_box,
     planar_extent,
     font_select,
     presentable_text,
     text_font);
 
REFERENCE FROM representation_schema
    (item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     text,
     bag_to_set);

TYPE text_delineation = label;
END_TYPE;

TYPE defined_symbol_select = SELECT
  (pre_defined_symbol,
   externally_defined_symbol);
END_TYPE;

TYPE text_or_character = SELECT
  (annotation_text,
   annotation_text_character,
   defined_character_glyph,
   composite_text,
   text_literal);
END_TYPE;

TYPE text_alignment = label;
END_TYPE;

TYPE defined_glyph_select = SELECT
  (pre_defined_character_glyph,
   externally_defined_character_glyph);
END_TYPE;

TYPE text_path = ENUMERATION OF
  (left,
   right,
   up,
   down);
END_TYPE;

ENTITY annotation_fill_area
  SUBTYPE OF (geometric_representation_item);
  boundaries : SET [1:?] OF curve;
END_ENTITY;

ENTITY defined_symbol
  SUBTYPE OF(geometric_representation_item);
  definition : defined_symbol_select;
  target     : symbol_target;
END_ENTITY;

ENTITY defined_table
  SUBTYPE OF(defined_symbol);
END_ENTITY;

ENTITY symbol_target
  SUBTYPE OF (geometric_representation_item);
  placement         : axis2_placement;
  x_scale           : positive_ratio_measure;
  y_scale           : positive_ratio_measure;
END_ENTITY;

ENTITY pre_defined_symbol
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY externally_defined_symbol
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY annotation_symbol
  SUBTYPE OF(mapped_item);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION_MAP' IN
         TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_TARGET' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_table
  SUBTYPE OF(annotation_symbol);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;

ENTITY symbol_representation_map
  SUBTYPE OF (representation_map);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_map.mapped_representation);
  WR2: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY symbol_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY symbol_representation_with_blanking_box
  SUBTYPE OF (symbol_representation);
  blanking : planar_box;
WHERE
  WR1: item_in_context (SELF.blanking, SELF\representation.context_of_items);
END_ENTITY;

ENTITY table_representation
  SUBTYPE OF (symbol_representation);
END_ENTITY;

ENTITY table_record_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                              'PRESENTATION_DEFINITION_SCHEMA.'+
                                              'TABLE_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_record_field_representation
  SUBTYPE OF (symbol_representation);
WHERE
  WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                            'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
       (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                               'REPRESENTATION_MAP.'+ 
                                               'MAPPED_REPRESENTATION') | 
         SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                              'MAPPED_ITEM.'+
                                              'MAPPING_SOURCE') |   
                                         'PRESENTATION_DEFINITION_SCHEMA.'+
                                           'TABLE_RECORD_REPRESENTATION' IN 
             TYPEOF (using_representations (mi)) )) > 0))  
                    > 0);
END_ENTITY;

ENTITY table_record_field_representation_with_clipping_box
  SUBTYPE OF (table_record_field_representation);
  clipping_box : planar_box;
WHERE
   WR1: item_in_context (SELF.clipping_box, 
                         SELF\representation.context_of_items);
END_ENTITY;

ENTITY symbol_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: acyclic_symbol_representation_relationship (SELF,
                                                   [SELF\representation_relationship.
                                                         rep_2]);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR3: 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION'IN
          TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY table_representation_relationship
  SUBTYPE OF (symbol_representation_relationship);
WHERE
  WR1: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR2: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
             TYPEOF (SELF\representation_relationship.rep_1))   
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
  WR3: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1)) 
         XOR
       ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2));
END_ENTITY;

ENTITY annotation_text
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
       TYPEOF( SELF\mapped_item.mapping_target);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.TEXT_STRING_REPRESENTATION' IN
       TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
       TYPEOF( SELF);
END_ENTITY;

ENTITY annotation_text_with_extent
  SUBTYPE OF (annotation_text);
  extent : planar_extent;
END_ENTITY;

ENTITY annotation_text_with_delineation
  SUBTYPE OF (annotation_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY annotation_text_with_blanking_box
  SUBTYPE OF (annotation_text);
  blanking : planar_box;
END_ENTITY;

ENTITY annotation_text_with_associated_curves
  SUBTYPE OF (annotation_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY text_string_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (
         QUERY (item <* SELF\representation.items |
           SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                    'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                    'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                    'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                    'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT',
                    'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * TYPEOF (item)) = 0
         )) = 0;
  WR2: SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                         'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                         'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
  WR3: SIZEOF (
         QUERY (a2p <* 
           QUERY (item <* SELF\representation.items | 
             'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <* 
               QUERY (item <* SELF\representation.items | 
                  'PRESENTATION_DEFINITION_SCHEMA.' + 
                  'ANNOTATION_TEXT' IN TYPEOF (item)) | 
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <* 
               QUERY (item <* SELF\representation.items |
                 'PRESENTATION_DEFINITION_SCHEMA.' + 
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | 
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
END_ENTITY;

ENTITY annotation_text_character
  SUBTYPE OF (mapped_item);
  alignment : text_alignment;
WHERE
  WR1: 'PRESENTATION_RESOURCE_SCHEMA.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  WR2: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN
         TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
END_ENTITY;

ENTITY defined_character_glyph
  SUBTYPE OF(geometric_representation_item);
  definition : defined_glyph_select;
  placement  : axis2_placement;
END_ENTITY;

ENTITY externally_defined_character_glyph
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY pre_defined_character_glyph
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY text_literal
  SUBTYPE OF (geometric_representation_item);
  literal   : presentable_text;
  placement : axis2_placement;
  alignment : text_alignment;
  path      : text_path;
  font      : font_select;
END_ENTITY;

ENTITY text_literal_with_extent
  SUBTYPE OF (text_literal);
  extent : planar_extent;
END_ENTITY;

ENTITY text_literal_with_delineation
  SUBTYPE OF (text_literal);
  delineation : text_delineation;
END_ENTITY;

ENTITY text_literal_with_blanking_box
  SUBTYPE OF (text_literal);
  blanking : planar_box;
END_ENTITY;

ENTITY text_literal_with_associated_curves
  SUBTYPE OF (text_literal);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY composite_text
  SUBTYPE OF (geometric_representation_item);
  collected_text : SET[2:?] of text_or_character;
WHERE
  WR1: acyclic_composite_text( SELF, SELF.collected_text);
END_ENTITY;

ENTITY composite_text_with_extent
  SUBTYPE OF (composite_text);
  extent : planar_extent;
END_ENTITY;

ENTITY composite_text_with_delineation
  SUBTYPE OF (composite_text);
  delineation : text_delineation;
END_ENTITY;

ENTITY composite_text_with_blanking_box
  SUBTYPE OF (composite_text);
  blanking : planar_box;
END_ENTITY;

ENTITY composite_text_with_associated_curves
  SUBTYPE OF (composite_text);
  associated_curves : SET[1:?] of curve;
END_ENTITY;

ENTITY annotation_occurrence
  SUPERTYPE OF (ONEOF(annotation_point_occurrence,
                      annotation_curve_occurrence,
                      annotation_fill_area_occurrence,
                      annotation_text_occurrence,
                      annotation_symbol_occurrence))
  SUBTYPE OF (styled_item);
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
END_ENTITY;

ENTITY annotation_point_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'GEOMETRY_SCHEMA.POINT' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_curve_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (SELF\styled_item.item);
END_ENTITY;

ENTITY annotation_fill_area_occurrence
  SUBTYPE OF (annotation_occurrence);
  fill_style_target : point;
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_FILL_AREA' IN
         TYPEOF (SELF.item);
END_ENTITY;

ENTITY annotation_text_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF (
         ['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
          'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
          'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
          'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_symbol_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1: SIZEOF(
         ['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_SYMBOL',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_SYMBOL'] *
         TYPEOF(SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_table_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (
         ['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE',
          'PRESENTATION_DEFINITION_SCHEMA.DEFINED_TABLE'] *
         TYPEOF (SELF\styled_item.item)) > 0;
END_ENTITY;

ENTITY annotation_occurrence_relationship;
  name                           : label;
  description                    : text;
  relating_annotation_occurrence : annotation_occurrence;
  related_annotation_occurrence  : annotation_occurrence;
END_ENTITY;

ENTITY table_text_relationship
  SUBTYPE OF (annotation_occurrence_relationship);
  field : table_record_field_representation;
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence\styled_item.item);
  WR3: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_OCCURRENCE'
       IN TYPEOF (SELF\annotation_occurrence_relationship.
                  related_annotation_occurrence);
  WR4: field_in_table (SELF.field,
                       SELF\annotation_occurrence_relationship.
                       relating_annotation_occurrence);
END_ENTITY;

FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;

  LOCAL
   i : INTEGER;
   local_composite_text : SET [0:?] OF composite_text;
   local_annotation_text : SET [0:?] OF annotation_text;
   local_children : SET [0:?] OF text_or_character;
  END_LOCAL;

  local_composite_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_composite_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      IF (start_composite :=: local_composite_text[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;

  local_children := child_text;

  IF (SIZEOF (local_composite_text)) > 0 THEN
    REPEAT i := 1 TO HIINDEX (local_composite_text);
      local_children := local_children +
                        local_composite_text[i].collected_text;
    END_REPEAT;
  END_IF;


  local_annotation_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT'
                           IN TYPEOF (child)));

  IF (SIZEOF (local_annotation_text) > 0) THEN
    REPEAT i := 1 TO HIINDEX (local_annotation_text);
      local_children := local_children +
      QUERY (item <* local_annotation_text[i]\mapped_item.
                     mapping_source.mapped_representation.items |
        SIZEOF(['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                TYPEOF(item)) > 0);
    END_REPEAT;
  END_IF;

  IF (local_children :<>: child_text) THEN
    RETURN (acyclic_composite_text (start_composite, local_children));
  ELSE
    RETURN (TRUE);
  END_IF;

 END_FUNCTION;

FUNCTION acyclic_symbol_representation_relationship
  (relation : symbol_representation_relationship;
   children : SET OF symbol_representation ) : BOOLEAN;
  LOCAL
    x : SET OF symbol_representation_relationship;
    local_children : SET OF symbol_representation;
  END_LOCAL;
 
  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
 
  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                'REPRESENTATION_SCHEMA.'+
                'REPRESENTATION_RELATIONSHIP.'+ 'REP_2'));
  local_children := children + relation\representation_relationship.rep_1;
 
  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
      IF NOT acyclic_symbol_representation_relationship(x[i] , 
                                                local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
 
  RETURN (TRUE);
 
END_FUNCTION;

FUNCTION field_in_table (field : table_record_field_representation;
                         table : annotation_table_occurrence): BOOLEAN;
  LOCAL
    table_rep : table_representation;
    symbol_rep_rel_set : SET OF symbol_representation_relationship;
    mapped_item_set : SET OF mapped_item;
    table_record_rep_set : SET OF table_record_representation := [];
  END_LOCAL;
 
  table_rep := table\styled_item.item\mapped_item.mapping_source.
    mapped_representation;
  mapped_item_set := QUERY(item <* table_rep.items |
                       ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                        TYPEOF(item))
                                 AND
                       ('PRESENTATION_DEFINITION_SCHEMA.'+
                        'TABLE_RECORD_REPRESENTATION' IN
                         TYPEOF(item\mapped_item.mapping_source.
                                    mapped_representation ))
                     );
 
  REPEAT i := 1 TO HIINDEX(mapped_item_set);
    table_record_rep_set := table_record_rep_set +
           mapped_item_set[i].mapping_source.mapped_representation;
  END_REPEAT;
 
  symbol_rep_rel_set := bag_to_set (USEDIN(table_rep, 
                               'REPRESENTATION_SCHEMA.'+
                               'REPRESENTATION_RELATIONSHIP.REP_1'));
 
  REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
     table_record_rep_set := table_record_rep_set +
              symbol_rep_rel_set[i]\representation_relationship.rep_2;
  END_REPEAT;
 
  IF SIZEOF(QUERY( table_record_rep <* table_record_rep_set |
--              (SIZEOF(QUERY( symbol_rep_rel <* USEDIN(table_record_rep,
--                            'PRESENTATION_DEFINITION_SCHEMA.'+
--                            'SYMBOL_REPRESENTATION_RELATIONSHIP.REP_1') |
--                       symbol_rep_rel\representation_relationship.rep_2 :=: field
              (SIZEOF(QUERY( rep_rel <* USEDIN(table_record_rep,
                            'REPRESENTATION_SCHEMA.'+
                            'REPRESENTATION_RELATIONSHIP.REP_1') |
                       ('PRESENTATION_DEFINITION_SCHEMA.' +
                       'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rep_rel)) AND  
                       (rep_rel.rep_2 :=: field)
                       )) > 0)
                       OR
              (SIZEOF(QUERY(item <* table_record_rep.items |
                        ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                         TYPEOF(item))
                                 AND
                        (field :=: item\mapped_item.mapping_source.
                                    mapped_representation )
                         )) > 0)
             )) = 0 THEN
    RETURN(FALSE);
  END_IF;
 
  RETURN(TRUE);
 
END_FUNCTION;

END_SCHEMA; -- presentation_definition_schema
(* Genenerated from: ../../irs/wg12n953.exp *)

SCHEMA presentation_organization_schema;

REFERENCE FROM presentation_resource_schema
   (colour,
    planar_box,
    planar_extent,
    presentation_scaled_placement);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     symbol_representation,
     symbol_representation_relationship);

REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM geometry_schema
    (axis2_placement_2d,
     axis2_placement_3d,
     cartesian_point,
     curve,
     direction,
     dot_product,
     geometric_representation_context,
     geometric_representation_item,
     plane
     );
 
REFERENCE FROM representation_schema
    (founded_item,
     item_defined_transformation,
     item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation);
 
REFERENCE FROM measure_schema
   (length_measure,
    positive_ratio_measure,
    positive_plane_angle_measure);
 
REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text,
     bag_to_set);

TYPE presentation_size_assignment_select = SELECT 
  (presentation_view,
   presentation_area,
   area_in_set);
END_TYPE;

TYPE area_or_view = SELECT 
  (presentation_area,
   presentation_view);
END_TYPE;

TYPE central_or_parallel = ENUMERATION OF 
  (central, 
   parallel);
END_TYPE;

TYPE layered_item = SELECT 
  (presentation_representation,
   representation_item);
END_TYPE;

TYPE presentation_representation_select = SELECT 
  (presentation_representation,
   presentation_set);
END_TYPE;

ENTITY presentation_set;
INVERSE
  areas : SET [1:?] OF area_in_set FOR in_set;
END_ENTITY;

ENTITY presentation_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SELF\representation.
            context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT'
       IN TYPEOF (SELF\representation.context_of_items);
END_ENTITY;

ENTITY presentation_area
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                             'AREA_IN_SET.AREA') | 
           SIZEOF (USEDIN (ais, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
         (SIZEOF (USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                'PRESENTATION_SIZE.UNIT')) =1));
END_ENTITY;

ENTITY area_in_set;
  area   : presentation_area;
  in_set : presentation_set;
END_ENTITY;

ENTITY presentation_view
  SUBTYPE OF (presentation_representation);
END_ENTITY;

ENTITY area_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.' +
                     'ANNOTATION_OCCURRENCE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
         TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY product_data_representation_view
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] *
                    TYPEOF (item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items | 
       ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY view_dependent_annotation_representation
  SUBTYPE OF (presentation_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.' +
                     'ANNOTATION_OCCURRENCE',
                     'GEOMETRY_SCHEMA.AXIS2_PLACEMENT'] * 
            TYPEOF(item)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (item <* SELF\representation.items |
       ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
       )) >= 1;
END_ENTITY;

ENTITY presentation_size;
  unit : presentation_size_assignment_select;
  size : planar_box;
WHERE
  WR1: (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
         IN TYPEOF (SELF.unit)) AND
         item_in_context (SELF.size, 
                          SELF.unit\representation.context_of_items)
       )
            OR
       (
        ('PRESENTATION_ORGANIZATION_SCHEMA.AREA_IN_SET'
          IN TYPEOF (SELF.unit)) AND
        (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0)
       ); 
END_ENTITY;

ENTITY background_colour
  SUBTYPE OF (colour);
  presentation : area_or_view;
UNIQUE
  UR1:  presentation;
END_ENTITY;

ENTITY presentation_representation_relationship
  SUBTYPE OF (representation_relationship_with_transformation);
WHERE
  WR1: 'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN
         TYPEOF (SELF\representation_relationship.rep_2);
  WR3: acyclic_presentation_representation_relationship (SELF,
         [SELF\representation_relationship.rep_2]);
  WR4: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
         TYPEOF (SELF\representation_relationship.rep_1)) 
                 AND
         NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                       'PRODUCT_DATA_REPRESENTATION_VIEW',
                       'PRESENTATION_ORGANIZATION_SCHEMA.' +
                       'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION'] *
         TYPEOF (SELF\representation_relationship.rep_2)) = 0));
  WR5: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW'
         IN TYPEOF (SELF\representation_relationship.rep_1))
                 AND
       NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'PRESENTATION_AREA',
                     'PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'PRESENTATION_VIEW',
                     'PRESENTATION_ORGANIZATION_SCHEMA.' +
                     'AREA_DEPENDENT_ANNOTATION_REPRESENTATION'] *
              TYPEOF (SELF\representation_relationship.rep_2))=0));
  WR6: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2)))
              XOR
         ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA'IN
         TYPEOF(SELF\representation_relationship.rep_1));
  WR7: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.' +
             'PRODUCT_DATA_REPRESENTATION_VIEW' IN
         (TYPEOF(SELF\representation_relationship.rep_1) +
          TYPEOF(SELF\representation_relationship.rep_2))))
              XOR
       ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_1))
                AND
       ('PRESENTATION_ORGANIZATION_SCHEMA.PRODUCT_DATA_REPRESENTATION_VIEW' IN
         TYPEOF(SELF\representation_relationship.rep_2));
  WR8: 'PRESENTATION_ORGANIZATION_SCHEMA.GRAPHICAL_TRANSFORMATION' IN
         TYPEOF(SELF\representation_relationship_with_transformation.
                     transformation_operator);
END_ENTITY;

ENTITY graphical_transformation
  SUBTYPE OF (item_defined_transformation);
WHERE
  WR1: 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_1);
  WR2: 'PRESENTATION_RESOURCE_SCHEMA.PRESENTATION_SCALED_PLACEMENT' IN
         TYPEOF (SELF\item_defined_transformation.transform_item_2);
END_ENTITY;

ENTITY camera_model
  SUPERTYPE OF (ONEOF(camera_model_d2, camera_model_d3))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: (SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                              'ITEM_DEFINED_TRANSFORMATION.' +
                              'TRANSFORM_ITEM_1')) +
        SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                              'REPRESENTATION_MAP.MAPPING_ORIGIN'))
       ) > 0;
  WR2: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                          'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY camera_model_d2
  SUBTYPE OF (camera_model);
  view_window          : planar_box;
  view_window_clipping : BOOLEAN;
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY camera_model_d2_shape_clipping
  SUBTYPE OF (camera_model_d2);
  shape_clipping : curve;
END_ENTITY;

ENTITY camera_model_d3
  SUBTYPE OF (camera_model);
  view_reference_system : axis2_placement_3d;
  perspective_of_volume : view_volume;
WHERE
  WR1: (dot_product (SELF.view_reference_system.p[3],
         SELF.perspective_of_volume.view_window.placement.p[3]) = 1.0)
         AND
       (SELF.view_reference_system.location.coordinates[3] =
        SELF.perspective_of_volume.view_window.
             placement.location.coordinates[3]);
  WR2: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY view_volume
  SUBTYPE OF (founded_item);
  projection_type            : central_or_parallel;
  projection_point           : cartesian_point;
  view_plane_distance        : length_measure;
  front_plane_distance       : length_measure;
  front_plane_clipping       : BOOLEAN;
  back_plane_distance        : length_measure;
  back_plane_clipping        : BOOLEAN;
  view_volume_sides_clipping : BOOLEAN;
  view_window                : planar_box;
END_ENTITY;

ENTITY camera_model_d3_with_hlhsr
  SUBTYPE OF (camera_model_d3);
  hidden_line_surface_removal : BOOLEAN;
END_ENTITY;

ENTITY camera_model_d3_multi_clipping
  SUBTYPE OF (camera_model_d3);
  shape_clipping : SET [1:?] OF plane;
END_ENTITY;

ENTITY camera_model_with_light_sources
  SUBTYPE OF (camera_model_d3);
  sources : SET [1:?] OF light_source;
END_ENTITY;

ENTITY light_source
  SUPERTYPE OF (ONEOF(light_source_ambient,
                      light_source_directional,
                      light_source_positional,
                      light_source_spot))
  SUBTYPE OF (geometric_representation_item);
  light_colour : colour;
WHERE
  WR1: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                         'STYLED_ITEM.ITEM')) = 0;
END_ENTITY;

ENTITY light_source_ambient
  SUBTYPE OF (light_source);
END_ENTITY;

ENTITY light_source_directional
  SUBTYPE OF (light_source);
  orientation : direction;
END_ENTITY;

ENTITY light_source_positional
  SUBTYPE OF (light_source);
  position             : cartesian_point;
  constant_attenuation : REAL;
  distance_attenuation : REAL;
END_ENTITY;

ENTITY light_source_spot
  SUBTYPE OF (light_source);
  position               : cartesian_point;
  orientation            : direction;
  concentration_exponent : REAL;
  constant_attenuation   : REAL;
  distance_attenuation   : REAL;
  spread_angle           : positive_plane_angle_measure;
END_ENTITY;

ENTITY camera_image
  SUBTYPE OF (mapped_item);
WHERE
  WR1: 'PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_USAGE'
       IN TYPEOF (SELF\mapped_item.mapping_source);
  WR2: 'PRESENTATION_RESOURCE_SCHEMA.PLANAR_BOX'
       IN TYPEOF (SELF\mapped_item.mapping_target);
  WR3: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
       IN TYPEOF (SELF);
END_ENTITY;

ENTITY camera_usage
  SUBTYPE OF (representation_map);
WHERE
  WR1: NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
       IN TYPEOF(SELF\representation_map.mapped_representation));
  WR2: 'PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL'
       IN TYPEOF (SELF\representation_map.mapping_origin);
END_ENTITY;

ENTITY camera_image_3d_with_scale
  SUBTYPE OF (camera_image);
DERIVE
  scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
         planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
         mapping_origin\camera_model_d3.perspective_of_volume.view_window.
         size_in_x));
WHERE
  WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D3'
       IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
  WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
       aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
       camera_model_d3.perspective_of_volume.view_window);
  WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.front_plane_clipping
       AND
       SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_volume_sides_clipping;
  WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
  WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_x > 0)
       AND
       (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
       perspective_of_volume.view_window.size_in_y > 0);
  WR6: ('GEOMETRY_SCHEMA.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement))
       AND NOT ('GEOMETRY_SCHEMA.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
       mapping_target\planar_box.placement));
END_ENTITY;

ENTITY presentation_layer_assignment;
  name           : label;
  description    : text;
  assigned_items : SET [1:?] OF layered_item;
END_ENTITY;

ENTITY representation_item_dependent_layer_assignment
  SUBTYPE OF (presentation_layer_assignment);
  item_context : representation_item;
END_ENTITY;

ENTITY presentation_layer_usage;
  assignment   : presentation_layer_assignment;
  presentation : presentation_representation;
UNIQUE
  UR1: assignment, presentation;
END_ENTITY;

ENTITY presented_item_representation;
  presentation : presentation_representation_select;
  item         : presented_item;
END_ENTITY;

ENTITY presented_item
  ABSTRACT SUPERTYPE;
END_ENTITY;

RULE symbol_representation_rule
  FOR (presentation_representation_relationship);
WHERE
  WR1: SIZEOF(QUERY(each_1 <* presentation_representation_relationship  |
              NOT ('PRESENTATION_DEFINITION_SCHEMA.'+
              'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(each_1)) AND
         (SIZEOF(QUERY(each_2 <* [each_1\representation_relationship.rep_1,
                                  each_1\representation_relationship.rep_2] |
         'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)
         )) > 0)
       )) = 0;
END_RULE;

FUNCTION acyclic_presentation_representation_relationship
  ( relation : presentation_representation_relationship;
    children : SET OF presentation_representation ) : BOOLEAN;

  LOCAL
    x : SET OF presentation_representation_relationship;
    local_children : SET OF presentation_representation;
  END_LOCAL;

  REPEAT i:=1 TO HIINDEX(children);
    IF relation\representation_relationship.rep_1 :=: children[i] THEN
       RETURN(FALSE);
    END_IF;
  END_REPEAT;

  x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.REP_2'));
  local_children := children + relation\representation_relationship.rep_1;

  IF SIZEOF (x) > 0 THEN
    REPEAT i:=1 TO HIINDEX (x);
       IF NOT acyclic_presentation_representation_relationship
              (x[i] , local_children) THEN
         RETURN (FALSE);
       END_IF;
    END_REPEAT;
  END_IF;

  RETURN (TRUE);

END_FUNCTION;

FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;
(* if the dimensions of the planar_box are greater than zero,
      compute the aspect ratio and return the resulting value. *)
   IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
   ELSE
      RETURN (?);
   END_IF;
END_FUNCTION; 

END_SCHEMA; -- presentation_organization_schema 
(* Genenerated from: ../../irs/wg12n953.exp *)

SCHEMA presentation_resource_schema;

REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item
     );

REFERENCE FROM measure_schema
    (length_measure,
     positive_length_measure,
     positive_ratio_measure,
     ratio_measure);

REFERENCE FROM presentation_definition_schema
    (annotation_fill_area,
     symbol_representation);

REFERENCE FROM representation_schema
    (item_in_context,
     representation);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);
 

TYPE staircase_or_linear = ENUMERATION OF 
  (staircase, 
   linear);
END_TYPE;

TYPE presentable_text = STRING;
END_TYPE;

TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font);
END_TYPE;

ENTITY character_glyph_symbol
  SUBTYPE OF (symbol_representation);
  character_box  : planar_extent;
  baseline_ratio : ratio_measure;
DERIVE
  box_height : length_measure := character_box.size_in_y;
WHERE
  WR1: {0.0 <= baseline_ratio <= 1.0};
  WR2: item_in_context(SELF.character_box, 
                       SELF\representation.context_of_items);
  WR3: 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;

ENTITY character_glyph_symbol_stroke
  SUBTYPE OF (character_glyph_symbol);
  strokes : SET [1:?] OF curve;
WHERE
  WR1: SELF.strokes <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_symbol_outline
  SUBTYPE OF (character_glyph_symbol);
  outlines : SET [1:?] OF annotation_fill_area;
WHERE
  WR1: SELF.outlines <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_font_usage;
  character : character_glyph_symbol;
  font      : text_font;
END_ENTITY;

ENTITY text_font;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;

ENTITY text_font_family;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  fonts       : SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;

ENTITY text_font_in_family;
  font   : text_font;
  family : text_font_family;
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_associated
  SUBTYPE OF (colour);
  name : label;
  variable_to_be_shown : SET [1:?] OF REAL;
  mapping              : colour_association_table;
END_ENTITY;

ENTITY colour_association_table;
  discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
  interpolation_type           : staircase_or_linear;
END_ENTITY;

ENTITY state_variable_with_colour;
  state_variable    : REAL;
  associated_colour : colour_specification;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY presentation_scaled_placement 
  SUBTYPE OF (geometric_representation_item);
  placement : axis2_placement;
  scaling   : positive_ratio_measure;
END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_text_font
   SUBTYPE of (pre_defined_text_font);
WHERE
   WR1: SELF.name IN ['ISO 3098-1 font A', 'ISO 3098-1 font B'];
END_ENTITY;

END_SCHEMA; -- presentation_resource_schema
(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_representation_schema;

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM process_property_schema
    (action_property, 
     resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

END_SCHEMA; -- process_property_representation_schema
(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_schema;

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema
(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA product_concept_schema;

  REFERENCE FROM support_resource_schema
    (text, label, identifier);

  REFERENCE FROM application_context_schema
    (product_concept_context);

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

END_SCHEMA; -- product_concept_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_definition_schema;

REFERENCE FROM application_context_schema   -- ISO 10303-41
  (product_context,
   product_definition_context); 

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM document_schema   -- ISO 10303-41
  (document); 

REFERENCE FROM effectivity_schema   -- ISO 10303-41
  (effectivity); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE source = ENUMERATION OF 
   (made,
    bought,
    not_known);
END_TYPE; 

ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET[1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship (SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;

ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;

ENTITY product_definition_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;

ENTITY product_definition_substitute;
  description : OPTIONAL text;
  context_relationship : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value (SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET[1:?] OF document;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET[1:?] OF product;
END_ENTITY;

ENTITY product_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product : product;
  related_product : product;
END_ENTITY;

FUNCTION acyclic_product_category_relationship
 (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_formation_relationship
 (relation : product_definition_formation_relationship; relatives : SET[1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_definition_relationship
 (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_product_relationship
 (relation : product_relationship; relatives : SET[1:?] OF product; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_product_definitions
 (c_def_instance : product) : SET OF product_definition; 
  LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_definition_schema

(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_property_definition_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_id_value,
   id_attribute); 

REFERENCE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   resource_property); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


TYPE characterized_definition = SELECT
   (characterized_object, 
    characterized_product_definition, 
    shape_definition);
END_TYPE; 

TYPE characterized_product_definition = SELECT
   (product_definition, 
    product_definition_relationship);
END_TYPE; 

TYPE derived_property_select = SELECT
   (action_property, 
    property_definition, 
    resource_property);
END_TYPE; 

TYPE shape_definition = SELECT
   (product_definition_shape, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY characterized_object_relationship;
  name : label;
  description : OPTIONAL text;
  relating_object : characterized_object;
  related_object : characterized_object;
END_ENTITY;

ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF( USEDIN( derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;

ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
END_ENTITY;

ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

FUNCTION acyclic_characterized_object_relationship
 (relation : characterized_object_relationship; relatives : SET[1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_general_property_relationship
 (relation : general_property_relationship; relatives : SET[1:?] OF general_property; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_shape_aspect_relationship
 (relation : shape_aspect_relationship; relatives : SET[1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION get_shape_aspects
 (c_def_instance : characterized_definition) : SET OF shape_aspect; 
  LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_property_definition_schema
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA product_property_representation_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   get_description_value,
   get_name_value,
   name_attribute); 

REFERENCE FROM material_property_definition_schema   -- ISO 10303-45
  (property_definition_relationship); 

REFERENCE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_definition,
   general_property,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   text); 


TYPE represented_definition = SELECT
   (general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
END_TYPE; 

ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY item_identified_representation_usage;
  name : label;
  description : OPTIONAL text;
  definition : represented_definition;
  used_representation : representation;
  identified_item : representation_item;
WHERE
  WR1: SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY;

ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value (SELF);
  name : label := get_name_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
  WR2: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;

FUNCTION relatives_of_product_definitions
 (definition_set : SET OF product_definition; relation_subtype : STRING) : SET OF product_definition; 
FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
END_FUNCTION; 

FUNCTION relatives_of_shape_representations
 (shape_representation_set : SET OF shape_representation) : SET OF shape_representation; 
 FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));      
END_FUNCTION; 

FUNCTION get_property_definition_representations
 (c_def_instance : characterized_definition) : SET OF property_definition_representation; 
LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
END_FUNCTION; 

END_SCHEMA;  -- product_property_representation_schema(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA product_structure_schema;

  REFERENCE FROM product_definition_schema
    (product,
     product_definition,
     product_definition_relationship,
     acyclic_product_definition_relationship);

  REFERENCE FROM measure_schema
     (measure_with_unit);

  REFERENCE FROM support_resource_schema
     (identifier, label, text);

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
                       specified_higher_usage_occurrence,
                       promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

END_SCHEMA; -- product_structure
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA qualifications_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 


ENTITY qualification;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification : qualification;
  related_qualification : qualification;
END_ENTITY;

ENTITY qualification_type;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_qualification_type : qualification_type;
  related_qualification_type : qualification_type;
END_ENTITY;

FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;  -- qualifications_schema

(* Genenerated from: ../../irs/wg12n257.exp *)

SCHEMA qualified_measure_schema;

REFERENCE FROM support_resource_schema
     (label,
      text);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM representation_schema
     (representation_item);

TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

END_SCHEMA;  -- qualified_measure_schema
(* Genenerated from: ../../irs/wg12n458.exp *)

SCHEMA representation_schema;

REFERENCE FROM basic_attribute_schema
  (get_description_value,
   get_id_value);

REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE compound_item_definition = SELECT
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE founded_item_select = SELECT
  (founded_item,
   representation_item);
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF (SELF\representation.context_of_items );
END_ENTITY;

ENTITY founded_item;
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET[1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id               : identifier := get_id_value (SELF);
  description      : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
 END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation
    FOR context_of_items;
END_ENTITY;

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET[1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1:
   SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value (SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
       NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF (rep.context_of_items)
       ))) = 0;
END_ENTITY;

FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
   children_set : SET OF representation_item) : BOOLEAN;
  LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z <* children_set | 'REPRESENTATION_SCHEMA.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) > 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);
END_FUNCTION;

FUNCTION item_in_context
  (item  : representation_item;
   cntxt : representation_context) : BOOLEAN;
  LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) > 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN (item , '') |
           'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) > 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);
END_FUNCTION;

FUNCTION using_items (item : founded_item_select;
                      checked_items: SET OF founded_item_select)
                    : SET OF founded_item_select;
  LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) > 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);
END_FUNCTION;

FUNCTION using_representations (item : founded_item_select)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) > 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);
END_FUNCTION;

FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;

END_SCHEMA; -- representation_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  WG12N3267 - ISO 10303-58 risk_schema
*)

SCHEMA risk_schema;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_method,
   action_method_relationship,
   action_resource); 

USE FROM application_context_schema   -- ISO 10303-41
  (application_context,
   application_context_element); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role); 

USE FROM document_schema   -- ISO 10303-41
  (document); 

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment,
   classification_assignment,
   classification_role,
   person_and_organization_assignment); 

USE FROM measure_schema   -- ISO 10303-41
  (measure_value); 

USE FROM person_organization_schema   -- ISO 10303-41
  (organization,
   person,
   person_and_organization,
   person_and_organization_role); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_relationship,
   product_definition_with_associated_documents,
   product_relationship); 

USE FROM representation_schema   -- ISO 10303-43
  (representation,
   representation_context,
   representation_item,
   value_representation_item); 

USE FROM state_observed_schema   -- ISO 10303-56
  (state_observed,
   state_observed_assignment,
   state_observed_role); 

USE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


TYPE mitigation_select = SELECT
   (risk, 
    risk_consequence, 
    risk_perception_relationship, 
    risk_probability_assignment, 
    risk_relationship, 
    risk_source_assignment);
END_TYPE; 

TYPE risk_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (risk, 
    risk_consequence, 
    risk_perception, 
    risk_perception_relationship, 
    risk_probability, 
    risk_relationship);
END_TYPE; 

TYPE risk_communication_select = SELECT
   (applied_risk_classification_assignment, 
    lessons_learned, 
    risk, 
    risk_analysis, 
    risk_assessment, 
    risk_consequence, 
    risk_context, 
    risk_control, 
    risk_criteria, 
    risk_evaluation, 
    risk_identification, 
    risk_impact, 
    risk_owner_assignment, 
    risk_perception, 
    risk_perception_context, 
    risk_perception_relationship, 
    risk_probability, 
    risk_reduction, 
    risk_relationship, 
    risk_resource, 
    risk_status_assignment, 
    risk_treatment, 
    source_identification);
END_TYPE; 

TYPE risk_estimation_select = SELECT
   (qualitative_consequence, 
    qualitative_probability, 
    quantitative_consequence, 
    quantitative_probability, 
    quantitative_probability_distribution);
END_TYPE; 

TYPE risk_evaluation_select = SELECT
   (risk_analysis, 
    risk_consequence, 
    risk_context, 
    risk_perception, 
    risk_perception_relationship, 
    risk_probability_assignment, 
    risk_source_assignment, 
    risk_treatment);
END_TYPE; 

TYPE risk_identification_select = SELECT
   (risk_consequence, 
    risk_criteria, 
    risk_probability, 
    risk_probability_assignment);
END_TYPE; 

TYPE risk_supported_item = SELECT
   (risk_analysis, 
    risk_assessment, 
    risk_communication, 
    risk_control, 
    risk_estimation, 
    risk_identification, 
    risk_reduction, 
    risk_treatment, 
    source_identification);
END_TYPE; 

ENTITY applied_risk_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF risk_classification_item;
  SELF\classification_assignment.assigned_class : group;
  SELF\classification_assignment.role : classification_role;
END_ENTITY;

ENTITY lessons_learned
  SUBTYPE OF (risk_perception);
  document_ids : document;
  risk_source_assignment : risk_source_assignment;
END_ENTITY;

ENTITY qualitative_consequence
  SUBTYPE OF (risk_consequence);
  SELF\representation.items RENAMED estimate : SET[1:?] OF qualitative_consequence_estimate;
END_ENTITY;

ENTITY qualitative_consequence_estimate
  SUBTYPE OF (representation_item);
  SELF\representation_item.name : label;
END_ENTITY;

ENTITY qualitative_probability
  SUBTYPE OF (risk_probability);
  SELF\representation.items RENAMED estimate : SET[1:?] OF qualitative_probability_estimate;
END_ENTITY;

ENTITY qualitative_probability_estimate
  SUBTYPE OF (representation_item);
  SELF\representation_item.name : label;
END_ENTITY;

ENTITY quantitative_consequence
  SUBTYPE OF (risk_consequence);
  SELF\representation.items RENAMED estimate : SET[1:?] OF quantitative_consequence_estimate;
END_ENTITY;

ENTITY quantitative_consequence_estimate
  SUBTYPE OF (value_representation_item);
  SELF\value_representation_item.value_component : measure_value;
END_ENTITY;

ENTITY quantitative_probability
  SUBTYPE OF (risk_probability);
  SELF\representation.items RENAMED estimate : SET[1:?] OF quantitative_probability_estimate;
END_ENTITY;

ENTITY quantitative_probability_distribution
  SUBTYPE OF (quantitative_probability);
  mean : REAL;
  variance : REAL;
END_ENTITY;

ENTITY quantitative_probability_estimate
  SUBTYPE OF (value_representation_item);
  SELF\value_representation_item.value_component : measure_value;
END_ENTITY;

ENTITY risk
  SUBTYPE OF (product);
  SELF\product.id : identifier;
  SELF\product.name : label;
  SELF\product.description : OPTIONAL text;
  SELF\product.frame_of_reference RENAMED risk_context : SET[1:?] OF risk_context;
END_ENTITY;

ENTITY risk_action
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (action);
  SELF\action.name : label;
  SELF\action.description : OPTIONAL text;
  SELF\action.chosen_method RENAMED risk_treatment : risk_treatment;
END_ENTITY;

ENTITY risk_analysis
  SUBTYPE OF (risk_action);
  source_identification : source_identification;
  risk_estimates : SET[1:?] OF risk_estimation;
END_ENTITY;

ENTITY risk_application_context_element
  ABSTRACT SUPERTYPE 
  SUBTYPE OF (application_context_element);
  SELF\application_context_element.name : label;
  SELF\application_context_element.frame_of_reference : application_context;
END_ENTITY;

ENTITY risk_assessment
  SUBTYPE OF (risk_action);
  risk_analysis : SET[1:?] OF risk_analysis;
  risk_evaluation : SET[1:?] OF risk_evaluation;
END_ENTITY;

ENTITY risk_communication
  SUBTYPE OF (risk_action);
  communicator : risk_stakeholder;
  communicatee : SET[1:?] OF risk_stakeholder;
  inputs : SET[1:?] OF risk_communication_select;
END_ENTITY;

ENTITY risk_consequence
  SUBTYPE OF (representation);
  SELF\representation.name : label;
  SELF\representation.context_of_items : representation_context;
  SELF\representation.items : SET[1:?] OF representation_item;
DERIVE
  SELF\representation.description : text := get_description_value (SELF);
  SELF\representation.id : identifier := get_id_value (SELF);
WHERE
 wr1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
 wr2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_context
  SUBTYPE OF (risk_application_context_element);
END_ENTITY;

ENTITY risk_control
  SUBTYPE OF (risk_action);
  monitor : SET[1:?] OF risk_assessment;
END_ENTITY;

ENTITY risk_criteria
  SUBTYPE OF (action_method);
  SELF\action_method.name : label;
  SELF\action_method.description : OPTIONAL text;
  SELF\action_method.consequence : text;
  SELF\action_method.purpose RENAMED risk_stakeholder : risk_stakeholder;
WHERE
  wr1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_estimation
  SUBTYPE OF (risk_action);
  inputs : SET[0:?] OF risk_evaluation;
  outputs : SET[1:?] OF risk_estimation_select;
END_ENTITY;

ENTITY risk_evaluation
  SUBTYPE OF (action);
  SELF\action.name : label;
  SELF\action.description : OPTIONAL text;
  SELF\action.chosen_method RENAMED risk_criteria : risk_criteria;
  inputs : SET[1:?] OF risk_evaluation_select;
DERIVE
  SELF\action.id : identifier := get_id_value (SELF);
WHERE
wr1  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_identification
  SUBTYPE OF (risk_action);
  inputs : SET[1:?] OF risk_identification_select;
END_ENTITY;

ENTITY risk_impact
  SUBTYPE OF (risk_consequence);
  causal_consequence : OPTIONAL risk_consequence;
END_ENTITY;

ENTITY risk_impact_assignment
  ABSTRACT SUPERTYPE ;
  assigned_risk_impact : risk_impact;
DERIVE
  role : object_role := get_role (SELF);
WHERE
wr1  : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY risk_organization_stakeholder
  SUBTYPE OF (organization, risk_stakeholder);
  SELF\organization.id : OPTIONAL identifier;
  SELF\organization.name : label;
  SELF\organization.description : OPTIONAL text;
END_ENTITY;

ENTITY risk_owner_assignment
  SUBTYPE OF (person_and_organization_assignment);
  SELF\person_and_organization_assignment.assigned_person_and_organization : risk_stakeholder;
  risk : SET[1:?] OF risk;
  SELF\person_and_organization_assignment.role : person_and_organization_role;
END_ENTITY;

ENTITY risk_perception
  SUBTYPE OF (product_definition);
  SELF\product_definition.id : identifier;
  SELF\product_definition.description : OPTIONAL text;
  SELF\product_definition.formation : risk_perception_formation;
  SELF\product_definition.frame_of_reference RENAMED risk_perception_context : risk_perception_context;
  risk_probability : risk_probability_assignment;
  risk_consequence : SET[1:?] OF risk_consequence;
DERIVE
  SELF\product_definition.name : label := SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
WHERE
wr1  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_perception_context
  SUBTYPE OF (risk_application_context_element);
END_ENTITY;

ENTITY risk_perception_formation
  SUBTYPE OF (product_definition_formation);
  SELF\product_definition_formation.id : identifier;
  SELF\product_definition_formation.description : OPTIONAL text;
  SELF\product_definition_formation.of_product RENAMED of_risk : risk;
END_ENTITY;

ENTITY risk_perception_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.id : identifier;
  SELF\product_definition_relationship.name : label;
  SELF\product_definition_relationship.description : OPTIONAL text;
  relating_risk_perception : SET[1:?] OF risk_perception;
  related_risk_perception : SET[1:?] OF risk_perception;
  probability : OPTIONAL risk_probability_assignment;
END_ENTITY;

ENTITY risk_person_and_organization_stakeholder
  SUBTYPE OF (person_and_organization, risk_stakeholder);
  SELF\person_and_organization.the_person : risk_person_stakeholder;
  SELF\person_and_organization.the_organization : risk_organization_stakeholder;
DERIVE
  SELF\person_and_organization.description : text := get_description_value (SELF);
  SELF\person_and_organization.name : label := get_name_value (SELF);
WHERE
wr1  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
wr2  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_person_stakeholder
  SUBTYPE OF (person, risk_stakeholder);
  SELF\person.id : identifier;
  SELF\person.last_name : OPTIONAL label;
  SELF\person.first_name : OPTIONAL label;
  SELF\person.middle_names : OPTIONAL LIST[1:?] OF label;
  SELF\person.prefix_titles : OPTIONAL LIST[1:?] OF label;
  SELF\person.suffix_titles : OPTIONAL LIST[1:?] OF label;
WHERE
wr1  : EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY risk_probability
  SUBTYPE OF (representation);
  SELF\representation.name : label;
  SELF\representation.context_of_items : representation_context;
  SELF\representation.items : SET[1:?] OF representation_item;
DERIVE
  SELF\representation.description : text := get_description_value (SELF);
  SELF\representation.id : identifier := get_id_value (SELF);
WHERE
wr1  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
wr2  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_probability_assignment
  ABSTRACT SUPERTYPE ;
  assigned_risk_probability : risk_probability;
DERIVE
  role : object_role := get_role (SELF);
WHERE
wr1  : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY risk_reduction
  SUBTYPE OF (action);
  SELF\action.name : label;
  SELF\action.description : OPTIONAL text;
  approach : risk_treatment;
  resolves : SET[1:?] OF mitigation_select;
  risk_evaluation : OPTIONAL risk_evaluation;
DERIVE
  SELF\action.id : identifier := get_id_value (SELF);
WHERE
wr1  : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY risk_relationship
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.id : identifier;
  SELF\product_relationship.name : label;
  SELF\product_relationship.description : OPTIONAL text;
  SELF\product_relationship.relating_product RENAMED relating_risk : risk;
  SELF\product_relationship.related_product RENAMED related_risk : risk;
END_ENTITY;

ENTITY risk_resource
  SUBTYPE OF (action_resource);
  SELF\action_resource.name : label;
  SELF\action_resource.description : OPTIONAL text;
  SELF\action_resource.usage : SET[1:?] OF risk_supported_item;
  SELF\action_resource.kind : label;
END_ENTITY;

ENTITY risk_resource_assignment
  ABSTRACT SUPERTYPE ;
  assigned_risk_resource : risk_resource;
  role : risk_resource_role;
END_ENTITY;

ENTITY risk_resource_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY risk_source_assignment
  ABSTRACT SUPERTYPE ;
  assigned_risk : risk;
  risk_context : risk_context;
END_ENTITY;

ENTITY risk_stakeholder
  ABSTRACT SUPERTYPE ;
END_ENTITY;

ENTITY risk_status_assignment
  SUBTYPE OF (state_observed_assignment);
  SELF\state_observed_assignment.assigned_state_observed : state_observed;
  SELF\state_observed_assignment.role : state_observed_role;
  risk : risk;
END_ENTITY;

ENTITY risk_treatment
  SUBTYPE OF (action_method);
  SELF\action_method.name : label;
  SELF\action_method.description : OPTIONAL text;
  SELF\action_method.consequence RENAMED primary_objective : mitigation_select;
  SELF\action_method.purpose RENAMED risk_analysis : risk_analysis;
  secondary_objectives : SET[0:?] OF mitigation_select;
END_ENTITY;

ENTITY source_identification
  SUBTYPE OF (risk_identification);
  risk_source_assignment : risk_source_assignment;
END_ENTITY;

END_SCHEMA;  -- risk_schema
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA security_classification_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;

END_SCHEMA;  -- security_classification_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 part of:
ISO TC184/SC4/WG12 N3213 - ISO/IS 10303-54 Classification and set theory - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1510
*) 


SCHEMA set_theory_schema;

REFERENCE FROM classification_schema   -- ISO 10303-54
  (class); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 


ENTITY complement;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  set_1 : class;
  set_2 : class;
  universe : class;
WHERE
  complement_different: NOT identical_sets(set_1, set_2);
END_ENTITY;

ENTITY intersection;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  operand : SET[2:?] OF class;
  resultant : class;
END_ENTITY;

ENTITY power_set;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  base : class;
  derived : class;
WHERE
  derived_different: NOT identical_sets(base, derived);
END_ENTITY;

ENTITY proper_subset
  SUBTYPE OF (subset);
WHERE
  subset_different: NOT identical_sets(superset, subset);
END_ENTITY;

ENTITY same_membership;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  set_1 : class;
  set_2 : class;
END_ENTITY;

ENTITY subset;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  subset : class;
  superset : class;
END_ENTITY;

ENTITY union;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  operand : SET[2:?] OF class;
  resultant : class;
END_ENTITY;

ENTITY union_of_all_members;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  operand : class;
  resultant : class;
WHERE
  resultant_different: NOT identical_sets(operand, resultant);
END_ENTITY;

FUNCTION identical_sets
 (set_a : class; set_b : class) : BOOLEAN; 
  LOCAL
    set_of_sets : SET OF class := [];
  END_LOCAL;
  
  IF (set_a = set_b) THEN
    RETURN (TRUE);
  END_IF;
  
  set_of_sets := set_of_sets + set_b;
  RETURN (identical_to_one_of_set_of_sets(set_a, set_of_sets));
      END_FUNCTION; 

FUNCTION identical_to_one_of_set_of_sets
 (set_a : class; set_of_sets : SET OF class) : BOOLEAN; 
  LOCAL
    i                            : INTEGER;
    initial_size                 : INTEGER;
    augmented_size               : INTEGER;
    set_of_forward_equivalences  : SET OF same_membership := [];
    set_of_backward_equivalences : SET OF same_membership := [];
    augmented_set_of_sets        : SET OF class := [];
  END_LOCAL;
  
  --  test membership of the specified set of sets
  
  IF (set_a IN set_of_sets) THEN
    RETURN (TRUE);
  END_IF;
  
  --  extend the specified set to include all sets that have the same membership
  --  as an existing member
  
  initial_size := SIZEOF(set_of_sets);
  IF (initial_size = 0) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO initial_size;
    set_of_forward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_1');
    set_of_backward_equivalences := set_of_forward_equivalences +
      USEDIN(set_of_sets[i], 'SET_THEORY_SCHEMA.SAME_MEMBERSHIP.SET_2');
  END_REPEAT;
  
  augmented_set_of_sets := set_of_sets;
  IF (SIZEOF(set_of_forward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_forward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_forward_equivalences[i].set_2;
    END_REPEAT;
  END_IF;
  IF (SIZEOF(set_of_backward_equivalences) > 0) THEN
    REPEAT i := 1 to HIINDEX(set_of_backward_equivalences);
      augmented_set_of_sets := augmented_set_of_sets +
        set_of_backward_equivalences[i].set_1;
    END_REPEAT;
  END_IF;
  
  -- if the specified set of sets has been augmented, then test membership
  
  augmented_size := SIZEOF(augmented_set_of_sets);
  IF augmented_size = initial_size THEN
    RETURN (FALSE);
  END_IF;
  
  RETURN (identical_to_one_of_set_of_sets(set_a, augmented_set_of_sets));
      END_FUNCTION; 

END_SCHEMA;  -- set_theory_schema
(* Genenerated from: ../../irs/wg12n548.exp *)

SCHEMA shape_aspect_definition_schema;
REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);
REFERENCE FROM measure_schema
    (measure_with_unit);
REFERENCE FROM support_resource_schema
    (bag_to_set, label, identifier);

TYPE limit_condition = ENUMERATION OF
  (maximum_material_condition,
   least_material_condition,
   regardless_of_feature_size);
END_TYPE;

ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification               :identifier;
INVERSE
  established_by_relationships : SET [1:?] OF shape_aspect_relationship
                                 FOR related_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\datum.established_by_relationships |
       SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* 
       ['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE', 
       'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET']) <> 1))=0;
END_ENTITY;

ENTITY datum_feature
   SUBTYPE OF (shape_aspect);
INVERSE 
   feature_basis_relationship : shape_aspect_relationship
                              FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'+
       'RELATING_SHAPE_ASPECT'))
       | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF
       (sar\shape_aspect_relationship.related_shape_aspect))))=0;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id             : identifier; 
INVERSE
  target_basis_relationship : shape_aspect_relationship FOR
                              relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +
       'RELATING_SHAPE_ASPECT'))
      | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF 
      (sar\shape_aspect_relationship.related_shape_aspect))))=0;
   WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_reference;
  precedence       : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;

ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;

ENTITY composite_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET [2:?] OF shape_aspect_relationship
                            FOR relating_shape_aspect;
END_ENTITY;

ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (apex,
                       centre_of_symmetry,
                       geometric_alignment,
                       geometric_intersection,
                       parallel_offset,
                       perpendicular_to,
                       extension,
                       tangent))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET [1:?] OF
          shape_aspect_relationship FOR relating_shape_aspect;
WHERE
   WR1: SIZEOF (QUERY (dr <*
          SELF\derived_shape_aspect.deriving_relationships |
          NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.' +
               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'
          IN TYPEOF (dr)))) = 0;
END_ENTITY;

ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY centre_of_symmetry 
   SUBTYPE OF (derived_shape_aspect);
WHERE
    WR1: SIZEOF
        (QUERY(sadr<*SELF\derived_shape_aspect.deriving_relationships|
    NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.SYMMETRIC_SHAPE_ASPECT'
     IN TYPEOF
     (sadr\shape_aspect_relationship.related_shape_aspect))))=0; 
END_ENTITY;

ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset               : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY shape_aspect_deriving_relationship
       SUBTYPE OF (shape_aspect_relationship);
     WHERE
       WR1: 'SHAPE_ASPECT_DEFINITION_SCHEMA.DERIVED_SHAPE_ASPECT' IN
TYPEOF
            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
     END_ENTITY;

ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET [1:?] OF shape_aspect_relationship
                        FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF (QUERY (x<*SELF\symmetric_shape_aspect.basis_relationships |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.CENTRE_OF_SYMMETRY' IN TYPEOF 
       (x\shape_aspect_relationship.related_shape_aspect)))>=1;
END_ENTITY;

END_SCHEMA;  --  shape_aspect_definition_schema
(* Genenerated from: ../../irs/wg12n548.exp *)

SCHEMA shape_dimension_schema;
REFERENCE FROM measure_schema
   (measure_with_unit);
REFERENCE FROM representation_schema
    (representation);
REFERENCE FROM qualified_measure_schema
    (measure_representation_item, 
     qualified_representation_item);
REFERENCE FROM product_property_representation_schema
    (shape_representation);
REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);
REFERENCE FROM support_resource_schema
    (label,
     text);

TYPE angle_relator = ENUMERATION OF
  (equal,
   large,
   small);
END_TYPE;

TYPE dimensional_characteristic = SELECT (dimensional_location,
                                          dimensional_size);
END_TYPE;

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension      : dimensional_characteristic; 
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (angular_location,
                       dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (angular_size,
                       dimensional_size_with_path));
  applies_to : shape_aspect;
  name       : label;
WHERE
  WR1: applies_to.product_definitional = TRUE;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY shape_dimension_representation
                SUBTYPE OF (shape_representation);
  WHERE
   WR1: SIZEOF (QUERY (temp <* SELF\representation.items | 
    NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF (temp)))) = 0;
   WR2: SIZEOF (SELF\representation.items) <= 3;
   WR3: SIZEOF (QUERY (pos_mri <* QUERY (real_mri <*
        SELF\representation.items | 'REAL' IN TYPEOF
        (real_mri\measure_with_unit.value_component) ) |        
     NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
END_ENTITY;

END_SCHEMA;   --  shape_dimension_schema
(* Genenerated from: ../../irs/wg12n548.exp *)

SCHEMA shape_tolerance_schema;
REFERENCE FROM product_property_definition_schema
    (shape_aspect,
     shape_aspect_relationship);
REFERENCE FROM measure_schema
   (derive_dimensional_exponents,
    dimensional_exponents,
    measure_with_unit,
    measure_value);
REFERENCE FROM representation_schema
    (representation);
REFERENCE FROM support_resource_schema
    (label,
     text);
REFERENCE FROM shape_aspect_definition_schema
    (datum_reference,
     limit_condition);
REFERENCE FROM shape_dimension_schema
    (dimensional_characteristic,
     dimensional_location);

TYPE tolerance_method_definition = SELECT
  (tolerance_value,
   limits_and_fits);
END_TYPE;

TYPE  shape_tolerance_select = SELECT
     (geometric_tolerance,
      plus_minus_tolerance);
END_TYPE;

ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location; 
  related_element   : tolerance_zone_definition;
END_ENTITY;

ENTITY geometric_tolerance;
  name                    : label;
  description             : text;
  magnitude               : measure_with_unit; 
  toleranced_shape_aspect : shape_aspect; 
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (magnitude\measure_with_unit.value_component)) AND
       (magnitude\measure_with_unit.value_component >= 0.0);
END_ENTITY;

ENTITY geometric_tolerance_relationship;
                                   name                         :label;
                                   description                  :text;
                                   relating_geometric_tolerance : geometric_tolerance; 
                                   related_geometric_tolerance  : geometric_tolerance; 
END_ENTITY;

ENTITY geometric_tolerance_with_datum_reference
   SUBTYPE OF (geometric_tolerance);
   datum_system : SET [1:?] OF  datum_reference;
END_ENTITY;

ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF
       (unit_size\measure_with_unit.value_component)) AND
       (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;

ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;

ENTITY projected_zone_definition 
  SUBTYPE OF (tolerance_zone_definition);  
  projection_end   : shape_aspect; 
  projected_length : measure_with_unit;
WHERE 
  WR1: ('NUMBER' IN TYPEOF
       (projected_length\measure_with_unit.value_component)) AND
       (projected_length\measure_with_unit.value_component > 0.0);
  WR2: (derive_dimensional_exponents
       (projected_length\measure_with_unit.unit_component)=
        dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;

ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition); 
  orientation  : runout_zone_orientation;
END_ENTITY;

ENTITY runout_zone_orientation;
  angle : measure_with_unit;
END_ENTITY;

ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation); 
  orientation_defining_relationship: shape_aspect_relationship;
END_ENTITY;

ENTITY statistical_distribution_for_tolerance
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
       NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (item)))) = 0;
END_ENTITY;

ENTITY tolerance_with_statistical_distribution;
   associated_tolerance : shape_tolerance_select;
   tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY;

ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET [1:?] OF geometric_tolerance; 
  form               : tolerance_zone_form;
END_ENTITY;

ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;

ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (projected_zone_definition,
                       runout_zone_definition));
  zone : tolerance_zone;
  boundaries: SET [1:?] OF shape_aspect;
END_ENTITY;

ENTITY limits_and_fits;
  form_variance   : label;
  zone_variance   : label;
  grade           : label;
  source          : text;
END_ENTITY;

ENTITY  plus_minus_tolerance;
  range                : tolerance_method_definition; 
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;

ENTITY tolerance_value; 
   lower_bound : measure_with_unit; 
   upper_bound : measure_with_unit;
WHERE 
   WR1: upper_bound\measure_with_unit.value_component >
        lower_bound\measure_with_unit.value_component;  
   WR2: upper_bound\measure_with_unit.unit_component =
        lower_bound\measure_with_unit.unit_component;
END_ENTITY;

END_SCHEMA;   -- End of shape_tolerance_schema
(* Genenerated from: 10303-108.exp *)

SCHEMA sketch_schema;

REFERENCE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation);

REFERENCE FROM support_resource_schema                -- ISO 10303-41
  (bag_to_set);

REFERENCE FROM geometry_schema;                       -- ISO 10303-42

REFERENCE FROM topology_schema                        -- ISO 10303-42
  (edge_curve,
   edge_loop,
   face_surface,
   oriented_edge,
   poly_loop,
   vertex_loop,
   vertex_point);

REFERENCE FROM geometric_model_schema;                -- ISO 10303-42

REFERENCE FROM representation_schema                  -- ISO 10303-43
  (mapped_item,
   representation,
   representation_relationship);

--REFERENCE FROM parameterization_schema;               -- ISO 10303-108

REFERENCE FROM explicit_constraint_schema;            -- ISO 10303-108

REFERENCE FROM variational_representation_schema;     -- ISO 10303-108

REFERENCE FROM explicit_geometric_constraint_schema;  -- ISO 10303-108

REFERENCE FROM ISO13584_generic_expressions_schema    -- ISO 13584-20
  (used_variables);

REFERENCE FROM ISO13584_expressions_schema;           -- ISO 13584-20

TYPE implicit_imported_element = SELECT
  (implicit_point_on_plane,
   implicit_planar_curve);
END_TYPE;

TYPE surface_or_solid_model = SELECT
  (surface_model,
   solid_model); 
END_TYPE;

TYPE neutral_sketch_select = SELECT
  (neutral_sketch_representation,
   variational_neutral_sketch_representation);
END_TYPE;

TYPE sketch_basis_select = SELECT
  (planar_curve,
   planar_face_surface,
   repositioned_neutral_sketch);
END_TYPE;

ENTITY planar_curve
  SUPERTYPE OF (ONEOF(variational_planar_curve,
                      implicit_planar_curve))
  SUBTYPE OF (curve);
  curve_plane : plane;
END_ENTITY;

ENTITY planar_face_surface
  SUPERTYPE OF (variational_planar_face_surface)
  SUBTYPE OF (face_surface);
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN 
    TYPEOF(SELF\face_surface.face_geometry);
END_ENTITY;

ENTITY implicit_point_on_plane
  ABSTRACT SUPERTYPE OF (ONEOF
    (implicit_planar_intersection_point,
     implicit_planar_projection_point))
  SUBTYPE OF (point, auxiliary_geometric_representation_item);
  using_sketch   : variational_positioned_sketch_representation;
  computed_representation 
                 : cartesian_point;
DERIVE
  plane_of_point : 
    plane := get_plane_of_implicit_geometry(using_sketch);
WHERE
  WR1: (plane_of_point\elementary_surface.position.location = 
    computed_representation) XOR
    (dot_product(plane_of_point\elementary_surface.position.p[3],
    get_relative_direction_2points
    (plane_of_point\elementary_surface.position.location, 
    computed_representation)) = 0);
END_ENTITY;

ENTITY implicit_planar_intersection_point
  SUBTYPE OF (implicit_point_on_plane);
  external_curve : curve;
END_ENTITY;

ENTITY implicit_planar_projection_point
  SUBTYPE OF (implicit_point_on_plane);
  external_point       : point;
  projection_direction : direction;
END_ENTITY;

ENTITY implicit_planar_curve
  ABSTRACT SUPERTYPE OF (ONEOF
    (implicit_intersection_curve,
     implicit_projected_curve,
     implicit_model_intersection_curve,
     implicit_silhouette_curve))
  SUBTYPE OF (planar_curve, auxiliary_geometric_representation_item);
  using_sketch            : variational_positioned_sketch_representation;
  computed_representation : planar_curve;
WHERE
  WR1: SELF\planar_curve.curve_plane 
    :=: get_plane_of_implicit_geometry(using_sketch);
END_ENTITY;

ENTITY implicit_intersection_curve
  SUBTYPE of (implicit_planar_curve);
  external_surface : surface;
END_ENTITY;

ENTITY implicit_projected_curve
  SUBTYPE of (implicit_planar_curve);
  external_curve       : curve;
  projection_direction : direction;
END_ENTITY;

ENTITY implicit_model_intersection_curve
  SUBTYPE of (implicit_planar_curve);
  intersected_model : surface_or_solid_model;
END_ENTITY;

ENTITY implicit_silhouette_curve
  SUBTYPE of (implicit_planar_curve);
  silhouetted_model : surface_or_solid_model;
  view_direction    : direction;
END_ENTITY;

ENTITY variational_planar_curve
  SUBTYPE OF (planar_curve);
  variational_elements : SET[1:?] OF variational_representation_item;
WHERE
  WR1: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.BOUND_MODEL_PARAMETER' IN TYPEOF(q)) 
    AND NOT (q.interpretation.semantics.owning_instance 
    IN unpack_composite_curve(SELF\planar_curve)))) = 0;
  WR2: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.UNBOUND_MODEL_PARAMETER' IN TYPEOF(q)) 
    AND (SIZEOF(QUERY(r <* variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.FREE_FORM_CONSTRAINT' IN TYPEOF(r))
    AND (q IN used_variables(r.constraining_expression)))) = 0))) = 0;
  WR3: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.FIXED_INSTANCE_ATTRIBUTE_SET' IN TYPEOF(q))
    AND (SIZEOF(QUERY(r <* q.fixed_attributes | NOT (r.owning_instance 
    IN unpack_composite_curve(SELF\planar_curve)))) = 0))) = 0;
  WR4: SIZEOF(QUERY(q <* variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) AND
    (SIZEOF(QUERY(r <* (q.constrained_elements + q.reference_elements) | 
    NOT (r IN unpack_composite_curve(SELF\planar_curve)))) = 0))) = 0;
  WR5: SIZEOF(QUERY(q <* variational_elements |
    'EXPLICIT_CONSTRAINT_SCHEMA.AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM'
    IN TYPEOF(q))) = 0;
END_ENTITY;

ENTITY variational_planar_face_surface
  SUBTYPE OF (planar_face_surface);
  variational_elements : SET[1:?] OF variational_representation_item;
WHERE
  WR1: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.BOUND_MODEL_PARAMETER' IN TYPEOF(q)) 
    AND NOT (q.interpretation.semantics.owning_instance 
    IN unpack_face_bounds(SELF\face)))) = 0;
  WR2: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.UNBOUND_MODEL_PARAMETER' IN TYPEOF(q))
    AND (SIZEOF(QUERY(r <* variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.FREE_FORM_CONSTRAINT' IN TYPEOF(r))
    AND (q IN used_variables(r.constraining_expression)))) = 0))) = 0;
  WR3: SIZEOF(QUERY(q <* variational_elements | 
    ('PARAMETERIZATION_SCHEMA.FIXED_INSTANCE_ATTRIBUTE_SET' IN TYPEOF(q))
    AND (SIZEOF(QUERY(r <* q.fixed_attributes | NOT
    (r.owning_instance IN unpack_face_bounds(SELF\face)))) = 0))) = 0;
  WR4: SIZEOF(QUERY(q <* variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) AND
    (SIZEOF(QUERY(r <* (q.constrained_elements + q.reference_elements) |
    NOT (r IN unpack_face_bounds(SELF\face)))) = 0))) = 0;
  WR5: SIZEOF(QUERY(q <* variational_elements |
    'EXPLICIT_CONSTRAINT_SCHEMA.AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM'
    IN TYPEOF(q))) = 0;
END_ENTITY;

ENTITY sketch_representation
  ABSTRACT SUPERTYPE OF 
    (ONEOF(neutral_sketch_representation,
           positioned_sketch_representation,
           variational_neutral_sketch_representation,
           variational_positioned_sketch_representation,
           (subsketch AND neutral_sketch_representation),
           (subsketch AND positioned_sketch_representation)))
  SUBTYPE OF (shape_representation);
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' 
    IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY neutral_sketch_representation
  SUBTYPE OF (sketch_representation);
  sketch_geometry : geometric_curve_set;
DERIVE
  SELF\representation.items : SET[1:?] OF geometric_representation_item
    := sketch_geometry.elements;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\representation.items | q.dim <> 2)) = 0;
END_ENTITY;

ENTITY variational_neutral_sketch_representation
  SUBTYPE OF (sketch_representation, 
              variational_representation);
  variational_data : SET[1:?] OF variational_representation_item;
DERIVE
  SELF\representation.items : SET[1:?] OF representation_item :=
  SELF\variational_representation.cm_link.rep_2.sketch_geometry.elements 
  + variational_data;
WHERE
  WR1: 'SKETCH_SCHEMA.NEUTRAL_SKETCH_REPRESENTATION' IN
    TYPEOF(SELF\variational_representation.cm_link.rep_2);
  WR2: SIZEOF(QUERY(q <* variational_data | 
    ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(q)) 
    AND (q.dim <> 2))) = 0;
  WR3: SIZEOF(QUERY(q <* variational_data | 
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) AND
    (SIZEOF(QUERY(r <* (q\explicit_constraint.constrained_elements +
    q\explicit_constraint.reference_elements) | 
    NOT (r IN unpack_curve_set(
    SELF\variational_representation.cm_link.rep_2.sketch_geometry 
    )))) <> 0))) = 0;
END_ENTITY;

ENTITY repositioned_neutral_sketch
  SUBTYPE OF (mapped_item, geometric_representation_item);
DERIVE
  map : representation_map 
        := SELF\mapped_item.mapping_source;
WHERE
  WR1 : 'SKETCH_SCHEMA.NEUTRAL_SKETCH_SELECT'
    IN TYPEOF(map.mapped_representation);
  WR2 : 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN 
    TYPEOF(map.mapping_origin);
  WR3 : 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN 
    TYPEOF(SELF\mapped_item.mapping_target);
END_ENTITY;

ENTITY repositioned_variational_data
  SUBTYPE OF (mapped_item, variational_representation_item);
  sketch_geometry 
      : repositioned_neutral_sketch;
DERIVE
  map : representation_map 
        := SELF\mapped_item.mapping_source;
WHERE
  WR1: 'SKETCH_SCHEMA.VARIATIONAL_NEUTRAL_SKETCH_REPRESENTATION'
    IN TYPEOF(map.mapped_representation);
  WR2: (map.mapped_representation :=: 
    sketch_geometry.map.mapped_representation)
    AND (map.mapping_origin :=:
    sketch_geometry.map.mapping_origin)
    AND (SELF\mapped_item.mapping_target :=:
    sketch_geometry\mapped_item.mapping_target);
  WR3: sketch_geometry.map.mapped_representation
    :=: map.mapped_representation\variational_representation.cm_link.rep_2;
  WR4: (SIZEOF(QUERY(q <* 
    map.mapped_representation.variational_data
    | ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(q)))) = 0)
    XOR ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF));
END_ENTITY;

ENTITY positioned_sketch_representation
  SUBTYPE OF (sketch_representation);
  sketch_basis              : sketch_basis_select;
DERIVE
  SELF\representation.items : SET[1:?] OF geometric_representation_item
    := collect_geometric_sketch_items(SELF);
END_ENTITY;

ENTITY variational_positioned_sketch_representation
  SUBTYPE OF (sketch_representation,
              variational_representation);
  sketch_basis      : sketch_basis_select;
  imported_geometry : SET[0:?] OF implicit_imported_element;
  imported_variational_elements 
                    : SET[0:?] OF variational_representation_item;
DERIVE
  SELF\representation.items     
                    : SET[1:?] OF representation_item
                      := collect_all_sketch_items(SELF);
WHERE
  WR1: SIZEOF(QUERY(q <* imported_variational_elements | 
    ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(q))
    AND (q\geometric_representation_item.dim <> 3))) = 0;
  WR2: (SIZEOF(imported_geometry) > 0) OR
    ((SIZEOF(TYPEOF(sketch_basis) *
    ['SKETCH_SCHEMA.VARIATIONAL_PLANAR_CURVE',
     'SKETCH_SCHEMA.VARIATIONAL_PLANAR_FACE_SURFACE']) = 1) XOR
    (('SKETCH_SCHEMA.REPOSITIONED_NEUTRAL_SKETCH' 
    IN TYPEOF(sketch_basis)) AND 
    ('SKETCH_SCHEMA.VARIATIONAL_NEUTRAL_SKETCH_REPRESENTATION' 
    IN TYPEOF(sketch_basis.map.mapped_representation))));
  WR3: ('SKETCH_SCHEMA.POSITIONED_SKETCH_REPRESENTATION' IN TYPEOF(
    SELF\variational_representation.cm_link.rep_2))
    AND (sketch_basis :=: 
    SELF\variational_representation.cm_link.rep_2.sketch_basis);
  WR4: (SIZEOF(imported_geometry) = 0) XOR
    (SIZEOF(QUERY(q <* imported_geometry |
    SIZEOF(QUERY(r <* imported_variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(r))
    AND NOT (q IN r\explicit_constraint.reference_elements))) = 0)) = 0);
  WR5: (SIZEOF(imported_geometry) = 0) XOR
    (SIZEOF(QUERY(q <* imported_geometry |
    SIZEOF(QUERY(r <* imported_variational_elements |
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(r))
    AND (q IN r\explicit_constraint.constrained_elements))) > 0)) = 0);
END_ENTITY;

ENTITY subsketch
SUBTYPE OF (sketch_representation); 
  subsketch_elements : geometric_curve_set; 
  owning_sketch      : sketch_representation;
WHERE
  WR1: SELF\representation.context_of_items :=: 
    owning_sketch\representation.context_of_items;
  WR2: SIZEOF(USEDIN(SELF,
    'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2') *
    USEDIN(SELF.owning_sketch,
    'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) = 1;
  WR3: SIZEOF(QUERY(q <* subsketch_elements\geometric_set.elements | 
    NOT (q IN owning_sketch\representation.items))) = 0;
END_ENTITY;

ENTITY rigid_subsketch
  SUBTYPE OF (subsketch); 
END_ENTITY;

FUNCTION get_relative_direction_2points 
           (cp1, cp2 : cartesian_point) : direction;

  LOCAL
    d1, d2, d3, magnitude : real;
    result                : direction := ?;  
  END_LOCAL;

  -- check that input points are three-dimensional

  IF ((cp1.dim <> 3) OR (cp2.dim <> 3)) THEN 
    RETURN(result);
  ELSE

    -- construct components of vector and compute its magnitude

    BEGIN
      d1 := cp2.coordinates[1] - cp1.coordinates[1];
      d2 := cp2.coordinates[2] - cp1.coordinates[2];
      d3 := cp2.coordinates[3] - cp1.coordinates[3];
      magnitude := sqrt(d1*d1 + d2*d2 + d3*d3);
      IF (magnitude = 0) THEN 
        return(result); -- direction is indeterminate in this case
      END_IF;
      result := dummy_gri || direction([d1, d2, d3]);
    END;
  END_IF;
  RETURN(result);

END_FUNCTION;

FUNCTION get_plane_of_implicit_geometry
         (psr : positioned_sketch_representation) : plane;

  LOCAL
    sb     : sketch_basis_select := psr.sketch_basis;
    result : plane := ?;
  END_LOCAL;

  -- determine plane of implicit geometry from the underlying entity data
  -- type of its owning instance of positioned_sketch_representation

  IF ('SKETCH_SCHEMA.PLANAR_FACE_SURFACE' IN TYPEOF(sb)) THEN 
    result := sb\face_surface.face_geometry;
  ELSE
    IF ('SKETCH_SCHEMA.PLANAR_CURVE' IN TYPEOF(sb)) THEN
      result := sb.curve_plane;
    END_IF;
  END_IF;
  RETURN(result);

END_FUNCTION;

FUNCTION unpack_curve_set(gcs : geometric_curve_set) 
                              : SET[1:?] OF geometric_set_select;

  LOCAL
    element : geometric_set_select;
    gss_bag : BAG[0:?] OF geometric_set_select := [];
    i,j     : INTEGER;
  END_LOCAL;

  -- examine each member of the geometric_curve_set instance, putting
  -- it into the gss_set if it is a simple point or curve, and the 
  -- underlying curves of its segments if it is a composite_curve

  REPEAT i := 1 TO SIZEOF(gcs\geometric_set.elements);
    element := gcs\geometric_set.elements[i];
    IF ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(element)) THEN
      REPEAT j := 1 TO element.n_segments;
        gss_bag := gss_bag + element.segments[j];
      END_REPEAT;
    ELSE 
      IF (('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(element)) OR 
          ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(element))) THEN
        gss_bag := gss_bag + element;
      END_IF;
    END_IF;
  END_REPEAT;

  -- convert gss_bag into a set of unique elements  

  RETURN(bag_to_set(gss_bag));

END_FUNCTION;

FUNCTION unpack_composite_curve (cur : curve) 
                                     : SET[1:?] OF geometric_set_select;

  LOCAL
    gss_bag : BAG[0:?] OF curve := [];
    i       : INTEGER;
  END_LOCAL;

  -- examine each segment of the input curve instance, if it is composite,
  -- and put its underlying curve into the gss_bag; if it is not composite,
  -- put the curve itself into the gss_bag

  IF ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(cur)) THEN
    REPEAT i := 1 TO cur.n_segments;
      gss_bag := gss_bag + cur.segments[i];
    END_REPEAT;
  ELSE 
    gss_bag := gss_bag + cur;
  END_IF;
  
  -- convert gss_bag into a set of unique elements

  RETURN(bag_to_set(gss_bag));

END_FUNCTION;

FUNCTION unpack_face_bounds(f : face) : SET[1:?] OF geometric_set_select;

  LOCAL
    fbb     : loop;
    oe      : oriented_edge;
    gss_bag : BAG[0:?] OF geometric_set_select := [];
    i,j     : INTEGER;
  END_LOCAL;
  
  -- cycle through all the bounds of the face, putting underlying points
  -- of all vertices and underlying curves of all edges into the gss_bag,
  -- unpacking composite curves into simple components where necessary

  REPEAT i := 1 TO SIZEOF(f.bounds);
    fbb := f.bounds[i].bound;
    IF ('TOPOLOGY_SCHEMA.VERTEX_LOOP' IN TYPEOF(fbb)) THEN
      IF ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF(fbb.loop_vertex)) THEN
        gss_bag := gss_bag + fbb.loop_vertex.vertex_geometry;
      END_IF;
    END_IF; 
    IF ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(fbb)) THEN
      REPEAT j := 1 TO fbb.ne;
        BEGIN
          oe := fbb\path.edge_list[j];
          IF ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe)) THEN
            gss_bag := gss_bag 
              + unpack_composite_curve(oe.edge_element.edge_geometry);
          END_IF;
          IF ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_start)) THEN
            gss_bag := gss_bag + oe.edge_start.vertex_geometry;
          END_IF; 
          IF ('TOPOLOGY_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end)) THEN
            gss_bag := gss_bag + oe.edge_end.vertex_geometry;
          END_IF; 
        END;
      END_REPEAT;
    END_IF;
    IF ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(fbb)) THEN
      REPEAT j := 1 TO HIINDEX(fbb.polygon);
        gss_bag := gss_bag + fbb.polygon[j];
      END_REPEAT;
    END_IF;
  END_REPEAT;

  -- convert gss_bag into a set of unique elements

  RETURN(bag_to_set(gss_bag));

END_FUNCTION;

FUNCTION collect_geometric_sketch_items 
  (psr : positioned_sketch_representation) :  
    SET[1:?] OF geometric_representation_item;

  LOCAL
    sb     : sketch_basis_select := psr.sketch_basis;
    result : SET[1:?] OF geometric_representation_item;  
  END_LOCAL;

  -- collect defining geometric_representation_items appropriate to 
  -- type of sketch basis

  IF ('SKETCH_SCHEMA.PLANAR_CURVE' IN TYPEOF(sb)) 
  THEN
      result := unpack_composite_curve(sb);
  ELSE
    IF ('SKETCH_SCHEMA.PLANAR_FACE_SURFACE' IN TYPEOF(sb)) 
    THEN 
      result := unpack_face_bounds(sb);
    ELSE -- sketch basis is a repositioned neutral sketch
	result := [sb]; -- a single mapped item
    END_IF;
  END_IF;
  RETURN(result);

END_FUNCTION;

FUNCTION collect_all_sketch_items 
  (vpsr : variational_positioned_sketch_representation) :  
    SET[1:?] OF representation_item;

  LOCAL
    sb     : sketch_basis_select 
               := vpsr\positioned_sketch_representation.sketch_basis;
    result : SET[1:?] OF representation_item;  
  END_LOCAL;

  -- collect defining representation items appropriate to type of 
  -- sketch basis

  IF ('SKETCH_SCHEMA.PLANAR_CURVE' IN TYPEOF(sb)) 
  THEN
    IF NOT ('SKETCH_SCHEMA.VARIATIONAL_PLANAR_CURVE' IN TYPEOF(sb))
    THEN
      result := [sb] +
      vpsr.imported_geometry + vpsr.imported_variational_elements;
    ELSE 
      result := [sb] + sb.variational_elements +
      vpsr.imported_geometry + vpsr.imported_variational_elements;
    END_IF;
  ELSE
    IF ('SKETCH_SCHEMA.PLANAR_FACE_SURFACE' IN TYPEOF(sb)) 
    THEN 
      IF NOT ('SKETCH_SCHEMA.VARIATIONAL_PLANAR_FACE_SURFACE' 
        IN TYPEOF(sb))
      THEN 
        result := unpack_face_bounds(sb) + 
        vpsr.imported_geometry + vpsr.imported_variational_elements;
      ELSE 
        result := unpack_face_bounds(sb) + sb.variational_elements + 
        vpsr.imported_geometry + vpsr.imported_variational_elements;
      END_IF;
    ELSE -- sketch basis is a repositioned neutral sketch
      IF NOT ('SKETCH_SCHEMA.VARIATIONAL_NEUTRAL_SKETCH_REPRESENTATION'
        IN TYPEOF(sb.map.mapped_representation))
      THEN
        result := [sb]; -- a single mapped item
      ELSE -- the neutral sketch is variational
        result := [sb] +  bag_to_set(USEDIN(sb,
        'SKETCH_SCHEMA.REPOSITIONED_VARIATIONAL_DATA.SKETCH_GEOMETRY')); 
      -- two mapped items (the relationship between a repositioned 
      -- neutral sketch and its variational data is unique, and USEDIN 
      -- will therefore return a set with only one member).
      END_IF;
    END_IF;
  END_IF;
  RETURN(result);

END_FUNCTION;

END_SCHEMA; -- sketch_schema
(* $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $ 
ISO TC184/SC4/WG12 N3207 - ISO/IS 10303-56 State - EXPRESS
Supersedes ISO TC184/SC4/WG12 N2465
*) 


SCHEMA state_observed_schema;

REFERENCE FROM state_type_schema   -- ISO 10303-56
  (state_type); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY ascribable_state;
  name : label;
  description : OPTIONAL text;
  pertaining_state_type : state_type;
  ascribed_state_observed : state_observed;
END_ENTITY;

ENTITY ascribable_state_relationship;
  name : label;
  description : OPTIONAL text;
  relating_ascribable_state : ascribable_state;
  related_ascribable_state : ascribable_state;
END_ENTITY;

ENTITY state_observed;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_observed_assignment
  ABSTRACT SUPERTYPE ;
  assigned_state_observed : state_observed;
  role : state_observed_role;
END_ENTITY;

ENTITY state_observed_relationship;
  name : label;
  description : OPTIONAL text;
  relating_state_observed : SET[1:?] OF state_observed;
  related_state_observed : SET[1:?] OF state_observed;
END_ENTITY;

ENTITY state_observed_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

END_SCHEMA;  -- state_observed_schema
(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3207 - ISO/IS 10303-56 State - EXPRESS
Supersedes ISO TC184/SC4/WG12 N2465
*) 


SCHEMA state_type_schema;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (label,
   text); 


ENTITY state_type;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY state_type_assignment
  ABSTRACT SUPERTYPE ;
  assigned_state_type : state_type;
  role : state_type_role;
END_ENTITY;

ENTITY state_type_relationship;
  name : label;
  description : OPTIONAL text;
  relating_state_type : SET[1:?] OF state_type;
  related_state_type : SET[1:?] OF state_type;
END_ENTITY;

ENTITY state_type_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

END_SCHEMA;  -- state_type_schema
(* Genenerated from: ../../irs/wg12n550.exp *)

SCHEMA structural_response_definition_schema;

  REFERENCE FROM product_property_definition_schema
      (property_definition,
       shape_aspect);

ENTITY structural_response_property
  SUBTYPE OF (property_definition);
END_ENTITY;

ENTITY fea_model_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY node_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY element_definition
  SUBTYPE OF (shape_aspect);
END_ENTITY;

END_SCHEMA; -- structural_response_definition_schema
(* Genenerated from: ../../irs/wg12n550.exp *)

SCHEMA structural_response_representation_schema;

  REFERENCE FROM fea_scalar_vector_tensor_schema
      (scalar,
       symmetric_tensor2_2d,
       symmetric_tensor2_3d,
       symmetric_tensor4_2d,
       symmetric_tensor4_3d);

  REFERENCE FROM finite_element_analysis_control_and_result_schema
      (curve_element_variable,
       measure_or_unspecified_value,
       surface_2d_edge,
       surface_2d_face,
       surface_3d_edge,
       surface_3d_face,
       surface_element_variable,
       volume_2d_edge,
       volume_2d_face,
       volume_3d_edge,
       volume_3d_face,
       volume_variable);

  REFERENCE FROM geometric_model_schema 
      (solid_model);

  REFERENCE FROM geometry_schema 
      (axis2_placement_2d,
       axis2_placement_3d,
       cartesian_point,
       cross_product,
       curve,
       cylindrical_point,
       degenerate_pcurve,
       direction,
       geometric_representation_context,
       geometric_representation_item,
       normalise,
       point,
       point_on_curve,
       point_on_surface,
       point_replica,
       spherical_point,
       surface);

  REFERENCE FROM group_schema 
      (group,
       group_relationship);

  REFERENCE FROM material_property_definition_schema 
      (material_property);

  REFERENCE FROM material_property_representation_schema 
      (material_property_representation);

  REFERENCE FROM measure_schema 
      (context_dependent_measure,
       length_measure,
       parameter_value,
       plane_angle_measure,
       thermodynamic_temperature_measure);

  REFERENCE FROM product_property_representation_schema 
      (property_definition_representation);

  REFERENCE FROM representation_schema 
      (representation,
       representation_item,
       representation_relationship,
       using_representations);

  REFERENCE FROM structural_response_definition_schema
      (element_definition,
       fea_model_definition,
       node_definition,
       structural_response_property);

  REFERENCE FROM support_resource_schema 
      (identifier,
       label,
       text);

TYPE axi_or_plane = ENUMERATION OF
  (axisymmetric,
   planar);
END_TYPE;

TYPE coordinate_system_type = ENUMERATION OF
     (cartesian,
      cylindrical,
      spherical);
END_TYPE;

TYPE element_order = ENUMERATION OF
     (linear,
      quadratic,
      cubic);
END_TYPE;

TYPE plane_2d_element_purpose = SELECT
     (enumerated_plane_2d_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_plane_2d_element_purpose = ENUMERATION OF
     (plane_stress,
      plane_strain);
END_TYPE;

TYPE application_defined_element_purpose = STRING;
END_TYPE;

TYPE volume_element_purpose = SELECT
     (enumerated_volume_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_volume_element_purpose = ENUMERATION OF
     (stress_displacement);
END_TYPE;

TYPE surface_element_purpose = SELECT
     (enumerated_surface_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_surface_element_purpose = ENUMERATION OF
     (membrane_direct,
      membrane_shear,
      bending_direct,
      bending_torsion,
      normal_to_plane_shear);
END_TYPE;

TYPE curve_element_purpose = SELECT
     (enumerated_curve_element_purpose,
      application_defined_element_purpose);
END_TYPE;

TYPE enumerated_curve_element_purpose = ENUMERATION OF
     (axial,
      y_y_bending,
      z_z_bending,
      torsion,
      x_y_shear,
      x_z_shear,
      warping);
END_TYPE;

TYPE volume_3d_element_shape = ENUMERATION OF
     (hexahedron,
      wedge,
      tetrahedron,
      pyramid);
END_TYPE;

TYPE element_2d_shape = ENUMERATION OF
     (quadrilateral,
      triangle);
END_TYPE;

TYPE matrix_property_type = SELECT
  (enumerated_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_matrix_property_type = ENUMERATION OF
     (stiffness,
      mass,
      damping);
END_TYPE;

TYPE application_defined_matrix_property_type = STRING;
END_TYPE;

TYPE surface_matrix_property_type = SELECT
  (enumerated_surface_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_surface_matrix_property_type = ENUMERATION OF
     (membrane_direct,
      membrane_shear,
      bending_direct,
      bending_torsion,
      normal_to_plane_shear,
      membrane_direct_mass,
      membrane_shear_mass,
      bending_direct_mass,
      bending_torsion_mass,
      normal_to_plane_shear_mass,
      mass);
END_TYPE;

TYPE curve_matrix_property_type = SELECT
  (enumerated_curve_matrix_property_type,
   application_defined_matrix_property_type);
END_TYPE;

TYPE enumerated_curve_matrix_property_type = ENUMERATION OF
     (axial,
      y_y_bending,
      z_z_bending,
      torsion,
      x_y_shear,
      x_z_shear,
      warping,
      axial_mass,
      y_y_bending_mass,
      z_z_bending_mass,
      torsion_mass,
      x_y_shear_mass,
      x_z_shear_mass,
      warping_mass,
      mass);
END_TYPE;

TYPE matrix_symmetry = ENUMERATION OF
     (symmetric,
      diagonal);
END_TYPE;

TYPE degree_of_freedom = SELECT
  (enumerated_degree_of_freedom,
   application_defined_degree_of_freedom);
END_TYPE;

TYPE enumerated_degree_of_freedom = ENUMERATION OF
     (x_translation, y_translation, z_translation,
      x_rotation, y_rotation, z_rotation,
      warp);
END_TYPE;

TYPE application_defined_degree_of_freedom = STRING;
END_TYPE;

TYPE curve_element_freedom = SELECT
     (enumerated_curve_element_freedom,
      application_defined_degree_of_freedom);
END_TYPE;

TYPE enumerated_curve_element_freedom = ENUMERATION OF
     (x_translation, y_translation, z_translation,
      x_rotation, y_rotation, z_rotation,
      warp,
      none);
END_TYPE;

TYPE integration_rule = ENUMERATION OF
     (gaussian,
      simpson);
END_TYPE;

TYPE shape_function = ENUMERATION OF
     (lagrangian,
      serendipity,
      hermitian,
      unspecified);
END_TYPE;

TYPE volume_2d_element_representation = SELECT
  (axisymmetric_volume_2d_element_representation,
   plane_volume_2d_element_representation);
END_TYPE;

TYPE surface_2d_element_representation = SELECT
  (axisymmetric_surface_2d_element_representation,
   plane_surface_2d_element_representation);
END_TYPE;

TYPE curve_2d_element_representation = SELECT
  (axisymmetric_curve_2d_element_representation,
   plane_curve_2d_element_representation);
END_TYPE;

TYPE volume_2d_element_descriptor = SELECT
     (axisymmetric_volume_2d_element_descriptor,
      plane_volume_2d_element_descriptor);
END_TYPE;

TYPE surface_2d_element_descriptor = SELECT
     (axisymmetric_surface_2d_element_descriptor,
      plane_surface_2d_element_descriptor);
END_TYPE;

TYPE curve_2d_element_descriptor = SELECT
     (axisymmetric_curve_2d_element_descriptor,
      plane_curve_2d_element_descriptor);
END_TYPE;

TYPE volume_3d_element_coordinate_system = SELECT
  (arbitrary_volume_3d_element_coordinate_system,
   parametric_volume_3d_element_coordinate_system);
END_TYPE;

TYPE volume_2d_element_coordinate_system = SELECT
  (arbitrary_volume_2d_element_coordinate_system,
   parametric_volume_2d_element_coordinate_system);
END_TYPE;

TYPE surface_3d_element_coordinate_system = SELECT
  (aligned_surface_3d_element_coordinate_system,
   parametric_surface_3d_element_coordinate_system,
   constant_surface_3d_element_coordinate_system);
END_TYPE;

TYPE surface_2d_element_coordinate_system = SELECT
  (aligned_surface_2d_element_coordinate_system,
   parametric_surface_2d_element_coordinate_system);
END_TYPE;

TYPE curve_3d_element_coordinate_system = SELECT
  (aligned_curve_3d_element_coordinate_system,
   parametric_curve_3d_element_coordinate_system);
END_TYPE;

TYPE curve_element_end_coordinate_system = SELECT
     (fea_axis2_placement_3d,
      curve_3d_element_coordinate_system);
END_TYPE;

TYPE directionally_explicit_element_coordinate_system = SELECT
  (directionally_explicit_element_coordinate_system_arbitrary,
   directionally_explicit_element_coordinate_system_aligned);
END_TYPE;

TYPE element_aspect = SELECT
     (element_volume,
      volume_3d_face,
      volume_2d_face,
      volume_3d_edge,
      volume_2d_edge,
      surface_3d_face,
      surface_2d_face,
      surface_3d_edge,
      surface_2d_edge,
      curve_edge);
END_TYPE;

TYPE element_volume = ENUMERATION OF
     (volume);
END_TYPE;

TYPE curve_edge = ENUMERATION OF
     (element_edge);
END_TYPE;

TYPE node_or_node_group = SELECT
     (node_representation,
      node_group);
END_TYPE;

TYPE element_or_element_group = SELECT
     (element_representation,
      element_group);
END_TYPE;

ENTITY fea_model
  SUPERTYPE OF (ONEOF(fea_model_2d,
                      fea_model_3d))
  SUBTYPE OF (representation);
  creating_software         : text;
  intended_analysis_code    : SET [1:?] OF text;
  description               : text;
  analysis_type             : text;
UNIQUE
  UR1:  SELF\representation.name;
END_ENTITY;

ENTITY fea_model_3d
  SUBTYPE OF (fea_model);
WHERE
  WR1: SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3;
END_ENTITY;

ENTITY fea_model_2d
  SUBTYPE OF (fea_model);
  type_of_2d_analysis       : axi_or_plane;
WHERE
  WR1: SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2;
END_ENTITY;

ENTITY structural_response_property_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
         'STRUCTURAL_RESPONSE_PROPERTY') IN TYPEOF 
         (SELF\property_definition_representation.definition));
  WR2: ((('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_MODEL'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.FEA_MODEL_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.ELEMENT_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.ELEMENT_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition)))
       OR
      (('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION'
        IN TYPEOF 
        (SELF\property_definition_representation.used_representation))
        AND
        ('STRUCTURAL_RESPONSE_DEFINITION_SCHEMA.NODE_DEFINITION'
        IN TYPEOF 
        (SELF\property_definition_representation.definition.definition))));
END_ENTITY;

ENTITY fea_representation_item
  SUPERTYPE OF (ONEOF
               (arbitrary_volume_3d_element_coordinate_system,
                parametric_volume_3d_element_coordinate_system,
                arbitrary_volume_2d_element_coordinate_system,
                parametric_volume_2d_element_coordinate_system,
                aligned_surface_3d_element_coordinate_system,
                parametric_surface_3d_element_coordinate_system,
                constant_surface_3d_element_coordinate_system,
                aligned_surface_2d_element_coordinate_system,
                parametric_surface_2d_element_coordinate_system,
                aligned_curve_3d_element_coordinate_system,
                parametric_curve_3d_element_coordinate_system,
                parametric_curve_3d_element_coordinate_direction,
                curve_2d_element_coordinate_system,
                directionally_explicit_element_coordinate_system_arbitrary,
                directionally_explicit_element_coordinate_system_aligned))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY direction_node
  SUBTYPE OF (direction);
  node_1                    : node_representation;
  node_2                    : node_representation;
DERIVE
  SELF\direction.direction_ratios : LIST [2:3] OF REAL := 
                                    build_direction_node (node_1, node_2);
WHERE
  WR1: SIZEOF (QUERY(item <* node_1\representation.items |
              'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item <* node_2\representation.items |
              'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF (item))) = 1;
  WR3: NOT ((direction_ratios[1] = 0.0) AND
            (direction_ratios[2] = 0.0) AND
            (direction_ratios[3] = 0.0));
END_ENTITY;

ENTITY fea_axis2_placement_2d
  SUBTYPE OF (axis2_placement_2d);
  system_type               : coordinate_system_type;
  description               : text;
END_ENTITY;

ENTITY fea_axis2_placement_3d
  SUBTYPE OF (axis2_placement_3d);
  system_type               : coordinate_system_type;
  description               : text;
END_ENTITY;

ENTITY node_set
  SUBTYPE OF (geometric_representation_item);
  nodes                     : SET [1:?] OF node_representation;
WHERE
  WR1: SIZEOF (QUERY (tmp <* nodes | 
               tmp\representation.context_of_items :<>:
               nodes[1]\representation.context_of_items)) = 0;
END_ENTITY;

ENTITY analysis_item_within_representation;
  name                      : label;
  description               : text;
  item                      : representation_item;
  rep                       : representation;
WHERE
  WR1: SIZEOF (QUERY (tmp <* using_representations(item) | 
                      tmp :=: rep)) = 1;
END_ENTITY;

ENTITY node_geometric_relationship;
  node_ref                  : node_or_node_group;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY element_geometric_relationship;
  element_ref               : element_or_element_group;
  item                      : analysis_item_within_representation;
  aspect                    : element_aspect;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
  WR2: consistent_geometric_reference (aspect, item.item);
  WR3: consistent_element_or_group_reference (aspect, element_ref);
END_ENTITY;

ENTITY node_representation
  SUPERTYPE OF (ONEOF
                     (node,
                      dummy_node,
                      geometric_node))
  SUBTYPE OF (representation);
  model_ref                 : fea_model;
UNIQUE
  UR1: model_ref, SELF\representation.name;
END_ENTITY;

ENTITY node
  SUPERTYPE OF (node_with_vector ANDOR
                node_with_solution_coordinate_system)
  SUBTYPE OF (node_representation);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY node_with_vector
  SUBTYPE OF (node);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.DIRECTION' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY node_with_solution_coordinate_system
  SUBTYPE OF (node);
WHERE
  WR1: ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3) )
     OR
       ( (SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_2D' 
              IN TYPEOF (item))) = 1)
          AND
          (SELF\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 2) );
END_ENTITY;

ENTITY dummy_node
  SUBTYPE OF (node_representation);
END_ENTITY;

ENTITY geometric_node
  SUBTYPE OF (node_representation);
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'GEOMETRY_SCHEMA.POINT' 
              IN TYPEOF (item))) = 1;
END_ENTITY;

ENTITY substructure_node_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_1);
  WR2: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.NODE_REPRESENTATION' 
        IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY element_representation
  SUPERTYPE OF (ONEOF(volume_3d_element_representation,
                      axisymmetric_volume_2d_element_representation,
                      plane_volume_2d_element_representation,
                      surface_3d_element_representation,
                      axisymmetric_surface_2d_element_representation,
                      plane_surface_2d_element_representation,
                      curve_3d_element_representation,
                      axisymmetric_curve_2d_element_representation,
                      plane_curve_2d_element_representation,
                      point_element_representation,
                      directionally_explicit_element_representation,
                      explicit_element_representation,
                      substructure_element_representation))
  SUBTYPE OF (representation);
  node_list                 : LIST [1:?] OF node_representation;
WHERE
  WR1: SIZEOF (QUERY(item <* node_list |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'GEOMETRIC_NODE' 
              IN TYPEOF (item))) = 0;
 END_ENTITY;

ENTITY volume_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : volume_3d_element_descriptor;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
               'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
               'PARAMETRIC_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
               'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
               'ARBITRARY_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_3d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_volume_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_volume_2d_element_descriptor;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY plane_volume_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_volume_2d_element_descriptor;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY surface_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : surface_3d_element_descriptor;
  property                  : surface_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CONSTANT_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_2d_nodes (
        SELF\element_representation.node_list,
        element_descriptor.shape,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_surface_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_surface_2d_element_descriptor;
  property                  : surface_element_property;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
               IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
               IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY plane_surface_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_surface_2d_element_descriptor;
  property                  : surface_element_property;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' 
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY curve_3d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_3d;
  element_descriptor        : curve_3d_element_descriptor;
  property                  : curve_3d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'PARAMETRIC_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) +
       SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'ALIGNED_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR2: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR3: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        element_descriptor\element_descriptor.topology_order);
END_ENTITY;

ENTITY axisymmetric_curve_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : axisymmetric_curve_2d_element_descriptor;
  property                  : curve_2d_element_property;
  angle_property            : axisymmetric_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = axisymmetric;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY plane_curve_2d_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model_2d;
  element_descriptor        : plane_curve_2d_element_descriptor;
  property                  : curve_2d_element_property;
  depth_property            : plane_2d_element_property;
  material                  : element_material;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: model_ref.type_of_2d_analysis = planar;
  WR2: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'
              IN TYPEOF (item))) = 1;
  WR3: SIZEOF (QUERY(item1 <* material.properties |
        (SIZEOF (QUERY (item2 <* 
        item1\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)
                  ) = 1
        )) = 1
       ))) >= 1;
  WR4: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF (SELF\representation.context_of_items); 
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY element_descriptor
  SUPERTYPE OF (ONEOF (volume_3d_element_descriptor,
                       axisymmetric_volume_2d_element_descriptor,
                       plane_volume_2d_element_descriptor,
                       surface_3d_element_descriptor,
                       axisymmetric_surface_2d_element_descriptor,
                       plane_surface_2d_element_descriptor,
                       curve_3d_element_descriptor,
                       axisymmetric_curve_2d_element_descriptor,
                       plane_curve_2d_element_descriptor));
  topology_order            : element_order;
  description               : text;
END_ENTITY;

ENTITY volume_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF volume_element_purpose;
  shape                     : volume_3d_element_shape;
END_ENTITY;

ENTITY axisymmetric_volume_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              volume_element_purpose;
  shape                     : element_2d_shape;
END_ENTITY;

ENTITY plane_volume_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              volume_element_purpose;
  shape                     : element_2d_shape;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY volume_3d_element_basis;
  descriptor                : volume_3d_element_descriptor;
  variable                  : volume_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF volume_element_location;
END_ENTITY;

ENTITY volume_2d_element_basis;
  descriptor                : volume_2d_element_descriptor;
  variable                  : volume_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF volume_element_location;
END_ENTITY;

ENTITY surface_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
  shape                     : element_2d_shape;
END_ENTITY;

ENTITY axisymmetric_surface_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
END_ENTITY;

ENTITY plane_surface_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              surface_element_purpose;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY surface_3d_element_basis;
  descriptor                : surface_3d_element_descriptor;
  variable                  : surface_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF surface_element_location;
END_ENTITY;

ENTITY surface_2d_element_basis;
  descriptor                : surface_2d_element_descriptor;
  variable                  : surface_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF surface_element_location;
END_ENTITY;

ENTITY curve_3d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
END_ENTITY;

ENTITY axisymmetric_curve_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
END_ENTITY;

ENTITY plane_curve_2d_element_descriptor
  SUBTYPE OF (element_descriptor);
  purpose                   : SET [1:?] OF SET [1:?] OF 
                              curve_element_purpose;
  assumption                : plane_2d_element_purpose;
END_ENTITY;

ENTITY curve_3d_element_basis;
  descriptor                : curve_3d_element_descriptor;
  variable                  : curve_element_variable;
  variable_order            : element_order;
  variable_shape_function   : shape_function;
  evaluation_points         : LIST [1:?] OF curve_element_location;
END_ENTITY;

ENTITY curve_2d_element_basis;
  descriptor                : curve_2d_element_descriptor;
  variable                  : curve_element_variable;
END_ENTITY;

ENTITY point_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  description               : text;
  matrix_set                : SET [1:?] OF point_element_matrix;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D'
              IN TYPEOF (item))) = 1;
  FU1:  required_0d_nodes (
        SELF\element_representation.node_list);
END_ENTITY;

ENTITY point_element_matrix
  SUPERTYPE OF (ONEOF(stationary_mass,
                      grounded_spring,
                      grounded_damper));
END_ENTITY;

ENTITY stationary_mass
  SUBTYPE OF (point_element_matrix);
  mass                      : ARRAY [1:3] OF context_dependent_measure;
  moments_of_inertia        : symmetric_tensor2_3d;
  coordinate_system         : fea_axis2_placement_3d;
  offset_vector             : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;

ENTITY grounded_spring
  SUBTYPE OF (point_element_matrix);
  stiffness_coefficients    : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;

ENTITY grounded_damper
  SUBTYPE OF (point_element_matrix);
  damping_coefficients      : ARRAY [1:6] OF context_dependent_measure;
END_ENTITY;

ENTITY directionally_explicit_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  systems_and_freedoms      : LIST [2:2] OF system_and_freedom;
  description               : text;
  coefficient               : directionally_explicit_element_coefficient;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  FU1:  required_1d_nodes (
        SELF\element_representation.node_list,
        linear);
END_ENTITY;

ENTITY system_and_freedom;
  matrix_coordinate_system  : 
                     directionally_explicit_element_coordinate_system;
  freedom                   : degree_of_freedom;
END_ENTITY;

ENTITY directionally_explicit_element_coefficient;
  property_type             : matrix_property_type;
  coefficient               : context_dependent_measure;
END_ENTITY;

ENTITY explicit_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  description               : text;
  matrix                    : explicit_element_matrix;
UNIQUE
  UR1: model_ref, SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY(item <* SELF\representation.items |
              ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' +
              'FEA_AXIS2_PLACEMENT_3D') 
              IN TYPEOF (item))) = 1;
  WR2:  SIZEOF (matrix.node_dof_list) = 
        SIZEOF (SELF\element_representation.node_list);
END_ENTITY;

ENTITY explicit_element_matrix;
  property_type             : matrix_property_type;
  symmetry                  : matrix_symmetry;
  node_dof_list             : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
  matrix_values             : LIST [1:?] OF context_dependent_measure;
WHERE
  WR1: SIZEOF (matrix_values) = number_of_terms (node_dof_list, symmetry);
END_ENTITY;

ENTITY substructure_element_representation
  SUBTYPE OF (element_representation);
  model_ref                 : fea_model;
  substructure_model_ref    : fea_model;
UNIQUE
  UR1: model_ref, SELF\representation.name;
END_ENTITY;

ENTITY aligned_axis_tolerance;
  model_ref                 : fea_model;
  tolerance                 : context_dependent_measure;
END_ENTITY;

ENTITY arbitrary_volume_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_volume_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis_1                    : INTEGER;
  axis_2                    : INTEGER;
  eu_angles                 : euler_angles;
WHERE
  WR1:  (axis_1 >= 1) AND (axis_1 <= 3) AND
        (axis_2 >= 1) AND (axis_2 <= 3) AND
        NOT (axis_1 = axis_2);
END_ENTITY;

ENTITY arbitrary_volume_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY parametric_volume_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY aligned_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY constant_surface_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  axis                      : INTEGER;
  angle                     : plane_angle_measure;
WHERE
  WR1:  (axis >= 1) AND (axis <= 2);
END_ENTITY;

ENTITY aligned_surface_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY parametric_surface_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
END_ENTITY;

ENTITY aligned_curve_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  coordinate_system         : fea_axis2_placement_3d;
END_ENTITY;

ENTITY parametric_curve_3d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  direction            :  parametric_curve_3d_element_coordinate_direction;
END_ENTITY;

ENTITY parametric_curve_3d_element_coordinate_direction
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=3;
END_ENTITY;

ENTITY curve_2d_element_coordinate_system
  SUBTYPE OF (fea_representation_item);
  orientation               : direction;
WHERE
  WR1: SELF\geometric_representation_item.dim=2;
END_ENTITY;

ENTITY directionally_explicit_element_coordinate_system_arbitrary
  SUBTYPE OF (fea_representation_item);
  arbitrary_system          : fea_axis2_placement_3d;
END_ENTITY;

ENTITY directionally_explicit_element_coordinate_system_aligned
  SUBTYPE OF (fea_representation_item);
  aligned_system            : curve_3d_element_coordinate_system;
END_ENTITY;

ENTITY euler_angles;
  angles                    : ARRAY [1:3] OF plane_angle_measure;
END_ENTITY;

ENTITY volume_3d_element_integrated_matrix;
  descriptor                : volume_3d_element_descriptor;
  property_type             : matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY volume_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (volume_3d_element_integrated_matrix);
  integration_definition    : volume_3d_element_field_integration;
END_ENTITY;

TYPE volume_3d_element_field_integration = SELECT
  (element_integration_algebraic,
   volume_3d_element_field_integration_rule,
   volume_3d_element_field_integration_explicit);
END_TYPE;

TYPE element_integration_algebraic = ENUMERATION OF (algebraic);
END_TYPE;

ENTITY volume_3d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:3] OF INTEGER;
END_ENTITY;

ENTITY volume_3d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF volume_position_weight;
END_ENTITY;

ENTITY volume_position_weight;
  integration_position      : volume_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY volume_2d_element_integrated_matrix;
  descriptor                : volume_2d_element_descriptor;
  property_type             : matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY volume_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (volume_2d_element_integrated_matrix);
  integration_definition    : volume_2d_element_field_integration;
END_ENTITY;

TYPE volume_2d_element_field_integration = SELECT
  (element_integration_algebraic,
   volume_2d_element_field_integration_rule,
   volume_2d_element_field_integration_explicit);
END_TYPE;

ENTITY volume_2d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:2] OF INTEGER;
END_ENTITY;

ENTITY volume_2d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF volume_position_weight;
END_ENTITY;

ENTITY surface_3d_element_integrated_matrix;
  descriptor                : surface_3d_element_descriptor;
  property_type             : surface_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY surface_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (surface_3d_element_integrated_matrix);
  integration_definition    : surface_3d_element_integration;
END_ENTITY;

ENTITY surface_3d_element_integration;
  field                     : surface_3d_element_field_integration;
  section                   : surface_section_integration;
END_ENTITY;

TYPE surface_3d_element_field_integration = SELECT
  (element_integration_algebraic,
   surface_3d_element_field_integration_rule,
   surface_3d_element_field_integration_explicit);
END_TYPE;

TYPE surface_section_integration = SELECT
  (element_integration_algebraic,
   surface_section_integration_rule,
   surface_section_integration_explicit);
END_TYPE;

ENTITY surface_3d_element_field_integration_rule;
  integration_method        : integration_rule;
  integration_order         : ARRAY [1:2] OF INTEGER;
END_ENTITY;

ENTITY surface_3d_element_field_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF surface_position_weight;
END_ENTITY;

ENTITY surface_position_weight;
  integration_position      : surface_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY surface_section_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY surface_section_integration_explicit;
  integration_positions_and_weights : SET [1:?] OF 
                                      surface_section_position_weight;
END_ENTITY;

ENTITY surface_section_position_weight;
  integration_position      : surface_section_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY surface_2d_element_integrated_matrix;
  descriptor                : surface_2d_element_descriptor;
  property_type             : surface_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY surface_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (surface_2d_element_integrated_matrix);
  integration_definition    : surface_2d_element_integration;
END_ENTITY;

ENTITY surface_2d_element_integration;
  element_length            : surface_2d_element_length_integration;
  section                   : surface_section_integration;
END_ENTITY;

TYPE surface_2d_element_length_integration = SELECT
  (element_integration_algebraic,
   surface_2d_element_length_integration_rule,
   surface_2d_element_length_integration_explicit);
END_TYPE;

ENTITY surface_2d_element_length_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY surface_2d_element_length_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF surface_position_weight;
END_ENTITY;

ENTITY curve_3d_element_integrated_matrix;
  descriptor                : curve_3d_element_descriptor;
  property_type             : curve_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY curve_3d_element_integrated_matrix_with_definition
  SUBTYPE OF (curve_3d_element_integrated_matrix);
  integration_definition    : curve_3d_element_integration;
END_ENTITY;

ENTITY curve_3d_element_integration;
  element_length            : curve_3d_element_length_integration;
  section                   : curve_section_integration_explicit;
END_ENTITY;

TYPE curve_3d_element_length_integration = SELECT
  (element_integration_algebraic,
   curve_3d_element_length_integration_rule,
   curve_3d_element_length_integration_explicit);
END_TYPE;

ENTITY curve_3d_element_length_integration_rule;
  integration_method        : integration_rule;
  integration_order         : INTEGER;
END_ENTITY;

ENTITY curve_3d_element_length_integration_explicit;
  integration_positions_and_weights: SET [1:?] OF 
                                     curve_3d_element_position_weight;
END_ENTITY;

ENTITY curve_3d_element_position_weight;
  integration_position      : curve_volume_element_location;
  integration_weight        : context_dependent_measure;
END_ENTITY;

ENTITY curve_section_integration_explicit;
  integration_positions     : SET [1:?] OF curve_section_element_location;
END_ENTITY;

ENTITY curve_2d_element_integrated_matrix;
  descriptor                : curve_2d_element_descriptor;
  property_type             : curve_matrix_property_type;
  integration_description   : text;
END_ENTITY;

ENTITY curve_2d_element_integrated_matrix_with_definition
  SUBTYPE OF (curve_2d_element_integrated_matrix);
  integration_definition    : curve_2d_element_integration;
END_ENTITY;

ENTITY curve_2d_element_integration;
  section                   : LIST [1:?] OF curve_section_element_location;
END_ENTITY;

ENTITY fea_parametric_point
  SUBTYPE OF (point);
  coordinates               : LIST [1:3] OF parameter_value;
WHERE
  WR1: valid_parametric_coordinate (coordinates);
  WR2:  SIZEOF (TYPEOF (SELF) *
         ['GEOMETRY_SCHEMA.CARTESIAN_POINT',
          'GEOMETRY_SCHEMA.POINT_ON_CURVE',
          'GEOMETRY_SCHEMA.POINT_ON_SURFACE',
          'GEOMETRY_SCHEMA.DEGENERATE_PCURVE',
          'GEOMETRY_SCHEMA.POINT_REPLICA',
          'GEOMETRY_SCHEMA.SPHERICAL_POINT',
          'GEOMETRY_SCHEMA.CYLINDRICAL_POINT'])
         = 0;
END_ENTITY;

ENTITY volume_element_location;
  coordinates               : fea_parametric_point;
END_ENTITY;

ENTITY surface_volume_element_location;
  field_location            : surface_element_location;
  section_location          : surface_section_element_location;
END_ENTITY;

ENTITY surface_element_location;
  coordinates               : fea_parametric_point;
END_ENTITY;

ENTITY surface_section_element_location
  SUPERTYPE OF (ONEOF (surface_section_element_location_absolute,
                       surface_section_element_location_dimensionless));
  above_material_discontinuity : LOGICAL;
END_ENTITY;

ENTITY surface_section_element_location_absolute
  SUBTYPE OF (surface_section_element_location);
  offset                    : context_dependent_measure;
END_ENTITY;

ENTITY surface_section_element_location_dimensionless
  SUBTYPE OF (surface_section_element_location);
  coordinate                : LIST [1:1] OF parameter_value;
WHERE
  WR1: valid_parametric_coordinate (coordinate);
END_ENTITY;

ENTITY curve_volume_element_location;
  field_location            : curve_element_location;
  section_location          : curve_section_element_location;
END_ENTITY;

ENTITY curve_element_location;
  coordinate                : fea_parametric_point;
END_ENTITY;

ENTITY curve_section_element_location;
  offsets                   : ARRAY [1:2] of context_dependent_measure;
END_ENTITY;

ENTITY element_material;
  material_id               : identifier;
  description               : text;
  properties                : SET [1:?] OF material_property_representation;
END_ENTITY;

ENTITY fea_material_property_geometric_relationship;
  material_ref              : fea_material_property_representation;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY fea_material_property_representation
  SUBTYPE OF (material_property_representation);
WHERE
  WR1: SIZEOF (QUERY (item <* 
       SELF\property_definition_representation.used_representation.items |
         SIZEOF (['STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_LINEAR_ELASTICITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MASS_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_AREA_DENSITY',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_MOISTURE_ABSORPTION',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_BENDING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',
                  'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.' + 
                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item)
                  ) = 1
       )) = 1;
  WR2: 'MATERIAL_PROPERTY_DEFINITION_SCHEMA.MATERIAL_PROPERTY' IN 
       TYPEOF (SELF\property_definition_representation.definition);
END_ENTITY;

ENTITY fea_material_property_representation_item
  SUPERTYPE OF (ONEOF (fea_linear_elasticity,
                   fea_mass_density,
                   fea_area_density,
                   fea_tangential_coefficient_of_linear_thermal_expansion,
                   fea_secant_coefficient_of_linear_thermal_expansion,
                   fea_moisture_absorption,
                   fea_shell_membrane_stiffness,
                   fea_shell_bending_stiffness,
                   fea_shell_membrane_bending_coupling_stiffness,
                   fea_shell_shear_stiffness))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY fea_linear_elasticity
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_3d;
END_ENTITY;

ENTITY fea_mass_density
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constant              : scalar;
END_ENTITY;

ENTITY fea_area_density
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constant              : scalar;
END_ENTITY;

ENTITY fea_tangential_coefficient_of_linear_thermal_expansion
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
END_ENTITY;

ENTITY fea_secant_coefficient_of_linear_thermal_expansion
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
  reference_temperature     : thermodynamic_temperature_measure;
END_ENTITY;

ENTITY fea_moisture_absorption
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_3d;
END_ENTITY;

ENTITY fea_shell_membrane_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_bending_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_membrane_bending_coupling_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor4_2d;
END_ENTITY;

ENTITY fea_shell_shear_stiffness
  SUBTYPE OF (fea_material_property_representation_item);
  fea_constants             : symmetric_tensor2_2d;
END_ENTITY;

ENTITY surface_element_property;
  property_id               : identifier;
  description               : text;
  section                   : surface_section_field;
END_ENTITY;

ENTITY surface_section_field
  SUPERTYPE OF (ONEOF (surface_section_field_constant,
                       surface_section_field_varying));
END_ENTITY;

ENTITY surface_section_field_constant
  SUBTYPE OF (surface_section_field);
  definition                : surface_section;
END_ENTITY;

ENTITY surface_section_field_varying
  SUBTYPE OF (surface_section_field);
  definitions               : LIST [1:?] OF surface_section;
  additional_node_values    : BOOLEAN;
END_ENTITY;

ENTITY surface_section
  SUPERTYPE OF (ONEOF (uniform_surface_section,
                       uniform_surface_section_layered));
  offset                     : measure_or_unspecified_value;
  non_structural_mass        : measure_or_unspecified_value;
  non_structural_mass_offset : measure_or_unspecified_value;
END_ENTITY;

ENTITY uniform_surface_section
  SUBTYPE OF (surface_section);
  thickness                 : context_dependent_measure;
  bending_thickness         : measure_or_unspecified_value;
  shear_thickness           : measure_or_unspecified_value;
END_ENTITY;

ENTITY uniform_surface_section_layered
  SUBTYPE OF (surface_section);
END_ENTITY;

ENTITY fea_surface_section_geometric_relationship;
  section_ref               : surface_section;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY curve_3d_element_property;
  property_id               : identifier;
  description               : text;
  interval_definitions      : LIST [1:?] OF curve_element_interval;
  end_offsets               : ARRAY [1:2] OF curve_element_end_offset;
  end_releases              : ARRAY [1:2] OF curve_element_end_release;
END_ENTITY;

ENTITY curve_element_interval
  SUPERTYPE OF (ONEOF (curve_element_interval_constant,
                       curve_element_interval_linearly_varying));
  finish_position           : curve_element_location;
  eu_angles                 : euler_angles;
END_ENTITY;

ENTITY curve_element_interval_constant
  SUBTYPE OF (curve_element_interval);
  section                : curve_element_section_definition;
END_ENTITY;

ENTITY curve_element_interval_linearly_varying
  SUBTYPE OF (curve_element_interval);
  sections               : ARRAY [1:2] OF curve_element_section_definition;
END_ENTITY;

ENTITY curve_2d_element_property;
  property_id               : identifier;
  description               : text;
  section                   : curve_element_section_definition;
END_ENTITY;

ENTITY curve_element_section_definition
  SUPERTYPE OF (curve_element_section_derived_definitions);
  description               : text;
  section_angle             : plane_angle_measure;
END_ENTITY;

ENTITY curve_element_section_derived_definitions
  SUBTYPE OF (curve_element_section_definition);
  cross_sectional_area      : context_dependent_measure;
  shear_area                : ARRAY [1:2] OF measure_or_unspecified_value;
  second_moment_of_area     : ARRAY [1:3] OF context_dependent_measure;
  torsional_constant        : context_dependent_measure;
  warping_constant          : measure_or_unspecified_value;
  location_of_centroid      : ARRAY [1:2] OF measure_or_unspecified_value;
  location_of_shear_centre  : ARRAY [1:2] OF measure_or_unspecified_value;
  location_of_non_structural_mass
                            : ARRAY [1:2] OF measure_or_unspecified_value;
  non_structural_mass       : measure_or_unspecified_value;
  polar_moment              : measure_or_unspecified_value;
END_ENTITY;

ENTITY fea_curve_section_geometric_relationship;
  section_ref               : curve_element_section_definition;
  item                      : analysis_item_within_representation;
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item);
END_ENTITY;

ENTITY curve_element_end_offset;
  coordinate_system         : curve_element_end_coordinate_system;
  offset_vector             : ARRAY [1:3] OF context_dependent_measure;
END_ENTITY;

ENTITY curve_element_end_release;
  coordinate_system        : curve_element_end_coordinate_system;
  releases                 : LIST [1:?] OF curve_element_end_release_packet;
END_ENTITY;

ENTITY curve_element_end_release_packet;
  release_freedom           : curve_element_freedom;
  release_stiffness         : context_dependent_measure;
END_ENTITY;

ENTITY axisymmetric_2d_element_property;
  angle                     : plane_angle_measure;
END_ENTITY;

ENTITY plane_2d_element_property
  SUPERTYPE OF (simple_plane_2d_element_property);
  depth                     : context_dependent_measure;
END_ENTITY;

ENTITY simple_plane_2d_element_property
  SUBTYPE OF (plane_2d_element_property);
END_ENTITY;

ENTITY fea_group
  SUPERTYPE OF (ONEOF(element_group,
                      node_group))
  SUBTYPE OF (group);
  model_ref                 : fea_model;
END_ENTITY;

ENTITY element_group
  SUBTYPE OF (fea_group);
  elements                  : SET [1:?] OF element_representation;
END_ENTITY;

ENTITY node_group
  SUBTYPE OF (fea_group);
  nodes                     : SET [1:?] OF node_representation;
END_ENTITY;

ENTITY fea_group_relation
  SUBTYPE OF (group_relationship);
WHERE
  WR1: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.relating_group);
  WR2: 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.FEA_GROUP'
        IN TYPEOF (SELF\group_relationship.related_group);
END_ENTITY;

ENTITY volume_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'VOLUME_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY volume_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

ENTITY surface_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'SURFACE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY surface_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

ENTITY curve_3d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(query(item <* elements |
       NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
            'CURVE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0;
END_ENTITY;

ENTITY curve_2d_element_group
  SUBTYPE OF (element_group);
WHERE
  WR1: SIZEOF(QUERY(item <* elements |
       (NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)) AND
        NOT ('STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.'+
             'PLANE_CURVE_2D_ELEMENT_REPRESENTATION'
              IN TYPEOF(item)))))=0;
END_ENTITY;

FUNCTION required_0d_nodes
  (node_list                : LIST [1:?] OF node_representation): BOOLEAN;

  RETURN (SIZEOF (node_list) = 1);

END_FUNCTION;

FUNCTION required_1d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   order                    : element_order) : BOOLEAN;  

  LOCAL
   end_nodes                : INTEGER;
   additional_nodes         : INTEGER;
  END_LOCAL;

  end_nodes := 2;

  IF (order = linear) THEN
    additional_nodes := 0;
  END_IF;
  IF (order = quadratic) THEN
    additional_nodes := 1;
  END_IF;
  IF (order = cubic) THEN
    additional_nodes := 2;
  END_IF;

  RETURN (SIZEOF (node_list) = end_nodes + additional_nodes);

END_FUNCTION;

FUNCTION required_2d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   element_shape            : element_2d_shape;
   order                    : element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = triangle) THEN
    vertex_nodes := 3;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 3;
      edge_face_body_nodes := 3;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 7;
    END_IF;
  END_IF;

  IF (element_shape = quadrilateral) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 4;
      edge_face_body_nodes := 5;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 12;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));

END_FUNCTION;

FUNCTION required_3d_nodes
  (node_list                : LIST [1:?] OF node_representation;
   element_shape            : volume_3d_element_shape;
   order                    : element_order) : BOOLEAN;
  LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = hexahedron) THEN
    vertex_nodes := 8;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 19;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 24;
      edge_face_body_nodes := 56;
    END_IF;
  END_IF;

  IF (element_shape = wedge) THEN
    vertex_nodes := 6;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 9;
      edge_face_body_nodes := 12;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 18;
      edge_face_body_nodes := 34;
    END_IF;
  END_IF;

  IF (element_shape = tetrahedron) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 6;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 16;
    END_IF;
  END_IF;

  IF (element_shape = pyramid) THEN
    vertex_nodes := 5;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 9;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 16;
      edge_face_body_nodes := 25;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));

END_FUNCTION;

FUNCTION number_of_terms
  (node_dof_list           : LIST [1:?] OF LIST [1:?] OF degree_of_freedom;
   matrix_type             : matrix_symmetry) : INTEGER;
  LOCAL
    num_terms              : INTEGER;
    number_of_freedoms     : INTEGER;
  END_LOCAL;

  number_of_freedoms := 0; (* loop for each item in the outer list*)

  REPEAT i := 1 TO SIZEOF (node_dof_list); (* find size of inner list*)
    number_of_freedoms := number_of_freedoms + SIZEOF (node_dof_list[i]);
  END_REPEAT;

  IF (matrix_type = symmetric) THEN
    num_terms := (number_of_freedoms * (number_of_freedoms+1)) DIV 2;
  END_IF;

  IF (matrix_type = diagonal) THEN
    num_terms := number_of_freedoms;
  END_IF;

RETURN (num_terms);

END_FUNCTION;

FUNCTION valid_parametric_coordinate
    (coordinates            :  LIST [1:3] OF parameter_value): BOOLEAN;

    LOCAL
      i                     : INTEGER;
    END_LOCAL; 

    REPEAT i:=1 TO HIINDEX(coordinates);
      IF ((1.0 < coordinates[i]) OR (coordinates[i] < -1.0)) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;

    RETURN (TRUE);

END_FUNCTION;

FUNCTION build_direction_node
    (node_1                 : node_representation;
     node_2                 : node_representation): LIST [2:3] OF REAL;

LOCAL
  nodal_direction_ratios    : LIST [2:3] OF REAL;
  u                         : direction;
  i                         : INTEGER;
  ndim                      : INTEGER;
  rep_items                 : SET [1:?] of representation_item;
  node_1_point              : cartesian_point;
  node_2_point              : cartesian_point;
END_LOCAL;

rep_items := node_1.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_1_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

rep_items := node_2.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_2_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

ndim := HIINDEX(node_2_point.coordinates);
REPEAT i := 1 TO ndim;
  u.direction_ratios[i] := node_2_point.coordinates[i] - 
                           node_1_point.coordinates[i];
END_REPEAT;

u := normalise (u);
REPEAT i := 1 TO ndim;
  nodal_direction_ratios[i] := u.direction_ratios[i];
END_REPEAT;

RETURN (nodal_direction_ratios);

END_FUNCTION;

FUNCTION consistent_geometric_reference (
  aspect                    : GENERIC;
  item                      : geometric_representation_item) : BOOLEAN;
 
LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  item_type                 : SET [1:?] OF STRING;
END_LOCAL;

srrs        := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';
feacr       := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
aspect_type := TYPEOF (aspect);
item_type   := TYPEOF (item);

IF ('GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN item_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('GEOMETRY_SCHEMA.SURFACE' IN item_type) OR
    ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_FACE'),
              (feacr + 'VOLUME_2D_FACE'),
              (feacr + 'SURFACE_3D_FACE'),
              (feacr + 'SURFACE_2D_FACE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('GEOMETRY_SCHEMA.CURVE' IN item_type) OR
    ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_EDGE'),
              (feacr + 'VOLUME_2D_EDGE'),
              (feacr + 'SURFACE_3D_EDGE'), 
              (feacr + 'SURFACE_2D_EDGE'),
              (srrs  + 'CURVE_EDGE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION;

FUNCTION consistent_element_or_group_reference (
  aspect                    : GENERIC;
  element                   : GENERIC) : BOOLEAN;
 
LOCAL
  srrs                      : STRING;
  i                         : INTEGER;
END_LOCAL;

srrs := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';

IF ((srrs + 'ELEMENT_REPRESENTATION') IN TYPEOF(element)) THEN
  RETURN (consistent_element_reference (aspect, element));
END_IF;

IF ((srrs + 'ELEMENT_GROUP') IN TYPEOF(element)) THEN
  REPEAT i := 1 TO HIINDEX (element.elements);
    IF NOT (consistent_element_reference (aspect, element.elements[i])) 
     THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_IF;

RETURN (FALSE);

END_FUNCTION;

FUNCTION consistent_element_reference (
  aspect                    : GENERIC;
  element                   : element_representation) : BOOLEAN;

LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  element_type              : SET [1:?] OF STRING;
END_LOCAL;

srrs         := 'STRUCTURAL_RESPONSE_REPRESENTATION_SCHEMA.';
feacr        := 'FINITE_ELEMENT_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.';
aspect_type  := TYPEOF (aspect);
element_type := TYPEOF (element);

IF ((srrs + 'ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'VOLUME_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'VOLUME_3D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION')
     IN element_type) OR
    ((srrs + 'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF (((feacr + 'VOLUME_2D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_2D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'SURFACE_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'SURFACE_3D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION')
    IN element_type) OR
    ((srrs + 'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION')
     IN element_type)) THEN
  IF (((feacr + 'SURFACE_2D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_2D_EDGE') IN aspect_type)) THEN
  RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'CURVE_3D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF ((srrs + 'CURVE_EDGE') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);

END_FUNCTION;

END_SCHEMA; -- structural_response_representation_schema
(*
  $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N2887 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*) 


SCHEMA support_resource_schema;


TYPE identifier = STRING;
END_TYPE; 

TYPE label = STRING;
END_TYPE; 

TYPE text = STRING;
END_TYPE; 

FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
END_FUNCTION; 

FUNCTION type_check_function
 (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
  END_CASE;
END_IF;
END_FUNCTION; 

END_SCHEMA;  -- support_resource_schema
 (* Document WG12 N1046r date 2003-04-29. EXPRESS listing corresponding to part
 42  edition IS WG12 N536, as modified by TC1 WG12 N608 and
 by revision 1 (edition 3)  WG12 N1045 *)

 SCHEMA topology_schema;
   REFERENCE FROM geometry_schema;
   REFERENCE FROM representation_schema(representation_item);

 CONSTANT
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        
 END_CONSTANT;

 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;

 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;

  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;

 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;

 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;

 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;

 ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
   parent_face_set   :  connected_face_set;
 END_ENTITY;

 ENTITY edge
   SUPERTYPE OF(ONEOF(edge_curve, oriented_edge, subedge))
   SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;

 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;

 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;

 ENTITY face
   SUPERTYPE OF(ONEOF(face_surface, subface, oriented_face))
   SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;

 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;

    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;

 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;

 ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY open_path
   SUBTYPE OF (path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                       (SELF\path.edge_list[ne].edge_element.edge_end);
 END_ENTITY;

 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;

 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;

 ENTITY path
   SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;

 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY seam_edge
   SUBTYPE OF (oriented_edge);
     pcurve_reference : pcurve ; 
 WHERE
    WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
                ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
                       (edge_element\edge_curve.edge_geometry)) ;
   WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry ;
 END_ENTITY;

 ENTITY subedge
   SUBTYPE OF (edge);
   parent_edge   :  edge;
 END_ENTITY;

 ENTITY subface
   SUBTYPE OF (face);
   parent_face   :  face;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
 END_ENTITY;

 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 END_ENTITY;

 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;

 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;

 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;

 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
   LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);
 END_FUNCTION;

 FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point; 
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (RESULT);
END_FUNCTION;

 END_SCHEMA; -- end TOPOLOGY schema
(* Genenerated from: 10303-108.exp *)

SCHEMA variational_representation_schema;

REFERENCE FROM geometry_schema;                       -- ISO 10303-42

REFERENCE FROM representation_schema                  -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations);

--REFERENCE FROM parameterization_schema;               -- ISO 10303-108

REFERENCE FROM explicit_constraint_schema;            -- ISO 10303-108

REFERENCE FROM explicit_geometric_constraint_schema;  -- ISO 10303-108

REFERENCE FROM ISO13584_generic_expressions_schema    -- ISO 13584-20
  (used_variables);

ENTITY variational_representation_item
  ABSTRACT SUPERTYPE OF (auxiliary_geometric_representation_item)
  SUBTYPE OF (representation_item);
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(SELF) |
    NOT ('VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION'  
    IN TYPEOF(q)))) = 0; 
END_ENTITY;

ENTITY auxiliary_geometric_representation_item
  SUBTYPE OF (geometric_representation_item, 
              variational_representation_item);
END_ENTITY;

ENTITY variational_representation 
  SUBTYPE OF (representation);
INVERSE
  cm_link : variational_current_representation_relationship FOR rep_1;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\representation.items | 
    'VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM' 
    IN TYPEOF(q))) > 0;
  WR2: SIZEOF(QUERY(q <* (SELF\representation.items - 
    cm_link.rep_2.items) | 
    ('PARAMETERIZATION_SCHEMA.BOUND_MODEL_PARAMETER' IN TYPEOF(q))
    AND NOT (q.interpretation.semantics.owning_instance
    IN SELF\representation.items))) = 0;
  WR3: SIZEOF(QUERY(q <* (SELF\representation.items - 
    cm_link.rep_2.items) | 
    ('PARAMETERIZATION_SCHEMA.UNBOUND_MODEL_PARAMETER' IN TYPEOF(q))
    AND (SIZEOF(QUERY(r <* (SELF\representation.items -
    cm_link.rep_2.items) |
    ('EXPLICIT_CONSTRAINT_SCHEMA.FREE_FORM_CONSTRAINT' IN TYPEOF(r))
    AND (q IN used_variables(r.constraining_expression)))) = 0))) = 0;
  WR4: SIZEOF(QUERY(q <* (SELF\representation.items - 
    cm_link.rep_2.items) | 
    ('PARAMETERIZATION_SCHEMA.FIXED_INSTANCE_ATTRIBUTE_SET' IN TYPEOF(q))
    AND (SIZEOF(QUERY(r <* q.fixed_attributes | 
    NOT (r.owning_instance IN SELF\representation.items))) = 0))) = 0;
  WR5: SIZEOF(QUERY(q <* (SELF\representation.items - 
    cm_link.rep_2.items) | 
    ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) AND
    (SIZEOF(QUERY(r <* (q.reference_elements + q.constrained_elements) |
    NOT (r IN SELF\representation.items))) = 0))) = 0;
END_ENTITY;

ENTITY variational_current_representation_relationship
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 
                 : variational_representation;
  current_result : representation;
UNIQUE
  UR1: current_result;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\representation_relationship.rep_2.items |
    NOT(q IN SELF\representation_relationship.rep_1.items))) = 0;
  WR2: SELF\representation_relationship.rep_1.context_of_items :=:
    SELF\representation_relationship.rep_2.context_of_items;
  WR3: SIZEOF(QUERY(q <* SELF\representation_relationship.rep_2.items |
    'VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM' 
    IN TYPEOF(q))) = 0;
  WR4: SIZEOF(QUERY(q <* (SELF\representation_relationship.rep_1.items - 
    SELF\representation_relationship.rep_2.items) | NOT
    ('VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM' 
    IN TYPEOF(q)))) = 0;
  WR5: current_result :=: SELF\representation_relationship.rep_2;
END_ENTITY;

END_SCHEMA; -- variational_representation_schema


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\activity_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1157 - ISO/TS 10303-1047 Activity - EXPRESS MIM
*)

SCHEMA Activity_mim;

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_relationship,
   action_status,
   executed_action); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   object_role); 

USE FROM management_resources_schema   -- ISO 10303-41
  (action_assignment); 

TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1 : ?] OF action_items;
END_ENTITY;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\activity_method_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
*)

SCHEMA Activity_method_mim;

USE FROM action_schema    -- ISO 10303-41
(action_method );

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\advanced_boundary_representation_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1289 - ISO/TS 10303-1514 Advanced boundary representation - EXPRESS MIM
*)

SCHEMA Advanced_boundary_representation_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_advanced_brep;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\alias_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2907 - ISO/TS 10303-1025 Alias identification - EXPRESS MIM
*)
 


SCHEMA Alias_identification_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021


TYPE aliasable_item = EXTENSIBLE SELECT;
END_TYPE; 

END_SCHEMA;  -- Alias_identification_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\altered_package_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3283 - ISO/CD-TS 10303-1601 Altered package - EXPRESS MIM
*)


SCHEMA Altered_package_mim;
	USE FROM Package_mim;	-- ISO/TS 10303-1707

(** Needed by mapping *)
TYPE ap_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (package_terminal);
END_TYPE; 

ENTITY altered_package_terminal
  ABSTRACT SUPERTYPE OF ((shape_formed_terminal ANDOR
      surface_prepped_terminal) ANDOR length_trimmed_terminal)
   SUBTYPE OF (package_terminal);
WHERE
 WR1: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'ALTERED_PACKAGE_MIM.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'terminal to be altered' ))
       = 1;
 WR2: (SELF.of_shape.definition\product_definition.description =
       'altered package');
END_ENTITY;

ENTITY length_trimmed_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
 WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['ALTERED_PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ALTERED_PACKAGE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0);
 WR2:  (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ALTERED_PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ALTERED_PACKAGE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
                   'maximum trimmed length'))) = 1)) = 1))) = 0);
 WR3:  (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ALTERED_PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['ALTERED_PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'ALTERED_PACKAGE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND 
        (it\representation_item.name = 
                  'minimum trimmed length'))) = 1
       )) = 1))) = 0);

END_ENTITY;

ENTITY shape_formed_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
 WR1: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ALTERED_PACKAGE_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ALTERED_PACKAGE_MIM.' +
       'EE_SPECIFICATION' IN
       TYPEOF (ada.assigned_document)) AND
       (ada.assigned_document.kind\document_type.product_data_type =
       'lead form specification') AND
       (SIZEOF (QUERY (dr <* USEDIN (ada.assigned_document,
       'ALTERED_PACKAGE_MIM.' +
       'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT') |
       dr.relating_document.kind\document_type.product_data_type =
       'material specification')) = 1))) = 1);
END_ENTITY;

ENTITY surface_prepped_terminal
   SUBTYPE OF (altered_package_terminal);
WHERE
WR2: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'ALTERED_PACKAGE_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ALTERED_PACKAGE_MIM.' +
       'EE_SPECIFICATION' IN
       TYPEOF (ada.assigned_document)) AND
       (ada.assigned_document.kind\document_type.product_data_type =
       'surface finish specification'))) = 1);
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\altered_part_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3286 - ISO/CD-TS 10303-1602 Altered part - EXPRESS MIM
*)


SCHEMA Altered_part_mim;
	USE FROM Altered_package_mim;	-- ISO/TS 10303-1601
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\analytical_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3289 - ISO/CD-TS 10303-1603 Analytical model - EXPRESS MIM
*)


SCHEMA Analytical_model_mim;

	USE FROM Model_parameter_mim;	-- ISO/TS 10303-1703
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017
	USE FROM Software_mim;	-- ISO/TS 10303-1746
	USE FROM Specification_document_mim;	-- ISO/TS 10303-1747
	USE FROM Document_structure_mim;	-- ISO/TS 10303-1124

USE FROM Date_time_schema
	(date_time_role,
	date_role);
	USE FROM Group_mim;	-- ISO/TS 10303-1113
	
TYPE am_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (digital_analytical_model_vector_port);
END_TYPE;
	
ENTITY across_port_variable
  SUBTYPE OF (port_variable);
END_ENTITY;

ENTITY analog_analytical_model_port
  SUBTYPE OF (analytical_model_port);
END_ENTITY;

ENTITY analog_port_variable 
	SUBTYPE OF (representation, representation_item);
END_ENTITY;

ENTITY analytical_model
  SUBTYPE OF (representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 2;
  WR2: SIZEOF (QUERY (dr <* USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       dr.assigned_document.kind\document_type.product_data_type = 
       'language reference manual')) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       NOT ('ANALYTICAL_MODEL_MIM.' +
       'MODEL_PARAMETER' IN 
       TYPEOF (it)))) = 0;
  WR4: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'access mechanism') AND
       ('ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL_PORT' IN
       TYPEOF (rr.rep_2)))) >= 1;
END_ENTITY;

ENTITY analytical_model_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('ANALYTICAL_MODEL_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'ANALYTICAL_MODEL_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\analytical_model_definition))) = 0;
END_ENTITY;

ENTITY analytical_model_make_from_relationship
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF( QUERY(rr <* USEDIN(SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |NOT(
       ('ANALYTICAL_MODEL_MIM.' +
       'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
  WR4: SIZEOF( QUERY(rr <* USEDIN(SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |NOT(
       (rr\representation_relationship.name = 'associated make from') AND
       ('ANALYTICAL_MODEL_MIM.' +
       'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2))))) = 0;
  WR5: SIZEOF (['ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL'] *
       TYPEOF (SELF)) = 0;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\analytical_model_make_from_relationship))) = 0;
END_ENTITY; 

ENTITY analytical_model_parameter 
 SUBTYPE OF (model_parameter);
WHERE
  WR1: SIZEOF (QUERY (cri <* USEDIN (SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION.ITEMS') |
       ('ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL' IN TYPEOF(cri)) 
       )) = 1;
END_ENTITY;

ENTITY analytical_model_port
  SUPERTYPE OF (analytical_model_vector_port ANDOR (ONEOF(
   analog_analytical_model_port, digital_analytical_model_port)))
  SUBTYPE OF (representation);
  WHERE
  WR1: SIZEOF (QUERY (am <* QUERY (rr <* USEDIN (SELF,
       'ANALYTICAL_MODEL_MIM.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       rr\representation_relationship.name = 'access mechanism') |
       'ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (am.rep_1))) = 1;
END_ENTITY;

ENTITY analytical_model_port_assignment
  SUBTYPE OF (property_definition_representation, representation_relationship);
END_ENTITY;

ENTITY analytical_model_scalar_port
  SUBTYPE OF (analytical_model_vector_port);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       ('ANALYTICAL_MODEL_MIM.' +
       'MEASURE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'size') AND
       ('ANALYTICAL_MODEL_MIM.' +
       'COUNT_MEASURE' IN
       TYPEOF (it\measure_with_unit.value_component)) AND
       (it\measure_with_unit.value_component = 1))) = 1;
END_ENTITY;

ENTITY analytical_model_vector_port
  SUBTYPE OF (analytical_model_port, compound_representation_item);
WHERE
  WR1: (SIZEOF (QUERY (it <* SELF.items |
       ('ANALYTICAL_MODEL_MIM.' +
       'MEASURE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'size') AND
       ('ANALYTICAL_MODEL_MIM.' +
       'COUNT_MEASURE' IN
       TYPEOF (it\measure_with_unit.value_component)) AND
       ('ANALYTICAL_MODEL_MIM.' +
       'CONTEXT_DEPENDENT_UNIT' IN
       TYPEOF (it\measure_with_unit.unit_component)))) = 1);
END_ENTITY;

ENTITY analytical_representation
  SUBTYPE OF (representation);
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       'ANALYTICAL_MODEL_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN
       TYPEOF (rr.rep_2))) >= 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'ANALYTICAL_MODEL_MIM.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL' IN TYPEOF (rr.rep_1))) = 1;
END_ENTITY;

ENTITY digital_analytical_model_port
  SUBTYPE OF (analytical_model_port);
WHERE
  WR2: SIZEOF (QUERY (it <* SELF.items |
       ('ANALYTICAL_MODEL_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'nominal signal flow direction') AND
       (it\descriptive_representation_item.description IN 
       ['input direction',
       'output direction', 'bidirectional', 'unknown direction']))) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       ('ANALYTICAL_MODEL_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'port type') AND
       (it\descriptive_representation_item.description IN 
       ['string property type',
       'logical property type',
       'boolean property type']))) = 1;
END_ENTITY;

ENTITY digital_analytical_model_scalar_port
  SUBTYPE OF (digital_analytical_model_vector_port, analytical_model_scalar_port);
END_ENTITY;

ENTITY digital_analytical_model_vector_port
  SUBTYPE OF (analytical_model_vector_port);
END_ENTITY;

ENTITY make_from_model_port_relationship
 SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, 
       SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL_PORT'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL_PORT'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\representation_relationship ||
       SELF\make_from_model_port_relationship)) = 0;
  WR4: rep_1 :<>: rep_2;
  WR5: SIZEOF(QUERY( rr1 <* USEDIN(SELF.rep_1,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        (SIZEOF(QUERY(rr2 <* USEDIN(SELF.rep_2,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
        (rr1.rep_1 :=: rr2.rep_1)
        )) = 0))) = 1;
  WR6: SIZEOF (QUERY( rr <* USEDIN(SELF,
       'ANALYTICAL_MODEL_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       (('ANALYTICAL_MODEL_MIM.' +
       'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP') IN TYPEOF (rr.rep_1))
       )) = 1; 
       
END_ENTITY;

ENTITY port_variable
  SUPERTYPE OF (ONEOF(across_port_variable, through_port_variable, transform_port_variable))
  SUBTYPE OF (representation, representation_item);
END_ENTITY;

ENTITY through_port_variable
  SUBTYPE OF (port_variable);
END_ENTITY;
	
ENTITY transform_port_variable
  SUBTYPE OF (port_variable);
WHERE
  WR1: (SIZEOF (QUERY (it <* SELF.items |
       ('ANALYTICAL_MODEL_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'nominal signal flow direction') AND
       (it\descriptive_representation_item.description IN 
       ['input direction',
       'output direction', 'unknown direction'])))) = 1;
END_ENTITY;

RULE analytical_model_port_unique_constraint FOR
 ( analytical_model_port );
LOCAL
  name_bag : BAG OF STRING := [];
  amp_bag : BAG OF analytical_model_port;
  rr_bag : BAG OF representation_relationship;
  pass : BOOLEAN := TRUE;
  am_bag : BAG OF analytical_model;
END_LOCAL;

REPEAT i := 1 to SIZEOF(analytical_model_port) by 1;
  IF EXISTS( analytical_model_port[i]\representation.name ) THEN
    IF( NOT( analytical_model_port[i]\representation.name IN name_bag ) ) THEN
      name_bag := name_bag + analytical_model_port[i]\representation.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  amp_bag := QUERY( amp <* analytical_model_port | 
          (amp\representation.name = name_bag[i]) );
  am_bag := [];
  REPEAT j := 1 to SIZEOF(amp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rr_bag := QUERY( rr <* USEDIN( amp_bag[j], 
               'ANALYTICAL_MODEL_MIM.'
+ 'REPRESENTATION_RELATIONSHIP.REP_2' ) | ((rr\representation_relationship.name = 'access mechanism') 
 AND
('ANALYTICAL_MODEL_MIM.'
+ 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1))) );
    REPEAT k := 1 to SIZEOF(rr_bag) by 1;
      IF EXISTS( rr_bag[k].rep_1 ) THEN
        IF ( rr_bag[k].rep_1 IN am_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          am_bag := am_bag + rr_bag[k].rep_1;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_functional_interface_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1612 - ISO/CD-TS 10303-1604 Ap210 assembly functional interface requirements - EXPRESS MIM
*)


SCHEMA Ap210_assembly_functional_interface_requirements_mim;
	USE FROM Assembly_module_usage_view_mim;	-- ISO/TS 10303-1642
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_functional_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1615 - ISO/CD-TS 10303-1605 Ap210 assembly functional requirements - EXPRESS MIM
*)


SCHEMA Ap210_assembly_functional_requirements_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Functional_decomposition_to_assembly_design_mim;	-- ISO/TS 10303-1675
	USE FROM Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;	-- ISO/TS 10303-1678
	USE FROM Physical_node_requirement_to_implementing_component_allocation_mim;	-- ISO/TS 10303-1723
	USE FROM Planned_characteristic_mim;	-- ISO/TS 10303-1733
	USE FROM Test_requirement_allocation_mim;	-- ISO/TS 10303-1751
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_physical_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1618 - ISO/CD-TS 10303-1606 Ap210 assembly physical design - EXPRESS MIM
*)


SCHEMA Ap210_assembly_physical_design_mim;
	USE FROM Altered_part_mim;	-- ISO/TS 10303-1602
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Assembly_2d_shape_mim;	-- ISO/TS 10303-1632
	USE FROM Assembly_3d_shape_mim;	-- ISO/TS 10303-1633
	USE FROM Assembly_functional_interface_requirement_mim;	-- ISO/TS 10303-1635
	USE FROM Assembly_module_with_cable_component_2d_mim;	-- ISO/TS 10303-1638
	USE FROM Assembly_module_with_cable_component_3d_mim;	-- ISO/TS 10303-1639
	USE FROM Assembly_module_with_macro_component_mim;	-- ISO/TS 10303-1640
	USE FROM Assembly_shape_mim;	-- ISO/TS 10303-1646
	USE FROM Chemical_substance_mim;	-- ISO/TS 10303-1655
	USE FROM Design_specific_assignment_to_assembly_usage_view_mim;	-- ISO/TS 10303-1662
	USE FROM Device_marking_mim;	-- ISO/TS 10303-1664
	USE FROM Physical_unit_interconnect_definition_mim;	-- ISO/TS 10303-1729
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_physical_interface_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1621 - ISO/CD-TS 10303-1607 Ap210 assembly physical interface requirements - EXPRESS MIM
*)


SCHEMA Ap210_assembly_physical_interface_requirements_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Assembly_physical_requirement_allocation_mim;	-- ISO/TS 10303-1648
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_physical_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1624 - ISO/CD-TS 10303-1608 Ap210 assembly physical requirements - EXPRESS MIM
*)


SCHEMA Ap210_assembly_physical_requirements_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Assembly_module_usage_view_mim;	-- ISO/TS 10303-1642
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
	USE FROM Requirement_identification_and_version_mim;	-- ISO/TS 10303-1140
	USE FROM Requirement_view_definition_mim;	-- ISO/TS 10303-1141
	USE FROM Requirement_view_definition_relationship_mim;	-- ISO/TS 10303-1142
	USE FROM Test_requirement_allocation_mim;	-- ISO/TS 10303-1751
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1627 - ISO/CD-TS 10303-1609 Ap210 assembly requirement allocation - EXPRESS MIM
*)


SCHEMA Ap210_assembly_requirement_allocation_mim;
	USE FROM Ap210_assembly_functional_requirements_mim;	-- ISO/TS 10303-1605
	USE FROM Ap210_assembly_physical_interface_requirements_mim;	-- ISO/TS 10303-1607
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_assembly_technology_constraints_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1630 - ISO/CD-TS 10303-1610 Ap210 assembly technology constraints - EXPRESS MIM
*)


SCHEMA Ap210_assembly_technology_constraints_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Specification_document_mim;	-- ISO/TS 10303-1747
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_connection_zone_based_model_extraction_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1633 - ISO/CD-TS 10303-1611 Ap210 connection zone based model extraction - EXPRESS MIM
*)


SCHEMA Ap210_connection_zone_based_model_extraction_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_datum_difference_based_model_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   N1746 - ISO/CD-TS - 10303-1759 ap210_datum_difference_based_model_definition - EXPRESS MIM
*)
SCHEMA Ap210_datum_difference_based_model_definition_mim;

	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Datum_difference_based_model_mim; -- ISO/TS 10303-1660

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_device_functional_and_physical_characterization_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1636 - ISO/CD-TS 10303-1612 Ap210 device functional and physical characterization - EXPRESS MIM
*)


SCHEMA Ap210_device_functional_and_physical_characterization_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Chemical_substance_mim;	-- ISO/TS 10303-1655
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
	USE FROM Part_feature_grouping_mim;	-- ISO/TS 10303-1713
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_electronic_assembly_interconnect_and_packaging_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1639 - ISO/CD-TS 10303-410 Ap210 electronic assembly interconnect and packaging design - EXPRESS MIM
*)


SCHEMA Ap210_electronic_assembly_interconnect_and_packaging_design_mim;
USE FROM Ap210_device_functional_and_physical_characterization_mim;	-- ISO/TS 10303-1612
USE FROM Ap210_interconnect_technology_constraints_mim;	-- ISO/TS 10303-1622
USE FROM Ap210_assembly_technology_constraints_mim;	-- ISO/TS 10303-1610
USE FROM Ap210_assembly_functional_requirements_mim;	-- ISO/TS 10303-1605
USE FROM Ap210_assembly_physical_requirements_mim;	-- ISO/TS 10303-1608
USE FROM Ap210_interconnect_functional_requirements_mim;	-- ISO/TS 10303-1619
USE FROM Ap210_interconnect_physical_requirements_mim;	-- ISO/TS 10303-1620
USE FROM Ap210_assembly_physical_design_mim;	-- ISO/TS 10303-1606
USE FROM Ap210_interconnect_design_mim;	-- ISO/TS 10303-1617
USE FROM Ap210_interconnect_design_for_microwave_mim;	-- ISO/TS 10303-1618
USE FROM Ap210_product_rule_mim;	-- ISO/TS 10303-1630
USE FROM Ap210_functional_decomposition_mim;	-- ISO/TS 10303-1614
USE FROM Ap210_package_functional_and_physical_characterization_mim;	-- ISO/TS 10303-1624
USE FROM Ap210_laminate_assembly_design_mim;	-- ISO/TS 10303-1623
USE FROM Ap210_connection_zone_based_model_extraction_mim;	-- ISO/TS 10303-1611
USE FROM Ap210_functional_specification_mim;	-- ISO/TS 10303-1616
USE FROM Ap210_physical_unit_physical_characterization_mim;	-- ISO/TS 10303-1626
USE FROM Ap210_packaged_part_white_box_model_mim;	-- ISO/TS 10303-1625
USE FROM Ap210_printed_part_functional_and_physical_characterization_mim;	-- ISO/TS 10303-1627
USE FROM Ap210_assembly_functional_interface_requirements_mim;	-- ISO/TS 10303-1604
USE FROM Ap210_assembly_physical_interface_requirements_mim;	-- ISO/TS 10303-1607
USE FROM Ap210_assembly_requirement_allocation_mim;	-- ISO/TS 10303-1609
USE FROM Ap210_interconnect_requirement_allocation_mim;	-- ISO/TS 10303-1621
USE FROM Ap210_functional_requirement_allocation_mim;	-- ISO/TS 10303-1615
USE FROM Ap210_datum_difference_based_model_definition_mim;	-- ISO/TS 10303-1759

USE FROM Application_context_schema
	(application_context,
	 application_protocol_definition);

USE FROM Geometry_schema(offset_curve_2d);


SUBTYPE_CONSTRAINT assembly_component_subtypes FOR assembly_component;         
  (ONEOF (printed_component, packaged_component, routed_physical_component)
                ANDOR (thermal_component) ANDOR (cable_component));
END_SUBTYPE_CONSTRAINT;        

SUBTYPE_CONSTRAINT component_terminal_subtypes FOR physical_component_terminal;         
  (ONEOF(assembly_module_macro_component_join_terminal,
        interconnect_module_macro_component_join_terminal));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT model_parameter_subtypes FOR model_parameter;         
	(ONEOF(analytical_model_parameter,
               category_model_parameter,
               rule_function_domain_parameter,
               rule_function_range_parameter));
END_SUBTYPE_CONSTRAINT;               

SUBTYPE_CONSTRAINT physical_unit_subtypes FOR physical_unit;         
 (ONEOF (bare_die, 
          package, 
          packaged_part, 
          assembly_definition, 
          interconnect_definition,
          reference_packaged_part_assembly_implementation,
          reference_packaged_part_interconnect_implementation));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;         
  (ONEOF (edge_segment_cross_section,
              pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship));
END_SUBTYPE_CONSTRAINT;        

TYPE ap210_managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON managed_design_object WITH 
     (action,
      alternate_product_relationship,
      applied_approval_assignment,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      approval,
      approval_status,
      certification,
      characterized_object,
      composite_curve_segment,
      configuration_effectivity,
      configuration_item,
      contract,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      date,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      fill_area_style_hatching,
      fill_area_style_tiles,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      layer_connection_point,
      material_designation,
      measure_with_unit,
      organization,
      person,
      person_and_organization,
      plus_minus_tolerance,
      pre_defined_item,
      presentation_style_assignment,
      product,
      product_concept,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      security_classification,
      shape_aspect,
      shape_aspect_relationship,
      tolerance_value,
      tolerance_zone_form,
      versioned_action_request,
      action_directive,
		
	analog_port_variable,
	annotation_fill_area,
	applied_external_identification_assignment,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	auxiliary_characteristic_dimension_representation,
	assembly_component,
	assembly_component_usage,
	assembly_component_usage_substitute,
	assembly_joint,
	assembly_group_component_definition_placement_link,
	assembly_bond_definition,
	analytical_representation,
	analytical_model_port_assignment,
	analytical_model_port,
	analytical_model_make_from_relationship,
	analytical_model_definition,
	applied_identification_assignment,
	bus_element_link,
	bus_structural_definition,
	calendar_date,
	component_2d_location,
	component_3d_location,
	component_definition,
	component_feature,
	component_feature_relationship,
	component_functional_terminal,
	component_functional_unit,
	component_terminal,
	composite_signal_property_relationship,
	connection_zone_map_identification,
	connection_zone_interface_plane_relationship,
	conductive_interconnect_element_terminal_link,
	connector_based_interconnect_definition,
	coordinated_representation_item,
	date_and_time,
	datum,
	datum_difference_functional_unit_usage_view_terminal_assignment,
	descriptive_representation_item,
	device_terminal_map,
	dimensional_location,
	direct_stratum_component_join_implementation,
	direction,
	effectivity,
	evaluated_characteristic,
	externally_defined_curve_font,
	externally_defined_hatch_style,
	externally_defined_text_font,
	externally_defined_tile_style,
	fabrication_joint,
	frozen_assignment,
	functional_specification,
	functional_unit_terminal_definition,
	functional_terminal_group,
	general_property_relationship,
	geometric_representation_context,
	geometric_representation_item,
	geometric_tolerance_group,
	group_product_definition,
	group_shape_aspect,
	item_defined_transformation,
	interface_mounted_join,
	join_shape_aspect,
	layer,
	layout_junction,
	linear_array_component_definition_link,
	make_from_connectivity_relationship,
	make_from_feature_relationship,
	make_from_usage_option,
	mapped_item,
	measure_qualification,
	model_parameter,
	network_node_definition,
	packaged_connector_terminal_relationship,
	parameter_assignment_override,
	parameter_assignment_representation,
	part_connected_terminals_definition,
	passage_technology,
	physical_connectivity_definition,
	physical_connectivity_element,
	physical_network,
	physical_node_requirement_to_implementing_component_allocation,
	plated_inter_stratum_feature,
	product_category,
	product_category_relationship,
	product_specific_parameter_value_assignment,
	promissory_usage_occurrence,
	projected_zone_definition,
	printed_connector_template_terminal_relationship,
	printed_part_template_connected_terminals_definition,
	printed_part_template_material,
	printed_part_template_material_link,
	representation_relationship_with_transformation,
	requirement_assignment,
	requirements_property,
	rule_action,
	rule_conclusion_definition,
	rule_complex_clause,
	rule_function_definition,
	rule_simple_clause,
	rule_premise_definition,
	runout_zone_orientation_reference_direction,
	scalar_terminal_definition_link,
	sequential_laminate_passage_based_fabrication_joint,
	shape_dimension_representation,
	shape_modification,
	shape_representation,
	shape_representation_relationship,
	signal,
	solid_curve_font,
	specified_higher_usage_occurrence,
	stratum_concept_relationship,
	stratum_surface,
	stratum_technology,
	stratum_technology_link,
	styled_item,
	tolerance_zone_definition,
	usage_view_connection_zone_terminal_shape_relationship,
	vector);
END_TYPE;


RULE application_protocol_definition_required FOR
    (application_context);
WHERE
  WR1:  SIZEOF( QUERY( ac <* application_context |
              (SIZEOF (QUERY (apd <*
USEDIN(ac,'APPLICATION_CONTEXT_SCHEMA.APPLICATION_PROTOCOL_DEFINITION.APPLICATION')
|
                apd.application_interpreted_model_schema_name =
'electronic_assembly_interconnect_and_packaging_design'
                )) > 0)
              )) > 0;
END_RULE;

RULE dependent_instantiable_tolerance_value FOR (
         tolerance_value);
WHERE
  WR1: SIZEOF (QUERY (tv <* tolerance_value |
       NOT (SIZEOF(USEDIN(tv, '')) >= 1))) = 0;
END_RULE;

RULE ee_product_definition_unique_constraint FOR
 ( product_definition_with_associated_documents, 
   physical_unit, functional_unit );
LOCAL
  pdwad : BAG OF product_definition := 
QUERY( r <* product_definition_with_associated_documents | (TRUE) );
  pu : BAG OF product_definition := QUERY( r <* physical_unit | (TRUE) );
  fu : BAG OF product_definition := QUERY( r <* functional_unit | (TRUE) );
  epd : BAG OF product_definition;
  pdf_bag : BAG OF product_definition_formation;
  pd_bag : BAG OF product_definition;
  pass1 : BOOLEAN := TRUE;
  lcs_bag : BAG OF STRING;
  pass2 : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

epd := pdwad + pu + fu;
REPEAT i := 1 to SIZEOF(epd) by 1;
  IF EXISTS( epd[i].formation ) THEN
    IF( NOT( epd[i].formation IN pdf_bag ) ) THEN
      pdf_bag := pdf_bag + epd[i].formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  lcs_bag := [];
  id_bag := [];
  pd_bag := QUERY( pd <* epd | (pd.formation :=: pdf_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass2 ) THEN
      IF EXISTS( pd_bag[j].id ) THEN
        IF ( pd_bag[j].id IN id_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + pd_bag[j].id;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass2;
END_RULE;


RULE no_shape_for_make_from FOR
  (make_from_usage_option);
WHERE
  WR1: SIZEOF (QUERY (mfuo <* make_from_usage_option |
       NOT (SIZEOF (QUERY (pd <* USEDIN (mfuo, 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (pd))) = 0))) = 0;
END_RULE;

RULE origin_constraint FOR (placement);
LOCAL
 origin_2d : SET OF axis2_placement_2d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.AXIS2_PLACEMENT_2D' IN TYPEOF(pl))));
 origin_3d : SET OF axis2_placement_3d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.AXIS2_PLACEMENT_3D' IN TYPEOF(pl))));
pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(origin_2d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF (NOT((origin_2d[i].location.coordinates[1] = 0.0) AND
   (origin_2d[i].location.coordinates[2] = 0.0) AND
   NOT EXISTS(origin_2d[i].ref_direction)))
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
REPEAT i := 1 to SIZEOF(origin_3d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF NOT(
   (origin_3d[i].location.coordinates[1] = 0.0) AND
   (origin_3d[i].location.coordinates[2] = 0.0) AND
   (origin_3d[i].location.coordinates[3] = 0.0) AND
   (NOT(EXISTS(origin_3d[i].ref_direction))) AND 
   (NOT(EXISTS(origin_3d[i].axis)))
   )
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass; 
END_RULE;

RULE part_feature_unique_constraint FOR
 ( composite_shape_aspect, shape_aspect, primary_orientation_feature,
tertiary_orientation_feature,
secondary_orientation_feature, package_body, part_tooling_feature,
thermal_feature, part_mounting_feature, package_terminal,
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal,
minimally_defined_bare_die_terminal, packaged_part_terminal, 
package_body_surface );
LOCAL
  csa : BAG OF shape_aspect := QUERY( r <* composite_shape_aspect |
(r\shape_aspect.description = 'part group feature') );
  sa : BAG OF shape_aspect := QUERY( r <* shape_aspect |
(r\shape_aspect.description IN ['part generic feature','polarity indication feature',
'interconnect module edge segment surface',
'interconnect module cavity surface',
'interconnect module cutout surface',
'interconnect module edge surface',
'interconnect module primary surface',
'interconnect module secondary surface',
'interconnect module surface feature']) );
  pof : BAG OF shape_aspect := QUERY( r <* 
                  primary_orientation_feature | (TRUE) );
  sof : BAG OF shape_aspect := QUERY( r <* 
                 secondary_orientation_feature | (TRUE) );
  tof : BAG OF shape_aspect := QUERY( r <* 
                 tertiary_orientation_feature | (TRUE) );
  pb : BAG OF shape_aspect := QUERY( r <* 
                                package_body | (TRUE) );
  ptf : BAG OF shape_aspect := QUERY( r <* part_tooling_feature | (TRUE) );
  tf : BAG OF shape_aspect := QUERY( r <* thermal_feature | (TRUE) );
  pmf : BAG OF shape_aspect := QUERY( r <* part_mounting_feature | (TRUE) );
  pt : BAG OF shape_aspect := QUERY( r <* package_terminal | (TRUE) );
  amt : BAG OF shape_aspect := QUERY( r <* 
                            assembly_module_terminal | (TRUE) );
  bdt : BAG OF shape_aspect := QUERY( r <* bare_die_terminal | (TRUE) );
  imt : BAG OF shape_aspect := QUERY( r <* 
                          interconnect_module_terminal | (TRUE) );
  mdbdt : BAG OF shape_aspect := QUERY( r <* 
                    minimally_defined_bare_die_terminal | (TRUE) );
  ppt : BAG OF shape_aspect := QUERY( r <* 
                                  packaged_part_terminal | (TRUE) );
  pbs : BAG OF shape_aspect := QUERY( r <* 
                                       package_body_surface | (TRUE) );
  pf : BAG OF shape_aspect := [];
  pu_bag : BAG OF physical_unit := [];
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

sa := csa + sa + pof + sof +tof + pb + ptf + tf + pmf + 
          pt + amt + bdt + imt + mdbdt + ppt + pbs;
REPEAT i := 1 to SIZEOF(sa) by 1;
  IF EXISTS( sa[i] ) THEN
    IF ( NOT ( sa[i] IN pf )) THEN
      pf := pf + sa[i];
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pf) by 1;
  IF EXISTS( pf[i].of_shape.definition ) THEN
    IF ( (
'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND
(pf[i].of_shape.definition.frame_of_reference.name = 
'physical design usage') ) THEN
      IF ( NOT ( pf[i].of_shape.definition IN pu_bag )) THEN
        pu_bag := pu_bag + pf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  sa_bag := QUERY( sa <* pf | (sa.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF EXISTS( sa_bag[j]\shape_aspect.name ) THEN
      IF ( sa_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sa_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE restrict_manifold_surface_shape_representation FOR
  (manifold_surface_shape_representation);
  WHERE
    WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
         (mssr\representation.name IN ['stratum feature non planar 2d shape',
         'open shell based surface',
         'design intent modification non planar 2d shape', 
         'part template non planar 2d shape']) AND
         (NOT(SIZEOF(QUERY(sbsm <* mssr.items | 
         ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
         'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND
         (SIZEOF(QUERY(os <* sbsm\shell_based_surface_model.sbsm_boundary |
         'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
         'OPEN_SHELL' IN TYPEOF(os))) = 1)
         )) = 1)))) = 0;
END_RULE;

RULE shape_representation_requires_origin FOR (shape_representation);
WHERE
  WR1: 
(* 
pseudocode
co:FOREACH (sr <* shape_representation |c1);
c1:EXACTLYONE(it <* sr\representation.items |c2) 
   or ATLEASTONE(it <* sr\representation.items |c3)
   or EXACTLYNONE(it <* sr\representation.items |c4);
c2:((it.name = 'origin') or (it.name = 'orientation')) and 
   (AXIS2_PLACEMENT_2D in TYPEOF(it)  OR
    AXIS2_PLACEMENT_3D in TYPEOF(it));
c3:STYLED_ITEM in TYPEOF(it);
c4:((it.name = 'origin') or (it.name = 'orientation')) and
   ((sr.name = 'zone shape') or 
   (sr.context_of_items.context_type = 'connection zone colour'));
*)
SIZEOF(QUERY ( sr <* shape_representation |  NOT(
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and 
   (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it))  OR
   ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it)))
))) = 1
) 
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
   ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
    'STYLED_ITEM' in TYPEOF(it))
))) >= 1
)
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and
   ((sr\representation.name = 'zone shape') or 
   (sr.context_of_items\representation_context.context_type = 'connection zone colour'))
))) = 0
)
))) = 0;
END_RULE;

RULE subtype_combination_shape_aspect FOR (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_BOND_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DATUM_REFERENCE_FRAME',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DERIVED_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DEVICE_TERMINAL_MAP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'GROUP_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERFACE_MOUNTED_JOIN',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAND_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MOUNTING_RESTRICTION_AREA',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGE_BODY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGED_PART_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PASSAGE_TECHNOLOGY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_NETWORK',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SHAPE_MODIFICATION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_FEATURE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_SURFACE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR2: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_BOND_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DATUM_REFERENCE_FRAME',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DEVICE_TERMINAL_MAP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'GROUP_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERFACE_MOUNTED_JOIN',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAND_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MOUNTING_RESTRICTION_AREA',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGE_BODY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGED_PART_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PASSAGE_TECHNOLOGY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_NETWORK',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_DATUM',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SHAPE_MODIFICATION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_FEATURE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_SURFACE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR3: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_BOND_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DATUM_REFERENCE_FRAME',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DERIVED_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DEVICE_TERMINAL_MAP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'GROUP_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERFACE_MOUNTED_JOIN',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAND_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MOUNTING_RESTRICTION_AREA',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGE_BODY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PASSAGE_TECHNOLOGY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_NETWORK',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SHAPE_MODIFICATION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_FEATURE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_SURFACE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR4: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'PHYSICAL_UNIT_DATUM']
       * TYPEOF(sa)) <= 1))) = 0;

END_RULE;

RULE subtype_exclusive_mapped_item FOR (mapped_item);
WHERE
  WR1: SIZEOF (QUERY (mi <* mapped_item |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ANNOTATION_TEXT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ANNOTATION_SYMBOL'] *
       TYPEOF(mi)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_product_definition FOR (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'BUS_STRUCTURAL_DEFINITION', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_DEFINITION', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_FUNCTIONAL_UNIT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'FUNCTIONAL_UNIT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'NETWORK_NODE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_property_definition FOR
  (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* property_definition |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DIMENSIONAL_SIZE_PROPERTY',   
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'GEOMETRIC_TOLERANCE_GROUP', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MATERIAL_PROPERTY', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_SHAPE', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'REQUIREMENTS_PROPERTY', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SIGNAL']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_representation FOR 
  (representation);
WHERE
  WR1: SIZEOF (QUERY (rep <* representation |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'ANALYTICAL_MODEL_PORT', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'COMPONENT_LOCATION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'RULE_FUNCTION_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TEXT_STRING_REPRESENTATION']
       * TYPEOF(rep)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_representation_context FOR 
  (representation_context);
LOCAL
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(representation_context) by 1;
  pass := (NOT ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN 
                          TYPEOF(representation_context[i]))
          OR (SIZEOF (TYPEOF(representation_context[i])) <= 2 )) 
       AND 
          (NOT ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
         * TYPEOF(representation_context[i])) <= 2 )) 
      AND
          (NOT ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT' IN 
                        TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
        * TYPEOF(representation_context[i])) <= 2 ));
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE subtype_exclusive_shape_aspect_relationship FOR 
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'ASSEMBLY_JOINT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DEVICE_TERMINAL_MAP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DIMENSIONAL_LOCATION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'INTERFACE_MOUNTED_JOIN',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MAKE_FROM_CONNECTIVITY_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'MAKE_FROM_FEATURE_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SHAPE_ASPECT_DERIVING_RELATIONSHIP',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP']
       * TYPEOF(sar)) <= 1))) = 0;
END_RULE;

RULE subtype_mandatory_action FOR (action);
WHERE
  WR1: SIZEOF (QUERY (act <* action |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'DIRECTED_ACTION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXECUTED_ACTION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'RULE_ACTION'] * 
       TYPEOF(act)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_externally_defined_item FOR 
                                       (externally_defined_item);
WHERE
  WR1: SIZEOF (QUERY (edi <* externally_defined_item |
       NOT (SIZEOF ([
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'BOND_CATEGORY',  
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_CURVE_FONT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_HATCH_STYLE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_SYMBOL',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_TEXT_FONT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_TILE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_TILE_STYLE',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'RULE_DEFINITION',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'SIGNAL_CATEGORY'] * 
       TYPEOF (edi)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);
WHERE
  WR1: SIZEOF (QUERY (pdi <* pre_defined_item |
       NOT (SIZEOF 
       (['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRE_DEFINED_TEXT_FONT',
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'PRE_DEFINED_CURVE_FONT'] *
       TYPEOF(pdi)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_text_literal FOR (text_literal);
WHERE
  WR1: SIZEOF (QUERY (tl <* text_literal |
       NOT ((
       'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF (tl)) OR
       ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' +
       'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN
       TYPEOF(tl))))) = 0;
END_RULE;

FUNCTION valid_2d_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basic curve types
  IF SIZEOF ([schma + '.LINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.CIRCLE',
              schma + '.HYPERBOLA',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic curves for curve_replicas
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    -- recursively check for valid basis curves for offset_curves
    ELSE
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv)
        THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\offset_curve_2d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;

RULE ee_material_unique_constraint FOR
 ( material_designation );
LOCAL
  name_bag : BAG OF STRING := [];
  md_bag : BAG OF material_designation;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(material_designation) by 1;
  IF EXISTS( material_designation[i].name ) THEN
    IF( NOT( material_designation[i].name IN name_bag ) ) THEN
      name_bag := name_bag + material_designation[i].name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  md_bag := QUERY( md <* material_designation | (md\material_designation.name = name_bag[i]) );
  doc_bag := [];
  REPEAT j := 1 to SIZEOF(md_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( md_bag[j], 
('AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'DOCUMENT') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_functional_decomposition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1642 - ISO/CD-TS 10303-1614 Ap210 functional decomposition - EXPRESS MIM
*)


SCHEMA Ap210_functional_decomposition_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Electrical_network_definition_mim;	-- ISO/TS 10303-1665
	USE FROM Thermal_network_definition_mim;	-- ISO/TS 10303-1752
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_functional_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1645 - ISO/CD-TS 10303-1615 Ap210 functional requirement allocation - EXPRESS MIM
*)


SCHEMA Ap210_functional_requirement_allocation_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Functional_unit_requirement_allocation_mim;	-- ISO/TS 10303-1680
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_functional_specification_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1648 - ISO/CD-TS 10303-1616 Ap210 functional specification - EXPRESS MIM
*)


SCHEMA Ap210_functional_specification_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Functional_specification_mim;	-- ISO/TS 10303-1679
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1651 - ISO/CD-TS 10303-1617 Ap210 interconnect design - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_design_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Chemical_substance_mim;	-- ISO/TS 10303-1655
	USE FROM Connectivity_allocation_to_physical_network_mim;	-- ISO/TS 10303-1658
	USE FROM Design_specific_assignment_to_interconnect_usage_view_mim;	-- ISO/TS 10303-1663
	USE FROM Device_marking_mim;	-- ISO/TS 10303-1664
	USE FROM Interconnect_2d_shape_mim;	-- ISO/TS 10303-1682
	USE FROM Interconnect_3d_shape_mim;	-- ISO/TS 10303-1683
	USE FROM Interconnect_module_to_assembly_module_relationship_mim;	-- ISO/TS 10303-1685
	USE FROM Layered_interconnect_module_2d_design_mim;	-- ISO/TS 10303-1695
	USE FROM Layered_interconnect_module_3d_design_mim;	-- ISO/TS 10303-1696
	USE FROM Layered_interconnect_module_3d_shape_mim;	-- ISO/TS 10303-1697
	USE FROM Layout_macro_definition_mim;	-- ISO/TS 10303-1701
	USE FROM Pre_defined_datum_symbol_mim;	-- ISO/TS 10303-1734
	USE FROM Via_component_mim;	-- ISO/TS 10303-1754
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_design_for_microwave_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1654 - ISO/CD-TS 10303-1618 Ap210 interconnect design for microwave - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_design_for_microwave_mim;
	USE FROM Ap210_interconnect_design_mim;	-- ISO/TS 10303-1617
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_functional_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1657 - ISO/CD-TS 10303-1619 Ap210 interconnect functional requirements - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_functional_requirements_mim;
	USE FROM Ap210_functional_decomposition_mim;	-- ISO/TS 10303-1614
	USE FROM Functional_decomposition_to_interconnect_design_mim;	-- ISO/TS 10303-1677
	USE FROM Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;	-- ISO/TS 10303-1678
	USE FROM Planned_characteristic_mim;	-- ISO/TS 10303-1733
	USE FROM Test_requirement_allocation_mim;	-- ISO/TS 10303-1751
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_physical_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1660 - ISO/CD-TS 10303-1620 Ap210 interconnect physical requirements - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_physical_requirements_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Fabrication_requirement_mim;	-- ISO/TS 10303-1669
	USE FROM Interconnect_placement_requirements_mim;	-- ISO/TS 10303-1690
	USE FROM Test_requirement_allocation_mim;	-- ISO/TS 10303-1751
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1663 - ISO/CD-TS 10303-1621 Ap210 interconnect requirement allocation - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_requirement_allocation_mim;
	USE FROM Ap210_interconnect_functional_requirements_mim;	-- ISO/TS 10303-1619
	USE FROM Ap210_interconnect_physical_requirements_mim;	-- ISO/TS 10303-1620
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_interconnect_technology_constraints_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1666 - ISO/CD-TS 10303-1622 Ap210 interconnect technology constraints - EXPRESS MIM
*)


SCHEMA Ap210_interconnect_technology_constraints_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_laminate_assembly_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1669 - ISO/CD-TS 10303-1623 Ap210 laminate assembly design - EXPRESS MIM
*)


SCHEMA Ap210_laminate_assembly_design_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Sequential_laminate_assembly_design_mim;	-- ISO/TS 10303-1741
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_package_functional_and_physical_characterization_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1672 - ISO/CD-TS 10303-1624 Ap210 package functional and physical characterization - EXPRESS MIM
*)


SCHEMA Ap210_package_functional_and_physical_characterization_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Chemical_substance_mim;	-- ISO/TS 10303-1655
	USE FROM Package_mim;	-- ISO/TS 10303-1707
	USE FROM Part_feature_grouping_mim;	-- ISO/TS 10303-1713
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_packaged_part_white_box_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1675 - ISO/CD-TS 10303-1674 Ap210 packaged part white box model - EXPRESS MIM
*)


SCHEMA Ap210_packaged_part_white_box_model_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Packaged_part_white_box_model_mim;	-- ISO/TS 10303-1709
	USE FROM Part_feature_grouping_mim;	-- ISO/TS 10303-1713
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_physical_unit_physical_characterization_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1678 - ISO/CD-TS 10303-1626 Ap210 physical unit physical characterization - EXPRESS MIM
*)


SCHEMA Ap210_physical_unit_physical_characterization_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Part_feature_grouping_mim;	-- ISO/TS 10303-1713
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_printed_part_functional_and_physical_characterization_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1681 - ISO/CD-TS 10303-1627 Ap210 printed part functional and physical characterization - EXPRESS MIM
*)


SCHEMA Ap210_printed_part_functional_and_physical_characterization_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Chemical_substance_mim;	-- ISO/TS 10303-1655
	USE FROM Physical_layout_template_mim;	-- ISO/TS 10303-1722
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_product_data_management_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3349 - ISO/CD-TS 10303-1628 Ap210 product data management - EXPRESS MIM
*)


SCHEMA Ap210_product_data_management_mim;

	USE FROM Product_data_management_mim;	-- ISO/TS 10303-1231
	USE FROM Alias_identification_mim;	-- ISO/TS 10303-1025
	USE FROM Classification_with_attributes_mim;	-- ISO/TS 10303-1111
	USE FROM Generic_material_aspects_mim;	-- ISO/TS 10303-1681
	USE FROM Group_mim;	-- ISO/TS 10303-1113
	USE FROM Part_occurrence_mim;	-- ISO/TS 10303-1715
	USE FROM Pre_defined_product_data_management_specialisations_mim;
	USE FROM Promissory_usage_in_product_concept_mim;	-- ISO/TS 10303-1758
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	USE FROM Requirement_view_definition_relationship_mim;	-- ISO/TS 10303-1142
	USE FROM Test_select_product_mim;	-- ISO/TS 10303-1757


	USE FROM Contract_schema(contract_type);
	USE FROM Document_schema(document_type);
	USE FROM Product_definition_schema(product_definition_formation_with_specified_source);
	USE FROM Product_structure_schema(make_from_usage_option);
	USE FROM Representation_schema(parametric_representation_context);


TYPE ap210_pdm_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (external_class_library,
   product,
   product_definition);
END_TYPE; 

TYPE ap210_pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_approval_item WITH 
     (action_directive,
      certification,
      configuration_item,
      contract,
      date,
      directed_action,
      document,
      effectivity,
      executed_action,
      general_property_relationship,
      product,
      product_definition,
      product_definition_formation_relationship,
      product_definition_relationship,
      product_definition_formation,
      representation,
      requirement_assignment,
      security_classification,
      shape_aspect_relationship);
END_TYPE;

TYPE ap210_pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_certification_item WITH 
     (alternate_product_relationship,
     product_definition_formation,
     make_from_usage_option);
END_TYPE;

TYPE ap210_pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_classification_item WITH 
     (material_designation);
END_TYPE;

TYPE ap210_pdm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
     (action_directive,
      alternate_product_relationship,
      directed_action,
      person_and_organization,
      product,
      product_definition_formation);
END_TYPE;

TYPE ap210_pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_and_time_item WITH 
     (action_directive,
      approval_person_organization,
      certification,
      contract,
      directed_action,
      document,
      product_definition,
      security_classification);
END_TYPE;

TYPE ap210_pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_document_reference_item WITH 
     (applied_external_identification_assignment,
      assembly_component_usage,
      characterized_object,
      configuration_item,
      descriptive_representation_item,
      externally_defined_item,
      material_designation,
      measure_representation_item,
      product,
      product_category,
      product_definition,
      product_definition_formation,
      property_definition,
      representation,
      representation_item);
END_TYPE;

TYPE ap210_pdm_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (product_definition,
     product_definition_formation,
     property_definition_representation,
     representation,
     representation_item,
     shape_aspect,
     shape_aspect_relationship);
END_TYPE;

TYPE ap210_pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_organization_item WITH 
     (action_directive,
      applied_identification_assignment,
      certification,
      directed_action,
      document,
      product,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      representation);
END_TYPE;

TYPE ap210_pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_person_and_organization_item WITH 
     (action_directive,
      applied_identification_assignment,
      certification,
      document,
      product,
      product_definition_formation,
      product_definition_formation_relationship,
      product_definition,
      directed_action);
END_TYPE;

TYPE ap210_pdm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (descriptive_representation_item, 
     configuration_item, 
     product_definition, 
     product_definition_formation, 
     product, 
     shape_aspect, 
     representation); 
END_TYPE; 

TYPE ap210_pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_security_classification_item WITH 
     (document,
      make_from_usage_option,
      product_definition_formation,
      product_definition);
END_TYPE;

TYPE ap210_pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_item WITH 
     (action_directive,
      product_definition,
      directed_action,
      approval_person_organization,
      contract,
	  document,
	  executed_action,
      security_classification,
      certification);
END_TYPE;

TYPE ap210_pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_identification_item WITH 
     (characterized_class,
      configuration_item,
      material_designation,
      person_and_organization,
      product,
      product_category,
      product_concept,
      product_definition_formation,
      organization);
END_TYPE;

TYPE promissory_usage_in_product_model_assigned_item = SELECT
     (product_concept,
      product_definition);
END_TYPE;

TYPE ap210_pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_action_request_item WITH 
     (versioned_action_request);
END_TYPE;

RULE approval_requires_approval_date_time FOR (approval,
         approval_date_time);
WHERE
  WR1: SIZEOF(QUERY ( app <* approval |
       NOT (SIZEOF (QUERY (adt <* approval_date_time |
       app :=: adt.dated_approval)) = 1))) = 0;
END_RULE;

RULE approval_requires_approval_person_organization FOR (approval,
         approval_person_organization);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (apo <* approval_person_organization |
       app :=: apo.authorized_approval)) >= 1))) = 0;
END_RULE;

RULE approval_role_constraint FOR
  (approval_role);
WHERE
  WR1: SIZEOF (QUERY (apr <* approval_role |
       NOT (apr\approval_role.role = 'authorizer')
       )) = 0;
END_RULE;

RULE approvals_are_assigned FOR
  (approval, approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (aa <* approval_assignment |
       app :=: aa.assigned_approval )) >= 1 ))) = 0;
END_RULE;

RULE certification_requires_date_or_date_and_time FOR
  (certification, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       cert IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       cert IN ada.items )) = 1 )))) = 0;
END_RULE;

RULE certification_unique_constraint FOR (certification);

LOCAL
  r :  BAG OF certification := QUERY (r <* certification | TRUE);
  pass :  BOOLEAN := TRUE;
  name_bag :  BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\certification.name ) THEN
    IF (r[i]\certification.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\certification.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1:  pass;

END_RULE;

RULE configuration_item_requires_person_organization FOR
  (configuration_item,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       ci IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       ci IN aoa.items )) = 1 )))) = 0;
END_RULE;

RULE contract_unique_constraint FOR (contract);

LOCAL
  r : BAG OF contract := QUERY (r <* contract | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\contract.name ) THEN
    IF (r[i]\contract.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\contract.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;

END_RULE;

RULE date_and_time_require_minute_and_second FOR ( date_and_time );
WHERE
  WR1: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.minute_component)))) = 0;
  WR2: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.second_component)))) = 0;
END_RULE;

RULE date_constraint FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       d.year_component < 1856)) = 0;
END_RULE;

RULE dependent_instantiable_action_directive FOR (action_directive);
WHERE
  WR1: SIZEOF (QUERY (ad <* action_directive |
       NOT (SIZEOF (USEDIN (ad, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_approval_status FOR (approval_status);
WHERE
WR1: SIZEOF (QUERY (ast <* approval_status |
     NOT (SIZEOF (USEDIN (ast, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF(QUERY ( ct <* contract_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (dt <* date |
       NOT (SIZEOF(USEDIN (dt, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (SIZEOF (USEDIN (dr, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (SIZEOF (USEDIN (dtr, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (SIZEOF (USEDIN (dt, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_named_unit FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (USEDIN (nu, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_organization_role FOR (
         organization_role);
WHERE
  WR1: SIZEOF (QUERY (org <* organization_role |
       NOT (SIZEOF (USEDIN (org, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_parametric_representation_context FOR
  (parametric_representation_context);
WHERE
  WR1: SIZEOF (QUERY (prc <* parametric_representation_context |
       NOT (SIZEOF (USEDIN (prc, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_person_and_organization_role FOR (
         person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (poar <* person_and_organization_role |
       NOT (SIZEOF (USEDIN (poar, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF (QUERY (ri <* representation_item |
       NOT (SIZEOF (USEDIN (ri, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_security_classification_level FOR (
         security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (SIZEOF (USEDIN (scl, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_shape_representation FOR (
         shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT (SIZEOF(USEDIN(sr, '')) >= 1))) = 0;
END_RULE;

RULE directed_action_requires_approval FOR
  (directed_action, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       da IN aaa.items )) = 1 ))) = 0;
END_RULE;

RULE directed_action_requires_date_or_date_and_time FOR
  (directed_action, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (da IN adata.items)
       AND (adata.role\date_time_role.name = 'start date'))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (da IN ada.items)
       AND (ada.role\date_role.name = 'start date'))) = 1 )))) = 0;
END_RULE;

RULE ee_product_configuration_unique_constraint FOR
 ( configuration_item );
LOCAL
  id_bag : BAG OF STRING := [];
  ci_bag : BAG OF configuration_item;
  cd_bag : BAG OF configuration_design;
  pass : BOOLEAN := TRUE;
  pdf_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_item) by 1;
  IF EXISTS( configuration_item[i].id ) THEN
    IF( NOT( configuration_item[i].id IN id_bag ) ) THEN
      id_bag := id_bag + configuration_item[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := [];
  ci_bag := QUERY( ci <* configuration_item | (ci.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(ci_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    cd_bag := USEDIN( ci_bag[j], 
'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
+ 'CONFIGURATION_DESIGN.CONFIGURATION');
    REPEAT k := 1 to SIZEOF(cd_bag) by 1;
      IF EXISTS( cd_bag[k].design ) THEN
        IF ( cd_bag[k].design IN pdf_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pdf_bag := pdf_bag + cd_bag[k].design;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_product_constraint FOR ( product );
WHERE
  WR1: SIZEOF(QUERY(prod <* product |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(prod,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'design owner')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(prod,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'design owner')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(p <* product |
              SIZEOF(USEDIN(p,
              'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
              + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0)) = 0;
END_RULE;

RULE ee_product_definition_constraint FOR 
( product_definition_with_associated_documents );
WHERE
  WR1: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(QUERY(adata <* USEDIN(pdwad,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(pdwad,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'creator')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(pdwad,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'creator')
       )) = 1))
       )) = 0;
  WR3: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
  WR4: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
END_RULE;

RULE ee_product_model_unique_constraint FOR (product_concept);

LOCAL
  r : BAG OF product_concept := QUERY (r <* product_concept | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\product_concept.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;
END_RULE;

RULE ee_product_unique_constraint FOR
 ( product );
LOCAL
  id_bag : BAG OF STRING := [];
  p_bag : BAG OF product;
  aoa_bag : BAG OF applied_organization_assignment;
  apaoa_bag : BAG OF applied_person_and_organization_assignment;
  pass : BOOLEAN := TRUE;
  o_bag : BAG OF organization;
  pao_bag : BAG OF person_and_organization;
END_LOCAL;

REPEAT i := 1 to SIZEOF(product) by 1;
  IF EXISTS( product[i].id ) THEN
    IF( NOT( product[i].id IN id_bag ) ) THEN
      id_bag := id_bag + product[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  o_bag := [];
  pao_bag := [];
  p_bag := QUERY( p <* product | (p.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aoa_bag := QUERY( aoa <* USEDIN( p_bag[j], 
'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
+ 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND 
(aoa.role\organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(aoa_bag) by 1;
      IF EXISTS( aoa_bag[k].assigned_organization ) THEN
        IF ( aoa_bag[k].assigned_organization IN o_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          o_bag := o_bag + aoa_bag[k].assigned_organization;
        END_IF;
      END_IF;
    END_REPEAT;
    apaoa_bag := QUERY( apaoa <* USEDIN( p_bag[j], 
'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
+ 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'PERSON_AND_ORGANIZATION' IN 
TYPEOF(apaoa.assigned_person_and_organization)) 
AND (apaoa.role\person_and_organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(apaoa_bag) by 1;
      IF EXISTS( apaoa_bag[k].assigned_person_and_organization ) THEN
        IF ( apaoa_bag[k].assigned_person_and_organization IN pao_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pao_bag := pao_bag + 
                     apaoa_bag[k].assigned_person_and_organization;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_product_version_supersedence_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       ((pdfr\product_definition_formation_relationship.name = 'product version supersedence')
       AND (NOT(pdfr.relating_product_definition_formation.of_product :=:
           pdfr.related_product_definition_formation.of_product)))
       )) = 0;
END_RULE;

RULE next_higher_assembly_relationship_constraint FOR
( next_assembly_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence|
       NOT(SIZEOF(QUERY(pd <* USEDIN(nauo,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ((SIZEOF(QUERY(pdr <* USEDIN(pd,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 3)
       )) <= 1)
       AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 2)
       )) <= 1))
       )) <= 1)
       )) = 0;
END_RULE;

RULE organization_unique_constraint FOR (organization);

LOCAL
  r : BAG OF organization := QUERY (r <* organization | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\organization.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;
END_RULE;

RULE planned_effectivity_constraint FOR ( configuration_effectivity );
WHERE
  WR1: SIZEOF(QUERY(ce <* configuration_effectivity |
       NOT(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))
       AND (ce.usage\product_definition_relationship.name = 'assembly composition'))
       )) = 0;
  WR2: SIZEOF(QUERY(ce <* configuration_effectivity |
       SIZEOF(USEDIN(ce,
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0 
       )) = 0;

END_RULE;

RULE planned_effectivity_unique_constraint FOR
 ( configuration_effectivity );
LOCAL
  ce_bag : BAG OF configuration_effectivity;
  ci_bag : BAG OF configuration_item := [];
  pass : BOOLEAN := TRUE;
  acu_bag : BAG OF assembly_component_usage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_effectivity) by 1;
  IF EXISTS( configuration_effectivity[i].configuration.configuration ) THEN
    IF( NOT( configuration_effectivity[i].configuration.configuration IN 
                                                            ci_bag ) ) THEN
      ci_bag := ci_bag + 
               configuration_effectivity[i].configuration.configuration;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ci_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ce_bag := QUERY( r <* configuration_effectivity |
((r.configuration.configuration :=: ci_bag[i]) AND 
                              (r.usage\product_definition_relationship.name = 'assembly composition')
AND ('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)) ) );
  acu_bag := [];
  REPEAT j := 1 to SIZEOF(ce_bag) by 1;
    IF EXISTS( ce_bag[j].usage ) THEN
      IF ( ce_bag[j].usage IN acu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        acu_bag := acu_bag + ce_bag[j].usage;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;


RULE product_concept_requires_configuration_item FOR
  (product_concept, configuration_item);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_concept |
       NOT (SIZEOF (QUERY (ci <* configuration_item |
       pc :=: ci.item_concept)) >=1 ))) = 0;
END_RULE;

RULE product_definition_formation_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition|
       (NOT('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1 ))))) = 0;
END_RULE;

RULE product_requires_person_organization FOR
  (product, applied_person_and_organization_assignment,
   applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       prod IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       prod IN aoa.items )) = 1 )))) = 0;
END_RULE;

RULE product_requires_product_definition_formation FOR
  (product, product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (pdf <* product_definition_formation |
       prod :=: pdf.of_product )) >= 1 ))) = 0;
END_RULE;

RULE restrict_action_request_status FOR (action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ars <* action_request_status |
       NOT (ars\action_request_status.status IN
       ['proposed', 'in work', 'issued', 'hold']))) = 0;
END_RULE;

RULE restrict_approval_status FOR (approval_status);
WHERE
  WR1: SIZEOF (QUERY (ast <* approval_status |
       NOT (ast\approval_status.name IN
       ['approved', 'not yet approved', 'disapproved', 'withdrawn']))) = 0;
END_RULE;

RULE restrict_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (dr\date_role.name IN ['creation date', 'request date', 'release date',
       'start date', 'contract date', 'certification date', 'sign off date',
       'classification date', 'declassification date']))) = 0;
END_RULE;

RULE security_classification_constraint FOR (security_classification,
     applied_date_and_time_assignment, applied_date_assignment,
     applied_person_and_organization_assignment, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (sc IN adata.items) AND
       ('classification date' = adata.role\date_time_role.name))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (sc IN ada.items) AND
       ('classification date' = ada.role\date_role.name))) = 1 )))) = 0;
  WR2: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (apa <* applied_person_and_organization_assignment |
       (sc IN apa.items) AND
       (apa.role\person_and_organization_role.name = 'classification officer')
       )) = 0)) = 0;
  WR3: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (aaa <* applied_approval_assignment |
       (sc IN aaa.items))) = 0)) = 0;
END_RULE;

RULE subtype_exclusive_action_request_assignment FOR 
  (action_request_assignment);
WHERE
  WR1: SIZEOF (QUERY (ara <* action_request_assignment |
       NOT (SIZEOF ([
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'CHANGE_REQUEST',
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'START_REQUEST']
       * TYPEOF(ara)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_property_definition_representation FOR 
  (property_definition_representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* property_definition_representation |
       NOT (SIZEOF ([
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'SHAPE_DEFINITION_REPRESENTATION',   
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'MATERIAL_PROPERTY_REPRESENTATION']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE;

RULE subtype_mandatory_address FOR (address);
WHERE
  WR1: SIZEOF (QUERY (add <* address |
       NOT (SIZEOF ([
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'PERSONAL_ADDRESS',
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'ORGANIZATIONAL_ADDRESS'] * 
       TYPEOF (add)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       NOT (
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'CALENDAR_DATE'
       IN TYPEOF (d)))) = 0;
END_RULE;

RULE subtype_mandatory_product_definition_usage FOR
  (product_definition_usage);
WHERE
  WR1: SIZEOF (QUERY (pdu <* product_definition_usage |
       NOT (SIZEOF([
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'ASSEMBLY_COMPONENT_USAGE',
       'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'MAKE_FROM_USAGE_OPTION'] * 
       TYPEOF(pdu)) = 1))) = 0;
END_RULE;


RULE versioned_action_request_requires_approval FOR
  (versioned_action_request, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       varq IN aaa.items )) = 1 ))) = 0;
END_RULE;

RULE versioned_action_request_requires_date_or_date_and_time FOR
  (versioned_action_request, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       varq IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       varq IN ada.items )) = 1 )))) = 0;
END_RULE;

RULE versioned_action_request_requires_person_organization FOR
  (versioned_action_request,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       varq IN apaoa.items )) >= 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       varq IN aoa.items )) >= 1 )))) = 0;
END_RULE;

RULE versioned_action_request_requires_status FOR
  (versioned_action_request, action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_status |
       ar :=: ars.assigned_request)) = 1))) = 0;
END_RULE;


RULE work_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  r : BAG OF versioned_action_request := 
QUERY( r <* versioned_action_request | 
(SIZEOF(QUERY( ara <* USEDIN(r,
'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST' ) |
((('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 
'CHANGE_REQUEST') IN TYPEOF(ara)) OR
(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 
'START_REQUEST') IN TYPEOF(ara))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF ( r[i].id IN id_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\ap210_product_rule_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N1687 - ISO/CD-TS 10303-1630 Ap210 product rule - EXPRESS MIM
*)


SCHEMA Ap210_product_rule_mim;
	USE FROM Ap210_product_data_management_mim;	-- ISO/TS 10303-1628
	USE FROM Product_rule_mim;	-- ISO/TS 10303-1739
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\appearance_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
ISO TC184/SC4/WG12 N2691 - ISO/TS 10303-1001 Appearance assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1912
*) 


SCHEMA Appearance_assignment_mim;

USE FROM aic_associative_draughting_elements;    -- ISO 10303-520

USE FROM aic_mechanical_design_geometric_presentation;    -- ISO 10303-517

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (invisibility,
   over_riding_styled_item,
   presentation_style_assignment,
   presentation_style_by_context,
   style_context_select,
   styled_item); 

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 


TYPE appearance_representation_identification_item = SELECT BASED_ON identification_item WITH 
   (draughting_model, 
    mechanical_design_geometric_presentation_representation);
END_TYPE; 

TYPE appearance_representation_version_item = SELECT BASED_ON versionable_item WITH 
   (draughting_model, 
    mechanical_design_geometric_presentation_representation);
END_TYPE; 

RULE styled_curve FOR 
(styled_item);
WHERE
  WR1: SIZEOF( QUERY( si <* styled_item | ('APPEARANCE_ASSIGNMENT_MIM.CURVE' IN TYPEOF (si.item)) AND (SIZEOF (QUERY (psa <* si.styles | (SIZEOF (QUERY (cs <* psa.styles | ('APPEARANCE_ASSIGNMENT_MIM.CURVE_STYLE' IN TYPEOF (cs)) )) > 0) )) <> 1) )) = 0;
END_RULE; 

END_SCHEMA;  -- Appearance_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\approval_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2910 - ISO/TS 10303-1012 Approval - EXPRESS MIM
*) 


SCHEMA Approval_mim;

USE FROM approval_schema   -- ISO 10303-41
  (approval,
   approval_date_time,
   approval_person_organization,
   approval_relationship,
   approval_role,
   approval_status); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM management_resources_schema   -- ISO 10303-41
  (approval_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011


TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH 
   (approval_person_organization);
END_TYPE; 

TYPE date_item_approval = SELECT BASED_ON date_item WITH 
   (approval_person_organization);
END_TYPE; 

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET[1:?] OF approval_item;
END_ENTITY;

END_SCHEMA;  -- Approval_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\area_2d_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3637 - ISO/CD-TS 10303-1631 Area 2d - EXPRESS MIM
*)

SCHEMA Area_2d_mim;
	USE FROM Extended_elemental_geometric_shape_mim;	-- ISO/TS 10303-1667
	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
	USE FROM Geometric_model_schema
		(circular_area,
		elliptic_area,
		polygonal_area,
		primitive_2d,
		rectangular_area);
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_2d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3640 - ISO/CD-TS 10303-1632 Assembly 2d shape - EXPRESS MIM
*)


SCHEMA Assembly_2d_shape_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3643 - ISO/CD-TS 10303-1633 Assembly 3d shape - EXPRESS MIM
*)


SCHEMA Assembly_3d_shape_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_component_placement_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3292 - ISO/CD-TS 10303-1634 Assembly component placement requirements - EXPRESS MIM
*)
SCHEMA Assembly_component_placement_requirements_mim;

	USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740	

TYPE acpr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (group_shape_aspect,
     group_product_definition);
END_TYPE;

TYPE acpr_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (shape_aspect,
     requirements_property);
END_TYPE;

ENTITY group_product_definition
  SUBTYPE OF (component_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'design requirement';
  WR2: (NOT (SELF\product_definition.description = 
                                      'placement group')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd))) >= 1);
END_ENTITY;

RULE component_placement_restriction_assignment_constraint FOR
( representation );
LOCAL
  cpra : SET OF representation := QUERY( cpra <* representation |
          cpra.name = 'component placement restriction assignment');
     i : INTEGER ;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mra : BOOLEAN := FALSE;
  mrv : BOOLEAN := FALSE;
END_LOCAL;
 REPEAT i := 1 to SIZEOF (cpra);
  IF NOT(pass1) THEN ESCAPE; END_IF;

  IF NOT((SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment area') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))
    ) = 1 ) 
     )) <=1 ) OR
(SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment volume') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) <=1 )
        ) THEN pass1 := FALSE;
  END_IF;      
  mra := (SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment area') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'MOUNTING_RESTRICTION_AREA' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) =1 );
  mrv := (SIZEOF(QUERY(rr <* USEDIN(cpra[i],
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name =
    'component placement restriction assignment volume') AND
    (SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2,
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
    ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(pdr.definition.definition)))
    ) = 1 )
     )) =1 );
  IF NOT(mra OR mrv) THEN pass1 := FALSE; END_IF;
 END_REPEAT;
 REPEAT i := 1 to SIZEOF (cpra);
  IF NOT(pass1) THEN ESCAPE; END_IF;
  IF NOT(pass2) THEN ESCAPE; END_IF;

  IF NOT(SIZEOF(QUERY(pdr <* USEDIN(cpra[i],
  'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
    ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
  'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.definition))
    AND
    (pdr.definition\group.name =
    'item restricted requirements property')
     )
    ) = 1 ) THEN pass2 := FALSE;
  END_IF;
 END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2; 
END_RULE;

ENTITY mounting_restriction_area
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PHYSICAL_UNIT' IN TYPEOF (SELF.of_shape.definition));

  WR3: SELF.of_shape.definition.frame_of_reference.name IN ['physical design'];

  WR4: SELF.of_shape.definition\product_definition.name = 'assembly module';

  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'CSG_2D_SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)))) = 1))) = 0;
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'mounting surface') AND 
       (sar.related_shape_aspect\shape_aspect.description =
       'interconnect module component surface feature')))) = 1;
  WR7: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect ||
       SELF\mounting_restriction_area))) = 0;

END_ENTITY;

ENTITY mounting_restriction_volume
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PHYSICAL_UNIT' IN TYPEOF (SELF.of_shape.definition));

  WR2: SELF.of_shape.definition.frame_of_reference.name IN ['physical design'];

  WR3: SELF.of_shape.definition.name = 'assembly module';

  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
        (pdr.used_representation\representation.context_of_items\
       geometric_representation_context.coordinate_space_dimension = 3)
       )) = 1))) = 0;
(* invlaid csa
  WR5: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (sar.related_shape_aspect)) AND
       (sar\shape_aspect_relationship.name = 'mounting surface') AND 
       (sar.related_shape_aspect\shape_aspect.description =
       'interconnect module component surface feature'))) = 1; *)
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect ||
       SELF\mounting_restriction_volume))) = 0;
END_ENTITY;

RULE placement_group_area_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'area impacted group') AND NOT
       (('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       OR (('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       AND ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'GROUP_PRODUCT_DEFINITION'
       IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))
       AND ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'PRODUCT_DEFINITION_CONTEXT'
IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))
   AND 
     (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name
       = 'design requirement') 
       )))) = 0;
END_RULE;

RULE placement_group_volume_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT
       ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'volume impacted group') AND NOT
       (('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'GROUP_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       OR (('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       AND ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'GROUP_PRODUCT_DEFINITION'
       IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))
       AND ('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'PRODUCT_DEFINITION_CONTEXT'
IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))
   AND 
     (sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name
       = 'design requirement') 
       )))) = 0;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_functional_interface_requirement_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3295 - ISO/CD-TS 10303-1635 Assembly functional interface requirement - EXPRESS MIM
*)
SCHEMA Assembly_functional_interface_requirement_mim;

	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
	USE FROM Specification_document_mim; 	-- ISO/TS 10303-1747
	
TYPE afir_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (protocol_physical_layer_definition);
END_TYPE;
	
ENTITY minimally_defined_connector
  SUBTYPE OF (packaged_part);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
       'PACKAGED_PART_TERMINAL' IN TYPEOF (sa)) AND 
       (sa.description = 'interface terminal')
       )) >= 0))) >= 0;
END_ENTITY;

ENTITY protocol_physical_layer_definition 
 SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY protocol_requirement_allocation_to_part_terminal
  SUBTYPE OF (requirement_assignment, requirement_allocation_group);
WHERE
  WR1: 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
       'REQUIREMENTS_PROPERTY' IN TYPEOF 
   (SELF\property_definition_relationship.relating_property_definition);
END_ENTITY;

RULE mating_connector_termination_constraint FOR ( shape_aspect );
WHERE
  WR1: SIZEOF(QUERY(sa <* shape_aspect |
       (sa\shape_aspect.description = 'mating connector termination')
       AND NOT(('ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.'
       + 'COMPONENT_DEFINITION' IN TYPEOF(sa.of_shape.definition))
       AND (sa.of_shape.definition\product_definition.description = 
                                           'mating connector')))) = 0;
END_RULE;

RULE mating_connector_termination_unique_constraint FOR
 ( shape_aspect );
LOCAL
  mct : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
(sa\shape_aspect.description = 'mating connector termination') );
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ppt_bag : BAG OF packaged_part_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(mct) by 1;
  IF EXISTS( mct[i].of_shape.definition ) THEN
    IF ( ('ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
'COMPONENT_DEFINITION' IN TYPEOF(mct[i].of_shape.definition)) AND
(mct[i].of_shape.definition\product_definition.description = 'mating connector') ) THEN
      IF( NOT( mct[i].of_shape.definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + mct[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ppt_bag := [];
  sa_bag := QUERY( sa <* mct | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'instantiated terminal') AND (
'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ppt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ppt_bag := ppt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3298 - ISO/CD-TS 10303-1636 Assembly module design - EXPRESS MIM
*)
SCHEMA Assembly_module_design_mim;

	USE FROM Altered_package_mim;	-- ISO/TS 10303-1601
	USE FROM Assembly_module_usage_view_mim;	-- ISO/TS 10303-1642
	USE FROM Bare_die_mim;	-- ISO/TS 10303-1650
	USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721

ENTITY component_mounting_feature
  SUBTYPE OF (physical_component_feature);
WHERE
  WR1: 'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: (SIZEOF (['ASSEMBLY_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROBE_ACCESS_AREA',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'LAND'] * 
       TYPEOF (SELF)) = 0);
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 
       'planar projected shape')) 
       <= 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) 
       <= 1))) = 0;
  WR5: (NOT (SELF\shape_aspect.description IN ['component feature'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1);
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
END_ENTITY;

ENTITY packaged_component
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PACKAGED_PART',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SIZEOF (QUERY (pa <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'package alternate') |
       (SIZEOF (['ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PACKAGE',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'LIBRARY_DEFINED_PACKAGE'] *
       TYPEOF (pa.relating_product_definition)) = 1) AND
       (pa.relating_product_definition\product_definition.description =
       'altered package'))) <= 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'packaged component join terminal'))) >= 1))) = 0;
  WR4: (NOT (SELF\product_definition.description = 'packaged connector component')) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PACKAGED_PART',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (TRUE))) = 1);
  WR5: (NOT (SELF\product_definition.description = 'packaged connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'packaged component join terminal'))) 
        >= 1))) = 0);
  WR6: (NOT (SELF\product_definition.description = 'routed packaged component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF (QUERY (pd <* USEDIN (sa,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (USEDIN (pd, 
        'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) 
       = 1)) = 1)) = 1))) = 0);
END_ENTITY;

ENTITY routed_physical_component
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ASSEMBLY_MODULE_DESIGN_MIM.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SELF\product_definition.description :<>: 'laminate component';
END_ENTITY;

RULE component_feature_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  cfer : BAG OF descriptive_representation_item := 
      QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'component feature external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(cfer) by 1;
  IF EXISTS( cfer[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( cfer[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + cfer[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* cfer | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'ASSEMBLY_MODULE_DESIGN_MIM.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'component external reference' ) );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF( QUERY( rep <* representation | (rep\representation.name =
        'component external reference') AND 
        (SIZEOF( QUERY( dri <* rep.items | NOT(
        ('ASSEMBLY_MODULE_DESIGN_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ASSEMBLY_MODULE_DESIGN_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ASSEMBLY_MODULE_DESIGN_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ASSEMBLY_MODULE_DESIGN_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
   WR5: SIZEOF(QUERY (rep <* representation |
        (rep\representation.name = 'component external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items | 
        NOT(('ASSEMBLY_MODULE_DESIGN_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND 
        (dri\representation_item.name = 'reference designation')))) = 1)))=0;
END_RULE;

RULE component_mounting_clearance_relationship_constraint FOR
( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'mounting clearance')
       AND (SIZEOF(QUERY(lmwu <* rep.items |
       ('ASSEMBLY_MODULE_DESIGN_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))
       AND (lmwu\representation_item.name = 'minimum height')
       )) = 0))) = 0;
END_RULE;

RULE component_overlap_relationship_constraint FOR
( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'overlap clearance')
       AND (SIZEOF(QUERY(lmwu <* rep.items |
       ('ASSEMBLY_MODULE_DESIGN_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))
       AND (lmwu\representation_item.name = 'minimum clearance')
       )) = 0))) = 0;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_macro_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3352 - ISO/CD-TS 10303-1637 Assembly module macro definition - EXPRESS MIM
*)


SCHEMA Assembly_module_macro_definition_mim;
	USE FROM Interconnect_module_with_macros_mim;	-- ISO/TS 10303-1687

SUBTYPE_CONSTRAINT assembly_module_terminal_subtypes FOR assembly_module_terminal;         
  (ONEOF (assembly_module_interface_terminal, 
           assembly_module_join_terminal));
END_SUBTYPE_CONSTRAINT;        

ENTITY assembly_module_join_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY;

RULE 
component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'ASSEMBLY_MODULE_MACRO_DEFINITION_MIM.' +
'ASSEMBLY_MODULE_JOIN_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3301 - ISO/CD-TS 10303-1642 Assembly module usage view - EXPRESS MIM
*)
SCHEMA Assembly_module_usage_view_mim;

--	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Packaged_connector_model_mim;	-- ISO/TS 10303-1708

ENTITY assembly_definition
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR 
        (SELF\product_definition.name = 'assembly module');
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'ASSEMBLY_DEFINITION', 
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 'assembly module')
        )) = 1);
  WR4: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY;

ENTITY assembly_module_interface_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY;

ENTITY assembly_module_terminal
  SUPERTYPE OF (assembly_module_interface_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: NOT EXISTS(SELF.of_shape.definition\product_definition.name) OR
      (SELF.of_shape.definition\product_definition.name = 'assembly module');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR5: (NOT (SELF\shape_aspect.description = 'pca terminal')) OR
       ((SIZEOF(TYPEOF (SELF.of_shape.definition) *
       ['ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'ASSEMBLY_DEFINITION',
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION',
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION']) >=1)
       AND (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 'physical design usage'));
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
  WR7: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 'interface terminal')) <= 1;
END_ENTITY;
(**
ENTITY externally_defined_assembly_definition
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'assembly module');
  WR3: (NOT (SELF.frame_of_reference\application_context_element.name = 'physical design usage')) 
        OR (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY;

ENTITY library_defined_assembly_definition
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SELF\product_definition.name = 'assembly module';
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design usage')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('ASSEMBLY_MODULE_USAGE_VIEW_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'pca terminal'))) >= 2))) = 0);
END_ENTITY;
*)
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_cable_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3304 - ISO/CD-TS 10303-1644 Assembly module with cable component - EXPRESS MIM
*)
SCHEMA Assembly_module_with_cable_component_mim;

	USE FROM Cable_mim;	-- ISO/TS 10303-1653

ENTITY cable_component
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_MODULE_WITH_CABLE_COMPONENT_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['ASSEMBLY_MODULE_WITH_CABLE_COMPONENT_MIM.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1;
  WR2: SELF\product_definition.description :<>: 'laminate component';
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_cable_component_2d_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3379 - ISO/CD-TS 10303-1638 Assembly module with cable component 2d - EXPRESS MIM
*)


SCHEMA Assembly_module_with_cable_component_2d_mim;
	USE FROM Assembly_module_with_cable_component_mim;	-- ISO/TS 10303-1644
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_cable_component_3d_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3382 - ISO/CD-TS 10303-1639 Assembly module with cable component 3d - EXPRESS MIM
*)


SCHEMA Assembly_module_with_cable_component_3d_mim;
	USE FROM Assembly_module_with_cable_component_mim;	-- ISO/TS 10303-1644
	USE FROM Physical_unit_3d_design_view_mim;	-- ISO/TS 10303-1725
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_interconnect_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3307 - ISO/CD-TS 10303-1643 Assembly module with interconnect component - EXPRESS MIM
*)
SCHEMA Assembly_module_with_interconnect_component_mim;

	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
	USE FROM Interconnect_module_usage_view_mim;	-- ISO/TS 10303-1686
	USE FROM Interface_component_mim;	-- ISO/TS 10303-1691	

ENTITY interconnect_module_component_surface_feature
  SUBTYPE OF (physical_component_feature);
WHERE
  WR1: 'ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: (SELF\shape_aspect.description IN [
       'interconnect module component surface feature']);
  WR3: SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description IN
       ['interconnect module secondary surface',
        'interconnect module primary surface',
        'interconnect module cavity surface',
        'interconnect module cutout surface',
        'interconnect module edge surface',
        'interconnect module edge segment surface'])) = 1;
END_ENTITY;

RULE interconnect_component_interface_terminal_unique_constraint FOR
 ( physical_component_interface_terminal );
LOCAL
  icit : BAG OF physical_component_interface_terminal := QUERY( cit <*
physical_component_interface_terminal | (cit\shape_aspect.description =
'interconnect component interface terminal') );
  icd_bag : BAG OF interface_component_definition := [];
  cit_bag : BAG OF physical_component_interface_terminal;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(icit) by 1;
  IF EXISTS( icit[i].of_shape.definition ) THEN
    IF ( 'ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' +
'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(icit[i].of_shape.definition) ) 
                                                          THEN
      IF ( NOT ( icit[i].of_shape.definition IN icd_bag )) THEN
        icd_bag := icd_bag + icit[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(icd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  cit_bag := 
        QUERY( cit <* icit | (cit.of_shape.definition :=: icd_bag[i]) );
  REPEAT j := 1 to SIZEOF(cit_bag) by 1;
    IF EXISTS( cit_bag[j]\shape_aspect.name ) THEN
      IF ( cit_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + cit_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE interconnect_component_join_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  icjt : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'interconnect component join terminal') );
  cd_bag : BAG OF component_definition := [];
  ct_bag : BAG OF component_terminal;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(icjt) by 1;
  IF EXISTS( icjt[i].of_shape.definition ) THEN
    IF ( 'ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' +
'COMPONENT_DEFINITION' IN TYPEOF(icjt[i].of_shape.definition) ) THEN
      IF ( NOT ( icjt[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + icjt[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  ct_bag := QUERY( ct <* icjt | (ct.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF EXISTS( ct_bag[j]\shape_aspect.name ) THEN
      IF ( ct_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + ct_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_macro_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3355 - ISO/CD-TS 10303-1640 Assembly module with macro component - EXPRESS MIM
*)


SCHEMA Assembly_module_with_macro_component_mim;
	USE FROM Assembly_module_macro_definition_mim;	-- ISO/TS 10303-1637
	USE FROM Assembly_module_with_subassembly_mim;	-- ISO/TS 10303-1641

  ENTITY assembly_module_macro_component
    SUBTYPE OF (assembly_component);
  END_ENTITY;
	
ENTITY assembly_module_macro_component_join_terminal
  SUBTYPE OF (physical_component_terminal);
WHERE
  WR1: NOT (SELF\shape_aspect.description IN 
      ['bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal', 'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']);
END_ENTITY;
	
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_packaged_connector_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3652 - ISO/CD-TS 10303-1645 Assembly module with packaged connector component - EXPRESS MIM
*)
SCHEMA Assembly_module_with_packaged_connector_component_mim;

	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
	USE FROM Interface_component_mim;	-- ISO/TS 10303-1691

ENTITY interface_mounted_join
 SUBTYPE OF (shape_aspect_relationship,shape_aspect);
WHERE
  WR1: ('ASSEMBLY_MODULE_WITH_PACKAGED_CONNECTOR_COMPONENT_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal');
  WR2: ('ASSEMBLY_MODULE_WITH_PACKAGED_CONNECTOR_COMPONENT_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       ((SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal') OR
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'packaged connector component interface terminal'));
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_module_with_subassembly_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3358 - ISO/CD-TS 10303-1641 Assembly module with subassembly - EXPRESS MIM
*)


SCHEMA Assembly_module_with_subassembly_mim;
	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_physical_interface_requirement_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3361 - ISO/CD-TS 10303-1647 Assembly physical interface requirement - EXPRESS MIM
*)


SCHEMA Assembly_physical_interface_requirement_mim;

	USE FROM Assembly_functional_interface_requirement_mim;	-- ISO/TS 10303-1635
	USE FROM Printed_physical_layout_template_mim; -- ISO/TS 10303-1737
	USE FROM Requirement_decomposition_mim; -- ISO/TS 10303-1740
	USE FROM Product_structure_schema(specified_higher_usage_occurrence);

TYPE apir_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (shape_aspect); 
END_TYPE; 

TYPE apir_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (protocol_physical_layer_definition); 
END_TYPE; 

RULE mating_connector_placement_relationship_constraint FOR
( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'mating connector placement')
       AND (SIZEOF(QUERY(p <* sr.items |
       ('ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENT_MIM.'
        + 'PLACEMENT' IN TYPEOF(p))
       AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
END_RULE;

RULE next_higher_assembly_interface_requirement_constraint FOR 
( specified_higher_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence |
       NOT(SIZEOF(QUERY(pd <* USEDIN(shuo,
       'ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENT_MIM.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENT_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENT_MIM.'
       + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))
       AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0)
       )) = 0)
       )) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_physical_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3310 - ISO/CD-TS 10303-1648 Assembly physical requirement allocation - EXPRESS MIM
*)
SCHEMA Assembly_physical_requirement_allocation_mim;

	USE FROM Assembly_physical_interface_requirement_mim;	-- ISO/TS 10303-1647
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Shield_mim;	-- ISO/TS 10303-1744

TYPE apra_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (shape_aspect,
     product_definition);
END_TYPE;

TYPE apra_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (product_definition, 
	shape_aspect); 
END_TYPE; 

ENTITY electromagnetic_compatibility_requirement_allocation
  SUPERTYPE OF (shield_allocation)
  SUBTYPE OF (requirement_assignment); --product_definition_relationship);
END_ENTITY;

ENTITY shield_allocation
  SUBTYPE OF (electromagnetic_compatibility_requirement_allocation);
END_ENTITY;

ENTITY thermal_requirement_allocation
  SUBTYPE OF (requirement_assignment); --product_definition_relationship);
END_ENTITY;

RULE interface_component_allocation_constraint FOR 
( product_definition_relationship );
   WHERE
     WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
          (pdr\product_definition_relationship.name = 'interface component allocation') AND
          NOT(('ASSEMBLY_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
   'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition)) AND
(pdr.relating_product_definition\product_definition.description = 'mating connector')))) = 0;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3364 - ISO/CD-TS 10303-1646 Assembly shape - EXPRESS MIM
*)


SCHEMA Assembly_shape_mim;
	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_structure_mim.exp
   ------------------------------------------------------------
*)

(* 
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2516 - ISO/TS 10303-1026 Assembly structure - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1136
*)

SCHEMA Assembly_structure_mim;

USE FROM Product_view_definition_relationship_mim; -- ISO/TS 10303-1041
USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM product_structure_schema -- ISO 10303-44
  (assembly_component_usage,
   next_assembly_usage_occurrence,
   promissory_usage_occurrence,
   quantified_assembly_component_usage,
   specified_higher_usage_occurrence);

END_SCHEMA;






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\assembly_technology_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3313 - ISO/CD-TS 10303-1649 Assembly technology - EXPRESS MIM
*)
SCHEMA Assembly_technology_mim;
	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
	USE FROM Component_grouping_mim;	-- ISO/TS 10303-1656
	USE FROM Product_identification_extension_mim;	-- ISO/TS 10303-1738

REFERENCE FROM Physical_unit_usage_view_mim 	-- ISO/TS 10303-1732
  (is_assembly_module_design);

REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);

TYPE at_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (assembly_joint);
END_TYPE;

TYPE at_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (assembly_bond_definition);
END_TYPE;

ENTITY assembly_bond_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR2: SIZEOF (QUERY (aga <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'BOND_CATEGORY' IN
       TYPEOF (aga.assigned_group))) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 2' ))  = 1;
  WR5: (('ASSEMBLY_TECHNOLOGY_MIM.' +
       'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN
        TYPEOF (SELF.of_shape.definition))
       AND
       (SIZEOF (QUERY (prpc <* USEDIN (SELF.of_shape.definition.formation.of_product,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'technology specific model')) >= 1));
  WR6: ('ASSEMBLY_TECHNOLOGY_MIM.' +
        'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF (SELF.of_shape.definition)) AND
        (SELF.of_shape.definition\product_definition.name='assembly bond model');
END_ENTITY;

ENTITY assembly_joint
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: (('ASSEMBLY_TECHNOLOGY_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal',
       'interconnect component join terminal', 
       'interconnect module component terminal',  
       'package terminal occurrence', 
       'packaged component join terminal'])) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'COMPONENT_MOUNTING_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect));
  WR2: (('ASSEMBLY_TECHNOLOGY_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal',  
       'package terminal occurrence', 
       'packaged component join terminal'])) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect)) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'COMPONENT_MOUNTING_FEATURE' IN
       TYPEOF (SELF.relating_shape_aspect));
  WR3: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with bonding')) OR
       (SIZEOF (QUERY (ddu <* QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'default definition usage') |
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'ASSEMBLY_BOND_DEFINITION' IN
       TYPEOF (ddu.relating_shape_aspect))) = 1);
  WR4: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with bonding')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'bond assembly position') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'MAPPED_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'assembly position'))) = 1))) = 1)) <= 1);
  WR5: (NOT (SELF\shape_aspect_relationship.name = 
       'assembled with fasteners')) OR
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition));
  WR6: ('ASSEMBLY_TECHNOLOGY_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) OR
       is_assembly_module_design(SELF.of_shape.definition); 
  WR7: (NOT (SELF\shape_aspect_relationship.name =
       'assembled with bonding')) OR
       (SIZEOF (QUERY (ddu <* QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'default definition usage') |
       ('ASSEMBLY_TECHNOLOGY_MIM.' +
        'ASSEMBLY_BOND_DEFINITION' IN
       TYPEOF (ddu.relating_shape_aspect)) AND
       (SIZEOF (QUERY (sar <* USEDIN (ddu.relating_shape_aspect,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1)
       AND (SIZEOF (QUERY (sar <* USEDIN (ddu.relating_shape_aspect,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name  = 'bonded feature 1' ))  = 1)
       )) = 1);
  WR8: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'ASSEMBLY_TECHNOLOGY_MIM.'+
       'ASSEMBLY_JOINT');
END_ENTITY;

ENTITY component_mating_constraint_condition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
END_ENTITY;

RULE default_assembly_bond_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'default assembly bond shape')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(sr,
       'ASSEMBLY_TECHNOLOGY_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ASSEMBLY_TECHNOLOGY_MIM.'
       + 'SHAPE_ASPECT'
       IN TYPEOF(pdr.definition.definition)))) = 1))) = 0;
END_RULE;

ENTITY connection_zone_based_assembly_joint
  SUBTYPE OF (assembly_joint);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 1')) = 1;
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 2')) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar.relating_shape_aspect\shape_aspect.description = 'connection zone')) = 2;

END_ENTITY;

ENTITY reference_packaged_part_assembly_implementation
 SUBTYPE OF (physical_unit);
WHERE
  WR1: (SIZEOF (QUERY (prpc <* 
       USEDIN (SELF.formation.of_product,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) AND
       (SELF\product_definition.name = 'assembly module');
  WR2: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['ASSEMBLY_TECHNOLOGY_MIM.' +
       'ASSEMBLY_DEFINITION', 
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'LIBRARY_DEFINED_ASSEMBLY_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name =
       'assembly module') AND
       (SIZEOF (QUERY (prpc <*
       USEDIN (du.relating_product_definition.formation.of_product,
       'ASSEMBLY_TECHNOLOGY_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1)
       )) = 1);
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\associative_text_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2694 - ISO/TS 10303-1132 Associative text - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1665
*) 


SCHEMA Associative_text_mim;

USE FROM Appearance_assignment_mim;    -- ISO/TS 10303-1001

USE FROM Curve_appearance_mim;    -- ISO/TS 10303-1003

USE FROM Text_appearance_mim;    -- ISO/TS 10303-1136

USE FROM Construction_geometry_mim;    -- ISO/TS 10303-1131

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM draughting_element_schema   -- ISO 10303-101
  (leader_curve); 

USE FROM aic_associative_draughting_elements;    -- ISO 10303-520

USE FROM aic_draughting_annotation;    -- ISO 10303-504

USE FROM aic_draughting_elements;    -- ISO 10303-506

USE FROM presentation_definition_schema;    -- ISO 10303-46


END_SCHEMA;  -- Associative_text_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\bare_die_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3316 - ISO/CD-TS 10303-1650 Bare die - EXPRESS MIM
*)
SCHEMA Bare_die_mim;

	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Part_feature_function_mim;	-- ISO/TS 10303-1712
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705

ENTITY bare_die
 SUBTYPE OF (physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\property_definition_relationship.name = 'implemented function') |
       ('BARE_DIE_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'BARE_DIE_MIM.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY;

ENTITY bare_die_bottom_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['BARE_DIE_MIM.' +
       'BARE_DIE',
       'BARE_DIE_MIM.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'BARE_DIE_MIM.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\bare_die_bottom_surface ||
       SELF\part_mounting_feature ||
       SELF\bare_die_surface)) = 0;
END_ENTITY;

ENTITY bare_die_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: 'BARE_DIE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR2: 'BARE_DIE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('BARE_DIE_MIM.' +
       'BARE_DIE_EDGE_SURFACE' IN TYPEOF
       (ce.relating_shape_aspect) ))) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\bare_die_edge_segment_surface)) = 0;
END_ENTITY;

ENTITY bare_die_edge_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['BARE_DIE_MIM.' +
       'BARE_DIE',
       'BARE_DIE_MIM.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'BARE_DIE_MIM.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_edge_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY;

ENTITY bare_die_surface
 ABSTRACT SUPERTYPE OF (ONEOF( bare_die_bottom_surface, 
                         bare_die_top_surface, 
                        bare_die_edge_surface))
 SUBTYPE OF (part_mounting_feature);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['BARE_DIE_MIM.' +
       'BARE_DIE',
       'BARE_DIE_MIM.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'BARE_DIE_MIM.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
END_ENTITY;

ENTITY bare_die_terminal
  SUBTYPE OF (minimally_defined_bare_die_terminal);
WHERE
  WR1: 'BARE_DIE_MIM.' +
       'BARE_DIE' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'external connection area') |
       eca.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'BARE_DIE_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR4: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'seating plane zone') |
       'BARE_DIE_MIM.' +
       'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN 
       TYPEOF (eca.related_shape_aspect))) <= 1;
END_ENTITY;

ENTITY bare_die_top_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['BARE_DIE_MIM.' +
       'BARE_DIE',
       'BARE_DIE_MIM.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'BARE_DIE_MIM.' +
       'LIBRARY_DEFINED_BARE_DIE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_top_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY;
(** 
ENTITY externally_defined_bare_die
  SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('BARE_DIE_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'BARE_DIE_MIM.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY;

ENTITY library_defined_bare_die
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: SIZEOF (QUERY (ifdu <* QUERY (pdr <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('BARE_DIE_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifdu.relating_product_definition)) AND
       (ifdu.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'device unit technology') |
       dut.relating_property_definition\property_definition.name = 
       'unit technology')) = 1)) = 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'BARE_DIE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'BARE_DIE_MIM.' +
       'BARE_DIE_TERMINAL' IN 
       TYPEOF (sa))) >= 2))) = 0;
END_ENTITY;
*)
ENTITY minimally_defined_bare_die_terminal
  SUPERTYPE OF (bare_die_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'BARE_DIE_MIM.' +
       'BARE_DIE' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'external connection area') |
       eca.related_shape_aspect\shape_aspect.description = 'connection zone')) <= 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'BARE_DIE_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'BARE_DIE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'BARE_DIE_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
END_ENTITY;

RULE bare_die_unique_constraint FOR
 ( bare_die); --, externally_defined_bare_die, library_defined_bare_die );
LOCAL
  bd : BAG OF physical_unit := QUERY( r <* bare_die |
(r.frame_of_reference.name = 'physical design usage') );
(**  edbd : BAG OF physical_unit := QUERY( r <* externally_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  ldbd : BAG OF physical_unit := QUERY( r <* library_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pdr_bag : BAG OF product_definition_relationship;
  fu_bag : BAG OF functional_unit := [];
  pu_bag : BAG OF physical_unit;
  ut_bag : BAG OF property_definition;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition;
END_LOCAL;

pu := bd; -- + edbd + ldbd;
REPEAT i := 1 to SIZEOF(pu) by 1;
  pdr_bag := QUERY( pdr <* USEDIN( pu[i],
'BARE_DIE_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
( (pdr\product_definition_relationship.name = 'implemented function') AND
(pdr.relating_product_definition.frame_of_reference.name = 
         'functional design usage')
AND ('BARE_DIE_MIM.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) ) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].relating_product_definition ) THEN
      IF( NOT( pdr_bag[j].relating_product_definition IN fu_bag ) ) THEN
        fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pu_bag := QUERY( r <* pu | (SIZEOF(QUERY(pdr <* USEDIN( fu_bag[i],
'BARE_DIE_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION' ) |
((pdr\product_definition_relationship.name = 'implemented function')AND
        (pdr.related_product_definition :=: r)) ))>0) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(pu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ut_bag := QUERY( pd <* USEDIN( pu_bag[j],
'BARE_DIE_MIM.' +
'PROPERTY_DEFINITION.DEFINITION' ) | (pd\property_definition.name = 'unit technology') );
    REPEAT k := 1 to SIZEOF(ut_bag) by 1;
      IF EXISTS( ut_bag[k] ) THEN
        IF ( ut_bag[k] IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + ut_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\basic_curve_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3367 - ISO/CD-TS 10303-1651 Basic curve - EXPRESS MIM
*)


SCHEMA Basic_curve_mim;
	USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128

	USE FROM geometry_schema
		(trimmed_curve,
		line,
		composite_curve,
		composite_curve_segment,
		pcurve,
		surface_curve);
	
TYPE bc_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (trimmed_curve);
END_TYPE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\basic_geometry_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3370 - ISO/CD-TS 10303-1652 Basic geometry - EXPRESS MIM
*)


SCHEMA Basic_geometry_mim;

	USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

	USE FROM Geometry_schema(plane,
	point_on_curve,
	curve,
	line,
	point_on_surface,
	degenerate_pcurve,
	surface,
	oriented_surface); -- required by mapping

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\cable_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3319 - ISO/CD-TS 10303-1653 Cable - EXPRESS MIM
*)
SCHEMA Cable_mim;

	USE FROM Assembly_module_with_packaged_connector_component_mim;	-- ISO/TS 10303-1645

ENTITY cable_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'CABLE_MIM.' +
       'CABLE_USAGE_VIEW' IN 
       TYPEOF (SELF.of_shape.definition);
END_ENTITY;

ENTITY cable_usage_view
 SUBTYPE OF (physical_unit);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'CABLE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'CABLE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'CABLE_MIM.' +
       'CABLE_TERMINAL' IN 
       TYPEOF (sa))) >= 1))) = 0;
  WR2: SELF.frame_of_reference.name IN ['physical design usage'];
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\certification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N1148 - ISO/TS 10303-1044 Certification - EXPRESS MIM
*) 


SCHEMA Certification_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (role_association,
   role_select); 

USE FROM certification_schema   -- ISO 10303-41
  (certification,
   certification_type); 

USE FROM management_resources_schema   -- ISO 10303-41
  (certification_assignment); 


TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;

END_SCHEMA;  -- Certification_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\characteristic_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3322 - ISO/CD-TS 10303-1654 Characteristic - EXPRESS MIM
*)
SCHEMA Characteristic_mim;

	USE FROM Document_assignment_mim;	-- ISO/TS 10303-1122
	USE FROM Extended_measure_representation_mim;	-- ISO/TS 10303-1106
	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753

USE FROM Group_schema(group);

USE FROM Qualified_measure_schema
	(expanded_uncertainty,
	qualitative_uncertainty,
	measure_qualification);

TYPE c_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (coordinated_representation_item);
END_TYPE;


ENTITY characteristic_type
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN [
       'string property',
       'logical property',
       'boolean property',
       'numeric property',
       'physical property',
       'externally defined property',
       'polar complex numeric property',
       'compound characteristic'
        ];

END_ENTITY;

ENTITY coordinated_representation_item
  SUBTYPE OF (representation, representation_item);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'CHARACTERISTIC_MIM.' + 
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       SIZEOF (USEDIN (pdr, 
       'CHARACTERISTIC_MIM.' +
       'DATA_ENVIRONMENT.ELEMENTS')) <= 1)) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 
       'CHARACTERISTIC_MIM.' + 
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
  WR3: (NOT (SELF\representation_item.name = 'tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'CHARACTERISTIC_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) >= 1); 
  WR4: (NOT (SELF\representation_item.name = 'plus minus tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'CHARACTERISTIC_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 3); 
  WR5: (NOT (SELF\representation_item.name = 'symmetrical tolerance')) OR
       (SIZEOF (QUERY (it <* SELF.items |
       'CHARACTERISTIC_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 2); 
  WR6: (NOT (SELF\representation_item.name = 'plus minus tolerance'))
       OR
       (
        (SIZEOF (QUERY (it <* SELF.items
         | ('CHARACTERISTIC_MIM.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'basic value'))
        ) = 1)
       AND
        (SIZEOF (QUERY (it <* SELF.items
         | ('CHARACTERISTIC_MIM.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'plus value'))
        ) = 1)
       AND
        (SIZEOF (QUERY (it <* SELF.items 
         | ('CHARACTERISTIC_MIM.' +
            'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) 
           AND 
            (it\representation_item.name = 'minus value'))
        ) = 1)
       );

  WR7: (NOT (SELF\representation_item.name = 'symmetrical tolerance')) OR
       ((SIZEOF (QUERY (it <* SELF.items |
       ('CHARACTERISTIC_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it)) AND (it\representation_item.name = 'basic value'))
                        ) = 1)
       AND
       (SIZEOF (QUERY (it <* SELF.items |
       ('CHARACTERISTIC_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN 
       TYPEOF (it)) AND ( it\representation_item.name = 'deviation value'))
                        ) = 1)
       ); 
END_ENTITY;

ENTITY parameter_type
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['string property type','logical property type',
       'physical property type','boolean property type'];
END_ENTITY;

ENTITY table_representation_item
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'CHARACTERISTIC_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS')) > 0;
  WR2: 'CHARACTERISTIC_MIM.' +
       'LIST_REPRESENTATION_ITEM'
       IN TYPEOF(SELF\compound_representation_item.item_element);
END_ENTITY; 

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\chemical_substance_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3373 - ISO/CD-TS 10303-1655 Chemical substance - EXPRESS MIM
*)


SCHEMA Chemical_substance_mim;
	USE FROM Assembly_structure_mim;	-- ISO/TS 10303-1026
	USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
	USE FROM Person_organization_assignment_mim;	-- ISO/TS 10303-1013
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017

	USE FROM material_property_definition_schema
		(product_material_composition_relationship);

	USE FROM product_structure_schema
		(make_from_usage_option);
		
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\class_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3023 - ISO/TS 10303-1070 Class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2259
*) 


SCHEMA Class_mim;

USE FROM classification_schema   -- ISO 10303-54
  (class,
   class_by_extension,
   class_by_intension); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


END_SCHEMA;  -- Class_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\classification_assignment_mim.exp
   ------------------------------------------------------------
*)

(* 
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3249 - ISO/TS 10303-1114 Classification assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2230 
*)

SCHEMA Classification_assignment_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;

END_SCHEMA;  -- Classification_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\classification_with_attributes_mim.exp
   ------------------------------------------------------------
*)

(* 
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO/TC184/SC4 WG12N2617 - ISO/TS 10303-1111 Classification_with_attributes - Express MIM 
   Supersedes ISO TC184/SC4/WG12N1764
*)

SCHEMA Classification_with_attributes_mim;

USE FROM Class_mim;

USE FROM Classification_assignment_mim;

USE FROM Extended_measure_representation_mim;

USE FROM External_class_mim;

USE FROM Identification_assignment_mim;

USE FROM Plib_class_reference_mim;

USE FROM Part_and_version_identification_mim;

USE FROM Part_view_definition_mim;

USE FROM group_schema(
	group,
      group_relationship);

USE FROM product_property_definition_schema(
      characterized_object,
	general_property,
	general_property_association,
	property_definition);

USE FROM product_property_representation_schema(
	property_definition_representation);

USE FROM representation_schema(
	set_representation_item);

USE FROM management_resources_schema(classification_role); --GL added

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
      product, 
      product_definition_formation,
      product_definition);
END_TYPE;

TYPE classification_identification_item = EXTENSIBLE SELECT BASED_ON identification_item WITH
  (class);
END_TYPE;

TYPE classification_classification_item = EXTENSIBLE SELECT BASED_ON classification_item WITH
  (class);
END_TYPE;

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (product, product_definition_formation, product_definition);
END_TYPE;

TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT(characterized_class);
END_TYPE;

TYPE cwa_identification_item = SELECT BASED_ON identification_item WITH (characterized_class);
END_TYPE;

TYPE cwa_versionable_item = SELECT BASED_ON versionable_item WITH (characterized_class);
END_TYPE;


ENTITY characterized_class
SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY class_system 
SUBTYPE OF (group); 
END_ENTITY; 


RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE;

FUNCTION class_assignment_is_valid (aia: applied_classification_assignment): BOOLEAN;
LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia.role;
IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
  IF(role.name <> 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
  IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;

  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);
END_FUNCTION;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship); 
WHERE 
WR1: SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'class hierarchy') AND 
  (NOT('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr.related_group)) OR 
  NOT('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\colour_mim.exp
   ------------------------------------------------------------
*)

(*
WG12 N655
ISO/TS 10303-1002
Product data representation and exchange: Application module: Colour
*)

SCHEMA Colour_mim;
  USE FROM external_reference_schema -- ISO 10303-41
      (externally_defined_item);
  USE FROM presentation_resource_schema -- ISO 10303-46
      (colour,
       colour_rgb,
       colour_specification,
       draughting_pre_defined_colour,
       pre_defined_colour);
  USE FROM support_resource_schema -- ISO 10303-41
      (identifier);

 ENTITY externally_defined_colour
  SUBTYPE OF (colour_specification,externally_defined_item);
END_ENTITY; -- externally_defined_colour

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\component_feature_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3325 - ISO/CD-TS 10303-1657 Component feature - EXPRESS MIM
*)
SCHEMA Component_feature_mim;

	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728

ENTITY component_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'COMPONENT_FEATURE_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
END_ENTITY;

ENTITY component_feature_relationship
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\component_feature_relationship)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
END_ENTITY; 

ENTITY component_terminal
  SUBTYPE OF (component_feature);
WHERE
  WR1: (SELF\shape_aspect.description IN 
      ['assembly module component terminal', 
       'bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal', 'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']) OR
        ('COMPONENT_FEATURE_MIM.' +
       'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN
       TYPEOF  (SELF)) OR
        ('COMPONENT_FEATURE_MIM.' +
       'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN
       TYPEOF  (SELF));
  WR2: 'COMPONENT_FEATURE_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF  (SELF.of_shape.definition);
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
  WR4: SIZEOF (QUERY (at <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated terminals') |
       'COMPONENT_FEATURE_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (at.relating_shape_aspect))) <= 1;
  WR5: SIZEOF (QUERY (cr <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connectivity requirement') |
       'COMPONENT_FEATURE_MIM.' +
       'PHYSICAL_NETWORK' IN
       TYPEOF (cr.relating_shape_aspect))) <= 1;
  WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1;
  WR7: (NOT (SELF\shape_aspect.description IN 
       ['assembly module component terminal', 
       'bare die component terminal', 'package terminal occurrence', 
       'packaged component join terminal', 
       'printed component join terminal'])) OR
       (SELF.product_definitional);
  WR8: (NOT (SELF\shape_aspect.description = 
       'assembly module component terminal')) OR
       ((SELF.of_shape.definition.frame_of_reference.name =
       'physical occurrence') AND
       (EXISTS(SELF.of_shape.definition\product_definition.name)) AND
       (NOT(EXISTS(SELF.of_shape.definition\product_definition.name)) OR
       (SELF.of_shape.definition\product_definition.name =
       'assembly module'))
       );
  WR9: (NOT (SELF\shape_aspect.description = 
       'assembly module component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('COMPONENT_FEATURE_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)))) = 1);
 WR10: (NOT (SELF\shape_aspect.description = 
       'bare die component terminal')) OR
       (SELF.of_shape.definition\product_definition.description = 
       'bare die component');
 WR11: (NOT (SELF\shape_aspect.description = 
       'bare die component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('COMPONENT_FEATURE_MIM.' +
       'BARE_DIE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)))) = 1);
(*
 WR12: (NOT (SELF\shape_aspect.description = 
       'component termination passage join terminal')) OR
       (
       ('COMPONENT_FEATURE_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description =
       'component termination passage'));
*)
 WR13: (NOT (SELF\shape_aspect.description = 
       'component termination passage join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'component termination passage template join terminal')) = 1);
(*
  WR14: (NOT (SELF\shape_aspect.description = 
        'conductive interconnect element terminal')) OR
       ('COMPONENT_FEATURE_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (associated_component(SELF)) AND
       ((associated_component(SELF).description =
       'conductive interconnect element with pre defined transitions') OR
       (associated_component(SELF).description =
   'conductive interconnect element with user defined single transition')
       ));
*)
 WR15: (NOT (SELF\shape_aspect.description IN
       ['conductive interconnect element terminal',
       'interconnect component join terminal',
       'printed component join terminal'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description =
       'connection zone')) <= 1);
 WR16: (NOT (SELF\shape_aspect.description =
       'interconnect module component terminal')) OR
   ((SELF.of_shape.definition\product_definition.frame_of_reference.name =
       'physical occurrence') AND
       (EXISTS(SELF.of_shape.definition\product_definition.name)) AND
       (NOT(EXISTS(SELF.of_shape.definition\product_definition.name)) OR
       (SELF.of_shape.definition\product_definition.name =
       'interconnect module'))
       );

 WR17: (NOT (SELF\shape_aspect.description =
       'interconnect module component terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       'COMPONENT_FEATURE_MIM.' +
       'INTERCONNECT_MODULE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)
       )) = 1);
 WR18: (NOT (SELF\shape_aspect.description IN
       ['land join terminal', 'non functional land join terminal'])) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       (('COMPONENT_FEATURE_MIM.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (TRUE)))) = 1);
(*
 WR19: (NOT (SELF\shape_aspect.description = 'land join terminal')) OR
       ('COMPONENT_FEATURE_MIM.' +
       'LAND' IN
       TYPEOF (associated_component(SELF)));
*)
 WR20: (NOT (SELF\shape_aspect.description = 
       'minimally defined terminal')) OR
       (SIZEOF (QUERY (pdr<* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'part terminal external reference')) = 1);
(*
 WR21: (NOT (SELF\shape_aspect.description = 
       'non functional land join terminal')) OR
       (('COMPONENT_FEATURE_MIM.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description IN
       ['non functional land',
       'via dependent non functional land',
       'via and contact size dependent non functional land',
       'component termination passage dependent non functional land',
       'contact size dependent non functional land',
       'component termination passage and contact size ' +
       'dependent non functional land',
       'unsupported passage dependent non functional land'])))) = 1);
*)
 WR22: (NOT (SELF\shape_aspect.description = 
       'package terminal occurrence')) OR
       (SIZEOF (QUERY (ud <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'usage definition') |
       ('COMPONENT_FEATURE_MIM.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (ud.relating_shape_aspect)))) = 1);
 WR23: (NOT (SELF\shape_aspect.description IN 
       ['package terminal occurrence',
       'packaged component join terminal'])) OR
       (('COMPONENT_FEATURE_MIM.' +
       'PACKAGED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
        frame_of_reference.name = 
       'physical occurrence'));
 WR24: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('COMPONENT_FEATURE_MIM.' +
       'PACKAGED_PART_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'join terminal'))) = 1);
 WR25: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['COMPONENT_FEATURE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'COMPONENT_FEATURE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2)) <= 2)) <= 1)) <= 1); 
 WR26: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['COMPONENT_FEATURE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'COMPONENT_FEATURE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'maximum wire length')) <= 1)) <= 1)) <= 1);
 WR27: (NOT (SELF\shape_aspect.description = 
       'packaged component join terminal')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['COMPONENT_FEATURE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'COMPONENT_FEATURE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'minimum wire length')) <= 1)) <= 1)) <= 1); 
 WR28: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       ((SELF.of_shape.definition\product_definition.
       frame_of_reference.name =
       'layout occurrence') AND
       (SELF.of_shape.definition\product_definition.
       name = 'interconnect module')
       );
 WR29: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('COMPONENT_FEATURE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'join terminal'))) = 1);
(* invalid csa
 WR30: (NOT (SELF\shape_aspect.description = 
       'printed component join terminal')) OR
       (SIZEOF (QUERY (i <* QUERY (pdr <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       pdr\shape_aspect_relationship.name = 'implementation') |
       ((SIZEOF (['COMPONENT_FEATURE_MIM.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (i.relating_shape_aspect)) >= 1) AND
       (i.relating_shape_aspect\shape_aspect.description = 
                        'stratum feature template component'))
       )) = 1); *)
(*
 WR31: (NOT (SELF\shape_aspect.description = 'via terminal')) OR
       (('COMPONENT_FEATURE_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description IN
       ['buried via', 'interfacial connection',
       'bonded conductive base blind via',
       'non conductive base blind via',
       'plated conductive base blind via'])))) = 1);
*)
 WR32: (NOT (SELF\shape_aspect.description = 'via terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'COMPONENT_FEATURE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'via template terminal')) = 1);
 WR33: (NOT (SELF\shape_aspect.description =
       'interconnect component join terminal')) OR
       ((SELF.of_shape.definition\product_definition.
       frame_of_reference.name =
       'physical occurrence') AND
       NOT(SELF.of_shape.definition\product_definition.description 
       IN ['assembly module component', 'bare die component', 
       'interconnect module component', 'laminate component',
       'packaged component']));
 WR34: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items |
       (dri\representation_item.name = 'global swappable') AND 
       (dri\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1)) <= 1;
 WR35: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items |
       (dri\representation_item.name = 'local swappable') AND 
       (dri\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1)) <= 1;
 WR36: SIZEOF(QUERY(pd <* USEDIN(SELF, 
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') | SIZEOF(QUERY(pdr <* USEDIN(pd,
       'COMPONENT_FEATURE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       SIZEOF(QUERY(dri <* pdr.used_representation.items | dri\representation_item.name = 
       'swap code'
       )) = 1)) = 1)) <= 1;
END_ENTITY;

ENTITY make_from_feature_relationship
 SUBTYPE OF (component_feature_relationship);
WHERE
  WR1: SIZEOF (['COMPONENT_FEATURE_MIM.' +
       'COMPONENT_TERMINAL',
       'COMPONENT_FEATURE_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1;
(* invalid csa       
  WR2: SIZEOF (['COMPONENT_FEATURE_MIM.' +
       'COMPONENT_TERMINAL',
       'COMPONENT_FEATURE_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL'] *
       TYPEOF (SELF.related_shape_aspect)) = 1; *)
(* invalid csa
  WR3: (NOT ('COMPONENT_FEATURE_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.relating_shape_aspect))) OR
       (SELF.relating_shape_aspect\shape_aspect.description IN ['component feature',
       'component termination passage interface terminal', 
       'land or non functional land interface terminal',  
       'printed connector component interface terminal']); *)
(* invalid csa
  WR4: (NOT ('COMPONENT_FEATURE_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.related_shape_aspect))) OR
       (SELF.related_shape_aspect\shape_aspect.description IN ['component feature',
       'component termination passage interface terminal', 
       'land or non functional land interface terminal',  
       'printed connector component interface terminal']); *)
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\component_grouping_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3328 - ISO/CD-TS 10303-1656 Component grouping - EXPRESS MIM
*)
SCHEMA Component_grouping_mim;

	USE FROM Interface_component_mim;	-- ISO/TS 10303-1691

ENTITY array_placement_group_component_definition
  SUPERTYPE OF (ONEOF(linear_array_placement_group_component_definition,
                      rectangular_array_placement_group_component_definition))
  SUBTYPE OF (assembly_group_component_definition);
END_ENTITY;

ENTITY assembly_group_component_definition
  SUBTYPE OF (assembly_component);
WHERE
(* invalid csa
  WR1: (SIZEOF (QUERY (gc <* QUERY (pdr <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'group component') |
       ('COMPONENT_GROUPING_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (gc.related_product_definition)))) >= 1)  OR
       (SIZEOF (QUERY(agcsa <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF (agcsa)))) = 0); *)
  WR2: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
       'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\shape_aspect_relationship.relating_shape_aspect,
       'COMPONENT_GROUPING_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('COMPONENT_GROUPING_MIM.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
       AND (acu\product_definition_relationship.relating_product_definition = SELF)
       )) >= 1))) >= 1);
  WR3: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj))AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect,
        'COMPONENT_GROUPING_MIM.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
        AND (acu\product_definition_relationship.relating_product_definition = SELF)
        )) = 0))) = 0);
  WR4: (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('COMPONENT_GROUPING_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
       (SIZEOF (QUERY( cl <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect.of_shape.definition,
        'COMPONENT_GROUPING_MIM.' +
        'REPRESENTATION.ITEMS') |
        ('COMPONENT_GROUPING_MIM.' +
        'COMPONENT_LOCATION' IN TYPEOF (cl))
        AND (aj IN cl\representation.items))) = 0))) = 0);
END_ENTITY;

ENTITY assembly_group_component_definition_placement_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'COMPONENT_GROUPING_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'COMPONENT_GROUPING_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\assembly_group_component_definition_placement_link)) = 0;
  WR5: SELF\product_definition.name = '';
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'COMPONENT_GROUPING_MIM.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; 

ENTITY interfaced_group_component_definition
  SUBTYPE OF (assembly_group_component_definition);
WHERE
  WR1: (SIZEOF (QUERY (gc <* QUERY (pdr <* USEDIN (SELF,
       'COMPONENT_GROUPING_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'group component') |
       ('COMPONENT_GROUPING_MIM.' +
       'INTERFACE_COMPONENT_DEFINITION' IN 
       TYPEOF (gc.related_product_definition))))
       >= 1);
END_ENTITY;

ENTITY linear_array_component_definition_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'COMPONENT_GROUPING_MIM.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'COMPONENT_GROUPING_MIM.' +
       'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\linear_array_component_definition_link)) = 0;
  WR5: SELF\product_definition.name = '';
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'COMPONENT_GROUPING_MIM.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; 

ENTITY linear_array_placement_group_component_definition
  SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY;

ENTITY rectangular_array_placement_group_component_definition
  SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY;

RULE product_definition_formation_requires_approval FOR
(product_definition,
  applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       (NOT('COMPONENT_GROUPING_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       pd.formation IN aaa.items )) = 1 )))) = 0;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\conductivity_material_aspects_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3655 - ISO/CD-TS 10303-1756 Conductivity material aspects - EXPRESS MIM
*)
SCHEMA Conductivity_material_aspects_mim;

	USE FROM Classification_assignment_mim;	-- ISO/TS 10303-1114
	USE FROM Generic_material_aspects_mim;	-- ISO/TS 10303-1681
	USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
	
TYPE cma_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
     (material_designation);
END_TYPE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\configuration_effectivity_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2950 - ISO/TS 10303-1058 Configuration effectivity - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2519
*) 


SCHEMA Configuration_effectivity_mim; 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM Configuration_item_mim;    -- ISO/CD-TS 10303-1056

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_effectivity); 


END_SCHEMA;  -- Configuration_effectivity_mim






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\configuration_item_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2533 - ISO/TS 10303-1056 Configuration item - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2483
*) 


SCHEMA Configuration_item_mim;

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_design,
   configuration_item); 


END_SCHEMA;  -- Configuration_item_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\connectivity_allocation_to_physical_network_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3376 - ISO/CD-TS 10303-1658 Connectivity allocation to physical network - EXPRESS MIM
*)


SCHEMA Connectivity_allocation_to_physical_network_mim;
	USE FROM Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;	-- ISO/TS 10303-1678
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\construction_geometry_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2868 - ISO/TS 10303-1131 Construction geometry - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1542
*) 


SCHEMA Construction_geometry_mim;

USE FROM aic_topologically_bounded_surface;    -- ISO 10303-511

USE FROM Basic_geometry_mim;    -- ISO/TS 10303-1652

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM geometry_schema   -- ISO 10303-42
  (b_spline_curve,
   b_spline_surface,
   circle,
   composite_curve,
   conical_surface,
   curve,
   curve_bounded_surface,
   curve_replica,
   cylindrical_surface,
   degenerate_pcurve,
   ellipse,
   hyperbola,
   line,
   offset_curve_2d,
   offset_curve_3d,
   offset_surface,
   oriented_surface,
   parabola,
   pcurve,
   placement,
   plane,
   point_on_curve,
   point_on_surface,
   point_replica,
   polyline,
   rectangular_composite_surface,
   rectangular_trimmed_surface,
   spherical_surface,
   surface,
   surface_curve,
   surface_of_linear_extrusion,
   surface_of_revolution,
   surface_replica,
   toroidal_surface,
   trimmed_curve); 

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item,
   representation,
   representation_map,
   representation_relationship); 

USE FROM topology_schema   -- ISO 10303-42
  (edge_curve,
   face_surface,
   vertex_point); 


ENTITY constructive_geometry_representation
  SUBTYPE OF (representation);
WHERE
  WR1: ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
  WR2: SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.PLACEMENT', 'CONSTRUCTION_GEOMETRY_MIM.CURVE', 'CONSTRUCTION_GEOMETRY_MIM.EDGE', 'CONSTRUCTION_GEOMETRY_MIM.FACE', 'CONSTRUCTION_GEOMETRY_MIM.POINT', 'CONSTRUCTION_GEOMETRY_MIM.SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.FACE_SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
  WR3: SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
  WR4: SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
END_ENTITY;

ENTITY constructive_geometry_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
  WR2: 'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2);
  WR3: SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.SHAPE_REPRESENTATION', 'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1;
  WR4: NOT('CONSTRUCTION_GEOMETRY_MIM.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
END_ENTITY;

END_SCHEMA;  -- Construction_geometry_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\constructive_solid_geometry_2d_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3331 - ISO/CD-TS 10303-1731 Constructive solid geometry 2d - EXPRESS MIM
*) 


SCHEMA Constructive_solid_geometry_2d_mim;

	USE FROM Area_2d_mim;	-- ISO/TS 10303-1631

USE FROM Representation_schema(mapped_item);

ENTITY csg_2d_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE 
 WR1: SELF.context_of_items\
  geometric_representation_context.coordinate_space_dimension = 2;

 WR2 : SIZEOF (QUERY (it <* SELF.items| NOT
     (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM', 
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D'] 
     * TYPEOF(it)) = 1 ))) = 0;

 WR3: SIZEOF(QUERY ( it <* SELF.items | 
    (SIZEOF(['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.CSG_SOLID']
	* TYPEOF(it)) = 1) 
	OR 
	(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
	IN TYPEOF(it)) AND
	('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
	'CSG_2D_SHAPE_REPRESENTATION' 
	  IN TYPEOF(it\mapped_item.mapping_source.mapped_representation))) 
       )) >= 1;

 WR4: SIZEOF(QUERY ( it <* SELF.items | 
     (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.MAPPED_ITEM' 
     IN TYPEOF(it)) AND (NOT (( 
      'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
      'CSG_2D_SHAPE_REPRESENTATION') 
      IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) )) = 0;
 WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_representation ||
      SELF\csg_2d_shape_representation || SELF\representation)) = 0;
END_ENTITY; -- csg_2d_shape_representation 

END_SCHEMA;  -- Constructive_solid_geometry_2d_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\contextual_shape_positioning_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1139 - ISO/TS 10303-1027 Contextual shape positioning - EXPRESS MIM
*)
SCHEMA Contextual_shape_positioning_mim;

USE FROM Elemental_geometric_shape_mim;
USE FROM Foundation_representation_mim;
USE FROM Shape_property_assignment_mim; 

USE FROM product_property_representation_schema -- ISO 10303-41
  (context_dependent_shape_representation);

USE FROM representation_schema 	-- ISO 10303-43
      (functionally_defined_transformation,
      representation_relationship_with_transformation,
      mapped_item);

END_SCHEMA;






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\contract_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1127 - ISO/TS 10303-1062 Contract - EXPRESS MIM
*)    
SCHEMA Contract_mim;
USE FROM contract_schema -- ISO 10303-41
  (contract);
USE FROM management_resources_schema -- ISO 10303-41
  (contract_assignment);

   
TYPE contract_item = EXTENSIBLE SELECT; 
END_TYPE;
   
   
ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;

END_SCHEMA;

 


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\curve_swept_solid_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3334 - ISO/CD-TS 10303-1659 Curve swept solid - EXPRESS MIM
 *)
SCHEMA Curve_swept_solid_mim;

USE FROM Aic_curve_swept_solid;
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\date_time_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1082 - ISO/TS 10303-1010 Date time - EXPRESS MIM
*)       
SCHEMA Date_time_mim;
USE FROM date_time_schema -- ISO 10303-41
  (calendar_date,
   date_and_time,
   coordinated_universal_time_offset);

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\date_time_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1094 - ISO/TS 10303-1014 Date time assignment - EXPRESS MIM
*)     
SCHEMA Date_time_assignment_mim;

USE FROM Date_time_mim; 	-- 10303-1010

USE FROM date_time_schema 	-- ISO 10303-41
  (date,
   date_role,
   date_time_role);
USE FROM management_resources_schema -- ISO 10303-41
  (date_and_time_assignment,
   date_assignment);

   
TYPE date_item = EXTENSIBLE SELECT; 
END_TYPE;
   
TYPE date_and_time_item = EXTENSIBLE SELECT; 
END_TYPE;
   
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
   
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\datum_difference_based_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3385 - ISO/CD-TS 10303-1660 Datum difference based model - EXPRESS MIM
*)


SCHEMA Datum_difference_based_model_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	
ENTITY datum_difference_based_model_parameter
  SUBTYPE OF (model_parameter);
WHERE
      WR1: SIZEOF(QUERY ( r <* USEDIN(SELF,
               'DATUM_DIFFERENCE_BASED_MODEL_MIM.' + 
               'REPRESENTATION.ITEMS') | (SIZEOF(QUERY (prd2 <*
                QUERY ( prd <* USEDIN(r,
               'DATUM_DIFFERENCE_BASED_MODEL_MIM.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               ((('DATUM_DIFFERENCE_BASED_MODEL_MIM.' 
               + 'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(prd)) AND 
               (('DATUM_DIFFERENCE_BASED_MODEL_MIM.' +
                'PROPERTY_DEFINITION') IN TYPEOF(prd\
               property_definition_representation.definition))) ) |
               ('DATUM_DIFFERENCE_BASED_MODEL_MIM.' +
                'DATUM_DIFFERENCE' IN
               TYPEOF(prd2\property_definition_representation.definition\
                                        property_definition.definition))))
                = 1) )) 
               = 1;
END_ENTITY;

ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
SELF\datum_difference_functional_unit_usage_view_terminal_assignment)) 
                                                              = 0;
  WR2: 'DATUM_DIFFERENCE_BASED_MODEL_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF 
        (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'DATUM_DIFFERENCE_BASED_MODEL_MIM.' +
       'DATUM_DIFFERENCE' IN TYPEOF 
        (SELF\shape_aspect_relationship.relating_shape_aspect);
END_ENTITY;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\default_tolerance_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $ 
ISO TC184/SC4/WG12 N2871 - ISO/TS 10303-1052 Default tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1545
*) 


SCHEMA Default_tolerance_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   representation,
   set_representation_item); 

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032


ENTITY default_tolerance_table
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF( QUERY( i <* SELF.items | NOT('DEFAULT_TOLERANCE_MIM.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i)) )) = 0;
  WR2: (SIZEOF( QUERY( rr <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | rr.name < 'general tolerance definition' )) = 0) AND (SIZEOF( QUERY( rr <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name = 'general tolerance definition') AND (rr.rep_2.name < 'default tolerance') )) = 0) AND (SIZEOF( USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) = 0);
END_ENTITY;

ENTITY default_tolerance_table_cell
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF(QUERY( x <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION.ITEMS') | 'DEFAULT_TOLERANCE_MIM.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1 ;
  WR2: default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element);
  WR3: default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element);
  WR4: default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element);
  WR5: default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element);
END_ENTITY;

FUNCTION default_tolerance_table_cell_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF SIZEOF(agg) <= 5 THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) 
  AND (i\representation_item.name = 'significant number of digits')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'lower limit')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'upper limit')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr4
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'plus minus tolerance value')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'lower tolerance value')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'upper tolerance value')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr5
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | ('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) <= 1) AND 
(SIZEOF(QUERY ( i <* agg | ('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) = 
  SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'cell description'))) )) 
THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

END_SCHEMA;  -- Default_tolerance_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\derived_shape_element_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2865 - ISO/TS 10303-1130 Derived shape element - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1539
*)


SCHEMA Derived_shape_element_mim;

USE FROM Basic_geometry_mim;

USE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (apex,
   centre_of_symmetry,
   derived_shape_aspect,
   extension,
   geometric_alignment,
   geometric_intersection,
   parallel_offset,
   perpendicular_to,
   shape_aspect_deriving_relationship,
   tangent); 

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Derived_shape_element_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\design_management_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3388 - ISO/CD-TS 10303-1661 Design management - EXPRESS MIM
*)


SCHEMA Design_management_mim;
	USE FROM Approval_mim;	-- ISO/TS 10303-1012
	USE FROM Product_view_definition_mim;	-- ISO/TS 10303-1019
	USE FROM Work_order_mim;	-- ISO/TS 10303-1043

	USE FROM Product_definition_schema(product_definition_relationship);

TYPE design_management_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
     (frozen_assignment);
END_TYPE;

TYPE managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT
	(product_definition);
END_TYPE;

ENTITY current_design_assignment
	SUBTYPE OF (design_object_management_assignment);
END_ENTITY;

ENTITY current_design_object_assignment 
	SUBTYPE OF (design_object_management_assignment);
END_ENTITY;

ENTITY design_object_management_assignment
	SUBTYPE OF (action_assignment);
	 items : SET [1:?] OF managed_design_object; 
END_ENTITY;

ENTITY design_object_management_relationship_action
	SUBTYPE OF (action);
END_ENTITY;

ENTITY frozen_assignment 
 SUBTYPE OF (approval_assignment); 
 items : SET [1:?] OF managed_design_object; 
WHERE
 WR1: SELF\approval_assignment.assigned_approval.status.name in ['approved', 'not yet approved'];
END_ENTITY;

ENTITY previous_design_assignment
	SUBTYPE OF (design_object_management_assignment);
END_ENTITY;

ENTITY previous_design_object_assignment 
	SUBTYPE OF (design_object_management_assignment);
END_ENTITY;

(** Need to review - rewrite global rules below
RULE add_design_object_management_relationship_unique_constraint FOR
 ( add_design_object_assignment, add_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  adoa_bag : BAG OF add_design_object_assignment;
  adora_bag : BAG OF add_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(add_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
   'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(add_design_object_assignment[i].items[j]))
    AND (add_design_object_assignment[i].items[j].name = 
            'design object addition') ) THEN
      IF EXISTS( add_design_object_assignment[i].items[j].
                          related_product_definition ) 
                                                               THEN
        IF( NOT( add_design_object_assignment[i].items[j].
                           related_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                    add_design_object_assignment[i].items[j].
                             related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(add_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
        SIZEOF(add_design_object_request_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
           TYPEOF(add_design_object_request_assignment[i].items[j]))
AND (add_design_object_request_assignment[i].items[j].name = 
                             'design object addition') ) THEN
      IF EXISTS( 
           add_design_object_request_assignment[i].items[j].
                             related_product_definition ) 
                                                          THEN
        IF( NOT( 
           add_design_object_request_assignment[i].items[j].
                               related_product_definition 
                                           IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
             add_design_object_request_assignment[i].items[j].
                                    related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
            'DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
                         (pdr\product_definition_relationship.name = 'design object addition') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adoa_bag := QUERY( adoa <* add_design_object_assignment | 
                                 (pdr_bag[j] IN adoa.items) );
    REPEAT k := 1 to SIZEOF(adoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adoa_bag[k].items) by 1;
        IF EXISTS( adoa_bag[k].items[l] ) THEN
          IF ( adoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + adoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adora_bag := QUERY( adora <* add_design_object_request_assignment | 
                                          (pdr_bag[j] IN adora.items) );
    REPEAT k := 1 to SIZEOF(adora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adora_bag[k].items) by 1;
        IF ( adora_bag[k].items[l] IN mdo_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          mdo_bag := mdo_bag + adora_bag[k].items[l];
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE change_design_object_management_relationship_unique_constraint FOR
 (  change_from_design_object_assignment, 
 change_from_design_object_request_assignment,
change_to_design_object_assignment, 
change_to_design_object_request_assignment );
LOCAL
  pd_bag : BAG OF product_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  ctdoa_bag : BAG OF change_to_design_object_assignment;
  ctdora_bag : BAG OF change_to_design_object_request_assignment;
  cfdoa_bag : BAG OF change_from_design_object_assignment;
  cfdora_bag : BAG OF change_from_design_object_request_assignment;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(change_from_design_object_assignment) by 1;
  REPEAT j := 1 TO 
          SIZEOF(change_from_design_object_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
     TYPEOF(change_from_design_object_assignment[i].items[j]))
AND (change_from_design_object_assignment[i].items[j].name = 
                                   'design object change') ) THEN
      IF EXISTS
( change_from_design_object_assignment[i].items[j].
 relating_product_definition ) 
                                                             THEN
        IF( NOT
          ( change_from_design_object_assignment[i].items[j].
                               relating_product_definition 
                                               IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
            change_from_design_object_assignment[i].items[j].
                               relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to 
         SIZEOF(change_from_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
       SIZEOF(change_from_design_object_request_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(change_from_design_object_request_assignment[i].items[j]))
AND (change_from_design_object_request_assignment[i].items[j].name = 
                      'design object change') ) THEN
      IF EXISTS
  ( change_from_design_object_request_assignment[i].items[j].
                                    relating_product_definition )
                                                THEN
        IF( NOT
  ( change_from_design_object_request_assignment[i].items[j].
                                       relating_product_definition 
                                          IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
    change_from_design_object_request_assignment[i].items[j].
                                      relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
  END_IF;
  IF ( pass1 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
   'DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
        (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdoa_bag := QUERY( ctdoa <* change_to_design_object_assignment | 
                (pdr_bag[j] IN ctdoa.items) );
      REPEAT k := 1 to SIZEOF(ctdoa_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdoa_bag[k].items) by 1;
          IF EXISTS( ctdoa_bag[k].items[l] ) THEN
            IF ( ctdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdora_bag := 
         QUERY( ctdora <* change_to_design_object_request_assignment | 
                    (pdr_bag[j] IN ctdora.items) );
      REPEAT k := 1 to SIZEOF(ctdora_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdora_bag[k].items) by 1;
          IF EXISTS( ctdora_bag[k].items[l] ) THEN
            IF ( ctdora_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  IF ( pass2 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
   (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdoa_bag := QUERY( cfdoa <* change_from_design_object_assignment | 
                                           (pdr_bag[j] IN cfdoa.items) );
      REPEAT k := 1 to SIZEOF(cfdoa_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdoa_bag[k].items) by 1;
          IF EXISTS( cfdoa_bag[k].items[l] ) THEN
            IF ( cfdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdora_bag := 
        QUERY( cfdora <* change_from_design_object_request_assignment | 
                                        (pdr_bag[j] IN cfdora.items) );
      REPEAT k := 1 to SIZEOF(cfdora_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdora_bag[k].items) by 1;
          IF EXISTS( cfdora_bag[k].items[l] ) THEN
            IF ( cfdora_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;

RULE delete_design_object_management_relationship_unique_constraint FOR
 ( delete_design_object_assignment, 
   delete_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  ddoa_bag : BAG OF delete_design_object_assignment;
  ddora_bag : BAG OF delete_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(delete_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
        IN TYPEOF(delete_design_object_assignment[i].items[j]))
AND (delete_design_object_assignment[i].items[j].name = 
                          'design object deletion') ) THEN
      IF EXISTS( delete_design_object_assignment[i].items[j].
                                      relating_product_definition )
                                                               THEN
        IF( NOT( delete_design_object_assignment[i].items[j].
                                          relating_product_definition 
                                                 IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                 delete_design_object_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(delete_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
         SIZEOF(delete_design_object_request_assignment[i].items) by 1;
    IF ( ('DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
         IN TYPEOF(delete_design_object_request_assignment[i].items[j]))
AND (delete_design_object_request_assignment[i].items[j].name = 
                                     'design object deletion') ) THEN
      IF EXISTS
       ( delete_design_object_request_assignment[i].items[j].
                                        relating_product_definition )
                                                            THEN
        IF( NOT
( delete_design_object_request_assignment[i].items[j].
                                         relating_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
          delete_design_object_request_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'DESIGN_MANAGEMENT_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
                        (pdr\product_definition_relationship.name = 'design object deletion') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddoa_bag := QUERY( ddoa <* delete_design_object_assignment | 
                                   (pdr_bag[j] IN ddoa.items) );
    REPEAT k := 1 to SIZEOF(ddoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddoa_bag[k].items) by 1;
        IF EXISTS( ddoa_bag[k].items[l] ) THEN
          IF ( ddoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddora_bag := 
        QUERY( ddora <* delete_design_object_request_assignment | 
                                    (pdr_bag[j] IN ddora.items) );
    REPEAT k := 1 to SIZEOF(ddora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddora_bag[k].items) by 1;
        IF EXISTS( ddora_bag[k].items[l] ) THEN
          IF ( ddora_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddora_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\design_specific_assignment_to_assembly_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3391 - ISO/CD-TS 10303-1662 Design specific assignment to assembly usage view - EXPRESS MIM
*)


SCHEMA Design_specific_assignment_to_assembly_usage_view_mim;
	USE FROM Assembly_module_usage_view_mim;	-- ISO/TS 10303-1642
	USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
	USE FROM Assembly_module_with_subassembly_mim;	-- ISO/TS 10303-1641
	USE FROM Component_feature_mim;	-- ISO/TS 10303-1657
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728

RULE 
component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'DESIGN_SPECIFIC_ASSIGNMENT_TO_ASSEMBLY_USAGE_VIEW_MIM.' +
'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
             'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( ('DESIGN_SPECIFIC_ASSIGNMENT_TO_ASSEMBLY_USAGE_VIEW_MIM.' +
'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND
(cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') ) THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;


END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\design_specific_assignment_to_interconnect_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3394 - ISO/CD-TS 10303-1663 Design specific assignment to interconnect usage view - EXPRESS MIM
*)


SCHEMA Design_specific_assignment_to_interconnect_usage_view_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
--	USE FROM Interconnect_module_usage_view_mim;	-- ISO/TS 10303-1686
--	USE FROM Land_mim;	-- ISO/TS 10303-1692
--	USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700

RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'DESIGN_SPECIFIC_ASSIGNMENT_TO_INTERCONNECT_USAGE_VIEW_MIM.' +
'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'DESIGN_SPECIFIC_ASSIGNMENT_TO_INTERCONNECT_USAGE_VIEW_MIM.' +
'INTERCONNECT_MODULE_JOIN_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\device_marking_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3397 - ISO/CD-TS 10303-1664 Device marking - EXPRESS MIM
*)


SCHEMA Device_marking_mim;

	USE FROM Part_template_2d_shape_mim;	-- ISO/TS 10303-1716
	USE FROM Part_template_non_planar_shape_mim;	-- ISO/TS 10303-1719
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
	
	USE FROM Presentation_definition_schema(annotation_text_occurrence);

TYPE device_marking_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
     (representation);
END_TYPE;

TYPE device_marking_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
     (representation);
END_TYPE;

TYPE device_marking_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (representation);
END_TYPE;

RULE marking_constraint FOR ( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'marking')
       AND (SIZEOF(QUERY(pdr <* USEDIN(rep,
       'DEVICE_MARKING_MIM.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('DEVICE_MARKING_MIM.'
        + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0))
       AND NOT (SIZEOF(QUERY(place <* rep.items |
       (('DEVICE_MARKING_MIM.'
        + 'PLACEMENT' IN TYPEOF (place))
       AND (place\representation_item.name = 'marking location'))
       )) = 1)
       )) = 0;
END_RULE;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\dimension_tolerance_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2874 - ISO/TS 10303-1050 Dimension tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1548
*) 


SCHEMA Dimension_tolerance_mim;

USE FROM Basic_curve_mim;

USE FROM Derived_shape_element_mim;    -- ISO/TS 10303-1130

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 

USE FROM geometry_schema   -- ISO 10303-42
  (placement); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_qualification,
   value_qualifier); 

USE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (shape_aspect_deriving_relationship); 

USE FROM shape_dimension_schema;    -- ISO 10303-47

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM shape_tolerance_schema   -- ISO 10303-47
  (limits_and_fits,
   plus_minus_tolerance,
   tolerance_method_definition,
   tolerance_value); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE dimension_identification_item = SELECT BASED_ON identification_item WITH 
   (dimensional_size);
END_TYPE; 

TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (dimensional_size, 
    externally_defined_dimension_definition);
END_TYPE; 

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY externally_defined_dimension_definition
  SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
  WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
  WR2: 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;

END_SCHEMA;  -- Dimension_tolerance_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_and_version_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1187 - ISO/TS 10303-1121 Document and version identification - EXPRESS MIM
*)

SCHEMA Document_and_version_identification_mim;

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2959 - ISO/TS 10303-1122 Document assignment - EXPRESS MIM
*)



SCHEMA Document_assignment_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM document_schema   -- ISO 10303-41
  (document_product_association); 

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM management_resources_schema   -- ISO 10303-41
  (document_reference,
   document_usage_constraint_assignment); 


TYPE document_reference_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  WR3: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
END_ENTITY;

END_SCHEMA;  -- Document_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_definition_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2961 - ISO/TS 10303-1123 Document definition - EXPRESS MIM
*) 


SCHEMA Document_definition_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_with_associated_documents); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE document_location_select = SELECT BASED_ON external_identification_item WITH 
   (product_definition);
END_TYPE; 

END_SCHEMA;  -- Document_definition_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_management_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3038 - ISO/TS 10303-1290 Document management - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2331
*) 


SCHEMA Document_management_mim;

USE FROM Alias_identification_mim;    -- ISO/TS 10303-1025

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role); 

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM Document_properties_mim;    -- ISO/TS 10303-1126

USE FROM document_schema   -- ISO 10303-41
  (document_relationship); 

USE FROM Document_structure_mim;    -- ISO/TS 10303-1124

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM management_resources_schema   -- ISO 10303-41
  (document_usage_role); 

USE FROM Product_categorization_mim;    -- ISO/TS 10303-1016

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_relationship); 

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015


TYPE dm_aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON aliasable_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (product_definition_formation);
END_TYPE; 

TYPE dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Document_management_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_properties_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1202 - ISO/TS 10303-1126 Document properties - EXPRESS MIM
*)



SCHEMA Document_properties_mim;

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM File_identification_mim;

USE FROM Foundation_representation_mim;

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM Property_assignment_mim;

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\document_structure_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1196 - ISO/TS 10303-1124 Document structure - EXPRESS MIM
*)



SCHEMA Document_structure_mim;
USE FROM Document_definition_mim; -- ISO/CD TS 10303-1123
USE FROM File_identification_mim; -- ISO/CD TS 10303-1127
USE FROM document_schema (document_relationship); -- ISO 10303-41
USE FROM product_definition_schema -- ISO 10303-41
	(product_definition_formation_relationship,
         product_definition_relationship);
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\effectivity_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1169 - ISO/TS 10303-1057 Effectivity - EXPRESS MIM
*)
  
SCHEMA Effectivity_mim;

USE FROM Time_interval_mim; -- ISO 10303-1065
USE FROM Value_with_unit_mim ; -- ISO 10303-1054

USE FROM effectivity_schema -- ISO 10303-41
  (	dated_effectivity,
	effectivity,
   	effectivity_relationship,
	lot_effectivity,
   	serial_numbered_effectivity,
      time_interval_based_effectivity);

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\effectivity_application_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3224 - ISO/TS 10303-1059 Effectivity application - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1175
*) 


SCHEMA Effectivity_application_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM management_resources_schema   -- ISO 10303-41
  (effectivity_assignment); 


TYPE effectivity_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;

END_SCHEMA;  -- Effectivity_application_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\electrical_network_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3337 - ISO/CD-TS 10303-1665 Electrical network definition - EXPRESS MIM
*)
SCHEMA Electrical_network_definition_mim;

	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704

ENTITY electrical_network
  SUBTYPE OF (functional_unit);
END_ENTITY;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\elemental_geometric_shape_mim.exp
   ------------------------------------------------------------
*)

(* 
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO/TC184/SC4 WG12N2103 - ISO/TS 10303-1004 Elemental geometric shape - EXPRESS MIM *)
   
SCHEMA Elemental_geometric_shape_mim;
  
USE FROM Foundation_representation_mim;

USE FROM Identification_assignment_mim; -- ISO 10303-1021

USE FROM Value_with_unit_mim; -- ISO 10303-1054

USE FROM qualified_measure_schema
	(measure_representation_item); -- ISO 10303-45

USE FROM geometry_schema -- ISO 10303-42
      (cartesian_point,
       direction,
       axis2_placement_2d,
       axis2_placement_3d,
       geometric_representation_context,
       geometric_representation_item,
       cartesian_transformation_operator_2d,
       cartesian_transformation_operator_3d);

USE FROM product_property_representation_schema -- ISO 10303-41
      (shape_representation,
  	 shape_representation_relationship);

USE FROM representation_schema -- ISO 10303-43
      (item_defined_transformation,
	value_representation_item);

TYPE representation_identification_item = SELECT BASED_ON identification_item WITH 
  (shape_representation);
END_TYPE; 
 
TYPE representation_version_item = SELECT BASED_ON versionable_item WITH 
  (shape_representation);
END_TYPE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\encoded_text_representation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
  ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-xxxx Encoded text representation - EXPRESS MIM
*) 


SCHEMA Encoded_text_representation_mim; 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM classification_schema   -- ISO/DIS 10303-54
  (class); 

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (representation_item,
   representation_item_relationship); 


TYPE encoded_text_representation_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (descriptive_representation_item, 
    encoded_text_representation_item, 
    product_definition, 
    uniform_resource_indicator_representation_item);
END_TYPE; 

TYPE encoded_text_representation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (encoded_text_format);
END_TYPE; 

ENTITY encoded_text_format
  SUBTYPE OF (class);
END_ENTITY;

ENTITY encoded_text_representation_item
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY string_representation_item_composition
  SUBTYPE OF (string_representation_item_relationship);
END_ENTITY;

ENTITY string_representation_item_relationship
  SUBTYPE OF (representation_item_relationship);
END_ENTITY;

ENTITY string_representation_item_sequence
  SUBTYPE OF (string_representation_item_relationship);
END_ENTITY;

ENTITY template_specification
  SUBTYPE OF (class);
END_ENTITY;

ENTITY uniform_resource_indicator_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;

END_SCHEMA;  -- Encoded_text_representation_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\event_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2115 - ISO/TS 10303-1064 Event - EXPRESS MIM
*)

SCHEMA Event_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM date_time_schema   -- ISO 10303-41
  (event_occurrence,
   event_occurrence_relationship,
   relative_event_occurrence); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (event_occurrence);
END_TYPE; 

END_SCHEMA;  -- Event_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\event_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2117 - ISO/TS 10303-1364 Event assignment - EXPRESS MIM
*)



SCHEMA Event_assignment_mim; 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (event_occurrence_assignment); 


TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;

END_SCHEMA;  -- Event_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\extended_elemental_geometric_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3673 - ISO/CD-TS 10303-1667 Extended elemental geometric shape - EXPRESS MIM
*)


SCHEMA Extended_elemental_geometric_shape_mim;
	USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
	USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032
	
	USE FROM Representation_schema(
		mapped_item,
		representation_item_relationship,
		representation_map,
		representation_relationship_with_transformation,
		transformation);
		
	USE FROM Geometry_schema(
		vector);	

  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
  END_ENTITY;  
	
ENTITY shape_item_relationship
  SUBTYPE OF (representation_item, representation_item_relationship);
UNIQUE
  UR1: SELF\representation_item_relationship.relating_representation_item, 
       SELF\representation_item_relationship.related_representation_item;
WHERE
  WR1: SELF\representation_item_relationship.relating_representation_item :<>: 
       SELF\representation_item_relationship.related_representation_item;
  WR2: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation_item ||
       SELF\representation_item_relationship || 
       SELF\shape_item_relationship))) = 0;
END_ENTITY; 

RULE feature_shape_definition_constraint FOR (
         shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'zone shape')
       AND (sr.context_of_items.coordinate_space_dimension = 3)
       AND NOT('EXTENDED_ELEMENTAL_GEOMETRIC_SHAPE_MIM.'
       + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr)))) = 0;
END_RULE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\extended_geometric_tolerance_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3400 - ISO/CD-TS 10303-1666 Extended geometric tolerance - EXPRESS MIM
*)


SCHEMA Extended_geometric_tolerance_mim;
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
	USE FROM Default_tolerance_mim;	-- ISO/TS 10303-1052
	USE FROM Dimension_tolerance_mim;	-- ISO/TS 10303-1050
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
	USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
	
	USE FROM Application_context_schema(application_context_element);
	USE FROM Material_property_definition_schema(property_definition_relationship);
	USE FROM Shape_tolerance_schema
		(runout_zone_orientation,
		tolerance_zone_form);

TYPE egt_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (statistical_geometric_tolerance,
   statistical_dimensional_size,
   statistical_dimensional_location,
   property_definition);
END_TYPE; 

TYPE egt_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (shape_dimension_representation);
END_TYPE; 
	
TYPE egt_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (representation);
END_TYPE; 
	
ENTITY auxiliary_characteristic_dimension_representation
 SUBTYPE OF (dimensional_characteristic_representation);
END_ENTITY;

ENTITY datum_difference
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PHYSICAL_UNIT_DATUM' IN TYPEOF
       (SELF\shape_aspect_relationship.relating_shape_aspect)) AND
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PHYSICAL_UNIT_DATUM' IN TYPEOF
       (SELF\shape_aspect_relationship.related_shape_aspect));
  WR2: SELF\shape_aspect.name = SELF\shape_aspect_relationship.name;
  WR3: SELF\shape_aspect.description = SELF\shape_aspect_relationship.
       description;
  WR4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR5: SIZEOF (TYPEOF(SELF) - (TYPEOF(SELF\shape_aspect || 
       SELF\shape_aspect_relationship || SELF\datum_difference))) = 0;
END_ENTITY;

ENTITY datum_difference_based_characteristic
  SUBTYPE OF (representation_item);
WHERE
  WR1: SIZEOF(QUERY ( r <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
       'REPRESENTATION.ITEMS') | (SIZEOF(QUERY (prd2 <*
        QUERY ( prd <* USEDIN(r,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
       ((('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' 
       + 'PROPERTY_DEFINITION_REPRESENTATION') IN TYPEOF(prd)) AND 
       (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
        'PROPERTY_DEFINITION') IN TYPEOF(prd\
       property_definition_representation.definition))) ) |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DATUM_DIFFERENCE' IN
      TYPEOF(prd2\property_definition_representation.definition\
                               property_definition.definition))))
            = 1) )) 
               = 1;
END_ENTITY;

(** Questionable entity - nothing directly mapps to it from ARM *)
ENTITY dimensional_size_property
  SUBTYPE OF (dimensional_size, property_definition);
END_ENTITY;

ENTITY edge_segment_vertex
  SUBTYPE OF (physical_unit_datum);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\physical_unit_datum ||
       SELF\edge_segment_vertex)) = 0;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        pd\property_definition.description = 'shape element characterization'
       )) = 1;
  WR3: SELF\shape_aspect.of_shape\property_definition.definition.
       frame_of_reference\application_context_element.name
       IN ['physical design occurrence', 'physical design usage'];
  WR4: SELF\shape_aspect.name = 'single datum';
END_ENTITY;

ENTITY geometric_tolerance_group
  SUBTYPE OF (property_definition);
WHERE
    WR1: SELF\property_definition.description
         IN ['separate requirement', 'simultaneous requirement'];
(* removed because of the geometric_tolerance_with_specified_datum_system          
    WR2: (NOT (SELF\property_definition.description = 
          'separate requirement'))
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' 
         IN TYPEOF(pdr.related_property_definition)) AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance')
         )) >=1);
*)         
    WR3: (NOT (SELF\property_definition.description = 
        'simultaneous requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' 
         IN TYPEOF(pdr.related_property_definition)) AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance'))
         )) >=2);
    WR4: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'LINEAR_PROFILE_TOLERANCE' IN 
          TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'linear profile refinement') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR5: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'SURFACE_PROFILE_TOLERANCE' IN 
         TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'surface profile refinement') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR6: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'POSITION_TOLERANCE' IN 
         TYPEOF(pdr.related_property_definition)) AND
         (pdr.related_property_definition\property_definition.name = 
         'feature relating position') AND
         (pdr\property_definition_relationship.name = 'group geometric tolerance') )
         )) =0);
    WR7: (NOT (SELF\property_definition.description = 
         'separate requirement')) 
         OR (SIZEOF (QUERY(pdr <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
         (pdr\property_definition_relationship.name = 'group geometric tolerance') AND
      (SIZEOF(['EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'LINEAR_PROFILE_TOLERANCE',
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
         'SURFACE_PROFILE_TOLERANCE',
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
     'POSITION_TOLERANCE'] * TYPEOF(pdr.related_property_definition)) > 0)
         )) =0);
END_ENTITY;

ENTITY linear_profile_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: ( NOT( SELF\geometric_tolerance.name = 
        'linear profile refinement')) OR
       ( SIZEOF (QUERY( gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
        TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')
       AND ((gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile locating')
       OR (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement')))
       )) = 1);
  WR2: ( NOT(SELF\geometric_tolerance.name = 'linear profile locating')) OR
       ( SIZEOF( QUERY( gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement'))
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))) = 1);
(* removed because of the geometric_tolerance_with_specified_datum_system                 
  WR3: ( NOT( ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(SELF))
       AND ( SELF\geometric_tolerance.name = 
       'linear profile refinement'))) OR
       ( SIZEOF( QUERY( gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.relating_geometric_tolerance\geometric_tolerance.name = 
      'linear profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control')
       )) = 0);
*)       
  WR4: ( NOT( SELF\geometric_tolerance.name = 
       'linear profile refinement')) OR
       ( SIZEOF (QUERY( gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE') |
       (('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'LINEAR_PROFILE_TOLERANCE' IN 
       TYPEOF(gtr.relating_geometric_tolerance))
       AND (gtr.related_geometric_tolerance\geometric_tolerance.name = 
       'linear profile refinement')
       AND (gtr\geometric_tolerance_relationship.name = 'linear profile refining control'))
       )) <= 1);
  WR5: NOT('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY;

ENTITY opposing_boundary_dimensional_size
  SUBTYPE OF (dimensional_size);
WHERE
    WR1: SELF\dimensional_size.name  IN ['angular', 'linear'];
END_ENTITY;

ENTITY physical_unit_datum
  SUPERTYPE OF (edge_segment_vertex)
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SELF\shape_aspect.description IN ['axis', 'plane', 'point', ''];
    WR2: SELF\shape_aspect.product_definitional = False;
    WR3: SELF\shape_aspect.name IN ['single datum', 'common datum', ''];
    WR4: (NOT (SELF\shape_aspect.name = 'common datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in datum system') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 1);
    WR5: (NOT (SELF\shape_aspect.name = 'common datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in common datum') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 2);
    WR6: (NOT ((SELF\shape_aspect.description = 'axis') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference axis') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR7: (NOT ((SELF\shape_aspect.description = 'plane') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference plane') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR8: (NOT ((SELF\shape_aspect.description = 'point') AND
         (SELF\shape_aspect.name IN ['common datum', 'single datum']))) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         NOT(sar\shape_aspect_relationship.name = 'reference origin') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR)))) = 1);
    WR9: (NOT (SELF\shape_aspect.name = 'single datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum usage in datum system') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'DATUM_SYSTEM' IN TYPEOF(SAR)))) >= 1);
   WR10: (NOT (SELF\shape_aspect.name = 'single datum')) OR
         (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         (sar\shape_aspect_relationship.name = 'datum feature usage in single datum') AND
         (TRUE))) <= 1);
   WR11: NOT ((SELF\shape_aspect.name IN [''])
         AND (SELF\shape_aspect.description IN ['']));
   WR12: (NOT(SELF\shape_aspect.description = 'plane')) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'PROPERTY_DEFINITION.DEFINITION') |
         pd\property_definition.description = 'datum direction property')) <= 2);
END_ENTITY;

ENTITY physical_unit_datum_feature
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
             'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
             'PROPERTY_DEFINITION.' + 'DEFINITION') | 
             (pd\property_definition.description = 'datum feature identification')))) = 1;
    WR2: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name IN ['datum feature usage in common datum',
         'datum feature usage in single datum'])) >= 1);
    WR3: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'datum feature usage in single datum')) <= 1);
END_ENTITY;

ENTITY physical_unit_datum_target_set
  SUBTYPE OF (physical_unit_datum_feature);
WHERE
    WR1: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'datum target usage')) >= 1);
    WR2: (SIZEOF (QUERY ( sar <* USEDIN(SELF,
         'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         sar\shape_aspect_relationship.name = 'constituent')) = 0);
END_ENTITY;

ENTITY physical_unit_geometric_tolerance
  SUBTYPE OF (geometric_tolerance, property_definition);
WHERE
    WR1: SELF\geometric_tolerance.name = SELF\property_definition.name;
    WR2: SELF\geometric_tolerance.toleranced_shape_aspect
         = SELF\property_definition.definition;
(* removed because of the geometric_tolerance_with_specified_datum_system                   
    WR3: (NOT (SIZEOF([
              'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
              'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM',
              'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
              'LINEAR_PROFILE_TOLERANCE',
              'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
              'SURFACE_PROFILE_TOLERANCE',
              'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
              'POSITION_TOLERANCE'] * TYPEOF(SELF)) = 0))
         OR (SELF\geometric_tolerance.name IN ['circularity',
             'cylindricity', 'flatness', 'straightness']);
*)             
    WR4: (NOT (SELF\geometric_tolerance.name = 'circularity')) OR
         (NOT ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR5: (NOT (SELF\geometric_tolerance.name = 'cylindricity')) OR
         (NOT ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
             'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR6: (NOT (SELF\geometric_tolerance.name = 'flatness')) OR
         (NOT ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
         'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
    WR7: (SIZEOF (QUERY (pugt <* QUERY ( sar <* USEDIN(SELF,
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 
          'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          sar\shape_aspect_relationship.name = 'group geometric tolerance') | 
          pugt.relating_shape_aspect\shape_aspect.description = 
          'simultaneous requirement')) <= 1);
END_ENTITY;

ENTITY positional_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN 
    ['dimension related positional boundary',
  'profile related positional boundary'];

  WR2: SELF\shape_aspect.product_definitional = False;

  WR3: (NOT(SELF\shape_aspect.description = 
           'dimension related positional boundary'))
       OR (SIZEOF(QUERY(sar <* USEDIN(SELF, 
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
             'POSITIONAL_BOUNDARY_MEMBER' IN 
               TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 'boundary member'))) >= 1);
(* invalid csa
  WR4: (NOT(SELF\shape_aspect.description = 
         'dimension related positional boundary'))
       OR (SIZEOF(QUERY(sar <*USEDIN(SELF, 
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | (sar.related_shape_aspect.product_definitional = True) AND
            (sar\shape_aspect_relationship.name = 'constrained feature'))) +
           SIZEOF(QUERY(sar <*USEDIN(SELF, 
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 'constrained feature'))
           ) = 1);     
*)
  WR5: (NOT(SELF\shape_aspect.description = 
              'dimension related positional boundary'))
       OR (SIZEOF(QUERY(pd <* USEDIN(SELF,
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'PROPERTY_DEFINITION.DEFINITION')        
          | (pd\property_definition.description = 
                'dimension related positional boundary property'))) = 1);

  WR6: (NOT(SELF\shape_aspect.description = 
                  'profile related positional boundary'))
       OR (SIZEOF(QUERY(pd <* USEDIN(SELF,
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'PROPERTY_DEFINITION.DEFINITION')        
          | (pd\property_definition.description = 
                  'profile related positional boundary property'))) = 1);
   
  WR7: (NOT(SELF\shape_aspect.description = 
                     'profile related positional boundary'))
       OR (SIZEOF(QUERY(sar <* USEDIN(SELF, 
          'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') 
          | ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))
            AND (sar\shape_aspect_relationship.name = 
               'positional boundary and profile boundary member'))) = 1);
END_ENTITY;

ENTITY positional_boundary_member
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = False;

  WR2: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION')        
       | (pd\property_definition.description = 'positional boundary member property'))
       ) = 1;
  WR3: SIZEOF(QUERY(sar <* USEDIN(SELF, 
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') 
       | (sar\shape_aspect_relationship.name = 'boundary member') AND
         ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
          'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))
         AND (sar.relating_shape_aspect\shape_aspect.description =
         'dimension related positional boundary'))) = 1;
END_ENTITY;

ENTITY statistical_dimensional_location
 SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY statistical_dimensional_size
 SUBTYPE OF (dimensional_size_property);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1;       
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 
        'dimensional tolerance statistical control requirement')))
       <= 1))) <= 1;       
  WR3: (NOT(SIZEOF (QUERY (pd <* USEDIN (SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1))
       OR (NOT(SIZEOF (QUERY (pd <* USEDIN (SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition)) AND
       (NOT('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'STATISTICAL_DIMENSIONAL_SIZE' IN 
       TYPEOF (pdr.related_property_definition))) AND
       (pdr\property_definition_relationship.name = 'substitutable dimension'))) 
       <= 1))) <= 1));     
END_ENTITY;

ENTITY statistical_geometric_tolerance
  SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') | 
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN
       TYPEOF(gtr.relating_geometric_tolerance)) AND
       (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance')
       )) <= 1;
  WR2: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') | 
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF(pdr.related_property_definition)) AND
       (pdr\property_definition_relationship.name = 'geometric tolerance statistical control requirement')
       )) = 1;
  WR3: SIZEOF(QUERY(gtr <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE') | 
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'STATISTICAL_GEOMETRIC_TOLERANCE' IN
       TYPEOF(gtr.relating_geometric_tolerance)) AND
       (gtr\geometric_tolerance_relationship.name = 'substitutable geometric tolerance')
       )) <= 0;
END_ENTITY;

ENTITY tolerance_zone_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: (NOT(SELF\shape_aspect.description = 'conical'))
       OR (NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
                'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
                IN TYPEOF(SELF))
           OR('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
               IN TYPEOF(SELF))));
  WR2: (NOT(SELF\shape_aspect.description = 
                 'circular or cylindrical or spherical'))
       OR (NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
                'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
                IN TYPEOF(SELF))
           OR('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
               'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
               IN TYPEOF(SELF))));
  WR3: SELF\shape_aspect.product_definitional = False;
  WR4: NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
           'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET'
           IN TYPEOF(SELF))
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
           'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET'
           IN TYPEOF(SELF)));
    WR5: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') | (pd\property_definition.description = 
       'boundary zone definition with specified size') OR 
       (pd\property_definition.description = 'conical tolerance zone boundary')
       )) = 1;
  WR6: SIZEOF(USEDIN(SELF, 
            'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'TOLERANCE_ZONE_DEFINITION.BOUNDARIES')) = 1;
END_ENTITY;

ENTITY tolerance_zone_explicit_opposing_boundary_set
  SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY;

ENTITY tolerance_zone_implicit_opposing_boundary_set
  SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY;

ENTITY viewing_plane
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: SELF\shape_aspect.description = 'affected plane';
    WR2: (SIZEOF(QUERY ( pd <* USEDIN (SELF,
             'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
             'PROPERTY_DEFINITION.' + 'DEFINITION') | (pd\property_definition.description = 
             'viewing plane property')))) =1;
    WR3: NOT SELF\shape_aspect.product_definitional;
END_ENTITY;

RULE boundary_size_characteristic_constraint FOR
  (representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'diametrical boundary size')
        OR (rep\representation.name = 'opposing boundary set size'))
       AND (NOT(SIZEOF(QUERY(lmwu <* rep.items |
       (lmwu\representation_item.name = 'tolerance value'))) = 1)))) = 0;
END_RULE;

RULE directed_axis_constraint FOR
  (derived_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'derived axis')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'end shape aspect')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'start shape aspect')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
END_RULE;

RULE directed_axis_unique_constraint FOR
 ( derived_shape_aspect );
LOCAL
  da : BAG OF derived_shape_aspect := QUERY( r <* derived_shape_aspect |
(r\shape_aspect.description = 'directed axis') );
  sar_bag : BAG OF shape_aspect_relationship;
  cos_bag : BAG OF centre_of_symmetry := [];
  sar2_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(da) by 1;
  sar_bag := QUERY( sar <* USEDIN(da[i],
'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.related_shape_aspect\shape_aspect.description = 'axis') AND
('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( NOT( sar_bag[j].related_shape_aspect IN cos_bag ) ) THEN
        cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cos_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  sar_bag := QUERY( sar <* USEDIN(cos_bag[i],
'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.relating_shape_aspect IN da)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar2_bag := QUERY( sar <* USEDIN(sar_bag[j].relating_shape_aspect,
'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
(sar\shape_aspect_relationship.name = 'start shape aspect') );
    REPEAT k := 1 to SIZEOF(sar2_bag) by 1;
      IF EXISTS( sar2_bag[k].related_shape_aspect ) THEN
        IF ( sar2_bag[k].related_shape_aspect IN sa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE direction_element_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'element direction vector')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'half datum plane direction vector')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'direction component')
       AND ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description =
       'datum based vector orientation'))) = 1))) = 0;
END_RULE;

RULE edge_segment_vertex_constraint 
FOR (shape_aspect_relationship, edge_segment_vertex);
LOCAL
sar : BAG OF shape_aspect_relationship := [];
esv : BAG OF edge_segment_vertex := edge_segment_vertex;
pass : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (esv) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      sar := QUERY (sar <* shape_aspect_relationship |
       esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
       pass := (SIZEOF(sar) = 2);
      REPEAT j := 2 to SIZEOF (sar) by 1;
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( (sar[j]) :<>: (sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( TYPEOF(sar[j]) = TYPEOF(sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := (sar[j].relating_shape_aspect :=:
               sar[j-1].relating_shape_aspect);
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE edge_segment_vertex_unique_constraint FOR
 ( edge_segment_vertex );
LOCAL
  esv : BAG OF edge_segment_vertex := QUERY( r <* edge_segment_vertex
| (r\shape_aspect.name = 'single datum') );
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(esv) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := QUERY( pd <* USEDIN( esv[i],
'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'shape element characterization') );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := USEDIN( pd_bag[j],
'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      IF ( (pdr_bag[k].used_representation\representation.name = 
           'shape element characterization') AND
('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pdr_bag[k].used_representation.items[1])) ) THEN
        IF EXISTS
            ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description ) THEN
          IF ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN 
                   desc_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            desc_bag := desc_bag + 
                      pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
WHERE
  WR1: SIZEOF(QUERY(mq <* measure_qualification |
       ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier')
       OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier'))
       AND NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure))
       AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'GEOMETRIC_TOLERANCE.MAGNITUDE') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)
       ))) = 0;
END_RULE;

RULE positional_boundary_member_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition))))) = 0; 
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'DIMENSIONAL_SIZE_PROPERTY' IN 
       TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'boundary member associated dimension')
       )) = 1))) = 0; 
END_RULE;

RULE positional_boundary_offset_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF (pd.definition)) AND
 (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))
       )) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'boundary offset') AND
       (pdr.relating_property_definition\property_definition.name =
       'profile related positional boundary property'))) = 1)
       )) = 0;
END_RULE;

RULE profile_related_positional_boundary_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND
       (pd.definition\shape_aspect.description = 'profile related positional boundary')
       ))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
(pdr.related_property_definition\property_definition.description = 'positional boundary offset')
       AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
END_RULE;

RULE projected_zone_and_base_relationship_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT(('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))
       OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
END_RULE;

RULE projected_zone_height_characteristic_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))
       )) = 0;
END_RULE;

RULE restraint_condition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'restraint') 
       OR (pd\property_definition.description = 'tolerance specific restraint'))
       AND (SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
    + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('EXTENDED_GEOMETRIC_TOLERANCE_MIM.'
    + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
END_RULE;

RULE shape_element_deriving_relationship_unique_constraint FOR
 ( shape_aspect_deriving_relationship );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  sadr_bag : BAG OF shape_aspect_deriving_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect_deriving_relationship) by 1;
  IF EXISTS( shape_aspect_deriving_relationship[i].relating_shape_aspect )
                                                    THEN
    IF( NOT( shape_aspect_deriving_relationship[i].
                           relating_shape_aspect IN sa_bag ) ) 
                                                  THEN
      sa_bag := sa_bag + 
            shape_aspect_deriving_relationship[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sadr_bag := QUERY( r <* shape_aspect_deriving_relationship | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sadr_bag) by 1;
    IF EXISTS( sadr_bag[j].related_shape_aspect ) THEN
      IF ( sadr_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE subtype_exclusive_dimensional_location FOR
  (dimensional_location);
WHERE  
  WR1: SIZEOF (QUERY (dl <* dimensional_location |
       NOT (SIZEOF ([
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'ANGULAR_DIMENSION_WITH_ORIENTATION',
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DIMENSIONAL_LOCATION',
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'DIMENSIONAL_LOCATION_WITH_PATH']
       * TYPEOF(dl)) <= 1))) = 0;
END_RULE;

(* Rule makes no sense after curve_dimension is substituted by Curved_size_dimension from dimension_tolerance
RULE subtype_exclusive_dimensional_size FOR
  (dimensional_size);
WHERE  
  WR1: SIZEOF (QUERY (ds <* dimensional_size |
       NOT (SIZEOF ([
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'ANGULAR_DIMENSIONAL_SIZE',
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'ANGULAR_SIZE']
       * TYPEOF(ds)) <= 1) OR
       NOT (SIZEOF ([
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'ANGULAR_DIMENSIONAL_SIZE',
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE']
       * TYPEOF(ds)) <= 1))) = 0;
END_RULE;
*)
RULE subtype_mandatory_extended_geometric_tolerance FOR
  (geometric_tolerance);
WHERE  
  WR1: SIZEOF (QUERY (gt <* geometric_tolerance |
       NOT (SIZEOF ([
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'] *
       TYPEOF (gt)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_runout_zone_orientation FOR
  (runout_zone_orientation);
WHERE  
  WR1: SIZEOF (QUERY (rzo <* runout_zone_orientation |
       NOT (SIZEOF ([
       'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' +
       'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION'] *
       TYPEOF (rzo)) = 1))) = 0;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\extended_measure_representation_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3232 - ISO/TS 10303-1106 Extended measure representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N3047
*) 


SCHEMA Extended_measure_representation_mim;

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item,
   precision_qualifier,
   qualified_representation_item,
   qualitative_uncertainty, -- GL added, needed for mapping
   standard_uncertainty,
   type_qualifier,
   uncertainty_qualifier); 

USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   list_representation_item,
   set_representation_item); 

USE FROM support_resource_schema;    -- ISO 10303-41

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (type_check_function); 


ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ( 'value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
  WR2: value_range_wr2 ( item_element );
  WR3: value_range_wr3 ( item_element );
END_ENTITY;

RULE subtype_exclusiveness_representation_item FOR 
(representation_item);
WHERE
  WR1: SIZEOF(QUERY (cri <* representation_item | NOT (type_check_function(cri,['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
END_RULE; 

FUNCTION value_range_wr1
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 <* agg | (
'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

FUNCTION value_range_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY (i <* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i <* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;
      END_FUNCTION; 

FUNCTION value_range_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN
IF (SIZEOF(QUERY(i1 <* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 <* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
(i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;
      END_FUNCTION; 

END_SCHEMA;  -- Extended_measure_representation_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\external_class_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3050 - ISO/TS 10303-1275 External class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2265
*) 


SCHEMA External_class_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select); 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
   (external_class_library);
END_TYPE; 

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

END_SCHEMA;  -- External_class_mim




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\external_item_identification_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1208 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
*)


SCHEMA External_item_identification_assignment_mim;

USE FROM management_resources_schema   	-- ISO 10303-41
  (external_identification_assignment); 

USE FROM support_resource_schema		-- ISO 10303-41
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\external_model_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1229 - ISO/TS 10303-1033 External model - EXPRESS MIM
*)

SCHEMA External_model_mim;
  
USE FROM Elemental_geometric_shape_mim; -- ISO 10303-1004
  
USE FROM File_identification_mim;

USE FROM product_property_definition_schema
  (property_definition);

USE FROM product_property_representation_schema
  (property_definition_representation);

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\fabrication_joint_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3403 - ISO/CD-TS 10303-1668 Fabrication joint - EXPRESS MIM
*)


SCHEMA Fabrication_joint_mim;
	USE FROM Land_mim;	-- ISO/TS 10303-1692
	USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700
	USE FROM Sequential_laminate_assembly_design_mim;	-- ISO/TS 10303-1741
	
REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);
	
	
ENTITY connection_zone_based_fabrication_joint
  SUBTYPE OF (fabrication_joint);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'FABRICATION_JOINT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 1')) = 1;
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'FABRICATION_JOINT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'zone 2')) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'FABRICATION_JOINT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar.relating_shape_aspect\shape_aspect.description = 'connection zone')) = 2;

END_ENTITY;

ENTITY fabrication_joint
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: (('FABRICATION_JOINT_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description IN
       ['via terminal', 'printed component join terminal',
       'non functional land join terminal',
       'land join terminal', 'conductive interconnect element terminal',
       'component termination passage join terminal']));
  WR2: (('FABRICATION_JOINT_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description IN
       ['via terminal', 'printed component join terminal',
       'non functional land join terminal',
       'land join terminal', 'conductive interconnect element terminal',
       'component termination passage join terminal']));
(* invalid csa 
  WR3: SIZEOF (QUERY (ajm <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_JOINT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'auxiliary joint material') |
       ('FABRICATION_JOINT_MIM.' +
       'LAND' IN
       TYPEOF (ajm.related_shape_aspect)) OR
       (('FABRICATION_JOINT_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (ajm.related_shape_aspect)) AND
       (ajm.related_shape_aspect\shape_aspect.description =
       'stratum feature template component')))) <= 1; *)
  WR4: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'FABRICATION_JOINT_MIM.'+
       'FABRICATION_JOINT');
END_ENTITY;

ENTITY passage_terminal_based_fabrication_joint_link
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
END_ENTITY;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\fabrication_requirement_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3406 - ISO/CD-TS 10303-1669 Fabrication requirement - EXPRESS MIM
*)


SCHEMA Fabrication_requirement_mim;
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\fabrication_technology_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3664 - ISO/CD-TS 10303-1670 Fabrication technology - EXPRESS MIM
*)


SCHEMA Fabrication_technology_mim;
	USE FROM Physical_layout_template_mim;	-- ISO/TS 10303-1722
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740

TYPE ft_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (land_physical_template);
END_TYPE; 
	
-- Needed by the mapping
TYPE ft_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (design_object);
END_TYPE; 

TYPE ft_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (characterized_object,
   representation);
END_TYPE; 

ENTITY dependent_material_removal_feature_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SELF\product_definition.description = 'material removal feature template';
  WR2: SIZEOF (QUERY (am <* QUERY (pdr <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'associated template') |
       (('FABRICATION_TECHNOLOGY_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (am.relating_product_definition)) AND
       (am.relating_product_definition.description IN
       ['default attachment size and component termination passage based',
       'default attachment size based',
       'default attachment size and via based',
       'default component termination passage based',
       'default via based',
       'default unsupported passage based']))
        )) = 1;
END_ENTITY;

ENTITY design_object
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY electrical_isolation_removal_template_definition
  SUBTYPE OF (part_template_definition);
(*
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
*)
END_ENTITY;

ENTITY grouped_requirements_property
  SUBTYPE OF (group, requirements_property);
WHERE
  WR1: (NOT (SELF\group.name = 
        'item restricted requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'FABRICATION_TECHNOLOGY_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       SIZEOF (aga.items) = 1)) = 1);
  WR2: (NOT (SELF\group.name = 
        'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'FABRICATION_TECHNOLOGY_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (aga.items) = 2) AND
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.name IN [
       'assembly module assembly component',
       'assembly module component terminal',
       'assembly module component',
       'assembly module macro component join terminal',
       'assembly module macro component',
       'assembly module',
       'bare die component terminal',
       'bare die component',
       'bonded conductive base blind via',
       'buried via',
       'cable component',
       'component feature',
       'component mounting feature',
       'component termination passage and contact size dependent land',
       'component termination passage and contact size dependent non functional land',
       'component termination passage dependent land',
       'component termination passage dependent non functional land',
       'component termination passage interface terminal',
       'component termination passage join terminal',
       'component termination passage',
       'conductive interconnect element terminal',
       'conductive interconnect element with pre defined transitions',
       'conductive interconnect element with user defined single transition',
       'connected area component',
       'contact size dependent land',
       'contact size dependent non functional land',
       'cutout edge segment',
       'cutout',
       'dielectric material passage',
       'electrical isolation laminate component',
       'embedded component terminal',
       'fiducial',
       'fill area',
       'filled area material removal laminate component',
       'inter stratum feature',
       'interconnect component interface terminal',
       'interconnect component join terminal',
       'interconnect module assembly component',
       'interconnect module component stratum based terminal',
       'interconnect module component surface feature',
       'interconnect module component terminal',
       'interconnect module component',
       'interconnect module edge segment',
       'interconnect module edge',
       'interconnect module macro component join terminal',
       'interconnect module macro component',
       'interface access material removal laminate component',
       'interface access stratum feature template component',
       'interface component',
       'interfacial connection',
       'internal probe access area',
       'join two physical connectivity definition supporting inter stratum feature',
       'join two physical connectivity definition supporting printed component',
       'laminate component',
       'laminate text component',
       'laminate text string component',
       'land interface terminal',
       'land join terminal',
       'land',
       'material removal laminate component',
       'minimally defined component terminal',
       'movable packaged component join terminal',
       'multi layer material removal laminate component',
       'multi layer stratum feature template component',
       'non conductive base blind via',
       'non functional land interface terminal',
       'non functional land join terminal',
       'non functional land',
       'packaged component join terminal',
       'packaged component',
       'packaged connector component interface terminal',
       'packaged connector component',
       'partially plated cutout',
       'partially plated interconnect module edge',
       'physical component',
       'physical connectivity interrupting cutout',
       'physical laminate component',
       'physical network supporting inter stratum feature',
       'plated conductive base blind via',
       'plated cutout edge segment',
       'plated cutout',
       'plated interconnect module edge segment',
       'plated interconnect module edge',
       'plated passage or unsupported passage',
       'plated passage',
       'primary stratum indicator symbol',
       'printed component join terminal',
       'printed connector component interface terminal',
       'probe access area',
       'routed interconnect component',
       'routed physical component',
       'special symbol laminate component',
       'stratum feature template component',
       'stratum feature',
       'thermal isolation laminate component',
       'unrouted conductive interconnect element',
       'unsupported passage dependent non functional land',
       'unsupported passage',
       'via and contact size dependent land',
       'via and contact size dependent non functional land',
       'via dependent land',
       'via dependent non functional land',
       'via terminal',
       'via']))) = 2))) = 1);
  WR3: (NOT (SELF\group.name = 
       'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'FABRICATION_TECHNOLOGY_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.description = 
       'dependent design object category'))) = 1))) = 1);
  WR4: (NOT (SELF\group.name = 
       'layout spacing requirements property')) OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'FABRICATION_TECHNOLOGY_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (QUERY (rp <* QUERY (it <* aga.items |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (it)) |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESIGN_OBJECT' IN 
       TYPEOF (rp)) AND
       (rp\characterized_object.description = 
       'reference design object category'))) = 1))) = 1);
END_ENTITY;

ENTITY land_physical_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SIZEOF (QUERY (ada <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
    duc\document_usage_constraint.subject_element = 
                 'pre defined classification code')) = 1)) <= 1;
(* invalid csa                 
  WR2: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated definition') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (am.related_shape_aspect))) >= 1; *)
(* invalid csa       
 WR3:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default attachment size based',
       'default attachment size and component termination passage based', 
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'minimum attachment region size') AND 
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone')))) <= 1));*)
(* invalid csa              
 WR4:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default attachment size based',
       'default attachment size and component termination passage based', 
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'maximum attachment region size') AND 
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone')))) <= 1));*)
(* invalid csa              
 WR5:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default component termination passage based',
   'default attachment size and component termination passage based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 
       'default component termination passage definition'))) = 1)); *)
(* invalid csa              
 WR6:  NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based',
       'default attachment size based', 
       'default attachment size and via based', 
       'default component termination passage based',
       'default via based',
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (ost <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'of stratum technology') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (ost.relating_shape_aspect.of_shape.definition)
       )) = 1)); *)
 WR7:  NOT(EXISTS(SELF\product_definition.description)) OR
       ((NOT (SELF\product_definition.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0));
 WR8:  NOT(EXISTS(SELF\product_definition.description)) OR
       ((NOT (SELF\product_definition.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND 
       (it\representation_item.name = 'minimum fabrication allowance'))) 
       = 1)) = 1))) = 0));
 WR9:  NOT(EXISTS(SELF\product_definition.description)) OR
       ((NOT (SELF\product_definition.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'minimum annular ring'))) = 1
       )) = 1))) = 0));
(* invalid csa       
 WR10: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN 
       ['default attachment size and component termination passage based', 
       'default attachment size and via based', 
       'default component termination passage based', 'default via based', 
       'default unsupported passage based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect))) = 1)); *)
(* invalid csa              
 WR11: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description IN ['default via based',
       'default attachment size and via based'])) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 'default via definition'))) 
       = 1)); *)
(* invalid csa         
 WR12: NOT(EXISTS(SELF\shape_aspect.description)) OR
       ((NOT (SELF\shape_aspect.description = 'default unsupported passage')) OR
       (SIZEOF (QUERY (tu <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'technology usage') |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (tu.related_shape_aspect)) AND
       (tu.related_shape_aspect\shape_aspect.description = 
       'default unsupported passage definition'))) = 1)); *)
END_ENTITY;

ENTITY land_template_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 'join terminal'];
  WR2: SIZEOF (QUERY (tcz <* QUERY (sar <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'terminal connection zone') AND
       (sar\shape_aspect_relationship.description IN ['edge curve', 'edge point', 
       'surface area', 'surface point'])) |
       tcz.related_shape_aspect\shape_aspect.description = 'connection zone')) >= 0;
END_ENTITY;

ENTITY stratum_technology
  SUBTYPE OF (characterized_object);
UNIQUE
  UR1: SELF\characterized_object.name;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
        'FABRICATION_TECHNOLOGY_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'stiffness class representation')) <= 1))) = 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation')) = 1))) = 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (scr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'stratum class representation') |
       NOT (SIZEOF (QUERY (it <* scr.used_representation.items | 
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'laminate stiffness class') AND
       (it\descriptive_representation_item.description IN ['fluid like', 'conformal coat', 
       'stiff laminate']))) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT ({2 <= SIZEOF (pcr.used_representation.items) 
        <= 8}))) = 0))) = 0;
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items | 
       NOT (it\representation_item.name IN ['layer purpose', 
       'layer position', 
       'maximum feature size requirement', 
       'minimum finished feature spacing', 
       'minimum finished feature size', 
       'maximum thickness',  
       'minimum thickness']))) = 0))) = 0))) = 0;
  WR7: NOT(EXISTS(SELF\characterized_object.description)) OR
       (NOT (SELF\characterized_object.description = 'design layer') OR 
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature size'))) = 1))) = 0))) = 0));
  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum thickness'))) = 1))) = 0))) = 0;
  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum thickness'))) = 1))) = 0))) = 0;
 WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum feature size requirement'))) <= 1))) = 0))) = 0;
 WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature spacing'))) <= 1))) = 0))) = 0;
 WR12: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'documentation layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer purpose'))) = 1))) = 0))) = 0));
 WR13: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'design layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['FABRICATION_TECHNOLOGY_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'FABRICATION_TECHNOLOGY_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum finished feature spacing'))) = 1))) = 0))) = 0));
 WR14: NOT(EXISTS(SELF\characterized_object.description)) OR
       ((NOT (SELF\characterized_object.description = 'design layer')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer purpose') AND
       (it\descriptive_representation_item.description IN ['power or ground', 'other signal', 
       'lands only']))) = 1))) = 0))) = 0));
 WR15:  SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('FABRICATION_TECHNOLOGY_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'layer position') AND
       (it\descriptive_representation_item.description IN [
        'primary', 
        'secondary', 
        'internal', 
        'external', 
        'all']))) = 1))) = 0))) = 0;
 WR16: NOT(EXISTS(SELF\characterized_object.description)) OR
        (SELF\characterized_object.description IN [
         'design layer',
         'documentation layer']);
END_ENTITY;

ENTITY stratum_technology_link
  SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
  WR1: SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
(** Need to likely move to subtype       
  WR2: (SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\stratum_technology_link || SELF\property_definition)) = 0) OR
        ('FABRICATION_TECHNOLOGY_MIM.' +
       'PRINTED_PART_TEMPLATE_LINK' IN TYPEOF(SELF)); *)
  WR3: 'FABRICATION_TECHNOLOGY_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
    TYPEOF(SELF\property_definition_relationship.related_property_definition.definition);
  WR4: 'FABRICATION_TECHNOLOGY_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
    TYPEOF(SELF\property_definition_relationship.relating_property_definition.definition);
  WR5: SELF\property_definition.name = '';
  WR6: SELF\property_definition.description = '';
  WR7: SELF\property_definition_relationship.name = '';
  WR8: SELF\property_definition_relationship.description = '';
  WR9: ('FABRICATION_TECHNOLOGY_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF\property_definition.definition)) AND
       (SELF\property_definition.definition.description = 'printed part template');
 WR10: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr.name = 'precedent stratum technology link')) <= 1; 
 WR11: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'FABRICATION_TECHNOLOGY_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr.name = 'precedent stratum technology link')) <= 1; 
END_ENTITY;

RULE layout_spacing_requirement_occurrence_unique_constraint FOR
 ( grouped_requirements_property, characterized_object );
LOCAL
  lsro : BAG OF grouped_requirements_property := QUERY( grp <*
grouped_requirements_property | 
(grp\group.name = 'layout spacing requirements property') );
  ddo : BAG OF characterized_object := QUERY( co <* characterized_object |
(co\characterized_object.description = 'dependent design object category') );
  ga_bag : BAG OF group_assignment := [];
  ddname_bag : BAG OF STRING := [];
  co_bag : BAG OF characterized_object := [];
  pdb : LIST OF property_definition := [];
  pd_bag : BAG OF property_definition := [];
  grp_bag : BAG OF grouped_requirements_property := [];
  rga_bag : BAG OF group_assignment := [];
  pass : BOOLEAN := TRUE;
  rdname_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(lsro) by 1;
  ga_bag := QUERY( aga <* USEDIN(lsro[i],
'FABRICATION_TECHNOLOGY_MIM.' +
'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | 
'FABRICATION_TECHNOLOGY_MIM.' +
'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga));
  REPEAT j := 1 to SIZEOF(ga_bag) by 1;
    REPEAT k := 1 to SIZEOF(ga_bag[j].items) by 1;
      IF ( 'FABRICATION_TECHNOLOGY_MIM.' +
           'PROPERTY_DEFINITION' IN TYPEOF(ga_bag[j].items[k])) 
     THEN pdb[i] := ga_bag[j].items[k];
     ELSE pdb := [];
     END_IF; 

    IF ( (pdb :<>: []) AND
        ('FABRICATION_TECHNOLOGY_MIM.' +
        'CHARACTERIZED_OBJECT' IN TYPEOF(pdb[1]\property_definition.definition)) AND
        (pdb[1]\property_definition.definition\characterized_object.description = 
        'dependent design object category') ) THEN
      IF EXISTS( pdb[1]\property_definition.definition\characterized_object.name ) THEN
        IF( NOT( pdb[1]\property_definition.definition\characterized_object.name IN ddname_bag ) ) THEN
          ddname_bag := ddname_bag + pdb[1]\property_definition.definition\characterized_object.name;
        END_IF;
      END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ddname_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  rdname_bag := [];
  co_bag := QUERY( co <* ddo | (co\characterized_object.name = ddname_bag[i]) );
  REPEAT j := 1 to SIZEOF(co_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( co_bag[j], 
'FABRICATION_TECHNOLOGY_MIM.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      ga_bag := QUERY( ga <* USEDIN(pd_bag[k], 
'FABRICATION_TECHNOLOGY_MIM.' +
'APPLIED_GROUP_ASSIGNMENT.ITEMS') | 
('FABRICATION_TECHNOLOGY_MIM.' +
'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(ga.assigned_group)) );
      REPEAT l := 1 to SIZEOF(ga_bag) by 1;
        IF ( NOT pass ) THEN ESCAPE;
        END_IF;
        IF( NOT( ga_bag[l].assigned_group IN grp_bag ) ) THEN
          grp_bag := grp_bag + ga_bag[l].assigned_group;
        END_IF;
      END_REPEAT;
      REPEAT l := 1 to SIZEOF(grp_bag) by 1;
        IF ( NOT pass ) THEN ESCAPE;
        END_IF;
        rga_bag := USEDIN(grp_bag[l], 
'FABRICATION_TECHNOLOGY_MIM.' +
'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
        REPEAT m := 1 to SIZEOF(rga_bag) by 1;
          IF ( NOT pass ) THEN ESCAPE;
          END_IF;
          REPEAT n:= 1 TO SIZEOF(rga_bag[m].items) by 1;
      IF ( 'FABRICATION_TECHNOLOGY_MIM.' +
           'PROPERTY_DEFINITION' IN TYPEOF(rga_bag[n].items[m]))
     THEN pdb[1] := rga_bag[n].items[m];
     ELSE pdb := [];
     END_IF;

    IF ( (pdb :<>: []) AND
         ('FABRICATION_TECHNOLOGY_MIM.' +
          'CHARACTERIZED_OBJECT' IN 
         TYPEOF(pdb[1]\property_definition.definition)) AND
(pdb[1]\property_definition.definition\characterized_object.description = 
'reference design object category') ) THEN
              IF EXISTS( pdb[1]\property_definition.definition\characterized_object.name ) THEN
                IF( pdb[1]\property_definition.definition\characterized_object.name IN rdname_bag ) THEN
                  pass := FALSE;
                  ESCAPE;
                ELSE
                  rdname_bag := rdname_bag + 
                          pdb[1]\property_definition.definition\characterized_object.name;
                END_IF;
              END_IF;
            END_IF;
          END_REPEAT;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  adr_bag : BAG OF applied_document_reference;
  duc : BAG OF document_usage_constraint;
  pass : BOOLEAN := TRUE;
  duc_bag : BAG OF document_usage_constraint := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(land_physical_template) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  adr_bag := USEDIN(land_physical_template[i],
'FABRICATION_TECHNOLOGY_MIM.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
  REPEAT j := 1 to SIZEOF(adr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    duc := QUERY( r <* USEDIN(adr_bag[j].assigned_document,
'FABRICATION_TECHNOLOGY_MIM.' +
'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (r\document_usage_constraint.subject_element =
'predefined classification code') );
    REPEAT k := 1 to SIZEOF(duc) by 1;
      IF EXISTS( duc[k] ) THEN
        IF ( duc[k] IN duc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          duc_bag := duc_bag + duc[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE land_template_terminal_unique_constraint FOR
 ( land_template_terminal );
LOCAL
  ltt : BAG OF land_template_terminal := 
QUERY( sa <* land_template_terminal |
(sa\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  ltt_bag : BAG OF land_template_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  lpt_bag : BAG OF land_physical_template;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ltt) by 1;
  IF EXISTS( ltt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ltt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ltt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  lpt_bag := [];
  ltt_bag := QUERY( sa <* ltt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(ltt_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(ltt_bag[j],
'FABRICATION_TECHNOLOGY_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition') AND
('FABRICATION_TECHNOLOGY_MIM.' +
'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN lpt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\feature_and_connection_zone_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3409 - ISO/CD-TS 10303-1671 Feature and connection zone - EXPRESS MIM
*)


SCHEMA Feature_and_connection_zone_mim;
	USE FROM Shape_property_assignment_mim;	-- ISO/TS 10303-1032
	
ENTITY connection_zone_interface_plane_relationship
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
       SELF\connection_zone_interface_plane_relationship ||
       SELF\shape_aspect)) = 0;
  WR2: 'FEATURE_AND_CONNECTION_ZONE_MIM.' +
       'SEATING_PLANE' IN 
       TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 
      'plane';
  WR4: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 
      'connection zone';
  WR5: SELF\shape_aspect_relationship.description IN ['area', 'edge']; 
  WR6: SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
  WR7: SELF\shape_aspect.of_shape = SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
  WR8: SIZEOF (QUERY (dz <* QUERY (sar <* USEDIN (SELF,
       'FEATURE_AND_CONNECTION_ZONE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'derived zone') |
       dz.related_shape_aspect\shape_aspect.description = 'connection zone')) = 1;
END_ENTITY;

RULE connection_zone_constraint FOR ( shape_aspect, representation );
WHERE
   WR1: SIZEOF( QUERY( sa <* shape_aspect | 
        (sa\shape_aspect.description = 'connection zone') AND NOT 
        (SIZEOF (USEDIN (sa, '')) >= 1))) = 0;
   WR2: SIZEOF( QUERY( sa <* shape_aspect | 
              (sa\shape_aspect.description = 'connection zone') AND 
        NOT(SIZEOF( QUERY( sar <* USEDIN(sa,
        'FEATURE_AND_CONNECTION_ZONE_MIM.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name IN [
        'connection',
        'minimum attachment region size',
        'maximum attachment region size',
        'external connection area', 
        'external connection zone',
        'internal connection zone',
        'mounting area', 
        'terminal connection zone'
         ]))) >= 1))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\file_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1205 - ISO/TS 10303-1127 File identification - EXPRESS MIM
*)

SCHEMA File_identification_mim;

USE FROM Identification_assignment_mim;
 
USE FROM External_item_identification_assignment_mim;

USE FROM document_schema   -- ISO 10303-41
  (document,
   document_representation_type); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

TYPE file_identification_item = SELECT BASED_ON identification_item WITH (document_file);
END_TYPE; 

TYPE file_version_item = SELECT BASED_ON versionable_item WITH
  (document_file);
END_TYPE;

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (document_file);
END_TYPE;

ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF( QUERY( drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical'])) = 1;
END_ENTITY;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\fill_area_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3412 - ISO/CD-TS 10303-1672 Fill area - EXPRESS MIM
*)

SCHEMA Fill_area_mim;
	USE FROM Basic_curve_mim;	-- ISO/TS 10303-1651
	USE FROM Styled_curve_mim;	-- ISO/TS 10303-1749
	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
--	USE FROM Annotated_presentation_mim;
	USE FROM Associative_text_mim;    -- ISO/TS 10303-1132

	USE FROM Extended_elemental_geometric_shape_mim;	-- ISO/TS 10303-1667	
	(** Layered_shape_arm is referenced just for the vector *)

	USE FROM Presentation_definition_schema
		(annotation_fill_area,
		annotation_fill_area_occurrence);
	USE FROM Presentation_appearance_schema(fill_area_style);

(* Not allowed by EXPRESS to extend non extensible select
TYPE fa_presentation_style_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON presentation_style_select WITH 
   (externally_defined_hatch_style,
   fill_area_style_hatching,
   fill_area_style_colour,
   fill_area_style_tiles,
   externally_defined_tile_style);
END_TYPE; *)

RULE fill_area_occurrence_constraint FOR 
( annotation_fill_area_occurrence );
WHERE
  WR1: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('FILL_AREA_MIM.'
       + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item))
       )) = 0;
  WR2: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('FILL_AREA_MIM.'
       + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target))
       )) = 0;
  WR3: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       SIZEOF(QUERY(psa <* afao.styles |
       SIZEOF(QUERY(cs <* psa.styles |
       ('FILL_AREA_MIM.'
       + 'CURVE_STYLE' IN TYPEOF(cs))
       )) = 0
       )) = 0
       )) = 0;
END_RULE;

RULE fill_area_style_constraint FOR ( fill_area_style );
WHERE
  WR1: SIZEOF(QUERY(fas <* fill_area_style |
       NOT (SIZEOF(fas.fill_styles) = 1 )
       )) = 0;
END_RULE;

RULE fill_area_style_unique_constraint FOR (fill_area_style);

LOCAL
  r :  BAG OF fill_area_style := QUERY (r <* fill_area_style | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\fill_area_style.name ) THEN
    IF (r[i]\fill_area_style.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\fill_area_style.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE;
	
END_SCHEMA;





(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\form_features_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3415 - ISO/CD-TS 10303-1673 Form features - EXPRESS MIM
*)


SCHEMA Form_features_mim;
	USE FROM Layered_2d_shape_mim;	-- ISO/TS 10303-1693

RULE radius_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum radius length')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum radius length')
       )) = 0))) = 0;
END_RULE;

RULE step_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step depth')
       )) = 1))) = 0; 
 WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step width')
       )) = 1))) = 0; 
 WR3: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step depth')
       )) = 1))) = 0; 
 WR4: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('FORM_FEATURES_MIM.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step width')
       )) = 1))) = 0; 
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\foundation_representation_mim.exp
   ------------------------------------------------------------
*)

(* 
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $ 
ISO TC184/SC4/WG12 N3223 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2105
*) 


SCHEMA Foundation_representation_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select); 

USE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   uncertainty_measure_with_unit); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Foundation_representation_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_assignment_to_part_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3670 - ISO/CD-TS 10303-1674 Functional assignment to part - EXPRESS MIM
*)


SCHEMA Functional_assignment_to_part_mim;
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
	
ENTITY part_connected_terminals_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       SIZEOF (['FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'BARE_DIE_TERMINAL',
       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'PACKAGE_TERMINAL',
       'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
       'PACKAGED_PART_TERMINAL'] *
       TYPEOF (mct.related_shape_aspect)) = 1)) >= 2;
END_ENTITY;

RULE functional_usage_view_to_part_terminal_assignment_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'
       + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect)) AND
       (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal')
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'
       + 'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'
       + 'BARE_DIE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'
       + 'INTERCONNECT_MODULE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) OR
       ('FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.'
       + 'PACKAGED_PART_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect))
       ))) = 0;
END_RULE;

RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  fuvtpta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'functional terminal allocation'));
  futd_bag : BAG OF functional_unit_terminal_definition := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fuvtpta) by 1;
  IF EXISTS( fuvtpta[i].relating_shape_aspect ) THEN
    IF ( fuvtpta[i].relating_shape_aspect\shape_aspect.description = 
                                             'scalar terminal' ) THEN
      IF ( NOT ( fuvtpta[i].relating_shape_aspect IN futd_bag ) ) THEN
        futd_bag := futd_bag + fuvtpta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(futd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* fuvtpta | 
        ((sar.relating_shape_aspect :=: futd_bag[i]) AND
(SIZEOF(['FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'ASSEMBLY_MODULE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'BARE_DIE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'INTERCONNECT_MODULE_TERMINAL',
'FUNCTIONAL_ASSIGNMENT_TO_PART_MIM.' +
'PACKAGED_PART_TERMINAL'] * TYPEOF(sar.related_shape_aspect))>0)) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_decomposition_to_assembly_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3418 - ISO/CD-TS 10303-1675 Functional decomposition to assembly design - EXPRESS MIM
*)


SCHEMA Functional_decomposition_to_assembly_design_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649

RULE
design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  dfuataj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuataj) by 1;
  IF EXISTS( dfuataj[i].relating_product_definition ) THEN
    IF ( dfuataj[i].relating_product_definition.id = 
                         'design composition path' ) THEN
      IF ( dfuataj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuataj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_decomposition_to_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3421 - ISO/CD-TS 10303-1676 Functional decomposition to design - EXPRESS MIM
*)


SCHEMA Functional_decomposition_to_design_mim;
	USE FROM Design_management_mim;	-- ISO/TS 10303-1661
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704	

TYPE fdtd_managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON managed_design_object WITH 
	(product_definition_relationship,
	property_definition_relationship);
END_TYPE;

RULE design_functional_unit_allocation_to_assembly_component_constraint FOR
( product_definition_relationship );
WHERE
   WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
     (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
                 (NOT(
    (pdr.relating_product_definition\product_definition.description = 'design definition path')
                    AND
            (pdr.relating_product_definition.id = 'design composition path')
                 ))
               )) = 0;

   WR2: SIZEOF (QUERY (pdr <* product_definition_relationship |
   (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
     (NOT('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' +
     'COMPONENT_DEFINITION' IN TYPEOF (pdr.related_product_definition))) 
               )) = 0;
END_RULE;

RULE
design_functional_unit_allocation_to_assembly_component_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatac : BAG OF product_definition_relationship := 
QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') );
  cd_bag : BAG OF component_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatac) by 1;
  IF EXISTS( dfuatac[i].related_product_definition ) THEN
    IF( 'FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' +
'COMPONENT_DEFINITION' IN 
TYPEOF(dfuatac[i].related_product_definition) ) THEN
      IF( NOT( dfuatac[i].related_product_definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + dfuatac[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdr_bag := QUERY( pdr <* dfuatac | 
                 (pdr.related_product_definition :=: cd_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].id ) THEN
      IF ( pdr_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + pdr_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE reference_composition_path_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
           TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'reference definition path')
       AND (pdr.relating_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
  WR2: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
         TYPEOF(pdr.related_product_definition))
       AND (pdr.related_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
END_RULE;

RULE reference_functional_unit_assignment_to_part_constraint FOR
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition))
       AND ('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.'
       + 'APPLICATION_CONTEXT_ELEMENT' IN
       TYPEOF(pdr.related_product_definition.frame_of_reference))
       AND ((pdr.relating_product_definition.frame_of_reference.name
              = 'physical design')
       OR (pdr.relating_product_definition.frame_of_reference.name
              = 'physical design usage'))))) = 0; 
  WR2: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'design definition path')
       AND (pdr.relating_product_definition.id = 
         'reference composition path')
       ))) = 0; 
END_RULE;

RULE reference_functional_unit_assignment_to_part_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name =
'reference functional unit assignment to part' ) );
  d_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i]\shape_aspect_relationship.description ) THEN
    IF( NOT( sar[i]\shape_aspect_relationship.description IN d_bag ) ) THEN
      d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(d_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.description = d_bag[i]) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect.of_shape.definition ) THEN
      IF ( sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag )
                                                                    THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + 
                    sar_bag[j].related_shape_aspect.of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_decomposition_to_interconnect_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3424 - ISO/CD-TS 10303-1677 Functional decomposition to interconnect design - EXPRESS MIM
*)


SCHEMA Functional_decomposition_to_interconnect_design_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704

RULE
design_functional_unit_allocation_to_fabrication_joint_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatfj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatfj) by 1;
  IF EXISTS( dfuatfj[i].relating_product_definition ) THEN
    IF ( dfuatfj[i].relating_product_definition.id = 
                    'design composition path' ) THEN
      IF ( dfuatfj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE transmission_line_functional_unit_terminal_allocation_unique_constraint
 FOR ( shape_aspect_relationship );
LOCAL
  tlfuta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'transmission line functional terminal allocation'));
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  ut_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tlfuta) by 1;
  IF EXISTS( tlfuta[i].relating_shape_aspect ) THEN
    IF ( tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' )
                                                              THEN
      IF ( NOT ( tlfuta[i].relating_shape_aspect IN ut_bag ) ) THEN
        ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ut_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* tlfuta | 
((sar.related_shape_aspect\shape_aspect.description =
'printed component join terminal') AND 
(sar.relating_shape_aspect :=: ut_bag[i])) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_decomposition_with_nodal_representation_to_packaged_mapping_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3430 - ISO/CD-TS 10303-1678 Functional decomposition with nodal representation to packaged mapping - EXPRESS MIM
*)


SCHEMA Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755

RULE aggregate_connectivity_requirement_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  acr : BAG OF product_definition_relationship := 
                     QUERY( pdr <* product_definition_relationship |
                     (pdr\product_definition_relationship.name = 'aggregate connectivity requirement') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].related_product_definition ) THEN
    IF ( acr[i].id = 'design composition path' ) THEN
      IF ( acr[i].related_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + acr[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_specification_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3427 - ISO/CD-TS 10303-1679 Functional specification - EXPRESS MIM
*)


SCHEMA Functional_specification_mim;
	USE FROM Signal_mim;	-- ISO/TS 10303-1745
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705	
	
	USE FROM Application_context_schema(application_context_element);	

TYPE fs_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (functional_specification);
END_TYPE; 

TYPE fs_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (representation);
END_TYPE; 
	
ENTITY functional_specification
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       (rr\representation_relationship.name = 'functional characteristic category') AND
       ('FUNCTIONAL_SPECIFICATION_MIM.' +
       'EXTERNAL_DEFINITION' IN
       TYPEOF (rr.rep_1.items[1])))) = 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'characterizing signal' +
       'for functional specification')
       )) = 1;
  WR3: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       (rr\representation_relationship.name = 'reference signal for' +
        'functional specification') 
       )) = 1;
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\functional_specification)) = 0;
  WR5: SELF\representation.name = '';
  WR6: SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('FUNCTIONAL_SPECIFICATION_MIM.' +
        'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF (pdr.definition.definition)) 
        )) = 0;
END_ENTITY;
	
ENTITY functional_specification_definition
  SUBTYPE OF (functional_unit);
WHERE
  WR1: SELF.frame_of_reference\application_context_element.name =
             'functional network design';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'FUNCTIONAL_SPECIFICATION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('FUNCTIONAL_SPECIFICATION_MIM.' +
       'FUNCTIONAL_SPECIFICATION' IN TYPEOF (pdr.used_representation))
       )) > 0))) > 0;
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\functional_unit_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3433 - ISO/CD-TS 10303-1680 Functional unit requirement allocation - EXPRESS MIM
*)


SCHEMA Functional_unit_requirement_allocation_mim;
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\generic_material_aspects_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3658 - ISO/CD-TS 10303-1681 Generic material aspects - EXPRESS MIM
*)

SCHEMA Generic_material_aspects_mim;

	USE FROM Independent_property_mim;	-- ISO/TS 10303-1036
	USE FROM Independent_property_representation_mim;	-- ISO/TS 10303-1038
	USE FROM Property_assignment_mim;	-- ISO/TS 10303-1030

USE FROM material_property_definition_schema(
  material_designation,
  material_designation_characterization,
  material_property);

USE FROM material_property_representation_schema (
  data_environment,  
  material_property_representation);

ENTITY general_material_property 
SUBTYPE OF (general_property); 
WHERE 
WR1: SIZEOF( QUERY( gpa <* USEDIN(SELF,'MATERIAL_ASPECTS_MIM.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | 
  NOT ('MATERIAL_ASPECTS_MIM.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0; 
END_ENTITY; 

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\geometric_tolerance_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2877 - ISO/TS 10303-1051 Geometric tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1551
*) 


SCHEMA Geometric_tolerance_mim;

USE FROM aic_geometric_tolerances;    -- ISO 10303-519

USE FROM Derived_shape_element_mim;    -- ISO/TS 10303-1130

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation,
   shape_representation); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_qualification,
   precision_qualifier,
   type_qualifier,
   value_qualifier); 

USE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (datum_target); 

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   type_check_function); 


ENTITY placed_datum_target_feature
  SUBTYPE OF (datum_target);
DERIVE
  representation_associations : SET[0:?] OF property_definition_representation := get_shape_aspect_property_definition_representations(SELF);
WHERE
  WR1: SELF.description IN ['point','line','rectangle','circle', 'circular line'];
  WR2: SIZEOF (QUERY (pdr <* representation_associations | 'GEOMETRIC_TOLERANCE_MIM.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1;
  WR3: valid_datum_target_parameters(SELF);
END_ENTITY;

ENTITY shape_representation_with_parameters
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF( QUERY( i <* SELF.items | SIZEOF(['GEOMETRIC_TOLERANCE_MIM.PLACEMENT', 'GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM', 'GEOMETRIC_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items);
END_ENTITY;

RULE subtype_exclusiveness_geometric_tolerance FOR 
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['GEOMETRIC_TOLERANCE_MIM.ANGULARITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CIRCULAR_RUNOUT_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.COAXIALITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CONCENTRICITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CYLINDRICITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.FLATNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.LINE_PROFILE_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.PARALLELISM_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.PERPENDICULARITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.POSITION_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.ROUNDNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.STRAIGHTNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.SURFACE_PROFILE_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.SYMMETRY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.TOTAL_RUNOUT_TOLERANCE'] , 3)))) = 0;
END_RULE; 

RULE subtype_mandatory_geometric_tolerance FOR 
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['GEOMETRIC_TOLERANCE_MIM.ANGULARITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CIRCULAR_RUNOUT_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.COAXIALITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CONCENTRICITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.CYLINDRICITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.FLATNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.LINE_PROFILE_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.PARALLELISM_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.PERPENDICULARITY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.POSITION_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.ROUNDNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.STRAIGHTNESS_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.SURFACE_PROFILE_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.SYMMETRY_TOLERANCE', 'GEOMETRIC_TOLERANCE_MIM.TOTAL_RUNOUT_TOLERANCE'] , 0)))) = 0;
END_RULE; 

FUNCTION get_shape_aspect_property_definition_representations
 (s_a_instance : shape_aspect) : SET OF property_definition_representation; 
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) < 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr <* USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);      
END_FUNCTION; 

FUNCTION valid_datum_target_parameters
 (pdf : placed_datum_target_feature) : BOOLEAN; 
LOCAL

rep_set : SET OF representation := [] ;

parameter_representations: SET OF representation;
END_LOCAL;


REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
rep_set := rep_set + pdf.representation_associations[i].used_representation;
END_REPEAT;
 
parameter_representations := QUERY(rep <* rep_set |
('GEOMETRIC_TOLERANCE_MIM.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));


IF (SIZEOF( QUERY( srwp <* parameter_representations |
          (SIZEOF( QUERY( i <* srwp.items |
          (i.name='orientation') AND
          ('GEOMETRIC_TOLERANCE_MIM.PLACEMENT' IN TYPEOF(i)))) = 1))) <> 1) THEN
   RETURN(FALSE);
END_IF;

CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);

'circle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		   'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));

'line': RETURN(SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);

'rectangle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp <* parameter_representations |
               (SIZEOF( QUERY( i <* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
 		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
OTHERWISE : RETURN(FALSE);
END_CASE;
   END_FUNCTION; 

END_SCHEMA;  -- Geometric_tolerance_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\geometrically_bounded_surface_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1274 - ISO/TS 10303-1507 Geometrically bounded surface - EXPRESS MIM
*)
SCHEMA Geometrically_bounded_surface_mim;

USE FROM aic_geometrically_bounded_surface;

USE FROM Elemental_geometric_shape_mim;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\group_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3246 - ISO/TS 10303-1113 Group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2227
*) 


SCHEMA Group_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Basic_attribute_schema(
	id_attribute, 
	id_attribute_select); -- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;

END_SCHEMA;  -- Group_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\identification_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2915 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
*)

SCHEMA Identification_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment,
   identification_role); 


TYPE identification_item = EXTENSIBLE SELECT;
END_TYPE; 

TYPE versionable_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

END_SCHEMA;  -- Identification_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\incomplete_data_reference_mechanism_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO/TC184/SC4 WG12N2635 - ISO/TS 10303- incomplete_data_reference_mechanism - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12N2069 
*)

SCHEMA Incomplete_data_reference_mechanism_mim;

USE FROM Classification_assignment_mim;

USE FROM Document_definition_mim;

USE FROM File_identification_mim;

USE FROM Part_view_definition_mim;


TYPE idrm_marked_item  = EXTENSIBLE SELECT BASED_ON classification_item WITH
      (product_definition, document_file);
END_TYPE;


END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\independent_property_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
*)
SCHEMA Independent_property_mim;

USE FROM product_property_definition_schema
(general_property,
 general_property_relationship);

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\independent_property_representation_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1244 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
*)
SCHEMA Independent_property_representation_mim;

USE FROM Foundation_representation_mim;	-- ISO 10303-1006
USE FROM Independent_property_mim;

USE FROM product_property_representation_schema
  (property_definition_representation);	-- ISO 10303-41

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_2d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3436 - ISO/CD-TS 10303-1682 Interconnect 2d shape - EXPRESS MIM
*)


SCHEMA Interconnect_2d_shape_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Layered_interconnect_module_with_design_intent_modifications_mim;	-- ISO/TS 10303-1699
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724

RULE design_intent_modification_planar_position_constraint FOR
( mapped_item );
WHERE
 WR1: SIZEOF(QUERY(mi <* mapped_item |
     (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('INTERCONNECT_2D_SHAPE_MIM.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
 WR2: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
       AND (SIZEOF(QUERY(rep <* USEDIN(mi,       
       'INTERCONNECT_2D_SHAPE_MIM.'
       + 'REPRESENTATION.ITEMS') |
       SIZEOF(USEDIN(rep,
       'INTERCONNECT_2D_SHAPE_MIM.'
     + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0
       )) = 0))) = 0;
 WR3: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('INTERCONNECT_2D_SHAPE_MIM.'
       + 'AXIS2_PLACEMENT_2D' IN
      TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3439 - ISO/CD-TS 10303-1683 Interconnect 3d shape - EXPRESS MIM
*)


SCHEMA Interconnect_3d_shape_mim;
	USE FROM Interconnect_non_planar_shape_mim;	-- ISO/TS 10303-1688

RULE design_intent_modification_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'positioned design intent modification 3d shape')
       AND NOT('INTERCONNECT_3D_SHAPE_MIM.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_module_connection_routing_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3442 - ISO/CD-TS 10303-1684 Interconnect module connection routing - EXPRESS MIM
*)


SCHEMA Interconnect_module_connection_routing_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Interconnect_module_with_macros_mim;	-- ISO/TS 10303-1687
	USE FROM Layered_interconnect_module_with_design_intent_modifications_mim;	-- ISO/TS 10303-1699
	
ENTITY direct_stratum_component_join_implementation
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
SELF\direct_stratum_component_join_implementation)) = 0;
END_ENTITY;

ENTITY indirect_stratum_component_join_implementation
  SUBTYPE OF (plated_inter_stratum_feature);
END_ENTITY;

RULE junction_vertex_allocation_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation')
       AND NOT ((('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.'
        + 'LAYER_CONNECTION_POINT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.description = 'explicitly located')) OR
       (('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.'
        + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect))
       AND (sar.related_shape_aspect\shape_aspect.name = 'inter stratum join'))
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'junction vertex allocation') AND
       NOT (sar.relating_shape_aspect\shape_aspect.description = 
                        'topological junction'))) = 0;
END_RULE;

RULE junction_vertex_allocation_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  jva : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 'junction vertex allocation') );
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(jva) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF EXISTS( jva[i].relating_shape_aspect ) THEN
    IF ( jva[i].relating_shape_aspect\shape_aspect.description = 
                       'topological junction' ) THEN
      IF ( jva[i].relating_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + jva[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
(* invalid csa	
RULE physical_connectivity_abstraction_map_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  pcam : BAG OF shape_aspect_relationship := 
        QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'physical to topological abstraction map') );
  pce_bag : BAG OF physical_connectivity_element := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pcam) by 1;
  IF EXISTS( pcam[i].related_shape_aspect ) THEN
    IF ( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'PHYSICAL_CONNECTIVITY_ELEMENT' IN 
TYPEOF(pcam[i].related_shape_aspect) ) THEN
      IF ( NOT ( pcam[i].related_shape_aspect IN pce_bag )) THEN
        pce_bag := pce_bag + pcam[i].related_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pce_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  csa_bag := [];
  sar_bag := QUERY( sar <* pcam | (sar.related_shape_aspect :=: 
                 pce_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( (
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'COMPONENT_SHAPE_ASPECT' IN 
TYPEOF(sar_bag[j].relating_shape_aspect))
AND (sar_bag[j].relating_shape_aspect\shape_aspect.description IN [
'conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition']) )
                                                      THEN
      IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
        IF ( sar_bag[j].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)
RULE topological_junction_unique_constraint FOR
 ( shape_aspect );
LOCAL
  tj : BAG OF shape_aspect := 
   QUERY( r <* shape_aspect | (r\shape_aspect.description = 'topological junction'));
  sar_bag : BAG OF shape_aspect_relationship;
  s_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tj) by 1;
  sar_bag := QUERY( sar <* USEDIN( tj[i], 
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
((sar\shape_aspect_relationship.name = 'topological junction scope') AND
(('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 
'PHYSICAL_CONNECTIVITY_DEFINITION') IN
TYPEOF(sar.relating_shape_aspect)) ) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].relating_shape_aspect IN s_bag ) ) THEN
        s_bag := s_bag + sar_bag[j].relating_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( s_bag[i], 
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | 
(sar\shape_aspect_relationship.name = 'topological junction scope') );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE explicitly_located_layer_connection_point_unique_constraint FOR
 ( layer_connection_point );
LOCAL
  ellcp : BAG OF layer_connection_point := 
   QUERY( lcp <* layer_connection_point
| (lcp\shape_aspect.description = 'explicitly located') );
  s_bag : BAG OF stratum := [];
  lcp_bag : BAG OF layer_connection_point;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  cp_bag : BAG OF cartesian_point;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ellcp) by 1;
  IF EXISTS( ellcp[i].of_shape.definition ) THEN
    IF( 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) ) THEN
      IF( NOT( ellcp[i].of_shape.definition IN s_bag ) ) THEN
        s_bag := s_bag + ellcp[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cp_bag := [];
  lcp_bag := 
    QUERY( lcp <* ellcp | (lcp.of_shape.definition :=: s_bag[i]) );
  REPEAT j := 1 to SIZEOF(lcp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( lcp_bag[j], 
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := QUERY( pdr <* USEDIN( pd_bag[k],
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
((pdr.used_representation\representation.name =
'connection point location') AND (
'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' +
'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1]))) );
      REPEAT l := 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].used_representation.items[1] ) THEN
          IF ( pdr_bag[l].used_representation.items[1] IN cp_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_module_to_assembly_module_relationship_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3445 - ISO/CD-TS 10303-1685 Interconnect module to assembly module relationship - EXPRESS MIM
*)


SCHEMA Interconnect_module_to_assembly_module_relationship_mim;
	USE FROM Interconnect_module_connection_routing_mim;	-- ISO/TS 10303-1684
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

TYPE imtamr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_aspect_relationship);
END_TYPE;

TYPE imtamr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (component_definition,
      component_feature,
      descriptive_representation_item,
      representation,
      physical_component_interface_terminal,
      component_terminal,
      laminate_component_interface_terminal);
END_TYPE;

RULE component_feature_to_layout_feature_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       [
       'INTERCONNECT_MODULE_TO_ASSEMBLY_MODULE_RELATIONSHIP_MIM.'
       + 'PHYSICAL_COMPONENT_INTERFACE_TERMINAL',
       'INTERCONNECT_MODULE_TO_ASSEMBLY_MODULE_RELATIONSHIP_MIM.'
       + 'COMPONENT_TERMINAL']
       * TYPEOF(sar.relating_shape_aspect)) > 0)
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       [
       'INTERCONNECT_MODULE_TO_ASSEMBLY_MODULE_RELATIONSHIP_MIM.'
       + 'STRATUM_FEATURE']
       * TYPEOF(sar.related_shape_aspect)) > 0)
       )) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_module_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3448 - ISO/CD-TS 10303-1686 Interconnect module usage view - EXPRESS MIM
*)


SCHEMA Interconnect_module_usage_view_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705	
(**	
ENTITY library_defined_interconnect_definition
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SELF\product_definition.name = 'interconnect module';
END_ENTITY;
*)
ENTITY interconnect_definition
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'interconnect module');
  WR3: (NOT (SELF.frame_of_reference.name = 'physical design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'INTERCONNECT_DEFINITION', 
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'LIBRARY_DEFINED_INTERCONNECT_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 
       'interconnect module')
)) = 1);
END_ENTITY;

ENTITY interconnect_module_cutout_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: 'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR2: 'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('interconnect module cutout surface' = 
       ce.relating_shape_aspect\shape_aspect.description) )) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\interconnect_module_cutout_segment_surface)) = 0;
END_ENTITY;

ENTITY interconnect_module_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: 'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR2: 'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('interconnect module edge surface' = 
       ce.relating_shape_aspect\shape_aspect.description) )) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\interconnect_module_edge_segment_surface)) = 0;
END_ENTITY;

ENTITY interconnect_module_interface_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY;

ENTITY interconnect_module_terminal
  SUPERTYPE OF (interconnect_module_interface_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
  WR2: ('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 
       'physical design usage') AND
       (SELF.of_shape.definition\product_definition.name = 
       'interconnect module');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1)) >= 1; 
  WR4: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR5: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 
       'connection zone')) <= 1;
END_ENTITY;

RULE interconnect_module_surface_feature_constraint FOR
 (shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
       AND NOT (
       (sa.of_shape.definition\product_definition.name = 'interconnect module')
       AND (sa.of_shape.definition.frame_of_reference.name = 
       'physical design usage')
       AND(('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))
       OR ('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))
       OR ('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
       'LIBRARY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition)))
       ))) = 0;
END_RULE;

RULE located_interconnect_module_thickness_requirement_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  limrt : BAG OF property_definition_representation := 
QUERY( pdr <* property_definition_representation
| (pdr.definition\property_definition.name = 
 'located interconnect module thickness') AND
  ('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
  'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition)));
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF property_definition_representation;
  rr_bag : BAG OF representation_relationship;
  pass : BOOLEAN := TRUE;
  ri_bag : BAG OF representation_item;
END_LOCAL;

REPEAT i := 1 to SIZEOF(limrt) by 1;
  IF EXISTS( limrt[i].definition.definition.of_shape.definition ) THEN
    IF (('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
         'PHYSICAL_UNIT' IN
         TYPEOF(limrt[i].definition.definition.of_shape.definition)))
        THEN
      IF ( NOT ( limrt[i].definition.definition.of_shape.definition IN 
                 pu_bag )) THEN
        pu_bag := pu_bag + 
                  limrt[i].definition.definition.of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ri_bag := [];
  pdr_bag := QUERY( pdr <* limrt | 
          (pdr.definition.definition.of_shape.definition :=: 
           pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rr_bag := QUERY( rr <* USEDIN( pdr_bag[j].used_representation,
'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
'REPRESENTATION_RELATIONSHIP.REP_2' ) | 
(rr\representation_relationship.name = 'reference location') );
    REPEAT k := 1 to SIZEOF(rr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(rr_bag[k].rep_1.items) by 1;
        IF ( ('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
'AXIS2_PLACEMENT_2D' IN TYPEOF(rr_bag[k].rep_1.items[l])) OR (
'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' +
'AXIS2_PLACEMENT_3D' IN TYPEOF(rr_bag[k].rep_1.items[l])) ) THEN
          IF EXISTS( rr_bag[k].rep_1.items[l] ) THEN
            IF ( rr_bag[k].rep_1.items[l] IN ri_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ri_bag := ri_bag + rr_bag[k].rep_1.items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_module_with_macros_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3451 - ISO/CD-TS 10303-1687 Interconnect module with macros - EXPRESS MIM
*)


SCHEMA Interconnect_module_with_macros_mim;
	USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

  ENTITY interconnect_module_macro_component
    SUBTYPE OF (assembly_component);
  END_ENTITY;
	
ENTITY interconnect_module_macro_component_join_terminal
  SUBTYPE OF (physical_component_terminal);
WHERE
  WR1: NOT (SELF\shape_aspect.description IN 
       ['assembly module component terminal', 
        'bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']);
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_non_planar_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3454 - ISO/CD-TS 10303-1688 Interconnect non planar shape - EXPRESS MIM
*)


SCHEMA Interconnect_non_planar_shape_mim;
	USE FROM Layered_interconnect_module_with_design_intent_modifications_mim;	-- ISO/TS 10303-1699
	USE FROM Physical_unit_non_planar_design_view_mim;	-- ISO/TS 10303-1613
	USE FROM Part_template_2d_shape_mim;	-- ISO/TS 10303-1716

ENTITY manifold_constraining_context_dependent_shape_representation
  SUBTYPE OF (context_dependent_shape_representation, representation_relationship);
END_ENTITY; 

ENTITY shape_representation_relationship_with_transformation
  SUBTYPE OF (shape_representation_relationship, representation_relationship_with_transformation);
END_ENTITY; 
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_physical_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3457 - ISO/CD-TS 10303-1689 Interconnect physical requirement allocation - EXPRESS MIM
*)


SCHEMA Interconnect_physical_requirement_allocation_mim;
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670

ENTITY thermal_isolation_removal_template_definition
  SUBTYPE OF (part_template_definition);
(*
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'INTERCONNECT_PHYSICAL_REQUIREMENT_ALLOCATION_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
*)
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interconnect_placement_requirements_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3460 - ISO/CD-TS 10303-1690 Interconnect placement requirements - EXPRESS MIM
*)


SCHEMA Interconnect_placement_requirements_mim;
	USE FROM Assembly_component_placement_requirements_mim;	-- ISO/TS 10303-1634
	USE FROM Land_mim;	-- ISO/TS 10303-1692
	USE FROM Layered_interconnect_module_3d_shape_mim;	-- ISO/TS 10303-1697
	USE FROM Part_template_extension_mim;	-- ISO/TS 10303-1718
	
TYPE ipr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (group_shape_aspect);
END_TYPE;
	
ENTITY interconnect_module_design_object_category
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SELF\characterized_object.description IN 
       ['cutout category', 
       'fill area category', 
       'inter stratum feature category', 
       'stratum feature category', 
       'via category'];
END_ENTITY;

RULE interconnect_module_constraint_region_constraint FOR
  ( group_shape_aspect );
WHERE

  WR1: SIZEOF(QUERY(gsa <* group_shape_aspect |
       NOT(gsa\shape_aspect.description =
       'interconnect module constraint region')
       OR NOT (SIZEOF (QUERY (pd <* USEDIN (gsa,
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (('INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.' +
       'CSG_2D_SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) OR
       (pdr.used_representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 3))
       )) = 1))) = 0)
       )) = 0;
END_RULE;

RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND (SIZEOF([
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'COMPONENT_TERMINAL',
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'STRATUM_FEATURE'] * TYPEOF(sar.related_shape_aspect)
       ) = 0))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND (SIZEOF([
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'COMPONENT_TERMINAL',
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'STRATUM_FEATURE'] * TYPEOF(sar.relating_shape_aspect)
       ) = 0))) = 0;
  WR3: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'layout spacing requirement violation')
       AND NOT(SIZEOF(QUERY(grp <* USEDIN(sar,
       'INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ('INTERCONNECT_PLACEMENT_REQUIREMENTS_MIM.'
       + 'GROUP' IN TYPEOF(grp))
       AND (grp\group.name = 'layout spacing requirements property')
       )) = 1))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\interface_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3463 - ISO/CD-TS 10303-1691 Interface component - EXPRESS MIM
*)


SCHEMA Interface_component_mim;
	USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721
	
ENTITY physical_component_interface_terminal
 SUBTYPE OF (physical_component_feature);
WHERE
  WR1: SELF\shape_aspect.description IN [
       'interconnect component interface terminal',
       'packaged connector component interface terminal'];
  WR2: 'INTERFACE_COMPONENT_MIM.' +
       'COMPONENT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition);
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'INTERFACE_COMPONENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) <= 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'INTERFACE_COMPONENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design usage')) <= 1;
  WR5: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       ('INTERFACE_COMPONENT_MIM.' +
       'INTERFACE_COMPONENT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition));
  WR6: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SELF.of_shape.definition\product_definition.
        frame_of_reference.name = 
       'physical occurrence');
  WR7: (NOT (SELF\shape_aspect.description = 
       'interconnect component interface terminal')) OR
       ((SIZEOF (QUERY (sar <* USEDIN (SELF,
       'INTERFACE_COMPONENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1)
       AND 
       NOT(SELF.of_shape.definition\product_definition.description 
       IN ['assembly module component', 'bare die component',
       'interconnect module component', 'laminate component',
       'packaged component']));
  WR8: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SELF.product_definitional);
  WR9: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (('INTERFACE_COMPONENT_MIM.' +
       'PACKAGED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.description = 
       'packaged connector component') AND
       (SELF.of_shape.definition\product_definition.
       frame_of_reference.name = 
       'physical occurrence'));
 WR10: (NOT (SELF\shape_aspect.description = 
       'packaged connector component interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'INTERFACE_COMPONENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('INTERFACE_COMPONENT_MIM.' +
       'PACKAGED_PART_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'interface terminal'))) = 1);
END_ENTITY;

ENTITY interface_component_definition
  SUBTYPE OF (assembly_component);
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'INTERFACE_COMPONENT_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'INTERFACE_COMPONENT_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('INTERFACE_COMPONENT_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL' IN 
       TYPEOF (sa)) AND
       (sa\shape_aspect.description IN ['interconnect component interface terminal',
       'packaged connector component interface terminal']))) >= 1)) >= 1);
END_ENTITY;

RULE component_feature_unique_constraint FOR
 ( component_terminal, physical_component_interface_terminal );
LOCAL
  ct : BAG OF shape_aspect := 
     QUERY( ct <* component_terminal | (ct\shape_aspect.description IN 
['assembly module component terminal',
'bare die component terminal',
'interconnect component join terminal',
'interconnect module component terminal',
'interconnect module component stratum based terminal',
'minimally defined component terminal',
'packaged component join terminal']) );
  cit : BAG OF shape_aspect := 
         QUERY( cit <* physical_component_interface_terminal | (
cit\shape_aspect.description IN ['interconnect component interface terminal',
'packaged connector component interface terminal']) );
  cf : BAG OF shape_aspect;
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  def_bag : BAG OF shape_aspect;
END_LOCAL;

cf := ct + cit;
REPEAT i := 1 to SIZEOF(cf) by 1;
  IF EXISTS( cf[i].of_shape.definition ) THEN
    IF ( 'COMPONENT_FEATURE_MIM.' +
'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) ) THEN
      IF ( NOT ( cf[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + cf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  def_bag := [];
  sa_bag := QUERY( sa <* cf | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'COMPONENT_FEATURE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
             (sar\shape_aspect_relationship.name = 'instantiated feature') );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN def_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          def_bag := def_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\item_definition_structure_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO/TC184/SC4 WG12N2620 - ISO/TS 10303-1345 item_definition_structure - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12N1767
*)

SCHEMA Item_definition_structure_mim;

USE FROM Effectivity_application_mim;

USE FROM Part_occurrence_mim;

USE FROM Product_structure_mim;

REFERENCE FROM Single_part_representation_mim
	(categories_of_product);


TYPE effectivity_item_for_replacement  = SELECT BASED_ON effectivity_item WITH
  (product_definition_relationship);
END_TYPE;


RULE restrict_assembly_category FOR (product_definition);
LOCAL
  assembly_definitions: SET OF product_definition := [];
END_LOCAL;
  assembly_definitions :=  QUERY( pd <* product_definition | 
    SIZEOF( QUERY( pdca <* USEDIN( pd, 'ITEM_DEFINITION_STRUCTURE_MIM.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
    pdca.frame_of_reference.name= 'assembly definition')) > 0 );
WHERE
WR1: SIZEOF( QUERY( pd <* assembly_definitions | 
   NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
END_RULE;

RULE restrict_product_definitions_for_part_definition_relationship FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
END_RULE;

RULE product_definition_replacement_requires_effectivity_assignment FOR 
	(product_definition_relationship);
WHERE 
WR1: SIZEOF( QUERY( pdr <* product_definition_relationship | 
	(pdr.name = 'definition replacement') AND 
	(SIZEOF( USEDIN(pdr,'ITEM_DEFINITION_STRUCTURE_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
	 = 0; 
END_RULE; 

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\land_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3466 - ISO/CD-TS 10303-1692 Land - EXPRESS MIM
*)


SCHEMA Land_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698


SUBTYPE_CONSTRAINT assembly_component_subtypes FOR assembly_component;         
(ONEOF (land, connected_area_component, inter_stratum_feature)
                ANDOR (thermal_component));
END_SUBTYPE_CONSTRAINT;        
	
ENTITY land
 SUBTYPE OF (assembly_component);
WHERE
  WR1: SIZEOF (QUERY (i_f <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'definition usage') |
       'LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (i_f.relating_product_definition))) = 1;
  WR2: SIZEOF (QUERY (aud <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'alternate usage definition') |
       'LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (aud.relating_product_definition))) <= 1;
  WR3: SIZEOF (QUERY (sfi <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'stratum feature implementation') |
       'LAND_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_product_definition))) = 1;
(*
  WR4: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent land',
    'component termination passage and contact size dependent land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('LAND_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'land interface terminal')))) >= 0);
  WR5: (NOT (SELF\shape_aspect.description IN
       ['functional land', 'via dependent land',
       'via and contact size dependent land',
       'component termination passage dependent land',
       'contact size dependent land',
   'component termination passage and contact size dependent land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('LAND_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'land join terminal')))) >= 1);
  WR6: (NOT (SELF\shape_aspect.description IN
       ['via and contact size dependent non functional land',
       'component termination passage and contact size '])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('LAND_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'non functional land interface terminal')))) = 1);
  WR7: (NOT (SELF\shape_aspect.description IN
       ['non functional land', 'via dependent non functional land',
       'via and contact size dependent non functional land',
       'component termination passage dependent non functional land',
       'contact size dependent non functional land',
       'component termination passage and contact size ' + 
       'dependent non functional land',
       'unsupported passage dependent non functional land'])) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF)|
       (('LAND_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'non functional land join terminal')))) >= 1);
*)
  WR8: (NOT (SELF\product_definition.description IN
       ['component termination passage and contact size dependent land',
       'component termination passage and contact size dependent' + 
       'non functional land',
       'component termination passage dependent land',
       'component termination passage dependent non functional land'])) OR
       (SIZEOF (QUERY (rp <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'reference passage') |
       (('LAND_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (rp.relating_product_definition)) AND
       (rp.relating_product_definition\product_definition.description =
       'component termination passage')))) = 1);
 WR9: (NOT (SELF\product_definition.description IN
       ['via and contact size dependent land',
       'via and contact size dependent non functional land',
       'via dependent land', 'via dependent non functional land'])) OR
       (SIZEOF (QUERY (rv <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'reference via') |
       (('LAND_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (rv.relating_product_definition)) AND
       (rv.relating_product_definition\product_definition.description IN
       ['buried via', 'interfacial connection', 
       'bonded conductive base blind via', 'non conductive base blind via',
       'plated conductive base blind via'])))) = 1);
 WR10: (NOT (SELF\product_definition.description = 
       'unsupported passage dependent non functional land')) OR
       (SIZEOF (QUERY (rp <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'reference passage') |
       ('LAND_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (rp.relating_product_definition)) AND
       (rp.relating_product_definition\product_definition.description =
       'unsupported passage'))) = 1);
 WR11: (NOT (SELF\product_definition.description IN
       ['component termination passage dependent land',
       'component termination passage dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       (('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default component termination passage based')))) = 1);
 WR12: (NOT (SELF\product_definition.description IN
       ['component termination passage and contact size dependent land',
       'component termination passage and contact size dependent ' +
       'non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       (('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default attachment size and component termination ' +
       'passage based')))) = 1);
 WR13: (NOT (SELF\product_definition.description IN
       ['contact size dependent land',
       'contact size dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       (('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default attachment size based')))) = 1);
 WR14: (NOT (SELF\product_definition.description IN
       ['via and contact size dependent land',
       'via and contact size dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       (('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default attachment size and via based')))) = 1);
 WR15: (NOT (SELF\product_definition.description IN
       ['via dependent land',
       'via dependent non functional land'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       (('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default via based')))) = 1);
 WR16: (NOT (SELF\product_definition.description = 
       'unsupported passage dependent ' +
       'non functional land')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAND_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAND_MIM.' +
       'LAND_PHYSICAL_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'default unsupported passage based'))) = 1);
END_ENTITY;	
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_2d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3469 - ISO/CD-TS 10303-1693 Layered 2d shape - EXPRESS MIM
*)


SCHEMA Layered_2d_shape_mim;
	USE FROM Constructive_solid_geometry_2d_mim;	-- ISO/TS 10303-1731
--	USE FROM Part_template_2d_shape_mim;	-- ISO/TS 10303-1716
--	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
	USE FROM Wireframe_2d_mim; 	-- ISO/TS 10303-1347	

RULE planar_curve_constraint FOR ( shape_representation );
WHERE
WR1: SIZEOF (QUERY (sr <* shape_representation | 
(
NOT(NOT ( sr\representation.name IN ['planar projected shape',
       'bevel edge feature shape',
       'step edge feature shape',
       'radius edge feature shape']) OR
(sr\representation.
context_of_items\geometric_representation_context.
coordinate_space_dimension = 2)
))
)) = 0;
END_RULE;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3472 - ISO/CD-TS 10303-1694 Layered 3d shape - EXPRESS MIM
*)


SCHEMA Layered_3d_shape_mim;
	USE FROM Advanced_boundary_representation_mim;	-- ISO/TS 10303-1514
	USE FROM Curve_swept_solid_mim;	-- ISO/TS 10303-1659
	USE FROM Geometrically_bounded_surface_mim;	-- ISO/TS 10303-1507
	USE FROM Part_template_3d_shape_mim;	-- ISO/TS 10303-1717
--	USE FROM Part_template_non_planar_shape_mim;	-- ISO/TS 10303-1719
    USE FROM Layered_2d_shape_mim; -- -- ISO/TS 10303-1693
	USE FROM Physical_unit_3d_shape_mim;	-- ISO/TS 10303-1727
	
	USE FROM Representation_schema(representation_relationship_with_transformation);

ENTITY shape_definition_3d_intersection
  SUBTYPE OF (representation, 
              shape_representation_relationship, 
              representation_relationship_with_transformation);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
  WR2: (SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\shape_definition_3d_intersection))) = 0)  OR
       ('LAYERED_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_CROSS_SECTION' IN TYPEOF (SELF)) OR
       ('LAYERED_3D_SHAPE_MIM.' +
       'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF)) OR
       ('LAYERED_3D_SHAPE_MIM.' +
       'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF)) OR
       ('LAYERED_3D_SHAPE_MIM.' +
       'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF (SELF));
  WR3: 'LAYERED_3D_SHAPE_MIM.' +
       'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF 
       (SELF\representation_relationship_with_transformation.transformation_operator);

END_ENTITY; 
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_2d_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3478 - ISO/CD-TS 10303-1695 Layered interconnect module 2d design - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_2d_design_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726

RULE stratum_interconnect_module_planar_position_constraint FOR 
          (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 
          'planar positioned stratum shape in interconnect module')
    AND NOT('LAYERED_INTERCONNECT_MODULE_2D_DESIGN_MIM.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;

RULE stratum_planar_shape_constraint FOR (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       NOT( NOT ((sr\representation.name = 'planar projected shape') AND 
       (SIZEOF(QUERY(pdr <* USEDIN(sr,
       'LAYERED_INTERCONNECT_MODULE_2D_DESIGN_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('LAYERED_INTERCONNECT_MODULE_2D_DESIGN_MIM.'
       + 'STRATUM' IN TYPEOF(pdr.definition.definition))
       )) = 1))
       OR (SIZEOF(QUERY(a2p2d <* sr.items |
       ('LAYERED_INTERCONNECT_MODULE_2D_DESIGN_MIM.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d))
       )) >= 0)))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_3d_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3481 - ISO/CD-TS 10303-1696 Layered interconnect module 3d design - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_3d_design_mim;
	USE FROM Stratum_non_planar_shape_mim;	-- ISO/TS 10303-1748

RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = '3d positioned stratum shape in interconnect module')
       AND NOT('LAYERED_INTERCONNECT_MODULE_3D_DESIGN_MIM.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;

RULE stratum_surface_in_stratum_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'stratum surface in stratum 3d position')
       AND NOT('LAYERED_INTERCONNECT_MODULE_3D_DESIGN_MIM.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3646 - ISO/CD-TS 10303-1697 Layered interconnect module 3d shape - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_3d_shape_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

SUBTYPE_CONSTRAINT plated_inter_stratum_feature_subtypes FOR plated_inter_stratum_feature;         
  (ONEOF(plated_passage,plated_cutout_edge_segment, 
 plated_interconnect_module_edge_segment));
END_SUBTYPE_CONSTRAINT;        

ENTITY cutout_edge_segment
  SUPERTYPE OF (plated_cutout_edge_segment)
  SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
WHERE
  WR1: SELF\product_definition.description IN [
       'plated cutout edge segment',
       'cutout edge segment'];
  WR2: SIZEOF (QUERY (cc <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'composed cutout') |(
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_product_definition)) AND 
	(cc.relating_product_definition\product_definition.description  IN ['cutout',
         'physical connectivity interrupting cutout', 'plated cutout']))
       )) = 1;
  WR3: ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition));
  WR4: ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition));
  WR5: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY edge_segment_cross_section
  SUBTYPE OF (shape_definition_3d_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\shape_definition_3d_intersection || 
       SELF\edge_segment_cross_section))) = 0;
END_ENTITY; 

ENTITY interconnect_module_edge_segment
  SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect.description IN [
       'plated interconnect module edge segment', 
       'interconnect module edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 
       'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'plated interconnect module edge'))) = 1);
  WR4: (NOT (SELF\shape_aspect.description = 'interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'interconnect module edge'))) = 1);
  WR5: 'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR6: 'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR7: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY inter_stratum_feature_edge_segment_template
  SUBTYPE OF (part_template_definition,shape_aspect_relationship);
WHERE
  WR1: (SIZEOF (QUERY (ce <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'INTER_STRATUM_FEATURE_EDGE_TEMPLATE' IN
       TYPEOF (ce.relating_shape_aspect)) 
       )) = 1);
  WR2: 'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition ||
       SELF\shape_aspect_relationship ||
       SELF\inter_stratum_feature_edge_segment_template)) = 0;
END_ENTITY;

ENTITY inter_stratum_feature_edge_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\part_template_definition ||
       SELF\inter_stratum_feature_edge_template)) = 0;
  WR2: SELF\product_definition.description = 
       'inter stratum feature edge template';
END_ENTITY;

ENTITY plated_cutout_edge_segment
  SUBTYPE OF (cutout_edge_segment,plated_inter_stratum_feature);
WHERE
  WR1: SELF\shape_aspect.description IN ['plated cutout edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 'plated cutout edge segment')) OR
       (SIZEOF (QUERY (cc <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed cutout') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_shape_aspect)) AND
       (cc.relating_shape_aspect\shape_aspect.description =
       'plated cutout'))) = 1);
END_ENTITY;

ENTITY plated_interconnect_module_edge_segment
  SUBTYPE OF (interconnect_module_edge_segment,
              plated_inter_stratum_feature);
WHERE
  WR1: SELF\shape_aspect.description IN ['plated interconnect module edge segment'];
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1;
  WR3: (NOT (SELF\shape_aspect.description = 
          'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed edge') |
       ('LAYERED_INTERCONNECT_MODULE_3D_SHAPE_MIM.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_shape_aspect)) AND
       (ce.relating_shape_aspect\shape_aspect.description =
       'plated interconnect module edge'))) = 1);
END_ENTITY;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3484 - ISO/CD-TS 10303-1698 Layered interconnect module design - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_design_mim;
	USE FROM Form_features_mim;	-- ISO/TS 10303-1673
	USE FROM Interconnect_module_usage_view_mim;	-- ISO/TS 10303-1686
	USE FROM Interconnect_physical_requirement_allocation_mim;	-- ISO/TS 10303-1689
	USE FROM Part_template_2d_shape_mim;	-- ISO/TS 10303-1716
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755
	USE FROM Fill_area_mim; -- ISO/TS 10303-1672
	USE FROM Part_template_extension_mim;	-- ISO/TS 10303-1718

TYPE limd_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (stratum_concept_relationship);
END_TYPE; 

TYPE limd_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (assembly_component,
      layer,
      stratum);
END_TYPE; 

TYPE limd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (inter_stratum_feature,
      stratum,
      stratum_feature,
      stratum_surface);
END_TYPE; 

SUBTYPE_CONSTRAINT interconnect_module_terminal_subtypes FOR interconnect_module_terminal;         
  (ONEOF (interconnect_module_interface_terminal,
                      interconnect_module_join_terminal));
END_SUBTYPE_CONSTRAINT;        

ENTITY conductive_interconnect_element_terminal_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\conductive_interconnect_element_terminal_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition);
  WR8: SELF\shape_aspect_relationship.related_shape_aspect.description = 'conductive interconnect element terminal';
  WR9: SELF\shape_aspect_relationship.relating_shape_aspect.description = 'conductive interconnect element terminal';
  WR10: SELF\shape_aspect.of_shape.definition\product_definition.description = 'laminate component';
END_ENTITY; 

ENTITY connected_area_component
 SUBTYPE OF (assembly_component);
WHERE
(* invalid csa
 WR1: SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'stratum feature implementation') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (sfi.relating_shape_aspect))) = 1;
 WR2: SIZEOF (QUERY (sfi <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated layer connection point') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (sfi.relating_shape_aspect))) >= 1; *)
 WR3: SELF\product_definition.description = 'stratum feature template component';
 WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\component_definition||
       SELF\connected_area_component)) = 0;
END_ENTITY;
	
ENTITY electrical_isolation_component_definition
  SUBTYPE OF (filled_area_material_removal_component_definition);
END_ENTITY;
(**
ENTITY externally_defined_interconnect_definition
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: NOT EXISTS(SELF\product_definition.name) OR
       (SELF\product_definition.name = 'interconnect module');
END_ENTITY;
*)
ENTITY fiducial
  SUBTYPE OF (assembly_component);
WHERE
  WR1: (description = 'laminate component');
END_ENTITY;

ENTITY fiducial_stratum_feature
 SUBTYPE OF (stratum_feature);
END_ENTITY;

ENTITY filled_area_material_removal_component_definition
  SUBTYPE OF (material_removal_component_definition);
END_ENTITY;

ENTITY footprint_occurrence
  SUBTYPE OF (assembly_group_component_definition);--assembly_group_component_shape_aspect);
END_ENTITY;

ENTITY footprint_occurrence_product_definition_relationship
  SUBTYPE OF (product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: SELF\product_definition_relationship.name = 'footprint occurrence sub assembly relationship';

END_ENTITY; 

ENTITY inter_stratum_feature
 SUBTYPE OF (assembly_component);
WHERE
  WR1: SELF\product_definition.description IN ['bonded conductive base blind via', 
       'buried via', 'component termination passage', 
       'interfacial connection', 'non conductive base blind via', 
       'plated conductive base blind via', 'plated cutout', 
       'partially plated cutout', 
       'plated cutout edge segment', 
       'partially plated interconnect module edge', 
       'plated interconnect module edge segment', 
       'plated interconnect module edge', 'unsupported passage', 'cutout', 
       'physical connectivity interrupting cutout', 
       'dielectric material passage', 'cutout edge segment', 
       'interconnect module edge segment', 'interconnect module edge'];
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'feature of size') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1))) = 1;
  WR3: SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description IN
       ['inter stratum feature template',
       'via template',
       'component termination passage template',
       'unsupported passage template']))) = 1;
  WR4: (NOT (SELF\product_definition.description = 'cutout edge segment')) OR
       (SIZEOF (QUERY (cc <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'composed cutout') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (cc.relating_product_definition)) AND
       ((cc.relating_product_definition\product_definition.description =
       'cutout') OR
       (cc.relating_product_definition\product_definition.description =
       'physical connectivity interrupting cutout') OR
       (cc.relating_product_definition\product_definition.description =
       'partially plated cutout')))) = 1);
  WR5: (NOT (SELF\product_definition.description = 'interconnect module edge segment')) OR
       (SIZEOF (QUERY (ce <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'composed edge') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (ce.relating_product_definition)) AND
       ((ce.relating_product_definition\product_definition.description =
       'interconnect module edge') OR
       (ce.relating_product_definition\product_definition.description =
       'interconnect module edge')
        ))) = 1);
  WR6: (NOT (SELF\product_definition.description = 'dielectric material passage')) OR
       (SIZEOF (QUERY (pp <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'precedent passage') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE' IN
       TYPEOF (pp.relating_product_definition)) AND
       ((pp.relating_product_definition\product_definition.description =
       'cutout') OR
       (pp.relating_product_definition\product_definition.description =
       'physical connectivity interrupting cutout') OR
       (pp.relating_product_definition\product_definition.description =
       'partially plated cutout')))) = 1);
  WR7: (NOT (SELF\product_definition.description = 'dielectric material passage')) OR
       ((SIZEOF (QUERY (rp <* QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd)) |
       rp\property_definition.name = 'feature material')) <= 1) OR
       (SIZEOF (USEDIN (SELF, 
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1));
  WR8: (NOT (SELF\product_definition.description = 
       'physical connectivity interrupting cutout')) OR
       (SIZEOF (QUERY (ice <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'interrupted connectivity elements') |
       ice.relating_product_definition\product_definition.name =
       'conductive interconnect element')) >= 1);
  WR9: (NOT (SELF\product_definition.description = 'unsupported passage')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'unsupported passage template'))) = 1);
 WR10: (NOT (SELF\product_definition.description = 'cutout edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)))) = 1);
 WR11: (NOT (SELF\product_definition.description = 
       'plated cutout edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)))) = 1);
 WR12: (NOT (SELF\product_definition.description = 
       'interconnect module edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)))) = 1);
 WR13: (NOT (SELF\product_definition.description = 
       'plated interconnect module edge segment')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN
       TYPEOF (it.relating_product_definition)))) = 1);
END_ENTITY;

ENTITY interconnect_module_join_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY;

ENTITY interface_access_component_definition
  SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY interface_access_material_removal_component_definition
  SUBTYPE OF (material_removal_component_definition);
END_ENTITY;

ENTITY internal_probe_access_area
  SUBTYPE OF (probe_access_area);
END_ENTITY;

ENTITY join_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: NOT(SELF\shape_aspect.name IN ['constrained intra layer join',
       'inter stratum join', 'intra stratum join']) OR 
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (cp.related_shape_aspect))) >= 2);
  WR2: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'network topology') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PHYSICAL_NETWORK' IN
       TYPEOF (nt.relating_shape_aspect))) = 1;
  WR3: (NOT (SELF\shape_aspect.name = 'intra stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 'conductor'))) <= 1);
  WR4: (NOT (SELF\shape_aspect.name = 'intra stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 'connected filled area'))) 
       <= 1);
  WR5: (NOT (SELF\shape_aspect.name = 'inter stratum join')) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP' IN
       TYPEOF (ji.related_shape_aspect)) AND
       (ji.related_shape_aspect\shape_aspect.description = 
       'physical network supporting stratum feature conductive join')) OR
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PLATED_INTER_STRATUM_FEATURE' IN
       TYPEOF (ji.related_shape_aspect)))) <= 1);
  WR6: NOT(SELF\shape_aspect.name = 'unrouted join') OR
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'unrouted terminals') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (cp.related_shape_aspect))) >= 2);
END_ENTITY;


  ENTITY laminate_component_feature
    ABSTRACT SUPERTYPE OF (ONEOF (laminate_component_interface_terminal,
 laminate_component_join_terminal))
    SUBTYPE OF (component_feature);
  END_ENTITY;

ENTITY laminate_component_interface_terminal
  SUBTYPE OF (laminate_component_feature);
WHERE
  WR1: (NOT (SELF\shape_aspect.description IN 
       ['component termination passage interface terminal', 
       'land interface terminal', 
       'printed connector component interface terminal',
       'non functional land interface terminal'])) OR
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition));
  WR2: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature')) = 1;
(*
  WR3: (NOT (SELF\shape_aspect.description = 
       'component termination passage interface terminal')) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (associated_component(SELF))) AND
       (associated_component(SELF).description =
       'component termination passage'));
*)
  WR4: (NOT (SELF\shape_aspect.description = 
       'component termination passage interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       i_f.relating_shape_aspect\shape_aspect.description =
       'component termination passage template interface terminal')) = 1);
 WR5: (NOT (SELF\shape_aspect.description IN
       ['land interface terminal',
       'non functional land interface terminal'])) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAND_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (TRUE)))) = 1);
(*
 WR6: NOT(SELF\shape_aspect.description = 'land interface terminal') OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
(associated_component(SELF).description IN
       ['via and contact size dependent land',
       'contact size dependent land',
    'component termination passage and contact size dependent land']));
 WR7: NOT(SELF\shape_aspect.description =
       'non functional land interface terminal') OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAND' IN
       TYPEOF (associated_component(SELF))) AND
(associated_component(SELF).description IN
       ['via and contact size dependent non functional land',
       'contact size dependent non functional land',
    'component termination passage and contact size dependent non functional land']));
*)
 WR8: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (SELF.product_definitional);
 WR9: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRINTED_COMPONENT' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.description = 
       'printed connector component'));
 WR10: (NOT (SELF\shape_aspect.description = 
       'printed connector component interface terminal')) OR
       (SIZEOF (QUERY (i_f <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated feature') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (i_f.relating_shape_aspect)) AND
       (i_f.relating_shape_aspect\shape_aspect.description =
       'interface terminal'))) = 1);
 WR11: (NOT (SELF\shape_aspect.description =
       'printed connector component interface terminal')) OR
       (SIZEOF (QUERY (i <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       pdr\shape_aspect_relationship.name = 'implementation') |
       (SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE'] *
       TYPEOF (i.relating_shape_aspect)) = 1)
       )) = 1);
 WR12: ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\
        product_definition.frame_of_reference\
        application_context_element.name = 'layout occurrence');
END_ENTITY;

  ENTITY laminate_component_join_terminal
    SUBTYPE OF (laminate_component_feature,
 		component_terminal);
  END_ENTITY;

ENTITY laminate_group_component_make_from_relationship
  SUBTYPE OF (make_from_usage_option);
WHERE
  WR1: SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION'] *
       TYPEOF (SELF.relating_product_definition)) = 1;
  WR2: SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION'] *
       TYPEOF (SELF.related_product_definition)) = 1;
  WR3: SIZEOF( QUERY(pd <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        (SIZEOF( QUERY(pdr <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ((pdr.name = 'stratum mapping') AND
       (pdr.related_property_definition\property_definition.
         definition\product_definition_relationship.name = 'stratum make from')
        AND
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
        'MAKE_FROM_USAGE_OPTION' IN 
         TYPEOF(pdr.related_property_definition\property_definition.definition)))
          )) > 0) 
        )) > 0;
END_ENTITY;

ENTITY layer
 SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (ada <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'layer definition')) = 1)) <= 1;       
  WR2: ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP'
       IN TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition_relationship.name = 
                                    'inter stratum extent');
END_ENTITY;

ENTITY layer_connection_point
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
WHERE
  WR1: SELF\shape_aspect.of_shape.definition\product_definition.
       name = 'design layer';
  WR2: SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'inter stratum join')))) <= 1;
  WR3: SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'intra stratum join')))) = 1;
  WR4: NOT(
       SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'inter stratum join')))) = 1)
       OR
       (SIZEOF (QUERY (cp <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connected point') |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (cp.relating_shape_aspect)) AND 
       (cp.relating_shape_aspect.name = 'intra stratum join')))) = 1);
  WR5: (NOT (SELF\shape_aspect.description = 'dependently located')) OR
       (SIZEOF (QUERY (ado <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated design object') |
       (SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTER_STRATUM_FEATURE',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'INTERCONNECT_MODULE_TERMINAL'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) OR
       ((SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) AND
       (ado.relating_shape_aspect.description IN ['printed component join terminal',
        'embedded component terminal']))
       )) = 1);
  WR6: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'connection point location 2d') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'CARTESIAN_POINT' IN
       TYPEOF (it)) AND (it\geometric_representation_item.dim = 2 )
       )) = 1))) <= 1))) = 0);
  WR7: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'connection point location 3d') AND
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'CARTESIAN_POINT' IN
       TYPEOF (it)) AND (it\geometric_representation_item.dim = 3 )
       )) = 1))) <= 1))) = 0);
  WR8: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) AND
       ((pdr.used_representation\representation.name = 'connection point location 2d')
       OR
       (pdr.used_representation\representation.name = 'connection point location 3d'))
       )) >= 1))) = 0);
  WR9: (NOT (SELF\shape_aspect.description = 'dependently located')) OR
       (SIZEOF (QUERY (ado <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference zone') |
       (SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) OR
       ((SIZEOF (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT'] *
       TYPEOF (ado.relating_shape_aspect)) = 1) AND
       (ado.relating_shape_aspect.description IN ['connection zone']))
       )) <= 1);
END_ENTITY;

ENTITY layout_junction
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY material_removal_component_definition
  SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY multi_layer_component_definition
  SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY multi_layer_material_removal_component_definition
  SUBTYPE OF (material_removal_component_definition);
END_ENTITY;

ENTITY multi_layer_stratum_feature
 SUBTYPE OF (stratum_feature);
END_ENTITY;

ENTITY padstack_occurrence
  SUBTYPE OF (assembly_group_component_definition);--assembly_group_component_shape_aspect);
END_ENTITY;

ENTITY padstack_occurrence_product_definition_relationship
  SUBTYPE OF (property_definition, product_definition_relationship);
WHERE
--  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
--       SELF\shape_aspect_relationship.relating_shape_aspect;
--  WR2: SIZEOF(TYPEOF(SELF)) - SIZEOF(TYPEOF(SELF\property_definition ||
--       SELF\shape_aspect_relationship ||
--       SELF\padstack_occurrence_shape_aspect_relationship)) = 0;
--  WR3: SELF\shape_aspect_relationship.name = 
--        'padstack occurrence sub assembly relationship';
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: SIZEOF(TYPEOF(SELF)) - SIZEOF(TYPEOF(SELF\property_definition ||
       SELF\product_definition_relationship ||
       SELF\padstack_occurrence_product_definition_relationship)) = 0;
  WR3: SELF\product_definition_relationship.name = 
        'padstack occurrence sub assembly relationship';
END_ENTITY; 

ENTITY passage_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; 

ENTITY passage_technology
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
WHERE
  WR1: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION' IN 
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (USEDIN (SELF, 
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation')) = 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (
          {1 <= SIZEOF (pcr.used_representation.items) <= 8}
                                             ))) = 0))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items | 
       NOT (it\representation_item.name IN ['maximum aspect ratio', 'plated passage', 
       'maximum allowed component terminal extent', 
       'minimum allowed component terminal extent', 
       'maximum as finished deposition thickness',  
       'minimum as finished deposition thickness',  
       'maximum as finished passage extent', 
       'minimum as finished passage extent']))) = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'RATIO_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'maximum aspect ratio') AND
       (it\measure_with_unit.value_component > 1.0))) <= 1))) = 0))) = 0;
  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'plated passage') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1))) = 0))) = 0;
  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum as finished passage extent')
       )) <= 1))) = 0))) = 0;
  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'maximum as finished deposition thickness'))) <= 1))) = 0))) = 0;
 WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) <= 1))) = 0))) = 0;
 WR11: (NOT (SELF\shape_aspect.description IN 
       ['default component termination passage definition',
       'default via definition'])) OR 
       (SIZEOF (USEDIN (SELF, 
        'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1);
 WR12: (NOT (SELF\shape_aspect.description IN  
       ['default component termination passage definition',
       'default unsupported passage definition',
       'default via definition'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 'minimum as finished passage extent'))) 
        = 1))) = 0))) = 0);
 WR13: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) 
         = 1))) = 0))) = 0);
 WR14: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum allowed component terminal extent'))) = 1))) = 0))) = 0);
 WR15: (NOT (SELF\shape_aspect.description =
       'default component termination passage definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'maximum allowed component terminal extent'))) = 1))) = 0))) = 0);
 WR16: (NOT (SELF\shape_aspect.description = 'default via definition')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pcr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
       'physical characteristics representation') |
       NOT (SIZEOF (QUERY (it <* pcr.used_representation.items |
       (SIZEOF (
       ['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND
       (it\representation_item.name = 
       'minimum as finished deposition thickness'))) = 1))) = 0))) = 0);
 WR17: SIZEOF (QUERY (rpt <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'as finished inter stratum extent') |
       (rpt.related_shape_aspect.of_shape\property_definition.description =
       'finished stratum extent') AND
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP' 
       IN 
        TYPEOF (rpt.related_shape_aspect.of_shape\property_definition.
       definition)) 
       AND    
       (rpt.related_shape_aspect.of_shape\property_definition.
        definition\product_definition_relationship.name =
       'inter stratum extent')))) = 1;
END_ENTITY;

ENTITY physical_network
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (cr <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'connectivity requirement') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (cr.related_shape_aspect)) AND
((cr.related_shape_aspect\shape_aspect.description = 
     'component termination passage join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
                              'land join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
               'non functional land join terminal') OR
(cr.related_shape_aspect\shape_aspect.description = 
                 'printed component join terminal'))
)) >= 2;
  WR2: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'network topology') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (nt.related_shape_aspect))) >= 1;
  WR3: SIZEOF (QUERY (nt <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'reference connected terminals') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION' IN
       TYPEOF (nt.relating_shape_aspect))) <= 1;
END_ENTITY;

ENTITY plated_inter_stratum_feature
  SUPERTYPE OF (plated_passage)
  SUBTYPE OF (inter_stratum_feature);
WHERE
  WR1: (SELF\product_definition.description IN ['bonded conductive base blind via', 
        'buried via',
       'component termination passage', 'interfacial connection', 
       'non conductive base blind via', 
       'join two physical connectivity definition supporting inter stratum feature', 
       'plated conductive base blind via', 
       'plated cutout', 'plated interconnect module edge']) OR 
       (SIZEOF 
       (['LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
	'PLATED_CUTOUT_EDGE_SEGMENT',
	'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
	'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT'] * TYPEOF (SELF)) = 1 );
(* invalid csa 	
  WR2: SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) <= 1; *)
END_ENTITY;

ENTITY plated_passage 
  SUBTYPE OF (plated_inter_stratum_feature);
WHERE
  WR1: SELF\product_definition.description IN ['bonded conductive base blind via', 
       'buried via', 'component termination passage', 
       'interfacial connection', 'non conductive base blind via',
       'plated conductive base blind via'];
(* invalid csa        
  WR2: (NOT (SELF\product_definition.description = 'bonded conductive base blind via')) OR
       (SIZEOF (QUERY (fj <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'features join') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_CONCEPT_RELATIONSHIP' IN
       TYPEOF (fj.relating_shape_aspect)) AND
       (fj.relating_shape_aspect\shape_aspect.name =
       'stratum feature conductive join'))) = 1); *)
  WR3: (NOT (SELF\product_definition.description = 'component termination passage')) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'component termination passage template'))) = 1);
(*
  WR4: (NOT (SELF\shape_aspect.description = 'component termination passage')) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF) |
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'component termination passage interface terminal')))) >= 0);
  WR5: (NOT (SELF\shape_aspect.description = 'component termination passage')) OR
       (SIZEOF (QUERY (at <* associated_terminals(SELF)|
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at)) AND
       (at\shape_aspect.description =
       'component termination passage join terminal')))) >= 1);
*)
  WR6: (NOT (SELF\product_definition.description IN
       ['bonded conductive base blind via',
       'buried via',
       'interfacial connection',
       'non conductive base blind via',
       'plated conductive base blind via'])) OR
       (SIZEOF (QUERY (it <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       pdr\product_definition_relationship.name = 'instantiated template') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_product_definition)) AND
       (it.relating_product_definition\product_definition.description =
       'via template'))) = 1);
END_ENTITY;

ENTITY probe_access_area
  SUBTYPE OF (assembly_component);
WHERE
  WR1: EXISTS(SELF.of_shape.definition\product_definition.name);
(* invalid csa   
  WR2: ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.name = 'interconnect module');*)
(* invalid csa          
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description =
       'connection zone')) = 1; *)
(* invalid csa          
  WR4: SIZEOF (QUERY (pli <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'probed layout item') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (pli.related_shape_aspect))) = 1; *)
(* invalid csa          
  WR5: (NOT (SELF\shape_aspect.description = 
        'internal probe access area')) OR
       (SIZEOF (QUERY (i <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (i.relating_shape_aspect)))) = 1); *)
END_ENTITY;

ENTITY stratum
 SUBTYPE OF (product_definition);
UNIQUE
  UR1: SELF\product_definition.id, SELF\product_definition.formation;
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1;
  WR3: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'attachment region size')) = 1)) <= 1) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'stratum usage') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'EXTERNAL_DEFINITION' IN 
       TYPEOF (tu.relating_property_definition))) = 1)) <= 1);
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) <= 1))) 
       = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 
                  'planar projected shape')) <= 1))) = 0;
  WR6: SIZEOF (QUERY (acu <* QUERY (pdr <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'ASSEMBLY_COMPONENT_USAGE' IN
       TYPEOF (pdr)) |
       acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship'
       )) >= 1;
  WR7: NOT(SELF\product_definition.name = 'design layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition)) AND
       (tu.relating_property_definition.definition\characterized_object.description =
       'design layer'))) = 1)) = 1);
  WR8: NOT(SELF\product_definition.name = 'design layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAYER_CONNECTION_POINT' IN
       TYPEOF (sa))) >= 1)) >= 1);
  WR9: NOT(SELF\product_definition.name = 'documentation layer') OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition)) AND
       (tu.relating_property_definition.definition\characterized_object.description =
       'documentation layer'))) = 1)) = 1);
  WR10: NOT(SELF\product_definition.name = 'design layer') OR
       ((NOT(SELF\product_definition.description = 'primary design layer stratum') OR 
       (SIZEOF(QUERY(imps <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (imps,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF (QUERY (sar <* USEDIN (sa,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT' IN
       TYPEOF (sar.relating_shape_aspect)) AND 
        (sar.relating_shape_aspect\shape_aspect.description = 
       'interconnect module primary surface'))) >= 0)) >= 0)) = 1)) OR 
       (NOT (SELF\product_definition.description = 'non primary design layer stratum') OR
       (SIZEOF(QUERY(imps <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (imps,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       SIZEOF(QUERY (sar <* USEDIN (sa,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT' IN
       TYPEOF (sar.relating_shape_aspect)) AND
        (sar.relating_shape_aspect\shape_aspect.description =
       'interconnect module primary surface'))) >= 0)) >= 0)) = 0)));
END_ENTITY;	

ENTITY stratum_concept_relationship
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'REQUIREMENTS_PROPERTY' IN
       TYPEOF (pd))) >= 1; 
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (USEDIN (pd, 
        'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) = 1;
  WR3: (NOT (SELF\shape_aspect_relationship.name = 
       'dielectric crossover area')) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN 
       TYPEOF (SELF.relating_shape_aspect)) AND
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (SELF.related_shape_aspect)));
  WR4: (NOT (SELF\shape_aspect_relationship.name = 
       'dielectric crossover area')) OR
       (SIZEOF (QUERY (rdc <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'resulting dielectric crossover') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (rdc.relating_shape_aspect)))) = 1);
(* invalid csa        
  WR5: (NOT (SELF\shape_aspect_relationship.name = 
       'stratum feature conductive join')) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAND' IN 
       TYPEOF (SELF.relating_shape_aspect)) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.relating_shape_aspect)) AND
       (SELF.relating_shape_aspect\shape_aspect.description = 
       'stratum feature template component')));
  WR6: (NOT (SELF\shape_aspect_relationship.name = 
       'stratum feature conductive join')) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'LAND' IN 
       TYPEOF (SELF.related_shape_aspect)) OR
       (('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'COMPONENT_SHAPE_ASPECT' IN
       TYPEOF (SELF.related_shape_aspect)) AND
       (SELF.related_shape_aspect\shape_aspect.description = 
       'stratum feature template component'))); *)
  WR7: (NOT (SELF\shape_aspect_relationship.name =
       'stratum feature conductive join')) OR
       (SIZEOF (QUERY (fj <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'features join') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PLATED_PASSAGE' IN
       TYPEOF (fj.related_shape_aspect)) AND
       (fj.related_shape_aspect\shape_aspect.description =
       'bonded conductive base blind via'))) <= 1);
  WR8: (NOT ((SELF\shape_aspect.description =
       'physical network supporting stratum feature conductive join') AND
       (SELF\shape_aspect_relationship.name =
       'stratum feature conductive join'))) OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name =
       'inter stratum join'))) = 1);
END_ENTITY;

ENTITY stratum_feature
  SUPERTYPE OF (fiducial_stratum_feature)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'STRATUM' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'feature of size') AND
       (it\descriptive_representation_item.description IN 
             ['true', 'false']))) = 1)) = 1))) = 0;
  WR3: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'conductor') OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name = 
       'intra stratum join'))) = 1));
  WR4: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'connected filled area') OR
       (SIZEOF (QUERY (ji <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'join implementation') |
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
       'JOIN_SHAPE_ASPECT' IN
       TYPEOF (ji.relating_shape_aspect)) AND
       (ji.relating_shape_aspect\shape_aspect.name = 
       'intra stratum join'))) = 1));
  WR5: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'conductor') OR
       (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
  WR6: (NOT(EXISTS(SELF\shape_aspect.description))) OR
       (NOT (SELF\shape_aspect.description = 'connected filled area') OR
       (SELF\shape_aspect.of_shape.definition.name = 'design layer'));
END_ENTITY;

ENTITY stratum_specific_part_template_location_in_padstack_definition
  SUBTYPE OF (assembly_component_usage, property_definition);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\assembly_component_usage ||
       SELF\product_definition_usage ||
       SELF\product_definition_relationship ||
       SELF\stratum_specific_part_template_location_in_padstack_definition || 
       SELF\property_definition)) = 0;
  WR2: SELF\property_definition.name = '';
  WR3: SELF\property_definition.description = '';
  WR4: SELF\product_definition_relationship.name = 'part template location in padstack definition';
  WR5: SELF\product_definition_relationship.description = '';
END_ENTITY;

ENTITY stratum_surface
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SELF\shape_aspect.description IN ['primary surface',
         'secondary surface', 'average surface']; 
    WR2: 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
         'STRATUM' IN TYPEOF(SELF\shape_aspect.of_shape.definition);
END_ENTITY;

ENTITY thermal_isolation_component_definition
  SUBTYPE OF (filled_area_material_removal_component_definition);
END_ENTITY;

RULE adjacent_stratum_surface_definition_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
           'STRATUM_SURFACE' IN TYPEOF (sar.related_shape_aspect)) AND
   (sar.related_shape_aspect\shape_aspect.description IN ['secondary surface']))))) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
     'STRATUM_SURFACE' IN TYPEOF (sar.relating_shape_aspect)) AND
    (sar.relating_shape_aspect\shape_aspect.description IN ['primary surface']))))) = 0;
END_RULE;

RULE adjacent_stratum_surface_definition_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  assd : BAG OF shape_aspect_relationship := 
      QUERY( sar <* shape_aspect_relationship
| (sar\shape_aspect_relationship.description = 'adjacent stratum surface definition') );
  pass1 : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
  pss_bag : BAG OF stratum_surface := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass2 : BOOLEAN := TRUE;
  sss_bag : BAG OF stratum_surface;
END_LOCAL;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i]\shape_aspect_relationship.name ) THEN
    IF ( assd[i]\shape_aspect_relationship.name IN name_bag ) THEN
      pass1 := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i].relating_shape_aspect ) THEN
    IF ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) ) THEN
      IF( NOT( assd[i].relating_shape_aspect IN pss_bag ) ) THEN
        pss_bag := pss_bag + assd[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pss_bag) by 1;
  IF ( NOT pass2 ) THEN ESCAPE;
  END_IF;
  sss_bag := [];
  sar_bag := QUERY( sar <* assd | (sar.relating_shape_aspect :=: 
              pss_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sss_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;
(* invalid csa
RULE component_termination_passage_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  ctptt : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
((sa\shape_aspect.description = 
'component termination passage template interface terminal') OR
(sa\shape_aspect.description = 
'component termination passage template join terminal')) );
  name_bag : BAG OF STRING := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ctptt) by 1;
  IF EXISTS( ctptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ctptt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ctptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* ctptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'access mechanism') AND
('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.name = 
       'component termination passage template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)
(* invalid csa
RULE conductive_interconnect_element_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  ciet : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'conductive interconnect element terminal') );
  name_bag : BAG OF STRING := [];
  ct_bag : BAG OF component_terminal;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ciet) by 1;
  IF EXISTS( ciet[i]\shape_aspect.name ) THEN
    IF( NOT( ciet[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ciet[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ct_bag := QUERY( ct <* ciet | (ct\shape_aspect.name = name_bag[i]) );
  csa_bag := [];
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( ct_bag[j],
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | ((pdr\product_definition_relationship.name =
'associated component') AND (pdr.relating_product_definition\product_definition.description IN
['conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition'])
AND ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF( pdr_bag[k].relating_product_definition IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)
RULE default_passage_based_land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  dpblpt : BAG OF land_physical_template := 
QUERY( lpt <* land_physical_template |
(lpt\shape_aspect.description IN ['default via based',
'default attachment size and via based',
'default unsupported passage based',
'default component termination passage based',
'default attachment size and component termination passage based']) );
  sar_bag : BAG OF shape_aspect_relationship;
  pt_bag : BAG OF passage_technology := [];
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  st_bag : BAG OF stratum_technology;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpblpt) by 1;
  sar_bag := QUERY( sar <* USEDIN(dpblpt[i],
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND 
('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].related_shape_aspect IN pt_bag ) ) THEN
        pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pt_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  st_bag := [];
  sar_bag := QUERY( sar <* USEDIN(pt_bag[i],
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND (sar.relating_shape_aspect IN dpblpt)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := 
    QUERY( pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'technology usage') AND
('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'STRATUM_TECHNOLOGY' IN 
      TYPEOF(pdr.relating_property_definition.definition))) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition.definition ) THEN
        IF 
          ( pdr_bag[k].relating_property_definition.definition IN st_bag ) 
                                                                      THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          st_bag := st_bag + 
                       pdr_bag[k].relating_property_definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE inter_stratum_extent_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'inter stratum extent') AND
       NOT(('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.'
       + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND
       ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.'
       + 'STRATUM' IN TYPEOF(pdr.relating_product_definition)) 
       ))) = 0;
END_RULE;

RULE interconnect_module_stratum_assembly_relationship_constraint FOR
( assembly_component_usage );
WHERE
  WR1: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.'
       + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.'
       + 'STRATUM' IN TYPEOF(acu.related_product_definition))
       )) = 0;
END_RULE;

RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  imsar : BAG OF assembly_component_usage := 
QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(imsar) by 1;
  IF EXISTS( imsar[i].relating_product_definition ) THEN
    IF( (imsar[i].relating_product_definition.frame_of_reference.name = 
        'physical design')
AND ('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) ) THEN
      IF ( NOT ( imsar[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + imsar[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  acu_bag := 
   QUERY( acu <* imsar | (acu.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].reference_designator ) THEN
      IF ( acu_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + acu_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE internal_stratum_access_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  isa : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'internal stratum access'));
  paa_bag : BAG OF probe_access_area := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pp_bag : BAG OF plated_passage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(isa) by 1;
  IF EXISTS( isa[i].relating_shape_aspect ) THEN
    IF ( (isa[i].relating_shape_aspect\shape_aspect.description = 
'internal probe access area') AND
('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) ) THEN
      IF ( NOT ( isa[i].relating_shape_aspect IN paa_bag ) ) THEN
        paa_bag := paa_bag + isa[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(paa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pp_bag := [];
  sar_bag := QUERY( sar <* isa | ((sar.relating_shape_aspect :=: 
paa_bag[i]) AND
('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' +
'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect)) AND
(sar.related_shape_aspect\shape_aspect.description IN 
['bonded conductive base blind via',
'buried via','interfacial connection','non conductive base blind via',
'plated conductive base blind via'])) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pp_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE stratum_feature_unique_constraint FOR
 ( stratum_feature );
LOCAL
  sf_bag : BAG OF stratum_feature;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_feature) by 1;
  IF EXISTS( stratum_feature[i].of_shape.definition ) THEN
    IF( NOT( stratum_feature[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_feature[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sf_bag := QUERY( r <* stratum_feature | 
             (r.of_shape.definition :=: s_bag[i]) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sf_bag) by 1;
    IF EXISTS( sf_bag[j]\shape_aspect.name ) THEN
      IF ( sf_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sf_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE stratum_surface_unique_constraint FOR
 ( stratum_surface );
LOCAL
  ss_bag : BAG OF stratum_surface;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_surface) by 1;
  IF EXISTS( stratum_surface[i].of_shape.definition ) THEN
    IF( NOT( stratum_surface[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_surface[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ss_bag := QUERY( r <* stratum_surface | 
               (r.of_shape.definition :=: s_bag[i]) );
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(ss_bag) by 1;
    IF EXISTS( ss_bag[j]\shape_aspect.description ) THEN
      IF ( ss_bag[j]\shape_aspect.description IN desc_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE via_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  vt : BAG OF shape_aspect := 
         QUERY( r <* shape_aspect | (r\shape_aspect.description = 'via template'));
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(vt) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( vt[i],
'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.'
 + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'access mechanism') AND 
(sar.related_shape_aspect\shape_aspect.description = 
'via template terminal' )) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_with_design_intent_modifications_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3661 - ISO/CD-TS 10303-1699 Layered interconnect module with design intent modifications - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_with_design_intent_modifications_mim;
	USE FROM Assembly_component_placement_requirements_mim;	-- ISO/TS 10303-1634
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

TYPE limwdim_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_modification);
END_TYPE; 

ENTITY shape_modification
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (dim <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design intent') |
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (dim.relating_shape_aspect))) = 1;
(* invalid csa      
  WR2: (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'modification causal'))) = 1) OR
       (SIZEOF (QUERY (mcf <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'modification causal feature') |
       (SIZEOF (['LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'COMPONENT_SHAPE_ASPECT',
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'COMPONENT_TERMINAL',
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL',
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'STRATUM_FEATURE'] *
       TYPEOF (mcf.relating_shape_aspect)) = 1) OR
       ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'STRATUM' IN
       TYPEOF (mcf.relating_shape_aspect.of_shape.definition)))) = 1); *)
  WR3: (NOT (SELF\shape_aspect.description IN ['electrical isolation removal',
         'thermal isolation removal'])) OR (SIZEOF(
          QUERY ( pd <* USEDIN(SELF,
         'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
         'PROPERTY_DEFINITION.DEFINITION') | 
         (pd\property_definition.name = 'spacing requirement')  AND
         (SIZEOF(QUERY (pdr <* USEDIN(pd,
         'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
   'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|
         (pdr\property_definition_relationship.name = 'spacing requirement') AND
         ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
         'REQUIREMENTS_PROPERTY' IN
         TYPEOF(pdr.relating_property_definition)))) = 1) ))
                = 1);
  WR4: (NOT (SELF\shape_aspect.description IN ['electrical isolation removal',
       'thermal isolation removal'])) OR
       (SIZEOF (QUERY (di <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'design intent') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'STRATUM_FEATURE' IN
       TYPEOF (di.relating_shape_aspect)) AND
       (di.relating_shape_aspect\shape_aspect.description IN ['conductive filled area',
       'connected filled area']))) = 1);
  WR5: (NOT (SELF\shape_aspect.description = 'thermal isolation removal')) OR
       (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'angular orientation requirement'))) = 1);
  WR6: (NOT (SELF\shape_aspect.description = 'thermal isolation removal')) OR
       (SIZEOF (QUERY (pd<* USEDIN (SELF, 
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'REQUIREMENTS_PROPERTY' IN 
       TYPEOF (pd)) AND
       (pd\property_definition.description = 'effective current capacity requirement'))) = 1);
  WR7: (NOT (SELF\shape_aspect.description = 'material addition feature')) OR
       (SIZEOF (QUERY (dim <* QUERY (sar <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material addition shape') |
       (dim.relating_shape_aspect\shape_aspect.description =
       'material addition feature template'))) = 1);
END_ENTITY;

RULE design_intent_modification_sequence_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'shape modification sequence')
               AND
         (NOT('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
            'SHAPE_MODIFICATION' IN TYPEOF (sar.relating_shape_aspect)))
               )) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'shape modification sequence')
               AND
        (NOT('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
            'SHAPE_MODIFICATION' IN TYPEOF (sar.related_shape_aspect)))
               )) = 0;
END_RULE;

RULE design_intent_modification_sequence_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dims : BAG OF shape_aspect_relationship := 
         QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'shape modification sequence'));
  pm_bag : BAG OF shape_modification := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sm_bag : BAG OF shape_modification;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dims) by 1;
  IF EXISTS( dims[i].relating_shape_aspect ) THEN
    IF( 'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dims[i].relating_shape_aspect IN pm_bag ) ) THEN
        pm_bag := pm_bag + dims[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pm_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* dims | 
         (sar.relating_shape_aspect :=: pm_bag[i]) );
  sm_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( 'LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTENT_MODIFICATIONS_MIM.' +
'SHAPE_MODIFICATION' IN 
                     TYPEOF(sar_bag[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sm_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layered_interconnect_module_with_printed_component_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3487 - ISO/CD-TS 10303-1700 Layered interconnect module with printed component design - EXPRESS MIM
*)


SCHEMA Layered_interconnect_module_with_printed_component_design_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	
TYPE limwpcd_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (printed_component);
END_TYPE; 
	
ENTITY printed_component
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SELF.frame_of_reference.name = 'layout occurrence';
  WR2: SELF\product_definition.description = 'printed component';
(* invalid csa  
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description IN ['printed part template', 
       'printed part cross section template', 
       'printed connector template']))) = 1)) = 1))) = 0; *)
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'printed component join terminal'))) >= 1))) = 0;
  WR5: (NOT (SELF\product_definition.description = 'printed connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'LAMINATE_COMPONENT_INTERFACE_TERMINAL' IN
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 
       'printed connector component interface terminal'))) >= 1))) = 0);
(* invalid csa       
  WR6: (NOT (SELF\product_definition.description = 'printed connector component')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description = 
       'printed connector template'))) = 1)) = 1))) = 0); *)
(* invalid csa
  WR7: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |  
        SIZEOF(QUERY(sa <* USEDIN(pd, 
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') | 
        SIZEOF(QUERY(sar <* USEDIN(sa, 
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        (('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
         'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
        AND (sar\shape_aspect_relationship.name = 'stratum feature implementation')
        AND (sar.relating_shape_aspect.description = 'stratum feature template component'))
        )) >= 1
        )) >= 1 
        )) >= 1;*)
END_ENTITY;	

ENTITY printed_component_link
  SUBTYPE OF (product_definition,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: 'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition);
  WR3: 'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\printed_component_link)) = 0;
  WR5: EXISTS(SELF\product_definition.name);
  WR6: SELF\product_definition.name = '';
  WR7: SELF\product_definition_relationship.name = '';
  WR8: SIZEOF(USEDIN(SELF, 
             'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) = 1;
END_ENTITY; 

ENTITY routed_printed_component
 SUBTYPE OF (printed_component);
(* invalid csa
WHERE
  WR1: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF(QUERY(sa <* USEDIN(pd, 
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (SIZEOF(QUERY(sar <* USEDIN(sa,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
         'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))
        AND (sar.relating_shape_aspect\shape_aspect.description = 
            'printed part cross section template')
        AND (sar\shape_aspect_relationship.name = 'instantiated template')
          )) = 1)
         )) = 1)
        )) = 1; *)
(* invalid csa
  WR2: SIZEOF(QUERY(csa <* USEDIN(SELF,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
         'COMPONENT_SHAPE_ASPECT' IN TYPEOF(csa))      
         AND (SIZEOF(QUERY(sar <* USEDIN(csa, 
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (SIZEOF(QUERY(pdr <* USEDIN(sar,
       'LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('LAYERED_INTERCONNECT_MODULE_WITH_PRINTED_COMPONENT_DESIGN_MIM.' +
         'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr)) AND
        (pdr\product_definition_relationship.name = 'inter stratum extent')      
        )) = 1)
        AND (sar\shape_aspect_relationship.name = 'component extent')
        )) = 1)
        )) = 1; *)
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\layout_macro_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3490 - ISO/CD-TS 10303-1701 Layout macro definition - EXPRESS MIM
*)


SCHEMA Layout_macro_definition_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
--	USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700
--	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
--	USE FROM Printed_physical_layout_template_mim;	-- ISO/TS 10303-1737

	USE FROM Application_context_schema(application_context_element);
	
ENTITY layout_macro_component
  SUBTYPE OF (printed_component);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'layout macro component shape aspect') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |
       ('LAYOUT_MACRO_DEFINITION_MIM.' +
       'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)) = 1))) = 0;
  WR2: SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       (SIZEOF (['LAYOUT_MACRO_DEFINITION_MIM.' +
       'LAYOUT_MACRO_DEFINITION'] *
       TYPEOF (ip.relating_product_definition)) = 1)
       )) = 1;
  WR3: SELF\product_definition.description <> 'printed connector component';
END_ENTITY;

ENTITY layout_macro_definition
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['LAYOUT_MACRO_DEFINITION_MIM.' +
       'INTERCONNECT_DEFINITION', 
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'LIBRARY_DEFINED_INTERCONNECT_DEFINITION'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name = 'interconnect module')
       )) = 0;
 WR3: SELF.frame_of_reference\application_context_element.name = 'physical design';
 WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'layout macro definition shape aspect') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'floor layout view') |
       ('LAYOUT_MACRO_DEFINITION_MIM.' +
       'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)) = 1))) = 0;
END_ENTITY;

ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect_relationship ||
       SELF\layout_macro_definition_terminal_to_usage_terminal_assignment ||
       SELF\shape_aspect)) = 0;
  WR2: 'LAYOUT_MACRO_DEFINITION_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF(SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description
       IN ['component termination passage join terminal',
           'conductive interconnect element terminal',
           'land join terminal',
           'non functional land join terminal',
           'printed component join terminal',
           'via terminal'];
  WR4: SIZEOF(USEDIN(SELF, 
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')) <= 1;

END_ENTITY;

ENTITY layout_macro_floor_plan_template
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: NOT(SELF\product_definition.description IN
      ['component termination passage template',
       'component termination passage template',
       'default trace template',
       'inter stratum feature template',
       'printed connector template',
       'printed part cross section template',
       'printed part template',
       'trace template',
       'unsupported passage template',
       'via template',
       'non conductive cross section template']);
(* invalid csa       
  WR2: SIZEOF(QUERY( sar <* USEDIN(SELF,
       'LAYOUT_MACRO_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ((sar\shape_aspect_relationship.name = 'access maps') AND
      ('LAYOUT_MACRO_DEFINITION_MIM.' +
       'LAYOUT_MACRO_DEFINITION_TERMINAL_TO_USAGE_TERMINAL_ASSIGNMENT' IN
       TYPEOF (sar.relating_shape_aspect)))
       )) >=1; *)
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\management_resource_information_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3080 - ISO/TS 10303-1288 Management resource information - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2280
*) 


SCHEMA Management_resource_information_mim;

USE FROM Alias_identification_mim;    -- ISO/TS 10303-1025

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM approval_schema   -- ISO 10303-41
  (approval,
   approval_relationship,
   approval_status); 

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM certification_schema   -- ISO 10303-41
  (certification,
   certification_type); 

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM contract_schema   -- ISO 10303-41
  (contract); 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM date_time_schema   -- ISO 10303-41
  (date_role,
   date_time_role); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_role,
   organizational_project_role); 

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organization,
   organization_relationship,
   organizational_project,
   organizational_project_relationship,
   person_and_organization); 

USE FROM Project_mim;    -- ISO/TS 10303-1061

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

USE FROM security_classification_schema   -- ISO 10303-41
  (security_classification,
   security_classification_level); 


TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON aliasable_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification_level);
END_TYPE; 

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (certification, 
    contract);
END_TYPE; 

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification_level);
END_TYPE; 

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 

END_SCHEMA;  -- Management_resource_information_mim






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\manifold_subsurface_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3475 - ISO/CD-TS 10303-1702 Manifold subsurface - EXPRESS MIM
*)


SCHEMA Manifold_subsurface_mim;
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509
	USE FROM Aic_manifold_subsurface;
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\manifold_surface_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1277 - ISO/TS 10303-1509 Manifold surface - EXPRESS MIM
*)

SCHEMA Manifold_surface_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_manifold_surface;              -- ISO 10303-511 


END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\measure_representation_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1217 - ISO/TS 10303-1118 Measure representation - EXPRESS MIM
*)

SCHEMA Measure_representation_mim;

USE FROM Foundation_representation_mim;

USE FROM qualified_measure_schema
(measure_representation_item);

USE FROM representation_schema
(value_representation_item);

USE FROM Value_with_unit_mim;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\model_parameter_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3493 - ISO/CD-TS 10303-1703 Model parameter - EXPRESS MIM
*)


SCHEMA Model_parameter_mim;
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	USE FROM Classification_with_attributes_mim;	-- ISO/TS 10303-1111
	USE FROM Independent_property_representation_mim;	-- ISO/TS 10303-1038
	USE FROM Group_mim;	-- ISO/TS 10303-1113	
	
	USE FROM Specification_document_mim;	-- ISO/TS 10303-1747

TYPE mp_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
   (representation_item);
END_TYPE; 

TYPE mp_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (model_parameter);
END_TYPE; 

TYPE model_parameter_assigned_item = SELECT
     (unit);
END_TYPE;

ENTITY category_model_parameter 
 SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY model_parameter 
 SUBTYPE OF (descriptive_representation_item,group_assignment, general_property);
  items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'MODEL_PARAMETER_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
  WR2: SIZEOF (QUERY (aga <* USEDIN (SELF, 
       'MODEL_PARAMETER_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       ('MODEL_PARAMETER_MIM.' +
       'PARAMETER_TYPE' IN 
       TYPEOF (aga.assigned_group)) AND
       (aga.assigned_group\group.name IN ['string property type', 
       'logical property type', 'physical property type', 
       'boolean property type']))) = 1;
END_ENTITY;

ENTITY parameter_assignment_override
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\parameter_assignment_override))) = 0;
  WR2: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
  WR3: SELF\representation_relationship.name = '';
  WR4: SELF\representation.name = '';
  WR5: 'MODEL_PARAMETER_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_1);
  WR6: 'MODEL_PARAMETER_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_2);
END_ENTITY; 

ENTITY parameter_assignment
  SUBTYPE OF (parameter_assignment_representation, property_definition_representation);
END_ENTITY; 

ENTITY parameter_assignment_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (SELF.items) = 2;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['MODEL_PARAMETER_MIM.' +
       'MODEL_PARAMETER']) 
       = 1))) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['MODEL_PARAMETER_MIM.' +
       'COORDINATED_REPRESENTATION_ITEM']) 
       = 1))) <= 1;
  WR4: SIZEOF (QUERY (it <* SELF.items |
        (SIZEOF (QUERY(aga <* USEDIN (it,
        'MODEL_PARAMETER_MIM.' +
        'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
             (SIZEOF (TYPEOF ( aga\group_assignment.assigned_group) *
       ['MODEL_PARAMETER_MIM.' +
       'CHARACTERISTIC_TYPE']) = 1))) 
       = 1))) <= 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\parameter_assignment_representation)) = 0; 
END_ENTITY;

ENTITY product_specific_parameter_value_assignment
  SUBTYPE OF (characterized_object,
              product_related_product_category); 
WHERE
  WR1: SIZEOF(SELF\product_related_product_category.products) = 1;
  WR2: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'MODEL_PARAMETER_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.description = 
                                'assigned parameter') AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'MODEL_PARAMETER_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (
       ['MODEL_PARAMETER_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION'] *
       TYPEOF (pdr.used_representation)) = 1))) = 1))) = 1;
  WR3: NOT ('MODEL_PARAMETER_MIM.' +
       'CHARACTERIZED_PRODUCT_CATEGORY' IN
       TYPEOF(SELF));  
  WR4: SELF\characterized_object.name = SELF\product_category.name;  
END_ENTITY;

ENTITY schema_based_model_parameter 
 SUBTYPE OF (model_parameter);
END_ENTITY;

RULE model_parameter_unique_constraint FOR
 ( model_parameter );
LOCAL
  name_bag : BAG OF STRING := [];
  mp_bag : BAG OF model_parameter;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  d_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(model_parameter) by 1;
  IF EXISTS( model_parameter[i]\representation_item.name ) THEN
    IF( NOT( model_parameter[i]\representation_item.name IN name_bag ) ) THEN
      name_bag := name_bag + model_parameter[i]\representation_item.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mp_bag := QUERY( mp <* model_parameter | (mp\representation_item.name = name_bag[i]) );
  d_bag := [];
  REPEAT j := 1 to SIZEOF(mp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := USEDIN( mp_bag[j], 
'MODEL_PARAMETER_MIM.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN d_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          d_bag := d_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\multi_linguism_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3243 - ISO/TS 10303-1105 Multi linguism - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2224
*) 


SCHEMA Multi_linguism_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (attribute_classification_assignment,
   attribute_value_assignment); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (multi_language_attribute_assignment, 
    attribute_value_assignment);
END_TYPE; 


TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY language 
SUBTYPE OF (group); 
WHERE
WR1: SELF\group.name <> '';
END_ENTITY; 

ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; 

ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY; 


RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\name_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3086 - ISO/TS 10303-1340 Name assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2283
*) 


SCHEMA Name_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (name_assignment); 


TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

END_SCHEMA;  -- Name_assignment_mim






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\network_functional_design_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3340 - ISO/CD-TS 10303-1704 Network functional design view - EXPRESS MIM
*)
SCHEMA Network_functional_design_view_mim;

	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Part_occurrence_mim;	-- ISO/TS 10303-1715
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233

USE FROM Material_property_definition_schema (property_definition_relationship);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 

TYPE nfdv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (component_functional_unit);
END_TYPE; 

ENTITY bus_element_link
  SUBTYPE OF (product_definition,product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.related_product_definition,
       SELF\product_definition_relationship.relating_product_definition;
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition)) OR
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'NETWORK_NODE_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.related_product_definition));
  WR3: ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition)) OR
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'NETWORK_NODE_DEFINITION' IN
       TYPEOF (SELF\product_definition_relationship.relating_product_definition));
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\product_definition_relationship ||
       SELF\bus_element_link)) = 0;
  WR5: NOT EXISTS(SELF\product_definition.name) OR 
        (SELF\product_definition.name = '');
  WR6: SELF\product_definition_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) >= 1;
END_ENTITY; 

ENTITY bus_structural_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (bce <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'bus composition') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_ELEMENT_LINK' IN
       TYPEOF (bce.related_product_definition))) >= 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition bus assignment')) 
       <= 1)) <= 1;
  WR3: consistent_bus_structural_definition(bag_to_set(QUERY( pdr <* USEDIN(SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
END_ENTITY;

ENTITY component_functional_terminal
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'COMPONENT_FUNCTIONAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition);
  WR2: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated terminal') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'
       IN TYPEOF (it.relating_shape_aspect))) = 1;
  WR3: SIZEOF (QUERY (futba <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'functional unit terminal bus assignment') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_STRUCTURAL_DEFINITION' IN 
       TYPEOF (futba.relating_property_definition.definition))) <= 1;
  WR4: SIZEOF (QUERY (futna <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'functional unit terminal node assignment') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'NETWORK_NODE_DEFINITION' IN 
       TYPEOF (futna.relating_property_definition.definition))) <= 1;
END_ENTITY;

ENTITY component_functional_unit
  SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'functional occurrence';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'COMPONENT_FUNCTIONAL_TERMINAL' IN
       TYPEOF (sa))) >= 1)) >= 1;
  WR3: SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated functional unit') |
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (ifu.relating_product_definition))) = 1;
  WR4: SIZEOF (QUERY (nc <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'network composition') |
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (nc.relating_product_definition)) AND
       (nc.relating_product_definition.frame_of_reference.name =
       'functional network design'))) = 1;
END_ENTITY;

ENTITY network_node_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name = 'functional network design';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (funtdna <* QUERY (pdr <* USEDIN (pd,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name =
       'functional unit network terminal definition node assignment') |
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (funtdna.related_property_definition)) AND
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN 
       TYPEOF 
       (funtdna.related_property_definition.definition)))) <= 1)) <= 1;
  WR3: SIZEOF (QUERY (funn <* USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (funn.relating_product_definition)) AND
       (funn.relating_product_definition.frame_of_reference.name =
       'functional network design'))) = 1;
END_ENTITY;

RULE bus_structural_definition_unique_constraint FOR 
(bus_structural_definition, product_definition_formation, product);

LOCAL
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(bus_structural_definition) by 1;
  IF EXISTS( bus_structural_definition[i].formation.of_product.name ) THEN
    IF (bus_structural_definition[i].formation.of_product.name IN 
                                                       name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + 
bus_structural_definition[i]\product_definition.formation.of_product.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1: pass;
END_RULE;

RULE functional_unit_network_terminal_definition_bus_assignment_constraint
FOR ( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
  (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment')
       AND NOT('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'BUS_STRUCTURAL_DEFINITION' IN
       TYPEOF(pdr.relating_property_definition.definition))
       )) = 0;
  WR2: SIZEOF(QUERY(pdr <* property_definition_relationship |
  (pdr\property_definition_relationship.name = 'functional unit network terminal definition bus assignment')
       AND NOT(('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF(pdr.related_property_definition.definition))
       AND (SIZEOF(QUERY(futd <* 
                       USEDIN(pdr.related_property_definition.definition,
       'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd))
       )) > 0)))) = 0;
END_RULE;

RULE functional_unit_terminal_bus_assignment_constraint FOR
( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
       (pdr\property_definition_relationship.name = 'functional unit terminal bus assignment')
       AND NOT('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.'
       + 'BUS_STRUCTURAL_DEFINITION'
       IN TYPEOF(pdr.relating_property_definition.definition))
       )) = 0;
END_RULE;

RULE functional_unit_network_node_definition_unique_constraint FOR
 ( network_node_definition );
LOCAL
  funnd : BAG OF network_node_definition := 
 QUERY( nnd <* network_node_definition
| (nnd.frame_of_reference.name = 'functional network design') );
  name_bag : BAG OF STRING := [];
  nnd_bag : BAG OF network_node_definition;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(funnd) by 1;
  IF EXISTS( funnd[i]\product_definition.name ) THEN
    IF( NOT( funnd[i]\product_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + funnd[i]\product_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  nnd_bag := QUERY( nnd <* funnd | (nnd\product_definition.name = 
          name_bag[i]) );
  REPEAT j := 1 to SIZEOF(nnd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( nnd_bag[j], 
'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
(('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND 
                  (pdr\product_definition_relationship.name = 'functional unit network node')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE functional_unit_unique_constraint FOR
 ( component_functional_unit );
LOCAL
  fu : BAG OF component_functional_unit := 
QUERY( cfu <* component_functional_unit
| (cfu.frame_of_reference.name = 'functional occurrence') );
  id_bag : BAG OF STRING := [];
  cfu_bag : BAG OF component_functional_unit;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fu) by 1;
  IF EXISTS( fu[i].id ) THEN
    IF( NOT( fu[i].id IN id_bag ) ) THEN
      id_bag := id_bag + fu[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  cfu_bag := QUERY( cfu <* fu | (cfu.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(cfu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( cfu_bag[j], 
'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
((pdr\product_definition_relationship.name = 'network composition')
AND ('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 
'FUNCTIONAL_UNIT'
IN TYPEOF(pdr.relating_product_definition)) AND 
      (pdr.relating_product_definition.frame_of_reference.name =
       'functional network design')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

FUNCTION consistent_bus_structural_definition
     (input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;    

LOCAL  
        input : SET OF product_definition := [];
       vertex : SET OF product_definition := []; 
         edge : INTEGER := SIZEOF(input);
           vc : INTEGER := 0;
vertex_degree : INTEGER := 0;    
END_LOCAL;    
REPEAT i := 1 to SIZEOF(input_rel) BY 1;
      input := input + input_rel[i].related_product_definition;
END_REPEAT;

REPEAT i := 1 TO SIZEOF(input) BY 1;
      vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
      vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
END_REPEAT;
     vc := SIZEOF(vertex);
    IF ( vc <> ( edge + 1 )) THEN 
      RETURN(FALSE);
    END_IF;
REPEAT i := 1 TO vc BY 1;
      vertex_degree := 0;
      REPEAT j := 1 to SIZEOF(input) BY 1;
        IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
        IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
      END_REPEAT;
      IF (vertex_degree > 2) THEN
        RETURN(FALSE);
      END_IF;
END_REPEAT;    
RETURN(TRUE);  
END_FUNCTION;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\network_functional_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3343 - ISO/CD-TS 10303-1705 Network functional usage view - EXPRESS MIM
*)
SCHEMA Network_functional_usage_view_mim;

	USE FROM Analytical_model_mim;	-- ISO/TS 10303-1603
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017
	USE FROM Product_view_definition_relationship_mim;	-- ISO/TS 10303-1041

-- USE FROM Date_time_schema;

USE FROM Document_schema(document_type);
USE FROM Product_property_definition_schema
	(shape_aspect,
	shape_aspect_relationship);
USE FROM Material_property_definition_schema(property_definition_relationship);

TYPE nfuv_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (shape_aspect);
END_TYPE;

ENTITY functional_terminal_group
 SUBTYPE OF (group);
UNIQUE
   UR1: SELF\group.name;
END_ENTITY;

ENTITY functional_unit
 SUBTYPE OF (product_definition);
WHERE
  WR1: SELF.frame_of_reference.name IN ['functional design usage', 
       'functional network design'];
  WR2: (NOT ('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
   SELF\product_definition_with_associated_documents.documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR3: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) = 1; 
  WR4: SIZEOF (USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR5: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR6: SIZEOF (USEDIN (SELF, 
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR7: (NOT (SELF.frame_of_reference.name = 
                                 'functional network design')) OR
       (SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       du.relating_product_definition.frame_of_reference.name = 
       'functional design usage')) = 1);
  WR8: (NOT (SIZEOF([
        'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
            'THERMAL_NETWORK',
            'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
            'ELECTRICAL_NETWORK'] * TYPEOF(SELF)) = 1))
        OR (SELF.frame_of_reference.name = 'functional network design');
END_ENTITY;

ENTITY functional_unit_terminal_definition
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: ('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (SELF.of_shape.definition)) AND
   (SELF.of_shape.definition\product_definition.frame_of_reference.name =
       'functional design usage');
  WR2: SIZEOF (QUERY (pd2 <* QUERY (pd <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION' IN
       TYPEOF (pd)) |
       SIZEOF (QUERY (funtdba <* QUERY (pdr <* USEDIN (pd2,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition bus assignment') |
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'BUS_STRUCTURAL_DEFINITION' IN 
       TYPEOF 
       (funtdba.relating_property_definition.definition))) <= 1)) <= 1;
  WR3: SIZEOF (QUERY (pd2 <* QUERY (pd <* USEDIN (SELF,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION' IN
       TYPEOF (pd)) |
       SIZEOF (QUERY (funtdna <* QUERY (pdr <* USEDIN (pd2,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 
       'functional unit network terminal definition node assignment') |
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'NETWORK_NODE_DEFINITION' IN 
       TYPEOF 
       (funtdna.relating_property_definition.definition))) <= 1)) <= 1;
END_ENTITY;
(**
ENTITY library_defined_functional_unit
 SUBTYPE OF (externally_defined_functional_unit);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY;
*)
ENTITY make_from_functional_unit_terminal_definition_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF (['NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1;
  WR2: SIZEOF (['NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION'] *
       TYPEOF (SELF.related_shape_aspect)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
    SELF\make_from_functional_unit_terminal_definition_relationship)) = 0;
  WR4: relating_shape_aspect.of_shape :<>: 
       related_shape_aspect.of_shape;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect.description = '';
  WR7: SELF\shape_aspect.product_definitional = FALSE;
  WR8: SIZEOF (USEDIN (SELF,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION')) = 0;
  WR9: SIZEOF (QUERY( sar <* USEDIN(SELF,
       'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP') IN TYPEOF
       (sar.of_shape\property_definition.definition))
       )) = 1;
END_ENTITY;

ENTITY scalar_terminal_definition_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
UNIQUE
  UR1: related_shape_aspect, relating_shape_aspect;
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\scalar_terminal_definition_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description = 'scalar terminal';
  WR8: SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'scalar terminal';
END_ENTITY; 

RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR
 ( functional_unit_terminal_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  futd_bag : BAG OF functional_unit_terminal_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(functional_unit_terminal_definition) by 1;
  IF EXISTS( functional_unit_terminal_definition[i]\shape_aspect.name ) THEN
    IF( NOT( functional_unit_terminal_definition[i]\shape_aspect.name IN 
                                              name_bag ) ) THEN
      name_bag := name_bag + 
                    functional_unit_terminal_definition[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  futd_bag := QUERY( futd <* functional_unit_terminal_definition |
((futd\shape_aspect.name = name_bag[i]) AND
('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' +
'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition)) AND
(futd.of_shape.definition.frame_of_reference.name = 
                                    'functional design usage')) );
  REPEAT j := 1 to SIZEOF(futd_bag) by 1;
    IF EXISTS( futd_bag[j].of_shape.definition ) THEN
      IF ( futd_bag[j].of_shape.definition IN fu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        fu_bag := fu_bag + futd_bag[j].of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\non_feature_shape_element_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3496 - ISO/CD-TS 10303-1706 Non feature shape element - EXPRESS MIM
*)

SCHEMA Non_feature_shape_element_mim;
	USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
	USE FROM Extended_elemental_geometric_shape_mim;	-- ISO/TS 10303-1667
	USE FROM Part_feature_location_mim;	-- ISO/TS 10303-1714
	USE FROM Shape_property_assignment_mim;	-- ISO/TS 10303-1032

	USE FROM Material_property_definition_schema(property_definition_relationship);
	
ENTITY group_shape_aspect
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: 'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PRODUCT_DEFINITION' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition);
  WR2: NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region']) OR
       (('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (SELF\shape_aspect.of_shape.definition)) AND
       (EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name)) AND
       (NOT EXISTS(SELF\shape_aspect.of_shape.definition\product_definition.name) OR 
       (SELF\shape_aspect.of_shape.definition\product_definition.name = 'interconnect module')));
 WR3: ((NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'constrained object')
     AND (('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                    'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY') IN
                  TYPEOF(pdr.related_property_definition.definition)))
                        )) = 1)
                )) = 1));
 WR4: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'design specific purpose'))) = 1)) = 1))) = 0);
  WR5: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'keepout') AND
       (it\descriptive_representation_item.description IN ['true', 'false']))) = 1)) = 1))) = 0);
  WR6: (NOT(SELF\shape_aspect.description IN 
       ['interconnect module constraint region'])) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) = 1)) = 1);
  WR7: (NOT(SELF\shape_aspect.description IN
       ['interconnect module constraint region'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'requirement')
     AND (('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition)))
                        )) = 1)
                )) = 1);
  WR8: (NOT(SELF\shape_aspect.description = 
       'termination constraint')) OR
       (SIZEOF (QUERY (ctm <* QUERY (sar <* USEDIN (SELF,
       'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'constrained termination member') |
       ctm.related_shape_aspect\shape_aspect.description = 
       'mating connector termination')) >= 2);
  WR9: EXISTS(SELF\shape_aspect.description);
  WR10: (NOT(SELF\shape_aspect.description IN
       ['placement group'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'requirement')
     AND (('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition))
               AND
           (pdr.relating_property_definition\property_definition.name = 'requirement')))
                   ) = 1)
                )) = 1);
  WR11: (NOT(SELF\shape_aspect.description IN
       ['termination constraint'])) OR
               (SIZEOF( QUERY ( pd <* USEDIN(SELF,
            'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                         'PROPERTY_DEFINITION.DEFINITION')
                     | (SIZEOF( QUERY ( pdr <* USEDIN(pd,
           'NON_FEATURE_SHAPE_ELEMENT_MIM.' +
    'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')
                            | ((pdr\property_definition_relationship.name = 'termination usage constraint')
     AND (('NON_FEATURE_SHAPE_ELEMENT_MIM.' +
                    'REQUIREMENTS_PROPERTY') IN
                  TYPEOF(pdr.relating_property_definition))
                           AND
    (pdr.relating_property_definition\property_definition.name = 'termination usage constraint')))
                        ) = 1) 
                )) = 1);
END_ENTITY;

ENTITY reference_graphic_registration_mark
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = false;
END_ENTITY;

ENTITY seating_plane
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
         SELF\seating_plane)) = 0;
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\package_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3499 - ISO/CD-TS 10303-1707 Package - EXPRESS MIM
*)


SCHEMA Package_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Part_feature_function_mim;	-- ISO/TS 10303-1712
(** 	
ENTITY externally_defined_package
 SUBTYPE OF (externally_defined_physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
                           'registered case style')) >= 1))) = 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PACKAGE_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr)) |
       sr_pdr.used_representation\representation.name = 'seating plane')) = 1))) = 0;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) <= 1))) = 0;
  WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'PACKAGE_TERMINAL' IN 
       TYPEOF (sa))) >= 1))) = 0;
  WR6: (NOT (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package preparation') AND
       (SIZEOF (['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
END_ENTITY;
*)
ENTITY functional_orientation_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY guided_wave_terminal
   SUBTYPE OF (package_terminal);
END_ENTITY;
(**
ENTITY library_defined_package
 SUBTYPE OF (library_defined_physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  WR2: SIZEOF(USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION')) > 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'SEATING_PLANE' IN
       TYPEOF (sa))) = 1))) = 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) = 1))) <= 1;
  WR5: NOT(EXISTS(SELF\product_definition.description) AND
        (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package preparation') AND
       (SIZEOF (['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
END_ENTITY;
*)
ENTITY package
 SUBTYPE OF (physical_unit);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical design usage';
  WR2: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'PACKAGE_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'package')) > 0;
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'PACKAGE_BODY' IN 
       TYPEOF (sa))) = 1))) <= 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGE_MIM.' +
       'PACKAGE_TERMINAL' IN 
       TYPEOF (sa))) >= 1))) >= 1;
  WR5: (NOT (SELF\product_definition.description = 'altered package')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'package alteration') AND
       (SIZEOF (['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (pdr.relating_product_definition)) = 1))) = 1); 
  WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'package mounting data')) = 1))) = 1;

  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body height above seating plane')) = 1)
       )) = 1))) = 1;

  WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body height below seating plane')) = 1)
       )) = 1))) <= 1;

  WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body clearance above seating plane')) = 1)
       )) = 1))) <= 1;

  WR10: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum body clearance below seating plane')) = 1)
       )) = 1))) <= 1;

  WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'minimum body clearance above seating plane')) = 1)
       )) = 1))) <= 1;

  WR12: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'minimum body clearance below seating plane')) = 1)
       )) = 1))) <= 1;

  WR13: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'maximum lead length below seating plane')) = 1)
       )) = 1))) <= 1;

  WR14: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 'package mounting data')
       AND (SIZEOF (QUERY (item <* USEDIN( pdr.used_representation,
       'PACKAGE_MIM.' +
       'REPRESENTATION.ITEMS') | item\representation_item.name =
       'least lead length below seating plane')) = 1)
       )) = 1))) <= 1;
  WR15: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PACKAGE_MIM.' +
       'SHAPE_ASPECT' IN TYPEOF(sa)) AND
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        ((sar\shape_aspect_relationship.name = 'package seating plane') AND
        ('PACKAGE_MIM.' +
       'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect))) )) = 1))
       )) = 1)
       )
       ) = 1;

  WR16: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PACKAGE_MIM.' +
       'SEATING_PLANE' IN
       TYPEOF (sa)))) = 1))) = 1;

  WR17: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PACKAGE_MIM.' +
       'SHAPE_ASPECT' IN TYPEOF(sa)) AND
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        ((sar\shape_aspect_relationship.name = 'of datum reference plane') AND
        ('PACKAGE_MIM.' +
       'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect))) )) = 1))
       )) = 1)
       )
       ) <= 1;
 WR18: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PACKAGE_MIM.' +
       'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa))
       )) = 1)
       )
       ) <= 1;
END_ENTITY;

ENTITY package_body
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR2: SIZEOF (USEDIN (SELF, 
        'PACKAGE_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) = 1;
END_ENTITY;

ENTITY package_body_bottom_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY;

ENTITY package_body_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: 'PACKAGE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR2: 'PACKAGE_MIM.' +
       'EDGE_SEGMENT_VERTEX' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR3: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
  WR4: SIZEOF (QUERY (ce <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'composed surface') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF
       (ce.relating_shape_aspect) ))) = 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\package_body_edge_segment_surface)) = 0;
END_ENTITY;

ENTITY package_body_edge_surface
 SUBTYPE OF (package_body_surface);
WHERE
  WR1: SELF\shape_aspect.product_definitional;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\package_body_edge_surface ||
       SELF\package_body_surface)) = 0;
END_ENTITY;

ENTITY package_body_surface
ABSTRACT SUPERTYPE OF (ONEOF(package_body_top_surface,
                         package_body_edge_surface,
                         package_body_bottom_surface))
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR2: SELF\shape_aspect.product_definitional;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (TYPEOF(sar\shape_aspect_relationship.relating_shape_aspect) = 
       ['PACKAGE_MIM.' +
       'PACKAGE_BODY']))) = 1;
END_ENTITY;

ENTITY package_body_top_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY;

ENTITY package_terminal
 SUPERTYPE OF ((guided_wave_terminal ANDOR wire_terminal) 
 	ANDOR primary_reference_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PACKAGE_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR2: SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['PACKAGE_MIM.' +
       'PACKAGE',
       'PACKAGE_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGE_MIM.' +
       'LIBRARY_DEFINED_PACKAGE']) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF, 
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |(
       'PACKAGE_MIM.' +
       'PRODUCT_DEFINITION' IN TYPEOF (sar.relating_shape_aspect.of_shape.definition)) AND
       (sar\shape_aspect_relationship.name = 'terminal core material') AND
       (sar.relating_shape_aspect.of_shape.definition.
        frame_of_reference\application_context_element.name = 'material definition') 
       )) <= 1;
  WR4: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |(
       'PACKAGE_MIM.' +
       'PRODUCT_DEFINITION' IN TYPEOF (sar.relating_shape_aspect.of_shape.definition)) AND
       (sar\shape_aspect_relationship.name = 'terminal surface material') AND
       (sar.relating_shape_aspect.of_shape.definition.
        frame_of_reference\application_context_element.name = 'material definition') 
       )) = 1;
  WR5: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'PACKAGE_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
 WR6: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'external connection zone') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) >= 0;
 WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PACKAGE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'maximum terminal diametrical extent')) 
        <= 1)) <= 1)) <= 1;
 WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (lmwu <* QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PACKAGE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) |
       lmwu\representation_item.name = 'minimum terminal diametrical extent')) 
         <= 1)) <= 1)) <= 1;
 WR9: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'PACKAGE_MIM.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
 WR10: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'PACKAGE_MIM.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
 WR11: SIZEOF (QUERY (eca <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'seating plane zone') |
       'PACKAGE_MIM.' +
       'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN
       TYPEOF (eca.related_shape_aspect))) <= 1;
END_ENTITY;

RULE polarity_indication_feature_constraint FOR 
( shape_aspect);
WHERE
  WR1: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated body vertical extent')
       ) |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1) 
       ))) = 0;
  WR2: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated body vertical extent')
       ) |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1)
       ))) = 0;
  WR3: SIZEOF (QUERY ( sa <* shape_aspect | NOT(
       NOT (sa\shape_aspect.description = 'polarity indication feature') OR 
       (SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (sa,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'associated terminal')
       ) |
       ('PACKAGE_MIM.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (it.relating_shape_aspect))
       )) = 1)
       ))) = 0;
END_RULE;

ENTITY primary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
  WR1: SELF\shape_aspect.product_definitional = TRUE;
  WR2: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1;
  WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect)) 
       )) <= 1;
END_ENTITY;

ENTITY primary_reference_terminal
  SUBTYPE OF (package_terminal);
WHERE
 WR1: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'PACKAGE_MIM.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       = 0;
 WR2: SIZEOF(QUERY ( sar <* USEDIN (SELF,
      'PACKAGE_MIM.' +
      'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'precedent feaure' ))
       <= 1;
END_ENTITY;

ENTITY secondary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
 WR1:SIZEOF ((TYPEOF (SELF)) * 
      ['PACKAGE_MIM.' +
       'PRIMARY_ORIENTATION_FEATURE',
       'PACKAGE_MIM.' +
       'SEATING_PLANE',
       'PACKAGE_MIM.' +
       'VIEWING_PLANE',
       'PACKAGE_MIM.' +
       'PHYSICAL_UNIT_DATUM',
       'PACKAGE_MIM.' +
       'COMPONENT_DEFINITION']) = 0;
 WR2: SELF.product_definitional = TRUE;
 WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
 WR4: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
END_ENTITY;

ENTITY tertiary_orientation_feature
 SUBTYPE OF (physical_unit_datum_feature);
WHERE
 WR1:SIZEOF ((TYPEOF (SELF)) * 
      ['PACKAGE_MIM.' +
       'PRIMARY_ORIENTATION_FEATURE',
       'PACKAGE_MIM.' +
       'SECONDARY_ORIENTATION_FEATURE',
       'PACKAGE_MIM.' +
       'SEATING_PLANE',
       'PACKAGE_MIM.' +
       'VIEWING_PLANE',
       'PACKAGE_MIM.' +
       'PHYSICAL_UNIT_DATUM',
       'PACKAGE_MIM.' +
       'COMPONENT_DEFINITION']) = 0;
 WR2: SELF.product_definitional = TRUE;
 WR3: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_BOTTOM_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
 WR4: SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated body vertical extent') |
       ('PACKAGE_MIM.' +
       'PACKAGE_BODY_TOP_SURFACE' IN
       TYPEOF (it.relating_shape_aspect))
       )) <= 1;
END_ENTITY;

ENTITY wire_terminal
   SUBTYPE OF (package_terminal);
WHERE
WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items |
       (('PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM') IN TYPEOF (it))
       AND
       (('PACKAGE_MIM.' +
       'LENGTH_UNIT') IN
   TYPEOF (it\measure_with_unit.unit_component)))) = 2))) = 1)) )) = 0);
 WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items | (
       'PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'maximum wire terminal length')
       AND
       (('PACKAGE_MIM.' +
       'LENGTH_UNIT') IN
        TYPEOF (it\measure_with_unit.unit_component)))) = 1
                                               ))) = 1)) )) = 0);
 WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (QUERY (it <* pdr.used_representation.items | (
       'PACKAGE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM' IN TYPEOF (it)) AND
       (it\representation_item.name = 'minimum wire terminal length')
       AND
       (('PACKAGE_MIM.' +
       'LENGTH_UNIT') IN
       TYPEOF (it\measure_with_unit.unit_component)))) = 1)))
                                                     = 1)) )) = 0);
 WR4: (SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PACKAGE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'internal connection zone') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1);
END_ENTITY;

RULE package_unique_constraint FOR
 ( package); --, externally_defined_package, library_defined_package );
LOCAL
  p : BAG OF physical_unit := QUERY( r <* package |
(r.frame_of_reference.name = 'physical design usage') );
(**  edp : BAG OF physical_unit := QUERY( r <* externally_defined_package |
(r.frame_of_reference.name = 'physical design usage') );
  ldp : BAG OF physical_unit := QUERY( r <* library_defined_package |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation := [];
END_LOCAL;

pu := p; -- + edp + ldp;

REPEAT i := 1 to SIZEOF(pu) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := USEDIN( pu[i], 
'PACKAGE_MIM.' +
'PROPERTY_DEFINITION.DEFINITION' );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( pd_bag[j], 
'PACKAGE_MIM.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | 
(pdr.used_representation\representation.name =
'registered case style') );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].used_representation ) THEN
        IF ( pdr_bag[k].used_representation IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + pdr_bag[k].used_representation;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; 

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\packaged_connector_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3502 - ISO/CD-TS 10303-1708 Packaged connector model - EXPRESS MIM
*)


SCHEMA Packaged_connector_model_mim;
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
(**	
ENTITY externally_defined_packaged_connector
 SUBTYPE OF (externally_defined_packaged_part);
END_ENTITY;

ENTITY library_defined_packaged_connector
 SUBTYPE OF (library_defined_packaged_part);
END_ENTITY;
*)
ENTITY packaged_connector
  SUBTYPE OF (packaged_part);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN
       TYPEOF (sa)))) = 1))) >= 1;

  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (SIZEOF (QUERY ( sar <* USEDIN(sa,
       'PACKAGED_CONNECTOR_MODEL_MIM.' + 
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        sar\shape_aspect_relationship.name = 'interface plane')) = 1)
       )) = 1)
       )
       ) <= 1;

  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PACKAGED_CONNECTOR_MODEL_MIM.' +
       'SEATING_PLANE' IN
       TYPEOF (sa)))) = 1))) <= 1;
END_ENTITY;

ENTITY packaged_connector_terminal_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
  WR1: (SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PACKAGED_PART',
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'PACKAGED_CONNECTOR_MODEL_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART']) 
       = 1) AND
       (SELF.of_shape.definition\product_definition.description =
       'packaged connector');
  WR2: (('PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'interface terminal'));
  WR3: (('PACKAGED_CONNECTOR_MODEL_MIM.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'join terminal'));
END_ENTITY;

RULE packaged_connector_terminal_relationship_unique_constraint FOR
 ( packaged_connector_terminal_relationship );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  pctr_bag : BAG OF packaged_connector_terminal_relationship;
  it_bag : BAG OF packaged_part_terminal;
  jt_bag : BAG OF packaged_part_terminal;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(packaged_connector_terminal_relationship) by 1;
  IF EXISTS( packaged_connector_terminal_relationship[i].
                               of_shape.definition ) THEN
    IF ( 'PACKAGED_CONNECTOR_MODEL_MIM.' +
'PHYSICAL_UNIT' 
   IN TYPEOF(packaged_connector_terminal_relationship[i].
                               of_shape.definition) ) THEN
      IF ( NOT ( packaged_connector_terminal_relationship[i].
                               of_shape.definition 
                                           IN pu_bag )) THEN
        pu_bag := pu_bag + 
    packaged_connector_terminal_relationship[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  pctr_bag := QUERY( r <* packaged_connector_terminal_relationship | 
                            (r.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pctr_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass1 AND (
'PACKAGED_CONNECTOR_MODEL_MIM.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))
AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') ) THEN
      IF EXISTS( pctr_bag[j].relating_shape_aspect ) THEN
        IF ( pctr_bag[j].relating_shape_aspect IN jt_bag ) THEN
          pass1 := FALSE;
          ESCAPE;
        ELSE
          jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
    IF ( pass2 AND (
'PACKAGED_CONNECTOR_MODEL_MIM.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))
AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 
'interface terminal') ) THEN
      IF EXISTS( pctr_bag[j].related_shape_aspect ) THEN
        IF ( pctr_bag[j].related_shape_aspect IN it_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          it_bag := it_bag + pctr_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\packaged_part_black_box_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3346 - ISO/CD-TS 10303-1710 Packaged part black box model - EXPRESS MIM
*)
SCHEMA Packaged_part_black_box_model_mim;

	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Package_mim;	-- ISO/TS 10303-1707
	USE FROM Part_external_reference_mim;	-- ISO/TS 10303-1711

ENTITY packaged_part
 SUBTYPE OF (physical_unit);
WHERE 
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGED_PART_TERMINAL' IN 
       TYPEOF (sa))) >= 0))) = 0;
  WR2: SIZEOF (USEDIN (SELF, 
        'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'MATERIAL_DESIGNATION.DEFINITIONS')) <= 1;
  WR3: SIZEOF (QUERY (ifu <* QUERY (pdr <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF (ifu.relating_product_definition)) AND
       (ifu.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) <= 1;
  WR4: NOT(EXISTS(SELF\product_definition.description)) OR
       ((NOT (SELF\product_definition.description = 'altered packaged part')) OR
       (SIZEOF (QUERY (bpp <* QUERY (pdr <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'base packaged part') |
       (SIZEOF (['PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGED_PART',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] * 
       TYPEOF (bpp.relating_product_definition)) = 1) AND
       (bpp.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) >= 1));
  WR5: SIZEOF (QUERY (upkg <* QUERY (pdr <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'used package') |
       SIZEOF (['PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGE',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGE',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'LIBRARY_DEFINED_PACKAGE'] * 
       TYPEOF (upkg.relating_product_definition)) = 1)) >= 1;
  WR6: SELF.frame_of_reference.name = 'physical design usage';
END_ENTITY;

ENTITY packaged_part_terminal
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 
       'join terminal'];
  WR2: (SIZEOF (TYPEOF (SELF.of_shape.definition) *
       ['PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGED_PART',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART']) 
       = 1) AND
  (SELF.of_shape.definition\product_definition.frame_of_reference.name = 
       'physical design usage');
  WR3: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR4: SIZEOF (QUERY (top <* QUERY (sar <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'terminal of package') |
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGE_TERMINAL' IN
       TYPEOF (top.related_shape_aspect))) >= 1;
  WR5: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PART_CONNECTED_TERMINALS_DEFINITION'
       IN TYPEOF (mct.relating_shape_aspect))) <= 1;
  WR6: (NOT(SELF\shape_aspect.description = 'interface terminal')) OR
       (SIZEOF(QUERY (sar <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))
       AND (sar.relating_shape_aspect\shape_aspect.description = 
       'join terminal'))) >= 1);
  WR7: (NOT(SELF\shape_aspect.description = 'join terminal')) OR
       (SIZEOF(QUERY (sar <* USEDIN (SELF,
       'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))
       AND (sar.relating_shape_aspect\shape_aspect.description = 
        'interface terminal'))) <= 1);
END_ENTITY;

RULE packaged_part_unique_constraint FOR
 ( packaged_part); --, externally_defined_packaged_part, library_defined_packaged_part);
LOCAL
  pp : SET OF physical_unit := packaged_part; -- + externally_defined_packaged_part + library_defined_packaged_part;
  pdr_bag : BAG OF product_definition_relationship;
  pdf_bag : BAG OF product_definition_formation := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pp) by 1;
  IF ( NOT pass ) THEN ESCAPE; END_IF;
    pdf_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN( pp[i], 
'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
((pdr\product_definition_relationship.name = 'used package')
AND (('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) (** OR
('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR
('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' +
'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))  *)
) ) );
    pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
     IF ( NOT pass ) THEN ESCAPE; END_IF;
      IF EXISTS( pdr_bag[k].relating_product_definition.formation ) THEN
        IF NOT( pdr_bag[k].relating_product_definition.formation IN pdf_bag ) THEN
          pass := FALSE;
        END_IF;
      END_IF;
    END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; 

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\packaged_part_white_box_model_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3505 - ISO/CD-TS 10303-1709 Packaged part white box model - EXPRESS MIM
*)


SCHEMA Packaged_part_white_box_model_mim;
	USE FROM Bare_die_mim;	-- ISO/TS 10303-1650
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
	
ENTITY device_terminal_map
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.related_shape_aspect,
       SELF\shape_aspect_relationship.relating_shape_aspect;
WHERE
  WR1: 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
       'PACKAGED_PART_TERMINAL'
       IN TYPEOF (SELF.relating_shape_aspect);
END_ENTITY;

RULE device_terminal_map_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'device terminal map relationship')
               AND
      (NOT('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
      'DEVICE_TERMINAL_MAP' IN TYPEOF (sar.relating_shape_aspect)))
               )) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'device terminal map relationship')
               AND
    (NOT('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
       'DEVICE_TERMINAL_MAP' IN TYPEOF (sar.related_shape_aspect)))
               )) = 0;
END_RULE;

(* removed 
RULE part_device_terminal_model_port_assignment_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  amp_bag : BAG OF analytical_model_port := [];
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(property_definition_representation) by 1;
  IF EXISTS( property_definition_representation[i].used_representation )
                                                            THEN
    IF( 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'ANALYTICAL_MODEL_PORT' IN TYPEOF(
property_definition_representation[i].used_representation) ) THEN
      IF( NOT( property_definition_representation[i].used_representation IN 
                                              amp_bag ) )
                                                               THEN
        amp_bag := amp_bag + 
              property_definition_representation[i].used_representation;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(amp_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  pdr_bag := QUERY( pdr <* property_definition_representation | 
                            (pdr.used_representation :=: amp_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].definition.definition ) THEN
      IF ( pdr_bag[j].definition.definition IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + pdr_bag[j].definition.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)

RULE analytical_model_port_assignment_unique_constraint FOR
 ( property_definition_representation );
 WHERE TRUE; 
END_RULE; 

RULE part_device_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  sa_bag : BAG OF shape_aspect;
  pd_bag : BAG OF property_definition;
  sa : BAG OF bare_die_terminal;
  pass : BOOLEAN := TRUE;
  bdt_bag : BAG OF bare_die_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect) by 1;
  IF EXISTS( shape_aspect[i].of_shape.definition ) THEN
    IF( ('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
TYPEOF(shape_aspect[i].of_shape.definition)) AND
(shape_aspect[i].of_shape.definition.description = 'part device') ) THEN
      IF( NOT( shape_aspect[i].of_shape.definition IN pdr_bag ) ) THEN
        pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  bdt_bag := [];
  sa_bag := QUERY( sa <* shape_aspect | (sa.of_shape.definition :=: 
                   pdr_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := QUERY( pd <* USEDIN(
sa_bag[j].of_shape.definition.related_product_definition,
'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF([
'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'BARE_DIE'
-- ,'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'EXTERNALLY_DEFINED_BARE_DIE',
-- 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'LIBRARY_DEFINED_BARE_DIE'
] * TYPEOF(pd.definition))>0) );
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      sa := QUERY( bdt <* USEDIN(pd_bag[k],
'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'SHAPE_ASPECT.OF_SHAPE') |
('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'BARE_DIE_TERMINAL' IN TYPEOF(bdt)) );
      REPEAT l := 1 to SIZEOF(sa) by 1;
        IF EXISTS( sa[l] ) THEN
          IF ( sa[l] IN bdt_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            bdt_bag := bdt_bag + sa[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_device_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  pd : BAG OF product_definition_relationship := QUERY( pdr <*
product_definition_relationship | (pdr\product_definition_relationship.description = 'part device') );
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pd) by 1;
  IF EXISTS( pd[i].relating_product_definition ) THEN
    IF( (pd[i].relating_product_definition.frame_of_reference.name =
'physical design usage') AND (SIZEOF(
['PACKAGED_PART_WHITE_BOX_MODEL_MIM.' +
'PACKAGED_PART'
-- ,'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'EXTERNALLY_DEFINED_PACKAGED_PART',
-- 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'LIBRARY_DEFINED_PACKAGED_PART'
] * 
TYPEOF(pd[i].relating_product_definition))>0) ) THEN
      IF( NOT( pd[i].relating_product_definition IN pu_bag ) ) THEN
        pu_bag := pu_bag + pd[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  pdr_bag := QUERY( pdr <* pd | (pdr.relating_product_definition :=: 
                                                       pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j]\product_definition_relationship.name ) THEN
      IF ( pdr_bag[j]\product_definition_relationship.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_and_version_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2522 - ISO/TS 10303-1022 Part and version identification - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1115
*) 


SCHEMA Part_and_version_identification_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018


END_SCHEMA;  -- Part_and_version_identification_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_definition_relationship_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1327 - ISO/TS 10303-1055 Part definition relationship - EXPRESS MIM
*)
   
SCHEMA Part_definition_relationship_mim;

USE FROM Part_view_definition_mim;
USE FROM Product_view_definition_relationship_mim;
USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM product_structure_schema
	(make_from_usage_option);

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_external_reference_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3508 - ISO/CD-TS 10303-1711 Part external reference - EXPRESS MIM
*)


SCHEMA Part_external_reference_mim;
	USE FROM Physical_layout_template_mim;	-- ISO/TS 10303-1722

RULE package_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('PART_EXTERNAL_REFERENCE_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('PART_EXTERNAL_REFERENCE_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('PART_EXTERNAL_REFERENCE_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('PART_EXTERNAL_REFERENCE_MIM.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
END_RULE;

RULE package_terminal_external_reference_constraint FOR
  (descriptive_representation_item);
WHERE
  WR1: SIZEOF(QUERY(dri <* descriptive_representation_item |
       (dri\representation_item.name = 'package terminal external reference')
       AND (SIZEOF(QUERY(rep <* USEDIN(dri,
       'PART_EXTERNAL_REFERENCE_MIM.'
       + 'REPRESENTATION.ITEMS') |
       (rep\representation.name = 'package external reference'))) = 0)
       )) = 0;
END_RULE;

RULE package_terminal_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  pter : BAG OF descriptive_representation_item := 
                QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'package terminal external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  IF EXISTS( pter[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( pter[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* pter | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'PART_EXTERNAL_REFERENCE_MIM.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'package external reference') );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_terminal_external_reference_unique_constraint FOR
 ( representation );
LOCAL
  pter : BAG OF representation := QUERY( r <* representation |
(r\representation.name = 'part terminal external reference'));
  fn_bag : BAG OF STRING := [];
  ft_bag : BAG OF STRING := [];
  r_bag : BAG OF representation;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  REPEAT j := 1 to SIZEOF(pter[i].items) by 1;
    IF ( 'PART_EXTERNAL_REFERENCE_MIM.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pter[i].items[j]) ) THEN
      IF ( (pter[i].items[j]\representation_item.name = 'feature name') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                                                  IN fn_bag )) ) THEN
        fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
      IF ( (pter[i].items[j]\representation_item.name = 'feature type') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                 IN ft_bag )) ) THEN
        ft_bag := ft_bag + 
        pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fn_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(ft_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    r_bag := QUERY( r <* pter | ((SIZEOF(
QUERY(ri <* r.items | ((ri\descriptive_representation_item.description =
ft_bag[j]) AND (ri\representation_item.name = 'feature type')) ) )>0) AND 
(SIZEOF(QUERY(ri <* r.items |
((ri\descriptive_representation_item.description = fn_bag[i]) AND 
         (ri\representation_item.name = 'feature name')) ) )>0)) );
    ptd_bag := [];
    REPEAT k := 1 to SIZEOF(r_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := USEDIN( r_bag[k], 
'PART_EXTERNAL_REFERENCE_MIM.' +
'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION' );
      REPEAT l:= 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].definition.definition ) THEN
          IF ( 'PART_EXTERNAL_REFERENCE_MIM.' +
'PHYSICAL_UNIT' IN TYPEOF( pdr_bag[l].definition.definition ) ) THEN
            IF ( pdr_bag[l].definition.definition IN ptd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_feature_function_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3511 - ISO/CD-TS 10303-1712 Part feature function - EXPRESS MIM
*)


SCHEMA Part_feature_function_mim;
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732

ENTITY fiducial_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

ENTITY part_interface_access_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PART_FEATURE_FUNCTION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'interface_access area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY;

ENTITY part_mating_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PART_FEATURE_FUNCTION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'mating area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY;

ENTITY part_mounting_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PART_FEATURE_FUNCTION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name  = 'mounting area') AND
       (sar.related_shape_aspect\shape_aspect.description = 'connection zone'))) = 1;
END_ENTITY;

ENTITY part_tooling_feature
 SUPERTYPE OF (ONEOF(fiducial_part_feature,
               tool_registration_mark) ANDOR 
               test_point_part_feature)
 SUBTYPE OF (shape_aspect);
WHERE
 WR1: SELF\shape_aspect.product_definitional = true;
END_ENTITY;

ENTITY test_point_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

ENTITY thermal_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY tool_registration_mark
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_feature_grouping_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3514 - ISO/CD-TS 10303-1713 Part feature grouping - EXPRESS MIM
*)


SCHEMA Part_feature_grouping_mim;
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
--	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
	USE FROM Shape_aspect_definition_schema(composite_shape_aspect);
	
ENTITY composite_array_shape_aspect
  SUPERTYPE OF (ONEOF( linear_composite_array_shape_aspect,
                 rectangular_composite_array_shape_aspect))
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'PART_FEATURE_GROUPING_MIM.' +
       'SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'PART_FEATURE_GROUPING_MIM.' +
       'SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\composite_array_shape_aspect_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'PART_FEATURE_GROUPING_MIM.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; 

ENTITY linear_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY;

ENTITY linear_composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'PART_FEATURE_GROUPING_MIM.' +
       'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'PART_FEATURE_GROUPING_MIM.' +
       'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\linear_composite_array_shape_aspect_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SIZEOF(USEDIN(SELF, 
             'PART_FEATURE_GROUPING_MIM.' +
             'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) = 1;
END_ENTITY; 

ENTITY rectangular_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_feature_location_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3517 - ISO/CD-TS 10303-1714 Part feature location - EXPRESS MIM
*)


SCHEMA Part_feature_location_mim;
	USE FROM Extended_elemental_geometric_shape_mim;	-- ISO/TS 10303-1667
--	USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_occurrence_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3649 - ISO/CD-TS 10303-1715 Part occurrence - EXPRESS MIM
*)


SCHEMA Part_occurrence_mim;
	USE FROM Assembly_structure_mim;	-- ISO/TS 10303-1026
	USE FROM Extended_measure_representation_mim;	-- ISO/TS 10303-1106
	USE FROM Measure_representation_mim;	-- ISO/TS 10303-1118
	USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
	USE FROM Product_view_definition_relationship_mim;	-- ISO/TS 10303-1041
	USE FROM Value_with_unit_mim;	-- ISO/TS 10303-1054

USE FROM product_property_definition_schema(
	characterized_product_definition,
	property_definition);

USE FROM product_property_representation_schema(
	property_definition_representation);
	
USE FROM product_structure_schema
	(product_definition_occurrence_relationship,
	quantified_assembly_component_usage);


TYPE product_definition_or_assembly_relationship = SELECT (assembly_component_usage, product_definition);
END_TYPE;
	
RULE restrict_part_occurrence FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := [];
END_LOCAL;
  part_occurrences := QUERY(pd <* product_definition | 
	( pd.frame_of_reference.name = 'part occurrence' ));
WHERE
WR1: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( NOT( pd.name IN 
['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
WR2: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	(SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
'PART_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	pdr.name = 'definition usage' ) ) <>1 ) AND 
	( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
	( cd.name = 'occurrence usage definition' ) AND 
	( NOT ('PART_OCCURRENCE_MIM.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
WR3: SIZEOF ( QUERY ( pd <* part_occurrences |  
	(SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
 	( 'PART_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
 	( SIZEOF ( USEDIN ( pd , 'PART_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
WR4: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'selected instance' ) AND 
	NOT valid_selected_instance_representation(pd) ))=0;
WR5: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	( pd.name = 'quantified instance' ) AND 
	( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION.DEFINITION' ) |
 	( ppd.name ='occurrence quantity' ) AND 
	( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'PART_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
	pdr.used_representation.name = 'quantity' ) AND 
	(SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
 	(SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
	('PART_OCCURRENCE_MIM.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
	( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
WR6: SIZEOF ( QUERY ( pd <* part_occurrences | 
	( pd.name = 'specified instance' ) AND 
	( SIZEOF ( QUERY (
pdor <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
  'PART_OCCURRENCE_MIM.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
END_RULE;
	
RULE restrict_part_occurrence_category FOR (product_definition);
LOCAL
  part_occurrences: SET OF product_definition := [];
END_LOCAL;
  part_occurrences :=  QUERY( pd <* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));
WHERE
WR1: SIZEOF( QUERY( pd <* part_occurrences | 
(SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'PRODUCT_OCCURRENCE_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
  prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
END_RULE;
	
RULE selected_instance_usage_requires_representation FOR
    (assembly_component_usage);
LOCAL
  selected_instance_usages: SET OF assembly_component_usage := [];
END_LOCAL;
  selected_instance_usages:=  QUERY( acr <* assembly_component_usage|
		(acr.name = 'selected instance usage'));
WHERE
WR1: SIZEOF ( QUERY ( acr <* selected_instance_usages | 
	NOT valid_selected_instance_representation(acr) ))=0;
END_RULE;
	
RULE restrict_product_definitions_for_definition_usage FOR
    (product_definition_relationship);
WHERE
WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
     ( pdr.name = 'definition usage' ) AND 
	( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
	( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
END_RULE;
	
FUNCTION valid_selected_instance_representation (pd: product_definition_or_assembly_relationship): LOGICAL;
LOCAL
  properties: SET OF property_definition :=[];
  property_definition_representations: SET OF property_definition_representation :=[];
  selected_representation: representation;
END_LOCAL;

properties :=QUERY( prd<* USEDIN ( pd ,'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION' ) | 
 (prd.name = 'occurrence selection' ));
IF (SIZEOF( properties)<>1) THEN
	RETURN(FALSE);
END_IF;

property_definition_representations := QUERY ( pdr <* USEDIN ( properties[1] , 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	( pdr.used_representation.name = 'selection criteria' ));
IF (SIZEOF(property_definition_representations)<>1) THEN
	RETURN(FALSE);
END_IF;

selected_representation := property_definition_representations[1].used_representation;

IF (SIZEOF(selected_representation.items) <1) OR (SIZEOF(selected_representation.items) >2) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( SIZEOF (['PRODUCT_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM' ,
			'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
 	( i.name = 'selection quantity' ))) <> 1 ) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( 'PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	( i.name = 'selection control' )))> 1) THEN
	RETURN(FALSE);
END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
	( 'PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
 	( i.name = 'selection control' ) ))= 0) AND 
   (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['PRODUCT_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM' ,
		'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	RETURN(FALSE);
END_IF;
	
RETURN(TRUE);
END_FUNCTION;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_template_2d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3520 - ISO/CD-TS 10303-1716 Part template 2d shape - EXPRESS MIM
*)


SCHEMA Part_template_2d_shape_mim;
	USE FROM Component_grouping_mim;	-- ISO/TS 10303-1656
	USE FROM Package_mim;	-- ISO/TS 10303-1707
	USE FROM Part_template_extension_mim;	-- ISO/TS 10303-1718
	USE FROM Printed_physical_layout_template_mim;	-- ISO/TS 10303-1737
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
	
ENTITY design_layer_type_specific_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; 

ENTITY footprint_definition
 SUBTYPE OF (part_template_definition);
WHERE
  WR1: (NOT ('PART_TEMPLATE_2D_SHAPE_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\footprint_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['layout design usage' ];
  WR8: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'template model')) = 1;
END_ENTITY;

ENTITY padstack_definition
 SUPERTYPE OF (ONEOF( design_layer_type_specific_padstack_definition,
               stratum_type_independent_padstack_definition))
 SUBTYPE OF (part_template_definition);
WHERE
  WR1: (NOT ('PART_TEMPLATE_2D_SHAPE_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\padstack_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['layout design usage' ];
  WR9: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'PART_TEMPLATE_2D_SHAPE_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'template model')) = 1;
END_ENTITY;

ENTITY stratum_type_independent_padstack_definition 
 SUBTYPE OF (padstack_definition);
END_ENTITY; 
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_template_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3523 - ISO/CD-TS 10303-1717 Part template 3d shape - EXPRESS MIM
*)


SCHEMA Part_template_3d_shape_mim;
	USE FROM Part_template_shape_with_parameters_mim;	-- ISO/TS 10303-1720
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_template_extension_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3526 - ISO/CD-TS 10303-1718 Part template extension - EXPRESS MIM
*)


SCHEMA Part_template_extension_mim;
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	USE FROM Styled_curve_mim;	-- ISO/TS 10303-1749
	USE FROM Styled_text_mim;	-- ISO/TS 10303-1750
	
	USE FROM Presentation_definition_schema(text_literal);

ENTITY part_text_template_definition
  SUBTYPE OF (part_template_definition);
WHERE
  WR1: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'TEXT_LITERAL' IN
       TYPEOF (it))) = 1)) = 1))) = 0);
  WR2: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['PART_TEMPLATE_EXTENSION_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font vertical extent'))) = 1
       )) = 1))) = 0);
  WR3: (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['PART_TEMPLATE_EXTENSION_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 
         'maximum font horizontal extent'))) = 1
       )) = 1))) = 0);
END_ENTITY;

ENTITY reference_packaged_part_interconnect_implementation
 SUBTYPE OF (physical_unit);
WHERE
  WR1: EXISTS(SELF\product_definition.name);
  WR2: (SIZEOF (QUERY (prpc <*
       USEDIN (SELF.formation.of_product,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) AND
       (SELF\product_definition.name = 'interconnect module');
  WR3: SIZEOF (QUERY (du <* QUERY (pdr <* USEDIN (SELF,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design usage') |
       (SIZEOF (['PART_TEMPLATE_EXTENSION_MIM.' +
       'PHYSICAL_UNIT', 
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'EXTERNALLY_DEFINED_PHYSICAL_UNIT', 
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'LIBRARY_DEFINED_PHYSICAL_UNIT'] *
       TYPEOF (du.relating_product_definition)) = 1) AND
       (du.relating_product_definition.frame_of_reference.name = 
       'physical design usage') AND
       (du.relating_product_definition\product_definition.name =
       'interconnect module') AND
       (SIZEOF (QUERY (prpc <*
       USEDIN (du.relating_product_definition.formation.of_product,
       'PART_TEMPLATE_EXTENSION_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1) 
       )) <= 1;
  WR4: SELF.frame_of_reference.name = 'physical design';
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_template_non_planar_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3529 - ISO/CD-TS 10303-1719 Part template non planar shape - EXPRESS MIM
*)


SCHEMA Part_template_non_planar_shape_mim;
	USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509

RULE part_template_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'part template non planar 2d shape')
       AND NOT(SIZEOF(QUERY(a2p3d <* mssr.items |
       ('PART_TEMPLATE_NON_PLANAR_SHAPE_MIM.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d))
       )) = 1)
       )) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_template_shape_with_parameters_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3532 - ISO/CD-TS 10303-1720 Part template shape with parameters - EXPRESS MIM
*)


SCHEMA Part_template_shape_with_parameters_mim;
	USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
	USE FROM Physical_layout_template_mim;	-- ISO/TS 10303-1722
	USE FROM Shape_parameters_mim;	-- ISO/TS 10303-1743
	
TYPE ptswp_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_representation);
END_TYPE; 

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\part_view_definition_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2919 - ISO/TS 10303-1023 Part view definition - EXPRESS MIM
*)


SCHEMA Part_view_definition_mim;

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


END_SCHEMA;  -- Part_view_definition_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\person_organization_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2922 - ISO/TS 10303-1011 Person organization - EXPRESS MIM
*) 


SCHEMA Person_organization_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select); 

USE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization,
   organization_relationship,
   organizational_address,
   person,
   person_and_organization,
   personal_address); 


ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;

END_SCHEMA;  -- Person_organization_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\person_organization_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1091 - ISO/TS 10303-1013 Person organization assignment - EXPRESS MIM
*)
      
SCHEMA Person_organization_assignment_mim;

USE FROM Person_organization_mim; 		-- 10303-1011
USE FROM person_organization_schema 	-- ISO 10303-41
  (organization_role,
   person_and_organization_role);
USE FROM management_resources_schema 	-- ISO 10303-41
  (organization_assignment,
   person_and_organization_assignment);

   
TYPE organization_item = EXTENSIBLE SELECT; 
END_TYPE;

   
TYPE person_and_organization_item = EXTENSIBLE SELECT; 
END_TYPE;

   
ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;

   
ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;

END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_component_feature_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3535 - ISO/CD-TS 10303-1721 Physical component feature - EXPRESS MIM
*)


SCHEMA Physical_component_feature_mim;
	USE FROM Component_feature_mim;	-- ISO/TS 10303-1657

 ENTITY physical_component_feature
    SUBTYPE OF (component_feature);
  END_ENTITY;

  ENTITY physical_component_terminal
    ABSTRACT SUPERTYPE
    SUBTYPE OF (component_terminal,
 			physical_component_feature);
  END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_connectivity_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3667 - ISO/CD-TS 10303-1755 Physical connectivity definition - EXPRESS MIM
*)


SCHEMA Physical_connectivity_definition_mim;
	USE FROM Part_external_reference_mim;	-- ISO/TS 10303-1711
	USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740

TYPE fde_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_aspect_relationship,
      physical_connectivity_definition,
      physical_connectivity_element);
END_TYPE; 

TYPE fde_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (physical_connectivity_definition,
      physical_connectivity_element);
END_TYPE; 
	
ENTITY make_from_connectivity_relationship
 SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: 'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION'
       IN TYPEOF (SELF.relating_shape_aspect);
  WR2: 'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION'
       IN TYPEOF (SELF.related_shape_aspect);
END_ENTITY;

ENTITY physical_connectivity_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name,SELF\shape_aspect.of_shape;
WHERE
  WR1: SIZEOF (QUERY (at <* QUERY (sar <* USEDIN (SELF,
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'associated terminals') |
       ('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'COMPONENT_TERMINAL' IN
       TYPEOF (at.related_shape_aspect)) AND
((at.related_shape_aspect\shape_aspect.description = 
                 'assembly module component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
                        'bare die component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
               'interconnect component join terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
             'interconnect module component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
              'minimally defined component terminal') OR
(at.related_shape_aspect\shape_aspect.description = 
                     'packaged component join terminal'))
       )) > 1;
  WR2: SIZEOF (QUERY( pd <* USEDIN(SELF,
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
        (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'connectivity allocation')) = 1)
       ))
       <= 1;
END_ENTITY;

RULE physical_connectivity_definition_relationship_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND NOT('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.'
       + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF(sar.related_shape_aspect))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND NOT('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.'
       + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect))
       )) = 0;
  WR3: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'physical connectivity definition change')
       AND (SIZEOF(QUERY(rpd <* USEDIN(sar, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.'
       + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd))
       )) = 0)
       )) = 0;
  
END_RULE;

ENTITY physical_connectivity_element
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: (SELF.relating_shape_aspect\shape_aspect.description = 
                          'topological junction') XOR
       (SIZEOF ([
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (SELF.relating_shape_aspect)) = 1);
  WR2: (SELF.related_shape_aspect\shape_aspect.description = 'topological junction') XOR
       (SIZEOF ([
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'COMPONENT_TERMINAL'] *
       TYPEOF (SELF.related_shape_aspect)) = 1);
  WR3: SIZEOF (QUERY (se <* QUERY (sar <* USEDIN (SELF,
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'structure element') |
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (se.relating_shape_aspect))) = 1;
  WR4: ('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PHYSICAL_UNIT' IN 
       TYPEOF (SELF.of_shape.definition)) AND
       (SELF.of_shape.definition\product_definition.
         frame_of_reference.name = 
       'physical design');
END_ENTITY;

ENTITY physical_unit_network_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SELF.frame_of_reference.name IN ['physical network design'];
END_ENTITY;

RULE physical_connectivity_element_unique_constraint FOR
 ( physical_connectivity_element );
LOCAL
  name_bag : BAG OF STRING := [];
  pce_bag : BAG OF physical_connectivity_element;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pcd_bag : BAG OF physical_connectivity_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(physical_connectivity_element) by 1;
  IF EXISTS( physical_connectivity_element[i]\shape_aspect.name ) THEN
    IF( NOT( physical_connectivity_element[i]\shape_aspect.name IN 
         name_bag ) ) THEN
      name_bag := name_bag + 
                physical_connectivity_element[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pcd_bag := [];
  pce_bag := QUERY( pce <* physical_connectivity_element |
(pce\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(pce_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( pce_bag[j],
'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'structure element') AND (
'PHYSICAL_CONNECTIVITY_DEFINITION_MIM.' +
'PHYSICAL_CONNECTIVITY_DEFINITION' IN 
TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
        IF ( sar_bag[j].relating_shape_aspect IN pcd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pcd_bag := pcd_bag + sar_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_layout_template_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3538 - ISO/CD-TS 10303-1722 Physical layout template - EXPRESS MIM
*)


SCHEMA Physical_layout_template_mim;
	USE FROM Functional_decomposition_to_design_mim;	-- ISO/TS 10303-1676
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017

	USE FROM Application_context_schema(application_context_element);
		
ENTITY part_template_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: frame_of_reference\application_context_element.name = 'template definition';

  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'part template analytical model'))) 
       <= 1))) = 0;       

  WR3: (NOT (SELF\product_definition.description = 
         'component termination passage template')) OR
       (SIZEOF (QUERY (ctpt <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'inter stratum feature passage technology') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (ctpt.relating_product_definition)) AND
       (ctpt.relating_product_definition\product_definition.description = 
       'default component termination passage definition'))) = 1);

  WR4: (NOT (SELF\product_definition.description = 
        'component termination passage template')) OR
       (SIZEOF (QUERY (am <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'access mechanism') |
       am.related_product_definition\product_definition.description IN 
       ['component termination passage template interface terminal',
       'component termination passage template join terminal'])) >= 2);

  WR5: (NOT (SELF\product_definition.description = 'default trace template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1);

  WR6: (NOT (SELF\product_definition.description = 'inter stratum feature template')) OR
       (SIZEOF (QUERY (isfpt <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'inter stratum feature passage technology') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PASSAGE_TECHNOLOGY' IN
       TYPEOF (isfpt.relating_product_definition)))) = 1);

  WR7: (NOT (SELF\product_definition.description = 'printed connector template')) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF, 
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name IN 
       ['connector'])) >= 1);

  WR8: (NOT (SELF\product_definition.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'ANALYTICAL_MODEL' IN 
       TYPEOF (pdr.used_representation)) AND
       (pdr.used_representation\representation.name = 'transmission line model'))) 
       = 1))) = 0);

  WR9: (NOT (SELF\product_definition.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       SIZEOF (
       ['PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2)) = 2)) = 1))) = 0);

 WR10: (NOT (SELF\product_definition.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'maximum width'))) = 1
       )) = 1))) = 0);

 WR11: (NOT (SELF\product_definition.description = 'printed part cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] * 
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'minimum width'))) = 1
       )) = 1))) = 0);

 WR12: (NOT (SELF\product_definition.description = 'printed part template')) OR
       (SIZEOF (QUERY (impl_func <* QUERY (pdr <* 
       USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'implemented function') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'FUNCTIONAL_UNIT' IN 
       TYPEOF (impl_func.relating_product_definition)) AND
       (impl_func.relating_product_definition.frame_of_reference.name =
       'functional design usage'))) = 1);
 
 WR13: (NOT (SELF\product_definition.description = 'printed part template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF, 
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'associated definition') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF (ad.related_product_definition)) AND
       (ad.related_product_definition\product_definition.description IN 
       ['interface terminal', 'join terminal']))) >= 2);

 WR14: (NOT (SELF\product_definition.description = 'trace template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 'curve style parameters'
       )) = 1 ) )) = 1 );  

 WR15: (NOT (SELF\product_definition.description = 'unsupported passage template')) OR
       (SIZEOF (QUERY (upt <* QUERY (pdr <* USEDIN (SELF, 
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'inter stratum feature passage technology') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PASSAGE_TECHNOLOGY' IN 
       TYPEOF (upt.relating_product_definition)) AND
       (upt.relating_product_definition\product_definition.description = 
       'default unsupported passage definition'))) = 1);

 WR16: (NOT (SELF\product_definition.description = 'via template')) OR
       (SIZEOF (QUERY (vpt <* QUERY (pdr <* USEDIN (SELF, 
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'inter stratum feature passage technology') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PASSAGE_TECHNOLOGY' IN 
       TYPEOF (vpt.relating_product_definition)) AND
       (vpt.relating_product_definition\product_definition.description = 
       'default via definition'))) = 1);

 WR17: (NOT (SELF\product_definition.description = 'via template')) OR
       (SIZEOF (QUERY (am <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'access mechanism') |
       am.related_product_definition\product_definition.description =
                                 'via template terminal')) >= 2);

 WR18: EXISTS(SELF\product_definition.name);

 WR19: (NOT (SELF\product_definition.description = 'non conductive cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'STRATUM_TECHNOLOGY' IN
       TYPEOF (tu.relating_property_definition.definition)))) = 1)) = 1);

 WR20: (NOT (SELF\product_definition.description = 'non conductive cross section template')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       (SIZEOF (
       ['PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'MEASURE_REPRESENTATION_ITEM',
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF (it)) = 2) AND (it\representation_item.name = 'nominal width'))) = 1
       )) = 1))) = 0);

 WR21: (NOT (SELF\product_definition.description = 'printed connector template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'associated definition') |
       ('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (ad.related_product_definition)) AND
       (ad.relating_product_definition\product_definition.description IN
       ['interface terminal', 'join terminal']))) >= 2);

 WR22: (NOT (SELF\product_definition.description = 
                         'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'horizontal material link') |
       NOT(('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_product_definition)) AND
       (('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_product_definition\product_definition_relationship.
                                                   related_product_definition)) AND
       (ad.relating_product_definition\product_definition_relationship.
                 related_product_definition\product_definition.description = 'left'))))) = 0); 

 WR23: (NOT (SELF\product_definition.description = 
                        'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'horizontal material link') |
       NOT(('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_product_definition)) AND
       (('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_product_definition\product_definition_relationship.
                                                 relating_product_definition)) AND
       (ad.relating_product_definition\product_definition_relationship.
              relating_product_definition\product_definition.description = 'right'))))) = 0); 

 WR24: (NOT (SELF\product_definition.description = 
                                'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'vertical material link') |
       NOT(('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_product_definition)) AND
       (('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_product_definition\product_definition_relationship.
                                              related_product_definition)) AND
       (ad.relating_product_definition\product_definition_relationship.
          related_product_definition\product_definition.description = 'bottom'))))) = 0); 

 WR25: (NOT (SELF\product_definition.description = 
                                 'printed part cross section template')) OR
       (SIZEOF (QUERY (ad <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'vertical material link') |
       NOT(('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (ad.relating_product_definition)) AND
       (('PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (ad.relating_product_definition\product_definition_relationship.
                                          relating_product_definition)) AND
       (ad.relating_product_definition\product_definition_relationship.
          relating_product_definition\product_definition.description = 'top'))))) = 0); 
END_ENTITY;	
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_node_requirement_to_implementing_component_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3541 - ISO/CD-TS 10303-1723 Physical node requirement to implementing component allocation - EXPRESS MIM
*)


SCHEMA Physical_node_requirement_to_implementing_component_allocation_mim;
	USE FROM Assembly_module_with_packaged_connector_component_mim;	-- ISO/TS 10303-1645
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755
	
REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);
	
ENTITY physical_node_requirement_to_implementing_component_allocation
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
  WR1: ('PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (SELF.related_shape_aspect.of_shape\property_definition.definition)) AND
       (NOT (SELF.related_shape_aspect.of_shape\property_definition.definition\product_definition.description IN 
       ['laminate component']));
  WR2: 'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION_MIM.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION' IN
       TYPEOF (SELF.relating_shape_aspect);
  WR3: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION_MIM.'+
       'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\physical_node_requirement_to_implementing_component_allocation)) = 0;
(*
  WR5: SIZEOF(terminal_of_implementing_component(SELF,SELF.relating_shape_aspect)) = 0;
*)
END_ENTITY;
	
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_2d_design_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3547 - ISO/CD-TS 10303-1724 Physical unit 2d design view - EXPRESS MIM
*)


SCHEMA Physical_unit_2d_design_view_mim;
	USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
REFERENCE FROM Physical_unit_usage_view_mim   	
  (is_laminate_component); -- ISO/TS 10303-1732
REFERENCE FROM Physical_unit_design_view_mim   
  (is_interconnect_module_occurrence); 	-- ISO/TS 10303-1728
REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 
	
	
ENTITY component_2d_location
  SUBTYPE OF (context_dependent_shape_representation, shape_representation_relationship, representation_relationship_with_transformation, definitional_representation_relationship);
(* NEED to re-write !!!  
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'placement fixed') AND 
       ((it\descriptive_representation_item.description = 'true') OR
       (it\descriptive_representation_item.description = 'false')))) = 1;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)))) = 1;
  WR3: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
       = 2)) OR (SIZEOF (QUERY (it <* SELF.items |
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1);
  WR4: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
        = 3)) OR (SIZEOF (QUERY (it <* SELF.items |
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1);
  WR5: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM'
       IN TYPEOF (it)) 
       )) = 1;
  WR6: NOT (SIZEOF (QUERY (it <* SELF.items |
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1)
        OR
        (SIZEOF (QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) >= 1)
        )) = 1);
  WR7: NOT (SIZEOF (QUERY (it <* SELF.items |
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1)
      OR
       (SIZEOF (QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'AXIS2_PLACEMENT_3D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) = 1)
        )) = 1);
  WR8:NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2) AND 
          (SELF.context_of_items.context_type = 'component surface') AND
        (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        ((sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module primary surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge segment surface')))) = 1)
       )
       )) = 1)))
       OR
       (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
  WR9:NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2) AND 
          (SELF.context_of_items.context_type = 'component surface') AND
         (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module secondary surface')) = 1)
       ))) = 1)))
       OR
    (SIZEOF(QUERY( cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))) = 1);
  WR10: (NOT(is_laminate_component_location(SELF))) OR
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
  WR11: (NOT(is_laminate_component_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
  WR12: SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.definition.definition\shape_aspect.description =
        'interconnect module component surface feature'))) = 0;
  WR13: (NOT((SELF.context_of_items\geometric_representation_context.
        coordinate_space_dimension = 2) AND
        (SELF.context_of_items.context_type = 'component stacked')))
        OR 
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
 WR14: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component edge'))
       OR
        ((NOT(is_laminate_component_location(SELF)))
          AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'reference terminal assembly joint') AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_TERMINAL' IN 
                      TYPEOF (pdr.definition.definition.related_shape_aspect)) 
         AND
       (pdr.definition.definition.related_shape_aspect\shape_aspect.description IN
       ['packaged component join terminal',
       'package terminal occurrence'])
         AND
       (SIZEOF(QUERY ( sar <* USEDIN 
                          (pdr.definition.definition.related_shape_aspect,
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name = 'instantiated feature')
           AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF (sar.relating_shape_aspect))
         )) = 1)
         AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) =
                 pdr.definition.definition.related_shape_aspect.of_shape.definition) 
       ))) = 1))
         AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.name = 'mounting surface assembly joint') AND
       (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
         'interconnect module component surface feature') AND
       (SIZEOF(QUERY ( sar <* USEDIN (pdr.definition.definition.relating_shape_aspect,
        'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge surface') OR
        (sar.relating_shape_aspect\shape_aspect.description =
         'interconnect module edge segment surface'))) = 1)
         AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_MOUNTING_FEATURE' IN 
                      TYPEOF (pdr.definition.definition.related_shape_aspect)) 
         AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) =
                 pdr.definition.definition.related_shape_aspect.of_shape.definition) 
       ))) = 1))
      );
 WR15: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component stacked'))
       OR
        ((NOT(is_laminate_component_location(SELF)))
          AND
       (( SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       (
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition))
         AND
       ('mounting joint' = pdr.name)
         AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_MOUNTING_FEATURE' IN
                      TYPEOF (pdr.definition.definition.related_shape_aspect))
         AND
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'COMPONENT_DEFINITION' IN
         TYPEOF (pdr.definition.definition.related_shape_aspect.of_shape.definition))
         AND
       (component_definition_located_by_component_location(SELF) :=:
                 pdr.definition.definition.related_shape_aspect.of_shape.definition)    
         AND
       (component_definition_located_by_component_location(SELF) :<>: 
                 pdr.definition.definition.relating_shape_aspect.of_shape.definition)    
       )
      )) = 1))
        );
 WR16: (NOT(is_interconnect_module_component_location(SELF))) OR
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
 WR17: NOT((SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)
          AND
         (SELF.context_of_items.context_type = 'component stacked'))
       OR
       (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      ((cto2d_determinant_test(cto2d,1.0,0.001 )) OR
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))
      )) = 1);
 WR18 : SIZEOF (QUERY (it <* SELF\representation.items| NOT
     (SIZEOF(
    ['PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
     'CARTESIAN_TRANSFORMATION_OPERATOR_2D', 
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
     'MAPPED_ITEM', 
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
     'DESCRIPTIVE_REPRESENTATION_ITEM', 
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
     'AXIS2_PLACEMENT_3D'] 
     * TYPEOF(it)) = 1 ))) = 0;
 WR19: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'origin') 
       )) = 0;
 WR20: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM'
       IN TYPEOF (it))
       AND NOT
       (((it\representation_item.name = 'component assembly 2d position')
        OR
       (it\representation_item.name = 'component assembly 3d position'))
       AND
       (it.mapping_source.mapping_origin\representation_item.name = 'origin')
       AND
       (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (it.mapping_source.mapping_origin))
        OR
       ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it.mapping_source.mapping_origin))))
       )) = 0;
 WR21: SIZEOF(QUERY(pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.'
       + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
            TYPEOF(pdr.definition.definition))
       )) = 1;
 WR22: (NOT(is_top_footprint_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
 WR23: (NOT(is_bottom_footprint_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))) = 1);
 WR24: (NOT(is_symmetrical_footprint_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
 WR25: (NOT(is_top_padstack_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);
 WR26: (NOT(is_bottom_padstack_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,-1.0,0.001 )))) = 1);
 WR27: (NOT(is_symmetrical_padstack_occurrence_location(SELF) AND
         (SELF.context_of_items\geometric_representation_context.coordinate_space_dimension
         = 2)))
         OR
         (SIZEOF(QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (cto2d)) AND
      (cto2d_determinant_test(cto2d,1.0,0.001 )))) = 1);*)
END_ENTITY;
	
RULE component_part_2d_geometric_representation_relationship_constraint FOR 
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 
                            'component part planar shape');
 pass: BOOLEAN := TRUE;
 grc1: Geometric_representation_context := ?;
 grc2: Geometric_representation_context := ?;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
  grc1 := rr[i].rep_1.context_of_items;
  grc2 := rr[i].rep_2.context_of_items;
IF ((grc1.coordinate_space_dimension) <>
          (grc2.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE;
	

FUNCTION component_definition_located_by_component_location 
                   (cl : component_2d_location) : component_definition; 
LOCAL
  pdr : BAG OF property_definition_representation := USEDIN (cl,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
  pd : property_definition := ?;
END_LOCAL;
   REPEAT i := 1 TO HIINDEX(pdr) BY 1;
    IF('PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION' IN 
                                  TYPEOF (pdr[i].definition))
      THEN                            
        pd := pdr[i].definition;
        IF(('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
          'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
                                    TYPEOF (pd.definition))
          AND
          ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
           'COMPONENT_DEFINITION' IN 
           TYPEOF (pd.definition\product_definition_relationship.
                                                  related_product_definition)))
        THEN 
          RETURN(pd.definition\product_definition_relationship.
                                                   related_product_definition);
      END_IF;                                               
    END_IF;
   END_REPEAT;
 RETURN (?);
END_FUNCTION;

FUNCTION cto2d_determinant_test (cto2d: cartesian_transformation_operator_2d;
                             expected_value: REAL; delta: REAL ) : BOOLEAN;

LOCAL
  det : REAL := 0.0;
  DRs : LIST [4:4] OF REAL := [];
END_LOCAL;
     DRs[1] := cto2d.u[1].direction_ratios[1];
     DRs[2] := cto2d.u[1].direction_ratios[2];
     DRs[3] := cto2d.u[2].direction_ratios[1];
     DRs[4] := cto2d.u[2].direction_ratios[2];
     det  :=  (DRs[1] * DRs[4]) - (DRs[2] * DRs[3]);
IF (Abs(expected_value - det) < Abs(delta) ) THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_interconnect_module_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_laminate_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_laminate_component(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_top_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_top_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_top_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_top_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('PHYSICAL_UNIT_2D_DESIGN_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_2d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3559 - ISO/CD-TS 10303-1726 Physical unit 2d shape - EXPRESS MIM
*)


SCHEMA Physical_unit_2d_shape_mim;
	USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
	USE FROM Physical_unit_shape_with_parameters_mim;	-- ISO/TS 10303-1730
	USE FROM Layered_2d_shape_mim; -- ISO/TS 10303-1693
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_3d_design_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3562 - ISO/CD-TS 10303-1725 Physical unit 3d design view - EXPRESS MIM
*)


SCHEMA Physical_unit_3d_design_view_mim;
	USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
	
ENTITY component_3d_location
  SUBTYPE OF (context_dependent_shape_representation, shape_representation_relationship, representation_relationship_with_transformation, definitional_representation_relationship);
(* NEED to re-write !!!    
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'placement fixed') AND 
       ((it\descriptive_representation_item.description = 'true') OR
       (it\descriptive_representation_item.description = 'false')))) = 1;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM'
       IN TYPEOF (it)))) = 1;
  WR3: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
       = 2)) OR (SIZEOF (QUERY (it <* SELF.items |
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1);
  WR4: (NOT 
       (SELF.context_of_items\geometric_representation_context.
       coordinate_space_dimension
        = 3)) OR (SIZEOF (QUERY (it <* SELF.items |
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1);
  WR5: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM'
       IN TYPEOF (it)) 
       )) = 1;
  WR6: NOT (SIZEOF (QUERY (it <* SELF.items |
        'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF (it))) = 1)
        OR
        (SIZEOF (QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'CARTESIAN_TRANSFORMATION_OPERATOR_2D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) >= 1)
        )) = 1);
  WR7: NOT (SIZEOF (QUERY (it <* SELF.items |
        'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (it))) = 1)
      OR
       (SIZEOF (QUERY (cto2d <* SELF.items |
        ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'AXIS2_PLACEMENT_3D'
        IN TYPEOF (cto2d)) AND
        (SIZEOF (QUERY (mi <* USEDIN (cto2d,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM.MAPPING_TARGET') | (
       (SIZEOF (QUERY (cl <* USEDIN (mi,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'REPRESENTATION.ITEMS') |(cl = SELF))) = 1)))) = 1)
        )) = 1);
  WR8: SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'SHAPE_ASPECT' IN TYPEOF (pdr.definition.definition)) AND
       (pdr.definition.definition\shape_aspect.description =
        'interconnect module component surface feature'))) = 0;
  WR9: (NOT((SELF.context_of_items\geometric_representation_context.
        coordinate_space_dimension = 2) AND
        (SELF.context_of_items.context_type = 'component stacked')))
        OR 
      (SIZEOF(QUERY( pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (pdr.definition.definition)) AND
      (pdr.definition.definition.relating_shape_aspect\shape_aspect.description =
        'interconnect module component surface feature'))) = 0);
 WR10 : SIZEOF (QUERY (it <* SELF\representation.items| NOT
     (SIZEOF(
    ['PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
     'CARTESIAN_TRANSFORMATION_OPERATOR_2D', 
     'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
     'MAPPED_ITEM', 
     'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
     'DESCRIPTIVE_REPRESENTATION_ITEM', 
     'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
     'AXIS2_PLACEMENT_3D'] 
     * TYPEOF(it)) = 1 ))) = 0;
 WR11: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D'
       IN TYPEOF (it)) AND
       (it\representation_item.name = 'origin') 
       )) = 0;
 WR12: SIZEOF (QUERY (it <* SELF.items |
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'MAPPED_ITEM'
       IN TYPEOF (it))
       AND NOT
       (((it\representation_item.name = 'component assembly 2d position')
        OR
       (it\representation_item.name = 'component assembly 3d position'))
       AND
       (it.mapping_source.mapping_origin\representation_item.name = 'origin')
       AND
       (('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_2D' IN TYPEOF (it.mapping_source.mapping_origin))
        OR
       ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.' +
       'AXIS2_PLACEMENT_3D' IN TYPEOF (it.mapping_source.mapping_origin))))
       )) = 0;
 WR13: SIZEOF(QUERY(pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        ('PHYSICAL_UNIT_3D_DESIGN_VIEW_MIM.'
       + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
            TYPEOF(pdr.definition.definition))
       )) = 1;*)
END_ENTITY;
(* temporary to get aim to compile.	
RULE component_part_3d_geometric_representation_relationship_constraint FOR
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 'component part 3d shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <> 
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE;
	
RULE component_part_3d_geometric_representation_relationship_constraint FOR
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 'component part 3d shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <> 
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE;	
*)

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_3d_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3565 - ISO/CD-TS 10303-1727 Physical unit 3d shape - EXPRESS MIM
*)


SCHEMA Physical_unit_3d_shape_mim;
	USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
	USE FROM Physical_unit_shape_with_parameters_mim;	-- ISO/TS 10303-1730
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_design_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3568 - ISO/CD-TS 10303-1728 Physical unit design view - EXPRESS MIM
*)

SCHEMA Physical_unit_design_view_mim;
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
	
	USE FROM Application_context_schema(application_context_element);
	
TYPE pudv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (assembly_component_usage,
     descriptive_representation_item);
END_TYPE; 
	
ENTITY component_definition
  SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = 'planar projected shape')) 
       <= 1))) = 0;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       sr_pdr.used_representation\representation.name = '3d bound volume shape')) 
       <= 1))) = 0;
  WR3: (NOT (SELF\product_definition.description = 
                                         'bare die component')) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'BARE_DIE',
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_BARE_DIE',
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'LIBRARY_DEFINED_BARE_DIE'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1);
  WR4: NOT(is_assembly_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage') AND
       (ip.relating_product_definition\product_definition.name = 
          'assembly module')
       )) = 1);
  WR5: NOT(is_assembly_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'COMPONENT_TERMINAL' IN 
       TYPEOF (sa)) AND
       (sa\shape_aspect.description = 'assembly module component terminal'))) 
       >= 2)) >= 1);
  WR6: NOT(is_interconnect_module_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage') AND
        (SELF\product_definition.name = 'interconnect module')
       )) = 1);
(* invalid csa       
  WR7: (NOT (SELF\product_definition.description = 'mating connector')) OR
       ((('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' + 
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF)) AND
       (SIZEOF (QUERY (doc <* 
   SELF\product_definition_with_associated_documents.documentation_ids |
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'EE_SPECIFICATION' IN 
       TYPEOF (doc))) = 1)) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pt_occ <* QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       sa\shape_aspect.description = 'part template occurrence') |
       SIZEOF (QUERY (it <* QUERY (sar <* USEDIN (pt_occ,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'instantiated template') |  
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (it.relating_shape_aspect)) AND
       (it.relating_shape_aspect\shape_aspect.description = 
       'printed connector template'))) = 1)) = 1))) = 0) OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PACKAGED_PART',
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'EXTERNALLY_DEFINED_PACKAGED_PART',
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'LIBRARY_DEFINED_PACKAGED_PART'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition\product_definition.description =
       'packaged connector'))) = 1)); *)
  WR8: (NOT (SELF\product_definition.description = 'mating connector')) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name  = 
       'mating connector placement')) = 1)) = 1);
 WR9: (NOT (SELF\product_definition.description = 'mating connector')) OR
       ((SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr))) = 0) AND
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr))) = 0));
 WR10: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        NOT(NOT(pdr\product_definition_relationship.name = 'instantiated part')
        OR 
        (SELF.formation :=: 
        pdr.relating_product_definition.formation))))
        = 0;
 WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation)) |
       (sr_pdr.used_representation\representation.name = 
        'part template non planar 2d shape')
       OR
       (sr_pdr.used_representation\representation.name = 'non planar 2d shape')
       OR
       (sr_pdr.used_representation\representation.name = 
        'open shell based surface'))) 
       <= 1))) = 0;
(** Wrong back dependence        
 WR12: NOT((SELF.frame_of_reference.name = 'layout occurrence') 
          AND
       NOT('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRINTED_COMPONENT' IN TYPEOF(SELF))) OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ((SIZEOF (['PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'COMPONENT_SHAPE_ASPECT'] *
       TYPEOF (sa)) >= 1)) 
        )) = 1))) = 0);
*)
 WR13: NOT(is_assembly_module_macro_occurrence(SELF))
       OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design') AND
       (ip.relating_product_definition\product_definition.name = 
           'assembly module')
       )) = 1);
 WR14: NOT(is_interconnect_module_macro_occurrence(SELF))
        OR
       (SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'design definition') |
       ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PHYSICAL_UNIT' IN
       TYPEOF (ip.relating_product_definition)) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design') AND
       (ip.relating_product_definition\product_definition.name = 
             'interconnect module')
        )) = 1);
 WR15: SIZEOF(QUERY(pdr <* USEDIN(SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ((pdr\product_definition_relationship.name = 'instantiated definition')
        AND
        (NOT(SELF.formation :=:
        pdr.relating_product_definition.formation)))))
        = 0;
 WR16: (NOT (SELF\product_definition.description =
                                         'routed interconnect component')) OR
       ((SIZEOF (QUERY (ip <* QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'instantiated part') |
       (SIZEOF (['PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
       'PHYSICAL_UNIT'] *
       TYPEOF (ip.relating_product_definition)) = 1) AND
       (ip.relating_product_definition.frame_of_reference.name =
       'physical design usage'))) = 1) AND
       (SELF.frame_of_reference.name = 'physical occurrence'));
END_ENTITY;

ENTITY assembly_component
  SUBTYPE OF (component_definition, product_definition_shape);
END_ENTITY;

ENTITY thermal_component
  SUBTYPE OF (assembly_component);
END_ENTITY;

FUNCTION is_assembly_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_assembly_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_interconnect_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_interconnect_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

RULE assembly_composition_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  acr : BAG OF assembly_component_usage := 
 QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'assembly composition') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  cd_bag : BAG OF component_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].relating_product_definition ) THEN
    IF( (acr[i].relating_product_definition.frame_of_reference.name = 
         'physical design')
AND ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) ) THEN
      IF ( NOT ( acr[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + acr[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cd_bag := [];
  acu_bag := QUERY( acu <* acr | (acu.relating_product_definition :=: 
                               pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].related_product_definition ) THEN
      IF ( 'PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
'COMPONENT_DEFINITION' IN 
             TYPEOF(acu_bag[j].related_product_definition) ) THEN
        IF ( acu_bag[j].related_product_definition IN cd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          cd_bag := cd_bag + acu_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE next_higher_assembly_relationship_unique_constraint FOR
 ( next_assembly_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  nauo_bag : BAG OF next_assembly_usage_occurrence;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(next_assembly_usage_occurrence) by 1;
  IF EXISTS( next_assembly_usage_occurrence[i].relating_product_definition )
                                                               THEN
    IF( 
(next_assembly_usage_occurrence[i].
                relating_product_definition.frame_of_reference.name 
                                                  = 'physical design')
AND ('PHYSICAL_UNIT_DESIGN_VIEW_MIM.' +
'PHYSICAL_UNIT' 
     IN TYPEOF(next_assembly_usage_occurrence[i].
                                relating_product_definition)) ) THEN
      IF ( NOT ( next_assembly_usage_occurrence[i].
                                  relating_product_definition 
                                              IN pu_bag )) THEN
        pu_bag := pu_bag + 
             next_assembly_usage_occurrence[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  nauo_bag := QUERY( nauo <* next_assembly_usage_occurrence | 
                  (nauo.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(nauo_bag) by 1;
    IF EXISTS( nauo_bag[j].reference_designator ) THEN
      IF ( nauo_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_interconnect_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3571 - ISO/CD-TS 10303-1729 Physical unit interconnect definition - EXPRESS MIM
*)


SCHEMA Physical_unit_interconnect_definition_mim;
	USE FROM Part_occurrence_mim;	-- ISO/TS 10303-1715

	USE FROM Date_time_schema
		(date_time_role,
		date_role);
	USE FROM Document_schema(document_type);
	USE FROM Person_organization_schema
		(person_and_organization_role,
		organization_role);	
	USE FROM Product_definition_schema(product_definition_with_associated_documents);	
	USE FROM Product_property_definition_schema(property_definition);
			
ENTITY connector_based_interconnect_definition
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.name,SELF\property_definition.definition;
WHERE
  WR1: 'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'PHYSICAL_INTERCONNECT_DEFINITION' IN 
        TYPEOF(SELF\property_definition.definition);
END_ENTITY;

ENTITY physical_interconnection_definition
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.name,SELF\property_definition.definition;
WHERE
  WR1: 'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION' IN 
        TYPEOF(SELF\property_definition.definition);
END_ENTITY;

ENTITY physical_unit_interconnect_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_INTERCONNECT_DEFINITION_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\physical_unit_interconnect_definition))) = 0;
  WR7: SELF.frame_of_reference.name IN ['physical interconnect design'];
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_non_planar_design_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3574 - ISO/CD-TS 10303-1613 Physical unit non planar design view - EXPRESS MIM
*)


SCHEMA Physical_unit_non_planar_design_view_mim;
	USE FROM Manifold_subsurface_mim;	-- ISO/TS 10303-1702
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_shape_with_parameters_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3577 - ISO/CD-TS 10303-1730 Physical unit shape with parameters - EXPRESS MIM
*)


SCHEMA Physical_unit_shape_with_parameters_mim;
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004
--	USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
	USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	USE FROM Shape_parameters_mim;	-- ISO/TS 10303-1743
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1023
	
TYPE puswp_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_representation);
END_TYPE; 
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\physical_unit_usage_view_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3580 - ISO/CD-TS 10303-1732 Physical unit usage view - EXPRESS MIM
*)


SCHEMA Physical_unit_usage_view_mim;
	USE FROM Analytical_model_mim;	-- ISO/TS 10303-1603
	USE FROM Feature_and_connection_zone_mim;	-- ISO/TS 10303-1671
	USE FROM Item_definition_structure_mim;	-- ISO/TS 10303-1345
	USE FROM Part_feature_location_mim;	-- ISO/TS 10303-1714
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	USE FROM Shape_composition_mim;	-- ISO/TS 10303-1742
	
	USE FROM Application_context_schema(application_context_element);
	USE FROM Material_property_definition_schema(property_definition_relationship);

TYPE puuv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_aspect);
END_TYPE;

TYPE puuv_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (shape_aspect);
END_TYPE;
	
ENTITY connection_zone_map_identification
  SUBTYPE OF (shape_aspect,representation_relationship);
WHERE
  WR1: SELF\representation_relationship.rep_2 :<>:
       SELF\representation_relationship.rep_1;
  WR2: 'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN 
	TYPEOF(SELF\representation_relationship.rep_1);
  WR3: 'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN 
	TYPEOF(SELF\representation_relationship.rep_2);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\representation_relationship ||
       SELF\connection_zone_map_identification)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\representation_relationship.name = '';
  WR7: 'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
END_ENTITY; 
(*
ENTITY library_defined_physical_unit
 SUPERTYPE OF (ONEOF (library_defined_package,
                      library_defined_assembly_definition,
                      library_defined_interconnect_definition,
                      library_defined_packaged_part, 
                      library_defined_bare_die))
 SUBTYPE OF (externally_defined_physical_unit);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY;

ENTITY library_defined_product_definition
 SUBTYPE OF (externally_defined_product_definition);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY;
*)
ENTITY make_from_part_feature_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF (['PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'COMPONENT_TERMINAL',
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL'] *
       TYPEOF (SELF.relating_shape_aspect)) = 0;
  WR2: SIZEOF (['PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'COMPONENT_TERMINAL',
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PHYSICAL_COMPONENT_INTERFACE_TERMINAL'] *
       TYPEOF (SELF.related_shape_aspect)) = 0;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\make_from_part_feature_relationship)) = 0;
  WR4: SELF.related_shape_aspect.product_definitional = TRUE;
  WR5: SELF.relating_shape_aspect.product_definitional = TRUE;
  WR6: SELF\shape_aspect.name = '';
  WR7: SELF\shape_aspect.description = '';
  WR8: SELF\shape_aspect.product_definitional = FALSE;
  WR9: SIZEOF (USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION')) = 0;
 WR10: SIZEOF (QUERY( sar <* USEDIN(SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'DESIGN_MAKE_FROM_RELATIONSHIP') IN TYPEOF
       (sar.of_shape\property_definition.definition))
       )) = 1;
END_ENTITY; 

ENTITY part_feature_template_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\part_feature_template_definition))) = 0;
  WR7: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'template model')) >= 1;
END_ENTITY;
	
ENTITY physical_unit
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SELF.frame_of_reference.name IN ['physical design', 
       'physical design usage'];
  WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (dut <* QUERY (pdr <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'physical unit technology') |
       dut.relating_property_definition\property_definition.name =
       'unit technology')) = 1)) <= 1;
  WR8: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'ASSEMBLY_MODULE_TERMINAL' IN
       TYPEOF (sa))) >= 1))) = 0);
  WR9: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
               'maximum negative component height')) <= 1))) = 0);
 WR10: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       pdr.used_representation\representation.name = 
                 'maximum positive component height')) <= 1))) = 0);
 WR11: NOT(is_assembly_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'implemented function') AND
       (pdr.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) = 1);
 WR12: NOT(is_assembly_module_design(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATING_PRODUCT_DEFINITION') |
       (is_laminate_component(pdr.related_product_definition)
       ))) = 0);
 WR14: NOT(is_interconnect_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
       (pdr\product_definition_relationship.name = 'implemented function') AND
       (pdr.relating_product_definition.frame_of_reference.name = 
       'functional design usage'))) <= 1);
 WR15: NOT(is_interconnect_module_usage(SELF)) 
       OR
       (SIZEOF (QUERY (pd1 <* USEDIN (SELF, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd1)) 
       AND (SIZEOF(QUERY(cd <* USEDIN(pd1,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'CHARACTERIZED_DEFINITION' IN TYPEOF (cd))
       AND (SIZEOF(QUERY(pd2 <* USEDIN(cd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd2\property_definition.name = 'located interconnect module thickness')
       AND (SIZEOF(USEDIN(pd2,        
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) > 1)
       )) = 1))) = 1))) <=1 );
 WR16: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
       'interconnect module usage view physical characteristics'))) <= 1);
 WR17: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
          'minimum thickness over metal requirement')
       AND ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR18: NOT(is_interconnect_module_usage(SELF))
        OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
         'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
         'maximum thickness over metal requirement')
       AND ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR19: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
         'minimum thickness over dielectric requirement')
       AND ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR20: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.name = 
          'interconnect module usage view physical characteristics')
       AND (SIZEOF (QUERY (pdr <* USEDIN (pd, 
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (pdr.used_representation\representation.name = 
           'maximum thickness over dielectric requirement')
       AND ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (pdr.used_representation))
       )) <= 1))) <= 1);
 WR21: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       ((pd\property_definition.name = 'restraint') OR
       (pd\property_definition.name = 'tolerance specific restraint')))) <= 1);
 WR22: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description = 
                                 'interconnect module primary surface')
       )) <= 1))) = 0);
WR23: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description = 
                              'interconnect module secondary surface')
       )) <= 1))) = 0);
WR24: NOT(is_interconnect_module_usage(SELF))
       OR
       (SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (sa\shape_aspect.description =
                                 'interconnect module edge surface')
       )) <= 1))) = 0);
WR25: NOT(is_assembly_module_design(SELF)) OR
((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       AND (SIZEOF (QUERY(pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (sa)))) > 0 ))) = 0)))
       OR (SIZEOF (QUERY(pd <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (SIZEOF (QUERY(sa <* USEDIN (pd,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'ASSEMBLY_JOINT' IN TYPEOF (sa)) AND
       (SIZEOF (QUERY( acu <* USEDIN (
       sa\shape_aspect_relationship.relating_shape_aspect.of_shape.definition,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
       AND (acu\product_definition_relationship.relating_product_definition = SELF)
       )) >= 1))) >=1 ))) >= 1));
WR26: NOT(is_assembly_module_design(SELF)) OR
      ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       ))
       AND (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj))AND
       (SIZEOF (QUERY( acu <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect,
        'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
        ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF (acu))
        AND (acu\product_definition_relationship.relating_product_definition = SELF)
        )) = 0))) = 0));
WR27: NOT(is_assembly_module_design(SELF)) OR
      ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'assembly module')      
       ))
       AND (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)))) = 0) OR
       (SIZEOF (QUERY(aj <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'ASSEMBLY_JOINT' IN TYPEOF (aj)) AND
        (SIZEOF (QUERY( cl <* USEDIN (aj\
        shape_aspect_relationship.related_shape_aspect.of_shape.definition,
        'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'REPRESENTATION.ITEMS') |
        ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
        'COMPONENT_LOCATION' IN TYPEOF (cl))
        AND (aj IN cl\representation.items))) = 0))) = 0));
WR28: NOT(is_interconnect_module_design(SELF)) OR
       ((NOT ((SELF.frame_of_reference.name = 'physical design') AND
       (SELF\product_definition.name = 'interconnect module')
       )) OR
       (SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATING_PRODUCT_DEFINITION') |
        (
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr))
       AND
       (pdr\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND
       (pdr.related_product_definition\product_definition.description = 'primary design layer stratum')
       AND
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'STRATUM' IN TYPEOF(pdr.related_product_definition))
        )
       )
       ) = 1));

END_ENTITY;

ENTITY usage_view_connection_zone_terminal_shape_relationship
  SUBTYPE OF (representation, representation_relationship_with_transformation);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF (['PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_REPRESENTATION'] *
       TYPEOF (SELF.rep_1)) = 1;
  WR2: SIZEOF (['PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
       'SHAPE_REPRESENTATION'] *
       TYPEOF (SELF.rep_2)) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\usage_view_connection_zone_terminal_shape_relationship))) = 0;
  WR4: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
END_ENTITY; 

RULE part_feature_constraint FOR
  (shape_aspect, product_definition, shape_aspect_relationship);
LOCAL
pass : BOOLEAN := TRUE;
name_bag : BAG OF STRING := [];
sa : BAG OF shape_aspect := [];
pd : BAG OF product_definition := QUERY ( pd <* product_definition |
       pd.frame_of_reference\application_context_element.name
       = 'physical design usage');
END_LOCAL;
 REPEAT i := 1 to SIZEOF (pd) by 1;
name_bag := [];
sa := QUERY ( sa <* shape_aspect | (
(sa.of_shape\property_definition.definition = pd[i]) AND
(sa.product_definitional) AND
(NOT (sa\shape_aspect.description = 'connection zone'))
));
  REPEAT j := 1 to SIZEOF (sa) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
 IF sa[j]\shape_aspect.name in name_bag THEN pass := FALSE;
 ELSE
  name_bag := name_bag + sa[j]\shape_aspect.name;
 END_IF;
  END_REPEAT;
 END_REPEAT;
WHERE
 WR1: pass;
 WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
      (sar\shape_aspect_relationship.name = 'precedent feature') AND
      (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
 WR3: SIZEOF(QUERY(sa <* shape_aspect | 
      ((sa\shape_aspect.description = 'part group feature') OR
      (sa\shape_aspect.description = 'part generic feature') OR
      (sa\shape_aspect.description = 'polarity indication feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 1))) = 0;
 WR4: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 0))) = 0;
END_RULE;

FUNCTION is_assembly_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_assembly_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_interconnect_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_laminate_component ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (pd\product_definition.description = 'laminate component') THEN
    RETURN (TRUE);
ELSE
  IF ('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'PRINTED_COMPONENT' IN TYPEOF(pd)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_ee_product_definition ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (NOT(is_laminate_component(pd)) AND 
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND 
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'STRATUM' IN TYPEOF(pd))) AND 
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('PHYSICAL_UNIT_USAGE_VIEW_MIM.' +
  'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)))
   ) 
THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

RULE promissory_usage_relationship_constraint FOR 
( promissory_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       ('PHYSICAL_UNIT_USAGE_VIEW_MIM.'
       + 'PHYSICAL_UNIT' IN TYPEOF (puo.relating_product_definition))
       AND (puo.relating_product_definition.frame_of_reference.name
       = 'physical design'))) = 0;
  WR2: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       SIZEOF(USEDIN(puo,
       'PHYSICAL_UNIT_USAGE_VIEW_MIM.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 0)) = 0;
END_RULE;

RULE promissory_usage_relationship_unique_constraint FOR
 ( promissory_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  puo_bag : BAG OF promissory_usage_occurrence;
  pass : BOOLEAN := TRUE;
  comp_bag : BAG OF physical_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(promissory_usage_occurrence) by 1;
  IF EXISTS( promissory_usage_occurrence[i].relating_product_definition ) 
                                                      THEN
    IF( (('PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
'PHYSICAL_UNIT') IN
TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (
promissory_usage_occurrence[i].relating_product_definition.
frame_of_reference.name =
'physical design') ) THEN
      IF( NOT( promissory_usage_occurrence[i].
                                relating_product_definition IN pu_bag ) ) 
                                                                THEN
        pu_bag := pu_bag + promissory_usage_occurrence[i].
                                             relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  puo_bag := QUERY( puo <* promissory_usage_occurrence | 
      (puo.relating_product_definition :=: pu_bag[i]) );
  comp_bag := [];
  REPEAT j := 1 to SIZEOF(puo_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( ((
'PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 
'PHYSICAL_UNIT') IN
TYPEOF(puo_bag[j].related_product_definition)) AND (
puo_bag[j].related_product_definition.frame_of_reference.name IN [
'physical design',
'physical design usage']) ) THEN
      IF EXISTS( puo_bag[j].related_product_definition ) THEN
        IF ( puo_bag[j].related_product_definition IN comp_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          comp_bag := comp_bag + puo_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

FUNCTION is_interconnect_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

RULE product_definition_requires_date_or_date_and_time FOR
  (product_definition, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT 
       (NOT(is_ee_product_definition(pd)) OR 
       ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       pd IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       pd IN ada.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_date_or_date_and_time

RULE product_definition_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT
       (NOT(is_ee_product_definition(pd)) OR
       ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       pd IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       pd IN aoa.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_person_organization

END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\planned_characteristic_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3544 - ISO/CD-TS 10303-1733 Planned characteristic - EXPRESS MIM
*)


SCHEMA Planned_characteristic_mim;
	USE FROM Product_rule_mim;	-- ISO/TS 10303-1739
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	
	USE FROM Representation_schema(representation_relationship_with_transformation);
	
ENTITY evaluated_characteristic
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\representation_relationship_with_transformation || 
       SELF\evaluated_characteristic))) = 0;
  WR2: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
  WR3: SELF\representation_relationship.name = '';
  WR4: SELF\representation.name = '';
  WR5: SELF\representation_relationship.rep_1.name = 'planned characteristic';
END_ENTITY; 

ENTITY evaluation_product_definition
 SUBTYPE OF (product_definition);
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\plib_class_reference_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3240 - ISO/TS 10303-1291 Plib class reference - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2289
*) 


SCHEMA Plib_class_reference_mim;

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   pre_defined_item); 

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013


TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH 
   (externally_defined_class);
END_TYPE; 

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH 
   (class);
END_TYPE; 

ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;

END_SCHEMA;  -- Plib_class_reference_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\pre_defined_datum_2d_symbol_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3550 - ISO/CD-TS 10303-1735 Pre defined datum 2d symbol - EXPRESS MIM
*)


SCHEMA Pre_defined_datum_2d_symbol_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\pre_defined_datum_3d_symbol_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3556 - ISO/CD-TS 10303-1736 Pre defined datum 3d symbol - EXPRESS MIM
*)


SCHEMA Pre_defined_datum_3d_symbol_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\pre_defined_datum_symbol_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3553 - ISO/CD-TS 10303-1734 Pre defined datum symbol - EXPRESS MIM
*)


SCHEMA Pre_defined_datum_symbol_mim;
	USE FROM Pre_defined_datum_2d_symbol_mim;	-- ISO/TS 10303-1735
	USE FROM Pre_defined_datum_3d_symbol_mim;	-- ISO/TS 10303-1736

SUBTYPE_CONSTRAINT pdds_shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;         
  (ONEOF (pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
          pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
          pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship));
END_SUBTYPE_CONSTRAINT;        
	
ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\shape_definition_3d_intersection || 
       SELF\pre_defined_parallel_datum_axis_symbol_3d_2d_relationship))) = 0;
END_ENTITY; 

ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\shape_definition_3d_intersection || 
       SELF\pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship))) = 0;
END_ENTITY; 

ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\shape_representation_relationship || 
       SELF\shape_definition_3d_intersection || 
       SELF\pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship))) = 0;
END_ENTITY; 
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\pre_defined_product_data_management_specialisations_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   N - ISO/CD-TS - 10303- pre_defined_product_data_management_specialisations - EXPRESS MIM
*)

SCHEMA Pre_defined_product_data_management_specialisations_mim;

USE FROM Activity_mim; -- ISO/TS 10303-1047
USE FROM Approval_mim; -- ISO/TS 10303-1012
USE FROM Date_time_assignment_mim; -- ISO/TS 10303-1014
USE FROM Person_organization_assignment_mim; -- ISO/TS 10303-1013
USE FROM Security_classification_mim; -- ISO/TS 10303-1015
USE FROM Work_request_mim; -- ISO/TS 10303-1042


END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\printed_physical_layout_template_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3583 - ISO/CD-TS 10303-1737 Printed physical layout template - EXPRESS MIM
*)


SCHEMA Printed_physical_layout_template_mim;
	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740

TYPE pplt_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (printed_part_template_terminal);
END_TYPE;
	
ENTITY printed_connector_template_terminal_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.relating_shape_aspect,
       SELF\shape_aspect_relationship.related_shape_aspect;
WHERE
  WR1: SIZEOF ( QUERY( sar <* USEDIN ( SELF, 
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (( sar\shape_aspect_relationship.name = 'connector') AND
          (sar.relating_shape_aspect\shape_aspect.description = 
              'printed connector template'))
        )) = 1;
  WR2: (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF 
       (SELF\shape_aspect_relationship.relating_shape_aspect)) AND
       (SELF\shape_aspect_relationship.relating_shape_aspect\shape_aspect.description 
        = 'interface terminal'));
  WR3: (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect)) AND
       (SELF\shape_aspect_relationship.related_shape_aspect\shape_aspect.description 
        = 'join terminal'));
  WR4: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY printed_part_cross_section_template_terminal
  SUBTYPE OF (printed_part_template_terminal);
WHERE
(* invalid csa
  WR1: 
       SIZEOF (QUERY (am <* QUERY (pdr <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\shape_aspect_relationship.name = 'cross section definition') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN
       TYPEOF (am.relating_product_definition)) AND
       (am.relating_product_definition\shape_aspect.description = 
       'printed part cross section template'))) = 1;
*)
  WR2: SIZEOF (QUERY (ga <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN
       TYPEOF (ga.assigned_group)) AND 
       (ga.assigned_group.name IN  
                       ['area edge segment', 'curve edge segment']))
        )) = 1;
  WR3: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR4: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR5: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR6: SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) <= 1;
  WR7: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
       
  WR8: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to top of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
  WR9: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to left of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to left of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR10: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to top of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR11: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to right of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to right of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
 WR12: NOT((SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to top of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1) AND
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'material to bottom of terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 1)) 
   OR
       (SIZEOF (QUERY (am <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'material to top of terminal') OR
       (sar\shape_aspect_relationship.name = 'material to bottom of terminal')
       ) |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN
       TYPEOF (am.relating_shape_aspect))
       )) = 2);
END_ENTITY;

ENTITY printed_part_template_connected_terminals_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
WHERE
  WR1: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       ('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF (mct.related_shape_aspect)) AND
       (mct.related_shape_aspect\shape_aspect.description IN 
       ['interface terminal', 'join terminal']))) >= 2;
END_ENTITY;

ENTITY printed_part_template_link
  SUBTYPE OF (stratum_technology_link,product_definition_relationship);
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\printed_part_template_link || SELF\property_definition ||
       SELF\stratum_technology_link || SELF\product_definition_relationship)) = 0;
  WR3: 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN 
    TYPEOF(SELF\product_definition_relationship.related_product_definition);
  WR4: 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PART_TEMPLATE_DEFINITION' IN 
    TYPEOF(SELF\product_definition_relationship.relating_product_definition);
  WR5: SELF\product_definition_relationship.name = '';
  WR6: SELF\product_definition_relationship.description = '';
  WR7: SELF\product_definition_relationship.related_product_definition.description =
       'printed part template';
  WR8: SELF\product_definition_relationship.relating_product_definition.description =
       'printed part template';
END_ENTITY;

ENTITY printed_part_template_material
 SUBTYPE OF (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF (QUERY (tu <* QUERY (pdr <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'technology usage') |
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'STRATUM_TECHNOLOGY' IN 
       TYPEOF (tu.relating_property_definition.definition))) = 1)) = 1;
  WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sr_pdr <* QUERY (pdr <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'REPRESENTATION' IN 
       TYPEOF (pdr.used_representation)) |
       ((sr_pdr.used_representation\representation.name = 
                'physical characteristics representation')
       AND
       (SIZEOF (sr_pdr.used_representation.items) = 2 )
       AND 
      ( SIZEOF(QUERY (it <* sr_pdr.used_representation.items |
       it\representation_item.name IN ['maximum width', 
                                        'minimum width'])) = 2 ))
       )) = 1)))
       = 0;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\product_definition ||
       SELF\printed_part_template_material)) = 0;
 WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'top')))) <= 1))) = 0;
 WR5: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'bottom')))) <= 1))) = 0;
 WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'left')))) <= 1))) = 0;
 WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (sa <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT.OF_SHAPE') |
       (('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (sa)) AND (sa.description = 'right')))) <= 1))) = 0;
END_ENTITY;

ENTITY printed_part_template_material_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.related_shape_aspect, 
       SELF\shape_aspect_relationship.relating_shape_aspect;
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
  WR2: 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (SELF\shape_aspect_relationship.related_shape_aspect);
  WR3: 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN
       TYPEOF (SELF\shape_aspect_relationship.relating_shape_aspect);
  WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\shape_aspect_relationship ||
       SELF\printed_part_template_material_link)) = 0;
  WR5: SELF\shape_aspect.name = '';
  WR6: SELF\shape_aspect_relationship.name = '';
  WR7: SELF\shape_aspect_relationship.related_shape_aspect.of_shape :<>: 
       SELF\shape_aspect_relationship.relating_shape_aspect.of_shape;
  WR8: SELF\shape_aspect_relationship.relating_shape_aspect.description IN
       ['bottom', 'right'];
  WR9: SELF\shape_aspect_relationship.related_shape_aspect.description IN
       ['top', 'left'];
END_ENTITY; 

ENTITY printed_part_template_terminal
  SUPERTYPE OF (printed_part_cross_section_template_terminal)
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.description IN ['interface terminal', 'join terminal'];
  WR2: SIZEOF (QUERY (ga <* USEDIN (SELF, 
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN
       TYPEOF (ga.assigned_group))) = 1;
  WR3: SIZEOF (QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       sar.related_shape_aspect\shape_aspect.description = 
       'connection zone')) >= 1;
  WR4: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_REPRESENTATION' IN
       TYPEOF (pdr.used_representation))) >= 1))) = 0;
  WR5: SIZEOF ((SELF\shape_aspect.of_shape.definition\product_definition.description = 'printed part template')
       OR
       (SELF\shape_aspect.of_shape.definition\product_definition.description = 'printed connector template'))
        = 1;
  WR6: SIZEOF (QUERY (mct <* QUERY (sar <* USEDIN (SELF,
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       sar\shape_aspect_relationship.name = 'member connected terminal') |
       'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION' IN
       TYPEOF (mct.relating_shape_aspect))) <= 1;
END_ENTITY;

ENTITY printed_part_template_terminal_connection_zone_category
   SUBTYPE OF (group);
WHERE
   WR1: SELF\group.name IN ['area edge segment','curve edge segment',
        'surface area','surface point'];
END_ENTITY;

ENTITY template_material_cross_section_boundary
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\template_material_cross_section_boundary)) = 0;
  WR2: 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
       'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF 
       (SELF.of_shape\property_definition.definition);
  WR3: SELF\shape_aspect.description IN
       ['top', 'left', 'right', 'bottom'];
END_ENTITY;
(* invalid csa
RULE printed_connector_template_terminal_relationship_unique_constraint FOR
 ( printed_connector_template_terminal_relationship );
LOCAL
  ptd_bag : BAG OF part_template_definition := [];
  pcttr_bag : BAG OF printed_connector_template_terminal_relationship;
  sar_bag : BAG OF shape_aspect_relationship;
  pass1 : BOOLEAN := TRUE;
  jt_bag : BAG OF printed_part_template_terminal;
  pass2 : BOOLEAN := TRUE;
  it_bag : BAG OF printed_part_template_terminal;
END_LOCAL;

REPEAT i := 1 to 
        SIZEOF(printed_connector_template_terminal_relationship) by 1;
  sar_bag := QUERY( sar <* 
          USEDIN( printed_connector_template_terminal_relationship[i],
'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
  ((sar\shape_aspect_relationship.name = 'connector') AND
('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.description = 'printed connector template')) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].relating_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].relating_shape_aspect IN ptd_bag )) THEN
        ptd_bag := ptd_bag + sar_bag[j].relating_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ptd_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  sar_bag := QUERY( sar <* USEDIN( ptd_bag[i],
'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT' ) | 
  (sar\shape_aspect_relationship.name = 'connector') );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    pcttr_bag := 
   QUERY( pcttr <* printed_connector_template_terminal_relationship |
(pcttr :=: sar_bag[j].related_shape_aspect) );
    REPEAT k := 1 to SIZEOF(pcttr_bag) by 1;
      IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
      END_IF;
      IF ( pass1 AND (
'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
'PRINTED_PART_TEMPLATE_TERMINAL' IN 
TYPEOF(pcttr_bag[k].relating_shape_aspect))
AND (pcttr_bag[k].relating_shape_aspect\shape_aspect.description = 'join terminal') )
                                                    THEN
        IF EXISTS( pcttr_bag[k].relating_shape_aspect ) THEN
          IF ( pcttr_bag[k].relating_shape_aspect IN jt_bag ) THEN
            pass1 := FALSE;
            ESCAPE;
          ELSE
            jt_bag := jt_bag + pcttr_bag[k].relating_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
      IF ( pass2 AND (
'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 
'PRINTED_PART_TEMPLATE_TERMINAL' IN 
TYPEOF(pcttr_bag[k].related_shape_aspect))
AND (pcttr_bag[k].related_shape_aspect\shape_aspect.description = 'interface terminal') )
                                                      THEN
        IF EXISTS( pcttr_bag[k].related_shape_aspect ) THEN
          IF ( pcttr_bag[k].related_shape_aspect IN it_bag ) THEN
            pass2 := FALSE;
            ESCAPE;
          ELSE
            it_bag := it_bag + pcttr_bag[k].related_shape_aspect;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;
*)
RULE printed_part_template_terminal_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'printed part template terminal relationship')
       AND NOT('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN 
        TYPEOF(sar.related_shape_aspect)
       ))) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'printed part template terminal relationship')
       AND NOT('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN 
       TYPEOF(sar.relating_shape_aspect)
       ))) = 0;
END_RULE;

RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint
FOR ( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.'
       + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN
       TYPEOF(sar.relating_shape_aspect)) AND
       (sar.relating_shape_aspect\shape_aspect.description = 'scalar terminal'))
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'functional terminal allocation')
       AND NOT(('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.'
       + 'PRINTED_PART_TEMPLATE_TERMINAL' IN
       TYPEOF(sar.related_shape_aspect)) AND
       ((sar.related_shape_aspect\shape_aspect.description = 'interface terminal')
       OR (sar.related_shape_aspect\shape_aspect.description = 'join terminal')))
       )) = 0;
END_RULE;

RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint
FOR ( shape_aspect_relationship );
LOCAL
  fuvtpptta : BAG OF shape_aspect_relationship := 
             QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'functional terminal allocation'));
  futd_bag : BAG OF functional_unit_terminal_definition := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pptt_bag : BAG OF printed_part_template_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fuvtpptta) by 1;
  IF EXISTS( fuvtpptta[i].relating_shape_aspect ) THEN
    IF ( fuvtpptta[i].relating_shape_aspect\shape_aspect.description = 
                                   'scalar terminal' ) THEN
      IF ( NOT ( fuvtpptta[i].relating_shape_aspect IN futd_bag ) ) THEN
        futd_bag := futd_bag + fuvtpptta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(futd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pptt_bag := [];
  sar_bag := QUERY( sar <* fuvtpptta |
((sar.relating_shape_aspect :=: futd_bag[i]) AND
(sar.related_shape_aspect\shape_aspect.description IN ['interface terminal',
'join terminal']) AND
('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' +
'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pptt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pptt_bag := pptt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
(* invalid csa
RULE printed_part_template_terminal_unique_constraint FOR
 ( printed_part_template_terminal );
LOCAL
  pptt : BAG OF printed_part_template_terminal := 
                QUERY( r <* printed_part_template_terminal |
(r\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pptt) by 1;
  IF EXISTS( pptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( pptt[i]\shape_aspect.name IN name_bag )) THEN
      name_bag := name_bag + pptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* pptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.'
+ 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition')
AND (sar.relating_shape_aspect\shape_aspect.description = 'printed part template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
*)
  FUNCTION printed_part_template_access_mechanisms(
    input : SET OF printed_part_template_link
  ) : SET OF printed_part_template_terminal;

    LOCAL
      pptt : SET OF printed_part_template_terminal := [];
    END_LOCAL;

    REPEAT i := 1 TO SIZEOF(input) BY 1;
      pptt := input[i].precedent_printed_part_template.raw_access_mechanisms + pptt;
      pptt := input[i].subsequent_printed_part_template.raw_access_mechanisms + pptt;
    END_REPEAT;
    RETURN(pptt);
  END_FUNCTION;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\process_property_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2126 - ISO/TS 10303-1040 Process property assignment - EXPRESS MIM
*)

SCHEMA Process_property_assignment_mim; 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   characterized_action_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (derived_property_select,
   general_property_association); 


END_SCHEMA;  -- Process_property_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_categorization_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N1100 - ISO/TS 10303-1016 Product categorization - EXPRESS MIM
*) 


SCHEMA Product_categorization_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_category_relationship); 


END_SCHEMA;  -- Product_categorization_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_concept_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1178 - ISO/TS 10303-1060 Product concept identification - EXPRESS MIM
*)
   
SCHEMA Product_concept_identification_mim;

USE FROM product_concept_schema -- ISO 10303-44
  (product_concept);
USE FROM application_context_schema -- ISO 10303-41
  (product_concept_context);

   
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_data_management_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG3 N1487 - ISO/CD-TS 10303-1231 Product data management - EXPRESS MIM
*)

SCHEMA Product_data_management_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_directive,
   action_method,
   action_relationship,
   action_request_solution,
   action_request_status,
   directed_action,
   executed_action,
   versioned_action_request); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM application_context_schema   -- ISO 10303-41
  (application_context_relationship,
   application_protocol_definition,
   product_definition_context); 

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM approval_schema   -- ISO 10303-41
  (approval,
   approval_person_organization,
   approval_relationship,
   approval_status); 

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role); 

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM certification_schema   -- ISO 10303-41
  (certification,
   certification_type); 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM Classification_assignment_mim;    -- ISO/TS 10303-1114

USE FROM classification_schema   -- ISO/DIS 10303-54
  (class,
   complete_membership_select); 

USE FROM Configuration_effectivity_mim;    -- ISO/TS 10303-1058

USE FROM Configuration_item_mim;    -- ISO/TS 10303-1056

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_effectivity,
   configuration_item); 

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM contract_schema   -- ISO 10303-41
  (contract); 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM date_time_schema   -- ISO 10303-41
  (calendar_date,
   date_and_time,
   date_role,
   date_time_role,
   event_occurrence); 

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Document_management_mim;    -- ISO/TS 10303-1290

USE FROM document_schema   -- ISO 10303-41
  (document_relationship); 

USE FROM Document_structure_mim;    -- ISO/TS 10303-1124

USE FROM Effectivity_application_mim;    -- ISO/TS 10303-1059

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM effectivity_schema   -- ISO 10303-41
  (effectivity); 

USE FROM Event_assignment_mim;    -- ISO/TS 10303-1364

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Incomplete_data_reference_mechanism_mim;    -- ISO/TS 10303-1349

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM Independent_property_representation_mim;    -- ISO/TS 10303-1038

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM management_resources_schema   -- ISO 10303-41
  (date_and_time_assignment,
   date_assignment,
   document_usage_role,
   identification_assignment,
   identification_role,
   organizational_project_role); 

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM measure_schema   -- ISO 10303-41
  (context_dependent_unit,
   conversion_based_unit,
   derived_unit,
   measure_with_unit,
   named_unit); 

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization,
   organization_relationship,
   organizational_address,
   organizational_project,
   organizational_project_relationship,
   person,
   person_and_organization); 

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM process_property_schema   -- ISO 10303-49
  (action_property); 

USE FROM Product_categorization_mim;    -- ISO/TS 10303-1016

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM product_concept_schema   -- ISO 10303-44
  (product_concept); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_formation_with_specified_source,
   product_definition_relationship); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property,
   general_property_relationship,
   property_definition,
   shape_aspect,
   shape_aspect_relationship); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 

USE FROM Product_replacement_mim;    -- ISO/TS 10303-1046

USE FROM Product_structure_mim;    -- ISO/TS 10303-1134

USE FROM product_structure_schema   -- ISO 10303-44
  (alternate_product_relationship,
   assembly_component_usage,
   assembly_component_usage_substitute); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_properties_mim;    -- ISO/TS 10303-1034

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Project_mim;    -- ISO/TS 10303-1061

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (founded_item,
   representation,
   representation_context,
   representation_item,
   uncertainty_measure_with_unit); 

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015

USE FROM security_classification_schema   -- ISO 10303-41
  (security_classification); 

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM Single_part_representation_mim;    -- ISO/TS 10303-1133

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

USE FROM Work_order_mim;    -- ISO/TS 10303-1043

USE FROM Work_request_mim;    -- ISO/TS 10303-1042


TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (configuration_effectivity, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_request_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    property_definition);
END_TYPE; 

TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action, 
    applied_action_assignment, 
    configuration_effectivity, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_certification_item = EXTENSIBLE SELECT BASED_ON certification_item WITH 
   (product_definition_formation_relationship);
END_TYPE; 

TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_property, 
    action_relationship, 
    action_request_solution, 
    action_request_status, 
    address, 
    alternate_product_relationship, 
    applied_action_assignment, 
    applied_action_request_assignment, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    assembly_component_usage_substitute, 
    calendar_date, 
    certification, 
    class, 
    configuration_item, 
    context_dependent_unit, 
    contract, 
    conversion_based_unit, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    descriptive_representation_item, 
    directed_action, 
    document_file, 
    document_relationship, 
    effectivity, 
    event_occurrence, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    group, 
    identification_assignment, 
    language, 
    measure_representation_item, 
    measure_with_unit, 
    multi_language_attribute_assignment, 
    named_unit, 
    organization, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization_address, 
    product, 
    product_category, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    security_classification, 
    uncertainty_measure_with_unit, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action, 
    applied_action_assignment, 
    executed_action, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action, 
    applied_action_assignment, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_method, 
    executed_action, 
    product_definition_formation_relationship, 
    shape_aspect, 
    shape_aspect_relationship, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE pdm_external_class_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (assembly_component_usage, 
    external_class_library);
END_TYPE; 

TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (shape_aspect_relationship);
END_TYPE; 

TYPE pdm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_category, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
END_TYPE; 

TYPE pdm_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (executed_action, 
    product_concept);
END_TYPE; 

TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (assembly_component_usage);
END_TYPE; 

END_SCHEMA;  -- Product_data_management_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_identification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2926 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2525
*) 


SCHEMA Product_identification_mim; 

USE FROM Product_categorization_mim;    -- ISO/TS 10303-1016

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_related_product_category); 


END_SCHEMA;  -- Product_identification_mim






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_identification_extension_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3586 - ISO/CD-TS 10303-1738 Product identification extension - EXPRESS MIM
*)


SCHEMA Product_identification_extension_mim;
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	USE FROM Product_view_definition_mim;	-- ISO/TS 10303-1019
	
	USE FROM External_reference_schema
		(externally_defined_item,
		external_source);
	
TYPE pie_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (externally_defined_product_definition);
END_TYPE; 

ENTITY externally_defined_product_definition
 SUPERTYPE OF (library_defined_product_definition)
 SUBTYPE OF (product_definition, externally_defined_item);
END_ENTITY;

ENTITY library_defined_product_definition
 SUBTYPE OF (externally_defined_product_definition);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_replacement_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1145 - ISO/TS 10303-1046 Product replacement - EXPRESS MIM
*)
    
SCHEMA Product_replacement_mim;

USE FROM Assembly_structure_mim; -- ISO 10303-1026
USE FROM Product_identification_mim; -- ISO 10303-1017

USE FROM product_structure_schema -- ISO 10303-44
  (alternate_product_relationship,
   assembly_component_usage_substitute);
END_SCHEMA;






(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_rule_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3589 - ISO/CD-TS 10303-1739 Product rule - EXPRESS MIM
*)


SCHEMA Product_rule_mim;
	USE FROM Model_parameter_mim;	-- ISO/TS 10303-1703
	USE FROM Specification_document_mim;    --  ISO/CD-TS 10303-1747
	USE FROM Software_mim;	-- ISO/TS 10303-1746
	USE FROM Product_identification_mim; -- ISO/TS 10303-1017
	
	USE FROM Date_time_assignment_mim; -- ISO/TS 10303-1014
	USE FROM Activity_mim; -- ISO/TS 10303-1047
	
	USE FROM Product_definition_schema(product_definition_relationship);

TYPE pr_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
     (rule_set);
END_TYPE; 

TYPE pr_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
     (product_definition_formation);
END_TYPE; 

TYPE pr_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
     (rule_action);
END_TYPE; 

TYPE pr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (rule_function_definition,
   representation);
END_TYPE; 

TYPE rule_superseded_item = SELECT
     (product_definition_formation);
END_TYPE;

ENTITY rule_action
  SUBTYPE OF (action);
WHERE
  WR1: SIZEOF (QUERY (aaa <* QUERY (aa <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' + 
       'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
       'PRODUCT_RULE_MIM.' +
       'APPLIED_ACTION_ASSIGNMENT' IN
       TYPEOF (aa)) |
       SIZEOF (QUERY (it <* aaa.items |
       (('PRODUCT_RULE_MIM.' +
       'PRODUCT_DEFINITION_FORMATION' IN 
       TYPEOF (it))
AND (it\product_definition_formation.description = 'rule version'))
)) = 1)) = 1;
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'participant date and time')) +
       SIZEOF (QUERY (ada <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'participant date')) = 1;
  WR3: (NOT (SELF\action.name = 'rule justification')) OR
       (SIZEOF (QUERY (ja <* QUERY (ar <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'ACTION_RELATIONSHIP.RELATED_ACTION') |
       ar\action_relationship.name = 'justified action') |
       'PRODUCT_RULE_MIM.' +
       'RULE_ACTION' IN
       TYPEOF (ja.relating_action))) = 1);
  WR4: (NOT (SELF\action.name = 'rule modification')) OR
       (SIZEOF (QUERY (mr <* QUERY (ar <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'ACTION_RELATIONSHIP.RELATED_ACTION') |
       ar\action_relationship.name = 'modification rationale') |
       ('PRODUCT_RULE_MIM.' +
       'RULE_ACTION' IN
       TYPEOF (mr.relating_action)) AND
       (mr.relating_action\action.name = 'rule change request'))) = 1);
END_ENTITY;

ENTITY rule_boolean_function_definition 
 SUBTYPE OF (rule_function_definition);
 WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       'PRODUCT_RULE_MIM.' +
       'MODEL_PARAMETER' IN
       TYPEOF (it))) >= 1;
END_ENTITY;

ENTITY rule_complex_clause 
 SUBTYPE OF (representation);
UNIQUE
 UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'PRODUCT_RULE_MIM.' +
       'RULE_SIMPLE_CLAUSE' IN TYPEOF (rr.rep_1))) >= 1;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_complex_clause)) = 0;
END_ENTITY;

ENTITY rule_conclusion_definition 
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        'PRODUCT_RULE_MIM.' +
        'RULE_DEFINITION' IN TYPEOF
       (pdr.definition.definition))) = 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        'PRODUCT_RULE_MIM.' +
        'RULE_SIMPLE_CLAUSE' IN TYPEOF 
       (rr\representation_relationship.rep_1))) >= 1;

  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_conclusion_definition)) = 0;
END_ENTITY;

ENTITY rule_definition 
 SUBTYPE OF (rule_software_definition);
WHERE
  WR1: SELF\product_definition.formation.description = 'rule version';
END_ENTITY;

ENTITY rule_function_definition 
 SUPERTYPE OF (rule_boolean_function_definition)
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
       'PRODUCT_RULE_MIM.' +
       'MODEL_PARAMETER' IN
       TYPEOF (it))) >= 1;
  WR2: SIZEOF(QUERY(adf <* USEDIN(SELF,
       'PRODUCT_RULE_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adf\document_reference.assigned_document.kind\document_type.product_data_type
       = 'reference document') AND
       (SIZEOF(['PRODUCT_RULE_MIM.' +
       'EE_SPECIFICATION', 
       'PRODUCT_RULE_MIM.' +
       'DOCUMENT'] * 
        TYPEOF(adf\document_reference.assigned_document))>=1))) = 1;
  WR3: SIZEOF(QUERY(adf <* USEDIN(SELF,
       'PRODUCT_RULE_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adf\document_reference.assigned_document.kind\document_type.product_data_type =
       'source code') AND
       ('PRODUCT_RULE_MIM.' +
       'EE_SPECIFICATION' IN 
        TYPEOF(adf\document_reference.assigned_document)))) = 1;
END_ENTITY;

ENTITY rule_function_domain_parameter 
 SUBTYPE OF (model_parameter);
WHERE
  WR1: SIZEOF (QUERY (cri <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION.ITEMS') |
       ('PRODUCT_RULE_MIM.' +
       'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri)) 
       )) = 1;
END_ENTITY;

ENTITY rule_function_range_parameter 
 SUBTYPE OF (model_parameter);
WHERE
  WR1: SIZEOF (QUERY (cri <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION.ITEMS') |
       ('PRODUCT_RULE_MIM.' +
       'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri)) 
       )) = 1;
END_ENTITY;

ENTITY rule_general_clause 
 SUBTYPE OF (representation);
UNIQUE
 UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       'PRODUCT_RULE_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN
       TYPEOF (rr.rep_2))) >= 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'PRODUCT_RULE_MIM.' +
       'RULE_FUNCTION_DEFINITION' IN TYPEOF (rr.rep_1))) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_general_clause)) = 0;
END_ENTITY;

ENTITY rule_premise_definition 
 SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
        'PRODUCT_RULE_MIM.' +
        'RULE_DEFINITION' IN TYPEOF
       (pdr.definition.definition))) = 1;

  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
        'PRODUCT_RULE_MIM.' +
        'RULE_COMPLEX_CLAUSE' IN TYPEOF 
       (rr\representation_relationship.rep_1))) >= 1;

  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_premise_definition)) = 0;
END_ENTITY;

ENTITY rule_superseded_assignment
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF rule_superseded_item;
END_ENTITY;

ENTITY rule_set 
 SUBTYPE OF (rule_software_definition);
END_ENTITY;

ENTITY rule_software_definition 
 SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY rule_set_group
SUBTYPE OF (rule_software_definition);
WHERE
  WR1: SIZEOF (QUERY (rsge <* QUERY (gr <* USEDIN (SELF, 
       'PRODUCT_RULE_MIM.' + 
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       gr\product_definition_relationship.name = 'rule set group element') |
       'PRODUCT_RULE_MIM.' +
       'RULE_SET' IN
       TYPEOF (rsge.related_product_definition))) >= 1;
END_ENTITY;

ENTITY rule_simple_clause 
 SUBTYPE OF (representation);
UNIQUE
 UR1: SELF\representation.name;
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_1') |
       'PRODUCT_RULE_MIM.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN
       TYPEOF (rr.rep_2))) >= 1;
  WR2: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'PRODUCT_RULE_MIM.' + 
       'REPRESENTATION_RELATIONSHIP.REP_2') | 
       'PRODUCT_RULE_MIM.' +
       'RULE_BOOLEAN_FUNCTION_DEFINITION' IN TYPEOF (rr.rep_1))) = 1;
  WR3: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\rule_simple_clause)) = 0;
END_ENTITY;

  ENTITY rule_supersedence
    SUBTYPE OF (rule_action);
  END_ENTITY;

RULE rule_action_unique_constraint FOR
 ( rule_action );
LOCAL
  adta : BAG OF applied_date_and_time_assignment;
  adta_bag : BAG OF applied_date_and_time_assignment := [];
  ra_bag : BAG OF rule_action;
  aaa_bag : BAG OF applied_action_assignment;
  pass : BOOLEAN := TRUE;
  rd_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_action) by 1;
  adta := USEDIN( rule_action[i], 
'PRODUCT_RULE_MIM.' +
'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' );
  REPEAT j := 1 to SIZEOF(adta) by 1;
    IF EXISTS( adta[j] ) THEN
      IF( NOT( adta[j] IN adta_bag ) ) THEN
        adta_bag := adta_bag + adta[j];
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(adta_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ra_bag := QUERY( r <* rule_action | (r IN adta_bag[i].items) );
  rd_bag := [];
  REPEAT j := 1 to SIZEOF(ra_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aaa_bag := QUERY( aa <* USEDIN( ra_bag[j], 
'PRODUCT_RULE_MIM.' +
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) | 
(('PRODUCT_RULE_MIM.' +
'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa) ) );
    REPEAT k := 1 to SIZEOF(aaa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(aaa_bag[k].items) by 1;
        IF EXISTS( aaa_bag[k].items[l] ) THEN
          IF ( ('PRODUCT_RULE_MIM.' +
'PRODUCT_DEFINITION_FORMATION'  IN TYPEOF(aaa_bag[k].items[l])) AND
(aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') ) THEN
            IF ( aaa_bag[k].items[l] IN rd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              rd_bag := rd_bag + aaa_bag[k].items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE rule_conclusion_definition_unique_constraint FOR 
(rule_conclusion_definition,
representation,representation_relationship);
LOCAL
r : BAG of representation := 
           QUERY (r <* representation | r\representation.name = 
                                             'rule definition');
rr : BAG OF representation_relationship := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
name_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   count := 0;
   name_bag := [];
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr := USEDIN(r[i],
 'PRODUCT_RULE_MIM.' +
        'REPRESENTATION_RELATIONSHIP.REP_1');
   REPEAT j := 1 to SIZEOF (rr) by 1;
    IF 'PRODUCT_RULE_MIM.' +
       'RULE_CONCLUSION_DEFINITION' IN
       TYPEOF (rr[j].rep_2)
    THEN
      IF EXISTS( rr[j].rep_2\representation.name ) THEN
        IF rr[j].rep_2\representation.name IN name_bag
        THEN
         pass := FALSE;
        ELSE
         name_bag := name_bag + rr[j].rep_2\representation.name;
        END_IF;
      END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE rule_function_unique_constraint FOR
 ( rule_function_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  rfd_bag : BAG OF rule_function_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_function_definition) by 1;
  IF EXISTS( rule_function_definition[i]\representation.name ) THEN
    IF( NOT( rule_function_definition[i]\representation.name IN name_bag ) ) THEN
      name_bag := name_bag + rule_function_definition[i]\representation.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  doc_bag := [];
  rfd_bag := QUERY( am <* rule_function_definition | 
               (am\representation.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(rfd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( rfd_bag[j],
'PRODUCT_RULE_MIM.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) |
(adr.assigned_document.kind\document_type.product_data_type = 'reference document') );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition,
representation,representation_relationship);
local
rr : BAG OF representation_relationship := [];
rpd : BAG OF rule_premise_definition := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (rule_premise_definition) by 1;
   count := 0;
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr :=
USEDIN(rule_premise_definition[i],'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2');
    REPEAT j := 1 to SIZEOF (rr) by 1;
     IF NOT pass THEN ESCAPE;
     END_IF;
     IF (rr[j]\representation_relationship.rep_1\representation.description IN
              ['rule definition']) THEN
     count := count + 1;
     END_IF;
     IF count = 2 THEN pass := FALSE;
     END_IF;
    END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_structure_mim.exp
   ------------------------------------------------------------
*)

(*
ISO TC184/SC4/WG12 N2547 - ISO/TS 10303-1134 Product structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1671
*) 


SCHEMA Product_structure_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Contextual_shape_positioning_mim;    -- ISO/TS 10303-1027

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Part_definition_relationship_mim;    -- ISO/TS 10303-1055

USE FROM Product_replacement_mim;    -- ISO/TS 10303-1046

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Single_part_representation_mim;    -- ISO/TS 10303-1133

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_structure_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_version_mim.exp
   ------------------------------------------------------------
*)

(* 
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1106
*) 


SCHEMA Product_version_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation); 


END_SCHEMA;  -- Product_version_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_version_relationship_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1130 - ISO/TS 10303-1020 Product version relationship - EXPRESS MIM
*)
   
SCHEMA Product_version_relationship_mim;

USE FROM Product_version_mim; 	--ISO 10303-1018

USE FROM product_definition_schema 	-- ISO 10303-41
  (product_definition_formation_relationship);
   
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_view_definition_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2928 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
*) 


SCHEMA Product_view_definition_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (product_definition_context); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (name_attribute,
   name_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_context_association); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_view_definition_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_view_definition_properties_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3228 - ISO/TS 10303-1034 Product view definition properties - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2127
*) 


SCHEMA Product_view_definition_properties_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


END_SCHEMA;  -- Product_view_definition_properties_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\product_view_definition_relationship_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1142 - ISO/TS 10303-1041 Product view definition relationship - EXPRESS MIM
*)

SCHEMA Product_view_definition_relationship_mim;

USE FROM Product_view_definition_mim; -- ISO 10303-1019
USE FROM product_definition_schema -- ISO 10303-41
  (product_definition_relationship);

USE FROM product_structure_schema -- ISO 10303-44
  (product_definition_usage);
END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\project_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2112 - ISO/TS 10303-1061 Project - EXPRESS MIM
*) 


SCHEMA Project_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM Event_assignment_mim;    -- ISO/TS 10303-1364

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (organizational_project_assignment,
   organizational_project_role); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organizational_project,
   organizational_project_relationship); 


TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_as_date_item = SELECT BASED_ON date_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;

END_SCHEMA;  -- Project_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\promissory_usage_in_product_concept_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3683 - ISO/TS 10303-1758 Promissory usage in product concept - EXPRESS MIM
*)

SCHEMA Promissory_usage_in_product_concept_mim;

	USE FROM Configuration_item_mim;	-- ISO/TS 10303-1056
	USE FROM Security_classification_mim;	-- ISO/TS 10303-1015

TYPE puipc_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
     (promissory_usage_in_product_concept_relationship);
END_TYPE;

 ENTITY promissory_usage_in_product_concept_relationship
  SUBTYPE OF (configuration_item);
 END_ENTITY;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\property_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2129 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
*) 


SCHEMA Property_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property_association,
   property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 


END_SCHEMA;  -- Property_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\requirement_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3125 - ISO/TS 10303-1233 Requirement assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2346
*) 


SCHEMA Requirement_assignment_mim;

USE FROM group_schema   -- ISO 10303-41
  (group); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141


TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY assigned_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF product_definition;
END_ENTITY;

ENTITY requirement_assigned_object
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF requirement_assigned_item;
END_ENTITY;

ENTITY requirement_assignment
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY requirement_source
  SUBTYPE OF (group);
END_ENTITY;

ENTITY source_for_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF requirement_source_item;
END_ENTITY;

ENTITY sourced_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF product_definition;
END_ENTITY;

END_SCHEMA;  -- Requirement_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\requirement_decomposition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3592 - ISO/CD-TS 10303-1740 Requirement decomposition - EXPRESS MIM
*)


SCHEMA Requirement_decomposition_mim;

	USE FROM Conductivity_material_aspects_mim;	-- ISO/TS 10303-1756
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004
	USE FROM Functional_specification_mim;	-- ISO/TS 10303-1679
	USE FROM Product_rule_mim;	-- ISO/TS 10303-1739
	
	USE FROM Material_property_definition_schema(property_definition_relationship);	

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 
	

TYPE rd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (requirements_property);
END_TYPE; 

TYPE rd_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (requirements_property);
END_TYPE;
	
ENTITY material_electrical_conductivity_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN ['conductive', 'non conductive', 'resistive',  
       'semi conductive'];
END_ENTITY;

ENTITY requirements_property
  SUBTYPE OF (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'requirements property composition')) <= 1;
  WR2: SIZEOF (QUERY (pdr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       SIZEOF (QUERY (it <* pdr.used_representation.items |
       ('REQUIREMENT_DECOMPOSITION_MIM.' +
       'DESCRIPTIVE_REPRESENTATION_ITEM' IN
       TYPEOF (it)) AND
       (it\representation_item.name = 'requirements description'))) = 1)) <= 1;
  WR3: SIZEOF (QUERY (dr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'EE_SPECIFICATION' IN 
       TYPEOF (dr.assigned_document))) >= 1;
  WR4: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description IN ['constraint', 
        'part based constraint']) OR
       (SIZEOF (QUERY (dc <* QUERY (pdr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'design constraint') |
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'RULE_DEFINITION' IN 
       TYPEOF (dc.relating_property_definition.definition))) = 1));
  WR5: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description = 
          'part based constraint') OR
       (SIZEOF (QUERY (cp <* QUERY (pdr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'constraining part') |
       ('REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP' IN
       TYPEOF (cp.relating_property_definition.definition)) AND
       (cp.relating_property_definition.definition\product_definition_relationship.name = 
       'constraining part') AND
   (cp.relating_property_definition.definition.related_product_definition.
       frame_of_reference.name = 'design requirement'))) = 1));
  WR6: NOT(EXISTS(SELF\property_definition.description)) OR
       (NOT (SELF\property_definition.description = 
         'interface requirement') OR
       (SIZEOF (QUERY (itnha <* QUERY (pdr <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       pdr\property_definition_relationship.name = 'interface to next higher assembly') |
       ('REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_DEFINITION' IN
       TYPEOF (itnha.relating_property_definition.definition)) AND
    (itnha.relating_property_definition.definition.frame_of_reference.name
       = 'design requirement') AND
       (SIZEOF (QUERY (hai <* QUERY (pdr <* 
       USEDIN (itnha.relating_property_definition.definition,
       'REQUIREMENT_DECOMPOSITION_MIM.' + 
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'higher assembly interface') |
       SIZEOF (QUERY (pdr <* USEDIN (hai,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'SPECIFIED_HIGHER_USAGE_OCCURRENCE'  
       IN TYPEOF (pdr))) = 1)) = 1))) = 1));
END_ENTITY;

(** It is declared as used for ARM concept Requirement_allocation, which is now substituted by requirement_assignment.
Need to analyse more on this *)
ENTITY requirement_allocation_group
  SUBTYPE OF (group, property_definition_relationship);
WHERE
  WR1: (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (['REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT',
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_DEFINITION_FORMATION',
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'CONFIGURATION_ITEM'] * TYPEOF (aga.items)) = 1))) = 1);

  WR2: 'REQUIREMENT_DECOMPOSITION_MIM.' +
       'REQUIREMENTS_PROPERTY' IN TYPEOF 
   (SELF\property_definition_relationship.relating_property_definition);

  WR3: NOT(SELF\property_definition_relationship.related_property_definition.description = 'test requirement') OR
       (SIZEOF (QUERY (aga <* QUERY (ga <* USEDIN (SELF,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'GROUP_ASSIGNMENT.ASSIGNED_GROUP') |
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_GROUP_ASSIGNMENT' IN
       TYPEOF (ga)) |
       (SIZEOF (['REQUIREMENT_DECOMPOSITION_MIM.' +
       'PROPERTY_DEFINITION_REPRESENTATION'] * TYPEOF (aga.items)) = 1))) >= 1);
END_ENTITY;

ENTITY requirement_definition
 SUBTYPE OF (product_definition);
WHERE
  WR1: (NOT ('REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN 
       TYPEOF (SELF))) OR
       (SIZEOF (QUERY (docs <* 
       SELF\product_definition_with_associated_documents.
        documentation_ids |
       docs.kind\document_type.product_data_type = 'CAD filename')) <= 1);
  WR2: SIZEOF (QUERY (adta <* USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' + 
       'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS') |
       adta.role\date_time_role.name = 'creation date')) + 
       SIZEOF (QUERY (ada <* USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' + 
       'APPLIED_DATE_ASSIGNMENT.ITEMS') |
       ada.role\date_role.name = 'creation date')) = 1;
  WR3: SIZEOF (USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 1;
  WR4: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'creator')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'creator')) >= 1;
  WR5: SIZEOF (USEDIN (SELF, 
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
  WR6: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\product_definition ||
       SELF\requirement_definition))) = 0;
  WR7: SIZEOF (QUERY (prpc <* USEDIN (SELF.formation.of_product,
       'REQUIREMENT_DECOMPOSITION_MIM.' +
       'PRODUCT_RELATED_PRODUCT_CATEGORY.' +
       'PRODUCTS') |
       prpc\product_category.name = 'requirements model')) >= 1;
END_ENTITY;

RULE operational_requirement_occurrence_relationship_constraint FOR
( property_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* property_definition_relationship |
       ((pdr\property_definition_relationship.name = 'and operation')
        OR (pdr\property_definition_relationship.name = 'or operation'))
       AND NOT('REQUIREMENT_DECOMPOSITION_MIM.'
        + 'REQUIREMENTS_PROPERTY' IN 
                             TYPEOF(pdr.related_property_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(pdr <* property_definition_relationship |
       ((pdr\property_definition_relationship.name = 'and operation')
        OR (pdr\property_definition_relationship.name = 'or operation'))
       AND NOT('REQUIREMENT_DECOMPOSITION_MIM.'
        + 'REQUIREMENTS_PROPERTY' IN 
                           TYPEOF(pdr.relating_property_definition))
       )) = 0;
END_RULE;

RULE requirements_property_constraint FOR 
           (product_definition,
            descriptive_representation_item,
            requirements_property);
LOCAL
ri : BAG OF descriptive_representation_item := 
         QUERY (dri <* descriptive_representation_item 
                              | dri\representation_item.name = 
                                          'requirements name');
pd : BAG OF product_definition:=
         QUERY(tpd <* product_definition
               | ('REQUIREMENT_DECOMPOSITION_MIM.' +
                  'APPLICATION_CONTEXT_ELEMENT' IN
                  TYPEOF(tpd.frame_of_reference)) AND
                  (tpd.frame_of_reference.name IN ['requirement',
                                                   'design requirement',
                                                   'assembly requirement'])
                  AND
                  (tpd.name = 'requirements model'));

r : BAG OF representation := [];
pdr : BAG OF property_definition_representation := [];
pass1 : BOOLEAN := TRUE;

rp : BAG OF property_definition := [];
pass2 : BOOLEAN := TRUE;

END_LOCAL;
  (* WR1 Test *)
  REPEAT i := 1 to SIZEOF (ri) by 1;
     r := [];
     pdr := [];
     r := (USEDIN(ri[i],
         'REQUIREMENT_DECOMPOSITION_MIM.' +
             'REPRESENTATION.ITEMS'));
     pass1 := (SIZEOF(r) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pdr := (USEDIN(r[1],
             'REQUIREMENT_DECOMPOSITION_MIM.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
     pass1 := (SIZEOF(pdr) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pass1 := ('REQUIREMENT_DECOMPOSITION_MIM.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition));
     IF (NOT pass1) THEN ESCAPE; END_IF;
  END_REPEAT;
  (* WR2 Test *)
  REPEAT i := 1 to SIZEOF (pd) by 1;
     rp := [];
     IF (NOT pass2) THEN ESCAPE; END_IF;
     rp := QUERY(rp <* USEDIN(pd[i],
             'REQUIREMENT_DECOMPOSITION_MIM.' +
             'PROPERTY_DEFINITION.DEFINITION') |
             'REQUIREMENT_DECOMPOSITION_MIM.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
     pass2 := (SIZEOF(rp) = 1);
  END_REPEAT;
WHERE
 WR1: pass1;
 WR2: pass2;
END_RULE;

RULE requirements_property_unique_constraint FOR 
           (descriptive_representation_item,
            requirements_property);
LOCAL
desc_bag : BAG OF STRING := [];
pass1 : BOOLEAN := TRUE;
pdr : BAG OF property_definition_representation := [];
rep : BAG OF representation := [];
pd : BAG OF product_definition := [];

END_LOCAL;
  REPEAT i := 1 to SIZEOF (requirements_property) by 1;
     IF (NOT pass1) THEN ESCAPE; END_IF;
     IF ('REQUIREMENT_DECOMPOSITION_MIM.' +
         'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition))
      THEN pd := pd + requirements_property[i].definition;
     END_IF;
  END_REPEAT;
  IF (instance_unique(pd) = FALSE ) THEN pass1 := FALSE; END_IF;
WHERE
 WR1: pass1;
END_RULE;

FUNCTION instance_unique 

      ( the_bag : BAG OF GENERIC : intype ) : BOOLEAN;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;
      pass : BOOLEAN := TRUE;
END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
                  the_set := bag_to_set(the_bag);
      END_IF ;
      IF NOT(SIZEOF(the_set) = SIZEOF(the_bag)) THEN
       pass := FALSE;
      END_IF;

      RETURN (pass);

END_FUNCTION ;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\requirement_identification_and_version_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3128 - ISO/TS 10303-1140 Requirement identification and version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2348
*) 


SCHEMA Requirement_identification_and_version_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition_formation); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020


TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Requirement_identification_and_version_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\requirement_view_definition_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3134 - ISO/TS 10303-1141 Requirement view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2355
*) 


SCHEMA Requirement_view_definition_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Requirement_identification_and_version_mim;    -- ISO/TS 10303-1140


END_SCHEMA;  -- Requirement_view_definition_mim




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\requirement_view_definition_relationship_mim.exp
   ------------------------------------------------------------
*)

(* 
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N3137 - ISO/TS 10303-1142 Requirement view definition relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2358
*) 


SCHEMA Requirement_view_definition_relationship_mim;

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141


END_SCHEMA;  -- Requirement_view_definition_relationship_mim



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\security_classification_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1097 - ISO/TS 10303-1015 Security classification - EXPRESS MIM
*)

SCHEMA Security_classification_mim;

USE FROM security_classification_schema -- ISO 10303-41
  (security_classification,
   security_classification_level);
USE FROM management_resources_schema -- ISO 10303-41
  (security_classification_assignment);
  
TYPE security_classification_item = EXTENSIBLE SELECT; 
END_TYPE;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;

END_SCHEMA;








(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\sequential_laminate_assembly_design_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3595 - ISO/CD-TS 10303-1741 Sequential laminate assembly design - EXPRESS MIM
*)


SCHEMA Sequential_laminate_assembly_design_mim;
	USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	
ENTITY interconnect_module_stratum_based_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY;

ENTITY sequential_laminate_passage_based_fabrication_joint
  SUBTYPE OF (shape_aspect);
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\shape_composition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3598 - ISO/CD-TS 10303-1742 Shape composition - EXPRESS MIM
*)


SCHEMA Shape_composition_mim;
	USE FROM Shape_property_assignment_mim;	-- ISO/TS 10303-1032
	
	USE FROM Shape_aspect_definition_schema(composite_shape_aspect);
--	USE FROM Product_property_definition_schema;
	USE FROM Shape_dimension_schema (dimensional_location);
	
ENTITY composite_group_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY composite_unit_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

RULE composite_shape_element_constraint FOR
  (composite_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(csa <* composite_shape_aspect |
        SIZEOF(QUERY(sar <* USEDIN(csa,
       'SHAPE_COMPOSITION_MIM.'
        + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name = 'composing')
        )) < 2)) = 0;
  WR2: SIZEOF(QUERY(csa <* composite_shape_aspect |
        NOT ((SIZEOF(TYPEOF(csa)) > 2) OR 
        (csa\shape_aspect.description <> '') OR 
        (csa\shape_aspect.name <> ''))
        )) = 0;
END_RULE;

RULE shape_element_composing_relationship_constraint FOR
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'composing') AND
       ('SHAPE_COMPOSITION_MIM.'
       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       )) = 0;
END_RULE;

RULE shape_element_constituent_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name IN [
'constituent', 'composing', 
'bare die terminal surface constituent relationship',
'interconnect module terminal surface constituent relationship',
'package terminal surface constituent relationship'] ) );
  sa_bag : BAG OF shape_aspect := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i].relating_shape_aspect ) THEN
    IF( NOT( sar[i].relating_shape_aspect IN sa_bag ) ) THEN
      sa_bag := sa_bag + sar[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE shape_element_locating_relationship_unique_constraint FOR
 ( dimensional_location );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  dl_bag : BAG OF dimensional_location;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF EXISTS( dimensional_location[i].relating_shape_aspect ) THEN
    IF( NOT( dimensional_location[i].relating_shape_aspect IN sa_bag ) )
                                                              THEN
      sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  dl_bag := QUERY( r <* dimensional_location | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(dl_bag) by 1;
    IF EXISTS( dl_bag[j].related_shape_aspect ) THEN
      IF ( dl_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE subtype_mandatory_composite_shape_aspect FOR
  (composite_shape_aspect);
WHERE  
  WR1: SIZEOF (QUERY (csa <* composite_shape_aspect |
       NOT (SIZEOF
       (['SHAPE_COMPOSITION_MIM.' +
       'COMPOSITE_GROUP_SHAPE_ASPECT',
       'SHAPE_COMPOSITION_MIM.' +
       'COMPOSITE_UNIT_SHAPE_ASPECT']
       * TYPEOF(csa)) = 1))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\shape_parameters_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3601 - ISO/CD-TS 10303-1743 Shape parameters - EXPRESS MIM
*)


SCHEMA Shape_parameters_mim;
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	
	USE FROM Product_property_definition_schema(characterized_object);
	
ENTITY keepout_design_object_category
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SELF\characterized_object.description IN 
       ['assembly module assembly component category',
        'component feature category',
        'assembly ee material category',
        'interconnect ee material category',
        'interconnect module assembly component category',
        'via category',
        'inter stratum feature category',
        'cutout category',
        'fill area category',
        'laminate component category',
        'stratum feature category'];
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\shape_property_assignment_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N1226 - ISO/TS 10303-1032 Shape property assignment - EXPRESS MIM
*) 


SCHEMA Shape_property_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute); 

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM External_model_mim;    -- ISO/TS 10303-1033

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object,
   product_definition_shape,
   shape_aspect,
   shape_aspect_relationship); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_definition_representation); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041


END_SCHEMA;  -- Shape_property_assignment_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\shield_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3604 - ISO/CD-TS 10303-1744 Shield - EXPRESS MIM
*)


SCHEMA Shield_mim;

	USE FROM Assembly_component_placement_requirements_mim;	-- ISO/TS 10303-1634
	USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700

ENTITY discrete_shield
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SELF.frame_of_reference.name = 'physical occurrence';
  WR2: SIZEOF (QUERY (si <* QUERY (pdr <* USEDIN (SELF,
       'SHIELD_MIM.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       pdr\product_definition_relationship.name = 'shielded item') |
       'SHIELD_MIM.' +
       'COMPONENT_DEFINITION' IN
       TYPEOF (si.relating_product_definition))) >= 1;
END_ENTITY;

ENTITY integral_shield
  SUBTYPE OF (assembly_component);
WHERE
  WR1: SIZEOF (QUERY(pdr <* USEDIN(SELF,
       'SHIELD_MIM.' +
       'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (('SHIELD_MIM.' +
       'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_property_definition))
       OR ('SHIELD_MIM.' +
    'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_property_definition)))
       AND (pdr\property_definition_relationship.name = 'shielded item'))) >=1;
END_ENTITY;

ENTITY routed_shield
  SUBTYPE OF (routed_printed_component);
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\signal_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3607 - ISO/CD-TS 10303-1745 Signal - EXPRESS MIM
*)


SCHEMA Signal_mim;
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	
	USE FROM Product_property_definition_schema
		(characterized_object,
		property_definition);
	USE FROM Material_property_definition_schema(property_definition_relationship);
	USE FROM Group_schema(group);
	USE FROM Document_schema(document_usage_constraint);
	
TYPE s_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (composite_signal_property_relationship,
      property_definition,
      signal);
END_TYPE; 
	
ENTITY composite_signal_property_relationship
  SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
  WR1: SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\property_definition_relationship ||
       SELF\composite_signal_property_relationship || SELF\property_definition)) = 0;
  WR3: SELF\property_definition_relationship.related_property_definition.name =
       'signal property';
  WR4: SELF\property_definition_relationship.relating_property_definition.name =
       'composite signal property';
  WR5: SELF\property_definition.name = '';
  WR6: SELF\property_definition.description = '';
  WR7: SELF\property_definition_relationship.name = '';
  WR8: SELF\property_definition_relationship.description = '';
  WR9: ('SIGNAL_MIM.' +
       'CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) AND
       (SELF\property_definition.definition.description = 'aggregate operation');
 WR10: 'SIGNAL_MIM.' +
       'EXTERNAL_DEFINITION' IN TYPEOF(SELF\property_definition.definition);
END_ENTITY;

ENTITY signal
  SUBTYPE OF (characterized_object);
WHERE
  WR1: SIZEOF (QUERY (aca <* USEDIN (SELF,
       'SIGNAL_MIM.' + 
       'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS') |
       'SIGNAL_MIM.' +
       'SIGNAL_CATEGORY' IN
       TYPEOF (aca.assigned_group))) >= 1;
  WR2: (SIZEOF (QUERY (ada <* USEDIN (SELF,
       'SIGNAL_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       SIZEOF (QUERY (duc <* USEDIN (ada.assigned_document,
       'SIGNAL_MIM.' +
       'DOCUMENT_USAGE_CONSTRAINT.SOURCE') |
       duc\document_usage_constraint.subject_element = 'signal category')) = 1)) = 1);
  WR3: SIZEOF (USEDIN (SELF, 
       'SIGNAL_MIM.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
END_ENTITY;

ENTITY signal_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.description IN ['signal characteristic category', 
       'signal property category'];
END_ENTITY;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\single_part_representation_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2544 - ISO/TS 10303-1133 Single part representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1668
*) 


SCHEMA Single_part_representation_mim;

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM External_model_mim;    -- ISO/TS 10303-1033

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Part_view_definition_mim;    -- ISO/TS 10303-1023

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Product_categorization_mim;    -- ISO/TS 10303-1016

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032


TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

FUNCTION categories_of_product
 (obj : product) : SET OF STRING; 
LOCAL
category_assignments: BAG OF product_category;
categories: SET OF STRING:=[];
i: INTEGER;
END_LOCAL;
category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);
      END_FUNCTION; 

END_SCHEMA;  -- Single_part_representation_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\software_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3610 - ISO/CD-TS 10303-1746 Software - EXPRESS MIM
*)


SCHEMA Software_mim;
	USE FROM Document_definition_mim;	-- ISO/TS 10303-1123
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\specification_document_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3613 - ISO/CD-TS 10303-1747 Specification document - EXPRESS MIM
*)


SCHEMA Specification_document_mim;
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	USE FROM Configuration_item_mim;	-- ISO/TS 10303-1056
	USE FROM Encoded_text_representation_mim; -- ISO/TS 10303-1366
	USE FROM Person_organization_assignment_mim;	-- ISO/TS 10303-1013
	USE FROM Person_organization_mim;	-- ISO/TS 10303-1011

	USE FROM Document_schema (document_type);
	USE FROM Management_resources_schema(group_assignment);
	USE FROM Date_time_schema(date_time_role);
	
	USE FROM Product_definition_schema(product_definition_formation_relationship);


TYPE document_identifier_assigned_item = SELECT
     (document);
END_TYPE;

TYPE sd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
	(configuration_item,
	product,
    product_definition,
    product_definition_formation);
END_TYPE;
	
ENTITY document_identifier
  SUBTYPE OF (group);
UNIQUE
  UR1: SELF\group.name, SELF\group.description;
WHERE
  WR1: SIZEOF (USEDIN(SELF,
                     'SPECIFICATION_DOCUMENT_MIM.' +
                     'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) > 0;
END_ENTITY;

ENTITY document_identifier_assignment
 SUBTYPE OF (group_assignment);
   SELF\group_assignment.assigned_group : document_identifier;
     items : SET [1:?] OF document_identifier_assigned_item;
END_ENTITY;

ENTITY ee_specification 
 SUBTYPE OF (document);
WHERE
  WR1: SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'SPECIFICATION_DOCUMENT_MIM.' +
       'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\person_and_organization_role.name = 'document source')) +
       SIZEOF (QUERY (apoa <* USEDIN (SELF, 
       'SPECIFICATION_DOCUMENT_MIM.' +
       'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') |
       apoa.role\organization_role.name = 'document source')) >= 1;
  WR2: SELF\document.kind\document_type.product_data_type IN 
       ['assembly technology specification',
       'design specification', 'fabrication technology specification',
       'interface specification', 'language reference manual',
       'lead form specification', 'material specification',
       'reference document', 'source code',
       'font registration document',
       'process specification', 'surface finish specification',
       'test specification'];
END_ENTITY;

ENTITY structured_text_representation_context
  SUBTYPE OF (representation_context);
WHERE
  WR1: SIZEOF (QUERY (rep <* USEDIN (SELF,
       'SPECIFICATION_DOCUMENT_MIM.' +
       'REPRESENTATION.CONTEXT_OF_ITEMS') | NOT (
       'SPECIFICATION_DOCUMENT_MIM.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN
       TYPEOF (rep)))) = 0;
END_ENTITY;

ENTITY structured_text_representation_item
  SUBTYPE OF (representation, descriptive_representation_item);
WHERE
  WR1: SIZEOF (QUERY (rr <* USEDIN (SELF,
       'SPECIFICATION_DOCUMENT_MIM.' +
       'REPRESENTATION_RELATIONSHIP.REP_2') |
       'SPECIFICATION_DOCUMENT_MIM.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN
       TYPEOF (rr.rep_1) ))<= 1;
  WR2: SIZEOF (USEDIN (SELF, 
        'SPECIFICATION_DOCUMENT_MIM.' + 
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) >= 1;
  WR3: (SIZEOF (QUERY (it <* SELF\representation.items |
       'SPECIFICATION_DOCUMENT_MIM.' +
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN 
       TYPEOF (it))) = 1); 
END_ENTITY;

RULE product_association_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       (pdfr\product_definition_formation_relationship.name = 'product association')
       AND (SIZEOF(QUERY(adr <* USEDIN(pdfr,
       'SPECIFICATION_DOCUMENT_MIM.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('SPECIFICATION_DOCUMENT_MIM.'
       + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))
       )) = 0))) = 0;
END_RULE;

RULE ee_document_constraint FOR ( document );
WHERE
  WR1: SIZEOF(QUERY(doc <* document |
       (SIZEOF(QUERY(adata <* USEDIN(doc,
       'SPECIFICATION_DOCUMENT_MIM.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(doc <* document |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(doc,
       'SPECIFICATION_DOCUMENT_MIM.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'publisher')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(doc,
       'SPECIFICATION_DOCUMENT_MIM.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'publisher')
       )) = 1)))) = 0;
  WR3: SIZEOF(QUERY(doc <* document |
       NOT (SIZEOF(USEDIN(doc,
       'SPECIFICATION_DOCUMENT_MIM.'
       + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1)
       )) = 0;
END_RULE;

RULE ee_document_unique_constraint FOR
 ( document, document_identifier_assignment );
LOCAL
  pass : BOOLEAN := TRUE;
  rev_exists_bag : BAG OF document := [];
  dia_bag : BAG OF document_identifier_assignment := [];
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(document) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF NOT(EXISTS( document[i].description )) THEN
   pass := FALSE;
  END_IF;
END_REPEAT;


REPEAT i := 1 to SIZEOF(document_identifier_assignment) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(document_identifier_assignment[i].items) by 1;
     desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
  END_REPEAT;
  IF NOT(value_unique(desc_bag)) THEN
    pass := FALSE;
  END_IF;
END_REPEAT;

WHERE
  WR1: pass;
END_RULE;

RULE product_association_unique_constraint FOR
 ( product_definition_formation_relationship );
LOCAL
  pdfr : BAG OF product_definition_formation_relationship := QUERY( r <*
product_definition_formation_relationship | 
  (r\product_definition_formation_relationship.name = 'product association' ) );
  pdf_bag : BAG OF product_definition_formation := [];
  pdfr_bag : BAG OF product_definition_formation_relationship;
  pass : BOOLEAN := TRUE;
  adr_bag : BAG OF applied_document_reference;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pdfr) by 1;
  IF EXISTS( pdfr[i].relating_product_definition_formation ) THEN
    IF( NOT( pdfr[i].relating_product_definition_formation IN pdf_bag ) )
                                                              THEN
      pdf_bag := pdf_bag + pdfr[i].
                 relating_product_definition_formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdfr_bag := QUERY( r <* pdfr | 
             (r.relating_product_definition_formation :=: pdf_bag[i]) );
  es_bag := [];
  REPEAT j := 1 to SIZEOF(pdfr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( pdfr_bag[j], 
('AP210_PRODUCT_DATA_MANAGEMENT_MIM.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' +
'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\stratum_non_planar_shape_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3616 - ISO/CD-TS 10303-1748 Stratum non planar shape - EXPRESS MIM
*)


SCHEMA Stratum_non_planar_shape_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509

RULE stratum_average_surface_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum average surface shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'STRATUM_NON_PLANAR_SHAPE_MIM.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('STRATUM_NON_PLANAR_SHAPE_MIM.'
        + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition))
       AND (pdr.definition.definition\shape_aspect.description = 
                                            'average surface'))) = 1
       ))) = 0;

END_RULE;

RULE stratum_feature_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum feature non planar 2d shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'STRATUM_NON_PLANAR_SHAPE_MIM.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('STRATUM_NON_PLANAR_SHAPE_MIM.'
        + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition))
       )) = 1
       ))) = 0;
END_RULE;

RULE 
stratum_feature_shape_stratum_average_surface_shape_relationship_constraint
 FOR 
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('STRATUM_NON_PLANAR_SHAPE_MIM.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('STRATUM_NON_PLANAR_SHAPE_MIM.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum average surface shape')
       ))) = 0;
END_RULE;

RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
        'stratum feature shape stratum surface shape relationship')
       AND NOT(('STRATUM_NON_PLANAR_SHAPE_MIM.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
            'stratum feature shape stratum surface shape relationship')
       AND NOT(('STRATUM_NON_PLANAR_SHAPE_MIM.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum surface shape')
       ))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\styled_curve_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3619 - ISO/CD-TS 10303-1749 Styled curve - EXPRESS MIM
*)

SCHEMA Styled_curve_mim;
	USE FROM Colour_mim;    -- ISO/TS 10303-1002

	USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

	USE FROM presentation_definition_schema
		(annotation_curve_occurrence,
		annotation_occurrence);

	USE FROM presentation_appearance_schema
		(presentation_style_assignment,
		presentation_style_select,
		styled_item);
	
	USE FROM representation_schema
		(parametric_representation_context);
		
		
	USE FROM presentation_appearance_schema
		(curve_style,
		curve_style_font,
		curve_style_font_and_scaling,
		fill_area_style_colour,		
		pre_defined_curve_font);

ENTITY solid_curve_font
 SUBTYPE OF (pre_defined_curve_font);
END_ENTITY; 

RULE curve_style_font_and_scaling_unique_constraint 
   FOR (curve_style_font_and_scaling);

LOCAL
  r : BAG OF curve_style_font_and_scaling := 
                         QUERY (r <* curve_style_font_and_scaling | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\curve_style_font_and_scaling.name ) THEN
    IF (r[i]\curve_style_font_and_scaling.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\curve_style_font_and_scaling.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE;

RULE curve_style_requires_length_measure_with_unit FOR ( curve_style );
WHERE
  WR1: SIZEOF(QUERY(cs <* curve_style |
       NOT('STYLED_CURVE_MIM.'
        + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs))
       )) = 0;
END_RULE;

RULE curve_style_unique_constraint FOR
 ( representation );
LOCAL
  cs : BAG OF representation := QUERY( r <* representation |
((r\representation.name = 'curve style parameters') AND (r.context_of_items\representation_context.context_type =
'curve style parametric context')) );
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cs) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(cs[i].items) by 1;
    IF ( ('STYLED_CURVE_MIM.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(cs[i].items[j])) AND
(cs[i].items[j]\representation_item.name = 'curve style name') ) THEN
      IF EXISTS( cs[i].items[j]\descriptive_representation_item.description ) THEN
        IF ( cs[i].items[j]\descriptive_representation_item.description IN desc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          desc_bag := desc_bag + cs[i].items[j]\descriptive_representation_item.description;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\styled_text_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3622 - ISO/CD-TS 10303-1750 Styled text - EXPRESS MIM
*)


SCHEMA Styled_text_mim;
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004
	USE FROM Specification_document_mim;	-- ISO/TS 10303-1747
	
	USE FROM External_reference_schema(externally_defined_item);
	USE FROM Presentation_definition_schema(text_literal);
	USE FROM Presentation_resource_schema(
		externally_defined_text_font,
		font_select);	

RULE registered_font_constraint FOR ( externally_defined_text_font );
WHERE
  WR1: SIZEOF(QUERY(edtf <* externally_defined_text_font |
       (SIZEOF(QUERY(adr <* USEDIN(edtf,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adr.assigned_document.kind\document_type.product_data_type =
                     'font registration document')
       )) = 0))) = 0;
END_RULE; -- registered_font_constraint

RULE registered_font_unique_constraint FOR
 ( externally_defined_text_font );
LOCAL
  ii_bag : BAG OF STRING := [];
  edtf_bag : BAG OF externally_defined_text_font;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(externally_defined_text_font) by 1;
  IF EXISTS( externally_defined_text_font[i].item_id ) THEN
    IF ( NOT ( externally_defined_text_font[i].item_id IN ii_bag ) ) THEN
      ii_bag := ii_bag + externally_defined_text_font[i].item_id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ii_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  edtf_bag := QUERY( edtf <* externally_defined_text_font |
            (edtf.item_id = ii_bag[i]) );
  REPEAT j := 1 to SIZEOF(edtf_bag) by 1;
    adr_bag := QUERY( adr <* USEDIN( edtf_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) |
         (adr.assigned_document.kind\document_type.product_data_type =
'font registration document') );
    es_bag := [];
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- registered_font_unique_constraint
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\test_requirement_allocation_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3625 - ISO/CD-TS 10303-1751 Test requirement allocation - EXPRESS MIM
*)


SCHEMA Test_requirement_allocation_mim;
	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
	USE FROM Network_functional_usage_view_mim;	-- ISO/TS 10303-1705

TYPE tra_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (product_definition_formation,
     property_definition_representation);
END_TYPE;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\test_select_product_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   N3680 - ISO/CD-TS - 10303-1757 Test select product - EXPRESS MIM
*)
SCHEMA Test_select_product_mim;

	USE FROM Product_replacement_mim;	-- ISO/TS 10303-1046

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\text_appearance_mim.exp
   ------------------------------------------------------------
*)

(*
$Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
ISO TC184/SC4/WG12 N2697 - ISO/TS 10303-1136 Text appearance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1701
*) 


SCHEMA Text_appearance_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle,
   character_glyph_style_stroke,
   character_glyph_style_outline,
   text_style,
   text_style_for_defined_font,
   text_style_with_box_characteristics,
   text_style_with_mirror,
   text_style_with_spacing); 

USE FROM presentation_definition_schema   -- ISO 10303-46
  (composite_text,
   composite_text_with_extent,
   composite_text_with_delineation,
   composite_text_with_blanking_box,
   text_literal,
   text_literal_with_extent,
   text_literal_with_delineation,
   text_literal_with_blanking_box); 

USE FROM presentation_resource_schema   -- ISO 10303-46
  (colour_rgb,
   externally_defined_text_font,
   font_select,
   pre_defined_colour,
   pre_defined_text_font); 

USE FROM aic_draughting_annotation;    -- ISO 10303-504


RULE text_font_usage FOR 
(externally_defined_text_font,pre_defined_text_font);
WHERE
  WR1: SIZEOF (QUERY (pdtf <* pre_defined_text_font | SIZEOF (USEDIN (pdtf, 'PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL.FONT')) = 0 )) = 0;
  WR2: SIZEOF (QUERY (edtf <* externally_defined_text_font | SIZEOF (USEDIN (edtf, 'PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL.FONT')) = 0 )) = 0;
END_RULE; 

END_SCHEMA;  -- Text_appearance_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\thermal_network_definition_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3628 - ISO/CD-TS 10303-1752 Thermal network definition - EXPRESS MIM
*)


SCHEMA Thermal_network_definition_mim;
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704

ENTITY thermal_network
  SUBTYPE OF (functional_unit);
END_ENTITY;
	
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\time_interval_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N2119 - ISO/TS 10303-1065 Time interval - EXPRESS MIM
*)

SCHEMA Time_interval_mim; 

USE FROM date_time_schema   -- ISO 10303-41
  (time_interval,
   time_interval_relationship,
   time_interval_with_bounds); 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Time_interval_mim


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\value_with_unit_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1302 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
*)

SCHEMA Value_with_unit_mim;

USE FROM measure_schema;

USE FROM representation_schema
 (uncertainty_measure_with_unit);

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\value_with_unit_extension_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3631 - ISO/CD-TS 10303-1753 Value with unit extension - EXPRESS MIM
*)


SCHEMA Value_with_unit_extension_mim;
	USE FROM Value_with_unit_mim;	-- ISO/TS 10303-1054

	USE FROM Iso13584_generic_expressions_schema
		(environment,
		generic_literal,
		variable_semantics);

	USE FROM basic_attribute_schema
		(name_attribute);
	
ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\absorbed_dose_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = gray;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY activity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\activity_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = becquerel;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
   WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY capacitance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\capacitance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = farad;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
   WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY conductance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\conductance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = siemens;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\dose_equivalent_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = sievert;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY electric_charge_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\electric_charge_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = coulomb;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY electromotive_force_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\electromotive_force_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = volt ;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY energy_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\energy_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = joule;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY expression_conversion_based_unit
  SUBTYPE OF (context_dependent_unit, variable_semantics); 
INVERSE
  associated_variable_environment: environment FOR semantics; 
END_ENTITY;

ENTITY force_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\force_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = newton;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY frequency_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\frequency_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = hertz;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY illuminance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\illuminance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = lux;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY inductance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\inductance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = henry;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY luminous_flux_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\luminous_flux_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = lumen;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY magnetic_flux_density_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_density_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = tesla;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY magnetic_flux_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = weber;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY polar_complex_number_literal
  SUBTYPE OF (generic_literal);
  radius    : REAL;
  angle     : REAL;
WHERE
  WR1: radius >= 0;
  WR2: { 0 <= angle < 2*PI };
END_ENTITY;

ENTITY power_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\power_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = watt;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY pressure_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\pressure_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = pascal;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY resistance_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||
       SELF\resistance_measure_with_unit))) = 0;
  WR2: SELF\measure_with_unit.unit_component\si_unit.name = ohm;
  WR3: 'VALUE_WITH_UNIT_EXTENSION_MIM.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
  WR4: 'VALUE_WITH_UNIT_EXTENSION_MIM.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY scattering_parameter
 SUBTYPE OF (polar_complex_number_literal);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\polar_complex_number_literal ||
       SELF\scattering_parameter))) = 0;
END_ENTITY;

RULE subtype_exclusive_measure_with_unit FOR (measure_with_unit);
WHERE
  WR1: SIZEOF (QUERY (mwu <* measure_with_unit |
       NOT (SIZEOF ([
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ABSORBED_DOSE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ACTIVITY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'AREA_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'CAPACITANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'CONDUCTANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'DOSE_EQUIVALENT_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ELECTRIC_CHARGE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ELECTRIC_CURRENT_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ENERGY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'FORCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'FREQUENCY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'ILLUMINANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'INDUCTANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'LENGTH_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'LUMINOUS_FLUX_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'MAGNETIC_FLUX_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'MASS_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'PLANE_ANGLE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'POWER_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'PRESSURE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'RATIO_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'RESISTANCE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'SOLID_ANGLE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'TIME_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'UNCERTAINTY_MEASURE_WITH_UNIT',
       'VALUE_WITH_UNIT_EXTENSION_MIM.' +
       'VOLUME_MEASURE_WITH_UNIT'] *
       TYPEOF(mwu)) <= 1))) = 0;
END_RULE;
	
END_SCHEMA;




(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\via_component_mim.exp
   ------------------------------------------------------------
*)

(*
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO TC184/SC4/WG12 N3634 - ISO/CD-TS 10303-1754 Via component - EXPRESS MIM
*)


SCHEMA Via_component_mim;
	USE FROM Interconnect_module_connection_routing_mim;	-- ISO/TS 10303-1684
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
END_SCHEMA;



(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\wireframe_2d_mim.exp
   ------------------------------------------------------------
*)

(* 
   $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
   ISO/TC184/SC4 WG12N2626 - ISO/TS 10303-1347 Wireframe_2d - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12N1776
*)

SCHEMA Wireframe_2d_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_geometrically_bounded_2d_wireframe;

END_SCHEMA;


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\work_order_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1154 - ISO/TS 10303-1043 Work order - EXPRESS MIM
*)

SCHEMA Work_order_mim; 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Work_request_mim;    -- ISO/TS 10303-1042

USE FROM action_schema   -- ISO 10303-41
  (action_directive,
   directed_action); 

END_SCHEMA; 


(*
   ------------------------------------------------------------
G:\workspace\stepmod\ballots\ballots\ap210_wg12\express\mim\work_request_mim.exp
   ------------------------------------------------------------
*)

(*
 $Id: mim_20050410v1_with_resources.exp,v 1.1 2005/04/12 22:11:03 thomasrthurman Exp $
 ISO TC184/SC4/WG12 N1151 - ISO/TS 10303-1042 Work request - EXPRESS MIM
*)

SCHEMA Work_request_mim;

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM action_schema   -- ISO 10303-41
  (action_request_solution,
   action_request_status,
   versioned_action_request); 

USE FROM management_resources_schema   -- ISO 10303-41
   (action_request_assignment);


TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

END_SCHEMA;
