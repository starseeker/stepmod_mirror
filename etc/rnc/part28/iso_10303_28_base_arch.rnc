# DTD elements: total number = 246
# Referenced not defined: NIL
# Defined not referenced: (iso_10303_28)
# Duplicate definitions: NIL

# Date: Year: 2000, Month:10, Day:27, time 16:14

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace xlink = "http://www.w3.org/1999/xlink"

abs = element abs { attlist.abs, empty }
attlist.abs &=
  [ a:defaultValue = "ABS" ]
  attribute express-production { string "ABS" }?
abstract =
  element abstract {
    attlist.abstract, (embedded_remark | tail_remark)?
  }
attlist.abstract &=
  [ a:defaultValue = "abstract_supertype" ]
  attribute express-production { string "abstract_supertype" }?
abstract_supertype =
  element abstract_supertype {
    attlist.abstract_supertype,
    (embedded_remark | tail_remark)?,
    (entity_ref | supertype_one_of | supertype_and_or | supertype_and)?
  }
attlist.abstract_supertype &=
  [ a:defaultValue = "abstract_supertype_declaration" ]
  attribute express-production {
    string "abstract_supertype_declaration"
  }?
acos = element acos { attlist.acos, empty }
attlist.acos &=
  [ a:defaultValue = "ACOS" ]
  attribute express-production { string "ACOS" }?
add = element add { attlist.add, empty }
attlist.add &=
  [ a:defaultValue = "+" ] attribute express-production { string "+" }?
aggregate_initializer =
  element aggregate_initializer {
    attlist.aggregate_initializer,
    (embedded_remark | tail_remark)?,
    element_list
  }
attlist.aggregate_initializer &=
  [ a:defaultValue = "aggregate_initializer" ]
  attribute express-production { string "aggregate_initializer" }?
aggregate_source =
  element aggregate_source {
    attlist.aggregate_source,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.aggregate_source &=
  [ a:defaultValue = "aggregate_source" ]
  attribute express-production { string "aggregate_source" }?
aggregate_type =
  element aggregate_type {
    attlist.aggregate_type,
    (embedded_remark | tail_remark)?,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    (type_label_id | type_label_ref)?
  }
attlist.aggregate_type &=
  [ a:defaultValue = "aggregate_type" ]
  attribute express-production { string "aggregate_type" }?
algorithm_head =
  element algorithm_head {
    attlist.algorithm_head,
    (embedded_remark | tail_remark)?,
    declaration_block?,
    constant_block?,
    local_variable_block?
  }
attlist.algorithm_head &=
  [ a:defaultValue = "algorithm_head" ]
  attribute express-production { string "algorithm_head" }?
alias_stmt =
  element alias_stmt {
    attlist.alias_stmt,
    (embedded_remark | tail_remark)?,
    variable_id,
    (parameter_ref | variable_ref),
    qualifier?,
    statement_block
  }
attlist.alias_stmt &=
  [ a:defaultValue = "alias_stmt" ]
  attribute express-production { string "alias_stmt" }?
and = element and { attlist.and, empty }
attlist.and &=
  [ a:defaultValue = "AND" ]
  attribute express-production { string "AND" }?
applies_to_entities =
  element applies_to_entities {
    attlist.applies_to_entities,
    (embedded_remark | tail_remark)?,
    entity_ref+
  }
attlist.applies_to_entities &=
  [ a:defaultValue = "rule_head" ]
  attribute express-production { string "rule_head" }?
array_literal =
  element array_literal {
    attlist.array_literal,
    (binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | bag_literal
     | list_literal
     | set_literal
     | array_literal
     | type_literal
     | entity_instance
     | entity_instance_as_group
     | entity_instance_ref
     | unset)*
  }
attlist.array_literal &=
  attribute express_constant_name { xsd:NMTOKEN }?
array_type =
  element array_type {
    attlist.array_type,
    (embedded_remark | tail_remark)?,
    index_spec,
    base_type,
    optional?,
    unique?
  }
attlist.array_type &=
  [ a:defaultValue = "array_type" ]
  attribute express-production { string "array_type" }?
asin = element asin { attlist.asin, empty }
attlist.asin &=
  [ a:defaultValue = "ASIN" ]
  attribute express-production { string "ASIN" }?
assignment_stmt =
  element assignment_stmt {
    attlist.assignment_stmt,
    (embedded_remark | tail_remark)?,
    (parameter_ref | variable_ref),
    qualifier?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)
  }
attlist.assignment_stmt &=
  [ a:defaultValue = "assignment_stmt" ]
  attribute express-production { string "assignment_stmt" }?
atan = element atan { attlist.atan, empty }
attlist.atan &=
  [ a:defaultValue = "ATAN" ]
  attribute express-production { string "ATAN" }?
attribute_id = element attribute_id { attlist.attribute_id, text }
attlist.attribute_id &=
  [ a:defaultValue = "attribute_id" ]
  attribute express-production { string "attribute_id" }?,
  attribute id { xsd:ID }?
attribute_instance =
  element attribute_instance {
    attlist.attribute_instance,
    (binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | bag_literal
     | list_literal
     | set_literal
     | array_literal
     | type_literal
     | entity_instance
     | entity_instance_as_group
     | entity_instance_ref)
  }
attlist.attribute_instance &=
  attribute express_attribute_name { xsd:NMTOKEN },
  [ a:defaultValue = "explicit" ]
  attribute express_attribute_type {
    "explicit" | "inverse" | "derived"
  }?
attribute_ref = element attribute_ref { attlist.attribute_ref, text }
attlist.attribute_ref &=
  [ a:defaultValue = "attribute_ref" ]
  attribute express-production { string "attribute_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (attribute_id)" ]
  attribute reftype { string "refid (attribute_id)" }?
author = element author { attlist.author, text }
attlist.author &= empty
authorization = element authorization { attlist.authorization, text }
attlist.authorization &= empty
bag_literal =
  element bag_literal {
    attlist.bag_literal,
    (binary_literal*
     | boolean_literal*
     | integer_literal*
     | logical_literal*
     | real_literal*
     | string_literal*
     | bag_literal*
     | list_literal*
     | set_literal*
     | array_literal*
     | type_literal*
     | (entity_instance
        | entity_instance_as_group
        | entity_instance_ref)*)
  }
attlist.bag_literal &= attribute express_constant_name { xsd:NMTOKEN }?
bag_type =
  element bag_type {
    attlist.bag_type,
    (embedded_remark | tail_remark)?,
    bound_spec?,
    base_type
  }
attlist.bag_type &=
  [ a:defaultValue = "bag_type" ]
  attribute express-production { string "bag_type" }?
base_type =
  element base_type {
    attlist.base_type,
    (embedded_remark | tail_remark)?,
    (array_type
     | bag_type
     | list_type
     | set_type
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | entity_ref
     | type_ref
     | generic_entity_type)
  }
attlist.base_type &=
  [ a:defaultValue = "base_type" ]
  attribute express-production { string "base_type" }?
binary =
  element binary {
    attlist.binary, (embedded_remark | tail_remark)?, width_spec?
  }
attlist.binary &=
  [ a:defaultValue = "binary_type" ]
  attribute express-production { string "binary_type" }?
binary_literal = element binary_literal { attlist.binary_literal, text }
attlist.binary_literal &=
  attribute empty_bits { text },
  [ a:defaultValue = "binary_literal" ]
  attribute express-production { string "binary_literal" }?,
  attribute express_constant_name { xsd:NMTOKEN }?,
  attribute external_binary_literal { xsd:ENTITY }?,
  attribute notation { "hex" | "base64" }?
blength = element blength { attlist.blength, empty }
attlist.blength &=
  [ a:defaultValue = "BLENGTH" ]
  attribute express-production { string "BLENGTH" }?
boolean = element boolean { attlist.boolean, empty }
attlist.boolean &=
  [ a:defaultValue = "boolean_type" ]
  attribute express-production { string "boolean_type" }?
boolean_literal =
  element boolean_literal {
    attlist.boolean_literal,
    (embedded_remark | tail_remark)?,
    (false | true)
  }
attlist.boolean_literal &=
  [ a:defaultValue = "#NONE" ]
  attribute express-production { string "#NONE" }?,
  attribute express_constant_name { xsd:NMTOKEN }?
bound_spec =
  element bound_spec {
    attlist.bound_spec,
    (embedded_remark | tail_remark)?,
    lower_bound,
    upper_bound
  }
attlist.bound_spec &=
  [ a:defaultValue = "bound_spec" ]
  attribute express-production { string "bound_spec" }?
case_action =
  element case_action {
    attlist.case_action,
    (embedded_remark | tail_remark)?,
    case_label,
    (alias_stmt
     | assignment_stmt
     | case_stmt
     | statement_block
     | escape_stmt
     | if_stmt
     | null_stmt
     | procedure_call_stmt
     | repeat_stmt
     | return_stmt
     | skip_stmt)
  }
attlist.case_action &=
  [ a:defaultValue = "case_action" ]
  attribute express-production { string "case_action" }?
case_label =
  element case_label {
    attlist.case_label,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)+
  }
attlist.case_label &=
  [ a:defaultValue = "case_label" ]
  attribute express-production { string "case_label" }?
case_stmt =
  element case_stmt {
    attlist.case_stmt,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression),
    case_action*,
    otherwise?
  }
attlist.case_stmt &=
  [ a:defaultValue = "case_stmt" ]
  attribute express-production { string "case_stmt" }?
complex_entity_constructor =
  element complex_entity_constructor {
    attlist.complex_entity_constructor, empty
  }
attlist.complex_entity_constructor &=
  [ a:defaultValue = "||" ]
  attribute express-production { string "||" }?
constant_block =
  element constant_block {
    attlist.constant_block,
    (embedded_remark | tail_remark)?,
    constant_decl*
  }
attlist.constant_block &=
  [ a:defaultValue = "constant_decl" ]
  attribute express-production { string "constant_decl" }?
constant_decl =
  element constant_decl {
    attlist.constant_decl,
    (embedded_remark | tail_remark)?,
    constant_id,
    base_type,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)
  }
attlist.constant_decl &=
  [ a:defaultValue = "constant_body" ]
  attribute express-production { string "constant_body" }?
constant_id = element constant_id { attlist.constant_id, text }
attlist.constant_id &=
  [ a:defaultValue = "constant_id" ]
  attribute express-production { string "constant_id" }?,
  attribute id { xsd:ID }?
constant_import =
  element constant_import {
    attlist.constant_import,
    (embedded_remark | tail_remark)?,
    constant_id,
    constant_ref
  }
attlist.constant_import &=
  [ a:defaultValue = "resource_or_rename" ]
  attribute express-production { string "resource_or_rename" }?
constant_ref = element constant_ref { attlist.constant_ref, text }
attlist.constant_ref &=
  [ a:defaultValue = "constant_ref" ]
  attribute express-production { string "constant_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (constant_id)" ]
  attribute reftype { string "refid (constant_id)" }?
constraint_decl =
  element constraint_decl {
    attlist.constraint_decl,
    (embedded_remark | tail_remark)?,
    constraint_id,
    entity_ref,
    (abstract?, total_over?, supertype_of?)
  }
attlist.constraint_decl &=
  [ a:defaultValue = "constraint_decl" ]
  attribute express-production { string "constraint_decl" }?
constraint_id = element constraint_id { attlist.constraint_id, text }
attlist.constraint_id &=
  [ a:defaultValue = "constraint_id" ]
  attribute express-production { string "constraint_id" }?,
  attribute id { xsd:ID }?
const_e = element const_e { attlist.const_e, empty }
attlist.const_e &=
  [ a:defaultValue = "CONST_E" ]
  attribute express-production { string "CONST_E" }?
cos = element cos { attlist.cos, empty }
attlist.cos &=
  [ a:defaultValue = "COS" ]
  attribute express-production { string "COS" }?
data_section_header =
  element data_section_header {
    attlist.data_section_header, documentation?
  }
attlist.data_section_header &= empty
declaration_block =
  element declaration_block {
    attlist.declaration_block,
    (embedded_remark | tail_remark)?,
    (entity_decl | function_decl | procedure_decl | type_decl)*
  }
attlist.declaration_block &=
  [ a:defaultValue = "declaration" ]
  attribute express-production { string "declaration" }?
derived_attr =
  element derived_attr {
    attlist.derived_attr,
    (embedded_remark | tail_remark)?,
    (attribute_id | qualified_attribute),
    base_type,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)
  }
attlist.derived_attr &=
  [ a:defaultValue = "derived_attr" ]
  attribute express-production { string "derived_attr" }?
derive_clause =
  element derive_clause {
    attlist.derive_clause,
    (embedded_remark | tail_remark)?,
    derived_attr+
  }
attlist.derive_clause &=
  [ a:defaultValue = "derive_clause" ]
  attribute express-production { string "derive_clause" }?
documentation = element documentation { attlist.documentation, text }
attlist.documentation &= empty
document_name = element document_name { attlist.document_name, text }
attlist.document_name &= empty
domain_rule =
  element domain_rule {
    attlist.domain_rule,
    (embedded_remark | tail_remark)?,
    label?,
    logical_expression
  }
attlist.domain_rule &=
  [ a:defaultValue = "domain_rule" ]
  attribute express-production { string "domain_rule" }?
element_item =
  element element_item {
    attlist.element_item,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression),
    repetition?
  }
attlist.element_item &=
  [ a:defaultValue = "element" ]
  attribute express-production { string "element" }?
element_list =
  element element_list {
    attlist.element_list,
    (embedded_remark | tail_remark)?,
    element_item*
  }
attlist.element_list &=
  [ a:defaultValue = "element" ]
  attribute express-production { string "element" }?
embedded_remark =
  element embedded_remark {
    attlist.embedded_remark, (text | embedded_remark)*
  }
attlist.embedded_remark &=
  [ a:defaultValue = "embedded_remark" ]
  attribute express-production { string "embedded_remark" }?
entity_constructor =
  element entity_constructor {
    attlist.entity_constructor,
    (embedded_remark | tail_remark)?,
    entity_ref,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)*
  }
attlist.entity_constructor &=
  [ a:defaultValue = "entity_constructor" ]
  attribute express-production { string "entity_constructor" }?
entity_decl =
  element entity_decl {
    attlist.entity_decl,
    (embedded_remark | tail_remark)?,
    entity_id,
    (abstract_supertype | supertype_of)?,
    subtype_of?,
    explicit_attr_block?,
    derive_clause?,
    inverse_clause?,
    unique_clause?,
    where_clause?
  }
attlist.entity_decl &=
  [ a:defaultValue = "entity_decl" ]
  attribute express-production { string "entity_decl" }?
entity_id = element entity_id { attlist.entity_id, text }
attlist.entity_id &=
  [ a:defaultValue = "entity_id" ]
  attribute express-production { string "entity_id" }?,
  attribute id { xsd:ID }?
entity_import =
  element entity_import {
    attlist.entity_import,
    (embedded_remark | tail_remark)?,
    entity_id,
    entity_ref
  }
attlist.entity_import &=
  [ a:defaultValue = "resource_or_rename" ]
  attribute express-production { string "resource_or_rename" }?
entity_instance =
  element entity_instance {
    attlist.entity_instance,
    (inherited_attribute_instance | attribute_instance)*,
    partial_entity_instance*
  }
attlist.entity_instance &=
  attribute express_constant_name { xsd:NMTOKEN }?,
  attribute express_entity_name { xsd:NMTOKEN },
  attribute express_schema_name { xsd:NMTOKEN }?,
  attribute id { xsd:ID }
entity_instance_as_group =
  element entity_instance_as_group {
    attlist.entity_instance_as_group, partial_entity_instance+
  }
attlist.entity_instance_as_group &=
  attribute express_constant_name { xsd:NMTOKEN }?,
  attribute id { xsd:ID }
entity_instance_ref =
  element entity_instance_ref { attlist.entity_instance_ref, empty }
attlist.entity_instance_ref &=
  attribute refid { xsd:IDREF },
  [
    a:defaultValue =
      "refid (entity_instance | entity_instance_as_group | partial_entity_instance | external_refid)"
  ]
  attribute reftype {
    string "refid (entity_instance | entity_instance_as_group | partial_entity_instance | external_refid)"
  }?
entity_ref = element entity_ref { attlist.entity_ref, text }
attlist.entity_ref &=
  [ a:defaultValue = "entity_ref" ]
  attribute express-production { string "entity_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (entity_id)" ]
  attribute reftype { string "refid (entity_id)" }?
enumeration =
  element enumeration {
    attlist.enumeration,
    (embedded_remark | tail_remark)?,
    extensible?,
    based_on?,
    enumeration_id*
  }
attlist.enumeration &=
  [ a:defaultValue = "enumeration_type" ]
  attribute express-production { string "enumeration_type" }?
based_on = element based_on { attlist.based_on, type_ref }
attlist.based_on &=
  [ a:defaultValue = "based_on" ]
  attribute express-production { string "based_on" }?
extensible = element extensible { attlist.extensible, empty }
attlist.extensible &= empty
enumeration_id = element enumeration_id { attlist.enumeration_id, text }
attlist.enumeration_id &=
  [ a:defaultValue = "enumeration_id" ]
  attribute express-production { string "enumeration_id" }?,
  attribute id { xsd:ID }?
enumeration_ref =
  element enumeration_ref { attlist.enumeration_ref, text }
attlist.enumeration_ref &=
  [ a:defaultValue = "enumeration_ref" ]
  attribute express-production { string "enumeration_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (enumeration_id)" ]
  attribute reftype { string "refid (enumeration_id)" }?
enumeration_reference =
  element enumeration_reference {
    attlist.enumeration_reference,
    (embedded_remark | tail_remark)?,
    type_ref?,
    enumeration_ref
  }
attlist.enumeration_reference &=
  [ a:defaultValue = "enumeration_reference" ]
  attribute express-production { string "enumeration_reference" }?
equal = element equal { attlist.equal, empty }
attlist.equal &=
  [ a:defaultValue = "=" ] attribute express-production { string "=" }?
escape_stmt = element escape_stmt { attlist.escape_stmt, empty }
attlist.escape_stmt &=
  [ a:defaultValue = "escape_stmt" ]
  attribute express-production { string "escape_stmt" }?
exists = element exists { attlist.exists, empty }
attlist.exists &=
  [ a:defaultValue = "EXISTS" ]
  attribute express-production { string "EXISTS" }?
exp = element exp { attlist.exp, empty }
attlist.exp &=
  [ a:defaultValue = "EXP" ]
  attribute express-production { string "EXP" }?
explicit_attr =
  element explicit_attr {
    attlist.explicit_attr,
    (embedded_remark | tail_remark)?,
    (attribute_id | qualified_attribute),
    renamed?,
    optional?,
    base_type
  }
attlist.explicit_attr &=
  [ a:defaultValue = "explicit_attr" ]
  attribute express-production { string "explicit_attr" }?
renamed = element renamed { attlist.renamed, attribute_id }
attlist.renamed &=
  [ a:defaultValue = "renamed" ]
  attribute express-production { string "renamed" }?
explicit_attr_block =
  element explicit_attr_block {
    attlist.explicit_attr_block,
    (embedded_remark | tail_remark)?,
    explicit_attr+
  }
attlist.explicit_attr_block &=
  [ a:defaultValue = "explicit_attr_block" ]
  attribute express-production { string "explicit_attr_block" }?
express_data =
  element express_data {
    attlist.express_data, data_section_header?, schema_instance
  }
attlist.express_data &=
  attribute id { xsd:ID },
  attribute name { text }?,
  attribute representation_category { xsd:NMTOKEN }?
express_schema =
  element express_schema {
    attlist.express_schema, (schema_decl | schema_text | external_refid)
  }
attlist.express_schema &=
  attribute express_schema_description { text }?,
  attribute express_schema_identifier { text }?,
  attribute express_schema_version { text }?,
  attribute express_version { "1" | "2" }?,
  attribute id { xsd:ID }?
external_refid =
  element external_refid { attlist.external_refid, empty }
attlist.external_refid &=
  attribute xlink:actuate { text }?,
  attribute xlink:arcrole { text },
  attribute xlink:href { text },
  attribute id { xsd:ID },
  attribute xlink:role { text }?,
  attribute xlink:show { text }?,
  attribute xlink:title { text }?,
  [ a:defaultValue = "simple" ]
  attribute xlink:type { string "simple" }?
factor =
  element factor {
    attlist.factor,
    raise_to_power,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op)
  }
attlist.factor &=
  [ a:defaultValue = "factor" ]
  attribute express-production { string "factor" }?
false = element false { attlist.false, empty }
attlist.false &=
  [ a:defaultValue = "FALSE" ]
  attribute express-production { string "FALSE" }?
fixed = element fixed { attlist.fixed, empty }
attlist.fixed &=
  [ a:defaultValue = "FIXED" ]
  attribute express-production { string "FIXED" }?
formal_parameter =
  element formal_parameter {
    attlist.formal_parameter,
    (embedded_remark | tail_remark)?,
    parameter_id,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type)
  }
attlist.formal_parameter &=
  [ a:defaultValue = "formal_parameter" ]
  attribute express-production { string "formal_parameter" }?
formal_parameter_block =
  element formal_parameter_block {
    attlist.formal_parameter_block,
    (embedded_remark | tail_remark)?,
    formal_parameter*
  }
attlist.formal_parameter_block &=
  [ a:defaultValue = "formal_parameter" ]
  attribute express-production { string "formal_parameter" }?
format = element format { attlist.format, empty }
attlist.format &=
  [ a:defaultValue = "FORMAT" ]
  attribute express-production { string "FORMAT" }?
function_call =
  element function_call {
    attlist.function_call,
    (embedded_remark | tail_remark)?,
    (abs
     | acos
     | asin
     | atan
     | blength
     | cos
     | exists
     | exp
     | format
     | hibound
     | hiindex
     | length
     | lobound
     | loindex
     | log
     | log2
     | log10
     | nvl
     | odd
     | rolesof
     | sin
     | sizeof
     | sqrt
     | tan
     | typeof
     | usedin
     | value
     | value_in
     | value_unique
     | function_ref),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)*
  }
attlist.function_call &=
  [ a:defaultValue = "function_call" ]
  attribute express-production { string "function_call" }?
function_decl =
  element function_decl {
    attlist.function_decl,
    (embedded_remark | tail_remark)?,
    function_id,
    formal_parameter_block?,
    function_return_type,
    algorithm_head?,
    statement_block
  }
attlist.function_decl &=
  [ a:defaultValue = "function_decl" ]
  attribute express-production { string "function_decl" }?
function_id = element function_id { attlist.function_id, text }
attlist.function_id &=
  [ a:defaultValue = "function_id" ]
  attribute express-production { string "function_id" }?,
  attribute id { xsd:ID }?
function_import =
  element function_import {
    attlist.function_import,
    (embedded_remark | tail_remark)?,
    function_id,
    function_ref
  }
attlist.function_import &=
  [ a:defaultValue = "resource_or_rename" ]
  attribute express-production { string "resource_or_rename" }?
function_ref = element function_ref { attlist.function_ref, text }
attlist.function_ref &=
  [ a:defaultValue = "function_ref" ]
  attribute express-production { string "function_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (function_id)" ]
  attribute reftype { string "refid (function_id)" }?
function_return_type =
  element function_return_type {
    attlist.function_return_type,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type)
  }
attlist.function_return_type &=
  [ a:defaultValue = "parameter_type" ]
  attribute express-production { string "parameter_type" }?
general_array_type =
  element general_array_type {
    attlist.general_array_type,
    (embedded_remark | tail_remark)?,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    bound_spec?,
    optional?,
    unique?
  }
attlist.general_array_type &=
  [ a:defaultValue = "general_array_type" ]
  attribute express-production { string "general_array_type" }?
general_bag_type =
  element general_bag_type {
    attlist.general_bag_type,
    (embedded_remark | tail_remark)?,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    bound_spec?
  }
attlist.general_bag_type &=
  [ a:defaultValue = "general_bag_type" ]
  attribute express-production { string "general_bag_type" }?
general_list_type =
  element general_list_type {
    attlist.general_list_type,
    (embedded_remark | tail_remark)?,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    bound_spec?,
    unique?
  }
attlist.general_list_type &=
  [ a:defaultValue = "general_list_type" ]
  attribute express-production { string "general_list_type" }?
general_set_type =
  element general_set_type {
    attlist.general_set_type,
    (embedded_remark | tail_remark)?,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    bound_spec?
  }
attlist.general_set_type &=
  [ a:defaultValue = "general_set_type" ]
  attribute express-production { string "general_set_type" }?
generic_type =
  element generic_type {
    attlist.generic_type,
    (embedded_remark | tail_remark)?,
    (type_label_id | type_label_ref)?
  }
attlist.generic_type &=
  [ a:defaultValue = "generic_type" ]
  attribute express-production { string "generic_type" }?
generic_entity_type =
  element generic_entity_type {
    attlist.generic_entity_type, (embedded_remark | tail_remark)?
  }
attlist.generic_entity_type &= empty
greater_than = element greater_than { attlist.greater_than, empty }
attlist.greater_than &=
  [ a:defaultValue = ">" ] attribute express-production { string ">" }?
greater_than_or_equal =
  element greater_than_or_equal { attlist.greater_than_or_equal, empty }
attlist.greater_than_or_equal &=
  [ a:defaultValue = ">=" ]
  attribute express-production { string ">=" }?
hibound = element hibound { attlist.hibound, empty }
attlist.hibound &=
  [ a:defaultValue = "HIBOUND" ]
  attribute express-production { string "HIBOUND" }?
high_index =
  element high_index {
    attlist.high_index,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.high_index &=
  [ a:defaultValue = "index_2" ]
  attribute express-production { string "index_2" }?
hiindex = element hiindex { attlist.hiindex, empty }
attlist.hiindex &=
  [ a:defaultValue = "HIINDEX" ]
  attribute express-production { string "HIINDEX" }?
if_stmt =
  element if_stmt {
    attlist.if_stmt,
    (embedded_remark | tail_remark)?,
    logical_expression,
    statement_block,
    statement_block?
  }
attlist.if_stmt &=
  [ a:defaultValue = "if_stmt" ]
  attribute express-production { string "if_stmt" }?
import_all = element import_all { attlist.import_all, empty }
attlist.import_all &=
  [ a:defaultValue = "#NONE" ]
  attribute express-production { string "#NONE" }?
in = element in { attlist.in, empty }
attlist.in &=
  [ a:defaultValue = "IN" ]
  attribute express-production { string "IN" }?
increment =
  element increment {
    attlist.increment,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.increment &=
  [ a:defaultValue = "increment" ]
  attribute express-production { string "increment" }?
increment_control =
  element increment_control {
    attlist.increment_control,
    (embedded_remark | tail_remark)?,
    variable_id,
    lower_bound,
    upper_bound,
    increment?
  }
attlist.increment_control &=
  [ a:defaultValue = "increment_control" ]
  attribute express-production { string "increment_control" }?
index_qualifier =
  element index_qualifier {
    attlist.index_qualifier,
    (embedded_remark | tail_remark)?,
    low_index,
    high_index?
  }
attlist.index_qualifier &=
  [ a:defaultValue = "index_qualifier" ]
  attribute express-production { string "index_qualifier" }?
index_spec =
  element index_spec {
    attlist.index_spec,
    (embedded_remark | tail_remark)?,
    low_index,
    high_index?
  }
attlist.index_spec &=
  [ a:defaultValue = "bound_spec" ]
  attribute express-production { string "bound_spec" }?
inherited_attribute_instance =
  element inherited_attribute_instance {
    attlist.inherited_attribute_instance,
    (binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | bag_literal
     | list_literal
     | set_literal
     | array_literal
     | type_literal
     | entity_instance
     | entity_instance_as_group
     | entity_instance_ref)
  }
attlist.inherited_attribute_instance &=
  attribute express_attribute_name { xsd:NMTOKEN },
  [ a:defaultValue = "explicit" ]
  attribute express_attribute_type {
    "explicit" | "inverse" | "derived"
  }?
insert = element insert { attlist.insert, empty }
attlist.insert &=
  [ a:defaultValue = "INSERT" ]
  attribute express-production { string "INSERT" }?
instance_equal =
  element instance_equal { attlist.instance_equal, empty }
attlist.instance_equal &=
  [ a:defaultValue = ":=:" ]
  attribute express-production { string ":=:" }?
instance_not_equal =
  element instance_not_equal { attlist.instance_not_equal, empty }
attlist.instance_not_equal &=
  [ a:defaultValue = ":<>:" ]
  attribute express-production { string ":<>:" }?
integer = element integer { attlist.integer, empty }
attlist.integer &=
  [ a:defaultValue = "integer_type" ]
  attribute express-production { string "integer_type" }?
integer_divide =
  element integer_divide { attlist.integer_divide, empty }
attlist.integer_divide &=
  [ a:defaultValue = "DIV" ]
  attribute express-production { string "DIV" }?
integer_literal =
  element integer_literal { attlist.integer_literal, text }
attlist.integer_literal &=
  [ a:defaultValue = "integer_literal" ]
  attribute express-production { string "integer_literal" }?,
  attribute express_constant_name { xsd:NMTOKEN }?
interface_specification_block =
  element interface_specification_block {
    attlist.interface_specification_block,
    (embedded_remark | tail_remark)?,
    (reference_from | use_from)+
  }
attlist.interface_specification_block &=
  [ a:defaultValue = "interface_specification" ]
  attribute express-production { string "interface_specification" }?
interval =
  element interval {
    attlist.interval,
    (embedded_remark | tail_remark)?,
    (interval_low_inclusive | interval_low_exclusive),
    interval_item,
    (interval_high_inclusive | interval_high_exclusive)
  }
attlist.interval &=
  [ a:defaultValue = "interval" ]
  attribute express-production { string "interval" }?
interval_high_exclusive =
  element interval_high_exclusive {
    attlist.interval_high_exclusive,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.interval_high_exclusive &=
  [ a:defaultValue = "interval_high" ]
  attribute express-production { string "interval_high" }?
interval_high_inclusive =
  element interval_high_inclusive {
    attlist.interval_high_inclusive,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.interval_high_inclusive &=
  [ a:defaultValue = "interval_high" ]
  attribute express-production { string "interval_high" }?
interval_item =
  element interval_item {
    attlist.interval_item,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.interval_item &=
  [ a:defaultValue = "interval_item" ]
  attribute express-production { string "interval_item" }?
interval_low_exclusive =
  element interval_low_exclusive {
    attlist.interval_low_exclusive,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.interval_low_exclusive &=
  [ a:defaultValue = "interval_low" ]
  attribute express-production { string "interval_low" }?
interval_low_inclusive =
  element interval_low_inclusive {
    attlist.interval_low_inclusive,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.interval_low_inclusive &=
  [ a:defaultValue = "interval_low" ]
  attribute express-production { string "interval_low" }?
inverse_attr =
  element inverse_attr {
    attlist.inverse_attr,
    (embedded_remark | tail_remark)?,
    (attribute_id | qualified_attribute),
    entity_ref,
    attribute_ref,
    (inverse_set | inverse_bag)?
  }
attlist.inverse_attr &=
  [ a:defaultValue = "inverse_attr" ]
  attribute express-production { string "inverse_attr" }?
inverse_bag =
  element inverse_bag {
    attlist.inverse_bag, (embedded_remark | tail_remark)?, bound_spec?
  }
attlist.inverse_bag &=
  [ a:defaultValue = "BAG" ]
  attribute express-production { string "BAG" }?
inverse_clause =
  element inverse_clause {
    attlist.inverse_clause,
    (embedded_remark | tail_remark)?,
    inverse_attr+
  }
attlist.inverse_clause &=
  [ a:defaultValue = "inverse_clause" ]
  attribute express-production { string "inverse_clause" }?
inverse_set =
  element inverse_set {
    attlist.inverse_set, (embedded_remark | tail_remark)?, bound_spec?
  }
attlist.inverse_set &=
  [ a:defaultValue = "SET" ]
  attribute express-production { string "SET" }?
iso_10303_28 =
  element iso_10303_28 {
    attlist.iso_10303_28,
    iso_10303_28_header?,
    (express_schema | express_data)+
  }
attlist.iso_10303_28 &=
  attribute representation_category { xsd:NMTOKENS },
  [ a:defaultValue = "TS-1" ] attribute version { string "TS-1" }?
iso_10303_28_header =
  element iso_10303_28_header {
    attlist.iso_10303_28_header,
    document_name,
    purpose?,
    time_stamp?,
    author?,
    originating_organization?,
    authorization?,
    originating_system?,
    preprocessor_version?,
    documentation?
  }
attlist.iso_10303_28_header &= empty
label = element label { attlist.label, text }
attlist.label &=
  [ a:defaultValue = "label" ]
  attribute express-production { string "label" }?
length = element length { attlist.length, empty }
attlist.length &=
  [ a:defaultValue = "LENGTH" ]
  attribute express-production { string "LENGTH" }?
less_than = element less_than { attlist.less_than, empty }
attlist.less_than &=
  [ a:defaultValue = "<" ] attribute express-production { string "<" }?
less_than_or_equal =
  element less_than_or_equal { attlist.less_than_or_equal, empty }
attlist.less_than_or_equal &=
  [ a:defaultValue = "<=" ]
  attribute express-production { string "<=" }?
like = element like { attlist.like, empty }
attlist.like &=
  [ a:defaultValue = "LIKE" ]
  attribute express-production { string "LIKE" }?
list_literal =
  element list_literal {
    attlist.list_literal,
    (binary_literal*
     | boolean_literal*
     | integer_literal*
     | logical_literal*
     | real_literal*
     | string_literal*
     | bag_literal*
     | list_literal*
     | set_literal*
     | array_literal*
     | type_literal*
     | (entity_instance
        | entity_instance_as_group
        | entity_instance_ref)*)
  }
attlist.list_literal &= attribute express_constant_name { xsd:NMTOKEN }?
list_type =
  element list_type {
    attlist.list_type,
    (embedded_remark | tail_remark)?,
    bound_spec?,
    base_type,
    unique?
  }
attlist.list_type &=
  [ a:defaultValue = "list_type" ]
  attribute express-production { string "list_type" }?
lobound = element lobound { attlist.lobound, empty }
attlist.lobound &=
  [ a:defaultValue = "LOBOUND" ]
  attribute express-production { string "LOBOUND" }?
local_variable_block =
  element local_variable_block {
    attlist.local_variable_block,
    (embedded_remark | tail_remark)?,
    local_variable_decl*
  }
attlist.local_variable_block &=
  [ a:defaultValue = "local_decl" ]
  attribute express-production { string "local_decl" }?
local_variable_decl =
  element local_variable_decl {
    attlist.local_variable_decl,
    (embedded_remark | tail_remark)?,
    variable_id,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)?
  }
attlist.local_variable_decl &=
  [ a:defaultValue = "local_variable" ]
  attribute express-production { string "local_variable" }?
log = element log { attlist.log, empty }
attlist.log &=
  [ a:defaultValue = "LOG" ]
  attribute express-production { string "LOG" }?
log10 = element log10 { attlist.log10, empty }
attlist.log10 &=
  [ a:defaultValue = "LOG10" ]
  attribute express-production { string "LOG10" }?
log2 = element log2 { attlist.log2, empty }
attlist.log2 &=
  [ a:defaultValue = "LOG2" ]
  attribute express-production { string "LOG2" }?
logical = element logical { attlist.logical, empty }
attlist.logical &=
  [ a:defaultValue = "logical_type" ]
  attribute express-production { string "logical_type" }?
logical_expression =
  element logical_expression {
    attlist.logical_expression,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)
  }
attlist.logical_expression &=
  [ a:defaultValue = "logical_expression" ]
  attribute express-production { string "logical_expression" }?
logical_literal =
  element logical_literal {
    attlist.logical_literal,
    (embedded_remark | tail_remark)?,
    (false | true | unknown)
  }
attlist.logical_literal &=
  [ a:defaultValue = "logical_literal" ]
  attribute express-production { string "logical_literal" }?,
  attribute express_constant_name { xsd:NMTOKEN }?
loindex = element loindex { attlist.loindex, empty }
attlist.loindex &=
  [ a:defaultValue = "LOINDEX" ]
  attribute express-production { string "LOINDEX" }?
lower_bound =
  element lower_bound {
    attlist.lower_bound,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.lower_bound &=
  [ a:defaultValue = "bound_1" ]
  attribute express-production { string "bound_1" }?
low_index =
  element low_index {
    attlist.low_index,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.low_index &=
  [ a:defaultValue = "index_1" ]
  attribute express-production { string "index_1" }?
mod = element mod { attlist.mod, empty }
attlist.mod &=
  [ a:defaultValue = "MOD" ]
  attribute express-production { string "MOD" }?
multiply = element multiply { attlist.multiply, empty }
attlist.multiply &=
  [ a:defaultValue = "*" ] attribute express-production { string "*" }?
negate = element negate { attlist.negate, empty }
attlist.negate &=
  [ a:defaultValue = "-" ] attribute express-production { string "-" }?
not = element not { attlist.not, empty }
attlist.not &=
  [ a:defaultValue = "NOT" ]
  attribute express-production { string "NOT" }?
not_equal = element not_equal { attlist.not_equal, empty }
attlist.not_equal &=
  [ a:defaultValue = "<>" ]
  attribute express-production { string "<>" }?
null_stmt = element null_stmt { attlist.null_stmt, empty }
attlist.null_stmt &=
  [ a:defaultValue = "null_stmt" ]
  attribute express-production { string "null_stmt" }?
number = element number { attlist.number, empty }
attlist.number &=
  [ a:defaultValue = "number_type" ]
  attribute express-production { string "number_type" }?
numeric_expression =
  element numeric_expression {
    attlist.numeric_expression,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.numeric_expression &=
  [ a:defaultValue = "numeric_expression" ]
  attribute express-production { string "numeric_expression" }?
nvl = element nvl { attlist.nvl, empty }
attlist.nvl &=
  [ a:defaultValue = "NVL" ]
  attribute express-production { string "NVL" }?
odd = element odd { attlist.odd, empty }
attlist.odd &=
  [ a:defaultValue = "ODD" ]
  attribute express-production { string "ODD" }?
optional = element optional { attlist.optional, empty }
attlist.optional &=
  [ a:defaultValue = "OPTIONAL" ]
  attribute express-production { string "OPTIONAL" }?
or = element or { attlist.or, empty }
attlist.or &=
  [ a:defaultValue = "OR" ]
  attribute express-production { string "OR" }?
originating_organization =
  element originating_organization {
    attlist.originating_organization, text
  }
attlist.originating_organization &= empty
originating_system =
  element originating_system { attlist.originating_system, text }
attlist.originating_system &= empty
otherwise =
  element otherwise {
    attlist.otherwise,
    (embedded_remark | tail_remark)?,
    (alias_stmt
     | assignment_stmt
     | case_stmt
     | statement_block
     | escape_stmt
     | if_stmt
     | null_stmt
     | procedure_call_stmt
     | repeat_stmt
     | return_stmt
     | skip_stmt)
  }
attlist.otherwise &=
  [ a:defaultValue = "OTHERWISE" ]
  attribute express-production { string "OTHERWISE" }?
parameter_id = element parameter_id { attlist.parameter_id, text }
attlist.parameter_id &=
  [ a:defaultValue = "parameter_id" ]
  attribute express-production { string "parameter_id" }?,
  attribute id { xsd:ID }?
parameter_ref = element parameter_ref { attlist.parameter_ref, text }
attlist.parameter_ref &=
  [ a:defaultValue = "parameter_ref" ]
  attribute express-production { string "parameter_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (parameter_id)" ]
  attribute reftype { string "refid (parameter_id)" }?
parenthetic_expression =
  element parenthetic_expression {
    attlist.parenthetic_expression,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)
  }
attlist.parenthetic_expression &=
  [ a:defaultValue = "()" ]
  attribute express-production { string "()" }?
partial_entity_instance =
  element partial_entity_instance {
    attlist.partial_entity_instance,
    (inherited_attribute_instance | attribute_instance)*,
    partial_entity_instance*
  }
attlist.partial_entity_instance &=
  attribute express_entity_name { xsd:NMTOKEN },
  attribute express_schema_name { xsd:NMTOKEN }?,
  attribute id { xsd:ID }?
pi = element pi { attlist.pi, empty }
attlist.pi &=
  [ a:defaultValue = "PI" ]
  attribute express-production { string "PI" }?
plus = element plus { attlist.plus, empty }
attlist.plus &=
  [ a:defaultValue = "+" ] attribute express-production { string "+" }?
population =
  element population {
    attlist.population, (embedded_remark | tail_remark)?, entity_ref
  }
attlist.population &=
  [ a:defaultValue = "population" ]
  attribute express-production { string "population" }?
precision_spec =
  element precision_spec {
    attlist.precision_spec,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.precision_spec &=
  [ a:defaultValue = "precision_spec" ]
  attribute express-production { string "precision_spec" }?
preprocessor_version =
  element preprocessor_version { attlist.preprocessor_version, text }
attlist.preprocessor_version &= empty
procedure_call_stmt =
  element procedure_call_stmt {
    attlist.procedure_call_stmt,
    (embedded_remark | tail_remark)?,
    ((insert | remove | procedure_ref),
     (aggregate_initializer
      | entity_constructor
      | enumeration_reference
      | interval
      | query
      | binary_literal
      | boolean_literal
      | integer_literal
      | logical_literal
      | real_literal
      | string_literal
      | attribute_ref
      | const_e
      | pi
      | self
      | unset
      | constant_ref
      | function_call
      | parameter_ref
      | variable_ref
      | population
      | qualified_factor
      | parenthetic_expression
      | unary_op
      | factor
      | term
      | simple_expression
      | relation_expression)*)
  }
attlist.procedure_call_stmt &=
  [ a:defaultValue = "procedure_call_stmt" ]
  attribute express-production { string "procedure_call_stmt" }?
procedure_decl =
  element procedure_decl {
    attlist.procedure_decl,
    (embedded_remark | tail_remark)?,
    procedure_id,
    procedure_formal_parameter_block?,
    algorithm_head?,
    statement_block?
  }
attlist.procedure_decl &=
  [ a:defaultValue = "procedure_decl" ]
  attribute express-production { string "procedure_decl" }?
procedure_formal_parameter_block =
  element procedure_formal_parameter_block {
    attlist.procedure_formal_parameter_block,
    (embedded_remark | tail_remark)?,
    (formal_parameter | var_formal_parameter)*
  }
attlist.procedure_formal_parameter_block &=
  [ a:defaultValue = "formal_parameter" ]
  attribute express-production { string "formal_parameter" }?
procedure_id = element procedure_id { attlist.procedure_id, text }
attlist.procedure_id &=
  [ a:defaultValue = "procedure_id" ]
  attribute express-production { string "procedure_id" }?,
  attribute id { xsd:ID }?
procedure_import =
  element procedure_import {
    attlist.procedure_import,
    (embedded_remark | tail_remark)?,
    procedure_id,
    procedure_ref
  }
attlist.procedure_import &=
  [ a:defaultValue = "resource_or_rename" ]
  attribute express-production { string "resource_or_rename" }?
procedure_ref = element procedure_ref { attlist.procedure_ref, text }
attlist.procedure_ref &=
  [ a:defaultValue = "procedure_ref" ]
  attribute express-production { string "procedure_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (procedure_id)" ]
  attribute reftype { string "refid (procedure_id)" }?
purpose = element purpose { attlist.purpose, text }
attlist.purpose &= empty
qualified_attribute =
  element qualified_attribute {
    attlist.qualified_attribute,
    (embedded_remark | tail_remark)?,
    entity_ref,
    attribute_ref
  }
attlist.qualified_attribute &=
  [ a:defaultValue = "qualified_attribute" ]
  attribute express-production { string "qualified_attribute" }?
qualified_factor =
  element qualified_factor {
    attlist.qualified_factor,
    (embedded_remark | tail_remark)?,
    (attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population),
    qualifier
  }
attlist.qualified_factor &=
  [ a:defaultValue = "qualifiable_factor" ]
  attribute express-production { string "qualifiable_factor" }?
qualifier =
  element qualifier {
    attlist.qualifier,
    (embedded_remark | tail_remark)?,
    (attribute_ref | entity_ref | index_qualifier)*
  }
attlist.qualifier &=
  [ a:defaultValue = "qualifier" ]
  attribute express-production { string "qualifier" }?
query =
  element query {
    attlist.query,
    (embedded_remark | tail_remark)?,
    variable_id,
    (aggregate_source, logical_expression)
  }
attlist.query &=
  [ a:defaultValue = "query_expression" ]
  attribute express-production { string "query_expression" }?
raise_to_power =
  element raise_to_power { attlist.raise_to_power, empty }
attlist.raise_to_power &=
  [ a:defaultValue = "**" ]
  attribute express-production { string "**" }?
real =
  element real {
    attlist.real, (embedded_remark | tail_remark)?, precision_spec?
  }
attlist.real &=
  [ a:defaultValue = "real_type" ]
  attribute express-production { string "real_type" }?
real_divide = element real_divide { attlist.real_divide, empty }
attlist.real_divide &=
  [ a:defaultValue = "/" ] attribute express-production { string "/" }?
real_literal = element real_literal { attlist.real_literal, text }
attlist.real_literal &=
  [ a:defaultValue = "real_literal" ]
  attribute express-production { string "real_literal" }?,
  attribute express_constant_name { xsd:NMTOKEN }?
reference_from =
  element reference_from {
    attlist.reference_from,
    (embedded_remark | tail_remark)?,
    schema_ref,
    (import_all
     | (constant_import
        | entity_import
        | function_import
        | procedure_import
        | type_import)+)
  }
attlist.reference_from &=
  [ a:defaultValue = "reference_clause" ]
  attribute express-production { string "reference_clause" }?
relation_expression =
  element relation_expression {
    attlist.relation_expression,
    (embedded_remark | tail_remark)?,
    (less_than
     | greater_than
     | less_than_or_equal
     | greater_than_or_equal
     | not_equal
     | equal
     | instance_not_equal
     | instance_equal
     | in
     | like),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.relation_expression &=
  [ a:defaultValue = "expression" ]
  attribute express-production { string "expression" }?
remove = element remove { attlist.remove, empty }
attlist.remove &=
  [ a:defaultValue = "REMOVE" ]
  attribute express-production { string "REMOVE" }?
repeat_control =
  element repeat_control {
    attlist.repeat_control,
    (embedded_remark | tail_remark)?,
    ((increment_control, while?, until?) | (while, until?) | until)
  }
attlist.repeat_control &=
  [ a:defaultValue = "repeat_control" ]
  attribute express-production { string "repeat_control" }?
repeat_stmt =
  element repeat_stmt {
    attlist.repeat_stmt,
    (embedded_remark | tail_remark)?,
    repeat_control,
    statement_block
  }
attlist.repeat_stmt &=
  [ a:defaultValue = "repeat_stmt" ]
  attribute express-production { string "repeat_stmt" }?
repetition =
  element repetition {
    attlist.repetition,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression)
  }
attlist.repetition &=
  [ a:defaultValue = "repetition" ]
  attribute express-production { string "repetition" }?
return_stmt =
  element return_stmt {
    attlist.return_stmt,
    (embedded_remark | tail_remark)?,
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression
     | relation_expression)?
  }
attlist.return_stmt &=
  [ a:defaultValue = "return_stmt" ]
  attribute express-production { string "return_stmt" }?
rolesof = element rolesof { attlist.rolesof, empty }
attlist.rolesof &=
  [ a:defaultValue = "ROLESOF" ]
  attribute express-production { string "ROLESOF" }?
rule_decl =
  element rule_decl {
    attlist.rule_decl,
    (embedded_remark | tail_remark)?,
    rule_id,
    applies_to_entities,
    algorithm_head?,
    statement_block?,
    where_clause
  }
attlist.rule_decl &=
  [ a:defaultValue = "rule_decl" ]
  attribute express-production { string "rule_decl" }?
rule_id = element rule_id { attlist.rule_id, text }
attlist.rule_id &=
  [ a:defaultValue = "rule_id" ]
  attribute express-production { string "rule_id" }?
schema_decl =
  element schema_decl {
    attlist.schema_decl,
    (embedded_remark | tail_remark)?,
    schema_id,
    interface_specification_block?,
    constant_block?,
    (entity_decl
     | function_decl
     | procedure_decl
     | type_decl
     | rule_decl
     | constraint_decl)*
  }
attlist.schema_decl &=
  [ a:defaultValue = "schema_decl" ]
  attribute express-production { string "schema_decl" }?
schema_id = element schema_id { attlist.schema_id, text }
attlist.schema_id &=
  [ a:defaultValue = "schema_id" ]
  attribute express-production { string "schema_id" }?,
  attribute id { xsd:ID }?
schema_instance =
  element schema_instance {
    attlist.schema_instance,
    (entity_instance | entity_instance_as_group | external_refid)*
  }
attlist.schema_instance &=
  [ a:defaultValue = "yes" ]
  attribute complete_population { "yes" | "no" }?,
  attribute express_schema_identifier { text }?,
  attribute express_schema_name { xsd:NMTOKEN },
  attribute express_schema_version { text }?,
  attribute id { xsd:ID }?,
  attribute xml:lang { text }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (express_schema | external_refid)" ]
  attribute reftype {
    string "refid (express_schema | external_refid)"
  }?
schema_ref = element schema_ref { attlist.schema_ref, text }
attlist.schema_ref &=
  [ a:defaultValue = "schema_ref" ]
  attribute express-production { string "schema_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (schema_id | external_refid)" ]
  attribute reftype { string "refid (schema_id | external_refid)" }?
schema_text = element schema_text { attlist.schema_text, text }
attlist.schema_text &= empty
select =
  element select {
    attlist.select,
    (embedded_remark | tail_remark)?,
    extensible?,
    generic_entity?,
    based_on?,
    (entity_ref | type_ref)*
  }
attlist.select &=
  [ a:defaultValue = "select_type" ]
  attribute express-production { string "select_type" }?
generic_entity =
  element generic_entity { attlist.generic_entity, empty }
attlist.generic_entity &= empty
self = element self { attlist.self, empty }
attlist.self &=
  [ a:defaultValue = "SELF" ]
  attribute express-production { string "SELF" }?
set_literal =
  element set_literal {
    attlist.set_literal,
    (binary_literal*
     | boolean_literal*
     | integer_literal*
     | logical_literal*
     | real_literal*
     | string_literal*
     | bag_literal*
     | list_literal*
     | set_literal*
     | array_literal*
     | type_literal*
     | (entity_instance
        | entity_instance_as_group
        | entity_instance_ref)*)
  }
attlist.set_literal &= attribute express_constant_name { xsd:NMTOKEN }?
set_type =
  element set_type {
    attlist.set_type,
    (embedded_remark | tail_remark)?,
    bound_spec?,
    base_type
  }
attlist.set_type &=
  [ a:defaultValue = "set_type" ]
  attribute express-production { string "set_type" }?
simple_expression =
  element simple_expression {
    attlist.simple_expression,
    (embedded_remark | tail_remark)?,
    (add | subtract | or | xor),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term
     | simple_expression)
  }
attlist.simple_expression &=
  [ a:defaultValue = "simple_expression" ]
  attribute express-production { string "simple_expression" }?
sin = element sin { attlist.sin, empty }
attlist.sin &=
  [ a:defaultValue = "SIN" ]
  attribute express-production { string "SIN" }?
sizeof = element sizeof { attlist.sizeof, empty }
attlist.sizeof &=
  [ a:defaultValue = "SIZEOF" ]
  attribute express-production { string "SIZEOF" }?
skip_stmt = element skip_stmt { attlist.skip_stmt, empty }
attlist.skip_stmt &=
  [ a:defaultValue = "SKIP" ]
  attribute express-production { string "SKIP" }?
sqrt = element sqrt { attlist.sqrt, empty }
attlist.sqrt &=
  [ a:defaultValue = "SQRT" ]
  attribute express-production { string "SQRT" }?
statement_block =
  element statement_block {
    attlist.statement_block,
    (embedded_remark | tail_remark)?,
    (alias_stmt
     | assignment_stmt
     | case_stmt
     | statement_block
     | escape_stmt
     | if_stmt
     | null_stmt
     | procedure_call_stmt
     | repeat_stmt
     | return_stmt
     | skip_stmt)+
  }
attlist.statement_block &=
  [ a:defaultValue = "stmt" ]
  attribute express-production { string "stmt" }?
\string =
  element string {
    attlist.string, (embedded_remark | tail_remark)?, width_spec?
  }
attlist.string &=
  [ a:defaultValue = "string_type" ]
  attribute express-production { string "string_type" }?
string_literal = element string_literal { attlist.string_literal, text }
attlist.string_literal &=
  [ a:defaultValue = "string_literal" ]
  attribute express-production { string "string_literal" }?,
  attribute express_constant_name { xsd:NMTOKEN }?
subtract = element subtract { attlist.subtract, empty }
attlist.subtract &=
  [ a:defaultValue = "-" ] attribute express-production { string "-" }?
subtype_of =
  element subtype_of {
    attlist.subtype_of, (embedded_remark | tail_remark)?, entity_ref+
  }
attlist.subtype_of &=
  [ a:defaultValue = "subtype_declaration" ]
  attribute express-production { string "subtype_declaration" }?
supertype_and =
  element supertype_and {
    attlist.supertype_and,
    (embedded_remark | tail_remark)?,
    (entity_ref | supertype_one_of | supertype_and_or | supertype_and)+
  }
attlist.supertype_and &=
  [ a:defaultValue = "supertype_rule" ]
  attribute express-production { string "supertype_rule" }?
supertype_and_or =
  element supertype_and_or {
    attlist.supertype_and_or,
    (embedded_remark | tail_remark)?,
    (entity_ref | supertype_one_of | supertype_and_or | supertype_and)+
  }
attlist.supertype_and_or &=
  [ a:defaultValue = "supertype_rule" ]
  attribute express-production { string "supertype_rule" }?
supertype_of =
  element supertype_of {
    attlist.supertype_of,
    (embedded_remark | tail_remark)?,
    (entity_ref | supertype_one_of | supertype_and_or | supertype_and)
  }
attlist.supertype_of &=
  [ a:defaultValue = "supertype_rule" ]
  attribute express-production { string "supertype_rule" }?
supertype_one_of =
  element supertype_one_of {
    attlist.supertype_one_of,
    (embedded_remark | tail_remark)?,
    (entity_ref | supertype_one_of | supertype_and_or | supertype_and)+
  }
attlist.supertype_one_of &=
  [ a:defaultValue = "one_of" ]
  attribute express-production { string "one_of" }?
tail_remark = element tail_remark { attlist.tail_remark, text* }
attlist.tail_remark &=
  [ a:defaultValue = "tail_remark" ]
  attribute express-production { string "tail_remark" }?
tan = element tan { attlist.tan, empty }
attlist.tan &=
  [ a:defaultValue = "TAN" ]
  attribute express-production { string "TAN" }?
term =
  element term {
    attlist.term,
    (multiply
     | real_divide
     | integer_divide
     | mod
     | and
     | complex_entity_constructor),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term),
    (aggregate_initializer
     | entity_constructor
     | enumeration_reference
     | interval
     | query
     | binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression
     | unary_op
     | factor
     | term)
  }
attlist.term &=
  [ a:defaultValue = "term" ]
  attribute express-production { string "term" }?
time_stamp = element time_stamp { attlist.time_stamp, text }
attlist.time_stamp &= empty
total_over =
  element total_over {
    attlist.total_over, (embedded_remark | tail_remark)?, entity_ref+
  }
attlist.total_over &=
  [ a:defaultValue = "total_over" ]
  attribute express-production { string "total_over" }?
true = element true { attlist.true, empty }
attlist.true &=
  [ a:defaultValue = "TRUE" ]
  attribute express-production { string "TRUE" }?
typeof = element typeof { attlist.typeof, empty }
attlist.typeof &=
  [ a:defaultValue = "TYPEOF" ]
  attribute express-production { string "TYPEOF" }?
type_decl =
  element type_decl {
    attlist.type_decl,
    (embedded_remark | tail_remark)?,
    type_id,
    underlying_type,
    where_clause?
  }
attlist.type_decl &=
  [ a:defaultValue = "type_decl" ]
  attribute express-production { string "type_decl" }?
type_id = element type_id { attlist.type_id, text }
attlist.type_id &=
  [ a:defaultValue = "type_id" ]
  attribute express-production { string "type_id" }?,
  attribute id { xsd:ID }?
type_import =
  element type_import {
    attlist.type_import,
    (embedded_remark | tail_remark)?,
    type_id,
    type_ref
  }
attlist.type_import &=
  [ a:defaultValue = "resource_or_rename" ]
  attribute express-production { string "resource_or_rename" }?
type_label_id = element type_label_id { attlist.type_label_id, text }
attlist.type_label_id &=
  [ a:defaultValue = "type_label_id" ]
  attribute express-production { string "type_label_id" }?,
  attribute id { xsd:ID }?
type_label_ref = element type_label_ref { attlist.type_label_ref, text }
attlist.type_label_ref &=
  [ a:defaultValue = "type_label_ref" ]
  attribute express-production { string "type_label_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (type_label_id)" ]
  attribute reftype { string "refid (type_label_id)" }?
type_literal =
  element type_literal {
    attlist.type_literal,
    (binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | bag_literal
     | list_literal
     | set_literal
     | array_literal
     | type_literal
     | entity_instance
     | entity_instance_as_group
     | entity_instance_ref
     | enumeration_ref)
  }
attlist.type_literal &=
  attribute enumeration_domain { xsd:NMTOKENS }?,
  attribute express_constant_name { xsd:NMTOKEN }?,
  attribute express_schema_name { xsd:NMTOKEN }?,
  attribute express_type_name { xsd:NMTOKEN }
type_ref = element type_ref { attlist.type_ref, text }
attlist.type_ref &=
  [ a:defaultValue = "type_ref" ]
  attribute express-production { string "type_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (type_id)" ]
  attribute reftype { string "refid (type_id)" }?
unary_op =
  element unary_op {
    attlist.unary_op,
    (embedded_remark | tail_remark)?,
    (plus | negate | not),
    (binary_literal
     | boolean_literal
     | integer_literal
     | logical_literal
     | real_literal
     | string_literal
     | attribute_ref
     | const_e
     | pi
     | self
     | unset
     | constant_ref
     | function_call
     | parameter_ref
     | variable_ref
     | population
     | qualified_factor
     | parenthetic_expression)
  }
attlist.unary_op &=
  [ a:defaultValue = "unary_op" ]
  attribute express-production { string "unary_op" }?
underlying_type =
  element underlying_type {
    attlist.underlying_type,
    (embedded_remark | tail_remark)?,
    (enumeration
     | select
     | array_type
     | bag_type
     | list_type
     | set_type
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | type_ref
     | generic_entity_type)
  }
attlist.underlying_type &=
  [ a:defaultValue = "underlying_type" ]
  attribute express-production { string "underlying_type" }?
unique = element unique { attlist.unique, empty }
attlist.unique &=
  [ a:defaultValue = "UNIQUE" ]
  attribute express-production { string "UNIQUE" }?
unique_clause =
  element unique_clause {
    attlist.unique_clause,
    (embedded_remark | tail_remark)?,
    unique_rule+
  }
attlist.unique_clause &=
  [ a:defaultValue = "unique_clause" ]
  attribute express-production { string "unique_clause" }?
unique_rule =
  element unique_rule {
    attlist.unique_rule,
    (embedded_remark | tail_remark)?,
    label?,
    (attribute_ref | qualified_attribute)+
  }
attlist.unique_rule &=
  [ a:defaultValue = "unique_rule" ]
  attribute express-production { string "unique_rule" }?
unknown = element unknown { attlist.unknown, empty }
attlist.unknown &=
  [ a:defaultValue = "UNKNOWN" ]
  attribute express-production { string "UNKNOWN" }?
unset = element unset { attlist.unset, empty }
attlist.unset &=
  [ a:defaultValue = "?" ] attribute express-production { string "?" }?
until =
  element until {
    attlist.until, (embedded_remark | tail_remark)?, logical_expression
  }
attlist.until &=
  [ a:defaultValue = "until_control" ]
  attribute express-production { string "until_control" }?
upper_bound =
  element upper_bound {
    attlist.upper_bound,
    (embedded_remark | tail_remark)?,
    (unset | integer_literal | numeric_expression)
  }
attlist.upper_bound &=
  [ a:defaultValue = "bound_2" ]
  attribute express-production { string "bound_2" }?
usedin = element usedin { attlist.usedin, empty }
attlist.usedin &=
  [ a:defaultValue = "USEDIN" ]
  attribute express-production { string "USEDIN" }?
use_from =
  element use_from {
    attlist.use_from,
    (embedded_remark | tail_remark)?,
    schema_ref,
    (import_all | (entity_import | type_import)+)
  }
attlist.use_from &=
  [ a:defaultValue = "use_clause" ]
  attribute express-production { string "use_clause" }?
value = element value { attlist.value, empty }
attlist.value &=
  [ a:defaultValue = "VALUE" ]
  attribute express-production { string "VALUE" }?
value_in = element value_in { attlist.value_in, empty }
attlist.value_in &=
  [ a:defaultValue = "VALUE_IN" ]
  attribute express-production { string "VALUE_IN" }?
value_unique = element value_unique { attlist.value_unique, empty }
attlist.value_unique &=
  [ a:defaultValue = "VALUE_UNIQUE" ]
  attribute express-production { string "VALUE_UNIQUE" }?
variable_id = element variable_id { attlist.variable_id, text }
attlist.variable_id &=
  [ a:defaultValue = "variable_id" ]
  attribute express-production { string "variable_id" }?,
  attribute id { xsd:ID }?
variable_ref = element variable_ref { attlist.variable_ref, text }
attlist.variable_ref &=
  [ a:defaultValue = "variable_ref" ]
  attribute express-production { string "variable_ref" }?,
  attribute refid { xsd:IDREF }?,
  [ a:defaultValue = "refid (variable_id)" ]
  attribute reftype { string "refid (variable_id)" }?
var_formal_parameter =
  element var_formal_parameter {
    attlist.var_formal_parameter,
    (embedded_remark | tail_remark)?,
    parameter_id,
    (aggregate_type
     | general_array_type
     | general_bag_type
     | general_list_type
     | general_set_type
     | generic_type
     | entity_ref
     | type_ref
     | binary
     | boolean
     | integer
     | logical
     | number
     | real
     | \string
     | generic_entity_type)
  }
attlist.var_formal_parameter &=
  [ a:defaultValue = "formal_parameter" ]
  attribute express-production { string "formal_parameter" }?
where_clause =
  element where_clause {
    attlist.where_clause, (embedded_remark | tail_remark)?, domain_rule+
  }
attlist.where_clause &=
  [ a:defaultValue = "where_clause" ]
  attribute express-production { string "where_clause" }?
while =
  element while {
    attlist.while, (embedded_remark | tail_remark)?, logical_expression
  }
attlist.while &=
  [ a:defaultValue = "while_control" ]
  attribute express-production { string "while_control" }?
width_spec =
  element width_spec {
    attlist.width_spec,
    (embedded_remark | tail_remark)?,
    (integer_literal | numeric_expression),
    fixed?
  }
attlist.width_spec &=
  [ a:defaultValue = "width_spec" ]
  attribute express-production { string "width_spec" }?
xor = element xor { attlist.xor, empty }
attlist.xor &=
  [ a:defaultValue = "XOR" ]
  attribute express-production { string "XOR" }?
start = iso_10303_28
