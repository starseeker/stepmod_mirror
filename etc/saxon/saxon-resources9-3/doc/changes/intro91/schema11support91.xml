<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="changes" page="intro91" subpage="schema11support91"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: XML Schema 1.1</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: XML Schema 1.1"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>XML Schema 1.1</h1>
      <p>There is now a configuration flag to enable use of XML Schema 1.1 syntax; if this flag is not set, all new
XML Schema 1.1 features will be disabled. The flag can be set using <code>-xsdversion:1.1</code> on the command
line (of <code>Query</code>, <code>Transform</code>, or <code>Validate</code>), 
or by calling <code>configuration.setConfigurationProperty(FeatureKeys.XSD_VERSION, "1.1")</code>.</p>
      <p><b>Conditional Type Assignment</b> (often called co-constraints) is implemented. Any XPath expression
may be used to define the condition, so long as it only accesses the attributes and namespaces of the 
element in question. Rules on type subsumption not yet implemented.</p>
      <p>The <b>xpathDefaultNamespace</b> attribute is supported for both <code>xs:assert</code> and <code>xs:alternative</code>
(but not yet for <code>xs:field</code> or <code>xs:selector</code>).
The <code>xpathDefaultNamespace</code> attribute on <code>xs:schema</code> is also recognized.</p>
      <p>A model group defined with an <code>&lt;xs:all&gt;</code> compositor may now have arbitrary
 <code>minOccurs</code> and <code>maxOccurs</code> values on the element particles within the group.
 Much more analysis is now done to determine whether a sequence of choice group is a valid restriction 
 of a type that uses
 an <code>xs:all</code> compositor; some of this will also apply to XSD 1.0 schemas.
 For example, substitution groups are now taken into account, and the derived type is allowed
 to have an <code>xs:choice</code> content model (each branch of the choice must be a valid restriction
 of the base content model.)</p>
      <p>Element wildcards (<code>&lt;xs:any&gt;</code>) are now allowed in an a model group defined 
using <code>&lt;xs:all&gt;</code>.</p>
      <p>Local element and attribute declarations can now have a <code>targetNamespace</code> attribute, provided that they
appear within an <code>xs:restriction</code> element that restricts a complex type. This makes it easier to define
a restriction of a complex type that has been imported from another namespace, since it is now possible for the
restricted type to declare local elements and attributes having the same names as those from the base type.</p>
      <p>The reporting of validation errors on <code>xs:assert</code> has been improved: if the assertion takes the form
<code>empty(expression)</code> then the validator will not only report an error if the result of the expression is not
empty; it will also identify all the nodes (or atomic values) that were present in the result of the expression, enabling
easier detection and correction of the problem. This also works for the expression <code>not(exp)</code> provided that <code>exp</code>
has a static item type of <code>node()</code>. </p>
      <p>Saxon 9.1 also allows assertions on simple types. 
The assertion is defined by means of an <code>xs:assert</code> element acting as a facet, that is, it is
a child element of the <code>xs:restriction</code> child of the
<code>xs:simpleType</code> element. This can be any kind of simple type (atomic, list, or union). The value of the <code>test</code>
attribute must be an XPath expression. The expression is evaluated with no context item, but with the variable <code>$value</code>
set to the typed value of the element or attribute.
The assertion is satisfied if the effective boolean value of the expression is true. 
For example, for an atomic type that restricts xs:date, the assertion <code>&lt;xs:assert test="$value lt current-date()"/&gt;</code>
indicates that the date must be in the past.
For a list-valued type, the following assertion indicates that all items in the list must be distinct: 
<code>&lt;assert test="count($value) eq count(distinct-values($value))"/&gt;</code>. 
The XPath expression is allowed to invoke external
Java functions, allowing full procedural validation logic. The XPath expression has access only to the value
being validated, it cannot access any nodes in the document. For further details see 
<a class="bodylink" href="../../schema-processing/schema11/simpleassert.xml">Assertions on Simple Types</a>.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="schema10support91.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>