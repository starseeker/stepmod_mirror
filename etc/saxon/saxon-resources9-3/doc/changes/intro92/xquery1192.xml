<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="changes" page="intro92" subpage="xquery1192"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: XQuery 1.1</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: XQuery 1.1"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>XQuery 1.1</h1>
      <p>These new features are available only with Saxon-PE or Saxon-EE, and require XQuery 1.1 to be enabled 
 (a) from the command line (-qversion:1.1) or Configuration
and (b) from the query prolog (<code>xquery version "1.1";</code>).</p>
      <p>The try/catch syntax from the draft XQuery 1.1 specification is implemented, but without the ability to declare
variables to receive error information. This feature cannot be used with XQuery Updates.</p>
      <p>A subset of the grouping syntax from the draft XQuery 1.1 specification is implemented. The <code>group by</code> clause
must be preceded in the FLWOR expression by (a) a single <code>for</code> clause, which selects the sequence to be grouped, and (b)
a single <code>let</code> clause, which defines the grouping key; the "group by" clause must name the variable that is declared in the
<code>let</code> clause. For example: <code>for $x in //employee let $k := $x/department group by $k return ...</code>.
Within the <code>return</code> clause, <code>$x</code> refers to the content of the current group, and <code>$k</code>
to the current grouping key.</p>
      <p>The "outer for" clause of a FLWOR expression is implemented. The implementation is functionally complete, but there is no
optimization.</p>
      <p>Computed namespace node constructors are supported, in the form <code>namespace prefix {uri-expression}</code> or
<code>namespace {prefix-expression} {uri-expression}</code>.</p>
      <p>In the query prolog, it is now possible to provide a default value for an external variable (for example,
<code>declare variable $ext external := 0;</code>.</p>
      <p>The <code>declare context item</code> declaration in the query prolog is implemented. This allows a
required type and a default value to be declared for the context item. At present (the rules aren't entirely clear)
it is possible to specify a value from the calling API, or to not specify a value, regardless whether
"external" is specified or not. At present there is no interaction with the API facilities for defining
a required type for the context item: both can be used independently.</p>
      <p>The expression <code>validate as type-name { expr }</code> is implemented.</p>
      <p>The functions <code>format-date()</code>, <code>format-time()</code>, and <code>format-dateTime()</code>,
as specified in XSLT 2.0, are now also available in XQuery 1.1. </p>
      <p>The function <code>format-number()</code> is now available, along with the new syntax in the Query Prolog
to declare a (named or default) decimal-format. (This has entailed some internal change in the way decimal
formats are managed, since XQuery allows each module to have its own set of named decimal formats.)</p>
      <p class="subhead">Higher-order functions</p>
      <p>The new facility for higher-order functions is fully implemented, with one or two restrictions.</p>
      <p>The syntax <code>my:function#3</code> is now available. This is synonymous with the extension available in
earlier releases, <code>saxon:function('my:function', 3)</code>.
This has also been extended so that it works with all functions; the Saxon extension previously 
worked only with user-written functions.</p>
      <p>The <code>SequenceType</code> syntax <code>function()</code> is now available to denote the type of a function item, that is, the type of
the result of <code>my:function#3</code> or <code>saxon:function('my:function', 3)</code>. You can also use a full
type signature, for example <code>function(xs:int, xs:int) as xs:string*</code>.</p>
      <p>The type <code>function()</code> is implemented as a new subtype of <code>Item</code> represented by the Java class
<code>net.sf.saxon.om.FunctionItem</code>. Note that any code that assumes every Item is either a node or an atomic value
is potentially affected.</p>
      <p>Dynamic function calls can now be written, for example, as <code>$f(x, y)</code> rather than <code>saxon:call($f, x, y)</code> as
previously. In this expression <code>$f</code> can be replaced by any primary expression or filter expression whose value is
a function item.</p>
      <p>Inline (anonymous) functions can be written, for example <code>function ($x as xs:integer) as xs:boolean {$x mod 2 eq 0}</code>.
Such a function will typically be used as an argument in a function call expecting a parameter of type <code>function()</code>.</p>
      <p>The functions <code>fn:function-name()</code>, <code>fn:function-arity()</code>, and <code>fn:partial-apply()</code> are implemented.</p>
      <p>Saxon applies function coercion when a function is passed to another function, or when it is returned as a function result.
However it also implements a proposed change to the specification whereby function coercion is not used for operations such as "instance of".
These follow stricter type checking rules: a function <code>F(A,B)-&gt;T</code> is an instance of a type <code>F(X,Y)-&gt;U</code> if every T is
an instance of U, every X is an instance of A, and every Y is an instance of B.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="xsd92.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>