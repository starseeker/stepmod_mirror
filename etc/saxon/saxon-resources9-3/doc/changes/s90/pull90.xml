<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="changes" page="s90" subpage="pull90"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: Pull processing in Java</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: Pull processing in Java"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>Pull processing in Java</h1>
      <p>The internal mechanisms and API for pull processing have been substantially rewritten in this release.</p>
      <p>There is a new method <code>iterateEvents()</code> on the <code>Expression</code> class, which evaluates
the expression and returns its result as a sequence of <code>PullEvent</code> objects. A <code>PullEvent</code>
can be an <code>Item</code> (that is, a <code>NodeInfo</code> or <code>AtomicValue</code>). It can also
be a StartElement, EndElement, StartDocument, or EndDocument event. Within the content of a document or element,
the child nodes can be represented either as complete nodes (including element nodes, and potentially even document
nodes, in which case the document wrapper should be ignored) or as nested event sequences using further StartElement
and EndElement events.</p>
      <p>An <code>EventIterator</code> is also a <code>PullEvent</code>, so a stream of events can contain nested
streams. If you want to process the events without having to handle this nesting, you can flatten the sequence
by calling the static method <code>EventStackIterator.flatten()</code>.</p>
      <p>To serialize the results of a query, there is a static method <code>EventIteratorToReceiver.copy()</code> which
reads the events from a pull pipeline (an <code>EventIterator</code>), and pushes them to a push pipeline (a
<code>Receiver</code>). However, if you are serializing the results then it probably makes sense in most cases
to evaluate the query in push mode to start with.</p>
      <p>A sequence in which all the <code>PullEvents</code> are <code>Item</code> objects is called a <i>composed</i>
sequence. A sequence in which all document and element nodes are split into their constituent events is called
a <i>decomposed</i> sequence. You can turn any sequence of PullEvents into a fully composed sequence by wrapping it in
a <code>SequenceComposer</code>. This will physically construct any document or element nodes that were represented 
in the sequence in decomposed form. Similarly, you can turn any sequence into a fully decomposed sequence by wrapping it in
a <code>Decomposer</code>.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="serialization90.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>