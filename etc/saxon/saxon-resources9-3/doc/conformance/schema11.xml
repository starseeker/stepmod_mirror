<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="conformance" page="schema11" subpage=""/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: XML Schema 1.1</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: XML Schema 1.1"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>XML Schema 1.1</h1>
      <p>Saxon includes an almost complete implementation of the proposed specification of XML Schema 1.1.</p>
      <p>This support is generally provided only if explicitly requested by using the -xsdversion:1.1 option
on the command line, or equivalent options in the API.</p>
      <p>The rules for valid type derivation follow the XML Schema 1.1 specification, regardless of this
option setting. This is because the rules in the 1.0 specification do not meet the stated intent, namely that
type derivation is valid in all cases where the restricted type allows a subset of the instances permitted
by the base type.</p>
      <p>Some of the changes implemented for XSD 1.1 are as follows:</p>
      <ul>
         <li content="para">
            <p>The rules for valid restrictions of complex types have changed: the specification now defines these rules 
in a very similar way to the way that Saxon has always implemented.</p>
         </li>
         <li content="para">
            <p>Assertions are implemented, on both complex types and simple types. Saxon allows the full syntax of XPath 2.0
to be used in assertions. In the case of complex types, the context item is currently set to the element node
being validated as an <i>untyped</i> tree (according to the specification, all nodes except the root of the tree
should be typed). For simple types, and for complex types with simple content, the typed value of the node is available
as the value of the variable <code>$value</code>. This is currently typed as an instance of the base type (the type
being restricted by the assertion), not the nearest built-in type as specified by W3C.</p>
         </li>
         <li content="para">
            <p>Conditional Type Assignment (<code>xs:alternative</code>) is implemented. Again the full syntax of XPath 2.0 is allowed.
(Currently however the rules for type subsumption are not checked). The XPath condition used to select a type alternative can access attributes
on ancestor elements provided they are declared as <code>inheritable</code>.</p>
         </li>
         <li content="para">
            <p>Unrestricted <code>minOccurs</code> and <code>maxOccurs</code> values are allowed on the element particles 
within <code>xs:all</code> groups.</p>
         </li>
         <li content="para">
            <p>An <code>xs:all</code> content model may now be derived by extension from another <code>xs:all</code> content model.</p>
         </li>
         <li content="para">
            <p>An <code>xs:all</code> content model may use an <code>xs:group</code> element to refer to a named model group
containing another <code>xs:all</code> content model.</p>
         </li>
         <li content="para">
            <p>Element wildcards (<code>xs:any</code>) are allowed within <code>xs:all</code> groups.</p>
         </li>
         <li content="para">
            <p>The <code>notNamespace</code> and <code>notQName</code> attributes are now supported on <code>xs:any</code> and
 <code>xs:anyAttribute</code> wildcards, including (from Saxon 9.3) <code>notQName="##defined"</code> and 
 <code>notQName="##definedSibling"/&gt;</code>
         </p>
         </li>
         <li content="para">
            <p>The <code>targetNamespace</code> attribute is available for use on local element and attribute declarations
appearing within the restriction of a complex type.</p>
         </li>
         <li content="para">
            <p>Open content is implemented.</p>
         </li>
         <li content="para">
            <p>The <code>defaultAttributes</code> attribute of <code>xs:schema</code> is implemented</p>
         </li>
         <li content="para">
            <p>Saxon allows conditional inclusion of elements in a schema document, using attributes such as <code>vc:minVersion</code>
and <code>vc:maxVersion</code>. This feature is available whether the schema processor is run in 1.0 or 1.1 mode,
allowing new 1.1 features such as assertions to be ignored when running in 1.0 mode.</p>
         </li>
         <li content="para">
            <p>The type <code>xs:error</code> is implemented.</p>
         </li>
         <li content="para">
            <p>An element may now appear in more than one substitution group.</p>
         </li>
         <li content="para">
            <p>A new facet <code>xs:explicitTimezone</code> is available with values <code>required</code>, <code>optional</code>, or <code>prohibited</code>.</p>
         </li>
         <li content="para">
            <p>The new built-in data type <code>xs:dateTimeStamp</code> (an <code>xs:dateTime</code> with timezone required)
is implemented.</p>
         </li>
         <li content="para">
            <p>The new primitive type xs:precisionDecimal. Validation of this type is implemented, plus enough comparison and arithmetic
logic to support creating of facets in the schema; however the full semantics of xs:precisionDecimal in XPath and XQuery are not
currently defined.</p>
         </li>
         <li content="para">
            <p>The <code>xs:override</code> declaration is implemented. There are a couple of known restrictions: circular
<code>xs:override</code> chains are not allowed, and the interaction of <code>xs:override</code> with <code>xs:redefine</code>
is untested.</p>
         </li>
         <li content="para">
            <p>Multiple ID attributes are allowed on an element; ID and IDREF values appearing within a simple type constructed from ID
by list and union (as well as restriction) are recognized.</p>
         </li>
         <li content="para">
            <p>The <code>notQName=##definedSibling</code> option in element wildcards is available.</p>
         </li>
      </ul>
      <p class="subhead">Unimplemented Features</p>
      <p>The following facilities are not implemented. This list may be incomplete.</p>
      <ul>
         <li content="para">
            <p>The so-called "dynamic element declarations consistent" constraint: specifically, the rule that if a wildcard
matches an element or attribute with a global declaration, then the global declaration must have a type that is consistent
with any locally-declared elements or attributes having the same name.</p>
         </li>
         <li content="para">
            <p>Assertions: the data presented to an assertion on a complex type is currently untyped.</p>
         </li>
         <li content="para">
            <p>There are new rules indicating what should happen when the XPath expressions in an identity contraint select
nodes in a part of the document that is skipped.</p>
         </li>
      </ul>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="serialization.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>