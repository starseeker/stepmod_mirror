<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="extensibility" page="dotnetextensions" subpage="instance-methods.net"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: Calling .NET Instance-Level Methods</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: Calling .NET Instance-Level Methods"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>Calling .NET Instance-Level Methods</h1>
      <p><b>Instance-level methods</b> (that is, non-static methods)
 are called by supplying an extra first argument of type <code>external .NET object</code> which is the
object on which the method is to be invoked. An external .NET Object may be created by calling an extension
 function (e.g. a constructor) that returns an object; it may also be passed to the query or stylesheet as the
 value of a global parameter. Matching of method names is done as for static methods.
 If there are several methods in the class that match the localname, the system again tries to
 find the one that is the best fit, according to the types of the supplied arguments.</p>
      <p>For example, the following XSLT stylesheet prints the operating system name and version.</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xsl:stylesheet version="2.0" 
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				
&lt;xsl:template name="main"&gt;
  &lt;out xmlns:env="clitype:System.Environment" xmlns:os="clitype:System.OperatingSystem"&gt;
    &lt;xsl:variable name="os" select="env:OSVersion()"/&gt;
      &lt;v platform="{os:Platform($os)}" version="{os:Version($os)}"/&gt;
  &lt;/out&gt;  
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</code>
         </pre>
      </div>
      <p>The equivalent in XQuery is:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
declare namespace env="clitype:System.Environment";
declare namespace os="clitype:System.OperatingSystem";
let $os := env:OSVersion() return
&lt;v platform="{os:Platform($os)}" version="{os:Version($os)}"/&gt;
</code>
         </pre>
      </div>
      <p>As with static methods, an instance-level Java method called as an extension function may have an extra first argument of
 class <a class="bodylink" href="../../javadoc/net/sf/saxon/expr/XPathContext.html"><code>net.sf.saxon.expr.XPathContext</code></a>.
This argument is not
supplied by the calling XPath or XQuery code, but by Saxon itself. 
The <code>XPathContext</code> object provides methods to access many
internal Saxon resources, the most useful being <code>getContextItem()</code> which returns the context item
from the dynamic context.</p>
      <p>If any exceptions are thrown by the method, or if a matching method cannot be found,
processing of the stylesheet will be abandoned. If the tracing option has been set (-TJ) on the
command line, a full stack trace will be output. The exception will be wrapped in a
<code>TransformerException</code> and passed to any user-specified <code>ErrorListener</code> object, 
so the <code>ErrorListener</code> can also produce extra diagnostics.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="../converting-args.net.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>