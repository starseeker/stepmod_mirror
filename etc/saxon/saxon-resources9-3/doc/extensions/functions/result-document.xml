<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="extensions" page="functions" subpage="result-document"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: saxon:result-document()</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: saxon:result-document()"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>saxon:result-document()</h1>
      <p><i>This function is available only in Saxon-EE</i></p>
      <p><b>saxon:result-document($href as xs:string, $content as item()*, $format as element(xsl:output))</b></p>
      <p>This function takes three arguments:</p>
      <ol>
         <li content="para">
            <p>$href is a URI identifying the destination of the serialized result document. Generally speaking,
the <code>file:/</code> URI scheme works and other schemes usually don't. If the URI is relative, it is
interpreted relative to the <i>base output URI</i> which is the destination of the principal output of
the query, and which defaults to the current directory (not the stylesheet directory). When the -t option
is used on the command line, the actual destination of output files is reported as a message on System.err.</p>
         </li>
         <li content="para">
            <p>$content is a sequence of items which makes up the content of the new document, it is processed
in the same way as the content sequence passed to the <code>document{}</code> constructor in XQuery, or
the <code>xsl:document</code> instruction in XSLT.</p>
         </li>
         <li content="para">
            <p>$format is used to define serialization properties; its value is an <code>xsl:output</code> element
conforming to the rules defined in the XSLT specification. This element may be constructed
dynamically, and may therefore be used to decide all the serialization properties dynamically.</p>
         </li>
      </ol>
      <p>For example, the function may be used as follows in XQuery. This example has the effect
of writing each <code>&lt;country&gt;</code> element to a separate file:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
declare namespace saxon="http://saxon.sf.net/";
declare namespace xsl="http://www.w3.org/1999/XSL/Transform";
let $input :=
  &lt;data&gt;
    &lt;country name="Austria"&gt;Vienna&lt;/country&gt;
    &lt;country name="France"&gt;Paris&lt;/country&gt;
    &lt;country name="Germany"&gt;Berlin&lt;/country&gt;
  &lt;/data&gt;
return
&lt;log&gt; {
  for $c in $input/country return
    let $href := concat($c/@name, '.xml')
    return (
      saxon:result-document($href, $c, 
          &lt;xsl:output method="xml" indent="yes"/&gt;),
      &lt;done href="{$href}"/&gt;
    )
} &lt;/log&gt;    
}&lt;/out&gt;
</code>
         </pre>
      </div>
      <p>The function returns no result (technically, it returns an empty sequence). 
Because it is called only for its side-effects, some care is needed in how
it is used. Generally, the safe approach is to call it in a position where, if it did produce output, the output
would form part of the result of the query. It is implemented internally using the <code>xsl:result-document</code>
instruction from XSLT, and must follow the same constraints. For example, an error will be reported if it is
 called while evaluating a variable or a function, or if you try to write and read the same document within
 a single query.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="serialize.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>