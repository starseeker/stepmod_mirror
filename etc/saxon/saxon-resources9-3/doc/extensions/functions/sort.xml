<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="extensions" page="functions" subpage="sort"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: saxon:sort()</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: saxon:sort()"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>saxon:sort()</h1>
      <p>The <code>saxon:sort</code> function is provided primarily for use in XPath, which has no built-in sorting
capability. In XSLT it is preferable to use <code>xsl:sort</code>, in XQuery to use a FLWOR expression with an
<code>order by</code> clause.</p>
      <p><b>saxon:sort($seq as item()*) =&gt; item()*</b></p>
      <p>This form of the function sorts a sequence of nodes and/or atomic values. For atomic values, the value itself
is used as the sort key. For nodes, the atomized value is used as the sort key. The atomized value must be a single
atomic value. The values must all be comparable. Strings are sorted using codepoint collation.</p>
      <p><b>saxon:sort($seq as item()*, $stored-expression as jt:net.sf.saxon.functions.Evaluate-PreparedExpression) =&gt; node()?</b></p>
      <p>This form of the function sorts a sequence of nodes and/or atomic values, using the supplied stored
expression to compute the sort key for each item in the sequence. The computed sort key must either be a single
atomic value, or a node that atomizes to a single atomic value, and the sort keys must all be comparable.
Strings are sorted using codepoint collation.</p>
      <p> A stored expression may be obtained as the result of calling
the <a class="bodylink" href="../../extensions/functions/expression.xml">saxon:expression</a> function.</p>
      <p>The stored expression is evaluated for each item in $seq in turn, with that item as the context
node, with the context position equal to the position of that item in $seq, and with the context size
equal to the size of $seq. </p>
      <p>Example: saxon:sort(sale, saxon:expression('@price * @qty')) will evaluate price times
 quantity for each child &lt;sale&gt; element, and return the <code>sale</code> elements in ascending
 numeric order of this value.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="stringtobase64binary.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>