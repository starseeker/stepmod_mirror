<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="extensions" page="functions" subpage="transform"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: saxon:transform()</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: saxon:transform()"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>saxon:transform()</h1>
      <p><b>saxon:transform($stylesheet as jt:javax.xml.transform.Templates, $source as node()) ==&gt; document-node()</b></p>
      <p><b>saxon:transform($stylesheet as jt:javax.xml.transform.Templates, $source as node(), $params as node()*) ==&gt; document-node()</b></p>
      <p>This function takes as input a compiled XSLT stylesheet, and uses it to transform a source document
into a result document. The first argument will generally be the result of calling the 
<a class="bodylink" href="../../extensions/functions/compile-stylesheet.xml">saxon:compile-stylesheet()</a> extension function. The second argument
can be any node (usually a document node or element node), either read from external filestore using the
<code>doc()</code> or <code>document()</code> function, or constructed programmatically.</p>
      <p>The function is available both in XQuery and in XSLT. It can thus be used for example in XQuery to pre-process
the input using a stylesheet, or to post-process the output using a stylesheet. It can also be used to chain multiple
XSLT transformations together.</p>
      <p>The compiled stylesheet can be used repeatedly to transform multiple source documents.</p>
      <p>If the optional third argument is present, it is used to supply parameters to the transformation. The
value is a sequence of nodes. Each node must be an element node, attribute node, or document node; supplying a document
node is equivalent to supplying all its element children. The name of the node must match the parameter name
declared in an <code>xsl:param</code> element in the stylesheet, and the atomized value of the node is used
as the value of the parameter. If this is <code>untypedAtomic</code> then it is converted to the required type declared
in the stylesheet.</p>
      <p>The stylesheet may contain calls on <code>xsl:result-document</code>. This allows the output of the stylesheet
to be serialized directly to filestore rather than being returned to the calling transformation or query.</p>
      <p>Here is an example of how to use the function from XQuery:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
let $results :=
  &lt;customers&gt;{ //customer[location="Scotland"] }&lt;/customers&gt;
let $rendition := saxon:compile-stylesheet(doc('show-customers.xsl'))
return saxon:transform($rendition, $results)
</code>
         </pre>
      </div>
      <p>The following example uses XSLT's ability to create multiple output files:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
let $splitter := saxon:compile-stylesheet(
  &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                       version="2.0"&gt;
    &lt;xsl:template match="customer"&gt;
      &lt;xsl:result-document href="{{@id}}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;)
let $results :=
  document {
     &lt;customers&gt;{ //customer[location="Scotland"] }&lt;/customers&gt;
  }
return saxon:transform($splitter, $results)
</code>
         </pre>
      </div>
      <p>Note (a) the need to double the curly braces to ensure that the contained expression is expanded when
the stylesheet is executed by XSLT, not when it is created by XQuery, and (b) the fact that the stylesheet and
source document are supplied as document nodes, not element nodes.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="try.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>