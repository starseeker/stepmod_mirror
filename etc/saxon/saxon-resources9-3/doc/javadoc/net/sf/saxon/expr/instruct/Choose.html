<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_18) on Fri Oct 29 18:21:26 BST 2010 -->
<TITLE>
Choose
</TITLE>

<META NAME="date" CONTENT="2010-10-29">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Choose";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../net/sf/saxon/expr/instruct/CallTemplate.CallTemplatePackage.html" title="class in net.sf.saxon.expr.instruct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../net/sf/saxon/expr/instruct/Comment.html" title="class in net.sf.saxon.expr.instruct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/sf/saxon/expr/instruct/Choose.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Choose.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.sf.saxon.expr.Expression">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.sf.saxon.expr.instruct</FONT>
<BR>
Class Choose</H2>
<PRE>
<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">net.sf.saxon.expr.Expression</A>
      <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">net.sf.saxon.expr.instruct.Instruction</A>
          <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>net.sf.saxon.expr.instruct.Choose</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="http://download.oracle.com/javase/6/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io">Serializable</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true" title="class or interface in javax.xml.transform">SourceLocator</A>, <A HREF="../../../../../net/sf/saxon/event/LocationProvider.html" title="interface in net.sf.saxon.event">LocationProvider</A>, <A HREF="../../../../../net/sf/saxon/event/SaxonLocator.html" title="interface in net.sf.saxon.event">SaxonLocator</A>, <A HREF="../../../../../net/sf/saxon/expr/EvaluableItem.html" title="interface in net.sf.saxon.expr">EvaluableItem</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/TailCallReturner.html" title="interface in net.sf.saxon.expr.instruct">TailCallReturner</A>, <A HREF="../../../../../net/sf/saxon/expr/SequenceIterable.html" title="interface in net.sf.saxon.expr">SequenceIterable</A>, <A HREF="../../../../../net/sf/saxon/trace/InstructionInfo.html" title="interface in net.sf.saxon.trace">InstructionInfo</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/org/xml/sax/Locator.html?is-external=true" title="class or interface in org.xml.sax">Locator</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Choose</B><DT>extends <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></DL>
</PRE>

<P>
Compiled representation of an xsl:choose or xsl:if element in the stylesheet.
 Also used for typeswitch in XQuery.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../serialized-form.html#net.sf.saxon.expr.instruct.Choose">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.sf.saxon.expr.Expression"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class net.sf.saxon.expr.<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#EVALUATE_METHOD">EVALUATE_METHOD</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#EVENT_FEED_METHOD">EVENT_FEED_METHOD</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#ITEM_FEED_METHOD">ITEM_FEED_METHOD</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#ITERATE_METHOD">ITERATE_METHOD</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#locationId">locationId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#PROCESS_METHOD">PROCESS_METHOD</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#PUSH_SELECTION">PUSH_SELECTION</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#staticProperties">staticProperties</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#WATCH_METHOD">WATCH_METHOD</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#Choose(net.sf.saxon.expr.Expression[], net.sf.saxon.expr.Expression[])">Choose</A></B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]&nbsp;conditions,
       <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]&nbsp;actions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an xsl:choose instruction</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/PathMap.PathMapNodeSet.html" title="class in net.sf.saxon.expr">PathMap.PathMapNodeSet</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#addToPathMap(net.sf.saxon.expr.PathMap, net.sf.saxon.expr.PathMap.PathMapNodeSet)">addToPathMap</A></B>(<A HREF="../../../../../net/sf/saxon/expr/PathMap.html" title="class in net.sf.saxon.expr">PathMap</A>&nbsp;pathMap,
             <A HREF="../../../../../net/sf/saxon/expr/PathMap.PathMapNodeSet.html" title="class in net.sf.saxon.expr">PathMap.PathMapNodeSet</A>&nbsp;pathMapNodeSet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a representation of this expression to a PathMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#checkForUpdatingSubexpressions()">checkForUpdatingSubexpressions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check to ensure that this expression does not contain any updating subexpressions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#checkPermittedContents(net.sf.saxon.type.SchemaType, net.sf.saxon.expr.StaticContext, boolean)">checkPermittedContents</A></B>(<A HREF="../../../../../net/sf/saxon/type/SchemaType.html" title="interface in net.sf.saxon.type">SchemaType</A>&nbsp;parentType,
                       <A HREF="../../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env,
                       boolean&nbsp;whole)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check that any elements and attributes constructed or returned by this expression are acceptable
 in the content model of a given complex type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#computeCardinality()">computeCardinality</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the cardinality of the sequence returned by evaluating this instruction</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#computeSpecialProperties()">computeSpecialProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the static properties of this expression (other than its type).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#copy()">copy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#createsNewNodes()">createsNewNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether this instruction creates new nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/om/Item.html" title="interface in net.sf.saxon.om">Item</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#evaluateItem(net.sf.saxon.expr.XPathContext)">evaluateItem</A></B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluate an expression as a single item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#evaluatePendingUpdates(net.sf.saxon.expr.XPathContext, net.sf.saxon.expr.PendingUpdateList)">evaluatePendingUpdates</A></B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context,
                       <A HREF="../../../../../net/sf/saxon/expr/PendingUpdateList.html" title="interface in net.sf.saxon.expr">PendingUpdateList</A>&nbsp;pul)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluate an updating expression, adding the results to a Pending Update List.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#explain(net.sf.saxon.trace.ExpressionPresenter)">explain</A></B>(<A HREF="../../../../../net/sf/saxon/trace/ExpressionPresenter.html" title="class in net.sf.saxon.trace">ExpressionPresenter</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Diagnostic print of expression structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#getActions()">getActions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the array of actions to be performed</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#getConditions()">getConditions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the array of conditions to be tested</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#getImplementationMethod()">getImplementationMethod</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An implementation of Expression must provide at least one of the methods evaluateItem(), iterate(), or process().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#getInstructionNameCode()">getInstructionNameCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the name of this instruction for diagnostic and tracing purposes
 We assume that if there was
 only one condition then it was an xsl:if; this is not necessarily so, but
 it's adequate for tracing purposes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#getItemType(net.sf.saxon.type.TypeHierarchy)">getItemType</A></B>(<A HREF="../../../../../net/sf/saxon/type/TypeHierarchy.html" title="class in net.sf.saxon.type">TypeHierarchy</A>&nbsp;th)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the item type of the items returned by evaluating this instruction</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#implementsStaticTypeCheck()">implementsStaticTypeCheck</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether this expression implements its own method for static type checking</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#isSingleBranchChoice(net.sf.saxon.expr.Expression)">isSingleBranchChoice</A></B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test whether an expression is a single-branch choose, that is, an expression of the form
 if (condition) then exp else ()</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#isUpdatingExpression()">isUpdatingExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether this is an updating expression as defined in the XQuery update specification</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#isVacuousExpression()">isVacuousExpression</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine whether this is a vacuous expression as defined in the XQuery update specification</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/om/SequenceIterator.html" title="interface in net.sf.saxon.om">SequenceIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#iterate(net.sf.saxon.expr.XPathContext)">iterate</A></B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an Iterator to iterate over the values of a sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/evpull/EventIterator.html" title="interface in net.sf.saxon.evpull">EventIterator</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#iterateEvents(net.sf.saxon.expr.XPathContext)">iterateEvents</A></B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deliver the result of the expression as a sequence of events.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html?is-external=true" title="class or interface in java.util">Iterator</A>&lt;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#iterateSubExpressions()">iterateSubExpressions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get all the XPath expressions associated with this instruction
 (in XSLT terms, the expression present on attributes of the instruction,
 as distinct from the child instructions in a sequence construction)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#makeConditional(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)">makeConditional</A></B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;condition,
                <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;thenExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a simple conditional expression (if (condition) then (thenExp) else ()</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#makeConditional(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)">makeConditional</A></B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;condition,
                <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;thenExp,
                <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;elseExp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a simple conditional expression (if (condition) then (thenExp) else (elseExp)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#markTailFunctionCalls(net.sf.saxon.om.StructuredQName, int)">markTailFunctionCalls</A></B>(<A HREF="../../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A>&nbsp;qName,
                      int&nbsp;arity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mark tail-recursive calls on functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#optimize(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">optimize</A></B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor,
         <A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A>&nbsp;contextItemType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform optimisation of an expression and its subexpressions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/instruct/TailCall.html" title="interface in net.sf.saxon.expr.instruct">TailCall</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#processLeavingTail(net.sf.saxon.expr.XPathContext)">processLeavingTail</A></B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Process this instruction, that is, choose an xsl:when or xsl:otherwise child
 and process it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#promoteInst(net.sf.saxon.expr.PromotionOffer)">promoteInst</A></B>(<A HREF="../../../../../net/sf/saxon/expr/PromotionOffer.html" title="class in net.sf.saxon.expr">PromotionOffer</A>&nbsp;offer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle promotion offers, that is, non-local tree rewrites.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#replaceSubExpression(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)">replaceSubExpression</A></B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;original,
                     <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;replacement)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace one subexpression by a replacement subexpression</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#simplify(net.sf.saxon.expr.ExpressionVisitor)">simplify</A></B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplify an expression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#staticTypeCheck(net.sf.saxon.value.SequenceType, boolean, net.sf.saxon.expr.RoleLocator, net.sf.saxon.TypeCheckerEnvironment)">staticTypeCheck</A></B>(<A HREF="../../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A>&nbsp;req,
                boolean&nbsp;backwardsCompatible,
                <A HREF="../../../../../net/sf/saxon/expr/RoleLocator.html" title="class in net.sf.saxon.expr">RoleLocator</A>&nbsp;role,
                <A HREF="../../../../../net/sf/saxon/TypeCheckerEnvironment.html" title="interface in net.sf.saxon">TypeCheckerEnvironment</A>&nbsp;visitor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static type checking for conditional expressions is delegated to the expression itself,
 and is performed separately on each branch of the conditional, so that dynamic checks are
 added only on those branches where the check is actually required.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The toString() method for an expression attempts to give a representation of the expression
 in an XPath-like form, but there is no guarantee that the syntax will actually be true XPath.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/sf/saxon/expr/instruct/Choose.html#typeCheck(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">typeCheck</A></B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor,
          <A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A>&nbsp;contextItemType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform type checking of an expression and its subexpressions.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.sf.saxon.expr.instruct.Instruction"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class net.sf.saxon.expr.instruct.<A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#assembleParams(net.sf.saxon.expr.XPathContext, net.sf.saxon.expr.instruct.WithParam[])">assembleParams</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#assembleTunnelParams(net.sf.saxon.expr.XPathContext, net.sf.saxon.expr.instruct.WithParam[])">assembleTunnelParams</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#dynamicError(javax.xml.transform.SourceLocator, net.sf.saxon.trans.XPathException, net.sf.saxon.expr.XPathContext)">dynamicError</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#evaluateAsString(net.sf.saxon.expr.XPathContext)">evaluateAsString</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getConstructType()">getConstructType</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getExpressionName()">getExpressionName</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getInstructionName()">getInstructionName</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getIteratorFromProcessMethod(net.sf.saxon.expr.XPathContext)">getIteratorFromProcessMethod</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getSourceLocator()">getSourceLocator</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#isXSLT()">isXSLT</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#process(net.sf.saxon.expr.XPathContext)">process</A>, <A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#promote(net.sf.saxon.expr.PromotionOffer, net.sf.saxon.expr.Expression)">promote</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_net.sf.saxon.expr.Expression"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class net.sf.saxon.expr.<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#adoptChildExpression(net.sf.saxon.expr.Expression)">adoptChildExpression</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#computeDependencies()">computeDependencies</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#computeStaticProperties()">computeStaticProperties</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#doPromotion(net.sf.saxon.expr.Expression, net.sf.saxon.expr.PromotionOffer)">doPromotion</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#dynamicError(java.lang.String, java.lang.String, net.sf.saxon.expr.XPathContext)">dynamicError</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#effectiveBooleanValue(net.sf.saxon.expr.XPathContext)">effectiveBooleanValue</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#explain(java.io.OutputStream)">explain</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getCardinality()">getCardinality</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getColumnNumber()">getColumnNumber</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getColumnNumber(long)">getColumnNumber</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getContainer()">getContainer</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getDependencies()">getDependencies</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getEvaluationMethod()">getEvaluationMethod</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getExecutable()">getExecutable</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getHostLanguage()">getHostLanguage</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getIntrinsicDependencies()">getIntrinsicDependencies</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getLineNumber()">getLineNumber</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getLineNumber(long)">getLineNumber</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getLocationId()">getLocationId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getLocationProvider()">getLocationProvider</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getObjectName()">getObjectName</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getProperties()">getProperties</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getProperty(java.lang.String)">getProperty</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getPublicId()">getPublicId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getSlotsUsed()">getSlotsUsed</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getSpecialProperties()">getSpecialProperties</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getSystemId()">getSystemId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#getSystemId(long)">getSystemId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#hasLoopingSubexpression(net.sf.saxon.expr.Expression)">hasLoopingSubexpression</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#isSubtreeExpression()">isSubtreeExpression</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#iterateSameFocusSubExpressions()">iterateSameFocusSubExpressions</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#resetLocalStaticProperties()">resetLocalStaticProperties</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#setContainer(net.sf.saxon.expr.Container)">setContainer</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#setEvaluationMethod(int)">setEvaluationMethod</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#setFiltered(boolean)">setFiltered</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#setFlattened(boolean)">setFlattened</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#setLocationId(int)">setLocationId</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#suppressValidation(int)">suppressValidation</A>, <A HREF="../../../../../net/sf/saxon/expr/Expression.html#typeError(java.lang.String, java.lang.String, net.sf.saxon.expr.XPathContext)">typeError</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.xml.transform.SourceLocator"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface javax.xml.transform.<A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true" title="class or interface in javax.xml.transform">SourceLocator</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true#getColumnNumber()" title="class or interface in javax.xml.transform">getColumnNumber</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true#getLineNumber()" title="class or interface in javax.xml.transform">getLineNumber</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true#getPublicId()" title="class or interface in javax.xml.transform">getPublicId</A>, <A HREF="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/SourceLocator.html?is-external=true#getSystemId()" title="class or interface in javax.xml.transform">getSystemId</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Choose(net.sf.saxon.expr.Expression[], net.sf.saxon.expr.Expression[])"><!-- --></A><H3>
Choose</H3>
<PRE>
public <B>Choose</B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]&nbsp;conditions,
              <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[]&nbsp;actions)</PRE>
<DL>
<DD>Construct an xsl:choose instruction
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>conditions</CODE> - the conditions to be tested, in order<DD><CODE>actions</CODE> - the actions to be taken when the corresponding condition is true</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="makeConditional(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)"><!-- --></A><H3>
makeConditional</H3>
<PRE>
public static <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>makeConditional</B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;condition,
                                         <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;thenExp,
                                         <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;elseExp)</PRE>
<DL>
<DD>Make a simple conditional expression (if (condition) then (thenExp) else (elseExp)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>condition</CODE> - the condition to be tested<DD><CODE>thenExp</CODE> - the expression to be evaluated if the condition is true<DD><CODE>elseExp</CODE> - the expression to be evaluated if the condition is false
<DT><B>Returns:</B><DD>the expression</DL>
</DD>
</DL>
<HR>

<A NAME="makeConditional(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)"><!-- --></A><H3>
makeConditional</H3>
<PRE>
public static <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>makeConditional</B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;condition,
                                         <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;thenExp)</PRE>
<DL>
<DD>Make a simple conditional expression (if (condition) then (thenExp) else ()
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>condition</CODE> - the condition to be tested<DD><CODE>thenExp</CODE> - the expression to be evaluated if the condition is true
<DT><B>Returns:</B><DD>the expression</DL>
</DD>
</DL>
<HR>

<A NAME="isSingleBranchChoice(net.sf.saxon.expr.Expression)"><!-- --></A><H3>
isSingleBranchChoice</H3>
<PRE>
public static boolean <B>isSingleBranchChoice</B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;exp)</PRE>
<DL>
<DD>Test whether an expression is a single-branch choose, that is, an expression of the form
 if (condition) then exp else ()
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>exp</CODE> - the expression to be tested
<DT><B>Returns:</B><DD>true if the expression is a choose expression and there is only one condition,
 so that the expression returns () if this condition is false</DL>
</DD>
</DL>
<HR>

<A NAME="getConditions()"><!-- --></A><H3>
getConditions</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[] <B>getConditions</B>()</PRE>
<DL>
<DD>Get the array of conditions to be tested
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the array of condition expressions</DL>
</DD>
</DL>
<HR>

<A NAME="getActions()"><!-- --></A><H3>
getActions</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>[] <B>getActions</B>()</PRE>
<DL>
<DD>Get the array of actions to be performed
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the array of expressions to be evaluated when the corresponding condition is true</DL>
</DD>
</DL>
<HR>

<A NAME="getInstructionNameCode()"><!-- --></A><H3>
getInstructionNameCode</H3>
<PRE>
public int <B>getInstructionNameCode</B>()</PRE>
<DL>
<DD>Get the name of this instruction for diagnostic and tracing purposes
 We assume that if there was
 only one condition then it was an xsl:if; this is not necessarily so, but
 it's adequate for tracing purposes.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getInstructionNameCode()">getInstructionNameCode</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a code identifying the instruction: typically but not always
 the fingerprint of a name in the XSLT namespace</DL>
</DD>
</DL>
<HR>

<A NAME="simplify(net.sf.saxon.expr.ExpressionVisitor)"><!-- --></A><H3>
simplify</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>simplify</B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor)
                    throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Simplify an expression. This performs any static optimization (by rewriting the expression
 as a different expression).
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#simplify(net.sf.saxon.expr.ExpressionVisitor)">simplify</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visitor</CODE> - expression visitor object
<DT><B>Returns:</B><DD>the simplified expression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if an error is discovered during expression
     rewriting</DL>
</DD>
</DL>
<HR>

<A NAME="typeCheck(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)"><!-- --></A><H3>
typeCheck</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>typeCheck</B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor,
                            <A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A>&nbsp;contextItemType)
                     throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#typeCheck(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">Expression</A></CODE></B></DD>
<DD>Perform type checking of an expression and its subexpressions. This is the second phase of
 static optimization.

 <p>This checks statically that the operands of the expression have
 the correct type; if necessary it generates code to do run-time type checking or type
 conversion. A static type error is reported only if execution cannot possibly succeed, that
 is, if a run-time type error is inevitable. The call may return a modified form of the expression.</p>

 <p>This method is called after all references to functions and variables have been resolved
 to the declaration of the function or variable. However, the types of such functions and
 variables may not be accurately known if they have not been explicitly declared.</p>

 <p>If the implementation returns a value other than "this", then it is required to ensure that
 the location information in the returned expression have been set up correctly.
 It should not rely on the caller to do this, although for historical reasons many callers do so.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#typeCheck(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">typeCheck</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visitor</CODE> - an expression visitor<DD><CODE>contextItemType</CODE> - the static type of "." at the point where this expression is invoked.
 The parameter is set to null if it is known statically that the context item will be undefined.
 If the type of the context item is not known statically, the argument is set to
 <A HREF="../../../../../net/sf/saxon/type/Type.html#ITEM_TYPE"><CODE>Type.ITEM_TYPE</CODE></A>
<DT><B>Returns:</B><DD>the original expression, rewritten to perform necessary run-time type checks,
 and to perform other type-related optimizations
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if an error is discovered during this phase
     (typically a type error)</DL>
</DD>
</DL>
<HR>

<A NAME="implementsStaticTypeCheck()"><!-- --></A><H3>
implementsStaticTypeCheck</H3>
<PRE>
public boolean <B>implementsStaticTypeCheck</B>()</PRE>
<DL>
<DD>Determine whether this expression implements its own method for static type checking
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#implementsStaticTypeCheck()">implementsStaticTypeCheck</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true - this expression has a non-trivial implementation of the staticTypeCheck()
         method</DL>
</DD>
</DL>
<HR>

<A NAME="staticTypeCheck(net.sf.saxon.value.SequenceType, boolean, net.sf.saxon.expr.RoleLocator, net.sf.saxon.TypeCheckerEnvironment)"><!-- --></A><H3>
staticTypeCheck</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>staticTypeCheck</B>(<A HREF="../../../../../net/sf/saxon/value/SequenceType.html" title="class in net.sf.saxon.value">SequenceType</A>&nbsp;req,
                                  boolean&nbsp;backwardsCompatible,
                                  <A HREF="../../../../../net/sf/saxon/expr/RoleLocator.html" title="class in net.sf.saxon.expr">RoleLocator</A>&nbsp;role,
                                  <A HREF="../../../../../net/sf/saxon/TypeCheckerEnvironment.html" title="interface in net.sf.saxon">TypeCheckerEnvironment</A>&nbsp;visitor)
                           throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Static type checking for conditional expressions is delegated to the expression itself,
 and is performed separately on each branch of the conditional, so that dynamic checks are
 added only on those branches where the check is actually required. This also results in a static
 type error if any branch is incapable of delivering a value of the required type. One reason
 for this approach is to avoid doing dynamic type checking on a recursive function call as this
 prevents tail-call optimization being used.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#staticTypeCheck(net.sf.saxon.value.SequenceType, boolean, net.sf.saxon.expr.RoleLocator, net.sf.saxon.TypeCheckerEnvironment)">staticTypeCheck</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>req</CODE> - the required type<DD><CODE>backwardsCompatible</CODE> - true if backwards compatibility mode applies<DD><CODE>role</CODE> - the role of the expression in relation to the required type<DD><CODE>visitor</CODE> - an expression visitor
<DT><B>Returns:</B><DD>the expression after type checking (perhaps augmented with dynamic type checking code)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if failures occur, for example if the static type of one branch of the conditional
 is incompatible with the required type</DL>
</DD>
</DL>
<HR>

<A NAME="optimize(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)"><!-- --></A><H3>
optimize</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>optimize</B>(<A HREF="../../../../../net/sf/saxon/expr/ExpressionVisitor.html" title="class in net.sf.saxon.expr">ExpressionVisitor</A>&nbsp;visitor,
                           <A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A>&nbsp;contextItemType)
                    throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD><B>Description copied from class: <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#optimize(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">Expression</A></CODE></B></DD>
<DD>Perform optimisation of an expression and its subexpressions. This is the third and final
 phase of static optimization.

 <p>This method is called after all references to functions and variables have been resolved
 to the declaration of the function or variable, and after all type checking has been done.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#optimize(net.sf.saxon.expr.ExpressionVisitor, net.sf.saxon.type.ItemType)">optimize</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visitor</CODE> - an expression visitor<DD><CODE>contextItemType</CODE> - the static type of "." at the point where this expression is invoked.
 The parameter is set to null if it is known statically that the context item will be undefined.
 If the type of the context item is not known statically, the argument is set to
 <A HREF="../../../../../net/sf/saxon/type/Type.html#ITEM_TYPE"><CODE>Type.ITEM_TYPE</CODE></A>
<DT><B>Returns:</B><DD>the original expression, rewritten if appropriate to optimize execution
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if an error is discovered during this phase
     (typically a type error)</DL>
</DD>
</DL>
<HR>

<A NAME="copy()"><!-- --></A><H3>
copy</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A> <B>copy</B>()</PRE>
<DL>
<DD>Copy an expression. This makes a deep copy.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#copy()">copy</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the copy of the original expression</DL>
</DD>
</DL>
<HR>

<A NAME="checkForUpdatingSubexpressions()"><!-- --></A><H3>
checkForUpdatingSubexpressions</H3>
<PRE>
public void <B>checkForUpdatingSubexpressions</B>()
                                    throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Check to ensure that this expression does not contain any updating subexpressions.
 This check is overridden for those expressions that permit updating subexpressions.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#checkForUpdatingSubexpressions()">checkForUpdatingSubexpressions</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the expression has a non-permitted updateing subexpression</DL>
</DD>
</DL>
<HR>

<A NAME="isUpdatingExpression()"><!-- --></A><H3>
isUpdatingExpression</H3>
<PRE>
public boolean <B>isUpdatingExpression</B>()</PRE>
<DL>
<DD>Determine whether this is an updating expression as defined in the XQuery update specification
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#isUpdatingExpression()">isUpdatingExpression</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this is an updating expression</DL>
</DD>
</DL>
<HR>

<A NAME="isVacuousExpression()"><!-- --></A><H3>
isVacuousExpression</H3>
<PRE>
public boolean <B>isVacuousExpression</B>()</PRE>
<DL>
<DD>Determine whether this is a vacuous expression as defined in the XQuery update specification
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#isVacuousExpression()">isVacuousExpression</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if this expression is vacuous</DL>
</DD>
</DL>
<HR>

<A NAME="getImplementationMethod()"><!-- --></A><H3>
getImplementationMethod</H3>
<PRE>
public int <B>getImplementationMethod</B>()</PRE>
<DL>
<DD>An implementation of Expression must provide at least one of the methods evaluateItem(), iterate(), or process().
 This method indicates which of these methods is prefered. For instructions this is the process() method.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getImplementationMethod()">getImplementationMethod</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the implementation method, for example <A HREF="../../../../../net/sf/saxon/expr/Expression.html#ITERATE_METHOD"><CODE>Expression.ITERATE_METHOD</CODE></A> or <A HREF="../../../../../net/sf/saxon/expr/Expression.html#EVALUATE_METHOD"><CODE>Expression.EVALUATE_METHOD</CODE></A> or
 <A HREF="../../../../../net/sf/saxon/expr/Expression.html#PROCESS_METHOD"><CODE>Expression.PROCESS_METHOD</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="markTailFunctionCalls(net.sf.saxon.om.StructuredQName, int)"><!-- --></A><H3>
markTailFunctionCalls</H3>
<PRE>
public int <B>markTailFunctionCalls</B>(<A HREF="../../../../../net/sf/saxon/om/StructuredQName.html" title="class in net.sf.saxon.om">StructuredQName</A>&nbsp;qName,
                                 int&nbsp;arity)</PRE>
<DL>
<DD>Mark tail-recursive calls on functions. For most expressions, this does nothing.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#markTailFunctionCalls(net.sf.saxon.om.StructuredQName, int)">markTailFunctionCalls</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>qName</CODE> - the name of the function<DD><CODE>arity</CODE> - the arity (number of parameters) of the function
<DT><B>Returns:</B><DD>0 if no tail call was found; 1 if a tail call on a different function was found;
 2 if a tail recursive call was found and if this call accounts for the whole of the value.</DL>
</DD>
</DL>
<HR>

<A NAME="getItemType(net.sf.saxon.type.TypeHierarchy)"><!-- --></A><H3>
getItemType</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/type/ItemType.html" title="interface in net.sf.saxon.type">ItemType</A> <B>getItemType</B>(<A HREF="../../../../../net/sf/saxon/type/TypeHierarchy.html" title="class in net.sf.saxon.type">TypeHierarchy</A>&nbsp;th)</PRE>
<DL>
<DD>Get the item type of the items returned by evaluating this instruction
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#getItemType(net.sf.saxon.type.TypeHierarchy)">getItemType</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>th</CODE> - Type hierarchy cache
<DT><B>Returns:</B><DD>the static item type of the instruction</DL>
</DD>
</DL>
<HR>

<A NAME="computeCardinality()"><!-- --></A><H3>
computeCardinality</H3>
<PRE>
public int <B>computeCardinality</B>()</PRE>
<DL>
<DD>Compute the cardinality of the sequence returned by evaluating this instruction
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#computeCardinality()">computeCardinality</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the static cardinality</DL>
</DD>
</DL>
<HR>

<A NAME="computeSpecialProperties()"><!-- --></A><H3>
computeSpecialProperties</H3>
<PRE>
public int <B>computeSpecialProperties</B>()</PRE>
<DL>
<DD>Get the static properties of this expression (other than its type). The result is
 bit-signficant. These properties are used for optimizations. In general, if
 property bit is set, it is true, but if it is unset, the value is unknown.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#computeSpecialProperties()">computeSpecialProperties</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a set of flags indicating static properties of this expression</DL>
</DD>
</DL>
<HR>

<A NAME="createsNewNodes()"><!-- --></A><H3>
createsNewNodes</H3>
<PRE>
public final boolean <B>createsNewNodes</B>()</PRE>
<DL>
<DD>Determine whether this instruction creates new nodes.
 This implementation returns true if any of the "actions" creates new nodes.
 (Nodes created by the conditions can't contribute to the result).
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#createsNewNodes()">createsNewNodes</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the instruction creates new nodes (or if it can't be proved that it doesn't)</DL>
</DD>
</DL>
<HR>

<A NAME="iterateSubExpressions()"><!-- --></A><H3>
iterateSubExpressions</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html?is-external=true" title="class or interface in java.util">Iterator</A>&lt;<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&gt; <B>iterateSubExpressions</B>()</PRE>
<DL>
<DD>Get all the XPath expressions associated with this instruction
 (in XSLT terms, the expression present on attributes of the instruction,
 as distinct from the child instructions in a sequence construction)
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#iterateSubExpressions()">iterateSubExpressions</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an iterator containing the sub-expressions of this expression</DL>
</DD>
</DL>
<HR>

<A NAME="replaceSubExpression(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)"><!-- --></A><H3>
replaceSubExpression</H3>
<PRE>
public boolean <B>replaceSubExpression</B>(<A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;original,
                                    <A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A>&nbsp;replacement)</PRE>
<DL>
<DD>Replace one subexpression by a replacement subexpression
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#replaceSubExpression(net.sf.saxon.expr.Expression, net.sf.saxon.expr.Expression)">replaceSubExpression</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>original</CODE> - the original subexpression<DD><CODE>replacement</CODE> - the replacement subexpression
<DT><B>Returns:</B><DD>true if the original subexpression is found</DL>
</DD>
</DL>
<HR>

<A NAME="promoteInst(net.sf.saxon.expr.PromotionOffer)"><!-- --></A><H3>
promoteInst</H3>
<PRE>
protected void <B>promoteInst</B>(<A HREF="../../../../../net/sf/saxon/expr/PromotionOffer.html" title="class in net.sf.saxon.expr">PromotionOffer</A>&nbsp;offer)
                    throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Handle promotion offers, that is, non-local tree rewrites.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#promoteInst(net.sf.saxon.expr.PromotionOffer)">promoteInst</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offer</CODE> - The type of rewrite being offered
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkPermittedContents(net.sf.saxon.type.SchemaType, net.sf.saxon.expr.StaticContext, boolean)"><!-- --></A><H3>
checkPermittedContents</H3>
<PRE>
public void <B>checkPermittedContents</B>(<A HREF="../../../../../net/sf/saxon/type/SchemaType.html" title="interface in net.sf.saxon.type">SchemaType</A>&nbsp;parentType,
                                   <A HREF="../../../../../net/sf/saxon/expr/StaticContext.html" title="interface in net.sf.saxon.expr">StaticContext</A>&nbsp;env,
                                   boolean&nbsp;whole)
                            throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Check that any elements and attributes constructed or returned by this expression are acceptable
 in the content model of a given complex type. It's always OK to say yes, since the check will be
 repeated at run-time. The process of checking element and attribute constructors against the content
 model of a complex type also registers the type of content expected of those constructors, so the
 static validation can continue recursively.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#checkPermittedContents(net.sf.saxon.type.SchemaType, net.sf.saxon.expr.StaticContext, boolean)">checkPermittedContents</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parentType</CODE> - the "given complex type": the method is checking that the nodes returned by this
 expression are acceptable members of the content model of this type<DD><CODE>env</CODE> - the static context<DD><CODE>whole</CODE> - if true, we want to check that the value of this expression satisfies the content model
 as a whole; if false we want to check that the value of the expression is acceptable as one part
 of the content
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if the value delivered by this expression cannot be part of the content model
 of the given type</DL>
</DD>
</DL>
<HR>

<A NAME="addToPathMap(net.sf.saxon.expr.PathMap, net.sf.saxon.expr.PathMap.PathMapNodeSet)"><!-- --></A><H3>
addToPathMap</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/PathMap.PathMapNodeSet.html" title="class in net.sf.saxon.expr">PathMap.PathMapNodeSet</A> <B>addToPathMap</B>(<A HREF="../../../../../net/sf/saxon/expr/PathMap.html" title="class in net.sf.saxon.expr">PathMap</A>&nbsp;pathMap,
                                           <A HREF="../../../../../net/sf/saxon/expr/PathMap.PathMapNodeSet.html" title="class in net.sf.saxon.expr">PathMap.PathMapNodeSet</A>&nbsp;pathMapNodeSet)</PRE>
<DL>
<DD>Add a representation of this expression to a PathMap. The PathMap captures a map of the nodes visited
 by an expression in a source tree.
 <p/>
 <p>The default implementation of this method assumes that an expression does no navigation other than
 the navigation done by evaluating its subexpressions, and that the subexpressions are evaluated in the
 same context as the containing expression. The method must be overridden for any expression
 where these assumptions do not hold. For example, implementations exist for AxisExpression, ParentExpression,
 and RootExpression (because they perform navigation), and for the doc(), document(), and collection()
 functions because they create a new navigation root. Implementations also exist for PathExpression and
 FilterExpression because they have subexpressions that are evaluated in a different context from the
 calling expression.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#addToPathMap(net.sf.saxon.expr.PathMap, net.sf.saxon.expr.PathMap.PathMapNodeSet)">addToPathMap</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pathMap</CODE> - the PathMap to which the expression should be added<DD><CODE>pathMapNodeSet</CODE> - the set of PathMap nodes to which the paths from this expression should be appended
<DT><B>Returns:</B><DD>the pathMapNode representing the focus established by this expression, in the case where this
         expression is the first operand of a path expression or filter expression. For an expression that does
         navigation, it represents the end of the arc in the path map that describes the navigation route. For other
         expressions, it is the same as the input pathMapNode.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public <A HREF="http://download.oracle.com/javase/6/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</A> <B>toString</B>()</PRE>
<DL>
<DD>The toString() method for an expression attempts to give a representation of the expression
 in an XPath-like form, but there is no guarantee that the syntax will actually be true XPath.
 In the case of XSLT instructions, the toString() method gives an abstracted view of the syntax
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#toString()">toString</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a representation of the expression as a string</DL>
</DD>
</DL>
<HR>

<A NAME="explain(net.sf.saxon.trace.ExpressionPresenter)"><!-- --></A><H3>
explain</H3>
<PRE>
public void <B>explain</B>(<A HREF="../../../../../net/sf/saxon/trace/ExpressionPresenter.html" title="class in net.sf.saxon.trace">ExpressionPresenter</A>&nbsp;out)</PRE>
<DL>
<DD>Diagnostic print of expression structure. The abstract expression tree
 is written to the supplied output destination.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#explain(net.sf.saxon.trace.ExpressionPresenter)">explain</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>out</CODE> - the expression presenter used to display the structure</DL>
</DD>
</DL>
<HR>

<A NAME="processLeavingTail(net.sf.saxon.expr.XPathContext)"><!-- --></A><H3>
processLeavingTail</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/expr/instruct/TailCall.html" title="interface in net.sf.saxon.expr.instruct">TailCall</A> <B>processLeavingTail</B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)
                            throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Process this instruction, that is, choose an xsl:when or xsl:otherwise child
 and process it.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/TailCallReturner.html#processLeavingTail(net.sf.saxon.expr.XPathContext)">processLeavingTail</A></CODE> in interface <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/TailCallReturner.html" title="interface in net.sf.saxon.expr.instruct">TailCallReturner</A></CODE><DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#processLeavingTail(net.sf.saxon.expr.XPathContext)">processLeavingTail</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the dynamic context of this transformation
<DT><B>Returns:</B><DD>a TailCall, if the chosen branch ends with a call of call-template or
 apply-templates. It is the caller's responsibility to execute such a TailCall.
 If there is no TailCall, returns null.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any non-recoverable dynamic error occurs</DL>
</DD>
</DL>
<HR>

<A NAME="evaluateItem(net.sf.saxon.expr.XPathContext)"><!-- --></A><H3>
evaluateItem</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/om/Item.html" title="interface in net.sf.saxon.om">Item</A> <B>evaluateItem</B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)
                  throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Evaluate an expression as a single item. This always returns either a single Item or
 null (denoting the empty sequence). No conversion is done. This method should not be
 used unless the static type of the expression is a subtype of "item" or "item?": that is,
 it should not be called if the expression may return a sequence. There is no guarantee that
 this condition will be detected.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/EvaluableItem.html#evaluateItem(net.sf.saxon.expr.XPathContext)">evaluateItem</A></CODE> in interface <CODE><A HREF="../../../../../net/sf/saxon/expr/EvaluableItem.html" title="interface in net.sf.saxon.expr">EvaluableItem</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#evaluateItem(net.sf.saxon.expr.XPathContext)">evaluateItem</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - The context in which the expression is to be evaluated
<DT><B>Returns:</B><DD>the node or atomic value that results from evaluating the
     expression; or null to indicate that the result is an empty
     sequence
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any dynamic error occurs evaluating the
     expression</DL>
</DD>
</DL>
<HR>

<A NAME="iterate(net.sf.saxon.expr.XPathContext)"><!-- --></A><H3>
iterate</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/om/SequenceIterator.html" title="interface in net.sf.saxon.om">SequenceIterator</A> <B>iterate</B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)
                         throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Return an Iterator to iterate over the values of a sequence. The value of every
 expression can be regarded as a sequence, so this method is supported for all
 expressions. This default implementation relies on the process() method: it
 "pushes" the results of the instruction to a sequence in memory, and then
 iterates over this in-memory sequence.

 In principle instructions should implement a pipelined iterate() method that
 avoids the overhead of intermediate storage.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/SequenceIterable.html#iterate(net.sf.saxon.expr.XPathContext)">iterate</A></CODE> in interface <CODE><A HREF="../../../../../net/sf/saxon/expr/SequenceIterable.html" title="interface in net.sf.saxon.expr">SequenceIterable</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html#iterate(net.sf.saxon.expr.XPathContext)">iterate</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/instruct/Instruction.html" title="class in net.sf.saxon.expr.instruct">Instruction</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - supplies the context for evaluation
<DT><B>Returns:</B><DD>a SequenceIterator that can be used to iterate over the result
     of the expression
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if any dynamic error occurs evaluating the
     expression</DL>
</DD>
</DL>
<HR>

<A NAME="iterateEvents(net.sf.saxon.expr.XPathContext)"><!-- --></A><H3>
iterateEvents</H3>
<PRE>
public <A HREF="../../../../../net/sf/saxon/evpull/EventIterator.html" title="interface in net.sf.saxon.evpull">EventIterator</A> <B>iterateEvents</B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context)
                            throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Deliver the result of the expression as a sequence of events.
 <p/>
 <p>The events (of class <A HREF="../../../../../net/sf/saxon/evpull/PullEvent.html" title="interface in net.sf.saxon.evpull"><CODE>PullEvent</CODE></A>) are either complete
 items, or one of startElement, endElement, startDocument, or endDocument, known
 as semi-nodes. The stream of events may also include a nested EventIterator.
 If a start-end pair exists in the sequence, then the events between
 this pair represent the content of the document or element. The content sequence will
 have been processed to the extent that any attribute and namespace nodes in the
 content sequence will have been merged into the startElement event. Namespace fixup
 will have been performed: that is, unique prefixes will have been allocated to element
 and attribute nodes, and all namespaces will be declared by means of a namespace node
 in the startElement event or in an outer startElement forming part of the sequence.
 However, duplicate namespaces may appear in the sequence.</p>
 <p>The content of an element or document may include adjacent or zero-length text nodes,
 atomic values, and nodes represented as nodes rather than broken down into events.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#iterateEvents(net.sf.saxon.expr.XPathContext)">iterateEvents</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - The dynamic evaluation context
<DT><B>Returns:</B><DD>the result of the expression as an iterator over a sequence of PullEvent objects
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE> - if a dynamic error occurs during expression evaluation</DL>
</DD>
</DL>
<HR>

<A NAME="evaluatePendingUpdates(net.sf.saxon.expr.XPathContext, net.sf.saxon.expr.PendingUpdateList)"><!-- --></A><H3>
evaluatePendingUpdates</H3>
<PRE>
public void <B>evaluatePendingUpdates</B>(<A HREF="../../../../../net/sf/saxon/expr/XPathContext.html" title="interface in net.sf.saxon.expr">XPathContext</A>&nbsp;context,
                                   <A HREF="../../../../../net/sf/saxon/expr/PendingUpdateList.html" title="interface in net.sf.saxon.expr">PendingUpdateList</A>&nbsp;pul)
                            throws <A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></PRE>
<DL>
<DD>Evaluate an updating expression, adding the results to a Pending Update List.
 The default implementation of this method, which is used for non-updating expressions,
 throws an UnsupportedOperationException
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html#evaluatePendingUpdates(net.sf.saxon.expr.XPathContext, net.sf.saxon.expr.PendingUpdateList)">evaluatePendingUpdates</A></CODE> in class <CODE><A HREF="../../../../../net/sf/saxon/expr/Expression.html" title="class in net.sf.saxon.expr">Expression</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>context</CODE> - the XPath dynamic evaluation context<DD><CODE>pul</CODE> - the pending update list to which the results should be written
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../net/sf/saxon/trans/XPathException.html" title="class in net.sf.saxon.trans">XPathException</A></CODE></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../net/sf/saxon/expr/instruct/CallTemplate.CallTemplatePackage.html" title="class in net.sf.saxon.expr.instruct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../net/sf/saxon/expr/instruct/Comment.html" title="class in net.sf.saxon.expr.instruct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/sf/saxon/expr/instruct/Choose.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Choose.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_net.sf.saxon.expr.Expression">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
Copyright (c) 2004-2010 Saxonica Limited. All rights reserved.
</BODY>
</HTML>
