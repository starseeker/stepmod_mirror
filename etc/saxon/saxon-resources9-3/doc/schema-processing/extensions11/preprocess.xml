<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="schema-processing" page="extensions11" subpage="preprocess"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: The saxon:preprocess facet</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: The saxon:preprocess facet"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>The saxon:preprocess facet</h1>
      <p>Saxon provides the <code>saxon:preprocess</code> facet as an addition to the standard facets defined in the
XSD 1.1 specification. It is available only when XSD 1.1 support is enabled.</p>
      <p>Like <code>xs:whiteSpace</code>, this is a pre-lexical facet. It is used to transform the supplied lexical value
of an element or attribute from the form as written (but after whitespace normalization) to the lexical space of the
base type. Constraining facets such as <code>pattern</code>, <code>enumeration</code>, and <code>minLength</code> apply
to the value after the <code>saxon:preprocess</code> facet has done its work. In addition, if the primitive type is say
<code>xs:date</code> or <code>xs:decimal</code>, the built-in lexical rules for parsing a date or a decimal number are
applied only after <code>saxon:preprocess</code> has transformed the value. The makes it possible, for example, to
accept <code>yes</code> and <code>no</code> as values of an <code>xs:boolean</code>, <code>3,14159</code> as the value of
an <code>xs:decimal</code>, or <code>13DEC1987</code> as the value of an <code>xs:date</code>.</p>
      <p>Like other facets, <code>saxon:preprocess</code> may be used as a child of <code>xs:restriction</code> when restricting
a simple type, or a complex type with simple content.</p>
      <p>The attributes are:</p>
      <table>
         <tr>
            <td content="para">
               <p>
                  <b>Attribute</b>
               </p>
            </td>
            <td content="para">
               <p>
                  <b>Usage</b>
               </p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>id</p>
            </td>
            <td content="para">
               <p>Standard attribute</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>action</p>
            </td>
            <td content="para">
               <p>Mandatory. An XPath expression. The rules for writing the XPath expression are generally the same as the rules
for the <code>test</code> expression of <code>xs:assert</code>. The value to be transformed is supplied (as a string) as the
value of the variable <code>$value</code>; the context item is undefined. The expression must return a single string.
If evaluation of the expression fails with a dynamic error, this is interpreted as a validation failure.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>reverse</p>
            </td>
            <td content="para">
               <p>Optional. An XPath expression used to reverse the transformation. Used (in XPath, XSLT, and XQuery) 
when a value of this type is converted to a string. When a value of this type is converted to a string,
it is first converted according to the rules of the base type. The resulting string is then passed,
as the value of variable <code>$value</code>, to the XPath expression, and the result of the XPath expression
is used as the final output. This attribute does not affect the schema validation process itself.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>xpathDefaultNamespace</p>
            </td>
            <td content="para">
               <p>The default namespace for element names (unlikely to appear in practice) and types.</p>
            </td>
         </tr>
      </table>
      <p>The following example converts a string to upper-case before testing it against the enumeration facet.</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xs:simpleType name="currency"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;saxon:preprocess action="upper-case($value)" xmlns:saxon="http://saxon.sf.net/"/&gt;
    &lt;xs:enumeration value="USD"/&gt;
    &lt;xs:enumeration value="EUR"/&gt;
    &lt;xs:enumeration value="GBP"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code>
         </pre>
      </div>
      <p>Of course, it is not only the constraining facets that will see the preprocessed value (in this case, the upper-case
value), any XPath operation that makes use of the typed value of an element or attribute node will also see the value
after preprocessing. However, the string value of the node is unchanged.</p>
      <p>The following example converts any commas appearing in the input to full stops, allowing decimal numbers to be
represented in Continental European style as <code>3,15</code>. On output, the process is reversed, so
that full stops are replaced by commas.</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xs:simpleType name="euroDecimal"&gt;
  &lt;xs:restriction base="xs:decimal"&gt;
    &lt;saxon:preprocess action="translate($value, ',', '.')" 
                      reverse="translate($value, '.', ',')"
                      xmlns:saxon="http://saxon.sf.net/"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code>
         </pre>
      </div>
      <p>Note that in this example, the user-defined type also accepts numbers written in the "standard" style <code>3.15</code>.</p>
      <p>The following example allows an <code>xs:time</code> value to be written with the seconds part omitted.
Again, it also accepts the standard <code>hh:mm:ss</code> notation:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xs:simpleType name="hoursAndMinutes"&gt;
  &lt;xs:restriction base="xs:time"&gt;
    &lt;saxon:preprocess action="concat($value, ':00'[string-length($value) = 5])" 
                      xmlns:saxon="http://saxon.sf.net/"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code>
         </pre>
      </div>
      <p>The following example uses extension function calls within the XPath expression to support integers
written in hexadecimal notation:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xs:simpleType name="hexInteger"&gt;
  &lt;xs:restriction base="xs:long"&gt;
    &lt;saxon:preprocess action="Long:parseLong($value, 16)" reverse="Long:toHexString(xs:long($value))"
      xmlns:Long="java:java.lang.Long"
      xmlns:saxon="http://saxon.sf.net/"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;</code>
         </pre>
      </div>
      <p>Given the input <code>&lt;val&gt;0040&lt;/val&gt;</code>, validated against this schema, the query
 <code>(val*3) cast as hexInteger</code> will produce the output <code>c0</code>.</p>
      <p><i>The preprocess facet is not currently implemented for list or union types.</i></p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="extended-uniqueness-constraints.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>