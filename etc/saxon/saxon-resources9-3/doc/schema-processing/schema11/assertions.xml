<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="schema-processing" page="schema11" subpage="assertions"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: Assertions on Complex Types</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: Assertions on Complex Types"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>Assertions on Complex Types</h1>
      <p>Saxon 9.2 supports the definition of assertions on both simple and complex types.</p>
      <p>Assertions enable cross-validation of different elements or attributes within a complex type. For example,
specifying:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>
&lt;xs:assert test="xs:date(@date-of-birth) lt xs:date(@date-of-death)"/&gt;
</code>
         </pre>
      </div>
      <p>will cause a run-time validation error if an instance document is validated in which the relevant condition
does not hold.</p>
      <p>Saxon allows any XPath 2.0 expression to be used in the <code>test</code> attribute. This includes
expressions call Java or .NET extension functions.</p>
      <p>For assertions on complex types, the context node supplied to the
expression is the element being validated, in its untyped state (this is a divergence from the specification). 
The static context for the expression comes from the
containing schema document: any namespace prefixes used in the expression must be declared using namespace declarations
in the schema in the usual way. The default namespace for elements and types may be set using the <code>xpathDefaultNamespace</code>
attribute either on the element containing the XPath expression, or on the <code>xs:schema</code> element).
It is not possible to use any variables or user-defined functions within the expression. </p>
      <p>Saxon recognizes an assertion of the form <code>empty(expr)</code> specially. For example, if you are validating
an XSLT stylesheet, you might write on the top-level complex type <code>&lt;xs:assert test="empty(if (@version='1.0')
then xsl:variable[@as] else ())"/&gt;</code>. If you use this form of assertion, the validator will not only report that the
assertion is false for the top-level element, it will also report the location of all the <code>xsl:variable</code> elements
that caused the assertion to be false. This also works for <code>not(expr)</code> provided that <code>expr</code> has a static
item type of <code>node()</code>.</p>
      <p>The XPath expression is evaluated against a temporary document
that contains the subtree rooted at this element: more specifically, the subtree contains a document node with this element
as its only child. Validation succeeds if the effective boolean value (EBV) of the expression is true, and fails if the
EBV is false or if an error occurs during the evaluation.</p>
      <p>If a complex type is derived by extension or by restriction, then the assertions supplied on the base type must be satisfied
as well as those supplied on the type itself.</p>
      <p>Note that when assertions are defined on a complex type, the subtree representing an element with that type will be
built in memory. It is therefore advisable to exercise care when applying this facility to elements that have very large
subtrees.</p>
      <p>For assertions on simple types, <code>&lt;xs:assert&gt;</code> is treated as a facet. It may be applied to any variety of
type, that is to a type derived by restriction from an atomic type, a list type, or a union type. The value against which the assertion is being
tested is available to the expression as the value of variable <code>$value</code>; this will be typed as an instance of the
base type (the type being restricted). There is no context node. The variable <code>$value</code> is also available in the same
way for complex types with simple content.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="simpleassert.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>