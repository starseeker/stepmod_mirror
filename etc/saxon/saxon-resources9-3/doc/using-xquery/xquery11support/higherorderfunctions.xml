<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="using-xquery" page="xquery11support" subpage="higherorderfunctions"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: Higher Order Functions</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: Higher Order Functions"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>Higher Order Functions</h1>
      <p>Saxon-EE implements the new facilities for higher-order functions in XQuery.</p>
      <ul>
         <li content="para">
            <p>An XPath item may be a <i>function item</i>, that is, a dynamic reference to a function. Function items can be
manipulated in the same way as any other item, for example they can be held in variables, passed as parameters, returned as a function result,
or arranged in sequences of items. In Saxon function items are currently represented as primitive atomic values,
unlike the Working Draft which represents them as a third kind of item alongside atomic values and nodes.</p>
         </li>
         <li content="para">
            <p>An expression such as <code>fn:contains#2</code> returns a function item bound to the 2-argument version
of the <code>fn:contains</code> function. Saxon previously allowed this using the syntax <code>saxon:function('fn:contains', 2)</code>.
Such an expression will often appear as an argument to a higher order function that expects a function item
as one of its arguments.</p>
         </li>
         <li content="para">
            <p>If the value of a variable <code>$f</code> is a function item, the function can be invoked using the
syntax <code>$f(x, y, z)</code>. Here <code>$f</code> can be any primary expression or filter expression so long as its
value is a single function item. Saxon previously allowed this using the syntax <code>saxon:call($f, x, y, z)</code>.</p>
         </li>
         <li content="para">
            <p>The type of a variable or function parameter can be declared as <code>function()</code> to indicate that
the expected value is a function item. It is also possible to declare the full signature, for example 
<code>function(xs:int, node()*)</code> as xs:string?.</p>
         </li>
         <li content="para">
            <p>Inline (anonymous) functions can be written, for example <code>function ($x as xs:integer) as xs:boolean {$x mod 2 eq 0}</code>.
Such a function will typically be used as an argument in a function call expecting a parameter of type <code>function()</code>.</p>
         </li>
         <li content="para">
            <p>The functions <code>fn:function-name()</code>, <code>fn:function-arity()</code>, and <code>fn:partial-apply()</code> are implemented.</p>
         </li>
      </ul>
      <p>Saxon applies function coercion when a function is passed to another function, or when it is returned as a function result.
However it also implements a proposed change to the specification whereby function coercion is not used for operations such as "instance of".
These follow stricter type checking rules: a function <code>F(A,B)-&gt;T</code> is an instance of a type <code>F(X,Y)-&gt;U</code> if every T is
an instance of U, every X is an instance of A, and every Y is an instance of B.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="miscellaneous.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>