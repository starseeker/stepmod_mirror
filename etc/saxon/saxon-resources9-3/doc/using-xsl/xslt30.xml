<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="using-xsl" page="xslt30" subpage=""/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: XSLT 3.0 Support</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: XSLT 3.0 Support"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>XSLT 3.0 Support</h1>
      <p>Saxon 9.3 introduces support for a number of features defined in the draft XSLT 3.0 specification (previously known as XSLT 2.1). It must be
noted that this is an early working draft, and everything is subject to change. If the W3C specification changes, Saxon
will change to match, without regards to backwards compatibility. Use it at your own risk.</p>
      <p>All these features require at least Saxon-PE. Streaming requires Saxon-EE.</p>
      <p>XSLT 3.0 support must be explicitly enabled, for example by specifying <code>version="3.0"</code> in the stylesheet
or by using the option <code>-xsltversion:3.0</code> on the command line. It can also be enabled from the configuration file
or using methods in the API (for example, on the s9api <code>XsltCompiler</code> object).</p>
      <p>The following features are implemented. For full details, see the W3C specifications.</p>
      <p class="subhead">xsl:evaluate</p>
      <p>This is a new instruction providing a standard way to perform dynamic evaluation of XPath expressions.
This effectively replaces the need for extensions such as <code>saxon:evaluate</code>, though that is likely to be retained
for a long time as it is so widely used.
This instruction is fully implemented, except that the precise rules for which functions can be called within the
dynamic XPath expression may not be 100% aligned with the specification.</p>
      <p class="subhead">xsl:try and xsl:catch</p>
      <p>The <code>xsl:try</code> and <code>xsl:catch</code> instructions provide a way for dynamic errors to be intercepted.
This applies both to system-defined errors and to errors thrown explicitly using the <code>error()</code> function or
by calling <code>xsl:message terminate="yes"</code> (which becomes something of a misnomer). The syntax allows catching
of specific error codes. The Saxon implementation is complete, though there may be edge cases where the semantics are
not precisely as defined in the specification; there may also be error conditions where Saxon is not using the most appropriate error
code according to the specification.</p>
      <p class="subhead">xsl:iterate</p>
      <p>The <code>xsl:iterate</code> instruction provides an alternative way of iterating over a sequence. Unlike <code>xsl:for-each</code>,
it is explicitly sequential, processing one item at a time in order, which means it is possible to break out of the loop at any
time using <code>xsl:break</code>. It is also possible to pass data from one iteration to the next using parameters, allowing the
kind of processing that previously required recursion. The Saxon implementation is functionally complete.</p>
      <p class="subhead">xsl:mode</p>
      <p>The <code>xsl:mode</code> declaration allows attributes of a mode to be declared. Most notably, the mode can be declared
to be streamable, in which case all the template rules for that mode must satisfy the rules for streamability. This allows large
source documents to be processed without building an entire tree in memory. (Streaming is available only in Saxon-EE, and is further
described at <a class="bodylink" href="../sourcedocs/streaming.xml">Streamed processing of large documents</a>.)</p>
      <p>The following attributes are implemented:</p>
      <ul>
         <li content="para">
            <p>
            <code>name</code> (optional). The name of a mode; absence indicates the unnamed mode.</p>
         </li>
         <li content="para">
            <p>
            <code>streamable = yes|no</code>. This indicates whether the mode allows documents to be processed using streaming.</p>
         </li>
         <li content="para">
            <p>
            <code>on-no-match = stringify|copy|discard|fail</code>. This allows the stylesheet to
specify how nodes are to be processed in the absence of a matching template rule.</p>
         </li>
         <li content="para">
            <p>
            <code>on-multiple-match = fail | use-last</code>. Indicates what happens when more than one template rules
with the same import precedence and priority matches a node.</p>
         </li>
         <li content="para">
            <p>
            <code>warning-on-no-match = yes|no</code>. Indicates whether warnings are output when there is no user-defined template
rule matching a node.</p>
         </li>
         <li content="para">
            <p>
            <code>warning-on-multiple-match = yes|no</code>. Indicates whether warnings are output when there is no user-defined template
rule matching a node.</p>
         </li>
      </ul>
      <p>The attribute <code>initial=yes|no</code> is not yet implemented. The rules for handling multiple <code>xsl:mode</code>
declarations for the same mode (taking account of import precedence) are not yet implemented. The <code>xsl:context-item</code>
element is not yet implemented.</p>
      <p>As well as the <code>streamable</code> attribute of <code>xsl:mode</code>, the <code>on-no-match</code> attribute is implemented,
with values <code>copy</code>, <code>discard</code>, <code>stringify</code>, or <code>fail</code>. This allows the stylesheet to
specify how nodes are to be processed in the absence of a matching template rule.</p>
      <p class="subhead">XSLT 3.0 functions</p>
      <p>The <code>unparsed-text-lines()</code> function is implemented.</p>
      <p>The functions <code>copy-of()</code> and <code>snapshot()</code> are implemented.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"/>
            </td>
         </tr>
      </table>
   </body>
</html>