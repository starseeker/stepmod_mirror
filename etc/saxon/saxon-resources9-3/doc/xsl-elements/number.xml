<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="xsl-elements" page="number" subpage=""/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: xsl:number</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: xsl:number"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>xsl:number</h1>
      <p>The <code>xsl:number</code> element outputs the sequential number of a node in the source document.</p>
      <p>If the <code>select</code> attribute is present, this is an expression that selects the node to be
numbered. The default is <code>.</code>, the context node.</p>
      <p>The instruction takes an attribute <code>count</code> whose value is a pattern indicating which nodes to count;
 the default is to match all nodes of the same type and name as the current node.</p>
      <p>The <code>level</code> attribute may take three values: "single", "any", or "multiple".
  The default is "single". This defines the rules for calculating a number.</p>
      <p>There is also an optional <code>from</code> attribute, which is also a pattern. 
  The exact meaning of this depends on the level.</p>
      <p>The calculation is as follows:</p>
      <table>
         <tr>
            <td content="para">
               <p>level=single</p>
            </td>
            <td content="para">
               <p>If the current node matches the pattern, the counted node is the current node. Otherwise the
 counted node is the innermost ancestor of the current node that matches the pattern. If no ancestor
 matches the pattern, the result is zero. If the from attribute is present, the counted node must be
 a descendant of a node that matches the "from" pattern.The result is one plus the number of elder siblings of the counted node that match the count pattern.
 </p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>level=any</p>
            </td>
            <td content="para">
               <p>
 The result is the number of nodes in the document that match the count pattern, that are at or before
 the current node in document order, and that follow in document order the most recent node that matches the "from"
 pattern, if any. Typically this is used
 to number, say, the diagrams or equations in a document, or in some section or chapter of a document, regardless
 of where the diagrams or equations appear in the hierarchic structure.
 </p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>level=multiple</p>
            </td>
            <td content="para">
               <p>
 The result of this is not a single number, but a list of numbers. There is one number in the list for each
 ancestor of the current element that matches the count pattern and that is a descendant of the anchor element.
 Each number is one plus the number of elder siblings of the relevant element that match the count pattern. The
 order of the numbers is "outwards-in".</p>
            </td>
         </tr>
      </table>
      <p>There is an optional <code>format</code> attribute which controls the output format. This contains an alternating
sequence of format-tokens and punctuation-tokens. A format-token is any sequence of alphanumeric characters,
a punctuation-token is any other sequence. The following
values (among others) are supported for the format-token:</p>
      <table>
         <tr>
            <td content="para">
               <p>1</p>
            </td>
            <td content="para">
               <p>Sequence 1, 2, 3, ... 10, 11, 12, ...</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>001</p>
            </td>
            <td content="para">
               <p>Sequence 001, 002, 003, ... 010, 011, 012, ... (any number of
leading zeroes)</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>a</p>
            </td>
            <td content="para">
               <p>Sequence a, b, c, ... aa, ab, ac, ...</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>A</p>
            </td>
            <td content="para">
               <p>Sequence A, B, C, ... AA, AB, AC, ...</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>i</p>
            </td>
            <td content="para">
               <p>Sequence i, ii, iii, iv, ... x, xi, xii, ...</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>I</p>
            </td>
            <td content="para">
               <p>Sequence I, II, III, IV, ... X, XI, XII, ...</p>
            </td>
         </tr>
      </table>
      <p>There is also support for various Japanese sequences (Hiragana, Katakana, and Kanji) using
the format tokens &amp;#x3042, &amp;#x30a2, &amp;#x3044, &amp;#x30a4, &amp;#x4e00, and
for Greek and Hebrew sequences.</p>
      <p>The format token "w" gives the sequence "one", "two", "three", ... , while "W" gives
the same in upper-case, and "Ww" in title case. The language is determined by the <code>lang</code>
attribute, for example <code>lang="en"</code> for English. Saxon currently supports Belgian French (fr-BE), 
Danish (da), Dutch (nl), English (en), Flemish (nl-BE), French (fr), German (de), Italian (it), Swedish (sw).
Additional languages can be achieved by writing a <code>Numberer</code> class, as described in
<a class="bodylink" href="../extensibility/localizing.xml">Localizing numbers and dates</a>.</p>
      <p>The default format is "1".</p>
      <p>A sequence of Unicode digits other than ASCII
digits (for exaple, Tibetan digits) can be used, and will result in decimal numbering using those
digits.</p>
      <p>Similarly, any other character classified as a letter can be used, and will result in "numbering" using
all consecutive Unicode letters following the one provided. For example, specifying "x" will give the
sequence x, y, z, xx, xy, xz, yx, yy, yz, etc. Specifying the Greek letter alpha (&amp;#178;) will
 cause "numbering" using the Greek letters up to "Greek letter omega with tonos" (&amp;#206;).
 Only "i" and "I" (for roman numbering), and the Japanese characters listed above, are exceptions to this rule.</p>
      <p>Successive format-tokens in the format are used to process successive numbers in the list.
If there are more format-tokens in the format than numbers in the list,
the excess format-tokens and punctuation-tokens are ignored. If there are fewer format-tokens
in the format than numbers in the list, the last format-token and the punctuation-token that
 precedes it are used to format all excess numbers, with the final punctuation-token being used
  only at the end.</p>
      <p>Examples:</p>
      <table>
         <thead>
            <tr>
               <td content="para">
                  <p>Number(s)</p>
               </td>
               <td content="para">
                  <p>Format</p>
               </td>
               <td content="para">
                  <p>Result</p>
               </td>
            </tr>
         </thead>
         <tr>
            <td content="para">
               <p>3</p>
            </td>
            <td content="para">
               <p>(1)</p>
            </td>
            <td content="para">
               <p>(3)</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>12</p>
            </td>
            <td content="para">
               <p>I</p>
            </td>
            <td content="para">
               <p>XII</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>2,3</p>
            </td>
            <td content="para">
               <p>1.1</p>
            </td>
            <td content="para">
               <p>2.3</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>2,3</p>
            </td>
            <td content="para">
               <p>1(i)</p>
            </td>
            <td content="para">
               <p>2(iii)</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>2,3</p>
            </td>
            <td content="para">
               <p>1.</p>
            </td>
            <td content="para">
               <p>2.3.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>2,3</p>
            </td>
            <td content="para">
               <p>A.1.1</p>
            </td>
            <td content="para">
               <p>B.3.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>2,3,4,5</p>
            </td>
            <td content="para">
               <p>1.1</p>
            </td>
            <td content="para">
               <p>2.3.4.5</p>
            </td>
         </tr>
      </table>
      <p>This character may be preceded or followed by arbitrary punctuation (anything other than
these characters or XML special characters such as "&lt;") which is copied to the output verbatim.
For example, the value 3 with format "(a)" produces output "(c)".</p>
      <p>It is also possible to use <code>xsl:number</code> to format a number obtained from an expression. This is achieved
using the value attribute of the <code>xsl:number</code> element. If this attribute is present, the count, level, and from
attributes are ignored.</p>
      <p>With large numbers, the digits may be split into groups. For example, specify grouping-size="3" and
grouping-separator="/" to have the number 3000000 displayed as "3/000/000".</p>
      <p>Negative numbers are always output in conventional decimal notation,
 regardless of the format specified.</p>
      <p>Example: This example outputs the title child of an H2 element preceded by a composite number
 formed from the sequential number of the containing H1 element and the number of the containing H2 element.</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>&lt;xsl:template match="H2/TITLE"&gt;
        &lt;xsl:number count="H1"&gt;.&lt;xsl:number count="H2"&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</code>
         </pre>
      </div>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="otherwise.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>