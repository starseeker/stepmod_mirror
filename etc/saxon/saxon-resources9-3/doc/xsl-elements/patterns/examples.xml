<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="xsl-elements" page="patterns" subpage="examples"/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: Examples of Patterns</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title"
            content="Saxonica: XSLT and XQuery Processing: Examples of Patterns"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>Examples of Patterns</h1>
      <p>The table below gives some examples of patterns, and explains their meaning:</p>
      <table>
         <tr>
            <td content="para">
               <p>
                  <b>Pattern</b>
               </p>
            </td>
            <td content="para">
               <p>
                  <b>Meaning</b>
               </p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>PARA</p>
            </td>
            <td content="para">
               <p>Matches any element whose name (tag) is PARA</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>
                  <b>*</b>
               </p>
            </td>
            <td content="para">
               <p>Matches any element</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>APPENDIX/PARA</p>
            </td>
            <td content="para">
               <p>Matches any PARA element 
    whose parent is an APPENDIX</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>APPENDIX//PARA</p>
            </td>
            <td content="para">
               <p>Matches any PARA element that has an ancestor named APPENDIX</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>/*/SECTION</p>
            </td>
            <td content="para">
               <p>Matches any SECTION element that is an immediate child
    of the outermost element in the document</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>*[@NAME]</p>
            </td>
            <td content="para">
               <p>Matches any element with a NAME attribute</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>SECTION/PARA[1]</p>
            </td>
            <td content="para">
               <p>Matches any PARA element that is the first PARA child of
    a SECTION element</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>SECTION[TITLE="Contents"]</p>
            </td>
            <td content="para">
               <p>Matches any SECTION element whose first TITLE child element
    has the value "Contents"</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>A/TITLE | B/TITLE | C/TITLE</p>
            </td>
            <td content="para">
               <p>Matches any TITLE element whose parent is of type A or B or C
    (Note that this cannot be written "(A|B|C)/TITLE", although that is a valid XPath 2.0 path expression.)</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>/BOOK//*</p>
            </td>
            <td content="para">
               <p>Matches any element in a document provided the top-level element in
    the document is named "BOOK"</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>A/text() </p>
            </td>
            <td content="para">
               <p>Matches the character content of an A element</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>A/@*</p>
            </td>
            <td content="para">
               <p>Matches any attribute of an A element</p>
            </td>
         </tr>
      </table>
      <p>In a schema-aware stylesheet, it can be useful to match elements by their schema-defined
type, rather than by their name. The following table shows some examples of this.</p>
      <table>
         <tr>
            <td content="para">
               <p>
                  <b>Pattern</b>
               </p>
            </td>
            <td content="para">
               <p>
                  <b>Meaning</b>
               </p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>schema-element(CHAPTER)</p>
            </td>
            <td content="para">
               <p>Matches any element that has been validated against the global element
    declaration named CHAPTER. More precisely, it matches an element named CHAPTER that has been
    validated against the type of the global element declaration named CHAPTER, and any element
    in the substitution group of the CHAPTER element.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>element(*, ADDRESS-TYPE)</p>
            </td>
            <td content="para">
               <p>Matches any element that has been validated against the schema-defined
    global type definition ADDRESS-TYPE. The "*" indicates that there are no constraints on the element's name.</p>
            </td>
         </tr>
         <tr>
            <td content="para">
               <p>attribute(*, xs:date)</p>
            </td>
            <td content="para">
               <p>Matches any attribute that has been validated as an instance of xs:date, including
    types derived by restriction from xs:date.</p>
            </td>
         </tr>
      </table>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="syntax.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>