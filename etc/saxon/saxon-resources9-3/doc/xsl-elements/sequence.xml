<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet href="../make-menu.xsl" type="text/xsl"?><html>
   <head>
      <this-is section="xsl-elements" page="sequence" subpage=""/>
      <!--
           Generated at 2010-10-29T18:20:48.427+01:00--><title>Saxonica: XSLT and XQuery Processing: xsl:sequence</title>
      <meta name="coverage" content="Worldwide"/>
      <meta name="copyright" content="Copyright Saxonica Ltd"/>
      <meta name="title" content="Saxonica: XSLT and XQuery Processing: xsl:sequence"/>
      <meta name="robots" content="noindex,nofollow"/>
      <link rel="stylesheet" href="../saxondocs.css" type="text/css"/>
   </head>
   <body class="main">
      <h1>xsl:sequence</h1>
      <p>The <code>xsl:sequence</code> element is used to construct arbitrary sequences.
It may select any sequence of nodes and/or atomic values, and essentially adds these to the result
sequence. The input may be specified either by a <code>select</code> attribute, or by the instructions
contained in the <code>xsl:sequence</code> instruction, or both (the <code>select</code> attribute
is processed first). Nodes and atomic values are included in the result sequence directly. Unlike
<code>xsl:copy-of</code>, no copy is made.</p>
      <p>There are two main usage scenarios. The first is copying atomic values into a tree. For example:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>&lt;e&gt;
    &lt;xsl:sequence select="1 to 5"/&gt;
    &lt;br/&gt;
    &lt;xsl:sequence select="6 to 10"/&gt;    
&lt;/e&gt;</code>
         </pre>
      </div>
      <p>which produces the output <code>&lt;e&gt;1 2 3 4 5&lt;br/&gt;6 7 8 9 10&lt;/e&gt;</code>.</p>
      <p>The second, more important, is constructing a sequence-valued variable. A variable
is sequence-valued if the variable binding element (e.g. <code>xsl:variable</code>
has non-empty content, an <code>as</code> attribute, and no <code>select</code> attribute.
For example:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>&lt;xsl:variable name="seq" as="xs:integer *"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;&gt;
       &lt;xsl:sequence select=". * ."/&gt;
    &lt;/xsl:for-each/&gt;    
&lt;/xsl:variable&gt;</code>
         </pre>
      </div>
      <p>This produces the sequence (1, 4, 9, 16, 25) as the value of the variable.</p>
      <p>The <code>xsl:sequence</code> instruction may be used to produce any sequence of nodes and/or
atomic values.</p>
      <p>If nodes are constructed within a sequence-valued variable, they will be <b>parentless</b>. For
example, the following code creates a variable whose value is a sequence of three parentless 
attributes:</p>
      <div class="codeblock"
           style="border: solid thin; background-color: #B1CCC7; padding: 2px">
         <pre>
            <code>&lt;xsl:variable name="seq" as="attribute() *"&gt;
    &lt;xsl:attribute name="a"&gt;10&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="b"&gt;20&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="a"&gt;30&lt;/xsl:attribute&gt;
&lt;/xsl:variable&gt;</code>
         </pre>
      </div>
      <p>It is quite legitimate to have two attributes in the sequence with the same name; there is
no conflict until an attempt is made to add them both to the same element. The attributes can
be added to an element by using <code>&lt;xsl:copy-of select="$seq"/&gt;</code> within an
<code>xsl:element</code> instruction or within a literal result element. At this stage the usual
rule applies: if there are duplicate attributes, the last one wins.</p>
      <table width="100%">
         <tr>
            <td>
               <p align="right"><a class="nav" href="sort.xml">Next</a></p>
            </td>
         </tr>
      </table>
   </body>
</html>